//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (256)
//--------------------------------------------------------------------------------
pub const MMTIME = extern struct {
    wType: u32,
    u: MMTIME._u_e__Union,
    const _u_e__Union = u32; // TODO: generate this nested type!
};

pub const HDRVR__ = extern struct {
    unused: i32,
};

pub const DRVCALLBACK = fn(
    hdrvr: ?*c_void,
    uMsg: u32,
    dwUser: ?*c_void,
    dw1: ?*c_void,
    dw2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPDRVCALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const PDRVCALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const DRVCONFIGINFOEX = extern struct {
    dwDCISize: u32,
    lpszDCISectionName: [*:0]const u16,
    lpszDCIAliasName: [*:0]const u16,
    dnDevNode: u32,
};

pub const DRVCONFIGINFO = extern struct {
    dwDCISize: u32,
    lpszDCISectionName: [*:0]const u16,
    lpszDCIAliasName: [*:0]const u16,
};

pub const DRIVERPROC = fn(
    param0: ?*c_void,
    param1: ?*c_void,
    param2: u32,
    param3: LPARAM,
    param4: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const DRIVERMSGPROC = fn(
    param0: u32,
    param1: u32,
    param2: ?*c_void,
    param3: ?*c_void,
    param4: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const HMMIO__ = extern struct {
    unused: i32,
};

pub const MMIOPROC = fn(
    lpmmioinfo: PSTR,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const LPMMIOPROC = fn(
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const MMIOINFO = extern struct {
    dwFlags: u32,
    fccIOProc: u32,
    pIOProc: LPMMIOPROC,
    wErrorRet: u32,
    htask: HTASK,
    cchBuffer: i32,
    pchBuffer: *i8,
    pchNext: *i8,
    pchEndRead: *i8,
    pchEndWrite: *i8,
    lBufOffset: i32,
    lDiskOffset: i32,
    adwInfo: [3]u32,
    dwReserved1: u32,
    dwReserved2: u32,
    hmmio: *HMMIO__,
};

pub const MMCKINFO = extern struct {
    ckid: u32,
    cksize: u32,
    fccType: u32,
    dwDataOffset: u32,
    dwFlags: u32,
};

pub const WAVECALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPWAVECALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const WAVEHDR = extern struct {
    lpData: PSTR,
    dwBufferLength: u32,
    dwBytesRecorded: u32,
    dwUser: ?*c_void,
    dwFlags: u32,
    dwLoops: u32,
    lpNext: *WAVEHDR,
    reserved: ?*c_void,
};

pub const WAVEOUTCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const WAVEOUTCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const WAVEOUTCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEOUTCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEINCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
};

pub const WAVEINCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
};

pub const WAVEINCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEINCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwFormats: u32,
    wChannels: u16,
    wReserved1: u16,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const WAVEFORMAT = extern struct {
    wFormatTag: u16,
    nChannels: u16,
    nSamplesPerSec: u32,
    nAvgBytesPerSec: u32,
    nBlockAlign: u16,
};

pub const PCMWAVEFORMAT = extern struct {
    wf: WAVEFORMAT,
    wBitsPerSample: u16,
};

pub const WAVEFORMATEX = extern struct {
    wFormatTag: u16,
    nChannels: u16,
    nSamplesPerSec: u32,
    nAvgBytesPerSec: u32,
    nBlockAlign: u16,
    wBitsPerSample: u16,
    cbSize: u16,
};

pub const MIDICALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPMIDICALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIDIOUTCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
};

pub const MIDIOUTCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
};

pub const MIDIOUTCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIOUTCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wVoices: u16,
    wNotes: u16,
    wChannelMask: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIINCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    dwSupport: u32,
};

pub const MIDIINCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwSupport: u32,
};

pub const MIDIINCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIINCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIDIHDR = extern struct {
    lpData: PSTR,
    dwBufferLength: u32,
    dwBytesRecorded: u32,
    dwUser: ?*c_void,
    dwFlags: u32,
    lpNext: *MIDIHDR,
    reserved: ?*c_void,
    dwOffset: u32,
    dwReserved: [8]?*c_void,
};

pub const MIDIEVENT = extern struct {
    dwDeltaTime: u32,
    dwStreamID: u32,
    dwEvent: u32,
    dwParms: [1]u32,
};

pub const MIDISTRMBUFFVER = extern struct {
    dwVersion: u32,
    dwMid: u32,
    dwOEMVersion: u32,
};

pub const MIDIPROPTIMEDIV = extern struct {
    cbStruct: u32,
    dwTimeDiv: u32,
};

pub const MIDIPROPTEMPO = extern struct {
    cbStruct: u32,
    dwTempo: u32,
};

pub const AUXCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const AUXCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
};

pub const AUXCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const AUXCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    wTechnology: u16,
    wReserved1: u16,
    dwSupport: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIXERCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    fdwSupport: u32,
    cDestinations: u32,
};

pub const MIXERCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    fdwSupport: u32,
    cDestinations: u32,
};

pub const MIXERCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]i8,
    fdwSupport: u32,
    cDestinations: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIXERCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    vDriverVersion: u32,
    szPname: [32]u16,
    fdwSupport: u32,
    cDestinations: u32,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const MIXERLINEA = extern struct {
    cbStruct: u32,
    dwDestination: u32,
    dwSource: u32,
    dwLineID: u32,
    fdwLine: u32,
    dwUser: ?*c_void,
    dwComponentType: u32,
    cChannels: u32,
    cConnections: u32,
    cControls: u32,
    szShortName: [16]i8,
    szName: [64]i8,
    Target: MIXERLINEA._Target_e__Struct,
    const _Target_e__Struct = u32; // TODO: generate this nested type!
};

pub const MIXERLINEW = extern struct {
    cbStruct: u32,
    dwDestination: u32,
    dwSource: u32,
    dwLineID: u32,
    fdwLine: u32,
    dwUser: ?*c_void,
    dwComponentType: u32,
    cChannels: u32,
    cConnections: u32,
    cControls: u32,
    szShortName: [16]u16,
    szName: [64]u16,
    Target: MIXERLINEW._Target_e__Struct,
    const _Target_e__Struct = u32; // TODO: generate this nested type!
};

pub const MIXERCONTROLA = extern struct {
    cbStruct: u32,
    dwControlID: u32,
    dwControlType: u32,
    fdwControl: u32,
    cMultipleItems: u32,
    szShortName: [16]i8,
    szName: [64]i8,
    Bounds: MIXERCONTROLA._Bounds_e__Union,
    Metrics: MIXERCONTROLA._Metrics_e__Union,
    const _Bounds_e__Union = u32; // TODO: generate this nested type!
    const _Metrics_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERCONTROLW = extern struct {
    cbStruct: u32,
    dwControlID: u32,
    dwControlType: u32,
    fdwControl: u32,
    cMultipleItems: u32,
    szShortName: [16]u16,
    szName: [64]u16,
    Bounds: MIXERCONTROLW._Bounds_e__Union,
    Metrics: MIXERCONTROLW._Metrics_e__Union,
    const _Bounds_e__Union = u32; // TODO: generate this nested type!
    const _Metrics_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERLINECONTROLSA = extern struct {
    cbStruct: u32,
    dwLineID: u32,
    Anonymous: MIXERLINECONTROLSA._Anonymous_e__Union,
    cControls: u32,
    cbmxctrl: u32,
    pamxctrl: *MIXERCONTROLA,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERLINECONTROLSW = extern struct {
    cbStruct: u32,
    dwLineID: u32,
    Anonymous: MIXERLINECONTROLSW._Anonymous_e__Union,
    cControls: u32,
    cbmxctrl: u32,
    pamxctrl: *MIXERCONTROLW,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERCONTROLDETAILS = extern struct {
    cbStruct: u32,
    dwControlID: u32,
    cChannels: u32,
    Anonymous: MIXERCONTROLDETAILS._Anonymous_e__Union,
    cbDetails: u32,
    paDetails: *c_void,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MIXERCONTROLDETAILS_LISTTEXTA = extern struct {
    dwParam1: u32,
    dwParam2: u32,
    szName: [64]i8,
};

pub const MIXERCONTROLDETAILS_LISTTEXTW = extern struct {
    dwParam1: u32,
    dwParam2: u32,
    szName: [64]u16,
};

pub const MIXERCONTROLDETAILS_BOOLEAN = extern struct {
    fValue: i32,
};

pub const MIXERCONTROLDETAILS_SIGNED = extern struct {
    lValue: i32,
};

pub const MIXERCONTROLDETAILS_UNSIGNED = extern struct {
    dwValue: u32,
};

pub const TIMECAPS = extern struct {
    wPeriodMin: u32,
    wPeriodMax: u32,
};

pub const JOYCAPSA = extern struct {
    wMid: u16,
    wPid: u16,
    szPname: [32]i8,
    wXmin: u32,
    wXmax: u32,
    wYmin: u32,
    wYmax: u32,
    wZmin: u32,
    wZmax: u32,
    wNumButtons: u32,
    wPeriodMin: u32,
    wPeriodMax: u32,
    wRmin: u32,
    wRmax: u32,
    wUmin: u32,
    wUmax: u32,
    wVmin: u32,
    wVmax: u32,
    wCaps: u32,
    wMaxAxes: u32,
    wNumAxes: u32,
    wMaxButtons: u32,
    szRegKey: [32]i8,
    szOEMVxD: [260]i8,
};

pub const JOYCAPSW = extern struct {
    wMid: u16,
    wPid: u16,
    szPname: [32]u16,
    wXmin: u32,
    wXmax: u32,
    wYmin: u32,
    wYmax: u32,
    wZmin: u32,
    wZmax: u32,
    wNumButtons: u32,
    wPeriodMin: u32,
    wPeriodMax: u32,
    wRmin: u32,
    wRmax: u32,
    wUmin: u32,
    wUmax: u32,
    wVmin: u32,
    wVmax: u32,
    wCaps: u32,
    wMaxAxes: u32,
    wNumAxes: u32,
    wMaxButtons: u32,
    szRegKey: [32]u16,
    szOEMVxD: [260]u16,
};

pub const JOYCAPS2A = extern struct {
    wMid: u16,
    wPid: u16,
    szPname: [32]i8,
    wXmin: u32,
    wXmax: u32,
    wYmin: u32,
    wYmax: u32,
    wZmin: u32,
    wZmax: u32,
    wNumButtons: u32,
    wPeriodMin: u32,
    wPeriodMax: u32,
    wRmin: u32,
    wRmax: u32,
    wUmin: u32,
    wUmax: u32,
    wVmin: u32,
    wVmax: u32,
    wCaps: u32,
    wMaxAxes: u32,
    wNumAxes: u32,
    wMaxButtons: u32,
    szRegKey: [32]i8,
    szOEMVxD: [260]i8,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const JOYCAPS2W = extern struct {
    wMid: u16,
    wPid: u16,
    szPname: [32]u16,
    wXmin: u32,
    wXmax: u32,
    wYmin: u32,
    wYmax: u32,
    wZmin: u32,
    wZmax: u32,
    wNumButtons: u32,
    wPeriodMin: u32,
    wPeriodMax: u32,
    wRmin: u32,
    wRmax: u32,
    wUmin: u32,
    wUmax: u32,
    wVmin: u32,
    wVmax: u32,
    wCaps: u32,
    wMaxAxes: u32,
    wNumAxes: u32,
    wMaxButtons: u32,
    szRegKey: [32]u16,
    szOEMVxD: [260]u16,
    ManufacturerGuid: Guid,
    ProductGuid: Guid,
    NameGuid: Guid,
};

pub const JOYINFO = extern struct {
    wXpos: u32,
    wYpos: u32,
    wZpos: u32,
    wButtons: u32,
};

pub const JOYINFOEX = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwXpos: u32,
    dwYpos: u32,
    dwZpos: u32,
    dwRpos: u32,
    dwUpos: u32,
    dwVpos: u32,
    dwButtons: u32,
    dwButtonNumber: u32,
    dwPOV: u32,
    dwReserved1: u32,
    dwReserved2: u32,
};

const CLSID_KSDATAFORMAT_SUBTYPE_PCM_Value = @import("../zig.zig").Guid.initString("00000001-0000-0010-8000-00AA00389B71");
pub const CLSID_KSDATAFORMAT_SUBTYPE_PCM = &CLSID_KSDATAFORMAT_SUBTYPE_PCM_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT_Value = @import("../zig.zig").Guid.initString("00000003-0000-0010-8000-00AA00389B71");
pub const CLSID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT = &CLSID_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT_Value;

const CLSID_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX_Value = @import("../zig.zig").Guid.initString("00000000-0000-0010-8000-00AA00389B71");
pub const CLSID_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX = &CLSID_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX_Value;

pub const WAVEFORMATEXTENSIBLE = extern struct {
    Format: WAVEFORMATEX,
    Samples: WAVEFORMATEXTENSIBLE._Samples_e__Union,
    dwChannelMask: u32,
    SubFormat: Guid,
    const _Samples_e__Union = u32; // TODO: generate this nested type!
};

pub const ADPCMCOEFSET = extern struct {
    iCoef1: i16,
    iCoef2: i16,
};

pub const ADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
    wNumCoef: u16,
    aCoef: ADPCMCOEFSET,
};

pub const DRMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wReserved: u16,
    ulContentId: u32,
    wfxSecure: WAVEFORMATEX,
};

pub const DVIADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const IMAADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const MEDIASPACEADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const SIERRAADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const G723_ADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    cbExtraSize: u16,
    nAuxBlockSize: u16,
};

pub const DIGISTDWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const DIGIFIXWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const DIALOGICOKIADPCMWAVEFORMAT = extern struct {
    ewf: WAVEFORMATEX,
};

pub const YAMAHA_ADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const SONARCWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wCompType: u16,
};

pub const TRUESPEECHWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
    nSamplesPerBlock: u16,
    abReserved: [28]u8,
};

pub const ECHOSC1WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const AUDIOFILE_AF36WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const APTXWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const AUDIOFILE_AF10WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const DOLBYAC2WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    nAuxBitsCode: u16,
};

pub const GSM610WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const ADPCMEWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const CONTRESVQLPCWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const DIGIREALWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const DIGIADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const CONTRESCR10WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const NMS_VBXADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
};

pub const G721_ADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    nAuxBlockSize: u16,
};

pub const MSAUDIO1WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wSamplesPerBlock: u16,
    wEncodeOptions: u16,
};

pub const WMAUDIO2WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    dwSamplesPerBlock: u32,
    wEncodeOptions: u16,
    dwSuperBlockAlign: u32,
};

pub const WMAUDIO3WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wValidBitsPerSample: u16,
    dwChannelMask: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    wEncodeOptions: u16,
    wReserved3: u16,
};

pub const CREATIVEADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const CREATIVEFASTSPEECH8WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const CREATIVEFASTSPEECH10WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const FMTOWNS_SND_WAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
    wRevision: u16,
};

pub const OLIGSMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const OLIADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const OLICELPWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const OLISBCWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const OLIOPRWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const CSIMAADPCMWAVEFORMAT = extern struct {
    wfx: WAVEFORMATEX,
};

pub const WAVEFILTER = extern struct {
    cbStruct: u32,
    dwFilterTag: u32,
    fdwFilter: u32,
    dwReserved: [5]u32,
};

pub const VOLUMEWAVEFILTER = extern struct {
    wfltr: WAVEFILTER,
    dwVolume: u32,
};

pub const ECHOWAVEFILTER = extern struct {
    wfltr: WAVEFILTER,
    dwVolume: u32,
    dwDelay: u32,
};

pub const s_RIFFWAVE_inst = extern struct {
    bUnshiftedNote: u8,
    chFineTune: i8,
    chGain: i8,
    bLowNote: u8,
    bHighNote: u8,
    bLowVelocity: u8,
    bHighVelocity: u8,
};

pub const tag_s_RIFFWAVE_INST = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const EXBMINFOHEADER = extern struct {
    bmi: BITMAPINFOHEADER,
    biExtDataOffset: u32,
};

pub const JPEGINFOHEADER = extern struct {
    JPEGSize: u32,
    JPEGProcess: u32,
    JPEGColorSpaceID: u32,
    JPEGBitsPerSample: u32,
    JPEGHSubSampling: u32,
    JPEGVSubSampling: u32,
};

pub const MCI_DGV_RECT_PARMS = extern struct {
    dwCallback: ?*c_void,
    rc: RECT,
};

pub const MCI_DGV_CAPTURE_PARMSA = extern struct {
    dwCallback: ?*c_void,
    lpstrFileName: PSTR,
    rc: RECT,
};

pub const MCI_DGV_CAPTURE_PARMSW = extern struct {
    dwCallback: ?*c_void,
    lpstrFileName: PWSTR,
    rc: RECT,
};

pub const MCI_DGV_COPY_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwFrom: u32,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_CUE_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwTo: u32,
};

pub const MCI_DGV_CUT_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwFrom: u32,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_DELETE_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwFrom: u32,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_INFO_PARMSA = extern struct {
    dwCallback: ?*c_void,
    lpstrReturn: PSTR,
    dwRetSize: u32,
    dwItem: u32,
};

pub const MCI_DGV_INFO_PARMSW = extern struct {
    dwCallback: ?*c_void,
    lpstrReturn: PWSTR,
    dwRetSize: u32,
    dwItem: u32,
};

pub const MCI_DGV_LIST_PARMSA = extern struct {
    dwCallback: ?*c_void,
    lpstrReturn: PSTR,
    dwLength: u32,
    dwNumber: u32,
    dwItem: u32,
    lpstrAlgorithm: PSTR,
};

pub const MCI_DGV_LIST_PARMSW = extern struct {
    dwCallback: ?*c_void,
    lpstrReturn: PWSTR,
    dwLength: u32,
    dwNumber: u32,
    dwItem: u32,
    lpstrAlgorithm: PWSTR,
};

pub const MCI_DGV_MONITOR_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwSource: u32,
    dwMethod: u32,
};

pub const MCI_DGV_OPEN_PARMSA = extern struct {
    dwCallback: ?*c_void,
    wDeviceID: u32,
    lpstrDeviceType: PSTR,
    lpstrElementName: PSTR,
    lpstrAlias: PSTR,
    dwStyle: u32,
    hWndParent: HWND,
};

pub const MCI_DGV_OPEN_PARMSW = extern struct {
    dwCallback: ?*c_void,
    wDeviceID: u32,
    lpstrDeviceType: PWSTR,
    lpstrElementName: PWSTR,
    lpstrAlias: PWSTR,
    dwStyle: u32,
    hWndParent: HWND,
};

pub const MCI_DGV_PASTE_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_QUALITY_PARMSA = extern struct {
    dwCallback: ?*c_void,
    dwItem: u32,
    lpstrName: PSTR,
    lpstrAlgorithm: u32,
    dwHandle: u32,
};

pub const MCI_DGV_QUALITY_PARMSW = extern struct {
    dwCallback: ?*c_void,
    dwItem: u32,
    lpstrName: PWSTR,
    lpstrAlgorithm: u32,
    dwHandle: u32,
};

pub const MCI_DGV_RECORD_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwFrom: u32,
    dwTo: u32,
    rc: RECT,
    dwAudioStream: u32,
    dwVideoStream: u32,
};

pub const MCI_DGV_RESERVE_PARMSA = extern struct {
    dwCallback: ?*c_void,
    lpstrPath: PSTR,
    dwSize: u32,
};

pub const MCI_DGV_RESERVE_PARMSW = extern struct {
    dwCallback: ?*c_void,
    lpstrPath: PWSTR,
    dwSize: u32,
};

pub const MCI_DGV_RESTORE_PARMSA = extern struct {
    dwCallback: ?*c_void,
    lpstrFileName: PSTR,
    rc: RECT,
};

pub const MCI_DGV_RESTORE_PARMSW = extern struct {
    dwCallback: ?*c_void,
    lpstrFileName: PWSTR,
    rc: RECT,
};

pub const MCI_DGV_SAVE_PARMSA = extern struct {
    dwCallback: ?*c_void,
    lpstrFileName: PSTR,
    rc: RECT,
};

pub const MCI_DGV_SAVE_PARMSW = extern struct {
    dwCallback: ?*c_void,
    lpstrFileName: PWSTR,
    rc: RECT,
};

pub const MCI_DGV_SET_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwTimeFormat: u32,
    dwAudio: u32,
    dwFileFormat: u32,
    dwSpeed: u32,
};

pub const MCI_DGV_SETAUDIO_PARMSA = extern struct {
    dwCallback: ?*c_void,
    dwItem: u32,
    dwValue: u32,
    dwOver: u32,
    lpstrAlgorithm: PSTR,
    lpstrQuality: PSTR,
};

pub const MCI_DGV_SETAUDIO_PARMSW = extern struct {
    dwCallback: ?*c_void,
    dwItem: u32,
    dwValue: u32,
    dwOver: u32,
    lpstrAlgorithm: PWSTR,
    lpstrQuality: PWSTR,
};

pub const MCI_DGV_SIGNAL_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwPosition: u32,
    dwPeriod: u32,
    dwUserParm: u32,
};

pub const MCI_DGV_SETVIDEO_PARMSA = extern struct {
    dwCallback: ?*c_void,
    dwItem: u32,
    dwValue: u32,
    dwOver: u32,
    lpstrAlgorithm: PSTR,
    lpstrQuality: PSTR,
    dwSourceNumber: u32,
};

pub const MCI_DGV_SETVIDEO_PARMSW = extern struct {
    dwCallback: ?*c_void,
    dwItem: u32,
    dwValue: u32,
    dwOver: u32,
    lpstrAlgorithm: PWSTR,
    lpstrQuality: PWSTR,
    dwSourceNumber: u32,
};

pub const MCI_DGV_STATUS_PARMSA = extern struct {
    dwCallback: ?*c_void,
    dwReturn: ?*c_void,
    dwItem: u32,
    dwTrack: u32,
    lpstrDrive: PSTR,
    dwReference: u32,
};

pub const MCI_DGV_STATUS_PARMSW = extern struct {
    dwCallback: ?*c_void,
    dwReturn: ?*c_void,
    dwItem: u32,
    dwTrack: u32,
    lpstrDrive: PWSTR,
    dwReference: u32,
};

pub const MCI_DGV_STEP_PARMS = extern struct {
    dwCallback: ?*c_void,
    dwFrames: u32,
};

pub const MCI_DGV_UPDATE_PARMS = extern struct {
    dwCallback: ?*c_void,
    rc: RECT,
    hDC: HDC,
};

pub const MCI_DGV_WINDOW_PARMSA = extern struct {
    dwCallback: ?*c_void,
    hWnd: HWND,
    nCmdShow: u32,
    lpstrText: PSTR,
};

pub const MCI_DGV_WINDOW_PARMSW = extern struct {
    dwCallback: ?*c_void,
    hWnd: HWND,
    nCmdShow: u32,
    lpstrText: PWSTR,
};

pub const HACMDRIVERID__ = extern struct {
    unused: i32,
};

pub const HACMDRIVER__ = extern struct {
    unused: i32,
};

pub const HACMSTREAM__ = extern struct {
    unused: i32,
};

pub const HACMOBJ__ = extern struct {
    unused: i32,
};

pub const ACMDRIVERENUMCB = fn(
    hadid: *HACMDRIVERID__,
    dwInstance: ?*c_void,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMDRIVERPROC = fn(
    param0: ?*c_void,
    param1: *HACMDRIVERID__,
    param2: u32,
    param3: LPARAM,
    param4: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const LPACMDRIVERPROC = fn(
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const tACMDRIVERDETAILSA = extern struct {
    cbStruct: u32,
    fccType: u32,
    fccComp: u32,
    wMid: u16,
    wPid: u16,
    vdwACM: u32,
    vdwDriver: u32,
    fdwSupport: u32,
    cFormatTags: u32,
    cFilterTags: u32,
    hicon: HICON,
    szShortName: [32]i8,
    szLongName: [128]i8,
    szCopyright: [80]i8,
    szLicensing: [128]i8,
    szFeatures: [512]i8,
};

pub const tACMDRIVERDETAILSW = extern struct {
    cbStruct: u32,
    fccType: u32,
    fccComp: u32,
    wMid: u16,
    wPid: u16,
    vdwACM: u32,
    vdwDriver: u32,
    fdwSupport: u32,
    cFormatTags: u32,
    cFilterTags: u32,
    hicon: HICON,
    szShortName: [32]u16,
    szLongName: [128]u16,
    szCopyright: [80]u16,
    szLicensing: [128]u16,
    szFeatures: [512]u16,
};

pub const tACMFORMATTAGDETAILSA = extern struct {
    cbStruct: u32,
    dwFormatTagIndex: u32,
    dwFormatTag: u32,
    cbFormatSize: u32,
    fdwSupport: u32,
    cStandardFormats: u32,
    szFormatTag: [48]i8,
};

pub const tACMFORMATTAGDETAILSW = extern struct {
    cbStruct: u32,
    dwFormatTagIndex: u32,
    dwFormatTag: u32,
    cbFormatSize: u32,
    fdwSupport: u32,
    cStandardFormats: u32,
    szFormatTag: [48]u16,
};

pub const ACMFORMATTAGENUMCBA = fn(
    hadid: *HACMDRIVERID__,
    paftd: *tACMFORMATTAGDETAILSA,
    dwInstance: ?*c_void,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATTAGENUMCBW = fn(
    hadid: *HACMDRIVERID__,
    paftd: *tACMFORMATTAGDETAILSW,
    dwInstance: ?*c_void,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const tACMFORMATDETAILSA = extern struct {
    cbStruct: u32,
    dwFormatIndex: u32,
    dwFormatTag: u32,
    fdwSupport: u32,
    pwfx: *WAVEFORMATEX,
    cbwfx: u32,
    szFormat: [128]i8,
};

pub const tACMFORMATDETAILSW = extern struct {
    cbStruct: u32,
    dwFormatIndex: u32,
    dwFormatTag: u32,
    fdwSupport: u32,
    pwfx: *WAVEFORMATEX,
    cbwfx: u32,
    szFormat: [128]u16,
};

pub const ACMFORMATENUMCBA = fn(
    hadid: *HACMDRIVERID__,
    pafd: *tACMFORMATDETAILSA,
    dwInstance: ?*c_void,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATENUMCBW = fn(
    hadid: *HACMDRIVERID__,
    pafd: *tACMFORMATDETAILSW,
    dwInstance: ?*c_void,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFORMATCHOOSEHOOKPROCA = fn(
    hwnd: HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFORMATCHOOSEHOOKPROCW = fn(
    hwnd: HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const tACMFORMATCHOOSEA = extern struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: HWND,
    pwfx: *WAVEFORMATEX,
    cbwfx: u32,
    pszTitle: [*:0]const u8,
    szFormatTag: [48]i8,
    szFormat: [128]i8,
    pszName: PSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfxEnum: *WAVEFORMATEX,
    hInstance: HINSTANCE,
    pszTemplateName: [*:0]const u8,
    lCustData: LPARAM,
    pfnHook: ACMFORMATCHOOSEHOOKPROCA,
};

pub const tACMFORMATCHOOSEW = extern struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: HWND,
    pwfx: *WAVEFORMATEX,
    cbwfx: u32,
    pszTitle: [*:0]const u16,
    szFormatTag: [48]u16,
    szFormat: [128]u16,
    pszName: PWSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfxEnum: *WAVEFORMATEX,
    hInstance: HINSTANCE,
    pszTemplateName: [*:0]const u16,
    lCustData: LPARAM,
    pfnHook: ACMFORMATCHOOSEHOOKPROCW,
};

pub const tACMFILTERTAGDETAILSA = extern struct {
    cbStruct: u32,
    dwFilterTagIndex: u32,
    dwFilterTag: u32,
    cbFilterSize: u32,
    fdwSupport: u32,
    cStandardFilters: u32,
    szFilterTag: [48]i8,
};

pub const tACMFILTERTAGDETAILSW = extern struct {
    cbStruct: u32,
    dwFilterTagIndex: u32,
    dwFilterTag: u32,
    cbFilterSize: u32,
    fdwSupport: u32,
    cStandardFilters: u32,
    szFilterTag: [48]u16,
};

pub const ACMFILTERTAGENUMCBA = fn(
    hadid: *HACMDRIVERID__,
    paftd: *tACMFILTERTAGDETAILSA,
    dwInstance: ?*c_void,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERTAGENUMCBW = fn(
    hadid: *HACMDRIVERID__,
    paftd: *tACMFILTERTAGDETAILSW,
    dwInstance: ?*c_void,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const tACMFILTERDETAILSA = extern struct {
    cbStruct: u32,
    dwFilterIndex: u32,
    dwFilterTag: u32,
    fdwSupport: u32,
    pwfltr: *WAVEFILTER,
    cbwfltr: u32,
    szFilter: [128]i8,
};

pub const tACMFILTERDETAILSW = extern struct {
    cbStruct: u32,
    dwFilterIndex: u32,
    dwFilterTag: u32,
    fdwSupport: u32,
    pwfltr: *WAVEFILTER,
    cbwfltr: u32,
    szFilter: [128]u16,
};

pub const ACMFILTERENUMCBA = fn(
    hadid: *HACMDRIVERID__,
    pafd: *tACMFILTERDETAILSA,
    dwInstance: ?*c_void,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERENUMCBW = fn(
    hadid: *HACMDRIVERID__,
    pafd: *tACMFILTERDETAILSW,
    dwInstance: ?*c_void,
    fdwSupport: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ACMFILTERCHOOSEHOOKPROCA = fn(
    hwnd: HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const ACMFILTERCHOOSEHOOKPROCW = fn(
    hwnd: HWND,
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const tACMFILTERCHOOSEA = extern struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: HWND,
    pwfltr: *WAVEFILTER,
    cbwfltr: u32,
    pszTitle: [*:0]const u8,
    szFilterTag: [48]i8,
    szFilter: [128]i8,
    pszName: PSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfltrEnum: *WAVEFILTER,
    hInstance: HINSTANCE,
    pszTemplateName: [*:0]const u8,
    lCustData: LPARAM,
    pfnHook: ACMFILTERCHOOSEHOOKPROCA,
};

pub const tACMFILTERCHOOSEW = extern struct {
    cbStruct: u32,
    fdwStyle: u32,
    hwndOwner: HWND,
    pwfltr: *WAVEFILTER,
    cbwfltr: u32,
    pszTitle: [*:0]const u16,
    szFilterTag: [48]u16,
    szFilter: [128]u16,
    pszName: PWSTR,
    cchName: u32,
    fdwEnum: u32,
    pwfltrEnum: *WAVEFILTER,
    hInstance: HINSTANCE,
    pszTemplateName: [*:0]const u16,
    lCustData: LPARAM,
    pfnHook: ACMFILTERCHOOSEHOOKPROCW,
};

pub const ACMSTREAMHEADER = extern struct {
    cbStruct: u32,
    fdwStatus: u32,
    dwUser: ?*c_void,
    pbSrc: *u8,
    cbSrcLength: u32,
    cbSrcLengthUsed: u32,
    dwSrcUser: ?*c_void,
    pbDst: *u8,
    cbDstLength: u32,
    cbDstLengthUsed: u32,
    dwDstUser: ?*c_void,
    dwReservedDriver: [10]u32,
};

pub const HIC__ = extern struct {
    unused: i32,
};

pub const ICOPEN = extern struct {
    dwSize: u32,
    fccType: u32,
    fccHandler: u32,
    dwVersion: u32,
    dwFlags: u32,
    dwError: LRESULT,
    pV1Reserved: *c_void,
    pV2Reserved: *c_void,
    dnDevNode: u32,
};

pub const ICINFO = extern struct {
    dwSize: u32,
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    dwVersion: u32,
    dwVersionICM: u32,
    szName: [16]u16,
    szDescription: [128]u16,
    szDriver: [128]u16,
};

pub const ICCOMPRESS = extern struct {
    dwFlags: u32,
    lpbiOutput: *BITMAPINFOHEADER,
    lpOutput: *c_void,
    lpbiInput: *BITMAPINFOHEADER,
    lpInput: *c_void,
    lpckid: *u32,
    lpdwFlags: *u32,
    lFrameNum: i32,
    dwFrameSize: u32,
    dwQuality: u32,
    lpbiPrev: *BITMAPINFOHEADER,
    lpPrev: *c_void,
};

pub const ICCOMPRESSFRAMES = extern struct {
    dwFlags: u32,
    lpbiOutput: *BITMAPINFOHEADER,
    lOutput: LPARAM,
    lpbiInput: *BITMAPINFOHEADER,
    lInput: LPARAM,
    lStartFrame: i32,
    lFrameCount: i32,
    lQuality: i32,
    lDataRate: i32,
    lKeyRate: i32,
    dwRate: u32,
    dwScale: u32,
    dwOverheadPerFrame: u32,
    dwReserved2: u32,
    GetData: ?*c_void,
    PutData: ?*c_void,
};

pub const ICSETSTATUSPROC = extern struct {
    dwFlags: u32,
    lParam: LPARAM,
    Status: ?*c_void,
};

pub const ICDECOMPRESS = extern struct {
    dwFlags: u32,
    lpbiInput: *BITMAPINFOHEADER,
    lpInput: *c_void,
    lpbiOutput: *BITMAPINFOHEADER,
    lpOutput: *c_void,
    ckid: u32,
};

pub const ICDECOMPRESSEX = extern struct {
    dwFlags: u32,
    lpbiSrc: *BITMAPINFOHEADER,
    lpSrc: *c_void,
    lpbiDst: *BITMAPINFOHEADER,
    lpDst: *c_void,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
};

pub const ICDRAWBEGIN = extern struct {
    dwFlags: u32,
    hpal: HPALETTE,
    hwnd: HWND,
    hdc: HDC,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    lpbi: *BITMAPINFOHEADER,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
    dwRate: u32,
    dwScale: u32,
};

pub const ICDRAW = extern struct {
    dwFlags: u32,
    lpFormat: *c_void,
    lpData: *c_void,
    cbData: u32,
    lTime: i32,
};

pub const ICDRAWSUGGEST = extern struct {
    lpbiIn: *BITMAPINFOHEADER,
    lpbiSuggest: *BITMAPINFOHEADER,
    dxSrc: i32,
    dySrc: i32,
    dxDst: i32,
    dyDst: i32,
    hicDecompressor: *HIC__,
};

pub const ICPALETTE = extern struct {
    dwFlags: u32,
    iStart: i32,
    iLen: i32,
    lppe: *PALETTEENTRY,
};

pub const COMPVARS = extern struct {
    cbSize: i32,
    dwFlags: u32,
    hic: *HIC__,
    fccType: u32,
    fccHandler: u32,
    lpbiIn: *BITMAPINFO,
    lpbiOut: *BITMAPINFO,
    lpBitsOut: *c_void,
    lpBitsPrev: *c_void,
    lFrame: i32,
    lKey: i32,
    lDataRate: i32,
    lQ: i32,
    lKeyCount: i32,
    lpState: *c_void,
    cbState: i32,
};

pub const DRAWDIBTIME = extern struct {
    timeCount: i32,
    timeDraw: i32,
    timeDecompress: i32,
    timeDither: i32,
    timeStretch: i32,
    timeBlt: i32,
    timeSetDIBits: i32,
};

pub const AVISTREAMINFOW = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    dwCaps: u32,
    wPriority: u16,
    wLanguage: u16,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwInitialFrames: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: RECT,
    dwEditCount: u32,
    dwFormatChangeCount: u32,
    szName: [64]u16,
};

pub const AVISTREAMINFOA = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwFlags: u32,
    dwCaps: u32,
    wPriority: u16,
    wLanguage: u16,
    dwScale: u32,
    dwRate: u32,
    dwStart: u32,
    dwLength: u32,
    dwInitialFrames: u32,
    dwSuggestedBufferSize: u32,
    dwQuality: u32,
    dwSampleSize: u32,
    rcFrame: RECT,
    dwEditCount: u32,
    dwFormatChangeCount: u32,
    szName: [64]i8,
};

pub const AVIFILEINFOW = extern struct {
    dwMaxBytesPerSec: u32,
    dwFlags: u32,
    dwCaps: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwScale: u32,
    dwRate: u32,
    dwLength: u32,
    dwEditCount: u32,
    szFileType: [64]u16,
};

pub const AVIFILEINFOA = extern struct {
    dwMaxBytesPerSec: u32,
    dwFlags: u32,
    dwCaps: u32,
    dwStreams: u32,
    dwSuggestedBufferSize: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwScale: u32,
    dwRate: u32,
    dwLength: u32,
    dwEditCount: u32,
    szFileType: [64]i8,
};

pub const AVISAVECALLBACK = fn(
    param0: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const AVICOMPRESSOPTIONS = extern struct {
    fccType: u32,
    fccHandler: u32,
    dwKeyFrameEvery: u32,
    dwQuality: u32,
    dwBytesPerSecond: u32,
    dwFlags: u32,
    lpFormat: *c_void,
    cbFormat: u32,
    lpParms: *c_void,
    cbParms: u32,
    dwInterleaveEvery: u32,
};

pub const IAVIStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IAVIStream,
            lParam1: LPARAM,
            lParam2: LPARAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Info: fn(
            self: *const IAVIStream,
            psi: [*]AVISTREAMINFOW,
            lSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSample: fn(
            self: *const IAVIStream,
            lPos: i32,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        ReadFormat: fn(
            self: *const IAVIStream,
            lPos: i32,
            lpFormat: ?[*]u8,
            lpcbFormat: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: fn(
            self: *const IAVIStream,
            lPos: i32,
            lpFormat: [*]u8,
            cbFormat: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Read: fn(
            self: *const IAVIStream,
            lStart: i32,
            lSamples: i32,
            lpBuffer: ?[*]u8,
            cbBuffer: i32,
            plBytes: ?*i32,
            plSamples: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const IAVIStream,
            lStart: i32,
            lSamples: i32,
            lpBuffer: [*]u8,
            cbBuffer: i32,
            dwFlags: u32,
            plSampWritten: ?*i32,
            plBytesWritten: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IAVIStream,
            lStart: i32,
            lSamples: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadData: fn(
            self: *const IAVIStream,
            fcc: u32,
            lp: ?[*]u8,
            lpcb: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteData: fn(
            self: *const IAVIStream,
            fcc: u32,
            lp: [*]u8,
            cb: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInfo: fn(
            self: *const IAVIStream,
            lpInfo: [*]AVISTREAMINFOW,
            cbInfo: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Create(self: *const T, lParam1: LPARAM, lParam2: LPARAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Create(@ptrCast(*const IAVIStream, self), lParam1, lParam2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Info(self: *const T, psi: [*]AVISTREAMINFOW, lSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Info(@ptrCast(*const IAVIStream, self), psi, lSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_FindSample(self: *const T, lPos: i32, lFlags: i32) callconv(.Inline) i32 {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).FindSample(@ptrCast(*const IAVIStream, self), lPos, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_ReadFormat(self: *const T, lPos: i32, lpFormat: ?[*]u8, lpcbFormat: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).ReadFormat(@ptrCast(*const IAVIStream, self), lPos, lpFormat, lpcbFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_SetFormat(self: *const T, lPos: i32, lpFormat: [*]u8, cbFormat: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).SetFormat(@ptrCast(*const IAVIStream, self), lPos, lpFormat, cbFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Read(self: *const T, lStart: i32, lSamples: i32, lpBuffer: ?[*]u8, cbBuffer: i32, plBytes: ?*i32, plSamples: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Read(@ptrCast(*const IAVIStream, self), lStart, lSamples, lpBuffer, cbBuffer, plBytes, plSamples);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Write(self: *const T, lStart: i32, lSamples: i32, lpBuffer: [*]u8, cbBuffer: i32, dwFlags: u32, plSampWritten: ?*i32, plBytesWritten: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Write(@ptrCast(*const IAVIStream, self), lStart, lSamples, lpBuffer, cbBuffer, dwFlags, plSampWritten, plBytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_Delete(self: *const T, lStart: i32, lSamples: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).Delete(@ptrCast(*const IAVIStream, self), lStart, lSamples);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_ReadData(self: *const T, fcc: u32, lp: ?[*]u8, lpcb: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).ReadData(@ptrCast(*const IAVIStream, self), fcc, lp, lpcb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_WriteData(self: *const T, fcc: u32, lp: [*]u8, cb: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).WriteData(@ptrCast(*const IAVIStream, self), fcc, lp, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStream_SetInfo(self: *const T, lpInfo: [*]AVISTREAMINFOW, cbInfo: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStream.VTable, self.vtable).SetInfo(@ptrCast(*const IAVIStream, self), lpInfo, cbInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IAVIStreaming = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin: fn(
            self: *const IAVIStreaming,
            lStart: i32,
            lEnd: i32,
            lRate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: fn(
            self: *const IAVIStreaming,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStreaming_Begin(self: *const T, lStart: i32, lEnd: i32, lRate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStreaming.VTable, self.vtable).Begin(@ptrCast(*const IAVIStreaming, self), lStart, lEnd, lRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIStreaming_End(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIStreaming.VTable, self.vtable).End(@ptrCast(*const IAVIStreaming, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IAVIEditStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cut: fn(
            self: *const IAVIEditStream,
            plStart: *i32,
            plLength: *i32,
            ppResult: **IAVIStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const IAVIEditStream,
            plStart: *i32,
            plLength: *i32,
            ppResult: **IAVIStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Paste: fn(
            self: *const IAVIEditStream,
            plPos: *i32,
            plLength: *i32,
            pstream: *IAVIStream,
            lStart: i32,
            lEnd: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IAVIEditStream,
            ppResult: **IAVIStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInfo: fn(
            self: *const IAVIEditStream,
            lpInfo: [*]AVISTREAMINFOW,
            cbInfo: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_Cut(self: *const T, plStart: *i32, plLength: *i32, ppResult: **IAVIStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).Cut(@ptrCast(*const IAVIEditStream, self), plStart, plLength, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_Copy(self: *const T, plStart: *i32, plLength: *i32, ppResult: **IAVIStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).Copy(@ptrCast(*const IAVIEditStream, self), plStart, plLength, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_Paste(self: *const T, plPos: *i32, plLength: *i32, pstream: *IAVIStream, lStart: i32, lEnd: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).Paste(@ptrCast(*const IAVIEditStream, self), plPos, plLength, pstream, lStart, lEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_Clone(self: *const T, ppResult: **IAVIStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).Clone(@ptrCast(*const IAVIEditStream, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIEditStream_SetInfo(self: *const T, lpInfo: [*]AVISTREAMINFOW, cbInfo: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIEditStream.VTable, self.vtable).SetInfo(@ptrCast(*const IAVIEditStream, self), lpInfo, cbInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IAVIPersistFile = extern struct {
    pub const VTable = extern struct {
        base: IPersistFile.VTable,
        Reserved1: fn(
            self: *const IAVIPersistFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistFile.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIPersistFile_Reserved1(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIPersistFile.VTable, self.vtable).Reserved1(@ptrCast(*const IAVIPersistFile, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IAVIFile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Info: fn(
            self: *const IAVIFile,
            pfi: [*]AVIFILEINFOW,
            lSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: fn(
            self: *const IAVIFile,
            ppStream: **IAVIStream,
            fccType: u32,
            lParam: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStream: fn(
            self: *const IAVIFile,
            ppStream: **IAVIStream,
            psi: *AVISTREAMINFOW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteData: fn(
            self: *const IAVIFile,
            ckid: u32,
            lpData: [*]u8,
            cbData: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadData: fn(
            self: *const IAVIFile,
            ckid: u32,
            lpData: [*]u8,
            lpcbData: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndRecord: fn(
            self: *const IAVIFile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteStream: fn(
            self: *const IAVIFile,
            fccType: u32,
            lParam: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_Info(self: *const T, pfi: [*]AVIFILEINFOW, lSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).Info(@ptrCast(*const IAVIFile, self), pfi, lSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_GetStream(self: *const T, ppStream: **IAVIStream, fccType: u32, lParam: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).GetStream(@ptrCast(*const IAVIFile, self), ppStream, fccType, lParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_CreateStream(self: *const T, ppStream: **IAVIStream, psi: *AVISTREAMINFOW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).CreateStream(@ptrCast(*const IAVIFile, self), ppStream, psi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_WriteData(self: *const T, ckid: u32, lpData: [*]u8, cbData: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).WriteData(@ptrCast(*const IAVIFile, self), ckid, lpData, cbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_ReadData(self: *const T, ckid: u32, lpData: [*]u8, lpcbData: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).ReadData(@ptrCast(*const IAVIFile, self), ckid, lpData, lpcbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_EndRecord(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).EndRecord(@ptrCast(*const IAVIFile, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAVIFile_DeleteStream(self: *const T, fccType: u32, lParam: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAVIFile.VTable, self.vtable).DeleteStream(@ptrCast(*const IAVIFile, self), fccType, lParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IGetFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrame: fn(
            self: *const IGetFrame,
            lPos: i32,
        ) callconv(@import("std").os.windows.WINAPI) *c_void,
        Begin: fn(
            self: *const IGetFrame,
            lStart: i32,
            lEnd: i32,
            lRate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: fn(
            self: *const IGetFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormat: fn(
            self: *const IGetFrame,
            lpbi: *BITMAPINFOHEADER,
            lpBits: ?*c_void,
            x: i32,
            y: i32,
            dx: i32,
            dy: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetFrame_GetFrame(self: *const T, lPos: i32) callconv(.Inline) *c_void {
            return @ptrCast(*const IGetFrame.VTable, self.vtable).GetFrame(@ptrCast(*const IGetFrame, self), lPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetFrame_Begin(self: *const T, lStart: i32, lEnd: i32, lRate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetFrame.VTable, self.vtable).Begin(@ptrCast(*const IGetFrame, self), lStart, lEnd, lRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetFrame_End(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetFrame.VTable, self.vtable).End(@ptrCast(*const IGetFrame, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetFrame_SetFormat(self: *const T, lpbi: *BITMAPINFOHEADER, lpBits: ?*c_void, x: i32, y: i32, dx: i32, dy: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetFrame.VTable, self.vtable).SetFormat(@ptrCast(*const IGetFrame, self), lpbi, lpBits, x, y, dx, dy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HVIDEO__ = extern struct {
    unused: i32,
};

pub const VIDEOHDR = extern struct {
    lpData: *u8,
    dwBufferLength: u32,
    dwBytesUsed: u32,
    dwTimeCaptured: u32,
    dwUser: ?*c_void,
    dwFlags: u32,
    dwReserved: [4]?*c_void,
};

pub const channel_caps_tag = extern struct {
    dwFlags: u32,
    dwSrcRectXMod: u32,
    dwSrcRectYMod: u32,
    dwSrcRectWidthMod: u32,
    dwSrcRectHeightMod: u32,
    dwDstRectXMod: u32,
    dwDstRectYMod: u32,
    dwDstRectWidthMod: u32,
    dwDstRectHeightMod: u32,
};

pub const CAPDRIVERCAPS = extern struct {
    wDeviceIndex: u32,
    fHasOverlay: BOOL,
    fHasDlgVideoSource: BOOL,
    fHasDlgVideoFormat: BOOL,
    fHasDlgVideoDisplay: BOOL,
    fCaptureInitialized: BOOL,
    fDriverSuppliesPalettes: BOOL,
    hVideoIn: HANDLE,
    hVideoOut: HANDLE,
    hVideoExtIn: HANDLE,
    hVideoExtOut: HANDLE,
};

pub const CAPSTATUS = extern struct {
    uiImageWidth: u32,
    uiImageHeight: u32,
    fLiveWindow: BOOL,
    fOverlayWindow: BOOL,
    fScale: BOOL,
    ptScroll: POINT,
    fUsingDefaultPalette: BOOL,
    fAudioHardware: BOOL,
    fCapFileExists: BOOL,
    dwCurrentVideoFrame: u32,
    dwCurrentVideoFramesDropped: u32,
    dwCurrentWaveSamples: u32,
    dwCurrentTimeElapsedMS: u32,
    hPalCurrent: HPALETTE,
    fCapturingNow: BOOL,
    dwReturn: u32,
    wNumVideoAllocated: u32,
    wNumAudioAllocated: u32,
};

pub const CAPTUREPARMS = extern struct {
    dwRequestMicroSecPerFrame: u32,
    fMakeUserHitOKToCapture: BOOL,
    wPercentDropForError: u32,
    fYield: BOOL,
    dwIndexSize: u32,
    wChunkGranularity: u32,
    fUsingDOSMemory: BOOL,
    wNumVideoRequested: u32,
    fCaptureAudio: BOOL,
    wNumAudioRequested: u32,
    vKeyAbort: u32,
    fAbortLeftMouse: BOOL,
    fAbortRightMouse: BOOL,
    fLimitEnabled: BOOL,
    wTimeLimit: u32,
    fMCIControl: BOOL,
    fStepMCIDevice: BOOL,
    dwMCIStartTime: u32,
    dwMCIStopTime: u32,
    fStepCaptureAt2x: BOOL,
    wStepCaptureAverageFrames: u32,
    dwAudioBufferSize: u32,
    fDisableWriteCache: BOOL,
    AVStreamMaster: u32,
};

pub const CAPINFOCHUNK = extern struct {
    fccInfoID: u32,
    lpData: *c_void,
    cbData: i32,
};

pub const CAPYIELDCALLBACK = fn(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPSTATUSCALLBACKW = fn(
    hWnd: HWND,
    nID: i32,
    lpsz: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPERRORCALLBACKW = fn(
    hWnd: HWND,
    nID: i32,
    lpsz: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPSTATUSCALLBACKA = fn(
    hWnd: HWND,
    nID: i32,
    lpsz: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPERRORCALLBACKA = fn(
    hWnd: HWND,
    nID: i32,
    lpsz: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPVIDEOCALLBACK = fn(
    hWnd: HWND,
    lpVHdr: *VIDEOHDR,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPWAVECALLBACK = fn(
    hWnd: HWND,
    lpWHdr: *WAVEHDR,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const CAPCONTROLCALLBACK = fn(
    hWnd: HWND,
    nState: i32,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const DRVM_IOCTL_DATA = extern struct {
    dwSize: u32,
    dwCmd: u32,
};

pub const WAVEOPENDESC = extern struct {
    hWave: ?*c_void,
    lpFormat: *WAVEFORMAT,
    dwCallback: ?*c_void,
    dwInstance: ?*c_void,
    uMappedDeviceID: u32,
    dnDevNode: ?*c_void,
};

pub const midiopenstrmid_tag = extern struct {
    dwStreamID: u32,
    uDeviceID: u32,
};

pub const tMIXEROPENDESC = extern struct {
    hmx: HMIXER,
    pReserved0: *c_void,
    dwCallback: ?*c_void,
    dwInstance: ?*c_void,
    dnDevNode: ?*c_void,
};

pub const timerevent_tag = extern struct {
    wDelay: u16,
    wResolution: u16,
    lpFunction: LPTIMECALLBACK,
    dwUser: u32,
    wFlags: u16,
    wReserved1: u16,
};

pub const joypos_tag = extern struct {
    dwX: u32,
    dwY: u32,
    dwZ: u32,
    dwR: u32,
    dwU: u32,
    dwV: u32,
};

pub const joyrange_tag = extern struct {
    jpMin: joypos_tag,
    jpMax: joypos_tag,
    jpCenter: joypos_tag,
};

pub const joyreguservalues_tag = extern struct {
    dwTimeOut: u32,
    jrvRanges: joyrange_tag,
    jpDeadZone: joypos_tag,
};

pub const joyreghwsettings_tag = extern struct {
    dwFlags: u32,
    dwNumButtons: u32,
};

pub const joyreghwconfig_tag = extern struct {
    hws: joyreghwsettings_tag,
    dwUsageSettings: u32,
    hwv: JOYREGHWVALUES,
    dwType: u32,
    dwReserved: u32,
};

pub const joycalibrate_tag = extern struct {
    wXbase: u16,
    wXdelta: u16,
    wYbase: u16,
    wYdelta: u16,
    wZbase: u16,
    wZdelta: u16,
};

pub const JOYDEVMSGPROC = fn(
    param0: u32,
    param1: u32,
    param2: i32,
    param3: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPJOYDEVMSGPROC = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const MCI_OPEN_DRIVER_PARMS = extern struct {
    wDeviceID: u32,
    lpstrParams: [*:0]const u16,
    wCustomCommandTable: u32,
    wType: u32,
};

pub const TASKCALLBACK = fn(
    dwInst: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPTASKCALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const HMIDI = ?*c_void;

pub const HMIDIIN = ?*c_void;

pub const HMIDIOUT = ?*c_void;

pub const HMIDISTRM = ?*c_void;

pub const HMIXER = ?*c_void;

pub const HMIXEROBJ = ?*c_void;

pub const HWAVEIN = ?*c_void;

pub const HWAVEOUT = ?*c_void;


//--------------------------------------------------------------------------------
// Section: Functions (305)
//--------------------------------------------------------------------------------
pub extern "WINMM" fn CloseDriver(
    hDriver: ?*c_void,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "WINMM" fn OpenDriver(
    szDriverName: [*:0]const u16,
    szSectionName: [*:0]const u16,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "WINMM" fn SendDriverMessage(
    hDriver: ?*c_void,
    message: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "WINMM" fn DrvGetModuleHandle(
    hDriver: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "WINMM" fn GetDriverModuleHandle(
    hDriver: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "WINMM" fn DefDriverProc(
    dwDriverIdentifier: ?*c_void,
    hdrvr: ?*c_void,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "WINMM" fn DriverCallback(
    dwCallback: ?*c_void,
    dwFlags: u32,
    hDevice: ?*c_void,
    dwMsg: u32,
    dwUser: ?*c_void,
    dwParam1: ?*c_void,
    dwParam2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-mm-misc-l1-1-1" fn sndOpenSound(
    EventName: [*:0]const u16,
    AppName: [*:0]const u16,
    Flags: i32,
    FileHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINMM" fn mmDrvInstall(
    hDriver: ?*c_void,
    wszDrvEntry: [*:0]const u16,
    drvMessage: DRIVERMSGPROC,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioStringToFOURCCA(
    sz: [*:0]const u8,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioStringToFOURCCW(
    sz: [*:0]const u16,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioInstallIOProcA(
    fccIOProc: u32,
    pIOProc: ?LPMMIOPROC,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LPMMIOPROC;

pub extern "WINMM" fn mmioInstallIOProcW(
    fccIOProc: u32,
    pIOProc: ?LPMMIOPROC,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LPMMIOPROC;

pub extern "WINMM" fn mmioOpenA(
    pszFileName: ?*[128]u8,
    pmmioinfo: ?*MMIOINFO,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) *HMMIO__;

pub extern "WINMM" fn mmioOpenW(
    pszFileName: ?*[128]u16,
    pmmioinfo: ?*MMIOINFO,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) *HMMIO__;

pub extern "WINMM" fn mmioRenameA(
    pszFileName: [*:0]const u8,
    pszNewFileName: [*:0]const u8,
    pmmioinfo: ?*MMIOINFO,
    fdwRename: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioRenameW(
    pszFileName: [*:0]const u16,
    pszNewFileName: [*:0]const u16,
    pmmioinfo: ?*MMIOINFO,
    fdwRename: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioClose(
    hmmio: *HMMIO__,
    fuClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioRead(
    hmmio: *HMMIO__,
    pch: [*]i8,
    cch: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINMM" fn mmioWrite(
    hmmio: *HMMIO__,
    pch: [*]const i8,
    cch: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINMM" fn mmioSeek(
    hmmio: *HMMIO__,
    lOffset: i32,
    iOrigin: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINMM" fn mmioGetInfo(
    hmmio: *HMMIO__,
    pmmioinfo: *MMIOINFO,
    fuInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioSetInfo(
    hmmio: *HMMIO__,
    pmmioinfo: *MMIOINFO,
    fuInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioSetBuffer(
    hmmio: *HMMIO__,
    pchBuffer: ?[*:0]u8,
    cchBuffer: i32,
    fuBuffer: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioFlush(
    hmmio: *HMMIO__,
    fuFlush: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioAdvance(
    hmmio: *HMMIO__,
    pmmioinfo: ?*MMIOINFO,
    fuAdvance: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioSendMessage(
    hmmio: *HMMIO__,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "WINMM" fn mmioDescend(
    hmmio: *HMMIO__,
    pmmcki: *MMCKINFO,
    pmmckiParent: ?*const MMCKINFO,
    fuDescend: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioAscend(
    hmmio: *HMMIO__,
    pmmcki: *MMCKINFO,
    fuAscend: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmioCreateChunk(
    hmmio: *HMMIO__,
    pmmcki: *MMCKINFO,
    fuCreate: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn sndPlaySoundA(
    pszSound: ?[*:0]const u8,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn sndPlaySoundW(
    pszSound: ?[*:0]const u16,
    fuSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn PlaySoundA(
    pszSound: ?[*:0]const u8,
    hmod: ?*c_void,
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn PlaySoundW(
    pszSound: ?[*:0]const u16,
    hmod: ?*c_void,
    fdwSound: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn waveOutGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetDevCapsA(
    uDeviceID: ?*c_void,
    pwoc: *WAVEOUTCAPSA,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetDevCapsW(
    uDeviceID: ?*c_void,
    pwoc: *WAVEOUTCAPSW,
    cbwoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetVolume(
    hwo: HWAVEOUT,
    pdwVolume: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutSetVolume(
    hwo: HWAVEOUT,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutOpen(
    phwo: ?*HWAVEOUT,
    uDeviceID: u32,
    pwfx: *WAVEFORMATEX,
    dwCallback: ?*c_void,
    dwInstance: ?*c_void,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutClose(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutPrepareHeader(
    hwo: HWAVEOUT,
    pwh: [*]WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutUnprepareHeader(
    hwo: HWAVEOUT,
    pwh: [*]WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutWrite(
    hwo: HWAVEOUT,
    pwh: [*]WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutPause(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutRestart(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutReset(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutBreakLoop(
    hwo: HWAVEOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetPosition(
    hwo: HWAVEOUT,
    pmmt: [*]MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetPitch(
    hwo: HWAVEOUT,
    pdwPitch: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutSetPitch(
    hwo: HWAVEOUT,
    dwPitch: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetPlaybackRate(
    hwo: HWAVEOUT,
    pdwRate: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutSetPlaybackRate(
    hwo: HWAVEOUT,
    dwRate: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutGetID(
    hwo: HWAVEOUT,
    puDeviceID: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveOutMessage(
    hwo: HWAVEOUT,
    uMsg: u32,
    dw1: ?*c_void,
    dw2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetDevCapsA(
    uDeviceID: ?*c_void,
    pwic: [*]WAVEINCAPSA,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetDevCapsW(
    uDeviceID: ?*c_void,
    pwic: [*]WAVEINCAPSW,
    cbwic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInOpen(
    phwi: ?*HWAVEIN,
    uDeviceID: u32,
    pwfx: *WAVEFORMATEX,
    dwCallback: ?*c_void,
    dwInstance: ?*c_void,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInClose(
    hwi: HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInPrepareHeader(
    hwi: HWAVEIN,
    pwh: [*]WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInUnprepareHeader(
    hwi: HWAVEIN,
    pwh: [*]WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInAddBuffer(
    hwi: HWAVEIN,
    pwh: [*]WAVEHDR,
    cbwh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInStart(
    hwi: HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInStop(
    hwi: HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInReset(
    hwi: HWAVEIN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetPosition(
    hwi: HWAVEIN,
    pmmt: [*]MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInGetID(
    hwi: HWAVEIN,
    puDeviceID: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn waveInMessage(
    hwi: HWAVEIN,
    uMsg: u32,
    dw1: ?*c_void,
    dw2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiStreamOpen(
    phms: *HMIDISTRM,
    puDeviceID: [*]u32,
    cMidi: u32,
    dwCallback: ?*c_void,
    dwInstance: ?*c_void,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiStreamClose(
    hms: HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiStreamProperty(
    hms: HMIDISTRM,
    lppropdata: *u8,
    dwProperty: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiStreamPosition(
    hms: HMIDISTRM,
    lpmmt: [*]MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiStreamOut(
    hms: HMIDISTRM,
    pmh: [*]MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiStreamPause(
    hms: HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiStreamRestart(
    hms: HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiStreamStop(
    hms: HMIDISTRM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiConnect(
    hmi: HMIDI,
    hmo: HMIDIOUT,
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiDisconnect(
    hmi: HMIDI,
    hmo: HMIDIOUT,
    pReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutGetDevCapsA(
    uDeviceID: ?*c_void,
    pmoc: [*]MIDIOUTCAPSA,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutGetDevCapsW(
    uDeviceID: ?*c_void,
    pmoc: [*]MIDIOUTCAPSW,
    cbmoc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutGetVolume(
    hmo: HMIDIOUT,
    pdwVolume: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutSetVolume(
    hmo: HMIDIOUT,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutOpen(
    phmo: *HMIDIOUT,
    uDeviceID: u32,
    dwCallback: ?*c_void,
    dwInstance: ?*c_void,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutClose(
    hmo: HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutPrepareHeader(
    hmo: HMIDIOUT,
    pmh: [*]MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutUnprepareHeader(
    hmo: HMIDIOUT,
    pmh: [*]MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutShortMsg(
    hmo: HMIDIOUT,
    dwMsg: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutLongMsg(
    hmo: HMIDIOUT,
    pmh: [*]MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutReset(
    hmo: HMIDIOUT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutCachePatches(
    hmo: HMIDIOUT,
    uBank: u32,
    pwpa: *[128]u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutCacheDrumPatches(
    hmo: HMIDIOUT,
    uPatch: u32,
    pwkya: *[128]u16,
    fuCache: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutGetID(
    hmo: HMIDIOUT,
    puDeviceID: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiOutMessage(
    hmo: HMIDIOUT,
    uMsg: u32,
    dw1: ?*c_void,
    dw2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInGetDevCapsA(
    uDeviceID: ?*c_void,
    pmic: [*]MIDIINCAPSA,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInGetDevCapsW(
    uDeviceID: ?*c_void,
    pmic: [*]MIDIINCAPSW,
    cbmic: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInGetErrorTextA(
    mmrError: u32,
    pszText: [*:0]u8,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInGetErrorTextW(
    mmrError: u32,
    pszText: [*:0]u16,
    cchText: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInOpen(
    phmi: *HMIDIIN,
    uDeviceID: u32,
    dwCallback: ?*c_void,
    dwInstance: ?*c_void,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInClose(
    hmi: HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInPrepareHeader(
    hmi: HMIDIIN,
    pmh: [*]MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInUnprepareHeader(
    hmi: HMIDIIN,
    pmh: [*]MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInAddBuffer(
    hmi: HMIDIIN,
    pmh: [*]MIDIHDR,
    cbmh: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInStart(
    hmi: HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInStop(
    hmi: HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInReset(
    hmi: HMIDIIN,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInGetID(
    hmi: HMIDIIN,
    puDeviceID: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn midiInMessage(
    hmi: HMIDIIN,
    uMsg: u32,
    dw1: ?*c_void,
    dw2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn auxGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn auxGetDevCapsA(
    uDeviceID: ?*c_void,
    pac: [*]AUXCAPSA,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn auxGetDevCapsW(
    uDeviceID: ?*c_void,
    pac: [*]AUXCAPSW,
    cbac: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn auxSetVolume(
    uDeviceID: u32,
    dwVolume: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn auxGetVolume(
    uDeviceID: u32,
    pdwVolume: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn auxOutMessage(
    uDeviceID: u32,
    uMsg: u32,
    dw1: ?*c_void,
    dw2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetDevCapsA(
    uMxId: ?*c_void,
    pmxcaps: [*]MIXERCAPSA,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetDevCapsW(
    uMxId: ?*c_void,
    pmxcaps: [*]MIXERCAPSW,
    cbmxcaps: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerOpen(
    phmx: ?*?*c_void,
    uMxId: u32,
    dwCallback: ?*c_void,
    dwInstance: ?*c_void,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerClose(
    hmx: HMIXER,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerMessage(
    hmx: HMIXER,
    uMsg: u32,
    dwParam1: ?*c_void,
    dwParam2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetLineInfoA(
    hmxobj: HMIXEROBJ,
    pmxl: *MIXERLINEA,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetLineInfoW(
    hmxobj: HMIXEROBJ,
    pmxl: *MIXERLINEW,
    fdwInfo: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetID(
    hmxobj: HMIXEROBJ,
    puMxId: *u32,
    fdwId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetLineControlsA(
    hmxobj: HMIXEROBJ,
    pmxlc: *MIXERLINECONTROLSA,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetLineControlsW(
    hmxobj: HMIXEROBJ,
    pmxlc: *MIXERLINECONTROLSW,
    fdwControls: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetControlDetailsA(
    hmxobj: HMIXEROBJ,
    pmxcd: *MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerGetControlDetailsW(
    hmxobj: HMIXEROBJ,
    pmxcd: *MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mixerSetControlDetails(
    hmxobj: HMIXEROBJ,
    pmxcd: *MIXERCONTROLDETAILS,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn timeGetSystemTime(
    pmmt: [*]MMTIME,
    cbmmt: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn timeGetTime(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn timeGetDevCaps(
    ptc: [*]TIMECAPS,
    cbtc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn timeBeginPeriod(
    uPeriod: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn timeEndPeriod(
    uPeriod: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joyGetPosEx(
    uJoyID: u32,
    pji: *JOYINFOEX,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joyGetNumDevs(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joyGetDevCapsA(
    uJoyID: ?*c_void,
    pjc: [*]JOYCAPSA,
    cbjc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joyGetDevCapsW(
    uJoyID: ?*c_void,
    pjc: [*]JOYCAPSW,
    cbjc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joyGetPos(
    uJoyID: u32,
    pji: *JOYINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joyGetThreshold(
    uJoyID: u32,
    puThreshold: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joyReleaseCapture(
    uJoyID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joySetCapture(
    hwnd: HWND,
    uJoyID: u32,
    uPeriod: u32,
    fChanged: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joySetThreshold(
    uJoyID: u32,
    uThreshold: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmGetVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmMetrics(
    hao: *HACMOBJ__,
    uMetric: u32,
    pMetric: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverEnum(
    fnCallback: ACMDRIVERENUMCB,
    dwInstance: ?*c_void,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverID(
    hao: *HACMOBJ__,
    phadid: **HACMDRIVERID__,
    fdwDriverID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverAddA(
    phadid: **HACMDRIVERID__,
    hinstModule: HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverAddW(
    phadid: **HACMDRIVERID__,
    hinstModule: HINSTANCE,
    lParam: LPARAM,
    dwPriority: u32,
    fdwAdd: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverRemove(
    hadid: *HACMDRIVERID__,
    fdwRemove: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverOpen(
    phad: **HACMDRIVER__,
    hadid: *HACMDRIVERID__,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverClose(
    had: *HACMDRIVER__,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverMessage(
    had: *HACMDRIVER__,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "MSACM32" fn acmDriverPriority(
    hadid: *HACMDRIVERID__,
    dwPriority: u32,
    fdwPriority: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverDetailsA(
    hadid: *HACMDRIVERID__,
    padd: *tACMDRIVERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmDriverDetailsW(
    hadid: *HACMDRIVERID__,
    padd: *tACMDRIVERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatTagDetailsA(
    had: *HACMDRIVER__,
    paftd: *tACMFORMATTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatTagDetailsW(
    had: *HACMDRIVER__,
    paftd: *tACMFORMATTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatTagEnumA(
    had: *HACMDRIVER__,
    paftd: *tACMFORMATTAGDETAILSA,
    fnCallback: ACMFORMATTAGENUMCBA,
    dwInstance: ?*c_void,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatTagEnumW(
    had: *HACMDRIVER__,
    paftd: *tACMFORMATTAGDETAILSW,
    fnCallback: ACMFORMATTAGENUMCBW,
    dwInstance: ?*c_void,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatDetailsA(
    had: *HACMDRIVER__,
    pafd: *tACMFORMATDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatDetailsW(
    had: *HACMDRIVER__,
    pafd: *tACMFORMATDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatEnumA(
    had: *HACMDRIVER__,
    pafd: *tACMFORMATDETAILSA,
    fnCallback: ACMFORMATENUMCBA,
    dwInstance: ?*c_void,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatEnumW(
    had: *HACMDRIVER__,
    pafd: *tACMFORMATDETAILSW,
    fnCallback: ACMFORMATENUMCBW,
    dwInstance: ?*c_void,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatSuggest(
    had: *HACMDRIVER__,
    pwfxSrc: *WAVEFORMATEX,
    pwfxDst: *WAVEFORMATEX,
    cbwfxDst: u32,
    fdwSuggest: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatChooseA(
    pafmtc: *tACMFORMATCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFormatChooseW(
    pafmtc: *tACMFORMATCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterTagDetailsA(
    had: *HACMDRIVER__,
    paftd: *tACMFILTERTAGDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterTagDetailsW(
    had: *HACMDRIVER__,
    paftd: *tACMFILTERTAGDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterTagEnumA(
    had: *HACMDRIVER__,
    paftd: *tACMFILTERTAGDETAILSA,
    fnCallback: ACMFILTERTAGENUMCBA,
    dwInstance: ?*c_void,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterTagEnumW(
    had: *HACMDRIVER__,
    paftd: *tACMFILTERTAGDETAILSW,
    fnCallback: ACMFILTERTAGENUMCBW,
    dwInstance: ?*c_void,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterDetailsA(
    had: *HACMDRIVER__,
    pafd: *tACMFILTERDETAILSA,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterDetailsW(
    had: *HACMDRIVER__,
    pafd: *tACMFILTERDETAILSW,
    fdwDetails: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterEnumA(
    had: *HACMDRIVER__,
    pafd: *tACMFILTERDETAILSA,
    fnCallback: ACMFILTERENUMCBA,
    dwInstance: ?*c_void,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterEnumW(
    had: *HACMDRIVER__,
    pafd: *tACMFILTERDETAILSW,
    fnCallback: ACMFILTERENUMCBW,
    dwInstance: ?*c_void,
    fdwEnum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterChooseA(
    pafltrc: *tACMFILTERCHOOSEA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmFilterChooseW(
    pafltrc: *tACMFILTERCHOOSEW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmStreamOpen(
    phas: **HACMSTREAM__,
    had: *HACMDRIVER__,
    pwfxSrc: *WAVEFORMATEX,
    pwfxDst: *WAVEFORMATEX,
    pwfltr: *WAVEFILTER,
    dwCallback: ?*c_void,
    dwInstance: ?*c_void,
    fdwOpen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmStreamClose(
    has: *HACMSTREAM__,
    fdwClose: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmStreamSize(
    has: *HACMSTREAM__,
    cbInput: u32,
    pdwOutputBytes: *u32,
    fdwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmStreamReset(
    has: *HACMSTREAM__,
    fdwReset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmStreamMessage(
    has: *HACMSTREAM__,
    uMsg: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmStreamConvert(
    has: *HACMSTREAM__,
    pash: *ACMSTREAMHEADER,
    fdwConvert: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmStreamPrepareHeader(
    has: *HACMSTREAM__,
    pash: *ACMSTREAMHEADER,
    fdwPrepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSACM32" fn acmStreamUnprepareHeader(
    has: *HACMSTREAM__,
    pash: *ACMSTREAMHEADER,
    fdwUnprepare: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSVFW32" fn VideoForWindowsVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSVFW32" fn ICInfo(
    fccType: u32,
    fccHandler: u32,
    lpicinfo: *ICINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn ICInstall(
    fccType: u32,
    fccHandler: u32,
    lParam: LPARAM,
    szDesc: PSTR,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn ICRemove(
    fccType: u32,
    fccHandler: u32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn ICGetInfo(
    hic: *HIC__,
    picinfo: [*]ICINFO,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "MSVFW32" fn ICOpen(
    fccType: u32,
    fccHandler: u32,
    wMode: u32,
) callconv(@import("std").os.windows.WINAPI) *HIC__;

pub extern "MSVFW32" fn ICOpenFunction(
    fccType: u32,
    fccHandler: u32,
    wMode: u32,
    lpfnHandler: FARPROC,
) callconv(@import("std").os.windows.WINAPI) *HIC__;

pub extern "MSVFW32" fn ICClose(
    hic: *HIC__,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "MSVFW32" fn ICSendMessage(
    hic: *HIC__,
    msg: u32,
    dw1: ?*c_void,
    dw2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "MSVFW32" fn ICCompress(
    hic: *HIC__,
    dwFlags: u32,
    lpbiOutput: *BITMAPINFOHEADER,
    lpData: *c_void,
    lpbiInput: *BITMAPINFOHEADER,
    lpBits: *c_void,
    lpckid: ?*u32,
    lpdwFlags: ?*u32,
    lFrameNum: i32,
    dwFrameSize: u32,
    dwQuality: u32,
    lpbiPrev: ?*BITMAPINFOHEADER,
    lpPrev: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSVFW32" fn ICDecompress(
    hic: *HIC__,
    dwFlags: u32,
    lpbiFormat: *BITMAPINFOHEADER,
    lpData: *c_void,
    lpbi: *BITMAPINFOHEADER,
    lpBits: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSVFW32" fn ICDrawBegin(
    hic: *HIC__,
    dwFlags: u32,
    hpal: HPALETTE,
    hwnd: HWND,
    hdc: HDC,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    lpbi: *BITMAPINFOHEADER,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
    dwRate: u32,
    dwScale: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSVFW32" fn ICDraw(
    hic: *HIC__,
    dwFlags: u32,
    lpFormat: *c_void,
    lpData: ?[*]u8,
    cbData: u32,
    lTime: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSVFW32" fn ICLocate(
    fccType: u32,
    fccHandler: u32,
    lpbiIn: *BITMAPINFOHEADER,
    lpbiOut: ?*BITMAPINFOHEADER,
    wFlags: u16,
) callconv(@import("std").os.windows.WINAPI) *HIC__;

pub extern "MSVFW32" fn ICGetDisplayFormat(
    hic: ?*HIC__,
    lpbiIn: *BITMAPINFOHEADER,
    lpbiOut: *BITMAPINFOHEADER,
    BitDepth: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) *HIC__;

pub extern "MSVFW32" fn ICImageCompress(
    hic: *HIC__,
    uiFlags: u32,
    lpbiIn: *BITMAPINFO,
    lpBits: *c_void,
    lpbiOut: ?*BITMAPINFO,
    lQuality: i32,
    plSize: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "MSVFW32" fn ICImageDecompress(
    hic: ?*HIC__,
    uiFlags: u32,
    lpbiIn: *BITMAPINFO,
    lpBits: *c_void,
    lpbiOut: ?*BITMAPINFO,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "MSVFW32" fn ICCompressorChoose(
    hwnd: HWND,
    uiFlags: u32,
    pvIn: ?*c_void,
    lpData: ?*c_void,
    pc: *COMPVARS,
    lpszTitle: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn ICSeqCompressFrameStart(
    pc: *COMPVARS,
    lpbiIn: *BITMAPINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn ICSeqCompressFrameEnd(
    pc: *COMPVARS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MSVFW32" fn ICSeqCompressFrame(
    pc: *COMPVARS,
    uiFlags: u32,
    lpBits: *c_void,
    pfKey: *BOOL,
    plSize: ?*i32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "MSVFW32" fn ICCompressorFree(
    pc: *COMPVARS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MSVFW32" fn DrawDibOpen(
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "MSVFW32" fn DrawDibClose(
    hdd: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn DrawDibGetBuffer(
    hdd: ?*c_void,
    lpbi: *BITMAPINFOHEADER,
    dwSize: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "MSVFW32" fn DrawDibGetPalette(
    hdd: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HPALETTE;

pub extern "MSVFW32" fn DrawDibSetPalette(
    hdd: ?*c_void,
    hpal: HPALETTE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn DrawDibChangePalette(
    hdd: ?*c_void,
    iStart: i32,
    iLen: i32,
    lppe: [*]PALETTEENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn DrawDibRealize(
    hdd: ?*c_void,
    hdc: HDC,
    fBackground: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MSVFW32" fn DrawDibStart(
    hdd: ?*c_void,
    rate: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn DrawDibStop(
    hdd: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn DrawDibBegin(
    hdd: ?*c_void,
    hdc: HDC,
    dxDst: i32,
    dyDst: i32,
    lpbi: *BITMAPINFOHEADER,
    dxSrc: i32,
    dySrc: i32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn DrawDibDraw(
    hdd: ?*c_void,
    hdc: HDC,
    xDst: i32,
    yDst: i32,
    dxDst: i32,
    dyDst: i32,
    lpbi: ?*BITMAPINFOHEADER,
    lpBits: ?*c_void,
    xSrc: i32,
    ySrc: i32,
    dxSrc: i32,
    dySrc: i32,
    wFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn DrawDibEnd(
    hdd: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn DrawDibTime(
    hdd: ?*c_void,
    lpddtime: *DRAWDIBTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn DrawDibProfileDisplay(
    lpbi: *BITMAPINFOHEADER,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "AVIFIL32" fn AVIFileInit(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "AVIFIL32" fn AVIFileExit(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "AVIFIL32" fn AVIFileAddRef(
    pfile: *IAVIFile,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "AVIFIL32" fn AVIFileRelease(
    pfile: *IAVIFile,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "AVIFIL32" fn AVIFileOpenA(
    ppfile: **IAVIFile,
    szFile: [*:0]const u8,
    uMode: u32,
    lpHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIFileOpenW(
    ppfile: **IAVIFile,
    szFile: [*:0]const u16,
    uMode: u32,
    lpHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIFileInfoW(
    pfile: *IAVIFile,
    pfi: [*]AVIFILEINFOW,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIFileInfoA(
    pfile: *IAVIFile,
    pfi: [*]AVIFILEINFOA,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIFileGetStream(
    pfile: *IAVIFile,
    ppavi: **IAVIStream,
    fccType: u32,
    lParam: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIFileCreateStreamW(
    pfile: *IAVIFile,
    ppavi: **IAVIStream,
    psi: *AVISTREAMINFOW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIFileCreateStreamA(
    pfile: *IAVIFile,
    ppavi: **IAVIStream,
    psi: *AVISTREAMINFOA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIFileWriteData(
    pfile: *IAVIFile,
    ckid: u32,
    lpData: [*]u8,
    cbData: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIFileReadData(
    pfile: *IAVIFile,
    ckid: u32,
    lpData: [*]u8,
    lpcbData: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIFileEndRecord(
    pfile: *IAVIFile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamAddRef(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "AVIFIL32" fn AVIStreamRelease(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "AVIFIL32" fn AVIStreamInfoW(
    pavi: *IAVIStream,
    psi: [*]AVISTREAMINFOW,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamInfoA(
    pavi: *IAVIStream,
    psi: [*]AVISTREAMINFOA,
    lSize: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamFindSample(
    pavi: *IAVIStream,
    lPos: i32,
    lFlags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "AVIFIL32" fn AVIStreamReadFormat(
    pavi: *IAVIStream,
    lPos: i32,
    lpFormat: ?[*]u8,
    lpcbFormat: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamSetFormat(
    pavi: *IAVIStream,
    lPos: i32,
    lpFormat: [*]u8,
    cbFormat: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamReadData(
    pavi: *IAVIStream,
    fcc: u32,
    lp: ?[*]u8,
    lpcb: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamWriteData(
    pavi: *IAVIStream,
    fcc: u32,
    lp: [*]u8,
    cb: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamRead(
    pavi: *IAVIStream,
    lStart: i32,
    lSamples: i32,
    lpBuffer: ?[*]u8,
    cbBuffer: i32,
    plBytes: ?*i32,
    plSamples: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamWrite(
    pavi: *IAVIStream,
    lStart: i32,
    lSamples: i32,
    lpBuffer: [*]u8,
    cbBuffer: i32,
    dwFlags: u32,
    plSampWritten: ?*i32,
    plBytesWritten: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamStart(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "AVIFIL32" fn AVIStreamLength(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "AVIFIL32" fn AVIStreamTimeToSample(
    pavi: *IAVIStream,
    lTime: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "AVIFIL32" fn AVIStreamSampleToTime(
    pavi: *IAVIStream,
    lSample: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "AVIFIL32" fn AVIStreamBeginStreaming(
    pavi: *IAVIStream,
    lStart: i32,
    lEnd: i32,
    lRate: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamEndStreaming(
    pavi: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamGetFrameOpen(
    pavi: *IAVIStream,
    lpbiWanted: ?*BITMAPINFOHEADER,
) callconv(@import("std").os.windows.WINAPI) *IGetFrame;

pub extern "AVIFIL32" fn AVIStreamGetFrame(
    pg: *IGetFrame,
    lPos: i32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "AVIFIL32" fn AVIStreamGetFrameClose(
    pg: *IGetFrame,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamOpenFromFileA(
    ppavi: **IAVIStream,
    szFile: [*:0]const u8,
    fccType: u32,
    lParam: i32,
    mode: u32,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamOpenFromFileW(
    ppavi: **IAVIStream,
    szFile: [*:0]const u16,
    fccType: u32,
    lParam: i32,
    mode: u32,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIStreamCreate(
    ppavi: **IAVIStream,
    lParam1: i32,
    lParam2: i32,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIMakeCompressedStream(
    ppsCompressed: **IAVIStream,
    ppsSource: *IAVIStream,
    lpOptions: *AVICOMPRESSOPTIONS,
    pclsidHandler: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVISaveA(
    szFile: [*:0]const u8,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    pfile: *IAVIStream,
    lpOptions: *AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVISaveVA(
    szFile: [*:0]const u8,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    ppavi: [*]*IAVIStream,
    plpOptions: [*]*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVISaveW(
    szFile: [*:0]const u16,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    pfile: *IAVIStream,
    lpOptions: *AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVISaveVW(
    szFile: [*:0]const u16,
    pclsidHandler: ?*Guid,
    lpfnCallback: AVISAVECALLBACK,
    nStreams: i32,
    ppavi: [*]*IAVIStream,
    plpOptions: [*]*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVISaveOptions(
    hwnd: HWND,
    uiFlags: u32,
    nStreams: i32,
    ppavi: [*]*IAVIStream,
    plpOptions: [*]*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "AVIFIL32" fn AVISaveOptionsFree(
    nStreams: i32,
    plpOptions: [*]*AVICOMPRESSOPTIONS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIBuildFilterW(
    lpszFilter: [*:0]u16,
    cbFilter: i32,
    fSaving: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIBuildFilterA(
    lpszFilter: [*:0]u8,
    cbFilter: i32,
    fSaving: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIMakeFileFromStreams(
    ppfile: **IAVIFile,
    nStreams: i32,
    papStreams: [*]*IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIMakeStreamFromClipboard(
    cfFormat: u32,
    hGlobal: HANDLE,
    ppstream: **IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIPutFileOnClipboard(
    pf: *IAVIFile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIGetFromClipboard(
    lppf: **IAVIFile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn AVIClearClipboard(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn CreateEditableStream(
    ppsEditable: **IAVIStream,
    psSource: *IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn EditStreamCut(
    pavi: *IAVIStream,
    plStart: *i32,
    plLength: *i32,
    ppResult: **IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn EditStreamCopy(
    pavi: *IAVIStream,
    plStart: *i32,
    plLength: *i32,
    ppResult: **IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn EditStreamPaste(
    pavi: *IAVIStream,
    plPos: *i32,
    plLength: *i32,
    pstream: *IAVIStream,
    lStart: i32,
    lEnd: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn EditStreamClone(
    pavi: *IAVIStream,
    ppResult: **IAVIStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn EditStreamSetNameA(
    pavi: *IAVIStream,
    lpszName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn EditStreamSetNameW(
    pavi: *IAVIStream,
    lpszName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn EditStreamSetInfoW(
    pavi: *IAVIStream,
    lpInfo: [*]AVISTREAMINFOW,
    cbInfo: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "AVIFIL32" fn EditStreamSetInfoA(
    pavi: *IAVIStream,
    lpInfo: [*]AVISTREAMINFOA,
    cbInfo: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MSVFW32" fn MCIWndCreateA(
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwStyle: u32,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "MSVFW32" fn MCIWndCreateW(
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwStyle: u32,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "MSVFW32" fn MCIWndRegisterClass(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "AVICAP32" fn capCreateCaptureWindowA(
    lpszWindowName: [*:0]const u8,
    dwStyle: u32,
    x: i32,
    y: i32,
    nWidth: i32,
    nHeight: i32,
    hwndParent: HWND,
    nID: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "AVICAP32" fn capGetDriverDescriptionA(
    wDriverIndex: u32,
    lpszName: [*:0]u8,
    cbName: i32,
    lpszVer: [*:0]u8,
    cbVer: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "AVICAP32" fn capCreateCaptureWindowW(
    lpszWindowName: [*:0]const u16,
    dwStyle: u32,
    x: i32,
    y: i32,
    nWidth: i32,
    nHeight: i32,
    hwndParent: HWND,
    nID: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "AVICAP32" fn capGetDriverDescriptionW(
    wDriverIndex: u32,
    lpszName: [*:0]u16,
    cbName: i32,
    lpszVer: [*:0]u16,
    cbVer: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn GetOpenFileNamePreviewA(
    lpofn: *OPENFILENAMEA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn GetSaveFileNamePreviewA(
    lpofn: *OPENFILENAMEA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn GetOpenFileNamePreviewW(
    lpofn: *OPENFILENAMEW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSVFW32" fn GetSaveFileNamePreviewW(
    lpofn: *OPENFILENAMEW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn mmTaskCreate(
    lpfn: LPTASKCALLBACK,
    lph: *HANDLE,
    dwInst: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn mmTaskBlock(
    h: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WINMM" fn mmTaskSignal(
    h: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINMM" fn mmTaskYield(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WINMM" fn mmGetCurrentTask(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn joyConfigChanged(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (94)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const WAVEOUTCAPS = WAVEOUTCAPSA;
        pub const WAVEOUTCAPS2 = WAVEOUTCAPS2A;
        pub const WAVEINCAPS = WAVEINCAPSA;
        pub const WAVEINCAPS2 = WAVEINCAPS2A;
        pub const MIDIOUTCAPS = MIDIOUTCAPSA;
        pub const MIDIOUTCAPS2 = MIDIOUTCAPS2A;
        pub const MIDIINCAPS = MIDIINCAPSA;
        pub const MIDIINCAPS2 = MIDIINCAPS2A;
        pub const AUXCAPS = AUXCAPSA;
        pub const AUXCAPS2 = AUXCAPS2A;
        pub const MIXERCAPS = MIXERCAPSA;
        pub const MIXERCAPS2 = MIXERCAPS2A;
        pub const MIXERLINE = MIXERLINEA;
        pub const MIXERCONTROL = MIXERCONTROLA;
        pub const MIXERLINECONTROLS = MIXERLINECONTROLSA;
        pub const MIXERCONTROLDETAILS_LISTTEXT = MIXERCONTROLDETAILS_LISTTEXTA;
        pub const JOYCAPS = JOYCAPSA;
        pub const JOYCAPS2 = JOYCAPS2A;
        pub const MCI_DGV_CAPTURE_PARMS = MCI_DGV_CAPTURE_PARMSA;
        pub const MCI_DGV_INFO_PARMS = MCI_DGV_INFO_PARMSA;
        pub const MCI_DGV_LIST_PARMS = MCI_DGV_LIST_PARMSA;
        pub const MCI_DGV_OPEN_PARMS = MCI_DGV_OPEN_PARMSA;
        pub const MCI_DGV_QUALITY_PARMS = MCI_DGV_QUALITY_PARMSA;
        pub const MCI_DGV_RESERVE_PARMS = MCI_DGV_RESERVE_PARMSA;
        pub const MCI_DGV_RESTORE_PARMS = MCI_DGV_RESTORE_PARMSA;
        pub const MCI_DGV_SAVE_PARMS = MCI_DGV_SAVE_PARMSA;
        pub const MCI_DGV_SETAUDIO_PARMS = MCI_DGV_SETAUDIO_PARMSA;
        pub const MCI_DGV_SETVIDEO_PARMS = MCI_DGV_SETVIDEO_PARMSA;
        pub const MCI_DGV_STATUS_PARMS = MCI_DGV_STATUS_PARMSA;
        pub const MCI_DGV_WINDOW_PARMS = MCI_DGV_WINDOW_PARMSA;
        pub const tACMDRIVERDETAILS = tACMDRIVERDETAILSA;
        pub const tACMFORMATTAGDETAILS = tACMFORMATTAGDETAILSA;
        pub const ACMFORMATTAGENUMCB = ACMFORMATTAGENUMCBA;
        pub const tACMFORMATDETAILS = tACMFORMATDETAILSA;
        pub const ACMFORMATENUMCB = ACMFORMATENUMCBA;
        pub const ACMFORMATCHOOSEHOOKPROC = ACMFORMATCHOOSEHOOKPROCA;
        pub const tACMFORMATCHOOSE = tACMFORMATCHOOSEA;
        pub const tACMFILTERTAGDETAILS = tACMFILTERTAGDETAILSA;
        pub const ACMFILTERTAGENUMCB = ACMFILTERTAGENUMCBA;
        pub const tACMFILTERDETAILS = tACMFILTERDETAILSA;
        pub const ACMFILTERENUMCB = ACMFILTERENUMCBA;
        pub const ACMFILTERCHOOSEHOOKPROC = ACMFILTERCHOOSEHOOKPROCA;
        pub const tACMFILTERCHOOSE = tACMFILTERCHOOSEA;
        pub const AVISTREAMINFO = AVISTREAMINFOA;
        pub const AVIFILEINFO = AVIFILEINFOA;
        pub const CAPSTATUSCALLBACK = CAPSTATUSCALLBACKA;
        pub const CAPERRORCALLBACK = CAPERRORCALLBACKA;
        pub const mmioStringToFOURCC = mmioStringToFOURCCA;
        pub const mmioInstallIOProc = mmioInstallIOProcA;
        pub const mmioOpen = mmioOpenA;
        pub const mmioRename = mmioRenameA;
        pub const sndPlaySound = sndPlaySoundA;
        pub const PlaySound = PlaySoundA;
        pub const waveOutGetDevCaps = waveOutGetDevCapsA;
        pub const waveOutGetErrorText = waveOutGetErrorTextA;
        pub const waveInGetDevCaps = waveInGetDevCapsA;
        pub const waveInGetErrorText = waveInGetErrorTextA;
        pub const midiOutGetDevCaps = midiOutGetDevCapsA;
        pub const midiOutGetErrorText = midiOutGetErrorTextA;
        pub const midiInGetDevCaps = midiInGetDevCapsA;
        pub const midiInGetErrorText = midiInGetErrorTextA;
        pub const auxGetDevCaps = auxGetDevCapsA;
        pub const mixerGetDevCaps = mixerGetDevCapsA;
        pub const mixerGetLineInfo = mixerGetLineInfoA;
        pub const mixerGetLineControls = mixerGetLineControlsA;
        pub const mixerGetControlDetails = mixerGetControlDetailsA;
        pub const joyGetDevCaps = joyGetDevCapsA;
        pub const acmDriverAdd = acmDriverAddA;
        pub const acmDriverDetails = acmDriverDetailsA;
        pub const acmFormatTagDetails = acmFormatTagDetailsA;
        pub const acmFormatTagEnum = acmFormatTagEnumA;
        pub const acmFormatDetails = acmFormatDetailsA;
        pub const acmFormatEnum = acmFormatEnumA;
        pub const acmFormatChoose = acmFormatChooseA;
        pub const acmFilterTagDetails = acmFilterTagDetailsA;
        pub const acmFilterTagEnum = acmFilterTagEnumA;
        pub const acmFilterDetails = acmFilterDetailsA;
        pub const acmFilterEnum = acmFilterEnumA;
        pub const acmFilterChoose = acmFilterChooseA;
        pub const AVIFileOpen = AVIFileOpenA;
        pub const AVIFileInfo = AVIFileInfoA;
        pub const AVIFileCreateStream = AVIFileCreateStreamA;
        pub const AVIStreamInfo = AVIStreamInfoA;
        pub const AVIStreamOpenFromFile = AVIStreamOpenFromFileA;
        pub const AVISave = AVISaveA;
        pub const AVISaveV = AVISaveVA;
        pub const AVIBuildFilter = AVIBuildFilterA;
        pub const EditStreamSetName = EditStreamSetNameA;
        pub const EditStreamSetInfo = EditStreamSetInfoA;
        pub const MCIWndCreate = MCIWndCreateA;
        pub const capCreateCaptureWindow = capCreateCaptureWindowA;
        pub const capGetDriverDescription = capGetDriverDescriptionA;
        pub const GetOpenFileNamePreview = GetOpenFileNamePreviewA;
        pub const GetSaveFileNamePreview = GetSaveFileNamePreviewA;
    },
    .wide => struct {
        pub const WAVEOUTCAPS = WAVEOUTCAPSW;
        pub const WAVEOUTCAPS2 = WAVEOUTCAPS2W;
        pub const WAVEINCAPS = WAVEINCAPSW;
        pub const WAVEINCAPS2 = WAVEINCAPS2W;
        pub const MIDIOUTCAPS = MIDIOUTCAPSW;
        pub const MIDIOUTCAPS2 = MIDIOUTCAPS2W;
        pub const MIDIINCAPS = MIDIINCAPSW;
        pub const MIDIINCAPS2 = MIDIINCAPS2W;
        pub const AUXCAPS = AUXCAPSW;
        pub const AUXCAPS2 = AUXCAPS2W;
        pub const MIXERCAPS = MIXERCAPSW;
        pub const MIXERCAPS2 = MIXERCAPS2W;
        pub const MIXERLINE = MIXERLINEW;
        pub const MIXERCONTROL = MIXERCONTROLW;
        pub const MIXERLINECONTROLS = MIXERLINECONTROLSW;
        pub const MIXERCONTROLDETAILS_LISTTEXT = MIXERCONTROLDETAILS_LISTTEXTW;
        pub const JOYCAPS = JOYCAPSW;
        pub const JOYCAPS2 = JOYCAPS2W;
        pub const MCI_DGV_CAPTURE_PARMS = MCI_DGV_CAPTURE_PARMSW;
        pub const MCI_DGV_INFO_PARMS = MCI_DGV_INFO_PARMSW;
        pub const MCI_DGV_LIST_PARMS = MCI_DGV_LIST_PARMSW;
        pub const MCI_DGV_OPEN_PARMS = MCI_DGV_OPEN_PARMSW;
        pub const MCI_DGV_QUALITY_PARMS = MCI_DGV_QUALITY_PARMSW;
        pub const MCI_DGV_RESERVE_PARMS = MCI_DGV_RESERVE_PARMSW;
        pub const MCI_DGV_RESTORE_PARMS = MCI_DGV_RESTORE_PARMSW;
        pub const MCI_DGV_SAVE_PARMS = MCI_DGV_SAVE_PARMSW;
        pub const MCI_DGV_SETAUDIO_PARMS = MCI_DGV_SETAUDIO_PARMSW;
        pub const MCI_DGV_SETVIDEO_PARMS = MCI_DGV_SETVIDEO_PARMSW;
        pub const MCI_DGV_STATUS_PARMS = MCI_DGV_STATUS_PARMSW;
        pub const MCI_DGV_WINDOW_PARMS = MCI_DGV_WINDOW_PARMSW;
        pub const tACMDRIVERDETAILS = tACMDRIVERDETAILSW;
        pub const tACMFORMATTAGDETAILS = tACMFORMATTAGDETAILSW;
        pub const ACMFORMATTAGENUMCB = ACMFORMATTAGENUMCBW;
        pub const tACMFORMATDETAILS = tACMFORMATDETAILSW;
        pub const ACMFORMATENUMCB = ACMFORMATENUMCBW;
        pub const ACMFORMATCHOOSEHOOKPROC = ACMFORMATCHOOSEHOOKPROCW;
        pub const tACMFORMATCHOOSE = tACMFORMATCHOOSEW;
        pub const tACMFILTERTAGDETAILS = tACMFILTERTAGDETAILSW;
        pub const ACMFILTERTAGENUMCB = ACMFILTERTAGENUMCBW;
        pub const tACMFILTERDETAILS = tACMFILTERDETAILSW;
        pub const ACMFILTERENUMCB = ACMFILTERENUMCBW;
        pub const ACMFILTERCHOOSEHOOKPROC = ACMFILTERCHOOSEHOOKPROCW;
        pub const tACMFILTERCHOOSE = tACMFILTERCHOOSEW;
        pub const AVISTREAMINFO = AVISTREAMINFOW;
        pub const AVIFILEINFO = AVIFILEINFOW;
        pub const CAPSTATUSCALLBACK = CAPSTATUSCALLBACKW;
        pub const CAPERRORCALLBACK = CAPERRORCALLBACKW;
        pub const mmioStringToFOURCC = mmioStringToFOURCCW;
        pub const mmioInstallIOProc = mmioInstallIOProcW;
        pub const mmioOpen = mmioOpenW;
        pub const mmioRename = mmioRenameW;
        pub const sndPlaySound = sndPlaySoundW;
        pub const PlaySound = PlaySoundW;
        pub const waveOutGetDevCaps = waveOutGetDevCapsW;
        pub const waveOutGetErrorText = waveOutGetErrorTextW;
        pub const waveInGetDevCaps = waveInGetDevCapsW;
        pub const waveInGetErrorText = waveInGetErrorTextW;
        pub const midiOutGetDevCaps = midiOutGetDevCapsW;
        pub const midiOutGetErrorText = midiOutGetErrorTextW;
        pub const midiInGetDevCaps = midiInGetDevCapsW;
        pub const midiInGetErrorText = midiInGetErrorTextW;
        pub const auxGetDevCaps = auxGetDevCapsW;
        pub const mixerGetDevCaps = mixerGetDevCapsW;
        pub const mixerGetLineInfo = mixerGetLineInfoW;
        pub const mixerGetLineControls = mixerGetLineControlsW;
        pub const mixerGetControlDetails = mixerGetControlDetailsW;
        pub const joyGetDevCaps = joyGetDevCapsW;
        pub const acmDriverAdd = acmDriverAddW;
        pub const acmDriverDetails = acmDriverDetailsW;
        pub const acmFormatTagDetails = acmFormatTagDetailsW;
        pub const acmFormatTagEnum = acmFormatTagEnumW;
        pub const acmFormatDetails = acmFormatDetailsW;
        pub const acmFormatEnum = acmFormatEnumW;
        pub const acmFormatChoose = acmFormatChooseW;
        pub const acmFilterTagDetails = acmFilterTagDetailsW;
        pub const acmFilterTagEnum = acmFilterTagEnumW;
        pub const acmFilterDetails = acmFilterDetailsW;
        pub const acmFilterEnum = acmFilterEnumW;
        pub const acmFilterChoose = acmFilterChooseW;
        pub const AVIFileOpen = AVIFileOpenW;
        pub const AVIFileInfo = AVIFileInfoW;
        pub const AVIFileCreateStream = AVIFileCreateStreamW;
        pub const AVIStreamInfo = AVIStreamInfoW;
        pub const AVIStreamOpenFromFile = AVIStreamOpenFromFileW;
        pub const AVISave = AVISaveW;
        pub const AVISaveV = AVISaveVW;
        pub const AVIBuildFilter = AVIBuildFilterW;
        pub const EditStreamSetName = EditStreamSetNameW;
        pub const EditStreamSetInfo = EditStreamSetInfoW;
        pub const MCIWndCreate = MCIWndCreateW;
        pub const capCreateCaptureWindow = capCreateCaptureWindowW;
        pub const capGetDriverDescription = capGetDriverDescriptionW;
        pub const GetOpenFileNamePreview = GetOpenFileNamePreviewW;
        pub const GetSaveFileNamePreview = GetSaveFileNamePreviewW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const WAVEOUTCAPS = *opaque{};
        pub const WAVEOUTCAPS2 = *opaque{};
        pub const WAVEINCAPS = *opaque{};
        pub const WAVEINCAPS2 = *opaque{};
        pub const MIDIOUTCAPS = *opaque{};
        pub const MIDIOUTCAPS2 = *opaque{};
        pub const MIDIINCAPS = *opaque{};
        pub const MIDIINCAPS2 = *opaque{};
        pub const AUXCAPS = *opaque{};
        pub const AUXCAPS2 = *opaque{};
        pub const MIXERCAPS = *opaque{};
        pub const MIXERCAPS2 = *opaque{};
        pub const MIXERLINE = *opaque{};
        pub const MIXERCONTROL = *opaque{};
        pub const MIXERLINECONTROLS = *opaque{};
        pub const MIXERCONTROLDETAILS_LISTTEXT = *opaque{};
        pub const JOYCAPS = *opaque{};
        pub const JOYCAPS2 = *opaque{};
        pub const MCI_DGV_CAPTURE_PARMS = *opaque{};
        pub const MCI_DGV_INFO_PARMS = *opaque{};
        pub const MCI_DGV_LIST_PARMS = *opaque{};
        pub const MCI_DGV_OPEN_PARMS = *opaque{};
        pub const MCI_DGV_QUALITY_PARMS = *opaque{};
        pub const MCI_DGV_RESERVE_PARMS = *opaque{};
        pub const MCI_DGV_RESTORE_PARMS = *opaque{};
        pub const MCI_DGV_SAVE_PARMS = *opaque{};
        pub const MCI_DGV_SETAUDIO_PARMS = *opaque{};
        pub const MCI_DGV_SETVIDEO_PARMS = *opaque{};
        pub const MCI_DGV_STATUS_PARMS = *opaque{};
        pub const MCI_DGV_WINDOW_PARMS = *opaque{};
        pub const tACMDRIVERDETAILS = *opaque{};
        pub const tACMFORMATTAGDETAILS = *opaque{};
        pub const ACMFORMATTAGENUMCB = *opaque{};
        pub const tACMFORMATDETAILS = *opaque{};
        pub const ACMFORMATENUMCB = *opaque{};
        pub const ACMFORMATCHOOSEHOOKPROC = *opaque{};
        pub const tACMFORMATCHOOSE = *opaque{};
        pub const tACMFILTERTAGDETAILS = *opaque{};
        pub const ACMFILTERTAGENUMCB = *opaque{};
        pub const tACMFILTERDETAILS = *opaque{};
        pub const ACMFILTERENUMCB = *opaque{};
        pub const ACMFILTERCHOOSEHOOKPROC = *opaque{};
        pub const tACMFILTERCHOOSE = *opaque{};
        pub const AVISTREAMINFO = *opaque{};
        pub const AVIFILEINFO = *opaque{};
        pub const CAPSTATUSCALLBACK = *opaque{};
        pub const CAPERRORCALLBACK = *opaque{};
        pub const mmioStringToFOURCC = *opaque{};
        pub const mmioInstallIOProc = *opaque{};
        pub const mmioOpen = *opaque{};
        pub const mmioRename = *opaque{};
        pub const sndPlaySound = *opaque{};
        pub const PlaySound = *opaque{};
        pub const waveOutGetDevCaps = *opaque{};
        pub const waveOutGetErrorText = *opaque{};
        pub const waveInGetDevCaps = *opaque{};
        pub const waveInGetErrorText = *opaque{};
        pub const midiOutGetDevCaps = *opaque{};
        pub const midiOutGetErrorText = *opaque{};
        pub const midiInGetDevCaps = *opaque{};
        pub const midiInGetErrorText = *opaque{};
        pub const auxGetDevCaps = *opaque{};
        pub const mixerGetDevCaps = *opaque{};
        pub const mixerGetLineInfo = *opaque{};
        pub const mixerGetLineControls = *opaque{};
        pub const mixerGetControlDetails = *opaque{};
        pub const joyGetDevCaps = *opaque{};
        pub const acmDriverAdd = *opaque{};
        pub const acmDriverDetails = *opaque{};
        pub const acmFormatTagDetails = *opaque{};
        pub const acmFormatTagEnum = *opaque{};
        pub const acmFormatDetails = *opaque{};
        pub const acmFormatEnum = *opaque{};
        pub const acmFormatChoose = *opaque{};
        pub const acmFilterTagDetails = *opaque{};
        pub const acmFilterTagEnum = *opaque{};
        pub const acmFilterDetails = *opaque{};
        pub const acmFilterEnum = *opaque{};
        pub const acmFilterChoose = *opaque{};
        pub const AVIFileOpen = *opaque{};
        pub const AVIFileInfo = *opaque{};
        pub const AVIFileCreateStream = *opaque{};
        pub const AVIStreamInfo = *opaque{};
        pub const AVIStreamOpenFromFile = *opaque{};
        pub const AVISave = *opaque{};
        pub const AVISaveV = *opaque{};
        pub const AVIBuildFilter = *opaque{};
        pub const EditStreamSetName = *opaque{};
        pub const EditStreamSetInfo = *opaque{};
        pub const MCIWndCreate = *opaque{};
        pub const capCreateCaptureWindow = *opaque{};
        pub const capGetDriverDescription = *opaque{};
        pub const GetOpenFileNamePreview = *opaque{};
        pub const GetSaveFileNamePreview = *opaque{};
    } else struct {
        pub const WAVEOUTCAPS = @compileError("'WAVEOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEOUTCAPS2 = @compileError("'WAVEOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS = @compileError("'WAVEINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const WAVEINCAPS2 = @compileError("'WAVEINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS = @compileError("'MIDIOUTCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIOUTCAPS2 = @compileError("'MIDIOUTCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS = @compileError("'MIDIINCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIDIINCAPS2 = @compileError("'MIDIINCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS = @compileError("'AUXCAPS' requires that UNICODE be set to true or false in the root module");
        pub const AUXCAPS2 = @compileError("'AUXCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS = @compileError("'MIXERCAPS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCAPS2 = @compileError("'MIXERCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINE = @compileError("'MIXERLINE' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROL = @compileError("'MIXERCONTROL' requires that UNICODE be set to true or false in the root module");
        pub const MIXERLINECONTROLS = @compileError("'MIXERLINECONTROLS' requires that UNICODE be set to true or false in the root module");
        pub const MIXERCONTROLDETAILS_LISTTEXT = @compileError("'MIXERCONTROLDETAILS_LISTTEXT' requires that UNICODE be set to true or false in the root module");
        pub const JOYCAPS = @compileError("'JOYCAPS' requires that UNICODE be set to true or false in the root module");
        pub const JOYCAPS2 = @compileError("'JOYCAPS2' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_CAPTURE_PARMS = @compileError("'MCI_DGV_CAPTURE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_INFO_PARMS = @compileError("'MCI_DGV_INFO_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_LIST_PARMS = @compileError("'MCI_DGV_LIST_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_OPEN_PARMS = @compileError("'MCI_DGV_OPEN_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_QUALITY_PARMS = @compileError("'MCI_DGV_QUALITY_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_RESERVE_PARMS = @compileError("'MCI_DGV_RESERVE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_RESTORE_PARMS = @compileError("'MCI_DGV_RESTORE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_SAVE_PARMS = @compileError("'MCI_DGV_SAVE_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_SETAUDIO_PARMS = @compileError("'MCI_DGV_SETAUDIO_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_SETVIDEO_PARMS = @compileError("'MCI_DGV_SETVIDEO_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_STATUS_PARMS = @compileError("'MCI_DGV_STATUS_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const MCI_DGV_WINDOW_PARMS = @compileError("'MCI_DGV_WINDOW_PARMS' requires that UNICODE be set to true or false in the root module");
        pub const tACMDRIVERDETAILS = @compileError("'tACMDRIVERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const tACMFORMATTAGDETAILS = @compileError("'tACMFORMATTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATTAGENUMCB = @compileError("'ACMFORMATTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const tACMFORMATDETAILS = @compileError("'tACMFORMATDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATENUMCB = @compileError("'ACMFORMATENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFORMATCHOOSEHOOKPROC = @compileError("'ACMFORMATCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const tACMFORMATCHOOSE = @compileError("'tACMFORMATCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const tACMFILTERTAGDETAILS = @compileError("'tACMFILTERTAGDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERTAGENUMCB = @compileError("'ACMFILTERTAGENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const tACMFILTERDETAILS = @compileError("'tACMFILTERDETAILS' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERENUMCB = @compileError("'ACMFILTERENUMCB' requires that UNICODE be set to true or false in the root module");
        pub const ACMFILTERCHOOSEHOOKPROC = @compileError("'ACMFILTERCHOOSEHOOKPROC' requires that UNICODE be set to true or false in the root module");
        pub const tACMFILTERCHOOSE = @compileError("'tACMFILTERCHOOSE' requires that UNICODE be set to true or false in the root module");
        pub const AVISTREAMINFO = @compileError("'AVISTREAMINFO' requires that UNICODE be set to true or false in the root module");
        pub const AVIFILEINFO = @compileError("'AVIFILEINFO' requires that UNICODE be set to true or false in the root module");
        pub const CAPSTATUSCALLBACK = @compileError("'CAPSTATUSCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const CAPERRORCALLBACK = @compileError("'CAPERRORCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const mmioStringToFOURCC = @compileError("'mmioStringToFOURCC' requires that UNICODE be set to true or false in the root module");
        pub const mmioInstallIOProc = @compileError("'mmioInstallIOProc' requires that UNICODE be set to true or false in the root module");
        pub const mmioOpen = @compileError("'mmioOpen' requires that UNICODE be set to true or false in the root module");
        pub const mmioRename = @compileError("'mmioRename' requires that UNICODE be set to true or false in the root module");
        pub const sndPlaySound = @compileError("'sndPlaySound' requires that UNICODE be set to true or false in the root module");
        pub const PlaySound = @compileError("'PlaySound' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetDevCaps = @compileError("'waveOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveOutGetErrorText = @compileError("'waveOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetDevCaps = @compileError("'waveInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const waveInGetErrorText = @compileError("'waveInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetDevCaps = @compileError("'midiOutGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiOutGetErrorText = @compileError("'midiOutGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetDevCaps = @compileError("'midiInGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const midiInGetErrorText = @compileError("'midiInGetErrorText' requires that UNICODE be set to true or false in the root module");
        pub const auxGetDevCaps = @compileError("'auxGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetDevCaps = @compileError("'mixerGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineInfo = @compileError("'mixerGetLineInfo' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetLineControls = @compileError("'mixerGetLineControls' requires that UNICODE be set to true or false in the root module");
        pub const mixerGetControlDetails = @compileError("'mixerGetControlDetails' requires that UNICODE be set to true or false in the root module");
        pub const joyGetDevCaps = @compileError("'joyGetDevCaps' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverAdd = @compileError("'acmDriverAdd' requires that UNICODE be set to true or false in the root module");
        pub const acmDriverDetails = @compileError("'acmDriverDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagDetails = @compileError("'acmFormatTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatTagEnum = @compileError("'acmFormatTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatDetails = @compileError("'acmFormatDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatEnum = @compileError("'acmFormatEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFormatChoose = @compileError("'acmFormatChoose' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagDetails = @compileError("'acmFilterTagDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterTagEnum = @compileError("'acmFilterTagEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterDetails = @compileError("'acmFilterDetails' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterEnum = @compileError("'acmFilterEnum' requires that UNICODE be set to true or false in the root module");
        pub const acmFilterChoose = @compileError("'acmFilterChoose' requires that UNICODE be set to true or false in the root module");
        pub const AVIFileOpen = @compileError("'AVIFileOpen' requires that UNICODE be set to true or false in the root module");
        pub const AVIFileInfo = @compileError("'AVIFileInfo' requires that UNICODE be set to true or false in the root module");
        pub const AVIFileCreateStream = @compileError("'AVIFileCreateStream' requires that UNICODE be set to true or false in the root module");
        pub const AVIStreamInfo = @compileError("'AVIStreamInfo' requires that UNICODE be set to true or false in the root module");
        pub const AVIStreamOpenFromFile = @compileError("'AVIStreamOpenFromFile' requires that UNICODE be set to true or false in the root module");
        pub const AVISave = @compileError("'AVISave' requires that UNICODE be set to true or false in the root module");
        pub const AVISaveV = @compileError("'AVISaveV' requires that UNICODE be set to true or false in the root module");
        pub const AVIBuildFilter = @compileError("'AVIBuildFilter' requires that UNICODE be set to true or false in the root module");
        pub const EditStreamSetName = @compileError("'EditStreamSetName' requires that UNICODE be set to true or false in the root module");
        pub const EditStreamSetInfo = @compileError("'EditStreamSetInfo' requires that UNICODE be set to true or false in the root module");
        pub const MCIWndCreate = @compileError("'MCIWndCreate' requires that UNICODE be set to true or false in the root module");
        pub const capCreateCaptureWindow = @compileError("'capCreateCaptureWindow' requires that UNICODE be set to true or false in the root module");
        pub const capGetDriverDescription = @compileError("'capGetDriverDescription' requires that UNICODE be set to true or false in the root module");
        pub const GetOpenFileNamePreview = @compileError("'GetOpenFileNamePreview' requires that UNICODE be set to true or false in the root module");
        pub const GetSaveFileNamePreview = @compileError("'GetSaveFileNamePreview' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (27)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const HDC = @import("gdi.zig").HDC;
const HINSTANCE = @import("system_services.zig").HINSTANCE;
const JOYREGHWVALUES = @import("hid.zig").JOYREGHWVALUES;
const OPENFILENAMEA = @import("windows_and_messaging.zig").OPENFILENAMEA;
const HRESULT = @import("com.zig").HRESULT;
const BITMAPINFOHEADER = @import("direct_show.zig").BITMAPINFOHEADER;
const BOOL = @import("system_services.zig").BOOL;
const LRESULT = @import("system_services.zig").LRESULT;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const HPALETTE = @import("gdi.zig").HPALETTE;
const HTASK = @import("core_audio.zig").HTASK;
const FARPROC = @import("system_services.zig").FARPROC;
const OPENFILENAMEW = @import("windows_and_messaging.zig").OPENFILENAMEW;
const HICON = @import("menus_and_resources.zig").HICON;
const PWSTR = @import("system_services.zig").PWSTR;
const IUnknown = @import("com.zig").IUnknown;
const LPTIMECALLBACK = @import("system_services.zig").LPTIMECALLBACK;
const PSTR = @import("system_services.zig").PSTR;
const RECT = @import("display_devices.zig").RECT;
const HWND = @import("windows_and_messaging.zig").HWND;
const BITMAPINFO = @import("gdi.zig").BITMAPINFO;
const IPersistFile = @import("com.zig").IPersistFile;
const PALETTEENTRY = @import("gdi.zig").PALETTEENTRY;
const HANDLE = @import("system_services.zig").HANDLE;
const POINT = @import("display_devices.zig").POINT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = DRVCALLBACK;
    _ = LPDRVCALLBACK;
    _ = PDRVCALLBACK;
    _ = DRIVERPROC;
    _ = DRIVERMSGPROC;
    _ = MMIOPROC;
    _ = LPMMIOPROC;
    _ = WAVECALLBACK;
    _ = LPWAVECALLBACK;
    _ = MIDICALLBACK;
    _ = LPMIDICALLBACK;
    _ = ACMDRIVERENUMCB;
    _ = ACMDRIVERPROC;
    _ = LPACMDRIVERPROC;
    _ = ACMFORMATTAGENUMCBA;
    _ = ACMFORMATTAGENUMCBW;
    _ = ACMFORMATENUMCBA;
    _ = ACMFORMATENUMCBW;
    _ = ACMFORMATCHOOSEHOOKPROCA;
    _ = ACMFORMATCHOOSEHOOKPROCW;
    _ = ACMFILTERTAGENUMCBA;
    _ = ACMFILTERTAGENUMCBW;
    _ = ACMFILTERENUMCBA;
    _ = ACMFILTERENUMCBW;
    _ = ACMFILTERCHOOSEHOOKPROCA;
    _ = ACMFILTERCHOOSEHOOKPROCW;
    _ = AVISAVECALLBACK;
    _ = CAPYIELDCALLBACK;
    _ = CAPSTATUSCALLBACKW;
    _ = CAPERRORCALLBACKW;
    _ = CAPSTATUSCALLBACKA;
    _ = CAPERRORCALLBACKA;
    _ = CAPVIDEOCALLBACK;
    _ = CAPWAVECALLBACK;
    _ = CAPCONTROLCALLBACK;
    _ = JOYDEVMSGPROC;
    _ = LPJOYDEVMSGPROC;
    _ = TASKCALLBACK;
    _ = LPTASKCALLBACK;

    const constant_export_count = 0;
    const type_export_count = 253;
    const enum_value_export_count = 0;
    const com_iface_id_export_count = 0;
    const com_class_id_export_count = 3;
    const func_export_count = 305;
    const unicode_alias_count = 94;
    const import_count = 27;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
