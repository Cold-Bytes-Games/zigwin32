//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (392)
//--------------------------------------------------------------------------------
pub const UIA_ScrollPatternNoScroll : f64 = -1;
pub const UIA_InvokePatternId : i32 = 10000;
pub const UIA_SelectionPatternId : i32 = 10001;
pub const UIA_ValuePatternId : i32 = 10002;
pub const UIA_RangeValuePatternId : i32 = 10003;
pub const UIA_ScrollPatternId : i32 = 10004;
pub const UIA_ExpandCollapsePatternId : i32 = 10005;
pub const UIA_GridPatternId : i32 = 10006;
pub const UIA_GridItemPatternId : i32 = 10007;
pub const UIA_MultipleViewPatternId : i32 = 10008;
pub const UIA_WindowPatternId : i32 = 10009;
pub const UIA_SelectionItemPatternId : i32 = 10010;
pub const UIA_DockPatternId : i32 = 10011;
pub const UIA_TablePatternId : i32 = 10012;
pub const UIA_TableItemPatternId : i32 = 10013;
pub const UIA_TextPatternId : i32 = 10014;
pub const UIA_TogglePatternId : i32 = 10015;
pub const UIA_TransformPatternId : i32 = 10016;
pub const UIA_ScrollItemPatternId : i32 = 10017;
pub const UIA_LegacyIAccessiblePatternId : i32 = 10018;
pub const UIA_ItemContainerPatternId : i32 = 10019;
pub const UIA_VirtualizedItemPatternId : i32 = 10020;
pub const UIA_SynchronizedInputPatternId : i32 = 10021;
pub const UIA_ObjectModelPatternId : i32 = 10022;
pub const UIA_AnnotationPatternId : i32 = 10023;
pub const UIA_TextPattern2Id : i32 = 10024;
pub const UIA_StylesPatternId : i32 = 10025;
pub const UIA_SpreadsheetPatternId : i32 = 10026;
pub const UIA_SpreadsheetItemPatternId : i32 = 10027;
pub const UIA_TransformPattern2Id : i32 = 10028;
pub const UIA_TextChildPatternId : i32 = 10029;
pub const UIA_DragPatternId : i32 = 10030;
pub const UIA_DropTargetPatternId : i32 = 10031;
pub const UIA_TextEditPatternId : i32 = 10032;
pub const UIA_CustomNavigationPatternId : i32 = 10033;
pub const UIA_SelectionPattern2Id : i32 = 10034;
pub const UIA_ToolTipOpenedEventId : i32 = 20000;
pub const UIA_ToolTipClosedEventId : i32 = 20001;
pub const UIA_StructureChangedEventId : i32 = 20002;
pub const UIA_MenuOpenedEventId : i32 = 20003;
pub const UIA_AutomationPropertyChangedEventId : i32 = 20004;
pub const UIA_AutomationFocusChangedEventId : i32 = 20005;
pub const UIA_AsyncContentLoadedEventId : i32 = 20006;
pub const UIA_MenuClosedEventId : i32 = 20007;
pub const UIA_LayoutInvalidatedEventId : i32 = 20008;
pub const UIA_Invoke_InvokedEventId : i32 = 20009;
pub const UIA_SelectionItem_ElementAddedToSelectionEventId : i32 = 20010;
pub const UIA_SelectionItem_ElementRemovedFromSelectionEventId : i32 = 20011;
pub const UIA_SelectionItem_ElementSelectedEventId : i32 = 20012;
pub const UIA_Selection_InvalidatedEventId : i32 = 20013;
pub const UIA_Text_TextSelectionChangedEventId : i32 = 20014;
pub const UIA_Text_TextChangedEventId : i32 = 20015;
pub const UIA_Window_WindowOpenedEventId : i32 = 20016;
pub const UIA_Window_WindowClosedEventId : i32 = 20017;
pub const UIA_MenuModeStartEventId : i32 = 20018;
pub const UIA_MenuModeEndEventId : i32 = 20019;
pub const UIA_InputReachedTargetEventId : i32 = 20020;
pub const UIA_InputReachedOtherElementEventId : i32 = 20021;
pub const UIA_InputDiscardedEventId : i32 = 20022;
pub const UIA_SystemAlertEventId : i32 = 20023;
pub const UIA_LiveRegionChangedEventId : i32 = 20024;
pub const UIA_HostedFragmentRootsInvalidatedEventId : i32 = 20025;
pub const UIA_Drag_DragStartEventId : i32 = 20026;
pub const UIA_Drag_DragCancelEventId : i32 = 20027;
pub const UIA_Drag_DragCompleteEventId : i32 = 20028;
pub const UIA_DropTarget_DragEnterEventId : i32 = 20029;
pub const UIA_DropTarget_DragLeaveEventId : i32 = 20030;
pub const UIA_DropTarget_DroppedEventId : i32 = 20031;
pub const UIA_TextEdit_TextChangedEventId : i32 = 20032;
pub const UIA_TextEdit_ConversionTargetChangedEventId : i32 = 20033;
pub const UIA_ChangesEventId : i32 = 20034;
pub const UIA_NotificationEventId : i32 = 20035;
pub const UIA_ActiveTextPositionChangedEventId : i32 = 20036;
pub const UIA_RuntimeIdPropertyId : i32 = 30000;
pub const UIA_BoundingRectanglePropertyId : i32 = 30001;
pub const UIA_ProcessIdPropertyId : i32 = 30002;
pub const UIA_ControlTypePropertyId : i32 = 30003;
pub const UIA_LocalizedControlTypePropertyId : i32 = 30004;
pub const UIA_NamePropertyId : i32 = 30005;
pub const UIA_AcceleratorKeyPropertyId : i32 = 30006;
pub const UIA_AccessKeyPropertyId : i32 = 30007;
pub const UIA_HasKeyboardFocusPropertyId : i32 = 30008;
pub const UIA_IsKeyboardFocusablePropertyId : i32 = 30009;
pub const UIA_IsEnabledPropertyId : i32 = 30010;
pub const UIA_AutomationIdPropertyId : i32 = 30011;
pub const UIA_ClassNamePropertyId : i32 = 30012;
pub const UIA_HelpTextPropertyId : i32 = 30013;
pub const UIA_ClickablePointPropertyId : i32 = 30014;
pub const UIA_CulturePropertyId : i32 = 30015;
pub const UIA_IsControlElementPropertyId : i32 = 30016;
pub const UIA_IsContentElementPropertyId : i32 = 30017;
pub const UIA_LabeledByPropertyId : i32 = 30018;
pub const UIA_IsPasswordPropertyId : i32 = 30019;
pub const UIA_NativeWindowHandlePropertyId : i32 = 30020;
pub const UIA_ItemTypePropertyId : i32 = 30021;
pub const UIA_IsOffscreenPropertyId : i32 = 30022;
pub const UIA_OrientationPropertyId : i32 = 30023;
pub const UIA_FrameworkIdPropertyId : i32 = 30024;
pub const UIA_IsRequiredForFormPropertyId : i32 = 30025;
pub const UIA_ItemStatusPropertyId : i32 = 30026;
pub const UIA_IsDockPatternAvailablePropertyId : i32 = 30027;
pub const UIA_IsExpandCollapsePatternAvailablePropertyId : i32 = 30028;
pub const UIA_IsGridItemPatternAvailablePropertyId : i32 = 30029;
pub const UIA_IsGridPatternAvailablePropertyId : i32 = 30030;
pub const UIA_IsInvokePatternAvailablePropertyId : i32 = 30031;
pub const UIA_IsMultipleViewPatternAvailablePropertyId : i32 = 30032;
pub const UIA_IsRangeValuePatternAvailablePropertyId : i32 = 30033;
pub const UIA_IsScrollPatternAvailablePropertyId : i32 = 30034;
pub const UIA_IsScrollItemPatternAvailablePropertyId : i32 = 30035;
pub const UIA_IsSelectionItemPatternAvailablePropertyId : i32 = 30036;
pub const UIA_IsSelectionPatternAvailablePropertyId : i32 = 30037;
pub const UIA_IsTablePatternAvailablePropertyId : i32 = 30038;
pub const UIA_IsTableItemPatternAvailablePropertyId : i32 = 30039;
pub const UIA_IsTextPatternAvailablePropertyId : i32 = 30040;
pub const UIA_IsTogglePatternAvailablePropertyId : i32 = 30041;
pub const UIA_IsTransformPatternAvailablePropertyId : i32 = 30042;
pub const UIA_IsValuePatternAvailablePropertyId : i32 = 30043;
pub const UIA_IsWindowPatternAvailablePropertyId : i32 = 30044;
pub const UIA_ValueValuePropertyId : i32 = 30045;
pub const UIA_ValueIsReadOnlyPropertyId : i32 = 30046;
pub const UIA_RangeValueValuePropertyId : i32 = 30047;
pub const UIA_RangeValueIsReadOnlyPropertyId : i32 = 30048;
pub const UIA_RangeValueMinimumPropertyId : i32 = 30049;
pub const UIA_RangeValueMaximumPropertyId : i32 = 30050;
pub const UIA_RangeValueLargeChangePropertyId : i32 = 30051;
pub const UIA_RangeValueSmallChangePropertyId : i32 = 30052;
pub const UIA_ScrollHorizontalScrollPercentPropertyId : i32 = 30053;
pub const UIA_ScrollHorizontalViewSizePropertyId : i32 = 30054;
pub const UIA_ScrollVerticalScrollPercentPropertyId : i32 = 30055;
pub const UIA_ScrollVerticalViewSizePropertyId : i32 = 30056;
pub const UIA_ScrollHorizontallyScrollablePropertyId : i32 = 30057;
pub const UIA_ScrollVerticallyScrollablePropertyId : i32 = 30058;
pub const UIA_SelectionSelectionPropertyId : i32 = 30059;
pub const UIA_SelectionCanSelectMultiplePropertyId : i32 = 30060;
pub const UIA_SelectionIsSelectionRequiredPropertyId : i32 = 30061;
pub const UIA_GridRowCountPropertyId : i32 = 30062;
pub const UIA_GridColumnCountPropertyId : i32 = 30063;
pub const UIA_GridItemRowPropertyId : i32 = 30064;
pub const UIA_GridItemColumnPropertyId : i32 = 30065;
pub const UIA_GridItemRowSpanPropertyId : i32 = 30066;
pub const UIA_GridItemColumnSpanPropertyId : i32 = 30067;
pub const UIA_GridItemContainingGridPropertyId : i32 = 30068;
pub const UIA_DockDockPositionPropertyId : i32 = 30069;
pub const UIA_ExpandCollapseExpandCollapseStatePropertyId : i32 = 30070;
pub const UIA_MultipleViewCurrentViewPropertyId : i32 = 30071;
pub const UIA_MultipleViewSupportedViewsPropertyId : i32 = 30072;
pub const UIA_WindowCanMaximizePropertyId : i32 = 30073;
pub const UIA_WindowCanMinimizePropertyId : i32 = 30074;
pub const UIA_WindowWindowVisualStatePropertyId : i32 = 30075;
pub const UIA_WindowWindowInteractionStatePropertyId : i32 = 30076;
pub const UIA_WindowIsModalPropertyId : i32 = 30077;
pub const UIA_WindowIsTopmostPropertyId : i32 = 30078;
pub const UIA_SelectionItemIsSelectedPropertyId : i32 = 30079;
pub const UIA_SelectionItemSelectionContainerPropertyId : i32 = 30080;
pub const UIA_TableRowHeadersPropertyId : i32 = 30081;
pub const UIA_TableColumnHeadersPropertyId : i32 = 30082;
pub const UIA_TableRowOrColumnMajorPropertyId : i32 = 30083;
pub const UIA_TableItemRowHeaderItemsPropertyId : i32 = 30084;
pub const UIA_TableItemColumnHeaderItemsPropertyId : i32 = 30085;
pub const UIA_ToggleToggleStatePropertyId : i32 = 30086;
pub const UIA_TransformCanMovePropertyId : i32 = 30087;
pub const UIA_TransformCanResizePropertyId : i32 = 30088;
pub const UIA_TransformCanRotatePropertyId : i32 = 30089;
pub const UIA_IsLegacyIAccessiblePatternAvailablePropertyId : i32 = 30090;
pub const UIA_LegacyIAccessibleChildIdPropertyId : i32 = 30091;
pub const UIA_LegacyIAccessibleNamePropertyId : i32 = 30092;
pub const UIA_LegacyIAccessibleValuePropertyId : i32 = 30093;
pub const UIA_LegacyIAccessibleDescriptionPropertyId : i32 = 30094;
pub const UIA_LegacyIAccessibleRolePropertyId : i32 = 30095;
pub const UIA_LegacyIAccessibleStatePropertyId : i32 = 30096;
pub const UIA_LegacyIAccessibleHelpPropertyId : i32 = 30097;
pub const UIA_LegacyIAccessibleKeyboardShortcutPropertyId : i32 = 30098;
pub const UIA_LegacyIAccessibleSelectionPropertyId : i32 = 30099;
pub const UIA_LegacyIAccessibleDefaultActionPropertyId : i32 = 30100;
pub const UIA_AriaRolePropertyId : i32 = 30101;
pub const UIA_AriaPropertiesPropertyId : i32 = 30102;
pub const UIA_IsDataValidForFormPropertyId : i32 = 30103;
pub const UIA_ControllerForPropertyId : i32 = 30104;
pub const UIA_DescribedByPropertyId : i32 = 30105;
pub const UIA_FlowsToPropertyId : i32 = 30106;
pub const UIA_ProviderDescriptionPropertyId : i32 = 30107;
pub const UIA_IsItemContainerPatternAvailablePropertyId : i32 = 30108;
pub const UIA_IsVirtualizedItemPatternAvailablePropertyId : i32 = 30109;
pub const UIA_IsSynchronizedInputPatternAvailablePropertyId : i32 = 30110;
pub const UIA_OptimizeForVisualContentPropertyId : i32 = 30111;
pub const UIA_IsObjectModelPatternAvailablePropertyId : i32 = 30112;
pub const UIA_AnnotationAnnotationTypeIdPropertyId : i32 = 30113;
pub const UIA_AnnotationAnnotationTypeNamePropertyId : i32 = 30114;
pub const UIA_AnnotationAuthorPropertyId : i32 = 30115;
pub const UIA_AnnotationDateTimePropertyId : i32 = 30116;
pub const UIA_AnnotationTargetPropertyId : i32 = 30117;
pub const UIA_IsAnnotationPatternAvailablePropertyId : i32 = 30118;
pub const UIA_IsTextPattern2AvailablePropertyId : i32 = 30119;
pub const UIA_StylesStyleIdPropertyId : i32 = 30120;
pub const UIA_StylesStyleNamePropertyId : i32 = 30121;
pub const UIA_StylesFillColorPropertyId : i32 = 30122;
pub const UIA_StylesFillPatternStylePropertyId : i32 = 30123;
pub const UIA_StylesShapePropertyId : i32 = 30124;
pub const UIA_StylesFillPatternColorPropertyId : i32 = 30125;
pub const UIA_StylesExtendedPropertiesPropertyId : i32 = 30126;
pub const UIA_IsStylesPatternAvailablePropertyId : i32 = 30127;
pub const UIA_IsSpreadsheetPatternAvailablePropertyId : i32 = 30128;
pub const UIA_SpreadsheetItemFormulaPropertyId : i32 = 30129;
pub const UIA_SpreadsheetItemAnnotationObjectsPropertyId : i32 = 30130;
pub const UIA_SpreadsheetItemAnnotationTypesPropertyId : i32 = 30131;
pub const UIA_IsSpreadsheetItemPatternAvailablePropertyId : i32 = 30132;
pub const UIA_Transform2CanZoomPropertyId : i32 = 30133;
pub const UIA_IsTransformPattern2AvailablePropertyId : i32 = 30134;
pub const UIA_LiveSettingPropertyId : i32 = 30135;
pub const UIA_IsTextChildPatternAvailablePropertyId : i32 = 30136;
pub const UIA_IsDragPatternAvailablePropertyId : i32 = 30137;
pub const UIA_DragIsGrabbedPropertyId : i32 = 30138;
pub const UIA_DragDropEffectPropertyId : i32 = 30139;
pub const UIA_DragDropEffectsPropertyId : i32 = 30140;
pub const UIA_IsDropTargetPatternAvailablePropertyId : i32 = 30141;
pub const UIA_DropTargetDropTargetEffectPropertyId : i32 = 30142;
pub const UIA_DropTargetDropTargetEffectsPropertyId : i32 = 30143;
pub const UIA_DragGrabbedItemsPropertyId : i32 = 30144;
pub const UIA_Transform2ZoomLevelPropertyId : i32 = 30145;
pub const UIA_Transform2ZoomMinimumPropertyId : i32 = 30146;
pub const UIA_Transform2ZoomMaximumPropertyId : i32 = 30147;
pub const UIA_FlowsFromPropertyId : i32 = 30148;
pub const UIA_IsTextEditPatternAvailablePropertyId : i32 = 30149;
pub const UIA_IsPeripheralPropertyId : i32 = 30150;
pub const UIA_IsCustomNavigationPatternAvailablePropertyId : i32 = 30151;
pub const UIA_PositionInSetPropertyId : i32 = 30152;
pub const UIA_SizeOfSetPropertyId : i32 = 30153;
pub const UIA_LevelPropertyId : i32 = 30154;
pub const UIA_AnnotationTypesPropertyId : i32 = 30155;
pub const UIA_AnnotationObjectsPropertyId : i32 = 30156;
pub const UIA_LandmarkTypePropertyId : i32 = 30157;
pub const UIA_LocalizedLandmarkTypePropertyId : i32 = 30158;
pub const UIA_FullDescriptionPropertyId : i32 = 30159;
pub const UIA_FillColorPropertyId : i32 = 30160;
pub const UIA_OutlineColorPropertyId : i32 = 30161;
pub const UIA_FillTypePropertyId : i32 = 30162;
pub const UIA_VisualEffectsPropertyId : i32 = 30163;
pub const UIA_OutlineThicknessPropertyId : i32 = 30164;
pub const UIA_CenterPointPropertyId : i32 = 30165;
pub const UIA_RotationPropertyId : i32 = 30166;
pub const UIA_SizePropertyId : i32 = 30167;
pub const UIA_IsSelectionPattern2AvailablePropertyId : i32 = 30168;
pub const UIA_Selection2FirstSelectedItemPropertyId : i32 = 30169;
pub const UIA_Selection2LastSelectedItemPropertyId : i32 = 30170;
pub const UIA_Selection2CurrentSelectedItemPropertyId : i32 = 30171;
pub const UIA_Selection2ItemCountPropertyId : i32 = 30172;
pub const UIA_HeadingLevelPropertyId : i32 = 30173;
pub const UIA_IsDialogPropertyId : i32 = 30174;
pub const UIA_AnimationStyleAttributeId : i32 = 40000;
pub const UIA_BackgroundColorAttributeId : i32 = 40001;
pub const UIA_BulletStyleAttributeId : i32 = 40002;
pub const UIA_CapStyleAttributeId : i32 = 40003;
pub const UIA_CultureAttributeId : i32 = 40004;
pub const UIA_FontNameAttributeId : i32 = 40005;
pub const UIA_FontSizeAttributeId : i32 = 40006;
pub const UIA_FontWeightAttributeId : i32 = 40007;
pub const UIA_ForegroundColorAttributeId : i32 = 40008;
pub const UIA_HorizontalTextAlignmentAttributeId : i32 = 40009;
pub const UIA_IndentationFirstLineAttributeId : i32 = 40010;
pub const UIA_IndentationLeadingAttributeId : i32 = 40011;
pub const UIA_IndentationTrailingAttributeId : i32 = 40012;
pub const UIA_IsHiddenAttributeId : i32 = 40013;
pub const UIA_IsItalicAttributeId : i32 = 40014;
pub const UIA_IsReadOnlyAttributeId : i32 = 40015;
pub const UIA_IsSubscriptAttributeId : i32 = 40016;
pub const UIA_IsSuperscriptAttributeId : i32 = 40017;
pub const UIA_MarginBottomAttributeId : i32 = 40018;
pub const UIA_MarginLeadingAttributeId : i32 = 40019;
pub const UIA_MarginTopAttributeId : i32 = 40020;
pub const UIA_MarginTrailingAttributeId : i32 = 40021;
pub const UIA_OutlineStylesAttributeId : i32 = 40022;
pub const UIA_OverlineColorAttributeId : i32 = 40023;
pub const UIA_OverlineStyleAttributeId : i32 = 40024;
pub const UIA_StrikethroughColorAttributeId : i32 = 40025;
pub const UIA_StrikethroughStyleAttributeId : i32 = 40026;
pub const UIA_TabsAttributeId : i32 = 40027;
pub const UIA_TextFlowDirectionsAttributeId : i32 = 40028;
pub const UIA_UnderlineColorAttributeId : i32 = 40029;
pub const UIA_UnderlineStyleAttributeId : i32 = 40030;
pub const UIA_AnnotationTypesAttributeId : i32 = 40031;
pub const UIA_AnnotationObjectsAttributeId : i32 = 40032;
pub const UIA_StyleNameAttributeId : i32 = 40033;
pub const UIA_StyleIdAttributeId : i32 = 40034;
pub const UIA_LinkAttributeId : i32 = 40035;
pub const UIA_IsActiveAttributeId : i32 = 40036;
pub const UIA_SelectionActiveEndAttributeId : i32 = 40037;
pub const UIA_CaretPositionAttributeId : i32 = 40038;
pub const UIA_CaretBidiModeAttributeId : i32 = 40039;
pub const UIA_LineSpacingAttributeId : i32 = 40040;
pub const UIA_BeforeParagraphSpacingAttributeId : i32 = 40041;
pub const UIA_AfterParagraphSpacingAttributeId : i32 = 40042;
pub const UIA_SayAsInterpretAsAttributeId : i32 = 40043;
pub const UIA_ButtonControlTypeId : i32 = 50000;
pub const UIA_CalendarControlTypeId : i32 = 50001;
pub const UIA_CheckBoxControlTypeId : i32 = 50002;
pub const UIA_ComboBoxControlTypeId : i32 = 50003;
pub const UIA_EditControlTypeId : i32 = 50004;
pub const UIA_HyperlinkControlTypeId : i32 = 50005;
pub const UIA_ImageControlTypeId : i32 = 50006;
pub const UIA_ListItemControlTypeId : i32 = 50007;
pub const UIA_ListControlTypeId : i32 = 50008;
pub const UIA_MenuControlTypeId : i32 = 50009;
pub const UIA_MenuBarControlTypeId : i32 = 50010;
pub const UIA_MenuItemControlTypeId : i32 = 50011;
pub const UIA_ProgressBarControlTypeId : i32 = 50012;
pub const UIA_RadioButtonControlTypeId : i32 = 50013;
pub const UIA_ScrollBarControlTypeId : i32 = 50014;
pub const UIA_SliderControlTypeId : i32 = 50015;
pub const UIA_SpinnerControlTypeId : i32 = 50016;
pub const UIA_StatusBarControlTypeId : i32 = 50017;
pub const UIA_TabControlTypeId : i32 = 50018;
pub const UIA_TabItemControlTypeId : i32 = 50019;
pub const UIA_TextControlTypeId : i32 = 50020;
pub const UIA_ToolBarControlTypeId : i32 = 50021;
pub const UIA_ToolTipControlTypeId : i32 = 50022;
pub const UIA_TreeControlTypeId : i32 = 50023;
pub const UIA_TreeItemControlTypeId : i32 = 50024;
pub const UIA_CustomControlTypeId : i32 = 50025;
pub const UIA_GroupControlTypeId : i32 = 50026;
pub const UIA_ThumbControlTypeId : i32 = 50027;
pub const UIA_DataGridControlTypeId : i32 = 50028;
pub const UIA_DataItemControlTypeId : i32 = 50029;
pub const UIA_DocumentControlTypeId : i32 = 50030;
pub const UIA_SplitButtonControlTypeId : i32 = 50031;
pub const UIA_WindowControlTypeId : i32 = 50032;
pub const UIA_PaneControlTypeId : i32 = 50033;
pub const UIA_HeaderControlTypeId : i32 = 50034;
pub const UIA_HeaderItemControlTypeId : i32 = 50035;
pub const UIA_TableControlTypeId : i32 = 50036;
pub const UIA_TitleBarControlTypeId : i32 = 50037;
pub const UIA_SeparatorControlTypeId : i32 = 50038;
pub const UIA_SemanticZoomControlTypeId : i32 = 50039;
pub const UIA_AppBarControlTypeId : i32 = 50040;
pub const AnnotationType_Unknown : i32 = 60000;
pub const AnnotationType_SpellingError : i32 = 60001;
pub const AnnotationType_GrammarError : i32 = 60002;
pub const AnnotationType_Comment : i32 = 60003;
pub const AnnotationType_FormulaError : i32 = 60004;
pub const AnnotationType_TrackChanges : i32 = 60005;
pub const AnnotationType_Header : i32 = 60006;
pub const AnnotationType_Footer : i32 = 60007;
pub const AnnotationType_Highlighted : i32 = 60008;
pub const AnnotationType_Endnote : i32 = 60009;
pub const AnnotationType_Footnote : i32 = 60010;
pub const AnnotationType_InsertionChange : i32 = 60011;
pub const AnnotationType_DeletionChange : i32 = 60012;
pub const AnnotationType_MoveChange : i32 = 60013;
pub const AnnotationType_FormatChange : i32 = 60014;
pub const AnnotationType_UnsyncedChange : i32 = 60015;
pub const AnnotationType_EditingLockedChange : i32 = 60016;
pub const AnnotationType_ExternalChange : i32 = 60017;
pub const AnnotationType_ConflictingChange : i32 = 60018;
pub const AnnotationType_Author : i32 = 60019;
pub const AnnotationType_AdvancedProofingIssue : i32 = 60020;
pub const AnnotationType_DataValidationError : i32 = 60021;
pub const AnnotationType_CircularReferenceError : i32 = 60022;
pub const AnnotationType_Mathematics : i32 = 60023;
pub const AnnotationType_Sensitive : i32 = 60024;
pub const StyleId_Custom : i32 = 70000;
pub const StyleId_Heading1 : i32 = 70001;
pub const StyleId_Heading2 : i32 = 70002;
pub const StyleId_Heading3 : i32 = 70003;
pub const StyleId_Heading4 : i32 = 70004;
pub const StyleId_Heading5 : i32 = 70005;
pub const StyleId_Heading6 : i32 = 70006;
pub const StyleId_Heading7 : i32 = 70007;
pub const StyleId_Heading8 : i32 = 70008;
pub const StyleId_Heading9 : i32 = 70009;
pub const StyleId_Title : i32 = 70010;
pub const StyleId_Subtitle : i32 = 70011;
pub const StyleId_Normal : i32 = 70012;
pub const StyleId_Emphasis : i32 = 70013;
pub const StyleId_Quote : i32 = 70014;
pub const StyleId_BulletedList : i32 = 70015;
pub const StyleId_NumberedList : i32 = 70016;
pub const UIA_CustomLandmarkTypeId : i32 = 80000;
pub const UIA_FormLandmarkTypeId : i32 = 80001;
pub const UIA_MainLandmarkTypeId : i32 = 80002;
pub const UIA_NavigationLandmarkTypeId : i32 = 80003;
pub const UIA_SearchLandmarkTypeId : i32 = 80004;
pub const HeadingLevel_None : i32 = 80050;
pub const HeadingLevel1 : i32 = 80051;
pub const HeadingLevel2 : i32 = 80052;
pub const HeadingLevel3 : i32 = 80053;
pub const HeadingLevel4 : i32 = 80054;
pub const HeadingLevel5 : i32 = 80055;
pub const HeadingLevel6 : i32 = 80056;
pub const HeadingLevel7 : i32 = 80057;
pub const HeadingLevel8 : i32 = 80058;
pub const HeadingLevel9 : i32 = 80059;
pub const UIA_SummaryChangeId : i32 = 90000;
pub const UIA_SayAsInterpretAsMetadataId : i32 = 100000;

//--------------------------------------------------------------------------------
// Section: Types (250)
//--------------------------------------------------------------------------------
pub const SERIALKEYSA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpszActivePort: PSTR,
    lpszPort: PSTR,
    iBaudRate: u32,
    iPortState: u32,
    iActive: u32,
};

pub const SERIALKEYSW = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpszActivePort: PWSTR,
    lpszPort: PWSTR,
    iBaudRate: u32,
    iPortState: u32,
    iActive: u32,
};

pub const HIGHCONTRASTA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpszDefaultScheme: PSTR,
};

pub const HIGHCONTRASTW = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpszDefaultScheme: PWSTR,
};

pub const FILTERKEYS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iWaitMSec: u32,
    iDelayMSec: u32,
    iRepeatMSec: u32,
    iBounceMSec: u32,
};

pub const STICKYKEYS = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const MOUSEKEYS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iMaxSpeed: u32,
    iTimeToMaxSpeed: u32,
    iCtrlSpeed: u32,
    dwReserved1: u32,
    dwReserved2: u32,
};

pub const ACCESSTIMEOUT = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iTimeOutMSec: u32,
};

pub const SOUNDSENTRYA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iFSTextEffect: u32,
    iFSTextEffectMSec: u32,
    iFSTextEffectColorBits: u32,
    iFSGrafEffect: u32,
    iFSGrafEffectMSec: u32,
    iFSGrafEffectColor: u32,
    iWindowsEffect: u32,
    iWindowsEffectMSec: u32,
    lpszWindowsEffectDLL: PSTR,
    iWindowsEffectOrdinal: u32,
};

pub const SOUNDSENTRYW = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iFSTextEffect: u32,
    iFSTextEffectMSec: u32,
    iFSTextEffectColorBits: u32,
    iFSGrafEffect: u32,
    iFSGrafEffectMSec: u32,
    iFSGrafEffectColor: u32,
    iWindowsEffect: u32,
    iWindowsEffectMSec: u32,
    lpszWindowsEffectDLL: PWSTR,
    iWindowsEffectOrdinal: u32,
};

pub const TOGGLEKEYS = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const WINEVENTPROC = fn(
    hWinEventHook: HWINEVENTHOOK,
    event: u32,
    hwnd: HWND,
    idObject: i32,
    idChild: i32,
    idEventThread: u32,
    dwmsEventTime: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type has a FreeFunc 'UnhookWinEvent', what can Zig do with this information?
pub const HWINEVENTHOOK = ?*c_void;

const CLSID_MSAAControl_Value = @import("../zig.zig").Guid.initString("08CD963F-7A3E-4F5C-9BD8-D692BB043C5B");
pub const CLSID_MSAAControl = &CLSID_MSAAControl_Value;

const CLSID_AccStore_Value = @import("../zig.zig").Guid.initString("5440837F-4BFF-4AE5-A1B1-7722ECC6332A");
pub const CLSID_AccStore = &CLSID_AccStore_Value;

const CLSID_AccDictionary_Value = @import("../zig.zig").Guid.initString("6572EE16-5FE5-4331-BB6D-76A49C56E423");
pub const CLSID_AccDictionary = &CLSID_AccDictionary_Value;

const CLSID_AccServerDocMgr_Value = @import("../zig.zig").Guid.initString("6089A37E-EB8A-482D-BD6F-F9F46904D16D");
pub const CLSID_AccServerDocMgr = &CLSID_AccServerDocMgr_Value;

const CLSID_AccClientDocMgr_Value = @import("../zig.zig").Guid.initString("FC48CC30-4F3E-4FA1-803B-AD0E196A83B1");
pub const CLSID_AccClientDocMgr = &CLSID_AccClientDocMgr_Value;

const CLSID_DocWrap_Value = @import("../zig.zig").Guid.initString("BF426F7E-7A5E-44D6-830C-A390EA9462A3");
pub const CLSID_DocWrap = &CLSID_DocWrap_Value;

const IID_IInternalDocWrap_Value = @import("../zig.zig").Guid.initString("E1AA6466-9DB4-40BA-BE03-77C38E8E60B2");
pub const IID_IInternalDocWrap = &IID_IInternalDocWrap_Value;
pub const IInternalDocWrap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyRevoke: fn(
            self: *const IInternalDocWrap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInternalDocWrap_NotifyRevoke(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInternalDocWrap.VTable, self.vtable).NotifyRevoke(@ptrCast(*const IInternalDocWrap, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreACPEx_Value = @import("../zig.zig").Guid.initString("A2DE3BC2-3D8E-11D3-81A9-F753FBE61A00");
pub const IID_ITextStoreACPEx = &IID_ITextStoreACPEx_Value;
pub const ITextStoreACPEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollToRect: fn(
            self: *const ITextStoreACPEx,
            acpStart: i32,
            acpEnd: i32,
            rc: RECT,
            dwPosition: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPEx_ScrollToRect(self: *const T, acpStart: i32, acpEnd: i32, rc: RECT, dwPosition: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPEx.VTable, self.vtable).ScrollToRect(@ptrCast(*const ITextStoreACPEx, self), acpStart, acpEnd, rc, dwPosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreAnchorEx_Value = @import("../zig.zig").Guid.initString("A2DE3BC1-3D8E-11D3-81A9-F753FBE61A00");
pub const IID_ITextStoreAnchorEx = &IID_ITextStoreAnchorEx_Value;
pub const ITextStoreAnchorEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollToRect: fn(
            self: *const ITextStoreAnchorEx,
            pStart: *IAnchor,
            pEnd: *IAnchor,
            rc: RECT,
            dwPosition: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreAnchorEx_ScrollToRect(self: *const T, pStart: *IAnchor, pEnd: *IAnchor, rc: RECT, dwPosition: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreAnchorEx.VTable, self.vtable).ScrollToRect(@ptrCast(*const ITextStoreAnchorEx, self), pStart, pEnd, rc, dwPosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreACPSinkEx_Value = @import("../zig.zig").Guid.initString("2BDF9464-41E2-43E3-950C-A6865BA25CD4");
pub const IID_ITextStoreACPSinkEx = &IID_ITextStoreACPSinkEx_Value;
pub const ITextStoreACPSinkEx = extern struct {
    pub const VTable = extern struct {
        base: ITextStoreACPSink.VTable,
        OnDisconnect: fn(
            self: *const ITextStoreACPSinkEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextStoreACPSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreACPSinkEx_OnDisconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreACPSinkEx.VTable, self.vtable).OnDisconnect(@ptrCast(*const ITextStoreACPSinkEx, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoreSinkAnchorEx_Value = @import("../zig.zig").Guid.initString("25642426-028D-4474-977B-111BB114FE3E");
pub const IID_ITextStoreSinkAnchorEx = &IID_ITextStoreSinkAnchorEx_Value;
pub const ITextStoreSinkAnchorEx = extern struct {
    pub const VTable = extern struct {
        base: ITextStoreAnchorSink.VTable,
        OnDisconnect: fn(
            self: *const ITextStoreSinkAnchorEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextStoreAnchorSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoreSinkAnchorEx_OnDisconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoreSinkAnchorEx.VTable, self.vtable).OnDisconnect(@ptrCast(*const ITextStoreSinkAnchorEx, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccDictionary_Value = @import("../zig.zig").Guid.initString("1DC4CB5F-D737-474D-ADE9-5CCFC9BC1CC9");
pub const IID_IAccDictionary = &IID_IAccDictionary_Value;
pub const IAccDictionary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLocalizedString: fn(
            self: *const IAccDictionary,
            Term: *const Guid,
            lcid: u32,
            pResult: *BSTR,
            plcid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentTerm: fn(
            self: *const IAccDictionary,
            Term: *const Guid,
            pParentTerm: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMnemonicString: fn(
            self: *const IAccDictionary,
            Term: *const Guid,
            pResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupMnemonicTerm: fn(
            self: *const IAccDictionary,
            bstrMnemonic: BSTR,
            pTerm: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertValueToString: fn(
            self: *const IAccDictionary,
            Term: *const Guid,
            lcid: u32,
            varValue: VARIANT,
            pbstrResult: *BSTR,
            plcid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccDictionary_GetLocalizedString(self: *const T, Term: *const Guid, lcid: u32, pResult: *BSTR, plcid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccDictionary.VTable, self.vtable).GetLocalizedString(@ptrCast(*const IAccDictionary, self), Term, lcid, pResult, plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccDictionary_GetParentTerm(self: *const T, Term: *const Guid, pParentTerm: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccDictionary.VTable, self.vtable).GetParentTerm(@ptrCast(*const IAccDictionary, self), Term, pParentTerm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccDictionary_GetMnemonicString(self: *const T, Term: *const Guid, pResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccDictionary.VTable, self.vtable).GetMnemonicString(@ptrCast(*const IAccDictionary, self), Term, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccDictionary_LookupMnemonicTerm(self: *const T, bstrMnemonic: BSTR, pTerm: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccDictionary.VTable, self.vtable).LookupMnemonicTerm(@ptrCast(*const IAccDictionary, self), bstrMnemonic, pTerm);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccDictionary_ConvertValueToString(self: *const T, Term: *const Guid, lcid: u32, varValue: VARIANT, pbstrResult: *BSTR, plcid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccDictionary.VTable, self.vtable).ConvertValueToString(@ptrCast(*const IAccDictionary, self), Term, lcid, varValue, pbstrResult, plcid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVersionInfo_Value = @import("../zig.zig").Guid.initString("401518EC-DB00-4611-9B29-2A0E4B9AFA85");
pub const IID_IVersionInfo = &IID_IVersionInfo_Value;
pub const IVersionInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSubcomponentCount: fn(
            self: *const IVersionInfo,
            ulSub: u32,
            ulCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplementationID: fn(
            self: *const IVersionInfo,
            ulSub: u32,
            implid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuildVersion: fn(
            self: *const IVersionInfo,
            ulSub: u32,
            pdwMajor: *u32,
            pdwMinor: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentDescription: fn(
            self: *const IVersionInfo,
            ulSub: u32,
            pImplStr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInstanceDescription: fn(
            self: *const IVersionInfo,
            ulSub: u32,
            pImplStr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVersionInfo_GetSubcomponentCount(self: *const T, ulSub: u32, ulCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVersionInfo.VTable, self.vtable).GetSubcomponentCount(@ptrCast(*const IVersionInfo, self), ulSub, ulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVersionInfo_GetImplementationID(self: *const T, ulSub: u32, implid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVersionInfo.VTable, self.vtable).GetImplementationID(@ptrCast(*const IVersionInfo, self), ulSub, implid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVersionInfo_GetBuildVersion(self: *const T, ulSub: u32, pdwMajor: *u32, pdwMinor: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVersionInfo.VTable, self.vtable).GetBuildVersion(@ptrCast(*const IVersionInfo, self), ulSub, pdwMajor, pdwMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVersionInfo_GetComponentDescription(self: *const T, ulSub: u32, pImplStr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVersionInfo.VTable, self.vtable).GetComponentDescription(@ptrCast(*const IVersionInfo, self), ulSub, pImplStr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVersionInfo_GetInstanceDescription(self: *const T, ulSub: u32, pImplStr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVersionInfo.VTable, self.vtable).GetInstanceDescription(@ptrCast(*const IVersionInfo, self), ulSub, pImplStr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICoCreateLocally_Value = @import("../zig.zig").Guid.initString("03DE00AA-F272-41E3-99CB-03C5E8114EA0");
pub const IID_ICoCreateLocally = &IID_ICoCreateLocally_Value;
pub const ICoCreateLocally = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CoCreateLocally: fn(
            self: *const ICoCreateLocally,
            rclsid: *const Guid,
            dwClsContext: u32,
            riid: *const Guid,
            punk: **IUnknown,
            riidParam: *const Guid,
            punkParam: ?*IUnknown,
            varParam: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICoCreateLocally_CoCreateLocally(self: *const T, rclsid: *const Guid, dwClsContext: u32, riid: *const Guid, punk: **IUnknown, riidParam: *const Guid, punkParam: ?*IUnknown, varParam: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICoCreateLocally.VTable, self.vtable).CoCreateLocally(@ptrCast(*const ICoCreateLocally, self), rclsid, dwClsContext, riid, punk, riidParam, punkParam, varParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICoCreatedLocally_Value = @import("../zig.zig").Guid.initString("0A53EB6C-1908-4742-8CFF-2CEE2E93F94C");
pub const IID_ICoCreatedLocally = &IID_ICoCreatedLocally_Value;
pub const ICoCreatedLocally = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LocalInit: fn(
            self: *const ICoCreatedLocally,
            punkLocalObject: *IUnknown,
            riidParam: *const Guid,
            punkParam: ?*IUnknown,
            varParam: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICoCreatedLocally_LocalInit(self: *const T, punkLocalObject: *IUnknown, riidParam: *const Guid, punkParam: ?*IUnknown, varParam: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICoCreatedLocally.VTable, self.vtable).LocalInit(@ptrCast(*const ICoCreatedLocally, self), punkLocalObject, riidParam, punkParam, varParam);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccStore_Value = @import("../zig.zig").Guid.initString("E2CD4A63-2B72-4D48-B739-95E4765195BA");
pub const IID_IAccStore = &IID_IAccStore_Value;
pub const IAccStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Register: fn(
            self: *const IAccStore,
            riid: *const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: fn(
            self: *const IAccStore,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocuments: fn(
            self: *const IAccStore,
            enumUnknown: **IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupByHWND: fn(
            self: *const IAccStore,
            hWnd: HWND,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupByPoint: fn(
            self: *const IAccStore,
            pt: POINT,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDocumentFocus: fn(
            self: *const IAccStore,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocused: fn(
            self: *const IAccStore,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccStore_Register(self: *const T, riid: *const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccStore.VTable, self.vtable).Register(@ptrCast(*const IAccStore, self), riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccStore_Unregister(self: *const T, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccStore.VTable, self.vtable).Unregister(@ptrCast(*const IAccStore, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccStore_GetDocuments(self: *const T, enumUnknown: **IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccStore.VTable, self.vtable).GetDocuments(@ptrCast(*const IAccStore, self), enumUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccStore_LookupByHWND(self: *const T, hWnd: HWND, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccStore.VTable, self.vtable).LookupByHWND(@ptrCast(*const IAccStore, self), hWnd, riid, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccStore_LookupByPoint(self: *const T, pt: POINT, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccStore.VTable, self.vtable).LookupByPoint(@ptrCast(*const IAccStore, self), pt, riid, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccStore_OnDocumentFocus(self: *const T, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccStore.VTable, self.vtable).OnDocumentFocus(@ptrCast(*const IAccStore, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccStore_GetFocused(self: *const T, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccStore.VTable, self.vtable).GetFocused(@ptrCast(*const IAccStore, self), riid, ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccServerDocMgr_Value = @import("../zig.zig").Guid.initString("AD7C73CF-6DD5-4855-ABC2-B04BAD5B9153");
pub const IID_IAccServerDocMgr = &IID_IAccServerDocMgr_Value;
pub const IAccServerDocMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NewDocument: fn(
            self: *const IAccServerDocMgr,
            riid: *const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevokeDocument: fn(
            self: *const IAccServerDocMgr,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDocumentFocus: fn(
            self: *const IAccServerDocMgr,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccServerDocMgr_NewDocument(self: *const T, riid: *const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccServerDocMgr.VTable, self.vtable).NewDocument(@ptrCast(*const IAccServerDocMgr, self), riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccServerDocMgr_RevokeDocument(self: *const T, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccServerDocMgr.VTable, self.vtable).RevokeDocument(@ptrCast(*const IAccServerDocMgr, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccServerDocMgr_OnDocumentFocus(self: *const T, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccServerDocMgr.VTable, self.vtable).OnDocumentFocus(@ptrCast(*const IAccServerDocMgr, self), punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccClientDocMgr_Value = @import("../zig.zig").Guid.initString("4C896039-7B6D-49E6-A8C1-45116A98292B");
pub const IID_IAccClientDocMgr = &IID_IAccClientDocMgr_Value;
pub const IAccClientDocMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocuments: fn(
            self: *const IAccClientDocMgr,
            enumUnknown: **IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupByHWND: fn(
            self: *const IAccClientDocMgr,
            hWnd: HWND,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupByPoint: fn(
            self: *const IAccClientDocMgr,
            pt: POINT,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocused: fn(
            self: *const IAccClientDocMgr,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccClientDocMgr_GetDocuments(self: *const T, enumUnknown: **IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccClientDocMgr.VTable, self.vtable).GetDocuments(@ptrCast(*const IAccClientDocMgr, self), enumUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccClientDocMgr_LookupByHWND(self: *const T, hWnd: HWND, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccClientDocMgr.VTable, self.vtable).LookupByHWND(@ptrCast(*const IAccClientDocMgr, self), hWnd, riid, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccClientDocMgr_LookupByPoint(self: *const T, pt: POINT, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccClientDocMgr.VTable, self.vtable).LookupByPoint(@ptrCast(*const IAccClientDocMgr, self), pt, riid, ppunk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccClientDocMgr_GetFocused(self: *const T, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccClientDocMgr.VTable, self.vtable).GetFocused(@ptrCast(*const IAccClientDocMgr, self), riid, ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocWrap_Value = @import("../zig.zig").Guid.initString("DCD285FE-0BE0-43BD-99C9-AAAEC513C555");
pub const IID_IDocWrap = &IID_IDocWrap_Value;
pub const IDocWrap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDoc: fn(
            self: *const IDocWrap,
            riid: *const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWrappedDoc: fn(
            self: *const IDocWrap,
            riid: *const Guid,
            ppunk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocWrap_SetDoc(self: *const T, riid: *const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocWrap.VTable, self.vtable).SetDoc(@ptrCast(*const IDocWrap, self), riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocWrap_GetWrappedDoc(self: *const T, riid: *const Guid, ppunk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocWrap.VTable, self.vtable).GetWrappedDoc(@ptrCast(*const IDocWrap, self), riid, ppunk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IClonableWrapper_Value = @import("../zig.zig").Guid.initString("B33E75FF-E84C-4DCA-A25C-33B8DC003374");
pub const IID_IClonableWrapper = &IID_IClonableWrapper_Value;
pub const IClonableWrapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CloneNewWrapper: fn(
            self: *const IClonableWrapper,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClonableWrapper_CloneNewWrapper(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClonableWrapper.VTable, self.vtable).CloneNewWrapper(@ptrCast(*const IClonableWrapper, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CAccPropServices_Value = @import("../zig.zig").Guid.initString("B5F8350B-0548-48B1-A6EE-88BD00B4A5E7");
pub const CLSID_CAccPropServices = &CLSID_CAccPropServices_Value;

pub const LPFNLRESULTFROMOBJECT = fn(
    riid: *const Guid,
    wParam: WPARAM,
    punk: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub const LPFNOBJECTFROMLRESULT = fn(
    lResult: LRESULT,
    riid: *const Guid,
    wParam: WPARAM,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPFNACCESSIBLEOBJECTFROMWINDOW = fn(
    hwnd: HWND,
    dwId: u32,
    riid: *const Guid,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPFNACCESSIBLEOBJECTFROMPOINT = fn(
    ptScreen: POINT,
    ppacc: **IAccessible,
    pvarChild: *VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPFNCREATESTDACCESSIBLEOBJECT = fn(
    hwnd: HWND,
    idObject: i32,
    riid: *const Guid,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPFNACCESSIBLECHILDREN = fn(
    paccContainer: *IAccessible,
    iChildStart: i32,
    cChildren: i32,
    rgvarChildren: *VARIANT,
    pcObtained: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const MSAAMENUINFO = extern struct {
    dwMSAASignature: u32,
    cchWText: u32,
    pszWText: PWSTR,
};

const IID_IAccessible_Value = @import("../zig.zig").Guid.initString("618736E0-3C3D-11CF-810C-00AA00389B71");
pub const IID_IAccessible = &IID_IAccessible_Value;
pub const IAccessible = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_accParent: fn(
            self: *const IAccessible,
            ppdispParent: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accChildCount: fn(
            self: *const IAccessible,
            pcountChildren: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accChild: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            ppdispChild: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accName: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            pszName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accValue: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            pszValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accDescription: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            pszDescription: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accRole: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            pvarRole: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accState: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            pvarState: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accHelp: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            pszHelp: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accHelpTopic: fn(
            self: *const IAccessible,
            pszHelpFile: *BSTR,
            varChild: VARIANT,
            pidTopic: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accKeyboardShortcut: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            pszKeyboardShortcut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accFocus: fn(
            self: *const IAccessible,
            pvarChild: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accSelection: fn(
            self: *const IAccessible,
            pvarChildren: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accDefaultAction: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            pszDefaultAction: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        accSelect: fn(
            self: *const IAccessible,
            flagsSelect: i32,
            varChild: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        accLocation: fn(
            self: *const IAccessible,
            pxLeft: *i32,
            pyTop: *i32,
            pcxWidth: *i32,
            pcyHeight: *i32,
            varChild: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        accNavigate: fn(
            self: *const IAccessible,
            navDir: i32,
            varStart: VARIANT,
            pvarEndUpAt: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        accHitTest: fn(
            self: *const IAccessible,
            xLeft: i32,
            yTop: i32,
            pvarChild: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        accDoDefaultAction: fn(
            self: *const IAccessible,
            varChild: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_accName: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            szName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_accValue: fn(
            self: *const IAccessible,
            varChild: VARIANT,
            szValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accParent(self: *const T, ppdispParent: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accParent(@ptrCast(*const IAccessible, self), ppdispParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accChildCount(self: *const T, pcountChildren: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accChildCount(@ptrCast(*const IAccessible, self), pcountChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accChild(self: *const T, varChild: VARIANT, ppdispChild: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accChild(@ptrCast(*const IAccessible, self), varChild, ppdispChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accName(self: *const T, varChild: VARIANT, pszName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accName(@ptrCast(*const IAccessible, self), varChild, pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accValue(self: *const T, varChild: VARIANT, pszValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accValue(@ptrCast(*const IAccessible, self), varChild, pszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accDescription(self: *const T, varChild: VARIANT, pszDescription: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accDescription(@ptrCast(*const IAccessible, self), varChild, pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accRole(self: *const T, varChild: VARIANT, pvarRole: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accRole(@ptrCast(*const IAccessible, self), varChild, pvarRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accState(self: *const T, varChild: VARIANT, pvarState: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accState(@ptrCast(*const IAccessible, self), varChild, pvarState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accHelp(self: *const T, varChild: VARIANT, pszHelp: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accHelp(@ptrCast(*const IAccessible, self), varChild, pszHelp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accHelpTopic(self: *const T, pszHelpFile: *BSTR, varChild: VARIANT, pidTopic: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accHelpTopic(@ptrCast(*const IAccessible, self), pszHelpFile, varChild, pidTopic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accKeyboardShortcut(self: *const T, varChild: VARIANT, pszKeyboardShortcut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accKeyboardShortcut(@ptrCast(*const IAccessible, self), varChild, pszKeyboardShortcut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accFocus(self: *const T, pvarChild: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accFocus(@ptrCast(*const IAccessible, self), pvarChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accSelection(self: *const T, pvarChildren: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accSelection(@ptrCast(*const IAccessible, self), pvarChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_get_accDefaultAction(self: *const T, varChild: VARIANT, pszDefaultAction: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).get_accDefaultAction(@ptrCast(*const IAccessible, self), varChild, pszDefaultAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accSelect(self: *const T, flagsSelect: i32, varChild: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accSelect(@ptrCast(*const IAccessible, self), flagsSelect, varChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accLocation(self: *const T, pxLeft: *i32, pyTop: *i32, pcxWidth: *i32, pcyHeight: *i32, varChild: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accLocation(@ptrCast(*const IAccessible, self), pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accNavigate(self: *const T, navDir: i32, varStart: VARIANT, pvarEndUpAt: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accNavigate(@ptrCast(*const IAccessible, self), navDir, varStart, pvarEndUpAt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accHitTest(self: *const T, xLeft: i32, yTop: i32, pvarChild: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accHitTest(@ptrCast(*const IAccessible, self), xLeft, yTop, pvarChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_accDoDefaultAction(self: *const T, varChild: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).accDoDefaultAction(@ptrCast(*const IAccessible, self), varChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_put_accName(self: *const T, varChild: VARIANT, szName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).put_accName(@ptrCast(*const IAccessible, self), varChild, szName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessible_put_accValue(self: *const T, varChild: VARIANT, szValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessible.VTable, self.vtable).put_accValue(@ptrCast(*const IAccessible, self), varChild, szValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccessibleHandler_Value = @import("../zig.zig").Guid.initString("03022430-ABC4-11D0-BDE2-00AA001A1953");
pub const IID_IAccessibleHandler = &IID_IAccessibleHandler_Value;
pub const IAccessibleHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AccessibleObjectFromID: fn(
            self: *const IAccessibleHandler,
            hwnd: i32,
            lObjectID: i32,
            pIAccessible: **IAccessible,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleHandler_AccessibleObjectFromID(self: *const T, hwnd: i32, lObjectID: i32, pIAccessible: **IAccessible) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleHandler.VTable, self.vtable).AccessibleObjectFromID(@ptrCast(*const IAccessibleHandler, self), hwnd, lObjectID, pIAccessible);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccessibleWindowlessSite_Value = @import("../zig.zig").Guid.initString("BF3ABD9C-76DA-4389-9EB6-1427D25ABAB7");
pub const IID_IAccessibleWindowlessSite = &IID_IAccessibleWindowlessSite_Value;
pub const IAccessibleWindowlessSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AcquireObjectIdRange: fn(
            self: *const IAccessibleWindowlessSite,
            rangeSize: i32,
            pRangeOwner: *IAccessibleHandler,
            pRangeBase: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseObjectIdRange: fn(
            self: *const IAccessibleWindowlessSite,
            rangeBase: i32,
            pRangeOwner: *IAccessibleHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryObjectIdRanges: fn(
            self: *const IAccessibleWindowlessSite,
            pRangesOwner: *IAccessibleHandler,
            psaRanges: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentAccessible: fn(
            self: *const IAccessibleWindowlessSite,
            ppParent: **IAccessible,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleWindowlessSite_AcquireObjectIdRange(self: *const T, rangeSize: i32, pRangeOwner: *IAccessibleHandler, pRangeBase: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleWindowlessSite.VTable, self.vtable).AcquireObjectIdRange(@ptrCast(*const IAccessibleWindowlessSite, self), rangeSize, pRangeOwner, pRangeBase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleWindowlessSite_ReleaseObjectIdRange(self: *const T, rangeBase: i32, pRangeOwner: *IAccessibleHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleWindowlessSite.VTable, self.vtable).ReleaseObjectIdRange(@ptrCast(*const IAccessibleWindowlessSite, self), rangeBase, pRangeOwner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleWindowlessSite_QueryObjectIdRanges(self: *const T, pRangesOwner: *IAccessibleHandler, psaRanges: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleWindowlessSite.VTable, self.vtable).QueryObjectIdRanges(@ptrCast(*const IAccessibleWindowlessSite, self), pRangesOwner, psaRanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleWindowlessSite_GetParentAccessible(self: *const T, ppParent: **IAccessible) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleWindowlessSite.VTable, self.vtable).GetParentAccessible(@ptrCast(*const IAccessibleWindowlessSite, self), ppParent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const AnnoScope = extern enum(i32) {
    ANNO_THIS = 0,
    ANNO_CONTAINER = 1,
};
pub const ANNO_THIS = AnnoScope.ANNO_THIS;
pub const ANNO_CONTAINER = AnnoScope.ANNO_CONTAINER;

const IID_IAccIdentity_Value = @import("../zig.zig").Guid.initString("7852B78D-1CFD-41C1-A615-9C0C85960B5F");
pub const IID_IAccIdentity = &IID_IAccIdentity_Value;
pub const IAccIdentity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdentityString: fn(
            self: *const IAccIdentity,
            dwIDChild: u32,
            ppIDString: [*]*u8,
            pdwIDStringLen: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccIdentity_GetIdentityString(self: *const T, dwIDChild: u32, ppIDString: [*]*u8, pdwIDStringLen: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccIdentity.VTable, self.vtable).GetIdentityString(@ptrCast(*const IAccIdentity, self), dwIDChild, ppIDString, pdwIDStringLen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccPropServer_Value = @import("../zig.zig").Guid.initString("76C0DBBB-15E0-4E7B-B61B-20EEEA2001E0");
pub const IID_IAccPropServer = &IID_IAccPropServer_Value;
pub const IAccPropServer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropValue: fn(
            self: *const IAccPropServer,
            pIDString: [*:0]const u8,
            dwIDStringLen: u32,
            idProp: Guid,
            pvarValue: *VARIANT,
            pfHasProp: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServer_GetPropValue(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, idProp: Guid, pvarValue: *VARIANT, pfHasProp: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServer.VTable, self.vtable).GetPropValue(@ptrCast(*const IAccPropServer, self), pIDString, dwIDStringLen, idProp, pvarValue, pfHasProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccPropServices_Value = @import("../zig.zig").Guid.initString("6E26E776-04F0-495D-80E4-3330352E3169");
pub const IID_IAccPropServices = &IID_IAccPropServices_Value;
pub const IAccPropServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPropValue: fn(
            self: *const IAccPropServices,
            pIDString: [*:0]const u8,
            dwIDStringLen: u32,
            idProp: Guid,
            @"var": VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPropServer: fn(
            self: *const IAccPropServices,
            pIDString: [*:0]const u8,
            dwIDStringLen: u32,
            paProps: [*]const Guid,
            cProps: i32,
            pServer: *IAccPropServer,
            annoScope: AnnoScope,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearProps: fn(
            self: *const IAccPropServices,
            pIDString: [*:0]const u8,
            dwIDStringLen: u32,
            paProps: [*]const Guid,
            cProps: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHwndProp: fn(
            self: *const IAccPropServices,
            hwnd: HWND,
            idObject: u32,
            idChild: u32,
            idProp: Guid,
            @"var": VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHwndPropStr: fn(
            self: *const IAccPropServices,
            hwnd: HWND,
            idObject: u32,
            idChild: u32,
            idProp: Guid,
            str: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHwndPropServer: fn(
            self: *const IAccPropServices,
            hwnd: HWND,
            idObject: u32,
            idChild: u32,
            paProps: [*]const Guid,
            cProps: i32,
            pServer: *IAccPropServer,
            annoScope: AnnoScope,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearHwndProps: fn(
            self: *const IAccPropServices,
            hwnd: HWND,
            idObject: u32,
            idChild: u32,
            paProps: [*]const Guid,
            cProps: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComposeHwndIdentityString: fn(
            self: *const IAccPropServices,
            hwnd: HWND,
            idObject: u32,
            idChild: u32,
            ppIDString: [*]*u8,
            pdwIDStringLen: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecomposeHwndIdentityString: fn(
            self: *const IAccPropServices,
            pIDString: [*:0]const u8,
            dwIDStringLen: u32,
            phwnd: *HWND,
            pidObject: *u32,
            pidChild: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHmenuProp: fn(
            self: *const IAccPropServices,
            hmenu: HMENU,
            idChild: u32,
            idProp: Guid,
            @"var": VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHmenuPropStr: fn(
            self: *const IAccPropServices,
            hmenu: HMENU,
            idChild: u32,
            idProp: Guid,
            str: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHmenuPropServer: fn(
            self: *const IAccPropServices,
            hmenu: HMENU,
            idChild: u32,
            paProps: [*]const Guid,
            cProps: i32,
            pServer: *IAccPropServer,
            annoScope: AnnoScope,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearHmenuProps: fn(
            self: *const IAccPropServices,
            hmenu: HMENU,
            idChild: u32,
            paProps: [*]const Guid,
            cProps: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ComposeHmenuIdentityString: fn(
            self: *const IAccPropServices,
            hmenu: HMENU,
            idChild: u32,
            ppIDString: [*]*u8,
            pdwIDStringLen: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecomposeHmenuIdentityString: fn(
            self: *const IAccPropServices,
            pIDString: [*:0]const u8,
            dwIDStringLen: u32,
            phmenu: *HMENU,
            pidChild: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetPropValue(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, idProp: Guid, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetPropValue(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, idProp, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetPropServer(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, paProps: [*]const Guid, cProps: i32, pServer: *IAccPropServer, annoScope: AnnoScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetPropServer(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, paProps, cProps, pServer, annoScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ClearProps(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, paProps: [*]const Guid, cProps: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ClearProps(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, paProps, cProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHwndProp(self: *const T, hwnd: HWND, idObject: u32, idChild: u32, idProp: Guid, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHwndProp(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, idProp, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHwndPropStr(self: *const T, hwnd: HWND, idObject: u32, idChild: u32, idProp: Guid, str: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHwndPropStr(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, idProp, str);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHwndPropServer(self: *const T, hwnd: HWND, idObject: u32, idChild: u32, paProps: [*]const Guid, cProps: i32, pServer: *IAccPropServer, annoScope: AnnoScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHwndPropServer(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, paProps, cProps, pServer, annoScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ClearHwndProps(self: *const T, hwnd: HWND, idObject: u32, idChild: u32, paProps: [*]const Guid, cProps: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ClearHwndProps(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, paProps, cProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ComposeHwndIdentityString(self: *const T, hwnd: HWND, idObject: u32, idChild: u32, ppIDString: [*]*u8, pdwIDStringLen: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ComposeHwndIdentityString(@ptrCast(*const IAccPropServices, self), hwnd, idObject, idChild, ppIDString, pdwIDStringLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_DecomposeHwndIdentityString(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, phwnd: *HWND, pidObject: *u32, pidChild: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).DecomposeHwndIdentityString(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, phwnd, pidObject, pidChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHmenuProp(self: *const T, hmenu: HMENU, idChild: u32, idProp: Guid, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHmenuProp(@ptrCast(*const IAccPropServices, self), hmenu, idChild, idProp, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHmenuPropStr(self: *const T, hmenu: HMENU, idChild: u32, idProp: Guid, str: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHmenuPropStr(@ptrCast(*const IAccPropServices, self), hmenu, idChild, idProp, str);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_SetHmenuPropServer(self: *const T, hmenu: HMENU, idChild: u32, paProps: [*]const Guid, cProps: i32, pServer: *IAccPropServer, annoScope: AnnoScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).SetHmenuPropServer(@ptrCast(*const IAccPropServices, self), hmenu, idChild, paProps, cProps, pServer, annoScope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ClearHmenuProps(self: *const T, hmenu: HMENU, idChild: u32, paProps: [*]const Guid, cProps: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ClearHmenuProps(@ptrCast(*const IAccPropServices, self), hmenu, idChild, paProps, cProps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_ComposeHmenuIdentityString(self: *const T, hmenu: HMENU, idChild: u32, ppIDString: [*]*u8, pdwIDStringLen: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).ComposeHmenuIdentityString(@ptrCast(*const IAccPropServices, self), hmenu, idChild, ppIDString, pdwIDStringLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccPropServices_DecomposeHmenuIdentityString(self: *const T, pIDString: [*:0]const u8, dwIDStringLen: u32, phmenu: *HMENU, pidChild: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccPropServices.VTable, self.vtable).DecomposeHmenuIdentityString(@ptrCast(*const IAccPropServices, self), pIDString, dwIDStringLen, phmenu, pidChild);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CUIAutomationRegistrar_Value = @import("../zig.zig").Guid.initString("6E29FABF-9977-42D1-8D0E-CA7E61AD87E6");
pub const CLSID_CUIAutomationRegistrar = &CLSID_CUIAutomationRegistrar_Value;

pub const NavigateDirection = extern enum(i32) {
    Parent = 0,
    NextSibling = 1,
    PreviousSibling = 2,
    FirstChild = 3,
    LastChild = 4,
};
pub const NavigateDirection_Parent = NavigateDirection.Parent;
pub const NavigateDirection_NextSibling = NavigateDirection.NextSibling;
pub const NavigateDirection_PreviousSibling = NavigateDirection.PreviousSibling;
pub const NavigateDirection_FirstChild = NavigateDirection.FirstChild;
pub const NavigateDirection_LastChild = NavigateDirection.LastChild;

pub const ProviderOptions = extern enum(i32) {
    ClientSideProvider = 1,
    ServerSideProvider = 2,
    NonClientAreaProvider = 4,
    OverrideProvider = 8,
    ProviderOwnsSetFocus = 16,
    UseComThreading = 32,
    RefuseNonClientSupport = 64,
    HasNativeIAccessible = 128,
    UseClientCoordinates = 256,
};
pub const ProviderOptions_ClientSideProvider = ProviderOptions.ClientSideProvider;
pub const ProviderOptions_ServerSideProvider = ProviderOptions.ServerSideProvider;
pub const ProviderOptions_NonClientAreaProvider = ProviderOptions.NonClientAreaProvider;
pub const ProviderOptions_OverrideProvider = ProviderOptions.OverrideProvider;
pub const ProviderOptions_ProviderOwnsSetFocus = ProviderOptions.ProviderOwnsSetFocus;
pub const ProviderOptions_UseComThreading = ProviderOptions.UseComThreading;
pub const ProviderOptions_RefuseNonClientSupport = ProviderOptions.RefuseNonClientSupport;
pub const ProviderOptions_HasNativeIAccessible = ProviderOptions.HasNativeIAccessible;
pub const ProviderOptions_UseClientCoordinates = ProviderOptions.UseClientCoordinates;

pub const StructureChangeType = extern enum(i32) {
    ChildAdded = 0,
    ChildRemoved = 1,
    ChildrenInvalidated = 2,
    ChildrenBulkAdded = 3,
    ChildrenBulkRemoved = 4,
    ChildrenReordered = 5,
};
pub const StructureChangeType_ChildAdded = StructureChangeType.ChildAdded;
pub const StructureChangeType_ChildRemoved = StructureChangeType.ChildRemoved;
pub const StructureChangeType_ChildrenInvalidated = StructureChangeType.ChildrenInvalidated;
pub const StructureChangeType_ChildrenBulkAdded = StructureChangeType.ChildrenBulkAdded;
pub const StructureChangeType_ChildrenBulkRemoved = StructureChangeType.ChildrenBulkRemoved;
pub const StructureChangeType_ChildrenReordered = StructureChangeType.ChildrenReordered;

pub const TextEditChangeType = extern enum(i32) {
    None = 0,
    AutoCorrect = 1,
    Composition = 2,
    CompositionFinalized = 3,
    AutoComplete = 4,
};
pub const TextEditChangeType_None = TextEditChangeType.None;
pub const TextEditChangeType_AutoCorrect = TextEditChangeType.AutoCorrect;
pub const TextEditChangeType_Composition = TextEditChangeType.Composition;
pub const TextEditChangeType_CompositionFinalized = TextEditChangeType.CompositionFinalized;
pub const TextEditChangeType_AutoComplete = TextEditChangeType.AutoComplete;

pub const OrientationType = extern enum(i32) {
    None = 0,
    Horizontal = 1,
    Vertical = 2,
};
pub const OrientationType_None = OrientationType.None;
pub const OrientationType_Horizontal = OrientationType.Horizontal;
pub const OrientationType_Vertical = OrientationType.Vertical;

pub const DockPosition = extern enum(i32) {
    Top = 0,
    Left = 1,
    Bottom = 2,
    Right = 3,
    Fill = 4,
    None = 5,
};
pub const DockPosition_Top = DockPosition.Top;
pub const DockPosition_Left = DockPosition.Left;
pub const DockPosition_Bottom = DockPosition.Bottom;
pub const DockPosition_Right = DockPosition.Right;
pub const DockPosition_Fill = DockPosition.Fill;
pub const DockPosition_None = DockPosition.None;

pub const ExpandCollapseState = extern enum(i32) {
    Collapsed = 0,
    Expanded = 1,
    PartiallyExpanded = 2,
    LeafNode = 3,
};
pub const ExpandCollapseState_Collapsed = ExpandCollapseState.Collapsed;
pub const ExpandCollapseState_Expanded = ExpandCollapseState.Expanded;
pub const ExpandCollapseState_PartiallyExpanded = ExpandCollapseState.PartiallyExpanded;
pub const ExpandCollapseState_LeafNode = ExpandCollapseState.LeafNode;

pub const ScrollAmount = extern enum(i32) {
    LargeDecrement = 0,
    SmallDecrement = 1,
    NoAmount = 2,
    LargeIncrement = 3,
    SmallIncrement = 4,
};
pub const ScrollAmount_LargeDecrement = ScrollAmount.LargeDecrement;
pub const ScrollAmount_SmallDecrement = ScrollAmount.SmallDecrement;
pub const ScrollAmount_NoAmount = ScrollAmount.NoAmount;
pub const ScrollAmount_LargeIncrement = ScrollAmount.LargeIncrement;
pub const ScrollAmount_SmallIncrement = ScrollAmount.SmallIncrement;

pub const RowOrColumnMajor = extern enum(i32) {
    RowMajor = 0,
    ColumnMajor = 1,
    Indeterminate = 2,
};
pub const RowOrColumnMajor_RowMajor = RowOrColumnMajor.RowMajor;
pub const RowOrColumnMajor_ColumnMajor = RowOrColumnMajor.ColumnMajor;
pub const RowOrColumnMajor_Indeterminate = RowOrColumnMajor.Indeterminate;

pub const ToggleState = extern enum(i32) {
    Off = 0,
    On = 1,
    Indeterminate = 2,
};
pub const ToggleState_Off = ToggleState.Off;
pub const ToggleState_On = ToggleState.On;
pub const ToggleState_Indeterminate = ToggleState.Indeterminate;

pub const WindowVisualState = extern enum(i32) {
    Normal = 0,
    Maximized = 1,
    Minimized = 2,
};
pub const WindowVisualState_Normal = WindowVisualState.Normal;
pub const WindowVisualState_Maximized = WindowVisualState.Maximized;
pub const WindowVisualState_Minimized = WindowVisualState.Minimized;

pub const SynchronizedInputType = extern enum(i32) {
    KeyUp = 1,
    KeyDown = 2,
    LeftMouseUp = 4,
    LeftMouseDown = 8,
    RightMouseUp = 16,
    RightMouseDown = 32,
};
pub const SynchronizedInputType_KeyUp = SynchronizedInputType.KeyUp;
pub const SynchronizedInputType_KeyDown = SynchronizedInputType.KeyDown;
pub const SynchronizedInputType_LeftMouseUp = SynchronizedInputType.LeftMouseUp;
pub const SynchronizedInputType_LeftMouseDown = SynchronizedInputType.LeftMouseDown;
pub const SynchronizedInputType_RightMouseUp = SynchronizedInputType.RightMouseUp;
pub const SynchronizedInputType_RightMouseDown = SynchronizedInputType.RightMouseDown;

pub const WindowInteractionState = extern enum(i32) {
    Running = 0,
    Closing = 1,
    ReadyForUserInteraction = 2,
    BlockedByModalWindow = 3,
    NotResponding = 4,
};
pub const WindowInteractionState_Running = WindowInteractionState.Running;
pub const WindowInteractionState_Closing = WindowInteractionState.Closing;
pub const WindowInteractionState_ReadyForUserInteraction = WindowInteractionState.ReadyForUserInteraction;
pub const WindowInteractionState_BlockedByModalWindow = WindowInteractionState.BlockedByModalWindow;
pub const WindowInteractionState_NotResponding = WindowInteractionState.NotResponding;

pub const SayAsInterpretAs = extern enum(i32) {
    None = 0,
    Spell = 1,
    Cardinal = 2,
    Ordinal = 3,
    Number = 4,
    Date = 5,
    Time = 6,
    Telephone = 7,
    Currency = 8,
    Net = 9,
    Url = 10,
    Address = 11,
    Alphanumeric = 12,
    Name = 13,
    Media = 14,
    Date_MonthDayYear = 15,
    Date_DayMonthYear = 16,
    Date_YearMonthDay = 17,
    Date_YearMonth = 18,
    Date_MonthYear = 19,
    Date_DayMonth = 20,
    Date_MonthDay = 21,
    Date_Year = 22,
    Time_HoursMinutesSeconds12 = 23,
    Time_HoursMinutes12 = 24,
    Time_HoursMinutesSeconds24 = 25,
    Time_HoursMinutes24 = 26,
};
pub const SayAsInterpretAs_None = SayAsInterpretAs.None;
pub const SayAsInterpretAs_Spell = SayAsInterpretAs.Spell;
pub const SayAsInterpretAs_Cardinal = SayAsInterpretAs.Cardinal;
pub const SayAsInterpretAs_Ordinal = SayAsInterpretAs.Ordinal;
pub const SayAsInterpretAs_Number = SayAsInterpretAs.Number;
pub const SayAsInterpretAs_Date = SayAsInterpretAs.Date;
pub const SayAsInterpretAs_Time = SayAsInterpretAs.Time;
pub const SayAsInterpretAs_Telephone = SayAsInterpretAs.Telephone;
pub const SayAsInterpretAs_Currency = SayAsInterpretAs.Currency;
pub const SayAsInterpretAs_Net = SayAsInterpretAs.Net;
pub const SayAsInterpretAs_Url = SayAsInterpretAs.Url;
pub const SayAsInterpretAs_Address = SayAsInterpretAs.Address;
pub const SayAsInterpretAs_Alphanumeric = SayAsInterpretAs.Alphanumeric;
pub const SayAsInterpretAs_Name = SayAsInterpretAs.Name;
pub const SayAsInterpretAs_Media = SayAsInterpretAs.Media;
pub const SayAsInterpretAs_Date_MonthDayYear = SayAsInterpretAs.Date_MonthDayYear;
pub const SayAsInterpretAs_Date_DayMonthYear = SayAsInterpretAs.Date_DayMonthYear;
pub const SayAsInterpretAs_Date_YearMonthDay = SayAsInterpretAs.Date_YearMonthDay;
pub const SayAsInterpretAs_Date_YearMonth = SayAsInterpretAs.Date_YearMonth;
pub const SayAsInterpretAs_Date_MonthYear = SayAsInterpretAs.Date_MonthYear;
pub const SayAsInterpretAs_Date_DayMonth = SayAsInterpretAs.Date_DayMonth;
pub const SayAsInterpretAs_Date_MonthDay = SayAsInterpretAs.Date_MonthDay;
pub const SayAsInterpretAs_Date_Year = SayAsInterpretAs.Date_Year;
pub const SayAsInterpretAs_Time_HoursMinutesSeconds12 = SayAsInterpretAs.Time_HoursMinutesSeconds12;
pub const SayAsInterpretAs_Time_HoursMinutes12 = SayAsInterpretAs.Time_HoursMinutes12;
pub const SayAsInterpretAs_Time_HoursMinutesSeconds24 = SayAsInterpretAs.Time_HoursMinutesSeconds24;
pub const SayAsInterpretAs_Time_HoursMinutes24 = SayAsInterpretAs.Time_HoursMinutes24;

pub const TextUnit = extern enum(i32) {
    Character = 0,
    Format = 1,
    Word = 2,
    Line = 3,
    Paragraph = 4,
    Page = 5,
    Document = 6,
};
pub const TextUnit_Character = TextUnit.Character;
pub const TextUnit_Format = TextUnit.Format;
pub const TextUnit_Word = TextUnit.Word;
pub const TextUnit_Line = TextUnit.Line;
pub const TextUnit_Paragraph = TextUnit.Paragraph;
pub const TextUnit_Page = TextUnit.Page;
pub const TextUnit_Document = TextUnit.Document;

pub const TextPatternRangeEndpoint = extern enum(i32) {
    Start = 0,
    End = 1,
};
pub const TextPatternRangeEndpoint_Start = TextPatternRangeEndpoint.Start;
pub const TextPatternRangeEndpoint_End = TextPatternRangeEndpoint.End;

pub const SupportedTextSelection = extern enum(i32) {
    None = 0,
    Single = 1,
    Multiple = 2,
};
pub const SupportedTextSelection_None = SupportedTextSelection.None;
pub const SupportedTextSelection_Single = SupportedTextSelection.Single;
pub const SupportedTextSelection_Multiple = SupportedTextSelection.Multiple;

pub const LiveSetting = extern enum(i32) {
    Off = 0,
    Polite = 1,
    Assertive = 2,
};
pub const Off = LiveSetting.Off;
pub const Polite = LiveSetting.Polite;
pub const Assertive = LiveSetting.Assertive;

pub const ActiveEnd = extern enum(i32) {
    None = 0,
    Start = 1,
    End = 2,
};
pub const ActiveEnd_None = ActiveEnd.None;
pub const ActiveEnd_Start = ActiveEnd.Start;
pub const ActiveEnd_End = ActiveEnd.End;

pub const CaretPosition = extern enum(i32) {
    Unknown = 0,
    EndOfLine = 1,
    BeginningOfLine = 2,
};
pub const CaretPosition_Unknown = CaretPosition.Unknown;
pub const CaretPosition_EndOfLine = CaretPosition.EndOfLine;
pub const CaretPosition_BeginningOfLine = CaretPosition.BeginningOfLine;

pub const CaretBidiMode = extern enum(i32) {
    LTR = 0,
    RTL = 1,
};
pub const CaretBidiMode_LTR = CaretBidiMode.LTR;
pub const CaretBidiMode_RTL = CaretBidiMode.RTL;

pub const ZoomUnit = extern enum(i32) {
    NoAmount = 0,
    LargeDecrement = 1,
    SmallDecrement = 2,
    LargeIncrement = 3,
    SmallIncrement = 4,
};
pub const ZoomUnit_NoAmount = ZoomUnit.NoAmount;
pub const ZoomUnit_LargeDecrement = ZoomUnit.LargeDecrement;
pub const ZoomUnit_SmallDecrement = ZoomUnit.SmallDecrement;
pub const ZoomUnit_LargeIncrement = ZoomUnit.LargeIncrement;
pub const ZoomUnit_SmallIncrement = ZoomUnit.SmallIncrement;

pub const AnimationStyle = extern enum(i32) {
    None = 0,
    LasVegasLights = 1,
    BlinkingBackground = 2,
    SparkleText = 3,
    MarchingBlackAnts = 4,
    MarchingRedAnts = 5,
    Shimmer = 6,
    Other = -1,
};
pub const AnimationStyle_None = AnimationStyle.None;
pub const AnimationStyle_LasVegasLights = AnimationStyle.LasVegasLights;
pub const AnimationStyle_BlinkingBackground = AnimationStyle.BlinkingBackground;
pub const AnimationStyle_SparkleText = AnimationStyle.SparkleText;
pub const AnimationStyle_MarchingBlackAnts = AnimationStyle.MarchingBlackAnts;
pub const AnimationStyle_MarchingRedAnts = AnimationStyle.MarchingRedAnts;
pub const AnimationStyle_Shimmer = AnimationStyle.Shimmer;
pub const AnimationStyle_Other = AnimationStyle.Other;

pub const BulletStyle = extern enum(i32) {
    None = 0,
    HollowRoundBullet = 1,
    FilledRoundBullet = 2,
    HollowSquareBullet = 3,
    FilledSquareBullet = 4,
    DashBullet = 5,
    Other = -1,
};
pub const BulletStyle_None = BulletStyle.None;
pub const BulletStyle_HollowRoundBullet = BulletStyle.HollowRoundBullet;
pub const BulletStyle_FilledRoundBullet = BulletStyle.FilledRoundBullet;
pub const BulletStyle_HollowSquareBullet = BulletStyle.HollowSquareBullet;
pub const BulletStyle_FilledSquareBullet = BulletStyle.FilledSquareBullet;
pub const BulletStyle_DashBullet = BulletStyle.DashBullet;
pub const BulletStyle_Other = BulletStyle.Other;

pub const CapStyle = extern enum(i32) {
    None = 0,
    SmallCap = 1,
    AllCap = 2,
    AllPetiteCaps = 3,
    PetiteCaps = 4,
    Unicase = 5,
    Titling = 6,
    Other = -1,
};
pub const CapStyle_None = CapStyle.None;
pub const CapStyle_SmallCap = CapStyle.SmallCap;
pub const CapStyle_AllCap = CapStyle.AllCap;
pub const CapStyle_AllPetiteCaps = CapStyle.AllPetiteCaps;
pub const CapStyle_PetiteCaps = CapStyle.PetiteCaps;
pub const CapStyle_Unicase = CapStyle.Unicase;
pub const CapStyle_Titling = CapStyle.Titling;
pub const CapStyle_Other = CapStyle.Other;

pub const FillType = extern enum(i32) {
    None = 0,
    Color = 1,
    Gradient = 2,
    Picture = 3,
    Pattern = 4,
};
pub const FillType_None = FillType.None;
pub const FillType_Color = FillType.Color;
pub const FillType_Gradient = FillType.Gradient;
pub const FillType_Picture = FillType.Picture;
pub const FillType_Pattern = FillType.Pattern;

pub const FlowDirections = extern enum(i32) {
    Default = 0,
    RightToLeft = 1,
    BottomToTop = 2,
    Vertical = 4,
};
pub const FlowDirections_Default = FlowDirections.Default;
pub const FlowDirections_RightToLeft = FlowDirections.RightToLeft;
pub const FlowDirections_BottomToTop = FlowDirections.BottomToTop;
pub const FlowDirections_Vertical = FlowDirections.Vertical;

pub const HorizontalTextAlignment = extern enum(i32) {
    Left = 0,
    Centered = 1,
    Right = 2,
    Justified = 3,
};
pub const HorizontalTextAlignment_Left = HorizontalTextAlignment.Left;
pub const HorizontalTextAlignment_Centered = HorizontalTextAlignment.Centered;
pub const HorizontalTextAlignment_Right = HorizontalTextAlignment.Right;
pub const HorizontalTextAlignment_Justified = HorizontalTextAlignment.Justified;

pub const OutlineStyles = extern enum(i32) {
    None = 0,
    Outline = 1,
    Shadow = 2,
    Engraved = 4,
    Embossed = 8,
};
pub const OutlineStyles_None = OutlineStyles.None;
pub const OutlineStyles_Outline = OutlineStyles.Outline;
pub const OutlineStyles_Shadow = OutlineStyles.Shadow;
pub const OutlineStyles_Engraved = OutlineStyles.Engraved;
pub const OutlineStyles_Embossed = OutlineStyles.Embossed;

pub const TextDecorationLineStyle = extern enum(i32) {
    None = 0,
    Single = 1,
    WordsOnly = 2,
    Double = 3,
    Dot = 4,
    Dash = 5,
    DashDot = 6,
    DashDotDot = 7,
    Wavy = 8,
    ThickSingle = 9,
    DoubleWavy = 11,
    ThickWavy = 12,
    LongDash = 13,
    ThickDash = 14,
    ThickDashDot = 15,
    ThickDashDotDot = 16,
    ThickDot = 17,
    ThickLongDash = 18,
    Other = -1,
};
pub const TextDecorationLineStyle_None = TextDecorationLineStyle.None;
pub const TextDecorationLineStyle_Single = TextDecorationLineStyle.Single;
pub const TextDecorationLineStyle_WordsOnly = TextDecorationLineStyle.WordsOnly;
pub const TextDecorationLineStyle_Double = TextDecorationLineStyle.Double;
pub const TextDecorationLineStyle_Dot = TextDecorationLineStyle.Dot;
pub const TextDecorationLineStyle_Dash = TextDecorationLineStyle.Dash;
pub const TextDecorationLineStyle_DashDot = TextDecorationLineStyle.DashDot;
pub const TextDecorationLineStyle_DashDotDot = TextDecorationLineStyle.DashDotDot;
pub const TextDecorationLineStyle_Wavy = TextDecorationLineStyle.Wavy;
pub const TextDecorationLineStyle_ThickSingle = TextDecorationLineStyle.ThickSingle;
pub const TextDecorationLineStyle_DoubleWavy = TextDecorationLineStyle.DoubleWavy;
pub const TextDecorationLineStyle_ThickWavy = TextDecorationLineStyle.ThickWavy;
pub const TextDecorationLineStyle_LongDash = TextDecorationLineStyle.LongDash;
pub const TextDecorationLineStyle_ThickDash = TextDecorationLineStyle.ThickDash;
pub const TextDecorationLineStyle_ThickDashDot = TextDecorationLineStyle.ThickDashDot;
pub const TextDecorationLineStyle_ThickDashDotDot = TextDecorationLineStyle.ThickDashDotDot;
pub const TextDecorationLineStyle_ThickDot = TextDecorationLineStyle.ThickDot;
pub const TextDecorationLineStyle_ThickLongDash = TextDecorationLineStyle.ThickLongDash;
pub const TextDecorationLineStyle_Other = TextDecorationLineStyle.Other;

pub const VisualEffects = extern enum(i32) {
    None = 0,
    Shadow = 1,
    Reflection = 2,
    Glow = 4,
    SoftEdges = 8,
    Bevel = 16,
};
pub const VisualEffects_None = VisualEffects.None;
pub const VisualEffects_Shadow = VisualEffects.Shadow;
pub const VisualEffects_Reflection = VisualEffects.Reflection;
pub const VisualEffects_Glow = VisualEffects.Glow;
pub const VisualEffects_SoftEdges = VisualEffects.SoftEdges;
pub const VisualEffects_Bevel = VisualEffects.Bevel;

pub const NotificationProcessing = extern enum(i32) {
    ImportantAll = 0,
    ImportantMostRecent = 1,
    All = 2,
    MostRecent = 3,
    CurrentThenMostRecent = 4,
};
pub const NotificationProcessing_ImportantAll = NotificationProcessing.ImportantAll;
pub const NotificationProcessing_ImportantMostRecent = NotificationProcessing.ImportantMostRecent;
pub const NotificationProcessing_All = NotificationProcessing.All;
pub const NotificationProcessing_MostRecent = NotificationProcessing.MostRecent;
pub const NotificationProcessing_CurrentThenMostRecent = NotificationProcessing.CurrentThenMostRecent;

pub const NotificationKind = extern enum(i32) {
    ItemAdded = 0,
    ItemRemoved = 1,
    ActionCompleted = 2,
    ActionAborted = 3,
    Other = 4,
};
pub const NotificationKind_ItemAdded = NotificationKind.ItemAdded;
pub const NotificationKind_ItemRemoved = NotificationKind.ItemRemoved;
pub const NotificationKind_ActionCompleted = NotificationKind.ActionCompleted;
pub const NotificationKind_ActionAborted = NotificationKind.ActionAborted;
pub const NotificationKind_Other = NotificationKind.Other;

pub const UiaRect = extern struct {
    left: f64,
    top: f64,
    width: f64,
    height: f64,
};

pub const UiaPoint = extern struct {
    x: f64,
    y: f64,
};

pub const UiaChangeInfo = extern struct {
    uiaId: i32,
    payload: VARIANT,
    extraInfo: VARIANT,
};

pub const UIAutomationType = extern enum(i32) {
    Int = 1,
    Bool = 2,
    String = 3,
    Double = 4,
    Point = 5,
    Rect = 6,
    Element = 7,
    Array = 65536,
    Out = 131072,
    IntArray = 65537,
    BoolArray = 65538,
    StringArray = 65539,
    DoubleArray = 65540,
    PointArray = 65541,
    RectArray = 65542,
    ElementArray = 65543,
    OutInt = 131073,
    OutBool = 131074,
    OutString = 131075,
    OutDouble = 131076,
    OutPoint = 131077,
    OutRect = 131078,
    OutElement = 131079,
    OutIntArray = 196609,
    OutBoolArray = 196610,
    OutStringArray = 196611,
    OutDoubleArray = 196612,
    OutPointArray = 196613,
    OutRectArray = 196614,
    OutElementArray = 196615,
};
pub const UIAutomationType_Int = UIAutomationType.Int;
pub const UIAutomationType_Bool = UIAutomationType.Bool;
pub const UIAutomationType_String = UIAutomationType.String;
pub const UIAutomationType_Double = UIAutomationType.Double;
pub const UIAutomationType_Point = UIAutomationType.Point;
pub const UIAutomationType_Rect = UIAutomationType.Rect;
pub const UIAutomationType_Element = UIAutomationType.Element;
pub const UIAutomationType_Array = UIAutomationType.Array;
pub const UIAutomationType_Out = UIAutomationType.Out;
pub const UIAutomationType_IntArray = UIAutomationType.IntArray;
pub const UIAutomationType_BoolArray = UIAutomationType.BoolArray;
pub const UIAutomationType_StringArray = UIAutomationType.StringArray;
pub const UIAutomationType_DoubleArray = UIAutomationType.DoubleArray;
pub const UIAutomationType_PointArray = UIAutomationType.PointArray;
pub const UIAutomationType_RectArray = UIAutomationType.RectArray;
pub const UIAutomationType_ElementArray = UIAutomationType.ElementArray;
pub const UIAutomationType_OutInt = UIAutomationType.OutInt;
pub const UIAutomationType_OutBool = UIAutomationType.OutBool;
pub const UIAutomationType_OutString = UIAutomationType.OutString;
pub const UIAutomationType_OutDouble = UIAutomationType.OutDouble;
pub const UIAutomationType_OutPoint = UIAutomationType.OutPoint;
pub const UIAutomationType_OutRect = UIAutomationType.OutRect;
pub const UIAutomationType_OutElement = UIAutomationType.OutElement;
pub const UIAutomationType_OutIntArray = UIAutomationType.OutIntArray;
pub const UIAutomationType_OutBoolArray = UIAutomationType.OutBoolArray;
pub const UIAutomationType_OutStringArray = UIAutomationType.OutStringArray;
pub const UIAutomationType_OutDoubleArray = UIAutomationType.OutDoubleArray;
pub const UIAutomationType_OutPointArray = UIAutomationType.OutPointArray;
pub const UIAutomationType_OutRectArray = UIAutomationType.OutRectArray;
pub const UIAutomationType_OutElementArray = UIAutomationType.OutElementArray;

pub const UIAutomationParameter = extern struct {
    type: UIAutomationType,
    pData: *c_void,
};

pub const UIAutomationPropertyInfo = extern struct {
    guid: Guid,
    pProgrammaticName: [*:0]const u16,
    type: UIAutomationType,
};

pub const UIAutomationEventInfo = extern struct {
    guid: Guid,
    pProgrammaticName: [*:0]const u16,
};

pub const UIAutomationMethodInfo = extern struct {
    pProgrammaticName: [*:0]const u16,
    doSetFocus: BOOL,
    cInParameters: u32,
    cOutParameters: u32,
    pParameterTypes: *UIAutomationType,
    pParameterNames: *PWSTR,
};

pub const UIAutomationPatternInfo = extern struct {
    guid: Guid,
    pProgrammaticName: [*:0]const u16,
    providerInterfaceId: Guid,
    clientInterfaceId: Guid,
    cProperties: u32,
    pProperties: *UIAutomationPropertyInfo,
    cMethods: u32,
    pMethods: *UIAutomationMethodInfo,
    cEvents: u32,
    pEvents: *UIAutomationEventInfo,
    pPatternHandler: *IUIAutomationPatternHandler,
};

const IID_IRawElementProviderSimple_Value = @import("../zig.zig").Guid.initString("D6DD68D1-86FD-4332-8666-9ABEDEA2D24C");
pub const IID_IRawElementProviderSimple = &IID_IRawElementProviderSimple_Value;
pub const IRawElementProviderSimple = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_ProviderOptions: fn(
            self: *const IRawElementProviderSimple,
            pRetVal: *ProviderOptions,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPatternProvider: fn(
            self: *const IRawElementProviderSimple,
            patternId: i32,
            pRetVal: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyValue: fn(
            self: *const IRawElementProviderSimple,
            propertyId: i32,
            pRetVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HostRawElementProvider: fn(
            self: *const IRawElementProviderSimple,
            pRetVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple_get_ProviderOptions(self: *const T, pRetVal: *ProviderOptions) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple.VTable, self.vtable).get_ProviderOptions(@ptrCast(*const IRawElementProviderSimple, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple_GetPatternProvider(self: *const T, patternId: i32, pRetVal: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple.VTable, self.vtable).GetPatternProvider(@ptrCast(*const IRawElementProviderSimple, self), patternId, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple_GetPropertyValue(self: *const T, propertyId: i32, pRetVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple.VTable, self.vtable).GetPropertyValue(@ptrCast(*const IRawElementProviderSimple, self), propertyId, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple_get_HostRawElementProvider(self: *const T, pRetVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple.VTable, self.vtable).get_HostRawElementProvider(@ptrCast(*const IRawElementProviderSimple, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccessibleEx_Value = @import("../zig.zig").Guid.initString("F8B80ADA-2C44-48D0-89BE-5FF23C9CD875");
pub const IID_IAccessibleEx = &IID_IAccessibleEx_Value;
pub const IAccessibleEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectForChild: fn(
            self: *const IAccessibleEx,
            idChild: i32,
            pRetVal: **IAccessibleEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIAccessiblePair: fn(
            self: *const IAccessibleEx,
            ppAcc: **IAccessible,
            pidChild: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRuntimeId: fn(
            self: *const IAccessibleEx,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertReturnedElement: fn(
            self: *const IAccessibleEx,
            pIn: *IRawElementProviderSimple,
            ppRetValOut: **IAccessibleEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleEx_GetObjectForChild(self: *const T, idChild: i32, pRetVal: **IAccessibleEx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleEx.VTable, self.vtable).GetObjectForChild(@ptrCast(*const IAccessibleEx, self), idChild, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleEx_GetIAccessiblePair(self: *const T, ppAcc: **IAccessible, pidChild: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleEx.VTable, self.vtable).GetIAccessiblePair(@ptrCast(*const IAccessibleEx, self), ppAcc, pidChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleEx_GetRuntimeId(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleEx.VTable, self.vtable).GetRuntimeId(@ptrCast(*const IAccessibleEx, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleEx_ConvertReturnedElement(self: *const T, pIn: *IRawElementProviderSimple, ppRetValOut: **IAccessibleEx) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleEx.VTable, self.vtable).ConvertReturnedElement(@ptrCast(*const IAccessibleEx, self), pIn, ppRetValOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawElementProviderSimple2_Value = @import("../zig.zig").Guid.initString("A0A839A9-8DA1-4A82-806A-8E0D44E79F56");
pub const IID_IRawElementProviderSimple2 = &IID_IRawElementProviderSimple2_Value;
pub const IRawElementProviderSimple2 = extern struct {
    pub const VTable = extern struct {
        base: IRawElementProviderSimple.VTable,
        ShowContextMenu: fn(
            self: *const IRawElementProviderSimple2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRawElementProviderSimple.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple2_ShowContextMenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple2.VTable, self.vtable).ShowContextMenu(@ptrCast(*const IRawElementProviderSimple2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawElementProviderSimple3_Value = @import("../zig.zig").Guid.initString("FCF5D820-D7EC-4613-BDF6-42A84CE7DAAF");
pub const IID_IRawElementProviderSimple3 = &IID_IRawElementProviderSimple3_Value;
pub const IRawElementProviderSimple3 = extern struct {
    pub const VTable = extern struct {
        base: IRawElementProviderSimple2.VTable,
        GetMetadataValue: fn(
            self: *const IRawElementProviderSimple3,
            targetId: i32,
            metadataId: i32,
            returnVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRawElementProviderSimple2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderSimple3_GetMetadataValue(self: *const T, targetId: i32, metadataId: i32, returnVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderSimple3.VTable, self.vtable).GetMetadataValue(@ptrCast(*const IRawElementProviderSimple3, self), targetId, metadataId, returnVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawElementProviderFragmentRoot_Value = @import("../zig.zig").Guid.initString("620CE2A5-AB8F-40A9-86CB-DE3C75599B58");
pub const IID_IRawElementProviderFragmentRoot = &IID_IRawElementProviderFragmentRoot_Value;
pub const IRawElementProviderFragmentRoot = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ElementProviderFromPoint: fn(
            self: *const IRawElementProviderFragmentRoot,
            x: f64,
            y: f64,
            pRetVal: **IRawElementProviderFragment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocus: fn(
            self: *const IRawElementProviderFragmentRoot,
            pRetVal: **IRawElementProviderFragment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragmentRoot_ElementProviderFromPoint(self: *const T, x: f64, y: f64, pRetVal: **IRawElementProviderFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragmentRoot.VTable, self.vtable).ElementProviderFromPoint(@ptrCast(*const IRawElementProviderFragmentRoot, self), x, y, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragmentRoot_GetFocus(self: *const T, pRetVal: **IRawElementProviderFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragmentRoot.VTable, self.vtable).GetFocus(@ptrCast(*const IRawElementProviderFragmentRoot, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawElementProviderFragment_Value = @import("../zig.zig").Guid.initString("F7063DA8-8359-439C-9297-BBC5299A7D87");
pub const IID_IRawElementProviderFragment = &IID_IRawElementProviderFragment_Value;
pub const IRawElementProviderFragment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Navigate: fn(
            self: *const IRawElementProviderFragment,
            direction: NavigateDirection,
            pRetVal: **IRawElementProviderFragment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRuntimeId: fn(
            self: *const IRawElementProviderFragment,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BoundingRectangle: fn(
            self: *const IRawElementProviderFragment,
            pRetVal: *UiaRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbeddedFragmentRoots: fn(
            self: *const IRawElementProviderFragment,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFocus: fn(
            self: *const IRawElementProviderFragment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FragmentRoot: fn(
            self: *const IRawElementProviderFragment,
            pRetVal: **IRawElementProviderFragmentRoot,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_Navigate(self: *const T, direction: NavigateDirection, pRetVal: **IRawElementProviderFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).Navigate(@ptrCast(*const IRawElementProviderFragment, self), direction, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_GetRuntimeId(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).GetRuntimeId(@ptrCast(*const IRawElementProviderFragment, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_get_BoundingRectangle(self: *const T, pRetVal: *UiaRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).get_BoundingRectangle(@ptrCast(*const IRawElementProviderFragment, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_GetEmbeddedFragmentRoots(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).GetEmbeddedFragmentRoots(@ptrCast(*const IRawElementProviderFragment, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_SetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).SetFocus(@ptrCast(*const IRawElementProviderFragment, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderFragment_get_FragmentRoot(self: *const T, pRetVal: **IRawElementProviderFragmentRoot) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderFragment.VTable, self.vtable).get_FragmentRoot(@ptrCast(*const IRawElementProviderFragment, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawElementProviderAdviseEvents_Value = @import("../zig.zig").Guid.initString("A407B27B-0F6D-4427-9292-473C7BF93258");
pub const IID_IRawElementProviderAdviseEvents = &IID_IRawElementProviderAdviseEvents_Value;
pub const IRawElementProviderAdviseEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AdviseEventAdded: fn(
            self: *const IRawElementProviderAdviseEvents,
            eventId: i32,
            propertyIDs: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AdviseEventRemoved: fn(
            self: *const IRawElementProviderAdviseEvents,
            eventId: i32,
            propertyIDs: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderAdviseEvents_AdviseEventAdded(self: *const T, eventId: i32, propertyIDs: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderAdviseEvents.VTable, self.vtable).AdviseEventAdded(@ptrCast(*const IRawElementProviderAdviseEvents, self), eventId, propertyIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderAdviseEvents_AdviseEventRemoved(self: *const T, eventId: i32, propertyIDs: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderAdviseEvents.VTable, self.vtable).AdviseEventRemoved(@ptrCast(*const IRawElementProviderAdviseEvents, self), eventId, propertyIDs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawElementProviderHwndOverride_Value = @import("../zig.zig").Guid.initString("1D5DF27C-8947-4425-B8D9-79787BB460B8");
pub const IID_IRawElementProviderHwndOverride = &IID_IRawElementProviderHwndOverride_Value;
pub const IRawElementProviderHwndOverride = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOverrideProviderForHwnd: fn(
            self: *const IRawElementProviderHwndOverride,
            hwnd: HWND,
            pRetVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderHwndOverride_GetOverrideProviderForHwnd(self: *const T, hwnd: HWND, pRetVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderHwndOverride.VTable, self.vtable).GetOverrideProviderForHwnd(@ptrCast(*const IRawElementProviderHwndOverride, self), hwnd, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProxyProviderWinEventSink_Value = @import("../zig.zig").Guid.initString("4FD82B78-A43E-46AC-9803-0A6969C7C183");
pub const IID_IProxyProviderWinEventSink = &IID_IProxyProviderWinEventSink_Value;
pub const IProxyProviderWinEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddAutomationPropertyChangedEvent: fn(
            self: *const IProxyProviderWinEventSink,
            pProvider: *IRawElementProviderSimple,
            id: i32,
            newValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAutomationEvent: fn(
            self: *const IProxyProviderWinEventSink,
            pProvider: *IRawElementProviderSimple,
            id: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStructureChangedEvent: fn(
            self: *const IProxyProviderWinEventSink,
            pProvider: *IRawElementProviderSimple,
            structureChangeType: StructureChangeType,
            runtimeId: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProxyProviderWinEventSink_AddAutomationPropertyChangedEvent(self: *const T, pProvider: *IRawElementProviderSimple, id: i32, newValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProxyProviderWinEventSink.VTable, self.vtable).AddAutomationPropertyChangedEvent(@ptrCast(*const IProxyProviderWinEventSink, self), pProvider, id, newValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProxyProviderWinEventSink_AddAutomationEvent(self: *const T, pProvider: *IRawElementProviderSimple, id: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProxyProviderWinEventSink.VTable, self.vtable).AddAutomationEvent(@ptrCast(*const IProxyProviderWinEventSink, self), pProvider, id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProxyProviderWinEventSink_AddStructureChangedEvent(self: *const T, pProvider: *IRawElementProviderSimple, structureChangeType: StructureChangeType, runtimeId: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProxyProviderWinEventSink.VTable, self.vtable).AddStructureChangedEvent(@ptrCast(*const IProxyProviderWinEventSink, self), pProvider, structureChangeType, runtimeId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProxyProviderWinEventHandler_Value = @import("../zig.zig").Guid.initString("89592AD4-F4E0-43D5-A3B6-BAD7E111B435");
pub const IID_IProxyProviderWinEventHandler = &IID_IProxyProviderWinEventHandler_Value;
pub const IProxyProviderWinEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RespondToWinEvent: fn(
            self: *const IProxyProviderWinEventHandler,
            idWinEvent: u32,
            hwnd: HWND,
            idObject: i32,
            idChild: i32,
            pSink: *IProxyProviderWinEventSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProxyProviderWinEventHandler_RespondToWinEvent(self: *const T, idWinEvent: u32, hwnd: HWND, idObject: i32, idChild: i32, pSink: *IProxyProviderWinEventSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProxyProviderWinEventHandler.VTable, self.vtable).RespondToWinEvent(@ptrCast(*const IProxyProviderWinEventHandler, self), idWinEvent, hwnd, idObject, idChild, pSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawElementProviderWindowlessSite_Value = @import("../zig.zig").Guid.initString("0A2A93CC-BFAD-42AC-9B2E-0991FB0D3EA0");
pub const IID_IRawElementProviderWindowlessSite = &IID_IRawElementProviderWindowlessSite_Value;
pub const IRawElementProviderWindowlessSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAdjacentFragment: fn(
            self: *const IRawElementProviderWindowlessSite,
            direction: NavigateDirection,
            ppParent: **IRawElementProviderFragment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRuntimeIdPrefix: fn(
            self: *const IRawElementProviderWindowlessSite,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderWindowlessSite_GetAdjacentFragment(self: *const T, direction: NavigateDirection, ppParent: **IRawElementProviderFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderWindowlessSite.VTable, self.vtable).GetAdjacentFragment(@ptrCast(*const IRawElementProviderWindowlessSite, self), direction, ppParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderWindowlessSite_GetRuntimeIdPrefix(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderWindowlessSite.VTable, self.vtable).GetRuntimeIdPrefix(@ptrCast(*const IRawElementProviderWindowlessSite, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAccessibleHostingElementProviders_Value = @import("../zig.zig").Guid.initString("33AC331B-943E-4020-B295-DB37784974A3");
pub const IID_IAccessibleHostingElementProviders = &IID_IAccessibleHostingElementProviders_Value;
pub const IAccessibleHostingElementProviders = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEmbeddedFragmentRoots: fn(
            self: *const IAccessibleHostingElementProviders,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectIdForProvider: fn(
            self: *const IAccessibleHostingElementProviders,
            pProvider: *IRawElementProviderSimple,
            pidObject: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleHostingElementProviders_GetEmbeddedFragmentRoots(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleHostingElementProviders.VTable, self.vtable).GetEmbeddedFragmentRoots(@ptrCast(*const IAccessibleHostingElementProviders, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAccessibleHostingElementProviders_GetObjectIdForProvider(self: *const T, pProvider: *IRawElementProviderSimple, pidObject: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAccessibleHostingElementProviders.VTable, self.vtable).GetObjectIdForProvider(@ptrCast(*const IAccessibleHostingElementProviders, self), pProvider, pidObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawElementProviderHostingAccessibles_Value = @import("../zig.zig").Guid.initString("24BE0B07-D37D-487A-98CF-A13ED465E9B3");
pub const IID_IRawElementProviderHostingAccessibles = &IID_IRawElementProviderHostingAccessibles_Value;
pub const IRawElementProviderHostingAccessibles = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEmbeddedAccessibles: fn(
            self: *const IRawElementProviderHostingAccessibles,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawElementProviderHostingAccessibles_GetEmbeddedAccessibles(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawElementProviderHostingAccessibles.VTable, self.vtable).GetEmbeddedAccessibles(@ptrCast(*const IRawElementProviderHostingAccessibles, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDockProvider_Value = @import("../zig.zig").Guid.initString("159BC72C-4AD3-485E-9637-D7052EDF0146");
pub const IID_IDockProvider = &IID_IDockProvider_Value;
pub const IDockProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDockPosition: fn(
            self: *const IDockProvider,
            dockPosition: DockPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DockPosition: fn(
            self: *const IDockProvider,
            pRetVal: *DockPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockProvider_SetDockPosition(self: *const T, dockPosition: DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockProvider.VTable, self.vtable).SetDockPosition(@ptrCast(*const IDockProvider, self), dockPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDockProvider_get_DockPosition(self: *const T, pRetVal: *DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDockProvider.VTable, self.vtable).get_DockPosition(@ptrCast(*const IDockProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IExpandCollapseProvider_Value = @import("../zig.zig").Guid.initString("D847D3A5-CAB0-4A98-8C32-ECB45C59AD24");
pub const IID_IExpandCollapseProvider = &IID_IExpandCollapseProvider_Value;
pub const IExpandCollapseProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Expand: fn(
            self: *const IExpandCollapseProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Collapse: fn(
            self: *const IExpandCollapseProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ExpandCollapseState: fn(
            self: *const IExpandCollapseProvider,
            pRetVal: *ExpandCollapseState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpandCollapseProvider_Expand(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpandCollapseProvider.VTable, self.vtable).Expand(@ptrCast(*const IExpandCollapseProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpandCollapseProvider_Collapse(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpandCollapseProvider.VTable, self.vtable).Collapse(@ptrCast(*const IExpandCollapseProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IExpandCollapseProvider_get_ExpandCollapseState(self: *const T, pRetVal: *ExpandCollapseState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IExpandCollapseProvider.VTable, self.vtable).get_ExpandCollapseState(@ptrCast(*const IExpandCollapseProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGridProvider_Value = @import("../zig.zig").Guid.initString("B17D6187-0907-464B-A168-0EF17A1572B1");
pub const IID_IGridProvider = &IID_IGridProvider_Value;
pub const IGridProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItem: fn(
            self: *const IGridProvider,
            row: i32,
            column: i32,
            pRetVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_RowCount: fn(
            self: *const IGridProvider,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ColumnCount: fn(
            self: *const IGridProvider,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridProvider_GetItem(self: *const T, row: i32, column: i32, pRetVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridProvider.VTable, self.vtable).GetItem(@ptrCast(*const IGridProvider, self), row, column, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridProvider_get_RowCount(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridProvider.VTable, self.vtable).get_RowCount(@ptrCast(*const IGridProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridProvider_get_ColumnCount(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridProvider.VTable, self.vtable).get_ColumnCount(@ptrCast(*const IGridProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGridItemProvider_Value = @import("../zig.zig").Guid.initString("D02541F1-FB81-4D64-AE32-F520F8A6DBD1");
pub const IID_IGridItemProvider = &IID_IGridItemProvider_Value;
pub const IGridItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_Row: fn(
            self: *const IGridItemProvider,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Column: fn(
            self: *const IGridItemProvider,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_RowSpan: fn(
            self: *const IGridItemProvider,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ColumnSpan: fn(
            self: *const IGridItemProvider,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ContainingGrid: fn(
            self: *const IGridItemProvider,
            pRetVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_Row(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_Row(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_Column(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_Column(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_RowSpan(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_RowSpan(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_ColumnSpan(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_ColumnSpan(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGridItemProvider_get_ContainingGrid(self: *const T, pRetVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGridItemProvider.VTable, self.vtable).get_ContainingGrid(@ptrCast(*const IGridItemProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInvokeProvider_Value = @import("../zig.zig").Guid.initString("54FCB24B-E18E-47A2-B4D3-ECCBE77599A2");
pub const IID_IInvokeProvider = &IID_IInvokeProvider_Value;
pub const IInvokeProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: fn(
            self: *const IInvokeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInvokeProvider_Invoke(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInvokeProvider.VTable, self.vtable).Invoke(@ptrCast(*const IInvokeProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMultipleViewProvider_Value = @import("../zig.zig").Guid.initString("6278CAB1-B556-4A1A-B4E0-418ACC523201");
pub const IID_IMultipleViewProvider = &IID_IMultipleViewProvider_Value;
pub const IMultipleViewProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetViewName: fn(
            self: *const IMultipleViewProvider,
            viewId: i32,
            pRetVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentView: fn(
            self: *const IMultipleViewProvider,
            viewId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentView: fn(
            self: *const IMultipleViewProvider,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedViews: fn(
            self: *const IMultipleViewProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultipleViewProvider_GetViewName(self: *const T, viewId: i32, pRetVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultipleViewProvider.VTable, self.vtable).GetViewName(@ptrCast(*const IMultipleViewProvider, self), viewId, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultipleViewProvider_SetCurrentView(self: *const T, viewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultipleViewProvider.VTable, self.vtable).SetCurrentView(@ptrCast(*const IMultipleViewProvider, self), viewId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultipleViewProvider_get_CurrentView(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultipleViewProvider.VTable, self.vtable).get_CurrentView(@ptrCast(*const IMultipleViewProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMultipleViewProvider_GetSupportedViews(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMultipleViewProvider.VTable, self.vtable).GetSupportedViews(@ptrCast(*const IMultipleViewProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRangeValueProvider_Value = @import("../zig.zig").Guid.initString("36DC7AEF-33E6-4691-AFE1-2BE7274B3D33");
pub const IID_IRangeValueProvider = &IID_IRangeValueProvider_Value;
pub const IRangeValueProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: fn(
            self: *const IRangeValueProvider,
            val: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Value: fn(
            self: *const IRangeValueProvider,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_IsReadOnly: fn(
            self: *const IRangeValueProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Maximum: fn(
            self: *const IRangeValueProvider,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Minimum: fn(
            self: *const IRangeValueProvider,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_LargeChange: fn(
            self: *const IRangeValueProvider,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_SmallChange: fn(
            self: *const IRangeValueProvider,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_SetValue(self: *const T, val: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).SetValue(@ptrCast(*const IRangeValueProvider, self), val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_Value(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_Value(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_IsReadOnly(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_IsReadOnly(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_Maximum(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_Maximum(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_Minimum(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_Minimum(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_LargeChange(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_LargeChange(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeValueProvider_get_SmallChange(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeValueProvider.VTable, self.vtable).get_SmallChange(@ptrCast(*const IRangeValueProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScrollItemProvider_Value = @import("../zig.zig").Guid.initString("2360C714-4BF1-4B26-BA65-9B21316127EB");
pub const IID_IScrollItemProvider = &IID_IScrollItemProvider_Value;
pub const IScrollItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollIntoView: fn(
            self: *const IScrollItemProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollItemProvider_ScrollIntoView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollItemProvider.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IScrollItemProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISelectionProvider_Value = @import("../zig.zig").Guid.initString("FB8B03AF-3BDF-48D4-BD36-1A65793BE168");
pub const IID_ISelectionProvider = &IID_ISelectionProvider_Value;
pub const ISelectionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: fn(
            self: *const ISelectionProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CanSelectMultiple: fn(
            self: *const ISelectionProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_IsSelectionRequired: fn(
            self: *const ISelectionProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider_GetSelection(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider.VTable, self.vtable).GetSelection(@ptrCast(*const ISelectionProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider_get_CanSelectMultiple(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider.VTable, self.vtable).get_CanSelectMultiple(@ptrCast(*const ISelectionProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider_get_IsSelectionRequired(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider.VTable, self.vtable).get_IsSelectionRequired(@ptrCast(*const ISelectionProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISelectionProvider2_Value = @import("../zig.zig").Guid.initString("14F68475-EE1C-44F6-A869-D239381F0FE7");
pub const IID_ISelectionProvider2 = &IID_ISelectionProvider2_Value;
pub const ISelectionProvider2 = extern struct {
    pub const VTable = extern struct {
        base: ISelectionProvider.VTable,
        get_FirstSelectedItem: fn(
            self: *const ISelectionProvider2,
            retVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_LastSelectedItem: fn(
            self: *const ISelectionProvider2,
            retVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentSelectedItem: fn(
            self: *const ISelectionProvider2,
            retVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ItemCount: fn(
            self: *const ISelectionProvider2,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISelectionProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider2_get_FirstSelectedItem(self: *const T, retVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider2.VTable, self.vtable).get_FirstSelectedItem(@ptrCast(*const ISelectionProvider2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider2_get_LastSelectedItem(self: *const T, retVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider2.VTable, self.vtable).get_LastSelectedItem(@ptrCast(*const ISelectionProvider2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider2_get_CurrentSelectedItem(self: *const T, retVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider2.VTable, self.vtable).get_CurrentSelectedItem(@ptrCast(*const ISelectionProvider2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionProvider2_get_ItemCount(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionProvider2.VTable, self.vtable).get_ItemCount(@ptrCast(*const ISelectionProvider2, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScrollProvider_Value = @import("../zig.zig").Guid.initString("B38B8077-1FC3-42A5-8CAE-D40C2215055A");
pub const IID_IScrollProvider = &IID_IScrollProvider_Value;
pub const IScrollProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Scroll: fn(
            self: *const IScrollProvider,
            horizontalAmount: ScrollAmount,
            verticalAmount: ScrollAmount,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScrollPercent: fn(
            self: *const IScrollProvider,
            horizontalPercent: f64,
            verticalPercent: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HorizontalScrollPercent: fn(
            self: *const IScrollProvider,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_VerticalScrollPercent: fn(
            self: *const IScrollProvider,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HorizontalViewSize: fn(
            self: *const IScrollProvider,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_VerticalViewSize: fn(
            self: *const IScrollProvider,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HorizontallyScrollable: fn(
            self: *const IScrollProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_VerticallyScrollable: fn(
            self: *const IScrollProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_Scroll(self: *const T, horizontalAmount: ScrollAmount, verticalAmount: ScrollAmount) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).Scroll(@ptrCast(*const IScrollProvider, self), horizontalAmount, verticalAmount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_SetScrollPercent(self: *const T, horizontalPercent: f64, verticalPercent: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).SetScrollPercent(@ptrCast(*const IScrollProvider, self), horizontalPercent, verticalPercent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_HorizontalScrollPercent(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_HorizontalScrollPercent(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_VerticalScrollPercent(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_VerticalScrollPercent(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_HorizontalViewSize(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_HorizontalViewSize(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_VerticalViewSize(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_VerticalViewSize(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_HorizontallyScrollable(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_HorizontallyScrollable(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScrollProvider_get_VerticallyScrollable(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScrollProvider.VTable, self.vtable).get_VerticallyScrollable(@ptrCast(*const IScrollProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISelectionItemProvider_Value = @import("../zig.zig").Guid.initString("2ACAD808-B2D4-452D-A407-91FF1AD167B2");
pub const IID_ISelectionItemProvider = &IID_ISelectionItemProvider_Value;
pub const ISelectionItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Select: fn(
            self: *const ISelectionItemProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddToSelection: fn(
            self: *const ISelectionItemProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFromSelection: fn(
            self: *const ISelectionItemProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_IsSelected: fn(
            self: *const ISelectionItemProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_SelectionContainer: fn(
            self: *const ISelectionItemProvider,
            pRetVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).Select(@ptrCast(*const ISelectionItemProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_AddToSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).AddToSelection(@ptrCast(*const ISelectionItemProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_RemoveFromSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).RemoveFromSelection(@ptrCast(*const ISelectionItemProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_get_IsSelected(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).get_IsSelected(@ptrCast(*const ISelectionItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionItemProvider_get_SelectionContainer(self: *const T, pRetVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionItemProvider.VTable, self.vtable).get_SelectionContainer(@ptrCast(*const ISelectionItemProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISynchronizedInputProvider_Value = @import("../zig.zig").Guid.initString("29DB1A06-02CE-4CF7-9B42-565D4FAB20EE");
pub const IID_ISynchronizedInputProvider = &IID_ISynchronizedInputProvider_Value;
pub const ISynchronizedInputProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartListening: fn(
            self: *const ISynchronizedInputProvider,
            inputType: SynchronizedInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const ISynchronizedInputProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizedInputProvider_StartListening(self: *const T, inputType: SynchronizedInputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizedInputProvider.VTable, self.vtable).StartListening(@ptrCast(*const ISynchronizedInputProvider, self), inputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISynchronizedInputProvider_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISynchronizedInputProvider.VTable, self.vtable).Cancel(@ptrCast(*const ISynchronizedInputProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableProvider_Value = @import("../zig.zig").Guid.initString("9C860395-97B3-490A-B52A-858CC22AF166");
pub const IID_ITableProvider = &IID_ITableProvider_Value;
pub const ITableProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowHeaders: fn(
            self: *const ITableProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnHeaders: fn(
            self: *const ITableProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_RowOrColumnMajor: fn(
            self: *const ITableProvider,
            pRetVal: *RowOrColumnMajor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableProvider_GetRowHeaders(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableProvider.VTable, self.vtable).GetRowHeaders(@ptrCast(*const ITableProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableProvider_GetColumnHeaders(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableProvider.VTable, self.vtable).GetColumnHeaders(@ptrCast(*const ITableProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableProvider_get_RowOrColumnMajor(self: *const T, pRetVal: *RowOrColumnMajor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableProvider.VTable, self.vtable).get_RowOrColumnMajor(@ptrCast(*const ITableProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITableItemProvider_Value = @import("../zig.zig").Guid.initString("B9734FA6-771F-4D78-9C90-2517999349CD");
pub const IID_ITableItemProvider = &IID_ITableItemProvider_Value;
pub const ITableItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRowHeaderItems: fn(
            self: *const ITableItemProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnHeaderItems: fn(
            self: *const ITableItemProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableItemProvider_GetRowHeaderItems(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableItemProvider.VTable, self.vtable).GetRowHeaderItems(@ptrCast(*const ITableItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITableItemProvider_GetColumnHeaderItems(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITableItemProvider.VTable, self.vtable).GetColumnHeaderItems(@ptrCast(*const ITableItemProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IToggleProvider_Value = @import("../zig.zig").Guid.initString("56D00BD0-C4F4-433C-A836-1A52A57E0892");
pub const IID_IToggleProvider = &IID_IToggleProvider_Value;
pub const IToggleProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Toggle: fn(
            self: *const IToggleProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ToggleState: fn(
            self: *const IToggleProvider,
            pRetVal: *ToggleState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToggleProvider_Toggle(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToggleProvider.VTable, self.vtable).Toggle(@ptrCast(*const IToggleProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToggleProvider_get_ToggleState(self: *const T, pRetVal: *ToggleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToggleProvider.VTable, self.vtable).get_ToggleState(@ptrCast(*const IToggleProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransformProvider_Value = @import("../zig.zig").Guid.initString("6829DDC4-4F91-4FFA-B86F-BD3E2987CB4C");
pub const IID_ITransformProvider = &IID_ITransformProvider_Value;
pub const ITransformProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Move: fn(
            self: *const ITransformProvider,
            x: f64,
            y: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resize: fn(
            self: *const ITransformProvider,
            width: f64,
            height: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Rotate: fn(
            self: *const ITransformProvider,
            degrees: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CanMove: fn(
            self: *const ITransformProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CanResize: fn(
            self: *const ITransformProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CanRotate: fn(
            self: *const ITransformProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_Move(self: *const T, x: f64, y: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).Move(@ptrCast(*const ITransformProvider, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_Resize(self: *const T, width: f64, height: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).Resize(@ptrCast(*const ITransformProvider, self), width, height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_Rotate(self: *const T, degrees: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).Rotate(@ptrCast(*const ITransformProvider, self), degrees);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_get_CanMove(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).get_CanMove(@ptrCast(*const ITransformProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_get_CanResize(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).get_CanResize(@ptrCast(*const ITransformProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider_get_CanRotate(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider.VTable, self.vtable).get_CanRotate(@ptrCast(*const ITransformProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IValueProvider_Value = @import("../zig.zig").Guid.initString("C7935180-6FB3-4201-B174-7DF73ADBF64A");
pub const IID_IValueProvider = &IID_IValueProvider_Value;
pub const IValueProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: fn(
            self: *const IValueProvider,
            val: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Value: fn(
            self: *const IValueProvider,
            pRetVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_IsReadOnly: fn(
            self: *const IValueProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueProvider_SetValue(self: *const T, val: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueProvider.VTable, self.vtable).SetValue(@ptrCast(*const IValueProvider, self), val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueProvider_get_Value(self: *const T, pRetVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueProvider.VTable, self.vtable).get_Value(@ptrCast(*const IValueProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValueProvider_get_IsReadOnly(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValueProvider.VTable, self.vtable).get_IsReadOnly(@ptrCast(*const IValueProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWindowProvider_Value = @import("../zig.zig").Guid.initString("987DF77B-DB06-4D77-8F8A-86A9C3BB90B9");
pub const IID_IWindowProvider = &IID_IWindowProvider_Value;
pub const IWindowProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetVisualState: fn(
            self: *const IWindowProvider,
            state: WindowVisualState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IWindowProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForInputIdle: fn(
            self: *const IWindowProvider,
            milliseconds: i32,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CanMaximize: fn(
            self: *const IWindowProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CanMinimize: fn(
            self: *const IWindowProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_IsModal: fn(
            self: *const IWindowProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_WindowVisualState: fn(
            self: *const IWindowProvider,
            pRetVal: *WindowVisualState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_WindowInteractionState: fn(
            self: *const IWindowProvider,
            pRetVal: *WindowInteractionState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_IsTopmost: fn(
            self: *const IWindowProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_SetVisualState(self: *const T, state: WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).SetVisualState(@ptrCast(*const IWindowProvider, self), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).Close(@ptrCast(*const IWindowProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_WaitForInputIdle(self: *const T, milliseconds: i32, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).WaitForInputIdle(@ptrCast(*const IWindowProvider, self), milliseconds, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_CanMaximize(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_CanMaximize(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_CanMinimize(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_CanMinimize(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_IsModal(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_IsModal(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_WindowVisualState(self: *const T, pRetVal: *WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_WindowVisualState(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_WindowInteractionState(self: *const T, pRetVal: *WindowInteractionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_WindowInteractionState(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowProvider_get_IsTopmost(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowProvider.VTable, self.vtable).get_IsTopmost(@ptrCast(*const IWindowProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ILegacyIAccessibleProvider_Value = @import("../zig.zig").Guid.initString("E44C3566-915D-4070-99C6-047BFF5A08F5");
pub const IID_ILegacyIAccessibleProvider = &IID_ILegacyIAccessibleProvider_Value;
pub const ILegacyIAccessibleProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Select: fn(
            self: *const ILegacyIAccessibleProvider,
            flagsSelect: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoDefaultAction: fn(
            self: *const ILegacyIAccessibleProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const ILegacyIAccessibleProvider,
            szValue: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIAccessible: fn(
            self: *const ILegacyIAccessibleProvider,
            ppAccessible: **IAccessible,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ChildId: fn(
            self: *const ILegacyIAccessibleProvider,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Name: fn(
            self: *const ILegacyIAccessibleProvider,
            pszName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Value: fn(
            self: *const ILegacyIAccessibleProvider,
            pszValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Description: fn(
            self: *const ILegacyIAccessibleProvider,
            pszDescription: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Role: fn(
            self: *const ILegacyIAccessibleProvider,
            pdwRole: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_State: fn(
            self: *const ILegacyIAccessibleProvider,
            pdwState: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Help: fn(
            self: *const ILegacyIAccessibleProvider,
            pszHelp: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_KeyboardShortcut: fn(
            self: *const ILegacyIAccessibleProvider,
            pszKeyboardShortcut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ILegacyIAccessibleProvider,
            pvarSelectedChildren: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DefaultAction: fn(
            self: *const ILegacyIAccessibleProvider,
            pszDefaultAction: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_Select(self: *const T, flagsSelect: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).Select(@ptrCast(*const ILegacyIAccessibleProvider, self), flagsSelect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_DoDefaultAction(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).DoDefaultAction(@ptrCast(*const ILegacyIAccessibleProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_SetValue(self: *const T, szValue: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).SetValue(@ptrCast(*const ILegacyIAccessibleProvider, self), szValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_GetIAccessible(self: *const T, ppAccessible: **IAccessible) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).GetIAccessible(@ptrCast(*const ILegacyIAccessibleProvider, self), ppAccessible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_ChildId(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_ChildId(@ptrCast(*const ILegacyIAccessibleProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Name(self: *const T, pszName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Name(@ptrCast(*const ILegacyIAccessibleProvider, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Value(self: *const T, pszValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Value(@ptrCast(*const ILegacyIAccessibleProvider, self), pszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Description(self: *const T, pszDescription: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Description(@ptrCast(*const ILegacyIAccessibleProvider, self), pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Role(self: *const T, pdwRole: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Role(@ptrCast(*const ILegacyIAccessibleProvider, self), pdwRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_State(self: *const T, pdwState: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_State(@ptrCast(*const ILegacyIAccessibleProvider, self), pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_Help(self: *const T, pszHelp: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_Help(@ptrCast(*const ILegacyIAccessibleProvider, self), pszHelp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_KeyboardShortcut(self: *const T, pszKeyboardShortcut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_KeyboardShortcut(@ptrCast(*const ILegacyIAccessibleProvider, self), pszKeyboardShortcut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_GetSelection(self: *const T, pvarSelectedChildren: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).GetSelection(@ptrCast(*const ILegacyIAccessibleProvider, self), pvarSelectedChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILegacyIAccessibleProvider_get_DefaultAction(self: *const T, pszDefaultAction: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILegacyIAccessibleProvider.VTable, self.vtable).get_DefaultAction(@ptrCast(*const ILegacyIAccessibleProvider, self), pszDefaultAction);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IItemContainerProvider_Value = @import("../zig.zig").Guid.initString("E747770B-39CE-4382-AB30-D8FB3F336F24");
pub const IID_IItemContainerProvider = &IID_IItemContainerProvider_Value;
pub const IItemContainerProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindItemByProperty: fn(
            self: *const IItemContainerProvider,
            pStartAfter: *IRawElementProviderSimple,
            propertyId: i32,
            value: VARIANT,
            pFound: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IItemContainerProvider_FindItemByProperty(self: *const T, pStartAfter: *IRawElementProviderSimple, propertyId: i32, value: VARIANT, pFound: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IItemContainerProvider.VTable, self.vtable).FindItemByProperty(@ptrCast(*const IItemContainerProvider, self), pStartAfter, propertyId, value, pFound);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVirtualizedItemProvider_Value = @import("../zig.zig").Guid.initString("CB98B665-2D35-4FAC-AD35-F3C60D0C0B8B");
pub const IID_IVirtualizedItemProvider = &IID_IVirtualizedItemProvider_Value;
pub const IVirtualizedItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Realize: fn(
            self: *const IVirtualizedItemProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVirtualizedItemProvider_Realize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVirtualizedItemProvider.VTable, self.vtable).Realize(@ptrCast(*const IVirtualizedItemProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IObjectModelProvider_Value = @import("../zig.zig").Guid.initString("3AD86EBD-F5EF-483D-BB18-B1042A475D64");
pub const IID_IObjectModelProvider = &IID_IObjectModelProvider_Value;
pub const IObjectModelProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUnderlyingObjectModel: fn(
            self: *const IObjectModelProvider,
            ppUnknown: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IObjectModelProvider_GetUnderlyingObjectModel(self: *const T, ppUnknown: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IObjectModelProvider.VTable, self.vtable).GetUnderlyingObjectModel(@ptrCast(*const IObjectModelProvider, self), ppUnknown);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAnnotationProvider_Value = @import("../zig.zig").Guid.initString("F95C7E80-BD63-4601-9782-445EBFF011FC");
pub const IID_IAnnotationProvider = &IID_IAnnotationProvider_Value;
pub const IAnnotationProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_AnnotationTypeId: fn(
            self: *const IAnnotationProvider,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AnnotationTypeName: fn(
            self: *const IAnnotationProvider,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Author: fn(
            self: *const IAnnotationProvider,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DateTime: fn(
            self: *const IAnnotationProvider,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Target: fn(
            self: *const IAnnotationProvider,
            retVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_AnnotationTypeId(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_AnnotationTypeId(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_AnnotationTypeName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_AnnotationTypeName(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_Author(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_Author(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_DateTime(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_DateTime(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAnnotationProvider_get_Target(self: *const T, retVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAnnotationProvider.VTable, self.vtable).get_Target(@ptrCast(*const IAnnotationProvider, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStylesProvider_Value = @import("../zig.zig").Guid.initString("19B6B649-F5D7-4A6D-BDCB-129252BE588A");
pub const IID_IStylesProvider = &IID_IStylesProvider_Value;
pub const IStylesProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_StyleId: fn(
            self: *const IStylesProvider,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_StyleName: fn(
            self: *const IStylesProvider,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FillColor: fn(
            self: *const IStylesProvider,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FillPatternStyle: fn(
            self: *const IStylesProvider,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Shape: fn(
            self: *const IStylesProvider,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FillPatternColor: fn(
            self: *const IStylesProvider,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ExtendedProperties: fn(
            self: *const IStylesProvider,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_StyleId(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_StyleId(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_StyleName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_StyleName(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_FillColor(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_FillColor(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_FillPatternStyle(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_FillPatternStyle(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_Shape(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_Shape(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_FillPatternColor(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_FillPatternColor(@ptrCast(*const IStylesProvider, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStylesProvider_get_ExtendedProperties(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStylesProvider.VTable, self.vtable).get_ExtendedProperties(@ptrCast(*const IStylesProvider, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpreadsheetProvider_Value = @import("../zig.zig").Guid.initString("6F6B5D35-5525-4F80-B758-85473832FFC7");
pub const IID_ISpreadsheetProvider = &IID_ISpreadsheetProvider_Value;
pub const ISpreadsheetProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemByName: fn(
            self: *const ISpreadsheetProvider,
            name: [*:0]const u16,
            pRetVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpreadsheetProvider_GetItemByName(self: *const T, name: [*:0]const u16, pRetVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpreadsheetProvider.VTable, self.vtable).GetItemByName(@ptrCast(*const ISpreadsheetProvider, self), name, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISpreadsheetItemProvider_Value = @import("../zig.zig").Guid.initString("EAED4660-7B3D-4879-A2E6-365CE603F3D0");
pub const IID_ISpreadsheetItemProvider = &IID_ISpreadsheetItemProvider_Value;
pub const ISpreadsheetItemProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_Formula: fn(
            self: *const ISpreadsheetItemProvider,
            pRetVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnnotationObjects: fn(
            self: *const ISpreadsheetItemProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnnotationTypes: fn(
            self: *const ISpreadsheetItemProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpreadsheetItemProvider_get_Formula(self: *const T, pRetVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpreadsheetItemProvider.VTable, self.vtable).get_Formula(@ptrCast(*const ISpreadsheetItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpreadsheetItemProvider_GetAnnotationObjects(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpreadsheetItemProvider.VTable, self.vtable).GetAnnotationObjects(@ptrCast(*const ISpreadsheetItemProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISpreadsheetItemProvider_GetAnnotationTypes(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISpreadsheetItemProvider.VTable, self.vtable).GetAnnotationTypes(@ptrCast(*const ISpreadsheetItemProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITransformProvider2_Value = @import("../zig.zig").Guid.initString("4758742F-7AC2-460C-BC48-09FC09308A93");
pub const IID_ITransformProvider2 = &IID_ITransformProvider2_Value;
pub const ITransformProvider2 = extern struct {
    pub const VTable = extern struct {
        base: ITransformProvider.VTable,
        Zoom: fn(
            self: *const ITransformProvider2,
            zoom: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CanZoom: fn(
            self: *const ITransformProvider2,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ZoomLevel: fn(
            self: *const ITransformProvider2,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ZoomMinimum: fn(
            self: *const ITransformProvider2,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ZoomMaximum: fn(
            self: *const ITransformProvider2,
            pRetVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ZoomByUnit: fn(
            self: *const ITransformProvider2,
            zoomUnit: ZoomUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITransformProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_Zoom(self: *const T, zoom: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).Zoom(@ptrCast(*const ITransformProvider2, self), zoom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_get_CanZoom(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).get_CanZoom(@ptrCast(*const ITransformProvider2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_get_ZoomLevel(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).get_ZoomLevel(@ptrCast(*const ITransformProvider2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_get_ZoomMinimum(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).get_ZoomMinimum(@ptrCast(*const ITransformProvider2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_get_ZoomMaximum(self: *const T, pRetVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).get_ZoomMaximum(@ptrCast(*const ITransformProvider2, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITransformProvider2_ZoomByUnit(self: *const T, zoomUnit: ZoomUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITransformProvider2.VTable, self.vtable).ZoomByUnit(@ptrCast(*const ITransformProvider2, self), zoomUnit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDragProvider_Value = @import("../zig.zig").Guid.initString("6AA7BBBB-7FF9-497D-904F-D20B897929D8");
pub const IID_IDragProvider = &IID_IDragProvider_Value;
pub const IDragProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_IsGrabbed: fn(
            self: *const IDragProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DropEffect: fn(
            self: *const IDragProvider,
            pRetVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DropEffects: fn(
            self: *const IDragProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGrabbedItems: fn(
            self: *const IDragProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragProvider_get_IsGrabbed(self: *const T, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragProvider.VTable, self.vtable).get_IsGrabbed(@ptrCast(*const IDragProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragProvider_get_DropEffect(self: *const T, pRetVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragProvider.VTable, self.vtable).get_DropEffect(@ptrCast(*const IDragProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragProvider_get_DropEffects(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragProvider.VTable, self.vtable).get_DropEffects(@ptrCast(*const IDragProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDragProvider_GetGrabbedItems(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDragProvider.VTable, self.vtable).GetGrabbedItems(@ptrCast(*const IDragProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDropTargetProvider_Value = @import("../zig.zig").Guid.initString("BAE82BFD-358A-481C-85A0-D8B4D90A5D61");
pub const IID_IDropTargetProvider = &IID_IDropTargetProvider_Value;
pub const IDropTargetProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_DropTargetEffect: fn(
            self: *const IDropTargetProvider,
            pRetVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DropTargetEffects: fn(
            self: *const IDropTargetProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTargetProvider_get_DropTargetEffect(self: *const T, pRetVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTargetProvider.VTable, self.vtable).get_DropTargetEffect(@ptrCast(*const IDropTargetProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDropTargetProvider_get_DropTargetEffects(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDropTargetProvider.VTable, self.vtable).get_DropTargetEffects(@ptrCast(*const IDropTargetProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextRangeProvider_Value = @import("../zig.zig").Guid.initString("5347AD7B-C355-46F8-AFF5-909033582F63");
pub const IID_ITextRangeProvider = &IID_ITextRangeProvider_Value;
pub const ITextRangeProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const ITextRangeProvider,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Compare: fn(
            self: *const ITextRangeProvider,
            range: *ITextRangeProvider,
            pRetVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEndpoints: fn(
            self: *const ITextRangeProvider,
            endpoint: TextPatternRangeEndpoint,
            targetRange: *ITextRangeProvider,
            targetEndpoint: TextPatternRangeEndpoint,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExpandToEnclosingUnit: fn(
            self: *const ITextRangeProvider,
            unit: TextUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindAttribute: fn(
            self: *const ITextRangeProvider,
            attributeId: i32,
            val: VARIANT,
            backward: BOOL,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextA: fn(
            self: *const ITextRangeProvider,
            text: BSTR,
            backward: BOOL,
            ignoreCase: BOOL,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeValue: fn(
            self: *const ITextRangeProvider,
            attributeId: i32,
            pRetVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBoundingRectangles: fn(
            self: *const ITextRangeProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnclosingElement: fn(
            self: *const ITextRangeProvider,
            pRetVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITextRangeProvider,
            maxLength: i32,
            pRetVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const ITextRangeProvider,
            unit: TextUnit,
            count: i32,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndpointByUnit: fn(
            self: *const ITextRangeProvider,
            endpoint: TextPatternRangeEndpoint,
            unit: TextUnit,
            count: i32,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndpointByRange: fn(
            self: *const ITextRangeProvider,
            endpoint: TextPatternRangeEndpoint,
            targetRange: *ITextRangeProvider,
            targetEndpoint: TextPatternRangeEndpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddToSelection: fn(
            self: *const ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFromSelection: fn(
            self: *const ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const ITextRangeProvider,
            alignToTop: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChildren: fn(
            self: *const ITextRangeProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_Clone(self: *const T, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).Clone(@ptrCast(*const ITextRangeProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_Compare(self: *const T, range: *ITextRangeProvider, pRetVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).Compare(@ptrCast(*const ITextRangeProvider, self), range, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_CompareEndpoints(self: *const T, endpoint: TextPatternRangeEndpoint, targetRange: *ITextRangeProvider, targetEndpoint: TextPatternRangeEndpoint, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).CompareEndpoints(@ptrCast(*const ITextRangeProvider, self), endpoint, targetRange, targetEndpoint, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_ExpandToEnclosingUnit(self: *const T, unit: TextUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).ExpandToEnclosingUnit(@ptrCast(*const ITextRangeProvider, self), unit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_FindAttribute(self: *const T, attributeId: i32, val: VARIANT, backward: BOOL, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).FindAttribute(@ptrCast(*const ITextRangeProvider, self), attributeId, val, backward, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_FindTextA(self: *const T, text: BSTR, backward: BOOL, ignoreCase: BOOL, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).FindTextA(@ptrCast(*const ITextRangeProvider, self), text, backward, ignoreCase, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetAttributeValue(self: *const T, attributeId: i32, pRetVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetAttributeValue(@ptrCast(*const ITextRangeProvider, self), attributeId, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetBoundingRectangles(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetBoundingRectangles(@ptrCast(*const ITextRangeProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetEnclosingElement(self: *const T, pRetVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetEnclosingElement(@ptrCast(*const ITextRangeProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetText(self: *const T, maxLength: i32, pRetVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetText(@ptrCast(*const ITextRangeProvider, self), maxLength, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_Move(self: *const T, unit: TextUnit, count: i32, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).Move(@ptrCast(*const ITextRangeProvider, self), unit, count, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_MoveEndpointByUnit(self: *const T, endpoint: TextPatternRangeEndpoint, unit: TextUnit, count: i32, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).MoveEndpointByUnit(@ptrCast(*const ITextRangeProvider, self), endpoint, unit, count, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_MoveEndpointByRange(self: *const T, endpoint: TextPatternRangeEndpoint, targetRange: *ITextRangeProvider, targetEndpoint: TextPatternRangeEndpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).MoveEndpointByRange(@ptrCast(*const ITextRangeProvider, self), endpoint, targetRange, targetEndpoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).Select(@ptrCast(*const ITextRangeProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_AddToSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).AddToSelection(@ptrCast(*const ITextRangeProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_RemoveFromSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).RemoveFromSelection(@ptrCast(*const ITextRangeProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_ScrollIntoView(self: *const T, alignToTop: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).ScrollIntoView(@ptrCast(*const ITextRangeProvider, self), alignToTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider_GetChildren(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider.VTable, self.vtable).GetChildren(@ptrCast(*const ITextRangeProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextProvider_Value = @import("../zig.zig").Guid.initString("3589C92C-63F3-4367-99BB-ADA653B77CF2");
pub const IID_ITextProvider = &IID_ITextProvider_Value;
pub const ITextProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSelection: fn(
            self: *const ITextProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVisibleRanges: fn(
            self: *const ITextProvider,
            pRetVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromChild: fn(
            self: *const ITextProvider,
            childElement: *IRawElementProviderSimple,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint: fn(
            self: *const ITextProvider,
            point: UiaPoint,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DocumentRange: fn(
            self: *const ITextProvider,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_SupportedTextSelection: fn(
            self: *const ITextProvider,
            pRetVal: *SupportedTextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_GetSelection(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).GetSelection(@ptrCast(*const ITextProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_GetVisibleRanges(self: *const T, pRetVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).GetVisibleRanges(@ptrCast(*const ITextProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_RangeFromChild(self: *const T, childElement: *IRawElementProviderSimple, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).RangeFromChild(@ptrCast(*const ITextProvider, self), childElement, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_RangeFromPoint(self: *const T, point: UiaPoint, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).RangeFromPoint(@ptrCast(*const ITextProvider, self), point, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_get_DocumentRange(self: *const T, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).get_DocumentRange(@ptrCast(*const ITextProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider_get_SupportedTextSelection(self: *const T, pRetVal: *SupportedTextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider.VTable, self.vtable).get_SupportedTextSelection(@ptrCast(*const ITextProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextProvider2_Value = @import("../zig.zig").Guid.initString("0DC5E6ED-3E16-4BF1-8F9A-A979878BC195");
pub const IID_ITextProvider2 = &IID_ITextProvider2_Value;
pub const ITextProvider2 = extern struct {
    pub const VTable = extern struct {
        base: ITextProvider.VTable,
        RangeFromAnnotation: fn(
            self: *const ITextProvider2,
            annotationElement: *IRawElementProviderSimple,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaretRange: fn(
            self: *const ITextProvider2,
            isActive: *BOOL,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider2_RangeFromAnnotation(self: *const T, annotationElement: *IRawElementProviderSimple, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider2.VTable, self.vtable).RangeFromAnnotation(@ptrCast(*const ITextProvider2, self), annotationElement, pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextProvider2_GetCaretRange(self: *const T, isActive: *BOOL, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextProvider2.VTable, self.vtable).GetCaretRange(@ptrCast(*const ITextProvider2, self), isActive, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextEditProvider_Value = @import("../zig.zig").Guid.initString("EA3605B4-3A05-400E-B5F9-4E91B40F6176");
pub const IID_ITextEditProvider = &IID_ITextEditProvider_Value;
pub const ITextEditProvider = extern struct {
    pub const VTable = extern struct {
        base: ITextProvider.VTable,
        GetActiveComposition: fn(
            self: *const ITextEditProvider,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionTarget: fn(
            self: *const ITextEditProvider,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextEditProvider_GetActiveComposition(self: *const T, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextEditProvider.VTable, self.vtable).GetActiveComposition(@ptrCast(*const ITextEditProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextEditProvider_GetConversionTarget(self: *const T, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextEditProvider.VTable, self.vtable).GetConversionTarget(@ptrCast(*const ITextEditProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextRangeProvider2_Value = @import("../zig.zig").Guid.initString("9BBCE42C-1921-4F18-89CA-DBA1910A0386");
pub const IID_ITextRangeProvider2 = &IID_ITextRangeProvider2_Value;
pub const ITextRangeProvider2 = extern struct {
    pub const VTable = extern struct {
        base: ITextRangeProvider.VTable,
        ShowContextMenu: fn(
            self: *const ITextRangeProvider2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRangeProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRangeProvider2_ShowContextMenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRangeProvider2.VTable, self.vtable).ShowContextMenu(@ptrCast(*const ITextRangeProvider2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextChildProvider_Value = @import("../zig.zig").Guid.initString("4C2DE2B9-C88F-4F88-A111-F1D336B7D1A9");
pub const IID_ITextChildProvider = &IID_ITextChildProvider_Value;
pub const ITextChildProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_TextContainer: fn(
            self: *const ITextChildProvider,
            pRetVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TextRange: fn(
            self: *const ITextChildProvider,
            pRetVal: **ITextRangeProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextChildProvider_get_TextContainer(self: *const T, pRetVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextChildProvider.VTable, self.vtable).get_TextContainer(@ptrCast(*const ITextChildProvider, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextChildProvider_get_TextRange(self: *const T, pRetVal: **ITextRangeProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextChildProvider.VTable, self.vtable).get_TextRange(@ptrCast(*const ITextChildProvider, self), pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICustomNavigationProvider_Value = @import("../zig.zig").Guid.initString("2062A28A-8C07-4B94-8E12-7037C622AEB8");
pub const IID_ICustomNavigationProvider = &IID_ICustomNavigationProvider_Value;
pub const ICustomNavigationProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Navigate: fn(
            self: *const ICustomNavigationProvider,
            direction: NavigateDirection,
            pRetVal: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICustomNavigationProvider_Navigate(self: *const T, direction: NavigateDirection, pRetVal: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICustomNavigationProvider.VTable, self.vtable).Navigate(@ptrCast(*const ICustomNavigationProvider, self), direction, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationPatternInstance_Value = @import("../zig.zig").Guid.initString("C03A7FE4-9431-409F-BED8-AE7C2299BC8D");
pub const IID_IUIAutomationPatternInstance = &IID_IUIAutomationPatternInstance_Value;
pub const IUIAutomationPatternInstance = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: fn(
            self: *const IUIAutomationPatternInstance,
            index: u32,
            cached: BOOL,
            type: UIAutomationType,
            pPtr: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallMethod: fn(
            self: *const IUIAutomationPatternInstance,
            index: u32,
            pParams: *const UIAutomationParameter,
            cParams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPatternInstance_GetProperty(self: *const T, index: u32, cached: BOOL, type: UIAutomationType, pPtr: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPatternInstance.VTable, self.vtable).GetProperty(@ptrCast(*const IUIAutomationPatternInstance, self), index, cached, type, pPtr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPatternInstance_CallMethod(self: *const T, index: u32, pParams: *const UIAutomationParameter, cParams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPatternInstance.VTable, self.vtable).CallMethod(@ptrCast(*const IUIAutomationPatternInstance, self), index, pParams, cParams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationPatternHandler_Value = @import("../zig.zig").Guid.initString("D97022F3-A947-465E-8B2A-AC4315FA54E8");
pub const IID_IUIAutomationPatternHandler = &IID_IUIAutomationPatternHandler_Value;
pub const IUIAutomationPatternHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateClientWrapper: fn(
            self: *const IUIAutomationPatternHandler,
            pPatternInstance: *IUIAutomationPatternInstance,
            pClientWrapper: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Dispatch: fn(
            self: *const IUIAutomationPatternHandler,
            pTarget: *IUnknown,
            index: u32,
            pParams: *const UIAutomationParameter,
            cParams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPatternHandler_CreateClientWrapper(self: *const T, pPatternInstance: *IUIAutomationPatternInstance, pClientWrapper: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPatternHandler.VTable, self.vtable).CreateClientWrapper(@ptrCast(*const IUIAutomationPatternHandler, self), pPatternInstance, pClientWrapper);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPatternHandler_Dispatch(self: *const T, pTarget: *IUnknown, index: u32, pParams: *const UIAutomationParameter, cParams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPatternHandler.VTable, self.vtable).Dispatch(@ptrCast(*const IUIAutomationPatternHandler, self), pTarget, index, pParams, cParams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationRegistrar_Value = @import("../zig.zig").Guid.initString("8609C4EC-4A1A-4D88-A357-5A66E060E1CF");
pub const IID_IUIAutomationRegistrar = &IID_IUIAutomationRegistrar_Value;
pub const IUIAutomationRegistrar = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterProperty: fn(
            self: *const IUIAutomationRegistrar,
            property: *const UIAutomationPropertyInfo,
            propertyId: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterEvent: fn(
            self: *const IUIAutomationRegistrar,
            event: *const UIAutomationEventInfo,
            eventId: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterPattern: fn(
            self: *const IUIAutomationRegistrar,
            pattern: *const UIAutomationPatternInfo,
            pPatternId: *i32,
            pPatternAvailablePropertyId: *i32,
            propertyIdCount: u32,
            pPropertyIds: [*]i32,
            eventIdCount: u32,
            pEventIds: [*]i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRegistrar_RegisterProperty(self: *const T, property: *const UIAutomationPropertyInfo, propertyId: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRegistrar.VTable, self.vtable).RegisterProperty(@ptrCast(*const IUIAutomationRegistrar, self), property, propertyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRegistrar_RegisterEvent(self: *const T, event: *const UIAutomationEventInfo, eventId: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRegistrar.VTable, self.vtable).RegisterEvent(@ptrCast(*const IUIAutomationRegistrar, self), event, eventId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRegistrar_RegisterPattern(self: *const T, pattern: *const UIAutomationPatternInfo, pPatternId: *i32, pPatternAvailablePropertyId: *i32, propertyIdCount: u32, pPropertyIds: [*]i32, eventIdCount: u32, pEventIds: [*]i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRegistrar.VTable, self.vtable).RegisterPattern(@ptrCast(*const IUIAutomationRegistrar, self), pattern, pPatternId, pPatternAvailablePropertyId, propertyIdCount, pPropertyIds, eventIdCount, pEventIds);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const HUIANODE__ = extern struct {
    unused: i32,
};

pub const HUIAPATTERNOBJECT__ = extern struct {
    unused: i32,
};

pub const HUIATEXTRANGE__ = extern struct {
    unused: i32,
};

pub const HUIAEVENT__ = extern struct {
    unused: i32,
};

pub const TreeScope = extern enum(i32) {
    None = 0,
    Element = 1,
    Children = 2,
    Descendants = 4,
    Parent = 8,
    Ancestors = 16,
    Subtree = 7,
};
pub const TreeScope_None = TreeScope.None;
pub const TreeScope_Element = TreeScope.Element;
pub const TreeScope_Children = TreeScope.Children;
pub const TreeScope_Descendants = TreeScope.Descendants;
pub const TreeScope_Parent = TreeScope.Parent;
pub const TreeScope_Ancestors = TreeScope.Ancestors;
pub const TreeScope_Subtree = TreeScope.Subtree;

pub const ConditionType = extern enum(i32) {
    True = 0,
    False = 1,
    Property = 2,
    And = 3,
    Or = 4,
    Not = 5,
};
pub const ConditionType_True = ConditionType.True;
pub const ConditionType_False = ConditionType.False;
pub const ConditionType_Property = ConditionType.Property;
pub const ConditionType_And = ConditionType.And;
pub const ConditionType_Or = ConditionType.Or;
pub const ConditionType_Not = ConditionType.Not;

pub const UiaCondition = extern struct {
    ConditionType: ConditionType,
};

pub const PropertyConditionFlags = extern enum(i32) {
    None = 0,
    IgnoreCase = 1,
    MatchSubstring = 2,
};
pub const PropertyConditionFlags_None = PropertyConditionFlags.None;
pub const PropertyConditionFlags_IgnoreCase = PropertyConditionFlags.IgnoreCase;
pub const PropertyConditionFlags_MatchSubstring = PropertyConditionFlags.MatchSubstring;

pub const UiaPropertyCondition = extern struct {
    ConditionType: ConditionType,
    PropertyId: i32,
    Value: VARIANT,
    Flags: PropertyConditionFlags,
};

pub const UiaAndOrCondition = extern struct {
    ConditionType: ConditionType,
    ppConditions: **UiaCondition,
    cConditions: i32,
};

pub const UiaNotCondition = extern struct {
    ConditionType: ConditionType,
    pCondition: *UiaCondition,
};

pub const AutomationElementMode = extern enum(i32) {
    None = 0,
    Full = 1,
};
pub const AutomationElementMode_None = AutomationElementMode.None;
pub const AutomationElementMode_Full = AutomationElementMode.Full;

pub const UiaCacheRequest = extern struct {
    pViewCondition: *UiaCondition,
    Scope: TreeScope,
    pProperties: *i32,
    cProperties: i32,
    pPatterns: *i32,
    cPatterns: i32,
    automationElementMode: AutomationElementMode,
};

pub const NormalizeState = extern enum(i32) {
    None = 0,
    View = 1,
    Custom = 2,
};
pub const NormalizeState_None = NormalizeState.None;
pub const NormalizeState_View = NormalizeState.View;
pub const NormalizeState_Custom = NormalizeState.Custom;

pub const TreeTraversalOptions = extern enum(i32) {
    Default = 0,
    PostOrder = 1,
    LastToFirstOrder = 2,
};
pub const TreeTraversalOptions_Default = TreeTraversalOptions.Default;
pub const TreeTraversalOptions_PostOrder = TreeTraversalOptions.PostOrder;
pub const TreeTraversalOptions_LastToFirstOrder = TreeTraversalOptions.LastToFirstOrder;

pub const UiaFindParams = extern struct {
    MaxDepth: i32,
    FindFirst: BOOL,
    ExcludeRoot: BOOL,
    pFindCondition: *UiaCondition,
};

pub const ProviderType = extern enum(i32) {
    BaseHwnd = 0,
    Proxy = 1,
    NonClientArea = 2,
};
pub const ProviderType_BaseHwnd = ProviderType.BaseHwnd;
pub const ProviderType_Proxy = ProviderType.Proxy;
pub const ProviderType_NonClientArea = ProviderType.NonClientArea;

pub const UiaProviderCallback = fn(
    hwnd: HWND,
    providerType: ProviderType,
) callconv(@import("std").os.windows.WINAPI) *SAFEARRAY;

pub const AutomationIdentifierType = extern enum(i32) {
    Property = 0,
    Pattern = 1,
    Event = 2,
    ControlType = 3,
    TextAttribute = 4,
    LandmarkType = 5,
    Annotation = 6,
    Changes = 7,
    Style = 8,
};
pub const AutomationIdentifierType_Property = AutomationIdentifierType.Property;
pub const AutomationIdentifierType_Pattern = AutomationIdentifierType.Pattern;
pub const AutomationIdentifierType_Event = AutomationIdentifierType.Event;
pub const AutomationIdentifierType_ControlType = AutomationIdentifierType.ControlType;
pub const AutomationIdentifierType_TextAttribute = AutomationIdentifierType.TextAttribute;
pub const AutomationIdentifierType_LandmarkType = AutomationIdentifierType.LandmarkType;
pub const AutomationIdentifierType_Annotation = AutomationIdentifierType.Annotation;
pub const AutomationIdentifierType_Changes = AutomationIdentifierType.Changes;
pub const AutomationIdentifierType_Style = AutomationIdentifierType.Style;

pub const EventArgsType = extern enum(i32) {
    Simple = 0,
    PropertyChanged = 1,
    StructureChanged = 2,
    AsyncContentLoaded = 3,
    WindowClosed = 4,
    TextEditTextChanged = 5,
    Changes = 6,
    Notification = 7,
    ActiveTextPositionChanged = 8,
    StructuredMarkup = 9,
};
pub const EventArgsType_Simple = EventArgsType.Simple;
pub const EventArgsType_PropertyChanged = EventArgsType.PropertyChanged;
pub const EventArgsType_StructureChanged = EventArgsType.StructureChanged;
pub const EventArgsType_AsyncContentLoaded = EventArgsType.AsyncContentLoaded;
pub const EventArgsType_WindowClosed = EventArgsType.WindowClosed;
pub const EventArgsType_TextEditTextChanged = EventArgsType.TextEditTextChanged;
pub const EventArgsType_Changes = EventArgsType.Changes;
pub const EventArgsType_Notification = EventArgsType.Notification;
pub const EventArgsType_ActiveTextPositionChanged = EventArgsType.ActiveTextPositionChanged;
pub const EventArgsType_StructuredMarkup = EventArgsType.StructuredMarkup;

pub const AsyncContentLoadedState = extern enum(i32) {
    Beginning = 0,
    Progress = 1,
    Completed = 2,
};
pub const AsyncContentLoadedState_Beginning = AsyncContentLoadedState.Beginning;
pub const AsyncContentLoadedState_Progress = AsyncContentLoadedState.Progress;
pub const AsyncContentLoadedState_Completed = AsyncContentLoadedState.Completed;

pub const UiaEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
};

pub const UiaPropertyChangedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    PropertyId: i32,
    OldValue: VARIANT,
    NewValue: VARIANT,
};

pub const UiaStructureChangedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    StructureChangeType: StructureChangeType,
    pRuntimeId: *i32,
    cRuntimeIdLen: i32,
};

pub const UiaTextEditTextChangedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    TextEditChangeType: TextEditChangeType,
    pTextChange: *SAFEARRAY,
};

pub const UiaChangesEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    EventIdCount: i32,
    pUiaChanges: *UiaChangeInfo,
};

pub const UiaAsyncContentLoadedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    AsyncContentLoadedState: AsyncContentLoadedState,
    PercentComplete: f64,
};

pub const UiaWindowClosedEventArgs = extern struct {
    Type: EventArgsType,
    EventId: i32,
    pRuntimeId: *i32,
    cRuntimeIdLen: i32,
};

pub const UiaEventCallback = fn(
    pArgs: *UiaEventArgs,
    pRequestedData: *SAFEARRAY,
    pTreeStructure: BSTR,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_CUIAutomation_Value = @import("../zig.zig").Guid.initString("FF48DBA4-60EF-4201-AA87-54103EEF594E");
pub const CLSID_CUIAutomation = &CLSID_CUIAutomation_Value;

const CLSID_CUIAutomation8_Value = @import("../zig.zig").Guid.initString("E22AD333-B25F-460C-83D0-0581107395C9");
pub const CLSID_CUIAutomation8 = &CLSID_CUIAutomation8_Value;

pub const ExtendedProperty = extern struct {
    PropertyName: BSTR,
    PropertyValue: BSTR,
};

const IID_IUIAutomationElement_Value = @import("../zig.zig").Guid.initString("D22108AA-8AC5-49A5-837B-37BBB3D7591E");
pub const IID_IUIAutomationElement = &IID_IUIAutomationElement_Value;
pub const IUIAutomationElement = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFocus: fn(
            self: *const IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRuntimeId: fn(
            self: *const IUIAutomationElement,
            runtimeId: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindFirst: fn(
            self: *const IUIAutomationElement,
            scope: TreeScope,
            condition: *IUIAutomationCondition,
            found: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindAll: fn(
            self: *const IUIAutomationElement,
            scope: TreeScope,
            condition: *IUIAutomationCondition,
            found: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindFirstBuildCache: fn(
            self: *const IUIAutomationElement,
            scope: TreeScope,
            condition: *IUIAutomationCondition,
            cacheRequest: *IUIAutomationCacheRequest,
            found: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindAllBuildCache: fn(
            self: *const IUIAutomationElement,
            scope: TreeScope,
            condition: *IUIAutomationCondition,
            cacheRequest: *IUIAutomationCacheRequest,
            found: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BuildUpdatedCache: fn(
            self: *const IUIAutomationElement,
            cacheRequest: *IUIAutomationCacheRequest,
            updatedElement: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPropertyValue: fn(
            self: *const IUIAutomationElement,
            propertyId: i32,
            retVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPropertyValueEx: fn(
            self: *const IUIAutomationElement,
            propertyId: i32,
            ignoreDefaultValue: BOOL,
            retVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedPropertyValue: fn(
            self: *const IUIAutomationElement,
            propertyId: i32,
            retVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedPropertyValueEx: fn(
            self: *const IUIAutomationElement,
            propertyId: i32,
            ignoreDefaultValue: BOOL,
            retVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPatternAs: fn(
            self: *const IUIAutomationElement,
            patternId: i32,
            riid: *const Guid,
            patternObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedPatternAs: fn(
            self: *const IUIAutomationElement,
            patternId: i32,
            riid: *const Guid,
            patternObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPattern: fn(
            self: *const IUIAutomationElement,
            patternId: i32,
            patternObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedPattern: fn(
            self: *const IUIAutomationElement,
            patternId: i32,
            patternObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedParent: fn(
            self: *const IUIAutomationElement,
            parent: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedChildren: fn(
            self: *const IUIAutomationElement,
            children: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentProcessId: fn(
            self: *const IUIAutomationElement,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentControlType: fn(
            self: *const IUIAutomationElement,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentLocalizedControlType: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentName: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentAcceleratorKey: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentAccessKey: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentHasKeyboardFocus: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsKeyboardFocusable: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsEnabled: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentAutomationId: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentClassName: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentHelpText: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCulture: fn(
            self: *const IUIAutomationElement,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsControlElement: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsContentElement: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsPassword: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentNativeWindowHandle: fn(
            self: *const IUIAutomationElement,
            retVal: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentItemType: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsOffscreen: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentOrientation: fn(
            self: *const IUIAutomationElement,
            retVal: *OrientationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentFrameworkId: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsRequiredForForm: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentItemStatus: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentBoundingRectangle: fn(
            self: *const IUIAutomationElement,
            retVal: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentLabeledBy: fn(
            self: *const IUIAutomationElement,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentAriaRole: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentAriaProperties: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsDataValidForForm: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentControllerFor: fn(
            self: *const IUIAutomationElement,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentDescribedBy: fn(
            self: *const IUIAutomationElement,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentFlowsTo: fn(
            self: *const IUIAutomationElement,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentProviderDescription: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedProcessId: fn(
            self: *const IUIAutomationElement,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedControlType: fn(
            self: *const IUIAutomationElement,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedLocalizedControlType: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedName: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAcceleratorKey: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAccessKey: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedHasKeyboardFocus: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsKeyboardFocusable: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsEnabled: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAutomationId: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedClassName: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedHelpText: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCulture: fn(
            self: *const IUIAutomationElement,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsControlElement: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsContentElement: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsPassword: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedNativeWindowHandle: fn(
            self: *const IUIAutomationElement,
            retVal: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedItemType: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsOffscreen: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedOrientation: fn(
            self: *const IUIAutomationElement,
            retVal: *OrientationType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedFrameworkId: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsRequiredForForm: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedItemStatus: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedBoundingRectangle: fn(
            self: *const IUIAutomationElement,
            retVal: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedLabeledBy: fn(
            self: *const IUIAutomationElement,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAriaRole: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAriaProperties: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsDataValidForForm: fn(
            self: *const IUIAutomationElement,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedControllerFor: fn(
            self: *const IUIAutomationElement,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedDescribedBy: fn(
            self: *const IUIAutomationElement,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedFlowsTo: fn(
            self: *const IUIAutomationElement,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedProviderDescription: fn(
            self: *const IUIAutomationElement,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClickablePoint: fn(
            self: *const IUIAutomationElement,
            clickable: *POINT,
            gotClickable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_SetFocus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).SetFocus(@ptrCast(*const IUIAutomationElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetRuntimeId(self: *const T, runtimeId: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetRuntimeId(@ptrCast(*const IUIAutomationElement, self), runtimeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_FindFirst(self: *const T, scope: TreeScope, condition: *IUIAutomationCondition, found: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).FindFirst(@ptrCast(*const IUIAutomationElement, self), scope, condition, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_FindAll(self: *const T, scope: TreeScope, condition: *IUIAutomationCondition, found: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).FindAll(@ptrCast(*const IUIAutomationElement, self), scope, condition, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_FindFirstBuildCache(self: *const T, scope: TreeScope, condition: *IUIAutomationCondition, cacheRequest: *IUIAutomationCacheRequest, found: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).FindFirstBuildCache(@ptrCast(*const IUIAutomationElement, self), scope, condition, cacheRequest, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_FindAllBuildCache(self: *const T, scope: TreeScope, condition: *IUIAutomationCondition, cacheRequest: *IUIAutomationCacheRequest, found: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).FindAllBuildCache(@ptrCast(*const IUIAutomationElement, self), scope, condition, cacheRequest, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_BuildUpdatedCache(self: *const T, cacheRequest: *IUIAutomationCacheRequest, updatedElement: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).BuildUpdatedCache(@ptrCast(*const IUIAutomationElement, self), cacheRequest, updatedElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCurrentPropertyValue(self: *const T, propertyId: i32, retVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCurrentPropertyValue(@ptrCast(*const IUIAutomationElement, self), propertyId, retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCurrentPropertyValueEx(self: *const T, propertyId: i32, ignoreDefaultValue: BOOL, retVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCurrentPropertyValueEx(@ptrCast(*const IUIAutomationElement, self), propertyId, ignoreDefaultValue, retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedPropertyValue(self: *const T, propertyId: i32, retVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedPropertyValue(@ptrCast(*const IUIAutomationElement, self), propertyId, retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedPropertyValueEx(self: *const T, propertyId: i32, ignoreDefaultValue: BOOL, retVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedPropertyValueEx(@ptrCast(*const IUIAutomationElement, self), propertyId, ignoreDefaultValue, retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCurrentPatternAs(self: *const T, patternId: i32, riid: *const Guid, patternObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCurrentPatternAs(@ptrCast(*const IUIAutomationElement, self), patternId, riid, patternObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedPatternAs(self: *const T, patternId: i32, riid: *const Guid, patternObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedPatternAs(@ptrCast(*const IUIAutomationElement, self), patternId, riid, patternObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCurrentPattern(self: *const T, patternId: i32, patternObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCurrentPattern(@ptrCast(*const IUIAutomationElement, self), patternId, patternObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedPattern(self: *const T, patternId: i32, patternObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedPattern(@ptrCast(*const IUIAutomationElement, self), patternId, patternObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedParent(self: *const T, parent: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedParent(@ptrCast(*const IUIAutomationElement, self), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetCachedChildren(self: *const T, children: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetCachedChildren(@ptrCast(*const IUIAutomationElement, self), children);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentProcessId(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentProcessId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentControlType(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentControlType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentLocalizedControlType(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentLocalizedControlType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentName(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAcceleratorKey(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAcceleratorKey(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAccessKey(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAccessKey(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentHasKeyboardFocus(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentHasKeyboardFocus(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsKeyboardFocusable(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsKeyboardFocusable(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsEnabled(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsEnabled(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAutomationId(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAutomationId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentClassName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentClassName(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentHelpText(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentHelpText(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentCulture(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentCulture(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsControlElement(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsControlElement(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsContentElement(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsContentElement(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsPassword(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsPassword(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentNativeWindowHandle(self: *const T, retVal: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentNativeWindowHandle(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentItemType(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentItemType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsOffscreen(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsOffscreen(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentOrientation(self: *const T, retVal: *OrientationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentOrientation(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentFrameworkId(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentFrameworkId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsRequiredForForm(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsRequiredForForm(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentItemStatus(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentItemStatus(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentBoundingRectangle(self: *const T, retVal: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentBoundingRectangle(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentLabeledBy(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentLabeledBy(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAriaRole(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAriaRole(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentAriaProperties(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentAriaProperties(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentIsDataValidForForm(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentIsDataValidForForm(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentControllerFor(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentControllerFor(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentDescribedBy(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentDescribedBy(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentFlowsTo(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentFlowsTo(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CurrentProviderDescription(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CurrentProviderDescription(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedProcessId(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedProcessId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedControlType(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedControlType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedLocalizedControlType(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedLocalizedControlType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedName(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAcceleratorKey(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAcceleratorKey(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAccessKey(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAccessKey(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedHasKeyboardFocus(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedHasKeyboardFocus(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsKeyboardFocusable(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsKeyboardFocusable(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsEnabled(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsEnabled(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAutomationId(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAutomationId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedClassName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedClassName(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedHelpText(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedHelpText(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedCulture(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedCulture(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsControlElement(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsControlElement(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsContentElement(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsContentElement(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsPassword(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsPassword(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedNativeWindowHandle(self: *const T, retVal: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedNativeWindowHandle(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedItemType(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedItemType(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsOffscreen(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsOffscreen(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedOrientation(self: *const T, retVal: *OrientationType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedOrientation(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedFrameworkId(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedFrameworkId(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsRequiredForForm(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsRequiredForForm(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedItemStatus(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedItemStatus(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedBoundingRectangle(self: *const T, retVal: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedBoundingRectangle(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedLabeledBy(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedLabeledBy(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAriaRole(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAriaRole(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedAriaProperties(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedAriaProperties(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedIsDataValidForForm(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedIsDataValidForForm(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedControllerFor(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedControllerFor(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedDescribedBy(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedDescribedBy(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedFlowsTo(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedFlowsTo(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_get_CachedProviderDescription(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).get_CachedProviderDescription(@ptrCast(*const IUIAutomationElement, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement_GetClickablePoint(self: *const T, clickable: *POINT, gotClickable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement.VTable, self.vtable).GetClickablePoint(@ptrCast(*const IUIAutomationElement, self), clickable, gotClickable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationElementArray_Value = @import("../zig.zig").Guid.initString("14314595-B4BC-4055-95F2-58F2E42C9855");
pub const IID_IUIAutomationElementArray = &IID_IUIAutomationElementArray_Value;
pub const IUIAutomationElementArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_Length: fn(
            self: *const IUIAutomationElementArray,
            length: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElement: fn(
            self: *const IUIAutomationElementArray,
            index: i32,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElementArray_get_Length(self: *const T, length: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElementArray.VTable, self.vtable).get_Length(@ptrCast(*const IUIAutomationElementArray, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElementArray_GetElement(self: *const T, index: i32, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElementArray.VTable, self.vtable).GetElement(@ptrCast(*const IUIAutomationElementArray, self), index, element);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationCondition_Value = @import("../zig.zig").Guid.initString("352FFBA8-0973-437C-A61F-F64CAFD81DF9");
pub const IID_IUIAutomationCondition = &IID_IUIAutomationCondition_Value;
pub const IUIAutomationCondition = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationBoolCondition_Value = @import("../zig.zig").Guid.initString("1B4E1F2E-75EB-4D0B-8952-5A69988E2307");
pub const IID_IUIAutomationBoolCondition = &IID_IUIAutomationBoolCondition_Value;
pub const IUIAutomationBoolCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        get_BooleanValue: fn(
            self: *const IUIAutomationBoolCondition,
            boolVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationBoolCondition_get_BooleanValue(self: *const T, boolVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationBoolCondition.VTable, self.vtable).get_BooleanValue(@ptrCast(*const IUIAutomationBoolCondition, self), boolVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationPropertyCondition_Value = @import("../zig.zig").Guid.initString("99EBF2CB-5578-4267-9AD4-AFD6EA77E94B");
pub const IID_IUIAutomationPropertyCondition = &IID_IUIAutomationPropertyCondition_Value;
pub const IUIAutomationPropertyCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        get_PropertyId: fn(
            self: *const IUIAutomationPropertyCondition,
            propertyId: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_PropertyValue: fn(
            self: *const IUIAutomationPropertyCondition,
            propertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_PropertyConditionFlags: fn(
            self: *const IUIAutomationPropertyCondition,
            flags: *PropertyConditionFlags,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPropertyCondition_get_PropertyId(self: *const T, propertyId: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPropertyCondition.VTable, self.vtable).get_PropertyId(@ptrCast(*const IUIAutomationPropertyCondition, self), propertyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPropertyCondition_get_PropertyValue(self: *const T, propertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPropertyCondition.VTable, self.vtable).get_PropertyValue(@ptrCast(*const IUIAutomationPropertyCondition, self), propertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPropertyCondition_get_PropertyConditionFlags(self: *const T, flags: *PropertyConditionFlags) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPropertyCondition.VTable, self.vtable).get_PropertyConditionFlags(@ptrCast(*const IUIAutomationPropertyCondition, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationAndCondition_Value = @import("../zig.zig").Guid.initString("A7D0AF36-B912-45FE-9855-091DDC174AEC");
pub const IID_IUIAutomationAndCondition = &IID_IUIAutomationAndCondition_Value;
pub const IUIAutomationAndCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        get_ChildCount: fn(
            self: *const IUIAutomationAndCondition,
            childCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChildrenAsNativeArray: fn(
            self: *const IUIAutomationAndCondition,
            childArray: [*]**IUIAutomationCondition,
            childArrayCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChildren: fn(
            self: *const IUIAutomationAndCondition,
            childArray: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAndCondition_get_ChildCount(self: *const T, childCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAndCondition.VTable, self.vtable).get_ChildCount(@ptrCast(*const IUIAutomationAndCondition, self), childCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAndCondition_GetChildrenAsNativeArray(self: *const T, childArray: [*]**IUIAutomationCondition, childArrayCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAndCondition.VTable, self.vtable).GetChildrenAsNativeArray(@ptrCast(*const IUIAutomationAndCondition, self), childArray, childArrayCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAndCondition_GetChildren(self: *const T, childArray: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAndCondition.VTable, self.vtable).GetChildren(@ptrCast(*const IUIAutomationAndCondition, self), childArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationOrCondition_Value = @import("../zig.zig").Guid.initString("8753F032-3DB1-47B5-A1FC-6E34A266C712");
pub const IID_IUIAutomationOrCondition = &IID_IUIAutomationOrCondition_Value;
pub const IUIAutomationOrCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        get_ChildCount: fn(
            self: *const IUIAutomationOrCondition,
            childCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChildrenAsNativeArray: fn(
            self: *const IUIAutomationOrCondition,
            childArray: [*]**IUIAutomationCondition,
            childArrayCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChildren: fn(
            self: *const IUIAutomationOrCondition,
            childArray: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationOrCondition_get_ChildCount(self: *const T, childCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationOrCondition.VTable, self.vtable).get_ChildCount(@ptrCast(*const IUIAutomationOrCondition, self), childCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationOrCondition_GetChildrenAsNativeArray(self: *const T, childArray: [*]**IUIAutomationCondition, childArrayCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationOrCondition.VTable, self.vtable).GetChildrenAsNativeArray(@ptrCast(*const IUIAutomationOrCondition, self), childArray, childArrayCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationOrCondition_GetChildren(self: *const T, childArray: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationOrCondition.VTable, self.vtable).GetChildren(@ptrCast(*const IUIAutomationOrCondition, self), childArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationNotCondition_Value = @import("../zig.zig").Guid.initString("F528B657-847B-498C-8896-D52B565407A1");
pub const IID_IUIAutomationNotCondition = &IID_IUIAutomationNotCondition_Value;
pub const IUIAutomationNotCondition = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationCondition.VTable,
        GetChild: fn(
            self: *const IUIAutomationNotCondition,
            condition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationCondition.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationNotCondition_GetChild(self: *const T, condition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationNotCondition.VTable, self.vtable).GetChild(@ptrCast(*const IUIAutomationNotCondition, self), condition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationCacheRequest_Value = @import("../zig.zig").Guid.initString("B32A92B5-BC25-4078-9C08-D7EE95C48E03");
pub const IID_IUIAutomationCacheRequest = &IID_IUIAutomationCacheRequest_Value;
pub const IUIAutomationCacheRequest = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddProperty: fn(
            self: *const IUIAutomationCacheRequest,
            propertyId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPattern: fn(
            self: *const IUIAutomationCacheRequest,
            patternId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IUIAutomationCacheRequest,
            clonedRequest: **IUIAutomationCacheRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TreeScope: fn(
            self: *const IUIAutomationCacheRequest,
            scope: *TreeScope,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_TreeScope: fn(
            self: *const IUIAutomationCacheRequest,
            scope: TreeScope,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TreeFilter: fn(
            self: *const IUIAutomationCacheRequest,
            filter: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_TreeFilter: fn(
            self: *const IUIAutomationCacheRequest,
            filter: *IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AutomationElementMode: fn(
            self: *const IUIAutomationCacheRequest,
            mode: *AutomationElementMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_AutomationElementMode: fn(
            self: *const IUIAutomationCacheRequest,
            mode: AutomationElementMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_AddProperty(self: *const T, propertyId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).AddProperty(@ptrCast(*const IUIAutomationCacheRequest, self), propertyId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_AddPattern(self: *const T, patternId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).AddPattern(@ptrCast(*const IUIAutomationCacheRequest, self), patternId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_Clone(self: *const T, clonedRequest: **IUIAutomationCacheRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).Clone(@ptrCast(*const IUIAutomationCacheRequest, self), clonedRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_get_TreeScope(self: *const T, scope: *TreeScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).get_TreeScope(@ptrCast(*const IUIAutomationCacheRequest, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_put_TreeScope(self: *const T, scope: TreeScope) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).put_TreeScope(@ptrCast(*const IUIAutomationCacheRequest, self), scope);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_get_TreeFilter(self: *const T, filter: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).get_TreeFilter(@ptrCast(*const IUIAutomationCacheRequest, self), filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_put_TreeFilter(self: *const T, filter: *IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).put_TreeFilter(@ptrCast(*const IUIAutomationCacheRequest, self), filter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_get_AutomationElementMode(self: *const T, mode: *AutomationElementMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).get_AutomationElementMode(@ptrCast(*const IUIAutomationCacheRequest, self), mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCacheRequest_put_AutomationElementMode(self: *const T, mode: AutomationElementMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCacheRequest.VTable, self.vtable).put_AutomationElementMode(@ptrCast(*const IUIAutomationCacheRequest, self), mode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTreeWalker_Value = @import("../zig.zig").Guid.initString("4042C624-389C-4AFC-A630-9DF854A541FC");
pub const IID_IUIAutomationTreeWalker = &IID_IUIAutomationTreeWalker_Value;
pub const IUIAutomationTreeWalker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParentElement: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            parent: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstChildElement: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            first: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastChildElement: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            last: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSiblingElement: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            next: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreviousSiblingElement: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            previous: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NormalizeElement: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            normalized: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentElementBuildCache: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            cacheRequest: *IUIAutomationCacheRequest,
            parent: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstChildElementBuildCache: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            cacheRequest: *IUIAutomationCacheRequest,
            first: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastChildElementBuildCache: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            cacheRequest: *IUIAutomationCacheRequest,
            last: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSiblingElementBuildCache: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            cacheRequest: *IUIAutomationCacheRequest,
            next: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreviousSiblingElementBuildCache: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            cacheRequest: *IUIAutomationCacheRequest,
            previous: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NormalizeElementBuildCache: fn(
            self: *const IUIAutomationTreeWalker,
            element: *IUIAutomationElement,
            cacheRequest: *IUIAutomationCacheRequest,
            normalized: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Condition: fn(
            self: *const IUIAutomationTreeWalker,
            condition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetParentElement(self: *const T, element: *IUIAutomationElement, parent: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetParentElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetFirstChildElement(self: *const T, element: *IUIAutomationElement, first: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetFirstChildElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, first);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetLastChildElement(self: *const T, element: *IUIAutomationElement, last: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetLastChildElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, last);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetNextSiblingElement(self: *const T, element: *IUIAutomationElement, next: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetNextSiblingElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, next);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetPreviousSiblingElement(self: *const T, element: *IUIAutomationElement, previous: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetPreviousSiblingElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, previous);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_NormalizeElement(self: *const T, element: *IUIAutomationElement, normalized: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).NormalizeElement(@ptrCast(*const IUIAutomationTreeWalker, self), element, normalized);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetParentElementBuildCache(self: *const T, element: *IUIAutomationElement, cacheRequest: *IUIAutomationCacheRequest, parent: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetParentElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetFirstChildElementBuildCache(self: *const T, element: *IUIAutomationElement, cacheRequest: *IUIAutomationCacheRequest, first: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetFirstChildElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, first);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetLastChildElementBuildCache(self: *const T, element: *IUIAutomationElement, cacheRequest: *IUIAutomationCacheRequest, last: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetLastChildElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, last);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetNextSiblingElementBuildCache(self: *const T, element: *IUIAutomationElement, cacheRequest: *IUIAutomationCacheRequest, next: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetNextSiblingElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, next);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_GetPreviousSiblingElementBuildCache(self: *const T, element: *IUIAutomationElement, cacheRequest: *IUIAutomationCacheRequest, previous: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).GetPreviousSiblingElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, previous);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_NormalizeElementBuildCache(self: *const T, element: *IUIAutomationElement, cacheRequest: *IUIAutomationCacheRequest, normalized: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).NormalizeElementBuildCache(@ptrCast(*const IUIAutomationTreeWalker, self), element, cacheRequest, normalized);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTreeWalker_get_Condition(self: *const T, condition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTreeWalker.VTable, self.vtable).get_Condition(@ptrCast(*const IUIAutomationTreeWalker, self), condition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationEventHandler_Value = @import("../zig.zig").Guid.initString("146C3C17-F12E-4E22-8C27-F894B9B79C69");
pub const IID_IUIAutomationEventHandler = &IID_IUIAutomationEventHandler_Value;
pub const IUIAutomationEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleAutomationEvent: fn(
            self: *const IUIAutomationEventHandler,
            sender: *IUIAutomationElement,
            eventId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandler_HandleAutomationEvent(self: *const T, sender: *IUIAutomationElement, eventId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandler.VTable, self.vtable).HandleAutomationEvent(@ptrCast(*const IUIAutomationEventHandler, self), sender, eventId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationPropertyChangedEventHandler_Value = @import("../zig.zig").Guid.initString("40CD37D4-C756-4B0C-8C6F-BDDFEEB13B50");
pub const IID_IUIAutomationPropertyChangedEventHandler = &IID_IUIAutomationPropertyChangedEventHandler_Value;
pub const IUIAutomationPropertyChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandlePropertyChangedEvent: fn(
            self: *const IUIAutomationPropertyChangedEventHandler,
            sender: *IUIAutomationElement,
            propertyId: i32,
            newValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationPropertyChangedEventHandler_HandlePropertyChangedEvent(self: *const T, sender: *IUIAutomationElement, propertyId: i32, newValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationPropertyChangedEventHandler.VTable, self.vtable).HandlePropertyChangedEvent(@ptrCast(*const IUIAutomationPropertyChangedEventHandler, self), sender, propertyId, newValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationStructureChangedEventHandler_Value = @import("../zig.zig").Guid.initString("E81D1B4E-11C5-42F8-9754-E7036C79F054");
pub const IID_IUIAutomationStructureChangedEventHandler = &IID_IUIAutomationStructureChangedEventHandler_Value;
pub const IUIAutomationStructureChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleStructureChangedEvent: fn(
            self: *const IUIAutomationStructureChangedEventHandler,
            sender: *IUIAutomationElement,
            changeType: StructureChangeType,
            runtimeId: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStructureChangedEventHandler_HandleStructureChangedEvent(self: *const T, sender: *IUIAutomationElement, changeType: StructureChangeType, runtimeId: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStructureChangedEventHandler.VTable, self.vtable).HandleStructureChangedEvent(@ptrCast(*const IUIAutomationStructureChangedEventHandler, self), sender, changeType, runtimeId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationFocusChangedEventHandler_Value = @import("../zig.zig").Guid.initString("C270F6B5-5C69-4290-9745-7A7F97169468");
pub const IID_IUIAutomationFocusChangedEventHandler = &IID_IUIAutomationFocusChangedEventHandler_Value;
pub const IUIAutomationFocusChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleFocusChangedEvent: fn(
            self: *const IUIAutomationFocusChangedEventHandler,
            sender: *IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationFocusChangedEventHandler_HandleFocusChangedEvent(self: *const T, sender: *IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationFocusChangedEventHandler.VTable, self.vtable).HandleFocusChangedEvent(@ptrCast(*const IUIAutomationFocusChangedEventHandler, self), sender);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTextEditTextChangedEventHandler_Value = @import("../zig.zig").Guid.initString("92FAA680-E704-4156-931A-E32D5BB38F3F");
pub const IID_IUIAutomationTextEditTextChangedEventHandler = &IID_IUIAutomationTextEditTextChangedEventHandler_Value;
pub const IUIAutomationTextEditTextChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleTextEditTextChangedEvent: fn(
            self: *const IUIAutomationTextEditTextChangedEventHandler,
            sender: *IUIAutomationElement,
            textEditChangeType: TextEditChangeType,
            eventStrings: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextEditTextChangedEventHandler_HandleTextEditTextChangedEvent(self: *const T, sender: *IUIAutomationElement, textEditChangeType: TextEditChangeType, eventStrings: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextEditTextChangedEventHandler.VTable, self.vtable).HandleTextEditTextChangedEvent(@ptrCast(*const IUIAutomationTextEditTextChangedEventHandler, self), sender, textEditChangeType, eventStrings);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationChangesEventHandler_Value = @import("../zig.zig").Guid.initString("58EDCA55-2C3E-4980-B1B9-56C17F27A2A0");
pub const IID_IUIAutomationChangesEventHandler = &IID_IUIAutomationChangesEventHandler_Value;
pub const IUIAutomationChangesEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleChangesEvent: fn(
            self: *const IUIAutomationChangesEventHandler,
            sender: *IUIAutomationElement,
            uiaChanges: [*]UiaChangeInfo,
            changesCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationChangesEventHandler_HandleChangesEvent(self: *const T, sender: *IUIAutomationElement, uiaChanges: [*]UiaChangeInfo, changesCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationChangesEventHandler.VTable, self.vtable).HandleChangesEvent(@ptrCast(*const IUIAutomationChangesEventHandler, self), sender, uiaChanges, changesCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationNotificationEventHandler_Value = @import("../zig.zig").Guid.initString("C7CB2637-E6C2-4D0C-85DE-4948C02175C7");
pub const IID_IUIAutomationNotificationEventHandler = &IID_IUIAutomationNotificationEventHandler_Value;
pub const IUIAutomationNotificationEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleNotificationEvent: fn(
            self: *const IUIAutomationNotificationEventHandler,
            sender: *IUIAutomationElement,
            notificationKind: NotificationKind,
            notificationProcessing: NotificationProcessing,
            displayString: BSTR,
            activityId: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationNotificationEventHandler_HandleNotificationEvent(self: *const T, sender: *IUIAutomationElement, notificationKind: NotificationKind, notificationProcessing: NotificationProcessing, displayString: BSTR, activityId: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationNotificationEventHandler.VTable, self.vtable).HandleNotificationEvent(@ptrCast(*const IUIAutomationNotificationEventHandler, self), sender, notificationKind, notificationProcessing, displayString, activityId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationInvokePattern_Value = @import("../zig.zig").Guid.initString("FB377FBE-8EA6-46D5-9C73-6499642D3059");
pub const IID_IUIAutomationInvokePattern = &IID_IUIAutomationInvokePattern_Value;
pub const IUIAutomationInvokePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: fn(
            self: *const IUIAutomationInvokePattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationInvokePattern_Invoke(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationInvokePattern.VTable, self.vtable).Invoke(@ptrCast(*const IUIAutomationInvokePattern, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationDockPattern_Value = @import("../zig.zig").Guid.initString("FDE5EF97-1464-48F6-90BF-43D0948E86EC");
pub const IID_IUIAutomationDockPattern = &IID_IUIAutomationDockPattern_Value;
pub const IUIAutomationDockPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDockPosition: fn(
            self: *const IUIAutomationDockPattern,
            dockPos: DockPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentDockPosition: fn(
            self: *const IUIAutomationDockPattern,
            retVal: *DockPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedDockPosition: fn(
            self: *const IUIAutomationDockPattern,
            retVal: *DockPosition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDockPattern_SetDockPosition(self: *const T, dockPos: DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDockPattern.VTable, self.vtable).SetDockPosition(@ptrCast(*const IUIAutomationDockPattern, self), dockPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDockPattern_get_CurrentDockPosition(self: *const T, retVal: *DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDockPattern.VTable, self.vtable).get_CurrentDockPosition(@ptrCast(*const IUIAutomationDockPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDockPattern_get_CachedDockPosition(self: *const T, retVal: *DockPosition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDockPattern.VTable, self.vtable).get_CachedDockPosition(@ptrCast(*const IUIAutomationDockPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationExpandCollapsePattern_Value = @import("../zig.zig").Guid.initString("619BE086-1F4E-4EE4-BAFA-210128738730");
pub const IID_IUIAutomationExpandCollapsePattern = &IID_IUIAutomationExpandCollapsePattern_Value;
pub const IUIAutomationExpandCollapsePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Expand: fn(
            self: *const IUIAutomationExpandCollapsePattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Collapse: fn(
            self: *const IUIAutomationExpandCollapsePattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentExpandCollapseState: fn(
            self: *const IUIAutomationExpandCollapsePattern,
            retVal: *ExpandCollapseState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedExpandCollapseState: fn(
            self: *const IUIAutomationExpandCollapsePattern,
            retVal: *ExpandCollapseState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationExpandCollapsePattern_Expand(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationExpandCollapsePattern.VTable, self.vtable).Expand(@ptrCast(*const IUIAutomationExpandCollapsePattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationExpandCollapsePattern_Collapse(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationExpandCollapsePattern.VTable, self.vtable).Collapse(@ptrCast(*const IUIAutomationExpandCollapsePattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationExpandCollapsePattern_get_CurrentExpandCollapseState(self: *const T, retVal: *ExpandCollapseState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationExpandCollapsePattern.VTable, self.vtable).get_CurrentExpandCollapseState(@ptrCast(*const IUIAutomationExpandCollapsePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationExpandCollapsePattern_get_CachedExpandCollapseState(self: *const T, retVal: *ExpandCollapseState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationExpandCollapsePattern.VTable, self.vtable).get_CachedExpandCollapseState(@ptrCast(*const IUIAutomationExpandCollapsePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationGridPattern_Value = @import("../zig.zig").Guid.initString("414C3CDC-856B-4F5B-8538-3131C6302550");
pub const IID_IUIAutomationGridPattern = &IID_IUIAutomationGridPattern_Value;
pub const IUIAutomationGridPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItem: fn(
            self: *const IUIAutomationGridPattern,
            row: i32,
            column: i32,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentRowCount: fn(
            self: *const IUIAutomationGridPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentColumnCount: fn(
            self: *const IUIAutomationGridPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedRowCount: fn(
            self: *const IUIAutomationGridPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedColumnCount: fn(
            self: *const IUIAutomationGridPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_GetItem(self: *const T, row: i32, column: i32, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).GetItem(@ptrCast(*const IUIAutomationGridPattern, self), row, column, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_get_CurrentRowCount(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).get_CurrentRowCount(@ptrCast(*const IUIAutomationGridPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_get_CurrentColumnCount(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).get_CurrentColumnCount(@ptrCast(*const IUIAutomationGridPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_get_CachedRowCount(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).get_CachedRowCount(@ptrCast(*const IUIAutomationGridPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridPattern_get_CachedColumnCount(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridPattern.VTable, self.vtable).get_CachedColumnCount(@ptrCast(*const IUIAutomationGridPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationGridItemPattern_Value = @import("../zig.zig").Guid.initString("78F8EF57-66C3-4E09-BD7C-E79B2004894D");
pub const IID_IUIAutomationGridItemPattern = &IID_IUIAutomationGridItemPattern_Value;
pub const IUIAutomationGridItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_CurrentContainingGrid: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentRow: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentColumn: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentRowSpan: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentColumnSpan: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedContainingGrid: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedRow: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedColumn: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedRowSpan: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedColumnSpan: fn(
            self: *const IUIAutomationGridItemPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentContainingGrid(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentContainingGrid(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentRow(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentRow(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentColumn(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentColumn(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentRowSpan(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentRowSpan(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CurrentColumnSpan(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CurrentColumnSpan(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedContainingGrid(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedContainingGrid(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedRow(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedRow(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedColumn(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedColumn(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedRowSpan(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedRowSpan(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationGridItemPattern_get_CachedColumnSpan(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationGridItemPattern.VTable, self.vtable).get_CachedColumnSpan(@ptrCast(*const IUIAutomationGridItemPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationMultipleViewPattern_Value = @import("../zig.zig").Guid.initString("8D253C91-1DC5-4BB5-B18F-ADE16FA495E8");
pub const IID_IUIAutomationMultipleViewPattern = &IID_IUIAutomationMultipleViewPattern_Value;
pub const IUIAutomationMultipleViewPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetViewName: fn(
            self: *const IUIAutomationMultipleViewPattern,
            view: i32,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentView: fn(
            self: *const IUIAutomationMultipleViewPattern,
            view: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCurrentView: fn(
            self: *const IUIAutomationMultipleViewPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSupportedViews: fn(
            self: *const IUIAutomationMultipleViewPattern,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCurrentView: fn(
            self: *const IUIAutomationMultipleViewPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedSupportedViews: fn(
            self: *const IUIAutomationMultipleViewPattern,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_GetViewName(self: *const T, view: i32, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).GetViewName(@ptrCast(*const IUIAutomationMultipleViewPattern, self), view, name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_SetCurrentView(self: *const T, view: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).SetCurrentView(@ptrCast(*const IUIAutomationMultipleViewPattern, self), view);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_get_CurrentCurrentView(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).get_CurrentCurrentView(@ptrCast(*const IUIAutomationMultipleViewPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_GetCurrentSupportedViews(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).GetCurrentSupportedViews(@ptrCast(*const IUIAutomationMultipleViewPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_get_CachedCurrentView(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).get_CachedCurrentView(@ptrCast(*const IUIAutomationMultipleViewPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationMultipleViewPattern_GetCachedSupportedViews(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationMultipleViewPattern.VTable, self.vtable).GetCachedSupportedViews(@ptrCast(*const IUIAutomationMultipleViewPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationObjectModelPattern_Value = @import("../zig.zig").Guid.initString("71C284B3-C14D-4D14-981E-19751B0D756D");
pub const IID_IUIAutomationObjectModelPattern = &IID_IUIAutomationObjectModelPattern_Value;
pub const IUIAutomationObjectModelPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUnderlyingObjectModel: fn(
            self: *const IUIAutomationObjectModelPattern,
            retVal: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationObjectModelPattern_GetUnderlyingObjectModel(self: *const T, retVal: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationObjectModelPattern.VTable, self.vtable).GetUnderlyingObjectModel(@ptrCast(*const IUIAutomationObjectModelPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationRangeValuePattern_Value = @import("../zig.zig").Guid.initString("59213F4F-7346-49E5-B120-80555987A148");
pub const IID_IUIAutomationRangeValuePattern = &IID_IUIAutomationRangeValuePattern_Value;
pub const IUIAutomationRangeValuePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: fn(
            self: *const IUIAutomationRangeValuePattern,
            val: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentValue: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsReadOnly: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentMaximum: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentMinimum: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentLargeChange: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentSmallChange: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedValue: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsReadOnly: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedMaximum: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedMinimum: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedLargeChange: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedSmallChange: fn(
            self: *const IUIAutomationRangeValuePattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_SetValue(self: *const T, val: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).SetValue(@ptrCast(*const IUIAutomationRangeValuePattern, self), val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentValue(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentValue(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentIsReadOnly(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentIsReadOnly(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentMaximum(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentMaximum(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentMinimum(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentMinimum(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentLargeChange(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentLargeChange(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CurrentSmallChange(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CurrentSmallChange(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedValue(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedValue(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedIsReadOnly(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedIsReadOnly(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedMaximum(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedMaximum(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedMinimum(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedMinimum(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedLargeChange(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedLargeChange(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationRangeValuePattern_get_CachedSmallChange(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationRangeValuePattern.VTable, self.vtable).get_CachedSmallChange(@ptrCast(*const IUIAutomationRangeValuePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationScrollPattern_Value = @import("../zig.zig").Guid.initString("88F4D42A-E881-459D-A77C-73BBBB7E02DC");
pub const IID_IUIAutomationScrollPattern = &IID_IUIAutomationScrollPattern_Value;
pub const IUIAutomationScrollPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Scroll: fn(
            self: *const IUIAutomationScrollPattern,
            horizontalAmount: ScrollAmount,
            verticalAmount: ScrollAmount,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScrollPercent: fn(
            self: *const IUIAutomationScrollPattern,
            horizontalPercent: f64,
            verticalPercent: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentHorizontalScrollPercent: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentVerticalScrollPercent: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentHorizontalViewSize: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentVerticalViewSize: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentHorizontallyScrollable: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentVerticallyScrollable: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedHorizontalScrollPercent: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedVerticalScrollPercent: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedHorizontalViewSize: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedVerticalViewSize: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedHorizontallyScrollable: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedVerticallyScrollable: fn(
            self: *const IUIAutomationScrollPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_Scroll(self: *const T, horizontalAmount: ScrollAmount, verticalAmount: ScrollAmount) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).Scroll(@ptrCast(*const IUIAutomationScrollPattern, self), horizontalAmount, verticalAmount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_SetScrollPercent(self: *const T, horizontalPercent: f64, verticalPercent: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).SetScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), horizontalPercent, verticalPercent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentHorizontalScrollPercent(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentHorizontalScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentVerticalScrollPercent(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentVerticalScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentHorizontalViewSize(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentHorizontalViewSize(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentVerticalViewSize(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentVerticalViewSize(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentHorizontallyScrollable(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentHorizontallyScrollable(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CurrentVerticallyScrollable(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CurrentVerticallyScrollable(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedHorizontalScrollPercent(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedHorizontalScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedVerticalScrollPercent(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedVerticalScrollPercent(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedHorizontalViewSize(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedHorizontalViewSize(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedVerticalViewSize(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedVerticalViewSize(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedHorizontallyScrollable(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedHorizontallyScrollable(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollPattern_get_CachedVerticallyScrollable(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollPattern.VTable, self.vtable).get_CachedVerticallyScrollable(@ptrCast(*const IUIAutomationScrollPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationScrollItemPattern_Value = @import("../zig.zig").Guid.initString("B488300F-D015-4F19-9C29-BB595E3645EF");
pub const IID_IUIAutomationScrollItemPattern = &IID_IUIAutomationScrollItemPattern_Value;
pub const IUIAutomationScrollItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ScrollIntoView: fn(
            self: *const IUIAutomationScrollItemPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationScrollItemPattern_ScrollIntoView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationScrollItemPattern.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IUIAutomationScrollItemPattern, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationSelectionPattern_Value = @import("../zig.zig").Guid.initString("5ED5202E-B2AC-47A6-B638-4B0BF140D78E");
pub const IID_IUIAutomationSelectionPattern = &IID_IUIAutomationSelectionPattern_Value;
pub const IUIAutomationSelectionPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentSelection: fn(
            self: *const IUIAutomationSelectionPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCanSelectMultiple: fn(
            self: *const IUIAutomationSelectionPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsSelectionRequired: fn(
            self: *const IUIAutomationSelectionPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedSelection: fn(
            self: *const IUIAutomationSelectionPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCanSelectMultiple: fn(
            self: *const IUIAutomationSelectionPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsSelectionRequired: fn(
            self: *const IUIAutomationSelectionPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_GetCurrentSelection(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).GetCurrentSelection(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_get_CurrentCanSelectMultiple(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).get_CurrentCanSelectMultiple(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_get_CurrentIsSelectionRequired(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).get_CurrentIsSelectionRequired(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_GetCachedSelection(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).GetCachedSelection(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_get_CachedCanSelectMultiple(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).get_CachedCanSelectMultiple(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern_get_CachedIsSelectionRequired(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern.VTable, self.vtable).get_CachedIsSelectionRequired(@ptrCast(*const IUIAutomationSelectionPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationSelectionPattern2_Value = @import("../zig.zig").Guid.initString("0532BFAE-C011-4E32-A343-6D642D798555");
pub const IID_IUIAutomationSelectionPattern2 = &IID_IUIAutomationSelectionPattern2_Value;
pub const IUIAutomationSelectionPattern2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationSelectionPattern.VTable,
        get_CurrentFirstSelectedItem: fn(
            self: *const IUIAutomationSelectionPattern2,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentLastSelectedItem: fn(
            self: *const IUIAutomationSelectionPattern2,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCurrentSelectedItem: fn(
            self: *const IUIAutomationSelectionPattern2,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentItemCount: fn(
            self: *const IUIAutomationSelectionPattern2,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedFirstSelectedItem: fn(
            self: *const IUIAutomationSelectionPattern2,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedLastSelectedItem: fn(
            self: *const IUIAutomationSelectionPattern2,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCurrentSelectedItem: fn(
            self: *const IUIAutomationSelectionPattern2,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedItemCount: fn(
            self: *const IUIAutomationSelectionPattern2,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationSelectionPattern.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CurrentFirstSelectedItem(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CurrentFirstSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CurrentLastSelectedItem(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CurrentLastSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CurrentCurrentSelectedItem(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CurrentCurrentSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CurrentItemCount(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CurrentItemCount(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CachedFirstSelectedItem(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CachedFirstSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CachedLastSelectedItem(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CachedLastSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CachedCurrentSelectedItem(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CachedCurrentSelectedItem(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionPattern2_get_CachedItemCount(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionPattern2.VTable, self.vtable).get_CachedItemCount(@ptrCast(*const IUIAutomationSelectionPattern2, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationSelectionItemPattern_Value = @import("../zig.zig").Guid.initString("A8EFA66A-0FDA-421A-9194-38021F3578EA");
pub const IID_IUIAutomationSelectionItemPattern = &IID_IUIAutomationSelectionItemPattern_Value;
pub const IUIAutomationSelectionItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Select: fn(
            self: *const IUIAutomationSelectionItemPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddToSelection: fn(
            self: *const IUIAutomationSelectionItemPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFromSelection: fn(
            self: *const IUIAutomationSelectionItemPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsSelected: fn(
            self: *const IUIAutomationSelectionItemPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentSelectionContainer: fn(
            self: *const IUIAutomationSelectionItemPattern,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsSelected: fn(
            self: *const IUIAutomationSelectionItemPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedSelectionContainer: fn(
            self: *const IUIAutomationSelectionItemPattern,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).Select(@ptrCast(*const IUIAutomationSelectionItemPattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_AddToSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).AddToSelection(@ptrCast(*const IUIAutomationSelectionItemPattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_RemoveFromSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).RemoveFromSelection(@ptrCast(*const IUIAutomationSelectionItemPattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_get_CurrentIsSelected(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).get_CurrentIsSelected(@ptrCast(*const IUIAutomationSelectionItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_get_CurrentSelectionContainer(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).get_CurrentSelectionContainer(@ptrCast(*const IUIAutomationSelectionItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_get_CachedIsSelected(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).get_CachedIsSelected(@ptrCast(*const IUIAutomationSelectionItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSelectionItemPattern_get_CachedSelectionContainer(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSelectionItemPattern.VTable, self.vtable).get_CachedSelectionContainer(@ptrCast(*const IUIAutomationSelectionItemPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationSynchronizedInputPattern_Value = @import("../zig.zig").Guid.initString("2233BE0B-AFB7-448B-9FDA-3B378AA5EAE1");
pub const IID_IUIAutomationSynchronizedInputPattern = &IID_IUIAutomationSynchronizedInputPattern_Value;
pub const IUIAutomationSynchronizedInputPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartListening: fn(
            self: *const IUIAutomationSynchronizedInputPattern,
            inputType: SynchronizedInputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IUIAutomationSynchronizedInputPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSynchronizedInputPattern_StartListening(self: *const T, inputType: SynchronizedInputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSynchronizedInputPattern.VTable, self.vtable).StartListening(@ptrCast(*const IUIAutomationSynchronizedInputPattern, self), inputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSynchronizedInputPattern_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSynchronizedInputPattern.VTable, self.vtable).Cancel(@ptrCast(*const IUIAutomationSynchronizedInputPattern, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTablePattern_Value = @import("../zig.zig").Guid.initString("620E691C-EA96-4710-A850-754B24CE2417");
pub const IID_IUIAutomationTablePattern = &IID_IUIAutomationTablePattern_Value;
pub const IUIAutomationTablePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentRowHeaders: fn(
            self: *const IUIAutomationTablePattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentColumnHeaders: fn(
            self: *const IUIAutomationTablePattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentRowOrColumnMajor: fn(
            self: *const IUIAutomationTablePattern,
            retVal: *RowOrColumnMajor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedRowHeaders: fn(
            self: *const IUIAutomationTablePattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedColumnHeaders: fn(
            self: *const IUIAutomationTablePattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedRowOrColumnMajor: fn(
            self: *const IUIAutomationTablePattern,
            retVal: *RowOrColumnMajor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_GetCurrentRowHeaders(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).GetCurrentRowHeaders(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_GetCurrentColumnHeaders(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).GetCurrentColumnHeaders(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_get_CurrentRowOrColumnMajor(self: *const T, retVal: *RowOrColumnMajor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).get_CurrentRowOrColumnMajor(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_GetCachedRowHeaders(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).GetCachedRowHeaders(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_GetCachedColumnHeaders(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).GetCachedColumnHeaders(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTablePattern_get_CachedRowOrColumnMajor(self: *const T, retVal: *RowOrColumnMajor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTablePattern.VTable, self.vtable).get_CachedRowOrColumnMajor(@ptrCast(*const IUIAutomationTablePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTableItemPattern_Value = @import("../zig.zig").Guid.initString("0B964EB3-EF2E-4464-9C79-61D61737A27E");
pub const IID_IUIAutomationTableItemPattern = &IID_IUIAutomationTableItemPattern_Value;
pub const IUIAutomationTableItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCurrentRowHeaderItems: fn(
            self: *const IUIAutomationTableItemPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentColumnHeaderItems: fn(
            self: *const IUIAutomationTableItemPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedRowHeaderItems: fn(
            self: *const IUIAutomationTableItemPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedColumnHeaderItems: fn(
            self: *const IUIAutomationTableItemPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTableItemPattern_GetCurrentRowHeaderItems(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTableItemPattern.VTable, self.vtable).GetCurrentRowHeaderItems(@ptrCast(*const IUIAutomationTableItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTableItemPattern_GetCurrentColumnHeaderItems(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTableItemPattern.VTable, self.vtable).GetCurrentColumnHeaderItems(@ptrCast(*const IUIAutomationTableItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTableItemPattern_GetCachedRowHeaderItems(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTableItemPattern.VTable, self.vtable).GetCachedRowHeaderItems(@ptrCast(*const IUIAutomationTableItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTableItemPattern_GetCachedColumnHeaderItems(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTableItemPattern.VTable, self.vtable).GetCachedColumnHeaderItems(@ptrCast(*const IUIAutomationTableItemPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTogglePattern_Value = @import("../zig.zig").Guid.initString("94CF8058-9B8D-4AB9-8BFD-4CD0A33C8C70");
pub const IID_IUIAutomationTogglePattern = &IID_IUIAutomationTogglePattern_Value;
pub const IUIAutomationTogglePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Toggle: fn(
            self: *const IUIAutomationTogglePattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentToggleState: fn(
            self: *const IUIAutomationTogglePattern,
            retVal: *ToggleState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedToggleState: fn(
            self: *const IUIAutomationTogglePattern,
            retVal: *ToggleState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTogglePattern_Toggle(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTogglePattern.VTable, self.vtable).Toggle(@ptrCast(*const IUIAutomationTogglePattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTogglePattern_get_CurrentToggleState(self: *const T, retVal: *ToggleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTogglePattern.VTable, self.vtable).get_CurrentToggleState(@ptrCast(*const IUIAutomationTogglePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTogglePattern_get_CachedToggleState(self: *const T, retVal: *ToggleState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTogglePattern.VTable, self.vtable).get_CachedToggleState(@ptrCast(*const IUIAutomationTogglePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTransformPattern_Value = @import("../zig.zig").Guid.initString("A9B55844-A55D-4EF0-926D-569C16FF89BB");
pub const IID_IUIAutomationTransformPattern = &IID_IUIAutomationTransformPattern_Value;
pub const IUIAutomationTransformPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Move: fn(
            self: *const IUIAutomationTransformPattern,
            x: f64,
            y: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resize: fn(
            self: *const IUIAutomationTransformPattern,
            width: f64,
            height: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Rotate: fn(
            self: *const IUIAutomationTransformPattern,
            degrees: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCanMove: fn(
            self: *const IUIAutomationTransformPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCanResize: fn(
            self: *const IUIAutomationTransformPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCanRotate: fn(
            self: *const IUIAutomationTransformPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCanMove: fn(
            self: *const IUIAutomationTransformPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCanResize: fn(
            self: *const IUIAutomationTransformPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCanRotate: fn(
            self: *const IUIAutomationTransformPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_Move(self: *const T, x: f64, y: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).Move(@ptrCast(*const IUIAutomationTransformPattern, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_Resize(self: *const T, width: f64, height: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).Resize(@ptrCast(*const IUIAutomationTransformPattern, self), width, height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_Rotate(self: *const T, degrees: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).Rotate(@ptrCast(*const IUIAutomationTransformPattern, self), degrees);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CurrentCanMove(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CurrentCanMove(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CurrentCanResize(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CurrentCanResize(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CurrentCanRotate(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CurrentCanRotate(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CachedCanMove(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CachedCanMove(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CachedCanResize(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CachedCanResize(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern_get_CachedCanRotate(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern.VTable, self.vtable).get_CachedCanRotate(@ptrCast(*const IUIAutomationTransformPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationValuePattern_Value = @import("../zig.zig").Guid.initString("A94CD8B1-0844-4CD6-9D2D-640537AB39E9");
pub const IID_IUIAutomationValuePattern = &IID_IUIAutomationValuePattern_Value;
pub const IUIAutomationValuePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetValue: fn(
            self: *const IUIAutomationValuePattern,
            val: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentValue: fn(
            self: *const IUIAutomationValuePattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsReadOnly: fn(
            self: *const IUIAutomationValuePattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedValue: fn(
            self: *const IUIAutomationValuePattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsReadOnly: fn(
            self: *const IUIAutomationValuePattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_SetValue(self: *const T, val: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).SetValue(@ptrCast(*const IUIAutomationValuePattern, self), val);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_get_CurrentValue(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).get_CurrentValue(@ptrCast(*const IUIAutomationValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_get_CurrentIsReadOnly(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).get_CurrentIsReadOnly(@ptrCast(*const IUIAutomationValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_get_CachedValue(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).get_CachedValue(@ptrCast(*const IUIAutomationValuePattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationValuePattern_get_CachedIsReadOnly(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationValuePattern.VTable, self.vtable).get_CachedIsReadOnly(@ptrCast(*const IUIAutomationValuePattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationWindowPattern_Value = @import("../zig.zig").Guid.initString("0FAEF453-9208-43EF-BBB2-3B485177864F");
pub const IID_IUIAutomationWindowPattern = &IID_IUIAutomationWindowPattern_Value;
pub const IUIAutomationWindowPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Close: fn(
            self: *const IUIAutomationWindowPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForInputIdle: fn(
            self: *const IUIAutomationWindowPattern,
            milliseconds: i32,
            success: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWindowVisualState: fn(
            self: *const IUIAutomationWindowPattern,
            state: WindowVisualState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCanMaximize: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCanMinimize: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsModal: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsTopmost: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentWindowVisualState: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *WindowVisualState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentWindowInteractionState: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *WindowInteractionState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCanMaximize: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCanMinimize: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsModal: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsTopmost: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedWindowVisualState: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *WindowVisualState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedWindowInteractionState: fn(
            self: *const IUIAutomationWindowPattern,
            retVal: *WindowInteractionState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).Close(@ptrCast(*const IUIAutomationWindowPattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_WaitForInputIdle(self: *const T, milliseconds: i32, success: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).WaitForInputIdle(@ptrCast(*const IUIAutomationWindowPattern, self), milliseconds, success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_SetWindowVisualState(self: *const T, state: WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).SetWindowVisualState(@ptrCast(*const IUIAutomationWindowPattern, self), state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentCanMaximize(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentCanMaximize(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentCanMinimize(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentCanMinimize(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentIsModal(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentIsModal(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentIsTopmost(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentIsTopmost(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentWindowVisualState(self: *const T, retVal: *WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentWindowVisualState(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CurrentWindowInteractionState(self: *const T, retVal: *WindowInteractionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CurrentWindowInteractionState(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedCanMaximize(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedCanMaximize(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedCanMinimize(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedCanMinimize(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedIsModal(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedIsModal(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedIsTopmost(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedIsTopmost(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedWindowVisualState(self: *const T, retVal: *WindowVisualState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedWindowVisualState(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationWindowPattern_get_CachedWindowInteractionState(self: *const T, retVal: *WindowInteractionState) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationWindowPattern.VTable, self.vtable).get_CachedWindowInteractionState(@ptrCast(*const IUIAutomationWindowPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTextRange_Value = @import("../zig.zig").Guid.initString("A543CC6A-F4AE-494B-8239-C814481187A8");
pub const IID_IUIAutomationTextRange = &IID_IUIAutomationTextRange_Value;
pub const IUIAutomationTextRange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Clone: fn(
            self: *const IUIAutomationTextRange,
            clonedRange: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Compare: fn(
            self: *const IUIAutomationTextRange,
            range: *IUIAutomationTextRange,
            areSame: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareEndpoints: fn(
            self: *const IUIAutomationTextRange,
            srcEndPoint: TextPatternRangeEndpoint,
            range: *IUIAutomationTextRange,
            targetEndPoint: TextPatternRangeEndpoint,
            compValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExpandToEnclosingUnit: fn(
            self: *const IUIAutomationTextRange,
            textUnit: TextUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindAttribute: fn(
            self: *const IUIAutomationTextRange,
            attr: i32,
            val: VARIANT,
            backward: BOOL,
            found: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextA: fn(
            self: *const IUIAutomationTextRange,
            text: BSTR,
            backward: BOOL,
            ignoreCase: BOOL,
            found: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeValue: fn(
            self: *const IUIAutomationTextRange,
            attr: i32,
            value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBoundingRectangles: fn(
            self: *const IUIAutomationTextRange,
            boundingRects: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnclosingElement: fn(
            self: *const IUIAutomationTextRange,
            enclosingElement: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const IUIAutomationTextRange,
            maxLength: i32,
            text: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const IUIAutomationTextRange,
            unit: TextUnit,
            count: i32,
            moved: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndpointByUnit: fn(
            self: *const IUIAutomationTextRange,
            endpoint: TextPatternRangeEndpoint,
            unit: TextUnit,
            count: i32,
            moved: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndpointByRange: fn(
            self: *const IUIAutomationTextRange,
            srcEndPoint: TextPatternRangeEndpoint,
            range: *IUIAutomationTextRange,
            targetEndPoint: TextPatternRangeEndpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddToSelection: fn(
            self: *const IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFromSelection: fn(
            self: *const IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const IUIAutomationTextRange,
            alignToTop: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChildren: fn(
            self: *const IUIAutomationTextRange,
            children: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_Clone(self: *const T, clonedRange: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).Clone(@ptrCast(*const IUIAutomationTextRange, self), clonedRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_Compare(self: *const T, range: *IUIAutomationTextRange, areSame: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).Compare(@ptrCast(*const IUIAutomationTextRange, self), range, areSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_CompareEndpoints(self: *const T, srcEndPoint: TextPatternRangeEndpoint, range: *IUIAutomationTextRange, targetEndPoint: TextPatternRangeEndpoint, compValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).CompareEndpoints(@ptrCast(*const IUIAutomationTextRange, self), srcEndPoint, range, targetEndPoint, compValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_ExpandToEnclosingUnit(self: *const T, textUnit: TextUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).ExpandToEnclosingUnit(@ptrCast(*const IUIAutomationTextRange, self), textUnit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_FindAttribute(self: *const T, attr: i32, val: VARIANT, backward: BOOL, found: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).FindAttribute(@ptrCast(*const IUIAutomationTextRange, self), attr, val, backward, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_FindTextA(self: *const T, text: BSTR, backward: BOOL, ignoreCase: BOOL, found: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).FindTextA(@ptrCast(*const IUIAutomationTextRange, self), text, backward, ignoreCase, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetAttributeValue(self: *const T, attr: i32, value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetAttributeValue(@ptrCast(*const IUIAutomationTextRange, self), attr, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetBoundingRectangles(self: *const T, boundingRects: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetBoundingRectangles(@ptrCast(*const IUIAutomationTextRange, self), boundingRects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetEnclosingElement(self: *const T, enclosingElement: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetEnclosingElement(@ptrCast(*const IUIAutomationTextRange, self), enclosingElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetText(self: *const T, maxLength: i32, text: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetText(@ptrCast(*const IUIAutomationTextRange, self), maxLength, text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_Move(self: *const T, unit: TextUnit, count: i32, moved: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).Move(@ptrCast(*const IUIAutomationTextRange, self), unit, count, moved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_MoveEndpointByUnit(self: *const T, endpoint: TextPatternRangeEndpoint, unit: TextUnit, count: i32, moved: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).MoveEndpointByUnit(@ptrCast(*const IUIAutomationTextRange, self), endpoint, unit, count, moved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_MoveEndpointByRange(self: *const T, srcEndPoint: TextPatternRangeEndpoint, range: *IUIAutomationTextRange, targetEndPoint: TextPatternRangeEndpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).MoveEndpointByRange(@ptrCast(*const IUIAutomationTextRange, self), srcEndPoint, range, targetEndPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).Select(@ptrCast(*const IUIAutomationTextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_AddToSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).AddToSelection(@ptrCast(*const IUIAutomationTextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_RemoveFromSelection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).RemoveFromSelection(@ptrCast(*const IUIAutomationTextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_ScrollIntoView(self: *const T, alignToTop: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IUIAutomationTextRange, self), alignToTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange_GetChildren(self: *const T, children: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange.VTable, self.vtable).GetChildren(@ptrCast(*const IUIAutomationTextRange, self), children);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTextRange2_Value = @import("../zig.zig").Guid.initString("BB9B40E0-5E04-46BD-9BE0-4B601B9AFAD4");
pub const IID_IUIAutomationTextRange2 = &IID_IUIAutomationTextRange2_Value;
pub const IUIAutomationTextRange2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTextRange.VTable,
        ShowContextMenu: fn(
            self: *const IUIAutomationTextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTextRange.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange2_ShowContextMenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange2.VTable, self.vtable).ShowContextMenu(@ptrCast(*const IUIAutomationTextRange2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTextRange3_Value = @import("../zig.zig").Guid.initString("6A315D69-5512-4C2E-85F0-53FCE6DD4BC2");
pub const IID_IUIAutomationTextRange3 = &IID_IUIAutomationTextRange3_Value;
pub const IUIAutomationTextRange3 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTextRange2.VTable,
        GetEnclosingElementBuildCache: fn(
            self: *const IUIAutomationTextRange3,
            cacheRequest: *IUIAutomationCacheRequest,
            enclosingElement: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChildrenBuildCache: fn(
            self: *const IUIAutomationTextRange3,
            cacheRequest: *IUIAutomationCacheRequest,
            children: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeValues: fn(
            self: *const IUIAutomationTextRange3,
            attributeIds: [*]const i32,
            attributeIdCount: i32,
            attributeValues: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTextRange2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange3_GetEnclosingElementBuildCache(self: *const T, cacheRequest: *IUIAutomationCacheRequest, enclosingElement: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange3.VTable, self.vtable).GetEnclosingElementBuildCache(@ptrCast(*const IUIAutomationTextRange3, self), cacheRequest, enclosingElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange3_GetChildrenBuildCache(self: *const T, cacheRequest: *IUIAutomationCacheRequest, children: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange3.VTable, self.vtable).GetChildrenBuildCache(@ptrCast(*const IUIAutomationTextRange3, self), cacheRequest, children);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRange3_GetAttributeValues(self: *const T, attributeIds: [*]const i32, attributeIdCount: i32, attributeValues: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRange3.VTable, self.vtable).GetAttributeValues(@ptrCast(*const IUIAutomationTextRange3, self), attributeIds, attributeIdCount, attributeValues);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTextRangeArray_Value = @import("../zig.zig").Guid.initString("CE4AE76A-E717-4C98-81EA-47371D028EB6");
pub const IID_IUIAutomationTextRangeArray = &IID_IUIAutomationTextRangeArray_Value;
pub const IUIAutomationTextRangeArray = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_Length: fn(
            self: *const IUIAutomationTextRangeArray,
            length: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElement: fn(
            self: *const IUIAutomationTextRangeArray,
            index: i32,
            element: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRangeArray_get_Length(self: *const T, length: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRangeArray.VTable, self.vtable).get_Length(@ptrCast(*const IUIAutomationTextRangeArray, self), length);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextRangeArray_GetElement(self: *const T, index: i32, element: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextRangeArray.VTable, self.vtable).GetElement(@ptrCast(*const IUIAutomationTextRangeArray, self), index, element);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTextPattern_Value = @import("../zig.zig").Guid.initString("32EBA289-3583-42C9-9C59-3B6D9A1E9B6A");
pub const IID_IUIAutomationTextPattern = &IID_IUIAutomationTextPattern_Value;
pub const IUIAutomationTextPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RangeFromPoint: fn(
            self: *const IUIAutomationTextPattern,
            pt: POINT,
            range: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromChild: fn(
            self: *const IUIAutomationTextPattern,
            child: *IUIAutomationElement,
            range: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const IUIAutomationTextPattern,
            ranges: **IUIAutomationTextRangeArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVisibleRanges: fn(
            self: *const IUIAutomationTextPattern,
            ranges: **IUIAutomationTextRangeArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DocumentRange: fn(
            self: *const IUIAutomationTextPattern,
            range: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_SupportedTextSelection: fn(
            self: *const IUIAutomationTextPattern,
            supportedTextSelection: *SupportedTextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_RangeFromPoint(self: *const T, pt: POINT, range: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).RangeFromPoint(@ptrCast(*const IUIAutomationTextPattern, self), pt, range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_RangeFromChild(self: *const T, child: *IUIAutomationElement, range: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).RangeFromChild(@ptrCast(*const IUIAutomationTextPattern, self), child, range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_GetSelection(self: *const T, ranges: **IUIAutomationTextRangeArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).GetSelection(@ptrCast(*const IUIAutomationTextPattern, self), ranges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_GetVisibleRanges(self: *const T, ranges: **IUIAutomationTextRangeArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).GetVisibleRanges(@ptrCast(*const IUIAutomationTextPattern, self), ranges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_get_DocumentRange(self: *const T, range: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).get_DocumentRange(@ptrCast(*const IUIAutomationTextPattern, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern_get_SupportedTextSelection(self: *const T, supportedTextSelection: *SupportedTextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern.VTable, self.vtable).get_SupportedTextSelection(@ptrCast(*const IUIAutomationTextPattern, self), supportedTextSelection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTextPattern2_Value = @import("../zig.zig").Guid.initString("506A921A-FCC9-409F-B23B-37EB74106872");
pub const IID_IUIAutomationTextPattern2 = &IID_IUIAutomationTextPattern2_Value;
pub const IUIAutomationTextPattern2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTextPattern.VTable,
        RangeFromAnnotation: fn(
            self: *const IUIAutomationTextPattern2,
            annotation: *IUIAutomationElement,
            range: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaretRange: fn(
            self: *const IUIAutomationTextPattern2,
            isActive: *BOOL,
            range: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTextPattern.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern2_RangeFromAnnotation(self: *const T, annotation: *IUIAutomationElement, range: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern2.VTable, self.vtable).RangeFromAnnotation(@ptrCast(*const IUIAutomationTextPattern2, self), annotation, range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextPattern2_GetCaretRange(self: *const T, isActive: *BOOL, range: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextPattern2.VTable, self.vtable).GetCaretRange(@ptrCast(*const IUIAutomationTextPattern2, self), isActive, range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTextEditPattern_Value = @import("../zig.zig").Guid.initString("17E21576-996C-4870-99D9-BFF323380C06");
pub const IID_IUIAutomationTextEditPattern = &IID_IUIAutomationTextEditPattern_Value;
pub const IUIAutomationTextEditPattern = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTextPattern.VTable,
        GetActiveComposition: fn(
            self: *const IUIAutomationTextEditPattern,
            range: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConversionTarget: fn(
            self: *const IUIAutomationTextEditPattern,
            range: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTextPattern.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextEditPattern_GetActiveComposition(self: *const T, range: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextEditPattern.VTable, self.vtable).GetActiveComposition(@ptrCast(*const IUIAutomationTextEditPattern, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextEditPattern_GetConversionTarget(self: *const T, range: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextEditPattern.VTable, self.vtable).GetConversionTarget(@ptrCast(*const IUIAutomationTextEditPattern, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationCustomNavigationPattern_Value = @import("../zig.zig").Guid.initString("01EA217A-1766-47ED-A6CC-ACF492854B1F");
pub const IID_IUIAutomationCustomNavigationPattern = &IID_IUIAutomationCustomNavigationPattern_Value;
pub const IUIAutomationCustomNavigationPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Navigate: fn(
            self: *const IUIAutomationCustomNavigationPattern,
            direction: NavigateDirection,
            pRetVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationCustomNavigationPattern_Navigate(self: *const T, direction: NavigateDirection, pRetVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationCustomNavigationPattern.VTable, self.vtable).Navigate(@ptrCast(*const IUIAutomationCustomNavigationPattern, self), direction, pRetVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationActiveTextPositionChangedEventHandler_Value = @import("../zig.zig").Guid.initString("F97933B0-8DAE-4496-8997-5BA015FE0D82");
pub const IID_IUIAutomationActiveTextPositionChangedEventHandler = &IID_IUIAutomationActiveTextPositionChangedEventHandler_Value;
pub const IUIAutomationActiveTextPositionChangedEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        HandleActiveTextPositionChangedEvent: fn(
            self: *const IUIAutomationActiveTextPositionChangedEventHandler,
            sender: *IUIAutomationElement,
            range: *IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationActiveTextPositionChangedEventHandler_HandleActiveTextPositionChangedEvent(self: *const T, sender: *IUIAutomationElement, range: *IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationActiveTextPositionChangedEventHandler.VTable, self.vtable).HandleActiveTextPositionChangedEvent(@ptrCast(*const IUIAutomationActiveTextPositionChangedEventHandler, self), sender, range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationLegacyIAccessiblePattern_Value = @import("../zig.zig").Guid.initString("828055AD-355B-4435-86D5-3B51C14A9B1B");
pub const IID_IUIAutomationLegacyIAccessiblePattern = &IID_IUIAutomationLegacyIAccessiblePattern_Value;
pub const IUIAutomationLegacyIAccessiblePattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Select: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            flagsSelect: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DoDefaultAction: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            szValue: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentChildId: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentName: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentValue: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentDescription: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszDescription: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentRole: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pdwRole: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentState: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pdwState: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentHelp: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszHelp: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentKeyboardShortcut: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszKeyboardShortcut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSelection: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pvarSelectedChildren: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentDefaultAction: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszDefaultAction: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedChildId: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pRetVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedName: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedValue: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedDescription: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszDescription: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedRole: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pdwRole: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedState: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pdwState: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedHelp: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszHelp: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedKeyboardShortcut: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszKeyboardShortcut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedSelection: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pvarSelectedChildren: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedDefaultAction: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            pszDefaultAction: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIAccessible: fn(
            self: *const IUIAutomationLegacyIAccessiblePattern,
            ppAccessible: **IAccessible,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_Select(self: *const T, flagsSelect: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).Select(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), flagsSelect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_DoDefaultAction(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).DoDefaultAction(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_SetValue(self: *const T, szValue: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).SetValue(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), szValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentChildId(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentChildId(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentName(self: *const T, pszName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentName(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentValue(self: *const T, pszValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentValue(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentDescription(self: *const T, pszDescription: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentDescription(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentRole(self: *const T, pdwRole: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentRole(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pdwRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentState(self: *const T, pdwState: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentState(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentHelp(self: *const T, pszHelp: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentHelp(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszHelp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentKeyboardShortcut(self: *const T, pszKeyboardShortcut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentKeyboardShortcut(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszKeyboardShortcut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_GetCurrentSelection(self: *const T, pvarSelectedChildren: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).GetCurrentSelection(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pvarSelectedChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CurrentDefaultAction(self: *const T, pszDefaultAction: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CurrentDefaultAction(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszDefaultAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedChildId(self: *const T, pRetVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedChildId(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pRetVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedName(self: *const T, pszName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedName(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedValue(self: *const T, pszValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedValue(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedDescription(self: *const T, pszDescription: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedDescription(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedRole(self: *const T, pdwRole: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedRole(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pdwRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedState(self: *const T, pdwState: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedState(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pdwState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedHelp(self: *const T, pszHelp: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedHelp(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszHelp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedKeyboardShortcut(self: *const T, pszKeyboardShortcut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedKeyboardShortcut(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszKeyboardShortcut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_GetCachedSelection(self: *const T, pvarSelectedChildren: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).GetCachedSelection(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pvarSelectedChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_get_CachedDefaultAction(self: *const T, pszDefaultAction: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).get_CachedDefaultAction(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), pszDefaultAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationLegacyIAccessiblePattern_GetIAccessible(self: *const T, ppAccessible: **IAccessible) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationLegacyIAccessiblePattern.VTable, self.vtable).GetIAccessible(@ptrCast(*const IUIAutomationLegacyIAccessiblePattern, self), ppAccessible);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationItemContainerPattern_Value = @import("../zig.zig").Guid.initString("C690FDB2-27A8-423C-812D-429773C9084E");
pub const IID_IUIAutomationItemContainerPattern = &IID_IUIAutomationItemContainerPattern_Value;
pub const IUIAutomationItemContainerPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindItemByProperty: fn(
            self: *const IUIAutomationItemContainerPattern,
            pStartAfter: *IUIAutomationElement,
            propertyId: i32,
            value: VARIANT,
            pFound: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationItemContainerPattern_FindItemByProperty(self: *const T, pStartAfter: *IUIAutomationElement, propertyId: i32, value: VARIANT, pFound: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationItemContainerPattern.VTable, self.vtable).FindItemByProperty(@ptrCast(*const IUIAutomationItemContainerPattern, self), pStartAfter, propertyId, value, pFound);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationVirtualizedItemPattern_Value = @import("../zig.zig").Guid.initString("6BA3D7A6-04CF-4F11-8793-A8D1CDE9969F");
pub const IID_IUIAutomationVirtualizedItemPattern = &IID_IUIAutomationVirtualizedItemPattern_Value;
pub const IUIAutomationVirtualizedItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Realize: fn(
            self: *const IUIAutomationVirtualizedItemPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationVirtualizedItemPattern_Realize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationVirtualizedItemPattern.VTable, self.vtable).Realize(@ptrCast(*const IUIAutomationVirtualizedItemPattern, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationAnnotationPattern_Value = @import("../zig.zig").Guid.initString("9A175B21-339E-41B1-8E8B-623F6B681098");
pub const IID_IUIAutomationAnnotationPattern = &IID_IUIAutomationAnnotationPattern_Value;
pub const IUIAutomationAnnotationPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_CurrentAnnotationTypeId: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentAnnotationTypeName: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentAuthor: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentDateTime: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentTarget: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAnnotationTypeId: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAnnotationTypeName: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAuthor: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedDateTime: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedTarget: fn(
            self: *const IUIAutomationAnnotationPattern,
            retVal: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentAnnotationTypeId(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentAnnotationTypeId(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentAnnotationTypeName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentAnnotationTypeName(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentAuthor(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentAuthor(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentDateTime(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentDateTime(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CurrentTarget(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CurrentTarget(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedAnnotationTypeId(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedAnnotationTypeId(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedAnnotationTypeName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedAnnotationTypeName(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedAuthor(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedAuthor(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedDateTime(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedDateTime(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationAnnotationPattern_get_CachedTarget(self: *const T, retVal: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationAnnotationPattern.VTable, self.vtable).get_CachedTarget(@ptrCast(*const IUIAutomationAnnotationPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationStylesPattern_Value = @import("../zig.zig").Guid.initString("85B5F0A2-BD79-484A-AD2B-388C9838D5FB");
pub const IID_IUIAutomationStylesPattern = &IID_IUIAutomationStylesPattern_Value;
pub const IUIAutomationStylesPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_CurrentStyleId: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentStyleName: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentFillColor: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentFillPatternStyle: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentShape: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentFillPatternColor: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentExtendedProperties: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentExtendedPropertiesAsArray: fn(
            self: *const IUIAutomationStylesPattern,
            propertyArray: **ExtendedProperty,
            propertyCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedStyleId: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedStyleName: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedFillColor: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedFillPatternStyle: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedShape: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedFillPatternColor: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedExtendedProperties: fn(
            self: *const IUIAutomationStylesPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedExtendedPropertiesAsArray: fn(
            self: *const IUIAutomationStylesPattern,
            propertyArray: **ExtendedProperty,
            propertyCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentStyleId(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentStyleId(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentStyleName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentStyleName(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentFillColor(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentFillColor(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentFillPatternStyle(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentFillPatternStyle(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentShape(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentShape(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentFillPatternColor(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentFillPatternColor(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CurrentExtendedProperties(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CurrentExtendedProperties(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_GetCurrentExtendedPropertiesAsArray(self: *const T, propertyArray: **ExtendedProperty, propertyCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).GetCurrentExtendedPropertiesAsArray(@ptrCast(*const IUIAutomationStylesPattern, self), propertyArray, propertyCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedStyleId(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedStyleId(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedStyleName(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedStyleName(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedFillColor(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedFillColor(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedFillPatternStyle(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedFillPatternStyle(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedShape(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedShape(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedFillPatternColor(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedFillPatternColor(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_get_CachedExtendedProperties(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).get_CachedExtendedProperties(@ptrCast(*const IUIAutomationStylesPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationStylesPattern_GetCachedExtendedPropertiesAsArray(self: *const T, propertyArray: **ExtendedProperty, propertyCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationStylesPattern.VTable, self.vtable).GetCachedExtendedPropertiesAsArray(@ptrCast(*const IUIAutomationStylesPattern, self), propertyArray, propertyCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationSpreadsheetPattern_Value = @import("../zig.zig").Guid.initString("7517A7C8-FAAE-4DE9-9F08-29B91E8595C1");
pub const IID_IUIAutomationSpreadsheetPattern = &IID_IUIAutomationSpreadsheetPattern_Value;
pub const IUIAutomationSpreadsheetPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItemByName: fn(
            self: *const IUIAutomationSpreadsheetPattern,
            name: BSTR,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetPattern_GetItemByName(self: *const T, name: BSTR, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetPattern.VTable, self.vtable).GetItemByName(@ptrCast(*const IUIAutomationSpreadsheetPattern, self), name, element);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationSpreadsheetItemPattern_Value = @import("../zig.zig").Guid.initString("7D4FB86C-8D34-40E1-8E83-62C15204E335");
pub const IID_IUIAutomationSpreadsheetItemPattern = &IID_IUIAutomationSpreadsheetItemPattern_Value;
pub const IUIAutomationSpreadsheetItemPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_CurrentFormula: fn(
            self: *const IUIAutomationSpreadsheetItemPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAnnotationObjects: fn(
            self: *const IUIAutomationSpreadsheetItemPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentAnnotationTypes: fn(
            self: *const IUIAutomationSpreadsheetItemPattern,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedFormula: fn(
            self: *const IUIAutomationSpreadsheetItemPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedAnnotationObjects: fn(
            self: *const IUIAutomationSpreadsheetItemPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedAnnotationTypes: fn(
            self: *const IUIAutomationSpreadsheetItemPattern,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_get_CurrentFormula(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).get_CurrentFormula(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_GetCurrentAnnotationObjects(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).GetCurrentAnnotationObjects(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_GetCurrentAnnotationTypes(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).GetCurrentAnnotationTypes(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_get_CachedFormula(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).get_CachedFormula(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_GetCachedAnnotationObjects(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).GetCachedAnnotationObjects(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationSpreadsheetItemPattern_GetCachedAnnotationTypes(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationSpreadsheetItemPattern.VTable, self.vtable).GetCachedAnnotationTypes(@ptrCast(*const IUIAutomationSpreadsheetItemPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTransformPattern2_Value = @import("../zig.zig").Guid.initString("6D74D017-6ECB-4381-B38B-3C17A48FF1C2");
pub const IID_IUIAutomationTransformPattern2 = &IID_IUIAutomationTransformPattern2_Value;
pub const IUIAutomationTransformPattern2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationTransformPattern.VTable,
        Zoom: fn(
            self: *const IUIAutomationTransformPattern2,
            zoomValue: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ZoomByUnit: fn(
            self: *const IUIAutomationTransformPattern2,
            zoomUnit: ZoomUnit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentCanZoom: fn(
            self: *const IUIAutomationTransformPattern2,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedCanZoom: fn(
            self: *const IUIAutomationTransformPattern2,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentZoomLevel: fn(
            self: *const IUIAutomationTransformPattern2,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedZoomLevel: fn(
            self: *const IUIAutomationTransformPattern2,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentZoomMinimum: fn(
            self: *const IUIAutomationTransformPattern2,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedZoomMinimum: fn(
            self: *const IUIAutomationTransformPattern2,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentZoomMaximum: fn(
            self: *const IUIAutomationTransformPattern2,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedZoomMaximum: fn(
            self: *const IUIAutomationTransformPattern2,
            retVal: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationTransformPattern.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_Zoom(self: *const T, zoomValue: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).Zoom(@ptrCast(*const IUIAutomationTransformPattern2, self), zoomValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_ZoomByUnit(self: *const T, zoomUnit: ZoomUnit) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).ZoomByUnit(@ptrCast(*const IUIAutomationTransformPattern2, self), zoomUnit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CurrentCanZoom(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CurrentCanZoom(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CachedCanZoom(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CachedCanZoom(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CurrentZoomLevel(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CurrentZoomLevel(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CachedZoomLevel(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CachedZoomLevel(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CurrentZoomMinimum(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CurrentZoomMinimum(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CachedZoomMinimum(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CachedZoomMinimum(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CurrentZoomMaximum(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CurrentZoomMaximum(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTransformPattern2_get_CachedZoomMaximum(self: *const T, retVal: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTransformPattern2.VTable, self.vtable).get_CachedZoomMaximum(@ptrCast(*const IUIAutomationTransformPattern2, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationTextChildPattern_Value = @import("../zig.zig").Guid.initString("6552B038-AE05-40C8-ABFD-AA08352AAB86");
pub const IID_IUIAutomationTextChildPattern = &IID_IUIAutomationTextChildPattern_Value;
pub const IUIAutomationTextChildPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_TextContainer: fn(
            self: *const IUIAutomationTextChildPattern,
            container: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TextRange: fn(
            self: *const IUIAutomationTextChildPattern,
            range: **IUIAutomationTextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextChildPattern_get_TextContainer(self: *const T, container: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextChildPattern.VTable, self.vtable).get_TextContainer(@ptrCast(*const IUIAutomationTextChildPattern, self), container);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationTextChildPattern_get_TextRange(self: *const T, range: **IUIAutomationTextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationTextChildPattern.VTable, self.vtable).get_TextRange(@ptrCast(*const IUIAutomationTextChildPattern, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationDragPattern_Value = @import("../zig.zig").Guid.initString("1DC7B570-1F54-4BAD-BCDA-D36A722FB7BD");
pub const IID_IUIAutomationDragPattern = &IID_IUIAutomationDragPattern_Value;
pub const IUIAutomationDragPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_CurrentIsGrabbed: fn(
            self: *const IUIAutomationDragPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsGrabbed: fn(
            self: *const IUIAutomationDragPattern,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentDropEffect: fn(
            self: *const IUIAutomationDragPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedDropEffect: fn(
            self: *const IUIAutomationDragPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentDropEffects: fn(
            self: *const IUIAutomationDragPattern,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedDropEffects: fn(
            self: *const IUIAutomationDragPattern,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentGrabbedItems: fn(
            self: *const IUIAutomationDragPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCachedGrabbedItems: fn(
            self: *const IUIAutomationDragPattern,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CurrentIsGrabbed(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CurrentIsGrabbed(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CachedIsGrabbed(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CachedIsGrabbed(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CurrentDropEffect(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CurrentDropEffect(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CachedDropEffect(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CachedDropEffect(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CurrentDropEffects(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CurrentDropEffects(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_get_CachedDropEffects(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).get_CachedDropEffects(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_GetCurrentGrabbedItems(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).GetCurrentGrabbedItems(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDragPattern_GetCachedGrabbedItems(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDragPattern.VTable, self.vtable).GetCachedGrabbedItems(@ptrCast(*const IUIAutomationDragPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationDropTargetPattern_Value = @import("../zig.zig").Guid.initString("69A095F7-EEE4-430E-A46B-FB73B1AE39A5");
pub const IID_IUIAutomationDropTargetPattern = &IID_IUIAutomationDropTargetPattern_Value;
pub const IUIAutomationDropTargetPattern = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_CurrentDropTargetEffect: fn(
            self: *const IUIAutomationDropTargetPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedDropTargetEffect: fn(
            self: *const IUIAutomationDropTargetPattern,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentDropTargetEffects: fn(
            self: *const IUIAutomationDropTargetPattern,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedDropTargetEffects: fn(
            self: *const IUIAutomationDropTargetPattern,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDropTargetPattern_get_CurrentDropTargetEffect(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDropTargetPattern.VTable, self.vtable).get_CurrentDropTargetEffect(@ptrCast(*const IUIAutomationDropTargetPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDropTargetPattern_get_CachedDropTargetEffect(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDropTargetPattern.VTable, self.vtable).get_CachedDropTargetEffect(@ptrCast(*const IUIAutomationDropTargetPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDropTargetPattern_get_CurrentDropTargetEffects(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDropTargetPattern.VTable, self.vtable).get_CurrentDropTargetEffects(@ptrCast(*const IUIAutomationDropTargetPattern, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationDropTargetPattern_get_CachedDropTargetEffects(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationDropTargetPattern.VTable, self.vtable).get_CachedDropTargetEffects(@ptrCast(*const IUIAutomationDropTargetPattern, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationElement2_Value = @import("../zig.zig").Guid.initString("6749C683-F70D-4487-A698-5F79D55290D6");
pub const IID_IUIAutomationElement2 = &IID_IUIAutomationElement2_Value;
pub const IUIAutomationElement2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement.VTable,
        get_CurrentOptimizeForVisualContent: fn(
            self: *const IUIAutomationElement2,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedOptimizeForVisualContent: fn(
            self: *const IUIAutomationElement2,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentLiveSetting: fn(
            self: *const IUIAutomationElement2,
            retVal: *LiveSetting,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedLiveSetting: fn(
            self: *const IUIAutomationElement2,
            retVal: *LiveSetting,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentFlowsFrom: fn(
            self: *const IUIAutomationElement2,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedFlowsFrom: fn(
            self: *const IUIAutomationElement2,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CurrentOptimizeForVisualContent(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CurrentOptimizeForVisualContent(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CachedOptimizeForVisualContent(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CachedOptimizeForVisualContent(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CurrentLiveSetting(self: *const T, retVal: *LiveSetting) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CurrentLiveSetting(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CachedLiveSetting(self: *const T, retVal: *LiveSetting) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CachedLiveSetting(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CurrentFlowsFrom(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CurrentFlowsFrom(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement2_get_CachedFlowsFrom(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement2.VTable, self.vtable).get_CachedFlowsFrom(@ptrCast(*const IUIAutomationElement2, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationElement3_Value = @import("../zig.zig").Guid.initString("8471DF34-AEE0-4A01-A7DE-7DB9AF12C296");
pub const IID_IUIAutomationElement3 = &IID_IUIAutomationElement3_Value;
pub const IUIAutomationElement3 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement2.VTable,
        ShowContextMenu: fn(
            self: *const IUIAutomationElement3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentIsPeripheral: fn(
            self: *const IUIAutomationElement3,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsPeripheral: fn(
            self: *const IUIAutomationElement3,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement3_ShowContextMenu(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement3.VTable, self.vtable).ShowContextMenu(@ptrCast(*const IUIAutomationElement3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement3_get_CurrentIsPeripheral(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement3.VTable, self.vtable).get_CurrentIsPeripheral(@ptrCast(*const IUIAutomationElement3, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement3_get_CachedIsPeripheral(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement3.VTable, self.vtable).get_CachedIsPeripheral(@ptrCast(*const IUIAutomationElement3, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationElement4_Value = @import("../zig.zig").Guid.initString("3B6E233C-52FB-4063-A4C9-77C075C2A06B");
pub const IID_IUIAutomationElement4 = &IID_IUIAutomationElement4_Value;
pub const IUIAutomationElement4 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement3.VTable,
        get_CurrentPositionInSet: fn(
            self: *const IUIAutomationElement4,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentSizeOfSet: fn(
            self: *const IUIAutomationElement4,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentLevel: fn(
            self: *const IUIAutomationElement4,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentAnnotationTypes: fn(
            self: *const IUIAutomationElement4,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentAnnotationObjects: fn(
            self: *const IUIAutomationElement4,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedPositionInSet: fn(
            self: *const IUIAutomationElement4,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedSizeOfSet: fn(
            self: *const IUIAutomationElement4,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedLevel: fn(
            self: *const IUIAutomationElement4,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAnnotationTypes: fn(
            self: *const IUIAutomationElement4,
            retVal: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedAnnotationObjects: fn(
            self: *const IUIAutomationElement4,
            retVal: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentPositionInSet(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentPositionInSet(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentSizeOfSet(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentSizeOfSet(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentLevel(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentLevel(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentAnnotationTypes(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentAnnotationTypes(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CurrentAnnotationObjects(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CurrentAnnotationObjects(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedPositionInSet(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedPositionInSet(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedSizeOfSet(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedSizeOfSet(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedLevel(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedLevel(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedAnnotationTypes(self: *const T, retVal: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedAnnotationTypes(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement4_get_CachedAnnotationObjects(self: *const T, retVal: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement4.VTable, self.vtable).get_CachedAnnotationObjects(@ptrCast(*const IUIAutomationElement4, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationElement5_Value = @import("../zig.zig").Guid.initString("98141C1D-0D0E-4175-BBE2-6BFF455842A7");
pub const IID_IUIAutomationElement5 = &IID_IUIAutomationElement5_Value;
pub const IUIAutomationElement5 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement4.VTable,
        get_CurrentLandmarkType: fn(
            self: *const IUIAutomationElement5,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CurrentLocalizedLandmarkType: fn(
            self: *const IUIAutomationElement5,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedLandmarkType: fn(
            self: *const IUIAutomationElement5,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedLocalizedLandmarkType: fn(
            self: *const IUIAutomationElement5,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement5_get_CurrentLandmarkType(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement5.VTable, self.vtable).get_CurrentLandmarkType(@ptrCast(*const IUIAutomationElement5, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement5_get_CurrentLocalizedLandmarkType(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement5.VTable, self.vtable).get_CurrentLocalizedLandmarkType(@ptrCast(*const IUIAutomationElement5, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement5_get_CachedLandmarkType(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement5.VTable, self.vtable).get_CachedLandmarkType(@ptrCast(*const IUIAutomationElement5, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement5_get_CachedLocalizedLandmarkType(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement5.VTable, self.vtable).get_CachedLocalizedLandmarkType(@ptrCast(*const IUIAutomationElement5, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationElement6_Value = @import("../zig.zig").Guid.initString("4780D450-8BCA-4977-AFA5-A4A517F555E3");
pub const IID_IUIAutomationElement6 = &IID_IUIAutomationElement6_Value;
pub const IUIAutomationElement6 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement5.VTable,
        get_CurrentFullDescription: fn(
            self: *const IUIAutomationElement6,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedFullDescription: fn(
            self: *const IUIAutomationElement6,
            retVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement6_get_CurrentFullDescription(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement6.VTable, self.vtable).get_CurrentFullDescription(@ptrCast(*const IUIAutomationElement6, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement6_get_CachedFullDescription(self: *const T, retVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement6.VTable, self.vtable).get_CachedFullDescription(@ptrCast(*const IUIAutomationElement6, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationElement7_Value = @import("../zig.zig").Guid.initString("204E8572-CFC3-4C11-B0C8-7DA7420750B7");
pub const IID_IUIAutomationElement7 = &IID_IUIAutomationElement7_Value;
pub const IUIAutomationElement7 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement6.VTable,
        FindFirstWithOptions: fn(
            self: *const IUIAutomationElement7,
            scope: TreeScope,
            condition: *IUIAutomationCondition,
            traversalOptions: TreeTraversalOptions,
            root: *IUIAutomationElement,
            found: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindAllWithOptions: fn(
            self: *const IUIAutomationElement7,
            scope: TreeScope,
            condition: *IUIAutomationCondition,
            traversalOptions: TreeTraversalOptions,
            root: *IUIAutomationElement,
            found: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindFirstWithOptionsBuildCache: fn(
            self: *const IUIAutomationElement7,
            scope: TreeScope,
            condition: *IUIAutomationCondition,
            cacheRequest: *IUIAutomationCacheRequest,
            traversalOptions: TreeTraversalOptions,
            root: *IUIAutomationElement,
            found: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindAllWithOptionsBuildCache: fn(
            self: *const IUIAutomationElement7,
            scope: TreeScope,
            condition: *IUIAutomationCondition,
            cacheRequest: *IUIAutomationCacheRequest,
            traversalOptions: TreeTraversalOptions,
            root: *IUIAutomationElement,
            found: **IUIAutomationElementArray,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentMetadataValue: fn(
            self: *const IUIAutomationElement7,
            targetId: i32,
            metadataId: i32,
            returnVal: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_FindFirstWithOptions(self: *const T, scope: TreeScope, condition: *IUIAutomationCondition, traversalOptions: TreeTraversalOptions, root: *IUIAutomationElement, found: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).FindFirstWithOptions(@ptrCast(*const IUIAutomationElement7, self), scope, condition, traversalOptions, root, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_FindAllWithOptions(self: *const T, scope: TreeScope, condition: *IUIAutomationCondition, traversalOptions: TreeTraversalOptions, root: *IUIAutomationElement, found: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).FindAllWithOptions(@ptrCast(*const IUIAutomationElement7, self), scope, condition, traversalOptions, root, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_FindFirstWithOptionsBuildCache(self: *const T, scope: TreeScope, condition: *IUIAutomationCondition, cacheRequest: *IUIAutomationCacheRequest, traversalOptions: TreeTraversalOptions, root: *IUIAutomationElement, found: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).FindFirstWithOptionsBuildCache(@ptrCast(*const IUIAutomationElement7, self), scope, condition, cacheRequest, traversalOptions, root, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_FindAllWithOptionsBuildCache(self: *const T, scope: TreeScope, condition: *IUIAutomationCondition, cacheRequest: *IUIAutomationCacheRequest, traversalOptions: TreeTraversalOptions, root: *IUIAutomationElement, found: **IUIAutomationElementArray) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).FindAllWithOptionsBuildCache(@ptrCast(*const IUIAutomationElement7, self), scope, condition, cacheRequest, traversalOptions, root, found);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement7_GetCurrentMetadataValue(self: *const T, targetId: i32, metadataId: i32, returnVal: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement7.VTable, self.vtable).GetCurrentMetadataValue(@ptrCast(*const IUIAutomationElement7, self), targetId, metadataId, returnVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationElement8_Value = @import("../zig.zig").Guid.initString("8C60217D-5411-4CDE-BCC0-1CEDA223830C");
pub const IID_IUIAutomationElement8 = &IID_IUIAutomationElement8_Value;
pub const IUIAutomationElement8 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement7.VTable,
        get_CurrentHeadingLevel: fn(
            self: *const IUIAutomationElement8,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedHeadingLevel: fn(
            self: *const IUIAutomationElement8,
            retVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement7.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement8_get_CurrentHeadingLevel(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement8.VTable, self.vtable).get_CurrentHeadingLevel(@ptrCast(*const IUIAutomationElement8, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement8_get_CachedHeadingLevel(self: *const T, retVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement8.VTable, self.vtable).get_CachedHeadingLevel(@ptrCast(*const IUIAutomationElement8, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationElement9_Value = @import("../zig.zig").Guid.initString("39325FAC-039D-440E-A3A3-5EB81A5CECC3");
pub const IID_IUIAutomationElement9 = &IID_IUIAutomationElement9_Value;
pub const IUIAutomationElement9 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomationElement8.VTable,
        get_CurrentIsDialog: fn(
            self: *const IUIAutomationElement9,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CachedIsDialog: fn(
            self: *const IUIAutomationElement9,
            retVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomationElement8.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement9_get_CurrentIsDialog(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement9.VTable, self.vtable).get_CurrentIsDialog(@ptrCast(*const IUIAutomationElement9, self), retVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationElement9_get_CachedIsDialog(self: *const T, retVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationElement9.VTable, self.vtable).get_CachedIsDialog(@ptrCast(*const IUIAutomationElement9, self), retVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationProxyFactory_Value = @import("../zig.zig").Guid.initString("85B94ECD-849D-42B6-B94D-D6DB23FDF5A4");
pub const IID_IUIAutomationProxyFactory = &IID_IUIAutomationProxyFactory_Value;
pub const IUIAutomationProxyFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProvider: fn(
            self: *const IUIAutomationProxyFactory,
            hwnd: *c_void,
            idObject: i32,
            idChild: i32,
            provider: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ProxyFactoryId: fn(
            self: *const IUIAutomationProxyFactory,
            factoryId: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactory_CreateProvider(self: *const T, hwnd: *c_void, idObject: i32, idChild: i32, provider: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactory.VTable, self.vtable).CreateProvider(@ptrCast(*const IUIAutomationProxyFactory, self), hwnd, idObject, idChild, provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactory_get_ProxyFactoryId(self: *const T, factoryId: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactory.VTable, self.vtable).get_ProxyFactoryId(@ptrCast(*const IUIAutomationProxyFactory, self), factoryId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationProxyFactoryEntry_Value = @import("../zig.zig").Guid.initString("D50E472E-B64B-490C-BCA1-D30696F9F289");
pub const IID_IUIAutomationProxyFactoryEntry = &IID_IUIAutomationProxyFactoryEntry_Value;
pub const IUIAutomationProxyFactoryEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_ProxyFactory: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            factory: **IUIAutomationProxyFactory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ClassName: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            className: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ImageName: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            imageName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AllowSubstringMatch: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            allowSubstringMatch: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CanCheckBaseClass: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            canCheckBaseClass: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_NeedsAdviseEvents: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            adviseEvents: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ClassName: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            className: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ImageName: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            imageName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_AllowSubstringMatch: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            allowSubstringMatch: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_CanCheckBaseClass: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            canCheckBaseClass: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_NeedsAdviseEvents: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            adviseEvents: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWinEventsForAutomationEvent: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            eventId: i32,
            propertyId: i32,
            winEvents: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWinEventsForAutomationEvent: fn(
            self: *const IUIAutomationProxyFactoryEntry,
            eventId: i32,
            propertyId: i32,
            winEvents: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_ProxyFactory(self: *const T, factory: **IUIAutomationProxyFactory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_ProxyFactory(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), factory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_ClassName(self: *const T, className: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_ClassName(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), className);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_ImageName(self: *const T, imageName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_ImageName(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), imageName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_AllowSubstringMatch(self: *const T, allowSubstringMatch: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_AllowSubstringMatch(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), allowSubstringMatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_CanCheckBaseClass(self: *const T, canCheckBaseClass: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_CanCheckBaseClass(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), canCheckBaseClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_get_NeedsAdviseEvents(self: *const T, adviseEvents: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).get_NeedsAdviseEvents(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), adviseEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_ClassName(self: *const T, className: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_ClassName(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), className);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_ImageName(self: *const T, imageName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_ImageName(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), imageName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_AllowSubstringMatch(self: *const T, allowSubstringMatch: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_AllowSubstringMatch(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), allowSubstringMatch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_CanCheckBaseClass(self: *const T, canCheckBaseClass: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_CanCheckBaseClass(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), canCheckBaseClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_put_NeedsAdviseEvents(self: *const T, adviseEvents: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).put_NeedsAdviseEvents(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), adviseEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_SetWinEventsForAutomationEvent(self: *const T, eventId: i32, propertyId: i32, winEvents: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).SetWinEventsForAutomationEvent(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), eventId, propertyId, winEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryEntry_GetWinEventsForAutomationEvent(self: *const T, eventId: i32, propertyId: i32, winEvents: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryEntry.VTable, self.vtable).GetWinEventsForAutomationEvent(@ptrCast(*const IUIAutomationProxyFactoryEntry, self), eventId, propertyId, winEvents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationProxyFactoryMapping_Value = @import("../zig.zig").Guid.initString("09E31E18-872D-4873-93D1-1E541EC133FD");
pub const IID_IUIAutomationProxyFactoryMapping = &IID_IUIAutomationProxyFactoryMapping_Value;
pub const IUIAutomationProxyFactoryMapping = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_Count: fn(
            self: *const IUIAutomationProxyFactoryMapping,
            count: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTable: fn(
            self: *const IUIAutomationProxyFactoryMapping,
            table: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntry: fn(
            self: *const IUIAutomationProxyFactoryMapping,
            index: u32,
            entry: **IUIAutomationProxyFactoryEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTable: fn(
            self: *const IUIAutomationProxyFactoryMapping,
            factoryList: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEntries: fn(
            self: *const IUIAutomationProxyFactoryMapping,
            before: u32,
            factoryList: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEntry: fn(
            self: *const IUIAutomationProxyFactoryMapping,
            before: u32,
            factory: *IUIAutomationProxyFactoryEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEntry: fn(
            self: *const IUIAutomationProxyFactoryMapping,
            index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearTable: fn(
            self: *const IUIAutomationProxyFactoryMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RestoreDefaultTable: fn(
            self: *const IUIAutomationProxyFactoryMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_get_Count(self: *const T, count: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).get_Count(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_GetTable(self: *const T, table: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).GetTable(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), table);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_GetEntry(self: *const T, index: u32, entry: **IUIAutomationProxyFactoryEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).GetEntry(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), index, entry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_SetTable(self: *const T, factoryList: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).SetTable(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), factoryList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_InsertEntries(self: *const T, before: u32, factoryList: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).InsertEntries(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), before, factoryList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_InsertEntry(self: *const T, before: u32, factory: *IUIAutomationProxyFactoryEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).InsertEntry(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), before, factory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_RemoveEntry(self: *const T, index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).RemoveEntry(@ptrCast(*const IUIAutomationProxyFactoryMapping, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_ClearTable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).ClearTable(@ptrCast(*const IUIAutomationProxyFactoryMapping, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationProxyFactoryMapping_RestoreDefaultTable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationProxyFactoryMapping.VTable, self.vtable).RestoreDefaultTable(@ptrCast(*const IUIAutomationProxyFactoryMapping, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomationEventHandlerGroup_Value = @import("../zig.zig").Guid.initString("C9EE12F2-C13B-4408-997C-639914377F4E");
pub const IID_IUIAutomationEventHandlerGroup = &IID_IUIAutomationEventHandlerGroup_Value;
pub const IUIAutomationEventHandlerGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddActiveTextPositionChangedEventHandler: fn(
            self: *const IUIAutomationEventHandlerGroup,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationActiveTextPositionChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAutomationEventHandler: fn(
            self: *const IUIAutomationEventHandlerGroup,
            eventId: i32,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddChangesEventHandler: fn(
            self: *const IUIAutomationEventHandlerGroup,
            scope: TreeScope,
            changeTypes: [*]i32,
            changesCount: i32,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationChangesEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddNotificationEventHandler: fn(
            self: *const IUIAutomationEventHandlerGroup,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationNotificationEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyChangedEventHandler: fn(
            self: *const IUIAutomationEventHandlerGroup,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationPropertyChangedEventHandler,
            propertyArray: [*]i32,
            propertyCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStructureChangedEventHandler: fn(
            self: *const IUIAutomationEventHandlerGroup,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationStructureChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTextEditTextChangedEventHandler: fn(
            self: *const IUIAutomationEventHandlerGroup,
            scope: TreeScope,
            textEditChangeType: TextEditChangeType,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationTextEditTextChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddActiveTextPositionChangedEventHandler(self: *const T, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationActiveTextPositionChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddActiveTextPositionChangedEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddAutomationEventHandler(self: *const T, eventId: i32, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddAutomationEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), eventId, scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddChangesEventHandler(self: *const T, scope: TreeScope, changeTypes: [*]i32, changesCount: i32, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationChangesEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddChangesEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, changeTypes, changesCount, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddNotificationEventHandler(self: *const T, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationNotificationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddNotificationEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddPropertyChangedEventHandler(self: *const T, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationPropertyChangedEventHandler, propertyArray: [*]i32, propertyCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddPropertyChangedEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, cacheRequest, handler, propertyArray, propertyCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddStructureChangedEventHandler(self: *const T, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationStructureChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddStructureChangedEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomationEventHandlerGroup_AddTextEditTextChangedEventHandler(self: *const T, scope: TreeScope, textEditChangeType: TextEditChangeType, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationTextEditTextChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomationEventHandlerGroup.VTable, self.vtable).AddTextEditTextChangedEventHandler(@ptrCast(*const IUIAutomationEventHandlerGroup, self), scope, textEditChangeType, cacheRequest, handler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomation_Value = @import("../zig.zig").Guid.initString("30CBE57D-D9D0-452A-AB13-7AC5AC4825EE");
pub const IID_IUIAutomation = &IID_IUIAutomation_Value;
pub const IUIAutomation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareElements: fn(
            self: *const IUIAutomation,
            el1: *IUIAutomationElement,
            el2: *IUIAutomationElement,
            areSame: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareRuntimeIds: fn(
            self: *const IUIAutomation,
            runtimeId1: *SAFEARRAY,
            runtimeId2: *SAFEARRAY,
            areSame: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootElement: fn(
            self: *const IUIAutomation,
            root: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ElementFromHandle: fn(
            self: *const IUIAutomation,
            hwnd: *c_void,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ElementFromPoint: fn(
            self: *const IUIAutomation,
            pt: POINT,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocusedElement: fn(
            self: *const IUIAutomation,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootElementBuildCache: fn(
            self: *const IUIAutomation,
            cacheRequest: *IUIAutomationCacheRequest,
            root: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ElementFromHandleBuildCache: fn(
            self: *const IUIAutomation,
            hwnd: *c_void,
            cacheRequest: *IUIAutomationCacheRequest,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ElementFromPointBuildCache: fn(
            self: *const IUIAutomation,
            pt: POINT,
            cacheRequest: *IUIAutomationCacheRequest,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFocusedElementBuildCache: fn(
            self: *const IUIAutomation,
            cacheRequest: *IUIAutomationCacheRequest,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTreeWalker: fn(
            self: *const IUIAutomation,
            pCondition: *IUIAutomationCondition,
            walker: **IUIAutomationTreeWalker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ControlViewWalker: fn(
            self: *const IUIAutomation,
            walker: **IUIAutomationTreeWalker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ContentViewWalker: fn(
            self: *const IUIAutomation,
            walker: **IUIAutomationTreeWalker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_RawViewWalker: fn(
            self: *const IUIAutomation,
            walker: **IUIAutomationTreeWalker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_RawViewCondition: fn(
            self: *const IUIAutomation,
            condition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ControlViewCondition: fn(
            self: *const IUIAutomation,
            condition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ContentViewCondition: fn(
            self: *const IUIAutomation,
            condition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCacheRequest: fn(
            self: *const IUIAutomation,
            cacheRequest: **IUIAutomationCacheRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTrueCondition: fn(
            self: *const IUIAutomation,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateFalseCondition: fn(
            self: *const IUIAutomation,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePropertyCondition: fn(
            self: *const IUIAutomation,
            propertyId: i32,
            value: VARIANT,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePropertyConditionEx: fn(
            self: *const IUIAutomation,
            propertyId: i32,
            value: VARIANT,
            flags: PropertyConditionFlags,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAndCondition: fn(
            self: *const IUIAutomation,
            condition1: *IUIAutomationCondition,
            condition2: *IUIAutomationCondition,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAndConditionFromArray: fn(
            self: *const IUIAutomation,
            conditions: *SAFEARRAY,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAndConditionFromNativeArray: fn(
            self: *const IUIAutomation,
            conditions: [*]*IUIAutomationCondition,
            conditionCount: i32,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateOrCondition: fn(
            self: *const IUIAutomation,
            condition1: *IUIAutomationCondition,
            condition2: *IUIAutomationCondition,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateOrConditionFromArray: fn(
            self: *const IUIAutomation,
            conditions: *SAFEARRAY,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateOrConditionFromNativeArray: fn(
            self: *const IUIAutomation,
            conditions: [*]*IUIAutomationCondition,
            conditionCount: i32,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateNotCondition: fn(
            self: *const IUIAutomation,
            condition: *IUIAutomationCondition,
            newCondition: **IUIAutomationCondition,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAutomationEventHandler: fn(
            self: *const IUIAutomation,
            eventId: i32,
            element: *IUIAutomationElement,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAutomationEventHandler: fn(
            self: *const IUIAutomation,
            eventId: i32,
            element: *IUIAutomationElement,
            handler: *IUIAutomationEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyChangedEventHandlerNativeArray: fn(
            self: *const IUIAutomation,
            element: *IUIAutomationElement,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationPropertyChangedEventHandler,
            propertyArray: [*]i32,
            propertyCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPropertyChangedEventHandler: fn(
            self: *const IUIAutomation,
            element: *IUIAutomationElement,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationPropertyChangedEventHandler,
            propertyArray: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePropertyChangedEventHandler: fn(
            self: *const IUIAutomation,
            element: *IUIAutomationElement,
            handler: *IUIAutomationPropertyChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStructureChangedEventHandler: fn(
            self: *const IUIAutomation,
            element: *IUIAutomationElement,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationStructureChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStructureChangedEventHandler: fn(
            self: *const IUIAutomation,
            element: *IUIAutomationElement,
            handler: *IUIAutomationStructureChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFocusChangedEventHandler: fn(
            self: *const IUIAutomation,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationFocusChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFocusChangedEventHandler: fn(
            self: *const IUIAutomation,
            handler: *IUIAutomationFocusChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllEventHandlers: fn(
            self: *const IUIAutomation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IntNativeArrayToSafeArray: fn(
            self: *const IUIAutomation,
            array: [*]i32,
            arrayCount: i32,
            safeArray: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IntSafeArrayToNativeArray: fn(
            self: *const IUIAutomation,
            intArray: *SAFEARRAY,
            array: [*]*i32,
            arrayCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RectToVariant: fn(
            self: *const IUIAutomation,
            rc: RECT,
            @"var": *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VariantToRect: fn(
            self: *const IUIAutomation,
            @"var": VARIANT,
            rc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SafeArrayToRectNativeArray: fn(
            self: *const IUIAutomation,
            rects: *SAFEARRAY,
            rectArray: [*]*RECT,
            rectArrayCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProxyFactoryEntry: fn(
            self: *const IUIAutomation,
            factory: *IUIAutomationProxyFactory,
            factoryEntry: **IUIAutomationProxyFactoryEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ProxyFactoryMapping: fn(
            self: *const IUIAutomation,
            factoryMapping: **IUIAutomationProxyFactoryMapping,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyProgrammaticName: fn(
            self: *const IUIAutomation,
            property: i32,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPatternProgrammaticName: fn(
            self: *const IUIAutomation,
            pattern: i32,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PollForPotentialSupportedPatterns: fn(
            self: *const IUIAutomation,
            pElement: *IUIAutomationElement,
            patternIds: **SAFEARRAY,
            patternNames: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PollForPotentialSupportedProperties: fn(
            self: *const IUIAutomation,
            pElement: *IUIAutomationElement,
            propertyIds: **SAFEARRAY,
            propertyNames: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckNotSupported: fn(
            self: *const IUIAutomation,
            value: VARIANT,
            isNotSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ReservedNotSupportedValue: fn(
            self: *const IUIAutomation,
            notSupportedValue: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ReservedMixedAttributeValue: fn(
            self: *const IUIAutomation,
            mixedAttributeValue: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ElementFromIAccessible: fn(
            self: *const IUIAutomation,
            accessible: *IAccessible,
            childId: i32,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ElementFromIAccessibleBuildCache: fn(
            self: *const IUIAutomation,
            accessible: *IAccessible,
            childId: i32,
            cacheRequest: *IUIAutomationCacheRequest,
            element: **IUIAutomationElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CompareElements(self: *const T, el1: *IUIAutomationElement, el2: *IUIAutomationElement, areSame: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CompareElements(@ptrCast(*const IUIAutomation, self), el1, el2, areSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CompareRuntimeIds(self: *const T, runtimeId1: *SAFEARRAY, runtimeId2: *SAFEARRAY, areSame: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CompareRuntimeIds(@ptrCast(*const IUIAutomation, self), runtimeId1, runtimeId2, areSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetRootElement(self: *const T, root: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetRootElement(@ptrCast(*const IUIAutomation, self), root);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromHandle(self: *const T, hwnd: *c_void, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromHandle(@ptrCast(*const IUIAutomation, self), hwnd, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromPoint(self: *const T, pt: POINT, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromPoint(@ptrCast(*const IUIAutomation, self), pt, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetFocusedElement(self: *const T, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetFocusedElement(@ptrCast(*const IUIAutomation, self), element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetRootElementBuildCache(self: *const T, cacheRequest: *IUIAutomationCacheRequest, root: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetRootElementBuildCache(@ptrCast(*const IUIAutomation, self), cacheRequest, root);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromHandleBuildCache(self: *const T, hwnd: *c_void, cacheRequest: *IUIAutomationCacheRequest, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromHandleBuildCache(@ptrCast(*const IUIAutomation, self), hwnd, cacheRequest, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromPointBuildCache(self: *const T, pt: POINT, cacheRequest: *IUIAutomationCacheRequest, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromPointBuildCache(@ptrCast(*const IUIAutomation, self), pt, cacheRequest, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetFocusedElementBuildCache(self: *const T, cacheRequest: *IUIAutomationCacheRequest, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetFocusedElementBuildCache(@ptrCast(*const IUIAutomation, self), cacheRequest, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateTreeWalker(self: *const T, pCondition: *IUIAutomationCondition, walker: **IUIAutomationTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateTreeWalker(@ptrCast(*const IUIAutomation, self), pCondition, walker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ControlViewWalker(self: *const T, walker: **IUIAutomationTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ControlViewWalker(@ptrCast(*const IUIAutomation, self), walker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ContentViewWalker(self: *const T, walker: **IUIAutomationTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ContentViewWalker(@ptrCast(*const IUIAutomation, self), walker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_RawViewWalker(self: *const T, walker: **IUIAutomationTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_RawViewWalker(@ptrCast(*const IUIAutomation, self), walker);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_RawViewCondition(self: *const T, condition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_RawViewCondition(@ptrCast(*const IUIAutomation, self), condition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ControlViewCondition(self: *const T, condition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ControlViewCondition(@ptrCast(*const IUIAutomation, self), condition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ContentViewCondition(self: *const T, condition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ContentViewCondition(@ptrCast(*const IUIAutomation, self), condition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateCacheRequest(self: *const T, cacheRequest: **IUIAutomationCacheRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateCacheRequest(@ptrCast(*const IUIAutomation, self), cacheRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateTrueCondition(self: *const T, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateTrueCondition(@ptrCast(*const IUIAutomation, self), newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateFalseCondition(self: *const T, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateFalseCondition(@ptrCast(*const IUIAutomation, self), newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreatePropertyCondition(self: *const T, propertyId: i32, value: VARIANT, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreatePropertyCondition(@ptrCast(*const IUIAutomation, self), propertyId, value, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreatePropertyConditionEx(self: *const T, propertyId: i32, value: VARIANT, flags: PropertyConditionFlags, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreatePropertyConditionEx(@ptrCast(*const IUIAutomation, self), propertyId, value, flags, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateAndCondition(self: *const T, condition1: *IUIAutomationCondition, condition2: *IUIAutomationCondition, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateAndCondition(@ptrCast(*const IUIAutomation, self), condition1, condition2, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateAndConditionFromArray(self: *const T, conditions: *SAFEARRAY, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateAndConditionFromArray(@ptrCast(*const IUIAutomation, self), conditions, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateAndConditionFromNativeArray(self: *const T, conditions: [*]*IUIAutomationCondition, conditionCount: i32, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateAndConditionFromNativeArray(@ptrCast(*const IUIAutomation, self), conditions, conditionCount, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateOrCondition(self: *const T, condition1: *IUIAutomationCondition, condition2: *IUIAutomationCondition, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateOrCondition(@ptrCast(*const IUIAutomation, self), condition1, condition2, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateOrConditionFromArray(self: *const T, conditions: *SAFEARRAY, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateOrConditionFromArray(@ptrCast(*const IUIAutomation, self), conditions, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateOrConditionFromNativeArray(self: *const T, conditions: [*]*IUIAutomationCondition, conditionCount: i32, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateOrConditionFromNativeArray(@ptrCast(*const IUIAutomation, self), conditions, conditionCount, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateNotCondition(self: *const T, condition: *IUIAutomationCondition, newCondition: **IUIAutomationCondition) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateNotCondition(@ptrCast(*const IUIAutomation, self), condition, newCondition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddAutomationEventHandler(self: *const T, eventId: i32, element: *IUIAutomationElement, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddAutomationEventHandler(@ptrCast(*const IUIAutomation, self), eventId, element, scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemoveAutomationEventHandler(self: *const T, eventId: i32, element: *IUIAutomationElement, handler: *IUIAutomationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemoveAutomationEventHandler(@ptrCast(*const IUIAutomation, self), eventId, element, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddPropertyChangedEventHandlerNativeArray(self: *const T, element: *IUIAutomationElement, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationPropertyChangedEventHandler, propertyArray: [*]i32, propertyCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddPropertyChangedEventHandlerNativeArray(@ptrCast(*const IUIAutomation, self), element, scope, cacheRequest, handler, propertyArray, propertyCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddPropertyChangedEventHandler(self: *const T, element: *IUIAutomationElement, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationPropertyChangedEventHandler, propertyArray: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddPropertyChangedEventHandler(@ptrCast(*const IUIAutomation, self), element, scope, cacheRequest, handler, propertyArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemovePropertyChangedEventHandler(self: *const T, element: *IUIAutomationElement, handler: *IUIAutomationPropertyChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemovePropertyChangedEventHandler(@ptrCast(*const IUIAutomation, self), element, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddStructureChangedEventHandler(self: *const T, element: *IUIAutomationElement, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationStructureChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddStructureChangedEventHandler(@ptrCast(*const IUIAutomation, self), element, scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemoveStructureChangedEventHandler(self: *const T, element: *IUIAutomationElement, handler: *IUIAutomationStructureChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemoveStructureChangedEventHandler(@ptrCast(*const IUIAutomation, self), element, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_AddFocusChangedEventHandler(self: *const T, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationFocusChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).AddFocusChangedEventHandler(@ptrCast(*const IUIAutomation, self), cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemoveFocusChangedEventHandler(self: *const T, handler: *IUIAutomationFocusChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemoveFocusChangedEventHandler(@ptrCast(*const IUIAutomation, self), handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RemoveAllEventHandlers(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RemoveAllEventHandlers(@ptrCast(*const IUIAutomation, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_IntNativeArrayToSafeArray(self: *const T, array: [*]i32, arrayCount: i32, safeArray: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).IntNativeArrayToSafeArray(@ptrCast(*const IUIAutomation, self), array, arrayCount, safeArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_IntSafeArrayToNativeArray(self: *const T, intArray: *SAFEARRAY, array: [*]*i32, arrayCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).IntSafeArrayToNativeArray(@ptrCast(*const IUIAutomation, self), intArray, array, arrayCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_RectToVariant(self: *const T, rc: RECT, @"var": *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).RectToVariant(@ptrCast(*const IUIAutomation, self), rc, @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_VariantToRect(self: *const T, @"var": VARIANT, rc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).VariantToRect(@ptrCast(*const IUIAutomation, self), @"var", rc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_SafeArrayToRectNativeArray(self: *const T, rects: *SAFEARRAY, rectArray: [*]*RECT, rectArrayCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).SafeArrayToRectNativeArray(@ptrCast(*const IUIAutomation, self), rects, rectArray, rectArrayCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CreateProxyFactoryEntry(self: *const T, factory: *IUIAutomationProxyFactory, factoryEntry: **IUIAutomationProxyFactoryEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CreateProxyFactoryEntry(@ptrCast(*const IUIAutomation, self), factory, factoryEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ProxyFactoryMapping(self: *const T, factoryMapping: **IUIAutomationProxyFactoryMapping) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ProxyFactoryMapping(@ptrCast(*const IUIAutomation, self), factoryMapping);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetPropertyProgrammaticName(self: *const T, property: i32, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetPropertyProgrammaticName(@ptrCast(*const IUIAutomation, self), property, name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_GetPatternProgrammaticName(self: *const T, pattern: i32, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).GetPatternProgrammaticName(@ptrCast(*const IUIAutomation, self), pattern, name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_PollForPotentialSupportedPatterns(self: *const T, pElement: *IUIAutomationElement, patternIds: **SAFEARRAY, patternNames: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).PollForPotentialSupportedPatterns(@ptrCast(*const IUIAutomation, self), pElement, patternIds, patternNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_PollForPotentialSupportedProperties(self: *const T, pElement: *IUIAutomationElement, propertyIds: **SAFEARRAY, propertyNames: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).PollForPotentialSupportedProperties(@ptrCast(*const IUIAutomation, self), pElement, propertyIds, propertyNames);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_CheckNotSupported(self: *const T, value: VARIANT, isNotSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).CheckNotSupported(@ptrCast(*const IUIAutomation, self), value, isNotSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ReservedNotSupportedValue(self: *const T, notSupportedValue: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ReservedNotSupportedValue(@ptrCast(*const IUIAutomation, self), notSupportedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_get_ReservedMixedAttributeValue(self: *const T, mixedAttributeValue: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).get_ReservedMixedAttributeValue(@ptrCast(*const IUIAutomation, self), mixedAttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromIAccessible(self: *const T, accessible: *IAccessible, childId: i32, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromIAccessible(@ptrCast(*const IUIAutomation, self), accessible, childId, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation_ElementFromIAccessibleBuildCache(self: *const T, accessible: *IAccessible, childId: i32, cacheRequest: *IUIAutomationCacheRequest, element: **IUIAutomationElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation.VTable, self.vtable).ElementFromIAccessibleBuildCache(@ptrCast(*const IUIAutomation, self), accessible, childId, cacheRequest, element);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomation2_Value = @import("../zig.zig").Guid.initString("34723AFF-0C9D-49D0-9896-7AB52DF8CD8A");
pub const IID_IUIAutomation2 = &IID_IUIAutomation2_Value;
pub const IUIAutomation2 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomation.VTable,
        get_AutoSetFocus: fn(
            self: *const IUIAutomation2,
            autoSetFocus: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_AutoSetFocus: fn(
            self: *const IUIAutomation2,
            autoSetFocus: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ConnectionTimeout: fn(
            self: *const IUIAutomation2,
            timeout: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ConnectionTimeout: fn(
            self: *const IUIAutomation2,
            timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TransactionTimeout: fn(
            self: *const IUIAutomation2,
            timeout: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_TransactionTimeout: fn(
            self: *const IUIAutomation2,
            timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomation.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_get_AutoSetFocus(self: *const T, autoSetFocus: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).get_AutoSetFocus(@ptrCast(*const IUIAutomation2, self), autoSetFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_put_AutoSetFocus(self: *const T, autoSetFocus: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).put_AutoSetFocus(@ptrCast(*const IUIAutomation2, self), autoSetFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_get_ConnectionTimeout(self: *const T, timeout: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).get_ConnectionTimeout(@ptrCast(*const IUIAutomation2, self), timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_put_ConnectionTimeout(self: *const T, timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).put_ConnectionTimeout(@ptrCast(*const IUIAutomation2, self), timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_get_TransactionTimeout(self: *const T, timeout: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).get_TransactionTimeout(@ptrCast(*const IUIAutomation2, self), timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation2_put_TransactionTimeout(self: *const T, timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation2.VTable, self.vtable).put_TransactionTimeout(@ptrCast(*const IUIAutomation2, self), timeout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomation3_Value = @import("../zig.zig").Guid.initString("73D768DA-9B51-4B89-936E-C209290973E7");
pub const IID_IUIAutomation3 = &IID_IUIAutomation3_Value;
pub const IUIAutomation3 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomation2.VTable,
        AddTextEditTextChangedEventHandler: fn(
            self: *const IUIAutomation3,
            element: *IUIAutomationElement,
            scope: TreeScope,
            textEditChangeType: TextEditChangeType,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationTextEditTextChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTextEditTextChangedEventHandler: fn(
            self: *const IUIAutomation3,
            element: *IUIAutomationElement,
            handler: *IUIAutomationTextEditTextChangedEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomation2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation3_AddTextEditTextChangedEventHandler(self: *const T, element: *IUIAutomationElement, scope: TreeScope, textEditChangeType: TextEditChangeType, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationTextEditTextChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation3.VTable, self.vtable).AddTextEditTextChangedEventHandler(@ptrCast(*const IUIAutomation3, self), element, scope, textEditChangeType, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation3_RemoveTextEditTextChangedEventHandler(self: *const T, element: *IUIAutomationElement, handler: *IUIAutomationTextEditTextChangedEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation3.VTable, self.vtable).RemoveTextEditTextChangedEventHandler(@ptrCast(*const IUIAutomation3, self), element, handler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomation4_Value = @import("../zig.zig").Guid.initString("1189C02A-05F8-4319-8E21-E817E3DB2860");
pub const IID_IUIAutomation4 = &IID_IUIAutomation4_Value;
pub const IUIAutomation4 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomation3.VTable,
        AddChangesEventHandler: fn(
            self: *const IUIAutomation4,
            element: *IUIAutomationElement,
            scope: TreeScope,
            changeTypes: [*]i32,
            changesCount: i32,
            pCacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationChangesEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveChangesEventHandler: fn(
            self: *const IUIAutomation4,
            element: *IUIAutomationElement,
            handler: *IUIAutomationChangesEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomation3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation4_AddChangesEventHandler(self: *const T, element: *IUIAutomationElement, scope: TreeScope, changeTypes: [*]i32, changesCount: i32, pCacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationChangesEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation4.VTable, self.vtable).AddChangesEventHandler(@ptrCast(*const IUIAutomation4, self), element, scope, changeTypes, changesCount, pCacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation4_RemoveChangesEventHandler(self: *const T, element: *IUIAutomationElement, handler: *IUIAutomationChangesEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation4.VTable, self.vtable).RemoveChangesEventHandler(@ptrCast(*const IUIAutomation4, self), element, handler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IUIAutomation5_Value = @import("../zig.zig").Guid.initString("25F700C8-D816-4057-A9DC-3CBDEE77E256");
pub const IID_IUIAutomation5 = &IID_IUIAutomation5_Value;
pub const IUIAutomation5 = extern struct {
    pub const VTable = extern struct {
        base: IUIAutomation4.VTable,
        AddNotificationEventHandler: fn(
            self: *const IUIAutomation5,
            element: *IUIAutomationElement,
            scope: TreeScope,
            cacheRequest: *IUIAutomationCacheRequest,
            handler: *IUIAutomationNotificationEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveNotificationEventHandler: fn(
            self: *const IUIAutomation5,
            element: *IUIAutomationElement,
            handler: *IUIAutomationNotificationEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUIAutomation4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation5_AddNotificationEventHandler(self: *const T, element: *IUIAutomationElement, scope: TreeScope, cacheRequest: *IUIAutomationCacheRequest, handler: *IUIAutomationNotificationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation5.VTable, self.vtable).AddNotificationEventHandler(@ptrCast(*const IUIAutomation5, self), element, scope, cacheRequest, handler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IUIAutomation5_RemoveNotificationEventHandler(self: *const T, element: *IUIAutomationElement, handler: *IUIAutomationNotificationEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IUIAutomation5.VTable, self.vtable).RemoveNotificationEventHandler(@ptrCast(*const IUIAutomation5, self), element, handler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (123)
//--------------------------------------------------------------------------------
pub extern "USER32" fn RegisterPointerInputTarget(
    hwnd: HWND,
    pointerType: POINTER_INPUT_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn UnregisterPointerInputTarget(
    hwnd: HWND,
    pointerType: POINTER_INPUT_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn RegisterPointerInputTargetEx(
    hwnd: HWND,
    pointerType: POINTER_INPUT_TYPE,
    fObserve: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn UnregisterPointerInputTargetEx(
    hwnd: HWND,
    pointerType: POINTER_INPUT_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn NotifyWinEvent(
    event: u32,
    hwnd: HWND,
    idObject: i32,
    idChild: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "USER32" fn SetWinEventHook(
    eventMin: u32,
    eventMax: u32,
    hmodWinEventProc: ?*c_void,
    pfnWinEventProc: WINEVENTPROC,
    idProcess: u32,
    idThread: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HWINEVENTHOOK;

pub extern "USER32" fn IsWinEventHookInstalled(
    event: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn UnhookWinEvent(
    hWinEventHook: HWINEVENTHOOK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "OLEACC" fn LresultFromObject(
    riid: *const Guid,
    wParam: WPARAM,
    punk: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "OLEACC" fn ObjectFromLresult(
    lResult: LRESULT,
    riid: *const Guid,
    wParam: WPARAM,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn WindowFromAccessibleObject(
    param0: *IAccessible,
    phwnd: ?*HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn AccessibleObjectFromWindow(
    hwnd: HWND,
    dwId: u32,
    riid: *const Guid,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn AccessibleObjectFromEvent(
    hwnd: HWND,
    dwId: u32,
    dwChildId: u32,
    ppacc: **IAccessible,
    pvarChild: *VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn AccessibleObjectFromPoint(
    ptScreen: POINT,
    ppacc: **IAccessible,
    pvarChild: *VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn AccessibleChildren(
    paccContainer: *IAccessible,
    iChildStart: i32,
    cChildren: i32,
    rgvarChildren: [*]VARIANT,
    pcObtained: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn GetRoleTextA(
    lRole: u32,
    lpszRole: ?[*:0]u8,
    cchRoleMax: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEACC" fn GetRoleTextW(
    lRole: u32,
    lpszRole: ?[*:0]u16,
    cchRoleMax: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEACC" fn GetStateTextA(
    lStateBit: u32,
    lpszState: ?[*:0]u8,
    cchState: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEACC" fn GetStateTextW(
    lStateBit: u32,
    lpszState: ?[*:0]u16,
    cchState: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "OLEACC" fn GetOleaccVersionInfo(
    pVer: *u32,
    pBuild: *u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "OLEACC" fn CreateStdAccessibleObject(
    hwnd: HWND,
    idObject: i32,
    riid: *const Guid,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn CreateStdAccessibleProxyA(
    hwnd: HWND,
    pClassName: [*:0]const u8,
    idObject: i32,
    riid: *const Guid,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn CreateStdAccessibleProxyW(
    hwnd: HWND,
    pClassName: [*:0]const u16,
    idObject: i32,
    riid: *const Guid,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn AccSetRunningUtilityState(
    hwndApp: HWND,
    dwUtilityStateMask: u32,
    dwUtilityState: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "OLEACC" fn AccNotifyTouchInteraction(
    hwndApp: HWND,
    hwndTarget: HWND,
    ptTarget: POINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaGetErrorDescription(
    pDescription: *BSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UIAutomationCore" fn UiaHUiaNodeFromVariant(
    pvar: *VARIANT,
    phnode: **HUIANODE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaHPatternObjectFromVariant(
    pvar: *VARIANT,
    phobj: **HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaHTextRangeFromVariant(
    pvar: *VARIANT,
    phtextrange: **HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaNodeRelease(
    hnode: *HUIANODE__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UIAutomationCore" fn UiaGetPropertyValue(
    hnode: *HUIANODE__,
    propertyId: i32,
    pValue: *VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaGetPatternProvider(
    hnode: *HUIANODE__,
    patternId: i32,
    phobj: **HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaGetRuntimeId(
    hnode: *HUIANODE__,
    pruntimeId: **SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaSetFocus(
    hnode: *HUIANODE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaNavigate(
    hnode: *HUIANODE__,
    direction: NavigateDirection,
    pCondition: *UiaCondition,
    pRequest: *UiaCacheRequest,
    ppRequestedData: **SAFEARRAY,
    ppTreeStructure: *BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaGetUpdatedCache(
    hnode: *HUIANODE__,
    pRequest: *UiaCacheRequest,
    normalizeState: NormalizeState,
    pNormalizeCondition: *UiaCondition,
    ppRequestedData: **SAFEARRAY,
    ppTreeStructure: *BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaFind(
    hnode: *HUIANODE__,
    pParams: *UiaFindParams,
    pRequest: *UiaCacheRequest,
    ppRequestedData: **SAFEARRAY,
    ppOffsets: **SAFEARRAY,
    ppTreeStructures: **SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaNodeFromPoint(
    x: f64,
    y: f64,
    pRequest: *UiaCacheRequest,
    ppRequestedData: **SAFEARRAY,
    ppTreeStructure: *BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaNodeFromFocus(
    pRequest: *UiaCacheRequest,
    ppRequestedData: **SAFEARRAY,
    ppTreeStructure: *BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaNodeFromHandle(
    hwnd: HWND,
    phnode: **HUIANODE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaNodeFromProvider(
    pProvider: *IRawElementProviderSimple,
    phnode: **HUIANODE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaGetRootNode(
    phnode: **HUIANODE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaRegisterProviderCallback(
    pCallback: *UiaProviderCallback,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "UIAutomationCore" fn UiaLookupId(
    type: AutomationIdentifierType,
    pGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "UIAutomationCore" fn UiaGetReservedNotSupportedValue(
    punkNotSupportedValue: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaGetReservedMixedAttributeValue(
    punkMixedAttributeValue: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaClientsAreListening(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UIAutomationCore" fn UiaRaiseAutomationPropertyChangedEvent(
    pProvider: *IRawElementProviderSimple,
    id: i32,
    oldValue: VARIANT,
    newValue: VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaRaiseAutomationEvent(
    pProvider: *IRawElementProviderSimple,
    id: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaRaiseStructureChangedEvent(
    pProvider: *IRawElementProviderSimple,
    structureChangeType: StructureChangeType,
    pRuntimeId: *i32,
    cRuntimeIdLen: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaRaiseAsyncContentLoadedEvent(
    pProvider: *IRawElementProviderSimple,
    asyncContentLoadedState: AsyncContentLoadedState,
    percentComplete: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaRaiseTextEditTextChangedEvent(
    pProvider: *IRawElementProviderSimple,
    textEditChangeType: TextEditChangeType,
    pChangedData: *SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaRaiseChangesEvent(
    pProvider: *IRawElementProviderSimple,
    eventIdCount: i32,
    pUiaChanges: *UiaChangeInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaRaiseNotificationEvent(
    provider: *IRawElementProviderSimple,
    notificationKind: NotificationKind,
    notificationProcessing: NotificationProcessing,
    displayString: BSTR,
    activityId: BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaRaiseActiveTextPositionChangedEvent(
    provider: *IRawElementProviderSimple,
    textRange: ?*ITextRangeProvider,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaAddEvent(
    hnode: *HUIANODE__,
    eventId: i32,
    pCallback: *UiaEventCallback,
    scope: TreeScope,
    pProperties: *i32,
    cProperties: i32,
    pRequest: *UiaCacheRequest,
    phEvent: **HUIAEVENT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaRemoveEvent(
    hEvent: *HUIAEVENT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaEventAddWindow(
    hEvent: *HUIAEVENT__,
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaEventRemoveWindow(
    hEvent: *HUIAEVENT__,
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn DockPattern_SetDockPosition(
    hobj: *HUIAPATTERNOBJECT__,
    dockPosition: DockPosition,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn ExpandCollapsePattern_Collapse(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn ExpandCollapsePattern_Expand(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn GridPattern_GetItem(
    hobj: *HUIAPATTERNOBJECT__,
    row: i32,
    column: i32,
    pResult: **HUIANODE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn InvokePattern_Invoke(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn MultipleViewPattern_GetViewName(
    hobj: *HUIAPATTERNOBJECT__,
    viewId: i32,
    ppStr: *BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn MultipleViewPattern_SetCurrentView(
    hobj: *HUIAPATTERNOBJECT__,
    viewId: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn RangeValuePattern_SetValue(
    hobj: *HUIAPATTERNOBJECT__,
    val: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn ScrollItemPattern_ScrollIntoView(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn ScrollPattern_Scroll(
    hobj: *HUIAPATTERNOBJECT__,
    horizontalAmount: ScrollAmount,
    verticalAmount: ScrollAmount,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn ScrollPattern_SetScrollPercent(
    hobj: *HUIAPATTERNOBJECT__,
    horizontalPercent: f64,
    verticalPercent: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn SelectionItemPattern_AddToSelection(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn SelectionItemPattern_RemoveFromSelection(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn SelectionItemPattern_Select(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TogglePattern_Toggle(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TransformPattern_Move(
    hobj: *HUIAPATTERNOBJECT__,
    x: f64,
    y: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TransformPattern_Resize(
    hobj: *HUIAPATTERNOBJECT__,
    width: f64,
    height: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TransformPattern_Rotate(
    hobj: *HUIAPATTERNOBJECT__,
    degrees: f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn ValuePattern_SetValue(
    hobj: *HUIAPATTERNOBJECT__,
    pVal: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn WindowPattern_Close(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn WindowPattern_SetWindowVisualState(
    hobj: *HUIAPATTERNOBJECT__,
    state: WindowVisualState,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn WindowPattern_WaitForInputIdle(
    hobj: *HUIAPATTERNOBJECT__,
    milliseconds: i32,
    pResult: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextPattern_GetSelection(
    hobj: *HUIAPATTERNOBJECT__,
    pRetVal: **SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextPattern_GetVisibleRanges(
    hobj: *HUIAPATTERNOBJECT__,
    pRetVal: **SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextPattern_RangeFromChild(
    hobj: *HUIAPATTERNOBJECT__,
    hnodeChild: *HUIANODE__,
    pRetVal: **HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextPattern_RangeFromPoint(
    hobj: *HUIAPATTERNOBJECT__,
    point: UiaPoint,
    pRetVal: **HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextPattern_get_DocumentRange(
    hobj: *HUIAPATTERNOBJECT__,
    pRetVal: **HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextPattern_get_SupportedTextSelection(
    hobj: *HUIAPATTERNOBJECT__,
    pRetVal: *SupportedTextSelection,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_Clone(
    hobj: *HUIATEXTRANGE__,
    pRetVal: **HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_Compare(
    hobj: *HUIATEXTRANGE__,
    range: *HUIATEXTRANGE__,
    pRetVal: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_CompareEndpoints(
    hobj: *HUIATEXTRANGE__,
    endpoint: TextPatternRangeEndpoint,
    targetRange: *HUIATEXTRANGE__,
    targetEndpoint: TextPatternRangeEndpoint,
    pRetVal: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_ExpandToEnclosingUnit(
    hobj: *HUIATEXTRANGE__,
    unit: TextUnit,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_GetAttributeValue(
    hobj: *HUIATEXTRANGE__,
    attributeId: i32,
    pRetVal: *VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_FindAttribute(
    hobj: *HUIATEXTRANGE__,
    attributeId: i32,
    val: VARIANT,
    backward: BOOL,
    pRetVal: **HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_FindText(
    hobj: *HUIATEXTRANGE__,
    text: BSTR,
    backward: BOOL,
    ignoreCase: BOOL,
    pRetVal: **HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_GetBoundingRectangles(
    hobj: *HUIATEXTRANGE__,
    pRetVal: **SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_GetEnclosingElement(
    hobj: *HUIATEXTRANGE__,
    pRetVal: **HUIANODE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_GetText(
    hobj: *HUIATEXTRANGE__,
    maxLength: i32,
    pRetVal: *BSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_Move(
    hobj: *HUIATEXTRANGE__,
    unit: TextUnit,
    count: i32,
    pRetVal: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_MoveEndpointByUnit(
    hobj: *HUIATEXTRANGE__,
    endpoint: TextPatternRangeEndpoint,
    unit: TextUnit,
    count: i32,
    pRetVal: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_MoveEndpointByRange(
    hobj: *HUIATEXTRANGE__,
    endpoint: TextPatternRangeEndpoint,
    targetRange: *HUIATEXTRANGE__,
    targetEndpoint: TextPatternRangeEndpoint,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_Select(
    hobj: *HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_AddToSelection(
    hobj: *HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_RemoveFromSelection(
    hobj: *HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_ScrollIntoView(
    hobj: *HUIATEXTRANGE__,
    alignToTop: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn TextRange_GetChildren(
    hobj: *HUIATEXTRANGE__,
    pRetVal: **SAFEARRAY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn ItemContainerPattern_FindItemByProperty(
    hobj: *HUIAPATTERNOBJECT__,
    hnodeStartAfter: *HUIANODE__,
    propertyId: i32,
    value: VARIANT,
    pFound: **HUIANODE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn LegacyIAccessiblePattern_Select(
    hobj: *HUIAPATTERNOBJECT__,
    flagsSelect: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn LegacyIAccessiblePattern_DoDefaultAction(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn LegacyIAccessiblePattern_SetValue(
    hobj: *HUIAPATTERNOBJECT__,
    szValue: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn LegacyIAccessiblePattern_GetIAccessible(
    hobj: *HUIAPATTERNOBJECT__,
    pAccessible: **IAccessible,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn SynchronizedInputPattern_StartListening(
    hobj: *HUIAPATTERNOBJECT__,
    inputType: SynchronizedInputType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn SynchronizedInputPattern_Cancel(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn VirtualizedItemPattern_Realize(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaPatternRelease(
    hobj: *HUIAPATTERNOBJECT__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UIAutomationCore" fn UiaTextRangeRelease(
    hobj: *HUIATEXTRANGE__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UIAutomationCore" fn UiaReturnRawElementProvider(
    hwnd: HWND,
    wParam: WPARAM,
    lParam: LPARAM,
    el: *IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "UIAutomationCore" fn UiaHostProviderFromHwnd(
    hwnd: HWND,
    ppProvider: **IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaProviderForNonClient(
    hwnd: HWND,
    idObject: i32,
    idChild: i32,
    ppProvider: **IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaIAccessibleFromProvider(
    pProvider: *IRawElementProviderSimple,
    dwFlags: u32,
    ppAccessible: **IAccessible,
    pvarChild: *VARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaProviderFromIAccessible(
    pAccessible: *IAccessible,
    idChild: i32,
    dwFlags: u32,
    ppProvider: **IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaDisconnectAllProviders(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaDisconnectProvider(
    pProvider: *IRawElementProviderSimple,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UIAutomationCore" fn UiaHasServerSideProvider(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (6)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const SERIALKEYS = SERIALKEYSA;
        pub const HIGHCONTRAST = HIGHCONTRASTA;
        pub const SOUNDSENTRY = SOUNDSENTRYA;
        pub const GetRoleText = GetRoleTextA;
        pub const GetStateText = GetStateTextA;
        pub const CreateStdAccessibleProxy = CreateStdAccessibleProxyA;
    },
    .wide => struct {
        pub const SERIALKEYS = SERIALKEYSW;
        pub const HIGHCONTRAST = HIGHCONTRASTW;
        pub const SOUNDSENTRY = SOUNDSENTRYW;
        pub const GetRoleText = GetRoleTextW;
        pub const GetStateText = GetStateTextW;
        pub const CreateStdAccessibleProxy = CreateStdAccessibleProxyW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const SERIALKEYS = *opaque{};
        pub const HIGHCONTRAST = *opaque{};
        pub const SOUNDSENTRY = *opaque{};
        pub const GetRoleText = *opaque{};
        pub const GetStateText = *opaque{};
        pub const CreateStdAccessibleProxy = *opaque{};
    } else struct {
        pub const SERIALKEYS = @compileError("'SERIALKEYS' requires that UNICODE be set to true or false in the root module");
        pub const HIGHCONTRAST = @compileError("'HIGHCONTRAST' requires that UNICODE be set to true or false in the root module");
        pub const SOUNDSENTRY = @compileError("'SOUNDSENTRY' requires that UNICODE be set to true or false in the root module");
        pub const GetRoleText = @compileError("'GetRoleText' requires that UNICODE be set to true or false in the root module");
        pub const GetStateText = @compileError("'GetStateText' requires that UNICODE be set to true or false in the root module");
        pub const CreateStdAccessibleProxy = @compileError("'CreateStdAccessibleProxy' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (22)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IDispatch = @import("automation.zig").IDispatch;
const SAFEARRAY = @import("automation.zig").SAFEARRAY;
const PWSTR = @import("system_services.zig").PWSTR;
const ITextStoreACPSink = @import("text_services.zig").ITextStoreACPSink;
const ITextStoreAnchorSink = @import("text_services.zig").ITextStoreAnchorSink;
const IUnknown = @import("com.zig").IUnknown;
const IAnchor = @import("text_services.zig").IAnchor;
const HRESULT = @import("com.zig").HRESULT;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const BSTR = @import("automation.zig").BSTR;
const PSTR = @import("system_services.zig").PSTR;
const RECT = @import("display_devices.zig").RECT;
const IEnumUnknown = @import("com.zig").IEnumUnknown;
const HWND = @import("windows_and_messaging.zig").HWND;
const BOOL = @import("system_services.zig").BOOL;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const LRESULT = @import("system_services.zig").LRESULT;
const VARIANT = @import("automation.zig").VARIANT;
const HMENU = @import("menus_and_resources.zig").HMENU;
const POINTER_INPUT_TYPE = @import("menus_and_resources.zig").POINTER_INPUT_TYPE;
const POINT = @import("display_devices.zig").POINT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = WINEVENTPROC;
    _ = LPFNLRESULTFROMOBJECT;
    _ = LPFNOBJECTFROMLRESULT;
    _ = LPFNACCESSIBLEOBJECTFROMWINDOW;
    _ = LPFNACCESSIBLEOBJECTFROMPOINT;
    _ = LPFNCREATESTDACCESSIBLEOBJECT;
    _ = LPFNACCESSIBLECHILDREN;
    _ = UiaProviderCallback;
    _ = UiaEventCallback;

    const constant_export_count = 392;
    const type_export_count = 240;
    const enum_value_export_count = 275;
    const com_iface_id_export_count = 147;
    const com_class_id_export_count = 10;
    const func_export_count = 123;
    const unicode_alias_count = 6;
    const import_count = 22;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
