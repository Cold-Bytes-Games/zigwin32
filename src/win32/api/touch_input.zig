//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (3)
//--------------------------------------------------------------------------------
pub const POSITIVE_INFINITY = @import("std").math.inf(f32);
pub const NEGATIVE_INFINITY = -@import("std").math.inf(f32);
pub const NaN = @import("std").math.nan(f32);

//--------------------------------------------------------------------------------
// Section: Types (12)
//--------------------------------------------------------------------------------
pub const TOUCHINPUT = extern struct {
    x: i32,
    y: i32,
    hSource: HANDLE,
    dwID: u32,
    dwFlags: u32,
    dwMask: u32,
    dwTime: u32,
    dwExtraInfo: ?*c_void,
    cxContact: u32,
    cyContact: u32,
};

pub const GESTUREINFO = extern struct {
    cbSize: u32,
    dwFlags: u32,
    dwID: u32,
    hwndTarget: HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
    dwSequenceID: u32,
    ullArguments: u64,
    cbExtraArgs: u32,
};

pub const GESTURENOTIFYSTRUCT = extern struct {
    cbSize: u32,
    dwFlags: u32,
    hwndTarget: HWND,
    ptsLocation: POINTS,
    dwInstanceID: u32,
};

pub const GESTURECONFIG = extern struct {
    dwID: u32,
    dwWant: u32,
    dwBlock: u32,
};

pub const HGESTUREINFO = ?*c_void;

pub const HTOUCHINPUT = ?*c_void;

const CLSID_InertiaProcessor_Value = @import("../zig.zig").Guid.initString("ABB27087-4CE0-4E58-A0CB-E24DF96814BE");
pub const CLSID_InertiaProcessor = &CLSID_InertiaProcessor_Value;

const CLSID_ManipulationProcessor_Value = @import("../zig.zig").Guid.initString("597D4FB0-47FD-4AFF-89B9-C6CFAE8CF08E");
pub const CLSID_ManipulationProcessor = &CLSID_ManipulationProcessor_Value;

pub const MANIPULATION_PROCESSOR_MANIPULATIONS = extern enum(i32) {
    MANIPULATION_NONE = 0,
    MANIPULATION_TRANSLATE_X = 1,
    MANIPULATION_TRANSLATE_Y = 2,
    MANIPULATION_SCALE = 4,
    MANIPULATION_ROTATE = 8,
    MANIPULATION_ALL = 15,
};
pub const MANIPULATION_NONE = MANIPULATION_PROCESSOR_MANIPULATIONS.MANIPULATION_NONE;
pub const MANIPULATION_TRANSLATE_X = MANIPULATION_PROCESSOR_MANIPULATIONS.MANIPULATION_TRANSLATE_X;
pub const MANIPULATION_TRANSLATE_Y = MANIPULATION_PROCESSOR_MANIPULATIONS.MANIPULATION_TRANSLATE_Y;
pub const MANIPULATION_SCALE = MANIPULATION_PROCESSOR_MANIPULATIONS.MANIPULATION_SCALE;
pub const MANIPULATION_ROTATE = MANIPULATION_PROCESSOR_MANIPULATIONS.MANIPULATION_ROTATE;
pub const MANIPULATION_ALL = MANIPULATION_PROCESSOR_MANIPULATIONS.MANIPULATION_ALL;

const IID__IManipulationEvents_Value = @import("../zig.zig").Guid.initString("4F62C8DA-9C53-4B22-93DF-927A862BBB03");
pub const IID__IManipulationEvents = &IID__IManipulationEvents_Value;
pub const _IManipulationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ManipulationStarted: fn(
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ManipulationDelta: fn(
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
            translationDeltaX: f32,
            translationDeltaY: f32,
            scaleDelta: f32,
            expansionDelta: f32,
            rotationDelta: f32,
            cumulativeTranslationX: f32,
            cumulativeTranslationY: f32,
            cumulativeScale: f32,
            cumulativeExpansion: f32,
            cumulativeRotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ManipulationCompleted: fn(
            self: *const _IManipulationEvents,
            x: f32,
            y: f32,
            cumulativeTranslationX: f32,
            cumulativeTranslationY: f32,
            cumulativeScale: f32,
            cumulativeExpansion: f32,
            cumulativeRotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _IManipulationEvents_ManipulationStarted(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _IManipulationEvents.VTable, self.vtable).ManipulationStarted(@ptrCast(*const _IManipulationEvents, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _IManipulationEvents_ManipulationDelta(self: *const T, x: f32, y: f32, translationDeltaX: f32, translationDeltaY: f32, scaleDelta: f32, expansionDelta: f32, rotationDelta: f32, cumulativeTranslationX: f32, cumulativeTranslationY: f32, cumulativeScale: f32, cumulativeExpansion: f32, cumulativeRotation: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _IManipulationEvents.VTable, self.vtable).ManipulationDelta(@ptrCast(*const _IManipulationEvents, self), x, y, translationDeltaX, translationDeltaY, scaleDelta, expansionDelta, rotationDelta, cumulativeTranslationX, cumulativeTranslationY, cumulativeScale, cumulativeExpansion, cumulativeRotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn _IManipulationEvents_ManipulationCompleted(self: *const T, x: f32, y: f32, cumulativeTranslationX: f32, cumulativeTranslationY: f32, cumulativeScale: f32, cumulativeExpansion: f32, cumulativeRotation: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const _IManipulationEvents.VTable, self.vtable).ManipulationCompleted(@ptrCast(*const _IManipulationEvents, self), x, y, cumulativeTranslationX, cumulativeTranslationY, cumulativeScale, cumulativeExpansion, cumulativeRotation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IInertiaProcessor_Value = @import("../zig.zig").Guid.initString("18B00C6D-C5EE-41B1-90A9-9D4A929095AD");
pub const IID_IInertiaProcessor = &IID_IInertiaProcessor_Value;
pub const IInertiaProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_InitialOriginX: fn(
            self: *const IInertiaProcessor,
            x: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_InitialOriginX: fn(
            self: *const IInertiaProcessor,
            x: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InitialOriginY: fn(
            self: *const IInertiaProcessor,
            y: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_InitialOriginY: fn(
            self: *const IInertiaProcessor,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InitialVelocityX: fn(
            self: *const IInertiaProcessor,
            x: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_InitialVelocityX: fn(
            self: *const IInertiaProcessor,
            x: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InitialVelocityY: fn(
            self: *const IInertiaProcessor,
            y: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_InitialVelocityY: fn(
            self: *const IInertiaProcessor,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InitialAngularVelocity: fn(
            self: *const IInertiaProcessor,
            velocity: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_InitialAngularVelocity: fn(
            self: *const IInertiaProcessor,
            velocity: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InitialExpansionVelocity: fn(
            self: *const IInertiaProcessor,
            velocity: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_InitialExpansionVelocity: fn(
            self: *const IInertiaProcessor,
            velocity: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InitialRadius: fn(
            self: *const IInertiaProcessor,
            radius: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_InitialRadius: fn(
            self: *const IInertiaProcessor,
            radius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BoundaryLeft: fn(
            self: *const IInertiaProcessor,
            left: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_BoundaryLeft: fn(
            self: *const IInertiaProcessor,
            left: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BoundaryTop: fn(
            self: *const IInertiaProcessor,
            top: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_BoundaryTop: fn(
            self: *const IInertiaProcessor,
            top: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BoundaryRight: fn(
            self: *const IInertiaProcessor,
            right: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_BoundaryRight: fn(
            self: *const IInertiaProcessor,
            right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BoundaryBottom: fn(
            self: *const IInertiaProcessor,
            bottom: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_BoundaryBottom: fn(
            self: *const IInertiaProcessor,
            bottom: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ElasticMarginLeft: fn(
            self: *const IInertiaProcessor,
            left: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ElasticMarginLeft: fn(
            self: *const IInertiaProcessor,
            left: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ElasticMarginTop: fn(
            self: *const IInertiaProcessor,
            top: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ElasticMarginTop: fn(
            self: *const IInertiaProcessor,
            top: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ElasticMarginRight: fn(
            self: *const IInertiaProcessor,
            right: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ElasticMarginRight: fn(
            self: *const IInertiaProcessor,
            right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ElasticMarginBottom: fn(
            self: *const IInertiaProcessor,
            bottom: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ElasticMarginBottom: fn(
            self: *const IInertiaProcessor,
            bottom: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DesiredDisplacement: fn(
            self: *const IInertiaProcessor,
            displacement: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_DesiredDisplacement: fn(
            self: *const IInertiaProcessor,
            displacement: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DesiredRotation: fn(
            self: *const IInertiaProcessor,
            rotation: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_DesiredRotation: fn(
            self: *const IInertiaProcessor,
            rotation: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DesiredExpansion: fn(
            self: *const IInertiaProcessor,
            expansion: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_DesiredExpansion: fn(
            self: *const IInertiaProcessor,
            expansion: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DesiredDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_DesiredDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DesiredAngularDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_DesiredAngularDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DesiredExpansionDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_DesiredExpansionDeceleration: fn(
            self: *const IInertiaProcessor,
            deceleration: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_InitialTimestamp: fn(
            self: *const IInertiaProcessor,
            timestamp: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_InitialTimestamp: fn(
            self: *const IInertiaProcessor,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IInertiaProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Process: fn(
            self: *const IInertiaProcessor,
            completed: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessTime: fn(
            self: *const IInertiaProcessor,
            timestamp: u32,
            completed: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Complete: fn(
            self: *const IInertiaProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompleteTime: fn(
            self: *const IInertiaProcessor,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialOriginX(self: *const T, x: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialOriginX(@ptrCast(*const IInertiaProcessor, self), x);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialOriginX(self: *const T, x: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialOriginX(@ptrCast(*const IInertiaProcessor, self), x);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialOriginY(self: *const T, y: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialOriginY(@ptrCast(*const IInertiaProcessor, self), y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialOriginY(self: *const T, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialOriginY(@ptrCast(*const IInertiaProcessor, self), y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialVelocityX(self: *const T, x: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialVelocityX(@ptrCast(*const IInertiaProcessor, self), x);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialVelocityX(self: *const T, x: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialVelocityX(@ptrCast(*const IInertiaProcessor, self), x);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialVelocityY(self: *const T, y: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialVelocityY(@ptrCast(*const IInertiaProcessor, self), y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialVelocityY(self: *const T, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialVelocityY(@ptrCast(*const IInertiaProcessor, self), y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialAngularVelocity(self: *const T, velocity: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialAngularVelocity(@ptrCast(*const IInertiaProcessor, self), velocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialAngularVelocity(self: *const T, velocity: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialAngularVelocity(@ptrCast(*const IInertiaProcessor, self), velocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialExpansionVelocity(self: *const T, velocity: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialExpansionVelocity(@ptrCast(*const IInertiaProcessor, self), velocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialExpansionVelocity(self: *const T, velocity: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialExpansionVelocity(@ptrCast(*const IInertiaProcessor, self), velocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialRadius(self: *const T, radius: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialRadius(@ptrCast(*const IInertiaProcessor, self), radius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialRadius(self: *const T, radius: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialRadius(@ptrCast(*const IInertiaProcessor, self), radius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_BoundaryLeft(self: *const T, left: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_BoundaryLeft(@ptrCast(*const IInertiaProcessor, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_BoundaryLeft(self: *const T, left: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_BoundaryLeft(@ptrCast(*const IInertiaProcessor, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_BoundaryTop(self: *const T, top: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_BoundaryTop(@ptrCast(*const IInertiaProcessor, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_BoundaryTop(self: *const T, top: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_BoundaryTop(@ptrCast(*const IInertiaProcessor, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_BoundaryRight(self: *const T, right: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_BoundaryRight(@ptrCast(*const IInertiaProcessor, self), right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_BoundaryRight(self: *const T, right: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_BoundaryRight(@ptrCast(*const IInertiaProcessor, self), right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_BoundaryBottom(self: *const T, bottom: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_BoundaryBottom(@ptrCast(*const IInertiaProcessor, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_BoundaryBottom(self: *const T, bottom: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_BoundaryBottom(@ptrCast(*const IInertiaProcessor, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_ElasticMarginLeft(self: *const T, left: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_ElasticMarginLeft(@ptrCast(*const IInertiaProcessor, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_ElasticMarginLeft(self: *const T, left: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_ElasticMarginLeft(@ptrCast(*const IInertiaProcessor, self), left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_ElasticMarginTop(self: *const T, top: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_ElasticMarginTop(@ptrCast(*const IInertiaProcessor, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_ElasticMarginTop(self: *const T, top: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_ElasticMarginTop(@ptrCast(*const IInertiaProcessor, self), top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_ElasticMarginRight(self: *const T, right: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_ElasticMarginRight(@ptrCast(*const IInertiaProcessor, self), right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_ElasticMarginRight(self: *const T, right: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_ElasticMarginRight(@ptrCast(*const IInertiaProcessor, self), right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_ElasticMarginBottom(self: *const T, bottom: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_ElasticMarginBottom(@ptrCast(*const IInertiaProcessor, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_ElasticMarginBottom(self: *const T, bottom: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_ElasticMarginBottom(@ptrCast(*const IInertiaProcessor, self), bottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredDisplacement(self: *const T, displacement: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredDisplacement(@ptrCast(*const IInertiaProcessor, self), displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredDisplacement(self: *const T, displacement: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredDisplacement(@ptrCast(*const IInertiaProcessor, self), displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredRotation(self: *const T, rotation: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredRotation(@ptrCast(*const IInertiaProcessor, self), rotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredRotation(self: *const T, rotation: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredRotation(@ptrCast(*const IInertiaProcessor, self), rotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredExpansion(self: *const T, expansion: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredExpansion(@ptrCast(*const IInertiaProcessor, self), expansion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredExpansion(self: *const T, expansion: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredExpansion(@ptrCast(*const IInertiaProcessor, self), expansion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredDeceleration(self: *const T, deceleration: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredDeceleration(self: *const T, deceleration: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredAngularDeceleration(self: *const T, deceleration: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredAngularDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredAngularDeceleration(self: *const T, deceleration: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredAngularDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_DesiredExpansionDeceleration(self: *const T, deceleration: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_DesiredExpansionDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_DesiredExpansionDeceleration(self: *const T, deceleration: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_DesiredExpansionDeceleration(@ptrCast(*const IInertiaProcessor, self), deceleration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_get_InitialTimestamp(self: *const T, timestamp: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).get_InitialTimestamp(@ptrCast(*const IInertiaProcessor, self), timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_put_InitialTimestamp(self: *const T, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).put_InitialTimestamp(@ptrCast(*const IInertiaProcessor, self), timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).Reset(@ptrCast(*const IInertiaProcessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_Process(self: *const T, completed: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).Process(@ptrCast(*const IInertiaProcessor, self), completed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_ProcessTime(self: *const T, timestamp: u32, completed: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).ProcessTime(@ptrCast(*const IInertiaProcessor, self), timestamp, completed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_Complete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).Complete(@ptrCast(*const IInertiaProcessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IInertiaProcessor_CompleteTime(self: *const T, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IInertiaProcessor.VTable, self.vtable).CompleteTime(@ptrCast(*const IInertiaProcessor, self), timestamp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IManipulationProcessor_Value = @import("../zig.zig").Guid.initString("A22AC519-8300-48A0-BEF4-F1BE8737DBA4");
pub const IID_IManipulationProcessor = &IID_IManipulationProcessor_Value;
pub const IManipulationProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_SupportedManipulations: fn(
            self: *const IManipulationProcessor,
            manipulations: *MANIPULATION_PROCESSOR_MANIPULATIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_SupportedManipulations: fn(
            self: *const IManipulationProcessor,
            manipulations: MANIPULATION_PROCESSOR_MANIPULATIONS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_PivotPointX: fn(
            self: *const IManipulationProcessor,
            pivotPointX: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_PivotPointX: fn(
            self: *const IManipulationProcessor,
            pivotPointX: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_PivotPointY: fn(
            self: *const IManipulationProcessor,
            pivotPointY: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_PivotPointY: fn(
            self: *const IManipulationProcessor,
            pivotPointY: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_PivotRadius: fn(
            self: *const IManipulationProcessor,
            pivotRadius: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_PivotRadius: fn(
            self: *const IManipulationProcessor,
            pivotRadius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompleteManipulation: fn(
            self: *const IManipulationProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessDown: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMove: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUp: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessDownWithTime: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMoveWithTime: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessUpWithTime: fn(
            self: *const IManipulationProcessor,
            manipulatorId: u32,
            x: f32,
            y: f32,
            timestamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVelocityX: fn(
            self: *const IManipulationProcessor,
            velocityX: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVelocityY: fn(
            self: *const IManipulationProcessor,
            velocityY: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpansionVelocity: fn(
            self: *const IManipulationProcessor,
            expansionVelocity: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAngularVelocity: fn(
            self: *const IManipulationProcessor,
            angularVelocity: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_MinimumScaleRotateRadius: fn(
            self: *const IManipulationProcessor,
            minRadius: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_MinimumScaleRotateRadius: fn(
            self: *const IManipulationProcessor,
            minRadius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_SupportedManipulations(self: *const T, manipulations: *MANIPULATION_PROCESSOR_MANIPULATIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_SupportedManipulations(@ptrCast(*const IManipulationProcessor, self), manipulations);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_SupportedManipulations(self: *const T, manipulations: MANIPULATION_PROCESSOR_MANIPULATIONS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_SupportedManipulations(@ptrCast(*const IManipulationProcessor, self), manipulations);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_PivotPointX(self: *const T, pivotPointX: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_PivotPointX(@ptrCast(*const IManipulationProcessor, self), pivotPointX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_PivotPointX(self: *const T, pivotPointX: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_PivotPointX(@ptrCast(*const IManipulationProcessor, self), pivotPointX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_PivotPointY(self: *const T, pivotPointY: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_PivotPointY(@ptrCast(*const IManipulationProcessor, self), pivotPointY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_PivotPointY(self: *const T, pivotPointY: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_PivotPointY(@ptrCast(*const IManipulationProcessor, self), pivotPointY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_PivotRadius(self: *const T, pivotRadius: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_PivotRadius(@ptrCast(*const IManipulationProcessor, self), pivotRadius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_PivotRadius(self: *const T, pivotRadius: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_PivotRadius(@ptrCast(*const IManipulationProcessor, self), pivotRadius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_CompleteManipulation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).CompleteManipulation(@ptrCast(*const IManipulationProcessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessDown(self: *const T, manipulatorId: u32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessDown(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessMove(self: *const T, manipulatorId: u32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessMove(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessUp(self: *const T, manipulatorId: u32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessUp(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessDownWithTime(self: *const T, manipulatorId: u32, x: f32, y: f32, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessDownWithTime(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y, timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessMoveWithTime(self: *const T, manipulatorId: u32, x: f32, y: f32, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessMoveWithTime(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y, timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_ProcessUpWithTime(self: *const T, manipulatorId: u32, x: f32, y: f32, timestamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).ProcessUpWithTime(@ptrCast(*const IManipulationProcessor, self), manipulatorId, x, y, timestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_GetVelocityX(self: *const T, velocityX: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).GetVelocityX(@ptrCast(*const IManipulationProcessor, self), velocityX);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_GetVelocityY(self: *const T, velocityY: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).GetVelocityY(@ptrCast(*const IManipulationProcessor, self), velocityY);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_GetExpansionVelocity(self: *const T, expansionVelocity: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).GetExpansionVelocity(@ptrCast(*const IManipulationProcessor, self), expansionVelocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_GetAngularVelocity(self: *const T, angularVelocity: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).GetAngularVelocity(@ptrCast(*const IManipulationProcessor, self), angularVelocity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_get_MinimumScaleRotateRadius(self: *const T, minRadius: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).get_MinimumScaleRotateRadius(@ptrCast(*const IManipulationProcessor, self), minRadius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IManipulationProcessor_put_MinimumScaleRotateRadius(self: *const T, minRadius: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IManipulationProcessor.VTable, self.vtable).put_MinimumScaleRotateRadius(@ptrCast(*const IManipulationProcessor, self), minRadius);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (10)
//--------------------------------------------------------------------------------
pub extern "USER32" fn GetTouchInputInfo(
    hTouchInput: HTOUCHINPUT,
    cInputs: u32,
    pInputs: [*]TOUCHINPUT,
    cbSize: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn CloseTouchInputHandle(
    hTouchInput: HTOUCHINPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn RegisterTouchWindow(
    hwnd: HWND,
    ulFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn UnregisterTouchWindow(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IsTouchWindow(
    hwnd: HWND,
    pulFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetGestureInfo(
    hGestureInfo: HGESTUREINFO,
    pGestureInfo: *GESTUREINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetGestureExtraArgs(
    hGestureInfo: HGESTUREINFO,
    cbExtraArgs: u32,
    pExtraArgs: [*:0]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn CloseGestureInfoHandle(
    hGestureInfo: HGESTUREINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn SetGestureConfig(
    hwnd: HWND,
    dwReserved: u32,
    cIDs: u32,
    pGestureConfig: [*]GESTURECONFIG,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetGestureConfig(
    hwnd: HWND,
    dwReserved: u32,
    dwFlags: u32,
    pcIDs: *u32,
    pGestureConfig: [*]GESTURECONFIG,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (6)
//--------------------------------------------------------------------------------
const HRESULT = @import("com.zig").HRESULT;
const BOOL = @import("system_services.zig").BOOL;
const HANDLE = @import("system_services.zig").HANDLE;
const POINTS = @import("display_devices.zig").POINTS;
const HWND = @import("windows_and_messaging.zig").HWND;
const IUnknown = @import("com.zig").IUnknown;

test {
    const constant_export_count = 3;
    const type_export_count = 10;
    const enum_value_export_count = 6;
    const com_iface_id_export_count = 3;
    const com_class_id_export_count = 2;
    const func_export_count = 10;
    const unicode_alias_count = 0;
    const import_count = 6;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
