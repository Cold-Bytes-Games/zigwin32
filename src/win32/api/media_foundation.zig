//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (579)
//--------------------------------------------------------------------------------
pub const g_wszSpeechFormatCaps = "SpeechFormatCap";
pub const g_wszWMCPCodecName = "_CODECNAME";
pub const g_wszWMCPSupportedVBRModes = "_SUPPORTEDVBRMODES";
pub const g_wszWMCPAudioVBRSupported = "_VBRENABLED";
pub const g_wszWMCPAudioVBRQuality = "_VBRQUALITY";
pub const g_wszWMCPMaxPasses = "_PASSESRECOMMENDED";
pub const g_wszWMCPDefaultCrisp = "_DEFAULTCRISP";
pub const COPP_ProtectionType_Unknown : i32 = -2147483648;
pub const COPP_ProtectionType_None : i32 = 0;
pub const COPP_ProtectionType_HDCP : i32 = 1;
pub const COPP_ProtectionType_ACP : i32 = 2;
pub const COPP_ProtectionType_CGMSA : i32 = 4;
pub const COPP_ProtectionType_Mask : i32 = -2147483641;
pub const COPP_ProtectionType_Reserved : i32 = 2147483640;
pub const MF_BYTESTREAM_ORIGIN_NAME = @import("../zig.zig").Guid.initString("fc358288-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_CONTENT_TYPE = @import("../zig.zig").Guid.initString("fc358289-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_DURATION = @import("../zig.zig").Guid.initString("fc35828a-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_LAST_MODIFIED_TIME = @import("../zig.zig").Guid.initString("fc35828b-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_IFO_FILE_URI = @import("../zig.zig").Guid.initString("fc35828c-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_DLNA_PROFILE_ID = @import("../zig.zig").Guid.initString("fc35828d-3cb6-460c-a424-b6681260375a");
pub const MF_BYTESTREAM_EFFECTIVE_URL = @import("../zig.zig").Guid.initString("9afa0209-89d1-42af-8456-1de6b562d691");
pub const MF_BYTESTREAM_TRANSCODED = @import("../zig.zig").Guid.initString("b6c5c282-4dc9-4db9-ab48-cf3b6d8bc5e0");
pub const CLSID_MFByteStreamProxyClassFactory = @import("../zig.zig").Guid.initString("770e8e77-4916-441c-a9a7-b342d0eebc71");
pub const MEDeviceStreamCreated = @import("../zig.zig").Guid.initString("0252a1cf-3540-43b4-9164-d72eb405fa40");
pub const MF_SA_D3D_AWARE = @import("../zig.zig").Guid.initString("eaa35c29-775e-488e-9b61-b3283e49583b");
pub const MF_SA_REQUIRED_SAMPLE_COUNT = @import("../zig.zig").Guid.initString("18802c61-324b-4952-abd0-176ff5c696ff");
pub const MFT_END_STREAMING_AWARE = @import("../zig.zig").Guid.initString("70fbc845-b07e-4089-b064-399dc6110f29");
pub const MF_SA_AUDIO_ENDPOINT_AWARE = @import("../zig.zig").Guid.initString("c0381701-805c-42b2-ac8d-e2b4bf21f4f8");
pub const MFT_AUDIO_DECODER_AUDIO_ENDPOINT_ID = @import("../zig.zig").Guid.initString("c7ccdd6e-5398-4695-8be7-51b3e95111bd");
pub const MFT_AUDIO_DECODER_SPATIAL_METADATA_CLIENT = @import("../zig.zig").Guid.initString("05987df4-1270-4999-925f-8e939a7c0af7");
pub const MF_DMFT_FRAME_BUFFER_INFO = @import("../zig.zig").Guid.initString("396ce1c9-67a9-454c-8797-95a45799d804");
pub const MF_SA_REQUIRED_SAMPLE_COUNT_PROGRESSIVE = @import("../zig.zig").Guid.initString("b172d58e-fa77-4e48-8d2a-1df2d850eac2");
pub const MF_SA_MINIMUM_OUTPUT_SAMPLE_COUNT = @import("../zig.zig").Guid.initString("851745d5-c3d6-476d-9527-498ef2d10d18");
pub const MF_SA_MINIMUM_OUTPUT_SAMPLE_COUNT_PROGRESSIVE = @import("../zig.zig").Guid.initString("0f5523a5-1cb2-47c5-a550-2eeb84b4d14a");
pub const MFT_SUPPORT_3DVIDEO = @import("../zig.zig").Guid.initString("093f81b1-4f2e-4631-8168-7934032a01d3");
pub const MF_ENABLE_3DVIDEO_OUTPUT = @import("../zig.zig").Guid.initString("bdad7bca-0e5f-4b10-ab16-26de381b6293");
pub const MF_SA_D3D11_BINDFLAGS = @import("../zig.zig").Guid.initString("eacf97ad-065c-4408-bee3-fdcbfd128be2");
pub const MF_SA_D3D11_USAGE = @import("../zig.zig").Guid.initString("e85fe442-2ca3-486e-a9c7-109dda609880");
pub const MF_SA_D3D11_AWARE = @import("../zig.zig").Guid.initString("206b4fc8-fcf9-4c51-afe3-9764369e33a0");
pub const MF_SA_D3D11_SHARED = @import("../zig.zig").Guid.initString("7b8f32c3-6d96-4b89-9203-dd38b61414f3");
pub const MF_SA_D3D11_SHARED_WITHOUT_MUTEX = @import("../zig.zig").Guid.initString("39dbd44d-2e44-4931-a4c8-352d3dc42115");
pub const MF_SA_D3D11_ALLOW_DYNAMIC_YUV_TEXTURE = @import("../zig.zig").Guid.initString("ce06d49f-0613-4b9d-86a6-d8c4f9c10075");
pub const MF_SA_D3D11_HW_PROTECTED = @import("../zig.zig").Guid.initString("3a8ba9d9-92ca-4307-a391-6999dbf3b6ce");
pub const MF_SA_BUFFERS_PER_SAMPLE = @import("../zig.zig").Guid.initString("873c5171-1e3d-4e25-988d-b433ce041983");
pub const MFT_DECODER_EXPOSE_OUTPUT_TYPES_IN_NATIVE_ORDER = @import("../zig.zig").Guid.initString("ef80833f-f8fa-44d9-80d8-41ed6232670c");
pub const MFT_DECODER_QUALITY_MANAGEMENT_CUSTOM_CONTROL = @import("../zig.zig").Guid.initString("a24e30d7-de25-4558-bbfb-71070a2d332e");
pub const MFT_DECODER_QUALITY_MANAGEMENT_RECOVERY_WITHOUT_ARTIFACTS = @import("../zig.zig").Guid.initString("d8980deb-0a48-425f-8623-611db41d3810");
pub const MFT_REMUX_MARK_I_PICTURE_AS_CLEAN_POINT = @import("../zig.zig").Guid.initString("364e8f85-3f2e-436c-b2a2-4440a012a9e8");
pub const MFT_DECODER_FINAL_VIDEO_RESOLUTION_HINT = @import("../zig.zig").Guid.initString("dc2f8496-15c4-407a-b6f0-1b66ab5fbf53");
pub const MFT_ENCODER_SUPPORTS_CONFIG_EVENT = @import("../zig.zig").Guid.initString("86a355ae-3a77-4ec4-9f31-01149a4e92de");
pub const MFT_ENUM_HARDWARE_VENDOR_ID_Attribute = @import("../zig.zig").Guid.initString("3aecb0cc-035b-4bcc-8185-2b8d551ef3af");
pub const MF_TRANSFORM_ASYNC = @import("../zig.zig").Guid.initString("f81a699a-649a-497d-8c73-29f8fed6ad7a");
pub const MF_TRANSFORM_ASYNC_UNLOCK = @import("../zig.zig").Guid.initString("e5666d6b-3422-4eb6-a421-da7db1f8e207");
pub const MF_TRANSFORM_FLAGS_Attribute = @import("../zig.zig").Guid.initString("9359bb7e-6275-46c4-a025-1c01e45f1a86");
pub const MF_TRANSFORM_CATEGORY_Attribute = @import("../zig.zig").Guid.initString("ceabba49-506d-4757-a6ff-66c184987e4e");
pub const MFT_TRANSFORM_CLSID_Attribute = @import("../zig.zig").Guid.initString("6821c42b-65a4-4e82-99bc-9a88205ecd0c");
pub const MFT_INPUT_TYPES_Attributes = @import("../zig.zig").Guid.initString("4276c9b1-759d-4bf3-9cd0-0d723d138f96");
pub const MFT_OUTPUT_TYPES_Attributes = @import("../zig.zig").Guid.initString("8eae8cf3-a44f-4306-ba5c-bf5dda242818");
pub const MFT_ENUM_HARDWARE_URL_Attribute = @import("../zig.zig").Guid.initString("2fb866ac-b078-4942-ab6c-003d05cda674");
pub const MFT_FRIENDLY_NAME_Attribute = @import("../zig.zig").Guid.initString("314ffbae-5b41-4c95-9c19-4e7d586face3");
pub const MFT_CONNECTED_STREAM_ATTRIBUTE = @import("../zig.zig").Guid.initString("71eeb820-a59f-4de2-bcec-38db1dd611a4");
pub const MFT_CONNECTED_TO_HW_STREAM = @import("../zig.zig").Guid.initString("34e6e728-06d6-4491-a553-4795650db912");
pub const MFT_PREFERRED_OUTPUTTYPE_Attribute = @import("../zig.zig").Guid.initString("7e700499-396a-49ee-b1b4-f628021e8c9d");
pub const MFT_PROCESS_LOCAL_Attribute = @import("../zig.zig").Guid.initString("543186e4-4649-4e65-b588-4aa352aff379");
pub const MFT_PREFERRED_ENCODER_PROFILE = @import("../zig.zig").Guid.initString("53004909-1ef5-46d7-a18e-5a75f8b5905f");
pub const MFT_HW_TIMESTAMP_WITH_QPC_Attribute = @import("../zig.zig").Guid.initString("8d030fb8-cc43-4258-a22e-9210bef89be4");
pub const MFT_FIELDOFUSE_UNLOCK_Attribute = @import("../zig.zig").Guid.initString("8ec2e9fd-9148-410d-831e-702439461a8e");
pub const MFT_CODEC_MERIT_Attribute = @import("../zig.zig").Guid.initString("88a7cb15-7b07-4a34-9128-e64c6703c4d3");
pub const MFT_ENUM_TRANSCODE_ONLY_ATTRIBUTE = @import("../zig.zig").Guid.initString("111ea8cd-b62a-4bdb-89f6-67ffcdc2458b");
pub const MFT_AUDIO_DECODER_DEGRADATION_INFO_ATTRIBUTE = @import("../zig.zig").Guid.initString("6c3386ad-ec20-430d-b2a5-505c7178d9c4");
pub const MFT_POLICY_SET_AWARE = @import("../zig.zig").Guid.initString("5a633b19-cc39-4fa8-8ca5-59981b7a0018");
pub const MFT_USING_HARDWARE_DRM = @import("../zig.zig").Guid.initString("34faa77d-d79e-4957-b8ce-362b2684996c");
pub const MF_WVC1_PROG_SINGLE_SLICE_CONTENT = @import("../zig.zig").Guid.initString("67ec2559-0f2f-4420-a4dd-2f8ee7a5738b");
pub const MF_PROGRESSIVE_CODING_CONTENT = @import("../zig.zig").Guid.initString("8f020eea-1508-471f-9da6-507d7cfa40db");
pub const MF_NALU_LENGTH_SET = @import("../zig.zig").Guid.initString("a7911d53-12a4-4965-ae70-6eadd6ff0551");
pub const MF_NALU_LENGTH_INFORMATION = @import("../zig.zig").Guid.initString("19124e7c-ad4b-465f-bb18-20186287b6af");
pub const MF_USER_DATA_PAYLOAD = @import("../zig.zig").Guid.initString("d1d4985d-dc92-457a-b3a0-651a33a31047");
pub const MF_MPEG4SINK_SPSPPS_PASSTHROUGH = @import("../zig.zig").Guid.initString("5601a134-2005-4ad2-b37d-22a6c554deb2");
pub const MF_MPEG4SINK_MOOV_BEFORE_MDAT = @import("../zig.zig").Guid.initString("f672e3ac-e1e6-4f10-b5ec-5f3b30828816");
pub const MF_MPEG4SINK_MINIMUM_PROPERTIES_SIZE = @import("../zig.zig").Guid.initString("dca1ed52-450e-4a22-8c62-4ed452f7a187");
pub const MF_MPEG4SINK_MIN_FRAGMENT_DURATION = @import("../zig.zig").Guid.initString("a30b570c-8efd-45e8-94fe-27c84b5bdff6");
pub const MF_MPEG4SINK_MAX_CODED_SEQUENCES_PER_FRAGMENT = @import("../zig.zig").Guid.initString("fc1b3bd6-692d-4ce5-9299-738aa5463e9a");
pub const MF_SESSION_TOPOLOADER = @import("../zig.zig").Guid.initString("1e83d482-1f1c-4571-8405-88f4b2181f71");
pub const MF_SESSION_GLOBAL_TIME = @import("../zig.zig").Guid.initString("1e83d482-1f1c-4571-8405-88f4b2181f72");
pub const MF_SESSION_QUALITY_MANAGER = @import("../zig.zig").Guid.initString("1e83d482-1f1c-4571-8405-88f4b2181f73");
pub const MF_SESSION_CONTENT_PROTECTION_MANAGER = @import("../zig.zig").Guid.initString("1e83d482-1f1c-4571-8405-88f4b2181f74");
pub const MF_SESSION_SERVER_CONTEXT = @import("../zig.zig").Guid.initString("afe5b291-50fa-46e8-b9be-0c0c3ce4b3a5");
pub const MF_SESSION_REMOTE_SOURCE_MODE = @import("../zig.zig").Guid.initString("f4033ef4-9bb3-4378-941f-85a0856bc244");
pub const MF_SESSION_APPROX_EVENT_OCCURRENCE_TIME = @import("../zig.zig").Guid.initString("190e852f-6238-42d1-b5af-69ea338ef850");
pub const MF_PMP_SERVER_CONTEXT = @import("../zig.zig").Guid.initString("2f00c910-d2cf-4278-8b6a-d077fac3a25f");
pub const MF_TIME_FORMAT_ENTRY_RELATIVE = @import("../zig.zig").Guid.initString("4399f178-46d3-4504-afda-20d32e9ba360");
pub const MF_SOURCE_STREAM_SUPPORTS_HW_CONNECTION = @import("../zig.zig").Guid.initString("a38253aa-6314-42fd-a3ce-bb27b6859946");
pub const MF_STREAM_SINK_SUPPORTS_HW_CONNECTION = @import("../zig.zig").Guid.initString("9b465cbf-0597-4f9e-9f3c-b97eeef90359");
pub const MF_STREAM_SINK_SUPPORTS_ROTATION = @import("../zig.zig").Guid.initString("b3e96280-bd05-41a5-97ad-8a7fee24b912");
pub const MF_SINK_VIDEO_PTS = @import("../zig.zig").Guid.initString("2162bde7-421e-4b90-9b33-e58fbf1d58b6");
pub const MF_SINK_VIDEO_NATIVE_WIDTH = @import("../zig.zig").Guid.initString("e6d6a707-1505-4747-9b10-72d2d158cb3a");
pub const MF_SINK_VIDEO_NATIVE_HEIGHT = @import("../zig.zig").Guid.initString("f0ca6705-490c-43e8-941c-c0b3206b9a65");
pub const MF_SINK_VIDEO_DISPLAY_ASPECT_RATIO_NUMERATOR = @import("../zig.zig").Guid.initString("d0f33b22-b78a-4879-b455-f03ef3fa82cd");
pub const MF_SINK_VIDEO_DISPLAY_ASPECT_RATIO_DENOMINATOR = @import("../zig.zig").Guid.initString("6ea1eb97-1fe0-4f10-a6e4-1f4f661564e0");
pub const MF_BD_MVC_PLANE_OFFSET_METADATA = @import("../zig.zig").Guid.initString("62a654e4-b76c-4901-9823-2cb615d47318");
pub const MF_LUMA_KEY_ENABLE = @import("../zig.zig").Guid.initString("7369820f-76de-43ca-9284-47b8f37e0649");
pub const MF_LUMA_KEY_LOWER = @import("../zig.zig").Guid.initString("93d7b8d5-0b81-4715-aea0-8725871621e9");
pub const MF_LUMA_KEY_UPPER = @import("../zig.zig").Guid.initString("d09f39bb-4602-4c31-a706-a12171a5110a");
pub const MF_USER_EXTENDED_ATTRIBUTES = @import("../zig.zig").Guid.initString("c02abac6-feb2-4541-922f-920b43702722");
pub const MF_INDEPENDENT_STILL_IMAGE = @import("../zig.zig").Guid.initString("ea12af41-0710-42c9-a127-daa3e78483a5");
pub const MF_XVP_SAMPLE_LOCK_TIMEOUT = @import("../zig.zig").Guid.initString("aa4ddb29-5134-4363-ac72-83ec4bc10426");
pub const MF_TOPOLOGY_PROJECTSTART = @import("../zig.zig").Guid.initString("7ed3f802-86bb-4b3f-b7e4-7cb43afd4b80");
pub const MF_TOPOLOGY_PROJECTSTOP = @import("../zig.zig").Guid.initString("7ed3f803-86bb-4b3f-b7e4-7cb43afd4b80");
pub const MF_TOPOLOGY_NO_MARKIN_MARKOUT = @import("../zig.zig").Guid.initString("7ed3f804-86bb-4b3f-b7e4-7cb43afd4b80");
pub const MF_TOPOLOGY_DXVA_MODE = @import("../zig.zig").Guid.initString("1e8d34f6-f5ab-4e23-bb88-874aa3a1a74d");
pub const MF_TOPOLOGY_ENABLE_XVP_FOR_PLAYBACK = @import("../zig.zig").Guid.initString("1967731f-cd78-42fc-b026-0992a56e5693");
pub const MF_TOPOLOGY_STATIC_PLAYBACK_OPTIMIZATIONS = @import("../zig.zig").Guid.initString("b86cac42-41a6-4b79-897a-1ab0e52b4a1b");
pub const MF_TOPOLOGY_PLAYBACK_MAX_DIMS = @import("../zig.zig").Guid.initString("5715cf19-5768-44aa-ad6e-8721f1b0f9bb");
pub const MF_TOPOLOGY_HARDWARE_MODE = @import("../zig.zig").Guid.initString("d2d362fd-4e4f-4191-a579-c618b66706af");
pub const MF_TOPOLOGY_PLAYBACK_FRAMERATE = @import("../zig.zig").Guid.initString("c164737a-c2b1-4553-83bb-5a526072448f");
pub const MF_TOPOLOGY_DYNAMIC_CHANGE_NOT_ALLOWED = @import("../zig.zig").Guid.initString("d529950b-d484-4527-a9cd-b1909532b5b0");
pub const MF_TOPOLOGY_ENUMERATE_SOURCE_TYPES = @import("../zig.zig").Guid.initString("6248c36d-5d0b-4f40-a0bb-b0b305f77698");
pub const MF_TOPOLOGY_START_TIME_ON_PRESENTATION_SWITCH = @import("../zig.zig").Guid.initString("c8cc113f-7951-4548-aad6-9ed6202e62b3");
pub const MF_DISABLE_LOCALLY_REGISTERED_PLUGINS = @import("../zig.zig").Guid.initString("66b16da9-add4-47e0-a16b-5af1fb483634");
pub const MF_LOCAL_PLUGIN_CONTROL_POLICY = @import("../zig.zig").Guid.initString("d91b0085-c86d-4f81-8822-8c68e1d7fa04");
pub const MF_TOPONODE_FLUSH = @import("../zig.zig").Guid.initString("494bbce8-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_DRAIN = @import("../zig.zig").Guid.initString("494bbce9-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_D3DAWARE = @import("../zig.zig").Guid.initString("494bbced-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPOLOGY_RESOLUTION_STATUS = @import("../zig.zig").Guid.initString("494bbcde-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_ERRORCODE = @import("../zig.zig").Guid.initString("494bbcee-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_CONNECT_METHOD = @import("../zig.zig").Guid.initString("494bbcf1-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_LOCKED = @import("../zig.zig").Guid.initString("494bbcf7-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_WORKQUEUE_ID = @import("../zig.zig").Guid.initString("494bbcf8-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_WORKQUEUE_MMCSS_CLASS = @import("../zig.zig").Guid.initString("494bbcf9-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_DECRYPTOR = @import("../zig.zig").Guid.initString("494bbcfa-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_DISCARDABLE = @import("../zig.zig").Guid.initString("494bbcfb-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_ERROR_MAJORTYPE = @import("../zig.zig").Guid.initString("494bbcfd-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_ERROR_SUBTYPE = @import("../zig.zig").Guid.initString("494bbcfe-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_WORKQUEUE_MMCSS_TASKID = @import("../zig.zig").Guid.initString("494bbcff-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_WORKQUEUE_MMCSS_PRIORITY = @import("../zig.zig").Guid.initString("5001f840-2816-48f4-9364-ad1ef661a123");
pub const MF_TOPONODE_WORKQUEUE_ITEM_PRIORITY = @import("../zig.zig").Guid.initString("a1ff99be-5e97-4a53-b494-568c642c0ff3");
pub const MF_TOPONODE_MARKIN_HERE = @import("../zig.zig").Guid.initString("494bbd00-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_MARKOUT_HERE = @import("../zig.zig").Guid.initString("494bbd01-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_DECODER = @import("../zig.zig").Guid.initString("494bbd02-b031-4e38-97c4-d5422dd618dc");
pub const MF_TOPONODE_MEDIASTART = @import("../zig.zig").Guid.initString("835c58ea-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_MEDIASTOP = @import("../zig.zig").Guid.initString("835c58eb-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_SOURCE = @import("../zig.zig").Guid.initString("835c58ec-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_PRESENTATION_DESCRIPTOR = @import("../zig.zig").Guid.initString("835c58ed-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_STREAM_DESCRIPTOR = @import("../zig.zig").Guid.initString("835c58ee-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_SEQUENCE_ELEMENTID = @import("../zig.zig").Guid.initString("835c58ef-e075-4bc7-bcba-4de000df9ae6");
pub const MF_TOPONODE_TRANSFORM_OBJECTID = @import("../zig.zig").Guid.initString("88dcc0c9-293e-4e8b-9aeb-0ad64cc016b0");
pub const MF_TOPONODE_STREAMID = @import("../zig.zig").Guid.initString("14932f9b-9087-4bb4-8412-5167145cbe04");
pub const MF_TOPONODE_NOSHUTDOWN_ON_REMOVE = @import("../zig.zig").Guid.initString("14932f9c-9087-4bb4-8412-5167145cbe04");
pub const MF_TOPONODE_RATELESS = @import("../zig.zig").Guid.initString("14932f9d-9087-4bb4-8412-5167145cbe04");
pub const MF_TOPONODE_DISABLE_PREROLL = @import("../zig.zig").Guid.initString("14932f9e-9087-4bb4-8412-5167145cbe04");
pub const MF_TOPONODE_PRIMARYOUTPUT = @import("../zig.zig").Guid.initString("6304ef99-16b2-4ebe-9d67-e4c539b3a259");
pub const MF_PD_PMPHOST_CONTEXT = @import("../zig.zig").Guid.initString("6c990d31-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_APP_CONTEXT = @import("../zig.zig").Guid.initString("6c990d32-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_DURATION = @import("../zig.zig").Guid.initString("6c990d33-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_TOTAL_FILE_SIZE = @import("../zig.zig").Guid.initString("6c990d34-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_AUDIO_ENCODING_BITRATE = @import("../zig.zig").Guid.initString("6c990d35-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_VIDEO_ENCODING_BITRATE = @import("../zig.zig").Guid.initString("6c990d36-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_MIME_TYPE = @import("../zig.zig").Guid.initString("6c990d37-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_LAST_MODIFIED_TIME = @import("../zig.zig").Guid.initString("6c990d38-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_PLAYBACK_ELEMENT_ID = @import("../zig.zig").Guid.initString("6c990d39-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_PREFERRED_LANGUAGE = @import("../zig.zig").Guid.initString("6c990d3a-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_PLAYBACK_BOUNDARY_TIME = @import("../zig.zig").Guid.initString("6c990d3b-bb8e-477a-8598-0d5d96fcd88a");
pub const MF_PD_AUDIO_ISVARIABLEBITRATE = @import("../zig.zig").Guid.initString("33026ee0-e387-4582-ae0a-34a2ad3baa18");
pub const MF_SD_LANGUAGE = @import("../zig.zig").Guid.initString("00af2180-bdc2-423c-abca-f503593bc121");
pub const MF_SD_PROTECTED = @import("../zig.zig").Guid.initString("00af2181-bdc2-423c-abca-f503593bc121");
pub const MF_SD_STREAM_NAME = @import("../zig.zig").Guid.initString("4f1b099d-d314-41e5-a781-7fefaa4c501f");
pub const MF_SD_MUTUALLY_EXCLUSIVE = @import("../zig.zig").Guid.initString("023ef79c-388d-487f-ac17-696cd6e3c6f5");
pub const MF_ACTIVATE_CUSTOM_VIDEO_MIXER_CLSID = @import("../zig.zig").Guid.initString("ba491360-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_MIXER_ACTIVATE = @import("../zig.zig").Guid.initString("ba491361-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_MIXER_FLAGS = @import("../zig.zig").Guid.initString("ba491362-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_CLSID = @import("../zig.zig").Guid.initString("ba491364-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_ACTIVATE = @import("../zig.zig").Guid.initString("ba491365-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_CUSTOM_VIDEO_PRESENTER_FLAGS = @import("../zig.zig").Guid.initString("ba491366-be50-451e-95ab-6d4accc7dad8");
pub const MF_ACTIVATE_MFT_LOCKED = @import("../zig.zig").Guid.initString("c1f6093c-7f65-4fbd-9e39-5faec3c4fbd7");
pub const MF_ACTIVATE_VIDEO_WINDOW = @import("../zig.zig").Guid.initString("9a2dbbdd-f57e-4162-82b9-6831377682d3");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_FLAGS = @import("../zig.zig").Guid.initString("ede4b5e0-f805-4d6c-99b3-db01bf95dfab");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_SESSION_ID = @import("../zig.zig").Guid.initString("ede4b5e3-f805-4d6c-99b3-db01bf95dfab");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ID = @import("../zig.zig").Guid.initString("b10aaec3-ef71-4cc3-b873-05a9a08b9f8e");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_ENDPOINT_ROLE = @import("../zig.zig").Guid.initString("6ba644ff-27c5-4d02-9887-c28619fdb91b");
pub const MF_AUDIO_RENDERER_ATTRIBUTE_STREAM_CATEGORY = @import("../zig.zig").Guid.initString("a9770471-92ec-4df4-94fe-81c36f0c3a7a");
pub const MFENABLETYPE_WMDRMV1_LicenseAcquisition = @import("../zig.zig").Guid.initString("4ff6eeaf-0b43-4797-9b85-abf31815e7b0");
pub const MFENABLETYPE_WMDRMV7_LicenseAcquisition = @import("../zig.zig").Guid.initString("003306df-4a06-4884-a097-ef6d22ec84a3");
pub const MFENABLETYPE_WMDRMV7_Individualization = @import("../zig.zig").Guid.initString("acd2c84a-b303-4f65-bc2c-2c848d01a989");
pub const MFENABLETYPE_MF_UpdateRevocationInformation = @import("../zig.zig").Guid.initString("e558b0b5-b3c4-44a0-924c-50d178932385");
pub const MFENABLETYPE_MF_UpdateUntrustedComponent = @import("../zig.zig").Guid.initString("9879f3d6-cee2-48e6-b573-9767ab172f16");
pub const MFENABLETYPE_MF_RebootRequired = @import("../zig.zig").Guid.initString("6d4d3d4b-0ece-4652-8b3a-f2d24260d887");
pub const MF_METADATA_PROVIDER_SERVICE = @import("../zig.zig").Guid.initString("db214084-58a4-4d2e-b84f-6f755b2f7a0d");
pub const MF_PROPERTY_HANDLER_SERVICE = @import("../zig.zig").Guid.initString("a3face02-32b8-41dd-90e7-5fef7c8991b5");
pub const MF_RATE_CONTROL_SERVICE = @import("../zig.zig").Guid.initString("866fa297-b802-4bf8-9dc9-5e3b6a9f53c9");
pub const MF_TIMECODE_SERVICE = @import("../zig.zig").Guid.initString("a0d502a7-0eb3-4885-b1b9-9feb0d083454");
pub const MR_POLICY_VOLUME_SERVICE = @import("../zig.zig").Guid.initString("1abaa2ac-9d3b-47c6-ab48-c59506de784d");
pub const MR_CAPTURE_POLICY_VOLUME_SERVICE = @import("../zig.zig").Guid.initString("24030acd-107a-4265-975c-414e33e65f2a");
pub const MR_STREAM_VOLUME_SERVICE = @import("../zig.zig").Guid.initString("f8b5fa2f-32ef-46f5-b172-1321212fb2c4");
pub const MR_AUDIO_POLICY_SERVICE = @import("../zig.zig").Guid.initString("911fd737-6775-4ab0-a614-297862fdac88");
pub const MF_SAMPLEGRABBERSINK_SAMPLE_TIME_OFFSET = @import("../zig.zig").Guid.initString("62e3d776-8100-4e03-a6e8-bd3857ac9c47");
pub const MF_SAMPLEGRABBERSINK_IGNORE_CLOCK = @import("../zig.zig").Guid.initString("0efda2c0-2b69-4e2e-ab8d-46dcbff7d25d");
pub const MF_QUALITY_SERVICES = @import("../zig.zig").Guid.initString("b7e2be11-2f96-4640-b52c-282365bdf16c");
pub const MF_WORKQUEUE_SERVICES = @import("../zig.zig").Guid.initString("8e37d489-41e0-413a-9068-287c886d8dda");
pub const MF_QUALITY_NOTIFY_PROCESSING_LATENCY = @import("../zig.zig").Guid.initString("f6b44af8-604d-46fe-a95d-45479b10c9bc");
pub const MF_QUALITY_NOTIFY_SAMPLE_LAG = @import("../zig.zig").Guid.initString("30d15206-ed2a-4760-be17-eb4a9f12295c");
pub const MF_TIME_FORMAT_SEGMENT_OFFSET = @import("../zig.zig").Guid.initString("c8b8be77-869c-431d-812e-169693f65a39");
pub const MF_SOURCE_PRESENTATION_PROVIDER_SERVICE = @import("../zig.zig").Guid.initString("e002aadc-f4af-4ee5-9847-053edf840426");
pub const MF_TOPONODE_ATTRIBUTE_EDITOR_SERVICE = @import("../zig.zig").Guid.initString("65656e1a-077f-4472-83ef-316f11d5087a");
pub const MFNETSOURCE_SSLCERTIFICATE_MANAGER = @import("../zig.zig").Guid.initString("55e6cb27-e69b-4267-940c-2d7ec5bb8a0f");
pub const MFNETSOURCE_RESOURCE_FILTER = @import("../zig.zig").Guid.initString("815d0ff6-265a-4477-9e46-7b80ad80b5fb");
pub const MFNET_SAVEJOB_SERVICE = @import("../zig.zig").Guid.initString("b85a587f-3d02-4e52-9565-55d3ec1e7ff7");
pub const MFNETSOURCE_STATISTICS_SERVICE = @import("../zig.zig").Guid.initString("3cb1f275-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_STATISTICS = @import("../zig.zig").Guid.initString("3cb1f274-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_BUFFERINGTIME = @import("../zig.zig").Guid.initString("3cb1f276-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ACCELERATEDSTREAMINGDURATION = @import("../zig.zig").Guid.initString("3cb1f277-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_MAXUDPACCELERATEDSTREAMINGDURATION = @import("../zig.zig").Guid.initString("4aab2879-bbe1-4994-9ff0-5495bd250129");
pub const MFNETSOURCE_MAXBUFFERTIMEMS = @import("../zig.zig").Guid.initString("408b24e6-4038-4401-b5b2-fe701a9ebf10");
pub const MFNETSOURCE_CONNECTIONBANDWIDTH = @import("../zig.zig").Guid.initString("3cb1f278-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_CACHEENABLED = @import("../zig.zig").Guid.initString("3cb1f279-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_AUTORECONNECTLIMIT = @import("../zig.zig").Guid.initString("3cb1f27a-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_RESENDSENABLED = @import("../zig.zig").Guid.initString("3cb1f27b-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_THINNINGENABLED = @import("../zig.zig").Guid.initString("3cb1f27c-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROTOCOL = @import("../zig.zig").Guid.initString("3cb1f27d-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_TRANSPORT = @import("../zig.zig").Guid.initString("3cb1f27e-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PREVIEWMODEENABLED = @import("../zig.zig").Guid.initString("3cb1f27f-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_CREDENTIAL_MANAGER = @import("../zig.zig").Guid.initString("3cb1f280-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PPBANDWIDTH = @import("../zig.zig").Guid.initString("3cb1f281-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_AUTORECONNECTPROGRESS = @import("../zig.zig").Guid.initString("3cb1f282-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYLOCATORFACTORY = @import("../zig.zig").Guid.initString("3cb1f283-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_BROWSERUSERAGENT = @import("../zig.zig").Guid.initString("3cb1f28b-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_BROWSERWEBPAGE = @import("../zig.zig").Guid.initString("3cb1f28c-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PLAYERVERSION = @import("../zig.zig").Guid.initString("3cb1f28d-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PLAYERID = @import("../zig.zig").Guid.initString("3cb1f28e-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_HOSTEXE = @import("../zig.zig").Guid.initString("3cb1f28f-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_HOSTVERSION = @import("../zig.zig").Guid.initString("3cb1f291-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PLAYERUSERAGENT = @import("../zig.zig").Guid.initString("3cb1f292-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_CLIENTGUID = @import("../zig.zig").Guid.initString("60a2c4a6-f197-4c14-a5bf-88830d2458af");
pub const MFNETSOURCE_LOGURL = @import("../zig.zig").Guid.initString("3cb1f293-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_UDP = @import("../zig.zig").Guid.initString("3cb1f294-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_TCP = @import("../zig.zig").Guid.initString("3cb1f295-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_MSB = @import("../zig.zig").Guid.initString("3cb1f296-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_RTSP = @import("../zig.zig").Guid.initString("3cb1f298-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_HTTP = @import("../zig.zig").Guid.initString("3cb1f299-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_STREAMING = @import("../zig.zig").Guid.initString("3cb1f29c-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_DOWNLOAD = @import("../zig.zig").Guid.initString("3cb1f29d-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_ENABLE_PRIVATEMODE = @import("../zig.zig").Guid.initString("824779d8-f18b-4405-8cf1-464fb5aa8f71");
pub const MFNETSOURCE_UDP_PORT_RANGE = @import("../zig.zig").Guid.initString("3cb1f29a-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYINFO = @import("../zig.zig").Guid.initString("3cb1f29b-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_DRMNET_LICENSE_REPRESENTATION = @import("../zig.zig").Guid.initString("47eae1bd-bdfe-42e2-82f3-54a48c17962d");
pub const MFNETSOURCE_PROXYSETTINGS = @import("../zig.zig").Guid.initString("3cb1f287-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYHOSTNAME = @import("../zig.zig").Guid.initString("3cb1f284-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYPORT = @import("../zig.zig").Guid.initString("3cb1f288-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYEXCEPTIONLIST = @import("../zig.zig").Guid.initString("3cb1f285-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYBYPASSFORLOCAL = @import("../zig.zig").Guid.initString("3cb1f286-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_PROXYRERUNAUTODETECTION = @import("../zig.zig").Guid.initString("3cb1f289-0505-4c5d-ae71-0a556344efa1");
pub const MFNETSOURCE_STREAM_LANGUAGE = @import("../zig.zig").Guid.initString("9ab44318-f7cd-4f2d-8d6d-fa35b492cecb");
pub const MFNETSOURCE_LOGPARAMS = @import("../zig.zig").Guid.initString("64936ae8-9418-453a-8cda-3e0a668b353b");
pub const MFNETSOURCE_PEERMANAGER = @import("../zig.zig").Guid.initString("48b29adb-febf-45ee-a9bf-efb81c492efc");
pub const MFNETSOURCE_FRIENDLYNAME = @import("../zig.zig").Guid.initString("5b2a7757-bc6b-447e-aa06-0dda1c646e2f");
pub const MF_BYTESTREAMHANDLER_ACCEPTS_SHARE_WRITE = @import("../zig.zig").Guid.initString("a6e1f733-3001-4915-8150-1558a2180ec8");
pub const MF_BYTESTREAM_SERVICE = @import("../zig.zig").Guid.initString("ab025e2b-16d9-4180-a127-ba6c70156161");
pub const MF_MEDIA_PROTECTION_MANAGER_PROPERTIES = @import("../zig.zig").Guid.initString("38bd81a9-acea-4c73-89b2-5532c0aeca79");
pub const MFCONNECTOR_SPDIF = @import("../zig.zig").Guid.initString("0b94a712-ad3e-4cee-83ce-ce32e3db6522");
pub const MFCONNECTOR_UNKNOWN = @import("../zig.zig").Guid.initString("ac3aef5c-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_PCI = @import("../zig.zig").Guid.initString("ac3aef5d-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_PCIX = @import("../zig.zig").Guid.initString("ac3aef5e-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_PCI_Express = @import("../zig.zig").Guid.initString("ac3aef5f-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_AGP = @import("../zig.zig").Guid.initString("ac3aef60-ce43-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_VGA = @import("../zig.zig").Guid.initString("57cd5968-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_SVIDEO = @import("../zig.zig").Guid.initString("57cd5969-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_COMPOSITE = @import("../zig.zig").Guid.initString("57cd596a-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_COMPONENT = @import("../zig.zig").Guid.initString("57cd596b-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_DVI = @import("../zig.zig").Guid.initString("57cd596c-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_HDMI = @import("../zig.zig").Guid.initString("57cd596d-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_LVDS = @import("../zig.zig").Guid.initString("57cd596e-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_D_JPN = @import("../zig.zig").Guid.initString("57cd5970-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_SDI = @import("../zig.zig").Guid.initString("57cd5971-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_DISPLAYPORT_EXTERNAL = @import("../zig.zig").Guid.initString("57cd5972-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_DISPLAYPORT_EMBEDDED = @import("../zig.zig").Guid.initString("57cd5973-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_UDI_EXTERNAL = @import("../zig.zig").Guid.initString("57cd5974-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_UDI_EMBEDDED = @import("../zig.zig").Guid.initString("57cd5975-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_MIRACAST = @import("../zig.zig").Guid.initString("57cd5977-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A = @import("../zig.zig").Guid.initString("57cd5978-ce47-11d9-92db-000bdb28ff98");
pub const MFCONNECTOR_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B = @import("../zig.zig").Guid.initString("57cd5979-ce47-11d9-92db-000bdb28ff98");
pub const MF_POLICY_ID = @import("../zig.zig").Guid.initString("b160c24d-c059-48f1-a901-9ee298a9a8c3");
pub const MFPROTECTION_DISABLE = @import("../zig.zig").Guid.initString("8cc6d81b-fec6-4d8f-964b-cfba0b0dad0d");
pub const MFPROTECTION_CONSTRICTVIDEO = @import("../zig.zig").Guid.initString("193370ce-c5e4-4c3a-8a66-6959b4da4442");
pub const MFPROTECTION_CONSTRICTVIDEO_NOOPM = @import("../zig.zig").Guid.initString("a580e8cd-c247-4957-b983-3c2eebd1ff59");
pub const MFPROTECTION_CONSTRICTAUDIO = @import("../zig.zig").Guid.initString("ffc99b44-df48-4e16-8e66-096892c1578a");
pub const MFPROTECTION_TRUSTEDAUDIODRIVERS = @import("../zig.zig").Guid.initString("65bdf3d2-0168-4816-a533-55d47b027101");
pub const MFPROTECTION_HDCP = @import("../zig.zig").Guid.initString("ae7cc03d-c828-4021-acb7-d578d27aaf13");
pub const MFPROTECTION_CGMSA = @import("../zig.zig").Guid.initString("e57e69e9-226b-4d31-b4e3-d3db008736dd");
pub const MFPROTECTION_ACP = @import("../zig.zig").Guid.initString("c3fd11c6-f8b7-4d20-b008-1db17d61f2da");
pub const MFPROTECTION_WMDRMOTA = @import("../zig.zig").Guid.initString("a267a6a1-362e-47d0-8805-4628598a23e4");
pub const MFPROTECTION_FFT = @import("../zig.zig").Guid.initString("462a56b2-2866-4bb6-980d-6d8d9edb1a8c");
pub const MFPROTECTION_PROTECTED_SURFACE = @import("../zig.zig").Guid.initString("4f5d9566-e742-4a25-8d1f-d287b5fa0ade");
pub const MFPROTECTION_DISABLE_SCREEN_SCRAPE = @import("../zig.zig").Guid.initString("a21179a4-b7cd-40d8-9614-8ef2371ba78d");
pub const MFPROTECTION_VIDEO_FRAMES = @import("../zig.zig").Guid.initString("36a59cbc-7401-4a8c-bc20-46a7c9e597f0");
pub const MFPROTECTION_HARDWARE = @import("../zig.zig").Guid.initString("4ee7f0c1-9ed7-424f-b6be-996b33528856");
pub const MFPROTECTION_HDCP_WITH_TYPE_ENFORCEMENT = @import("../zig.zig").Guid.initString("a4a585e8-ed60-442d-814d-db4d4220a06d");
pub const MFPROTECTIONATTRIBUTE_BEST_EFFORT = @import("../zig.zig").Guid.initString("c8e06331-75f0-4ec1-8e77-17578f773b46");
pub const MFPROTECTIONATTRIBUTE_FAIL_OVER = @import("../zig.zig").Guid.initString("8536abc5-38f1-4151-9cce-f55d941229ac");
pub const MFPROTECTION_GRAPHICS_TRANSFER_AES_ENCRYPTION = @import("../zig.zig").Guid.initString("c873de64-d8a5-49e6-88bb-fb963fd3d4ce");
pub const MFPROTECTIONATTRIBUTE_CONSTRICTVIDEO_IMAGESIZE = @import("../zig.zig").Guid.initString("008476fc-4b58-4d80-a790-e7297673161d");
pub const MFPROTECTIONATTRIBUTE_HDCP_SRM = @import("../zig.zig").Guid.initString("6f302107-3477-4468-8a08-eef9db10e20f");
pub const MF_SampleProtectionSalt = @import("../zig.zig").Guid.initString("5403deee-b9ee-438f-aa83-3804997e569d");
pub const MF_REMOTE_PROXY = @import("../zig.zig").Guid.initString("2f00c90e-d2cf-4278-8b6a-d077fac3a25f");
pub const CLSID_CreateMediaExtensionObject = @import("../zig.zig").Guid.initString("ef65a54d-0788-45b8-8b14-bc0f6a6b5137");
pub const MF_SAMI_SERVICE = @import("../zig.zig").Guid.initString("49a89ae7-b4d9-4ef2-aa5c-f65a3e05ae4e");
pub const MF_PD_SAMI_STYLELIST = @import("../zig.zig").Guid.initString("e0b73c7f-486d-484e-9872-4de5192a7bf8");
pub const MF_SD_SAMI_LANGUAGE = @import("../zig.zig").Guid.initString("36fcb98a-6cd0-44cb-acb9-a8f5600dd0bb");
pub const MF_TRANSCODE_CONTAINERTYPE = @import("../zig.zig").Guid.initString("150ff23f-4abc-478b-ac4f-e1916fba1cca");
pub const MFTranscodeContainerType_ASF = @import("../zig.zig").Guid.initString("430f6f6e-b6bf-4fc1-a0bd-9ee46eee2afb");
pub const MFTranscodeContainerType_MPEG4 = @import("../zig.zig").Guid.initString("dc6cd05d-b9d0-40ef-bd35-fa622c1ab28a");
pub const MFTranscodeContainerType_MP3 = @import("../zig.zig").Guid.initString("e438b912-83f1-4de6-9e3a-9ffbc6dd24d1");
pub const MFTranscodeContainerType_FLAC = @import("../zig.zig").Guid.initString("31344aa3-05a9-42b5-901b-8e9d4257f75e");
pub const MFTranscodeContainerType_3GP = @import("../zig.zig").Guid.initString("34c50167-4472-4f34-9ea0-c49fbacf037d");
pub const MFTranscodeContainerType_AC3 = @import("../zig.zig").Guid.initString("6d8d91c3-8c91-4ed1-8742-8c347d5b44d0");
pub const MFTranscodeContainerType_ADTS = @import("../zig.zig").Guid.initString("132fd27d-0f02-43de-a301-38fbbbb3834e");
pub const MFTranscodeContainerType_MPEG2 = @import("../zig.zig").Guid.initString("bfc2dbf9-7bb4-4f8f-afde-e112c44ba882");
pub const MFTranscodeContainerType_WAVE = @import("../zig.zig").Guid.initString("64c3453c-0f26-4741-be63-87bdf8bb935b");
pub const MFTranscodeContainerType_AVI = @import("../zig.zig").Guid.initString("7edfe8af-402f-4d76-a33c-619fd157d0f1");
pub const MFTranscodeContainerType_FMPEG4 = @import("../zig.zig").Guid.initString("9ba876f1-419f-4b77-a1e0-35959d9d4004");
pub const MFTranscodeContainerType_AMR = @import("../zig.zig").Guid.initString("025d5ad3-621a-475b-964d-66b1c824f079");
pub const MF_TRANSCODE_SKIP_METADATA_TRANSFER = @import("../zig.zig").Guid.initString("4e4469ef-b571-4959-8f83-3dcfba33a393");
pub const MF_TRANSCODE_TOPOLOGYMODE = @import("../zig.zig").Guid.initString("3e3df610-394a-40b2-9dea-3bab650bebf2");
pub const MF_TRANSCODE_ADJUST_PROFILE = @import("../zig.zig").Guid.initString("9c37c21b-060f-487c-a690-80d7f50d1c72");
pub const MF_TRANSCODE_ENCODINGPROFILE = @import("../zig.zig").Guid.initString("6947787c-f508-4ea9-b1e9-a1fe3a49fbc9");
pub const MF_TRANSCODE_QUALITYVSSPEED = @import("../zig.zig").Guid.initString("98332df8-03cd-476b-89fa-3f9e442dec9f");
pub const MF_TRANSCODE_DONOT_INSERT_ENCODER = @import("../zig.zig").Guid.initString("f45aa7ce-ab24-4012-a11b-dc8220201410");
pub const MF_VIDEO_PROCESSOR_ALGORITHM = @import("../zig.zig").Guid.initString("4a0a1e1f-272c-4fb6-9eb1-db330cbc97ca");
pub const MF_XVP_DISABLE_FRC = @import("../zig.zig").Guid.initString("2c0afa19-7a97-4d5a-9ee8-16d4fc518d8c");
pub const MF_XVP_CALLER_ALLOCATES_OUTPUT = @import("../zig.zig").Guid.initString("04a2cabc-0cab-40b1-a1b9-75bc3658f000");
pub const MF_LOCAL_MFT_REGISTRATION_SERVICE = @import("../zig.zig").Guid.initString("ddf5cf9c-4506-45aa-abf0-6d5d94dd1b4a");
pub const MF_WRAPPED_SAMPLE_SERVICE = @import("../zig.zig").Guid.initString("31f52bf2-d03e-4048-80d0-9c1046d87c61");
pub const MF_WRAPPED_OBJECT = @import("../zig.zig").Guid.initString("2b182c4c-d6ac-49f4-8915-f71887db70cd");
pub const CLSID_HttpSchemePlugin = @import("../zig.zig").Guid.initString("44cb442b-9da9-49df-b3fd-023777b16e50");
pub const CLSID_UrlmonSchemePlugin = @import("../zig.zig").Guid.initString("9ec4b4f9-3029-45ad-947b-344de2a249e2");
pub const CLSID_NetSchemePlugin = @import("../zig.zig").Guid.initString("e9f4ebab-d97b-463e-a2b1-c54ee3f9414d");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE = @import("../zig.zig").Guid.initString("c60ac5fe-252a-478f-a0ef-bc8fa5f7cad3");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_HW_SOURCE = @import("../zig.zig").Guid.initString("de7046ba-54d6-4487-a2a4-ec7c0d1bd163");
pub const MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME = @import("../zig.zig").Guid.initString("60d0e559-52f8-4fa2-bbce-acdb34a8ec01");
pub const MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE = @import("../zig.zig").Guid.initString("56a819ca-0c78-4de4-a0a7-3ddaba0f24d4");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_CATEGORY = @import("../zig.zig").Guid.initString("77f0ae69-c3bd-4509-941d-467e4d24899e");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK = @import("../zig.zig").Guid.initString("58f0aad8-22bf-4f8a-bb3d-d2c4978c6e2f");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_SYMBOLIC_LINK = @import("../zig.zig").Guid.initString("98d24b5e-5930-4614-b5a1-f600f9355a78");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_MAX_BUFFERS = @import("../zig.zig").Guid.initString("7dd9b730-4f2d-41d5-8f95-0cc9a912ba26");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ENDPOINT_ID = @import("../zig.zig").Guid.initString("30da9258-feb9-47a7-a453-763a7a8e1c5f");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_ROLE = @import("../zig.zig").Guid.initString("bc9d118e-8c67-4a18-85d4-12d300400552");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_PROVIDER_DEVICE_ID = @import("../zig.zig").Guid.initString("36689d42-a06c-40ae-84cf-f5a034067cc4");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_XADDRESS = @import("../zig.zig").Guid.initString("bca0be52-c327-44c7-9b7d-7fa8d9b5bcda");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_STREAM_URL = @import("../zig.zig").Guid.initString("9d7b40d2-3617-4043-93e3-8d6da9bb3492");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_USERNAME = @import("../zig.zig").Guid.initString("05d01add-949f-46eb-bc8e-8b0d2b32d79d");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_PASSWORD = @import("../zig.zig").Guid.initString("a0fd7e16-42d9-49df-84c0-e82c5eab8874");
pub const CLSID_FrameServerNetworkCameraSource = @import("../zig.zig").Guid.initString("7a213aa7-866f-414a-8c1a-275c7283a395");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_AUDCAP_GUID = @import("../zig.zig").Guid.initString("14dd9a1c-7cff-41be-b1b9-ba1ac6ecb571");
pub const MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID = @import("../zig.zig").Guid.initString("8ac3587a-4ae7-42d8-99e0-0a6013eef90f");
pub const MF_DEVICESTREAM_IMAGE_STREAM = @import("../zig.zig").Guid.initString("a7ffb865-e7b2-43b0-9f6f-9af2a0e50fc0");
pub const MF_DEVICESTREAM_INDEPENDENT_IMAGE_STREAM = @import("../zig.zig").Guid.initString("03eeec7e-d605-4576-8b29-6580b490d7d3");
pub const MF_DEVICESTREAM_STREAM_ID = @import("../zig.zig").Guid.initString("11bd5120-d124-446b-88e6-17060257fff9");
pub const MF_DEVICESTREAM_STREAM_CATEGORY = @import("../zig.zig").Guid.initString("2939e7b8-a62e-4579-b674-d4073dfabbba");
pub const MF_DEVICESTREAM_FRAMESERVER_SHARED = @import("../zig.zig").Guid.initString("1cb378e9-b279-41d4-af97-34a243e68320");
pub const MF_DEVICESTREAM_TRANSFORM_STREAM_ID = @import("../zig.zig").Guid.initString("e63937b7-daaf-4d49-815f-d826f8ad31e7");
pub const MF_DEVICESTREAM_EXTENSION_PLUGIN_CLSID = @import("../zig.zig").Guid.initString("048e6558-60c4-4173-bd5b-6a3ca2896aee");
pub const MF_DEVICEMFT_EXTENSION_PLUGIN_CLSID = @import("../zig.zig").Guid.initString("0844dbae-34fa-48a0-a783-8e696fb1c9a8");
pub const MF_DEVICESTREAM_EXTENSION_PLUGIN_CONNECTION_POINT = @import("../zig.zig").Guid.initString("37f9375c-e664-4ea4-aae4-cb6d1daca1f4");
pub const MF_DEVICESTREAM_TAKEPHOTO_TRIGGER = @import("../zig.zig").Guid.initString("1d180e34-538c-4fbb-a75a-859af7d261a6");
pub const MF_DEVICESTREAM_MAX_FRAME_BUFFERS = @import("../zig.zig").Guid.initString("1684cebe-3175-4985-882c-0efd3e8ac11e");
pub const MF_DEVICEMFT_CONNECTED_FILTER_KSCONTROL = @import("../zig.zig").Guid.initString("6a2c4fa6-d179-41cd-9523-822371ea40e5");
pub const MF_DEVICEMFT_CONNECTED_PIN_KSCONTROL = @import("../zig.zig").Guid.initString("e63310f7-b244-4ef8-9a7d-24c74e32ebd0");
pub const MF_DEVICE_THERMAL_STATE_CHANGED = @import("../zig.zig").Guid.initString("70ccd0af-fc9f-4deb-a875-9fecd16c5bd4");
pub const MFSampleExtension_DeviceTimestamp = @import("../zig.zig").Guid.initString("8f3e35e7-2dcd-4887-8622-2a58baa652b0");
pub const MFSampleExtension_Spatial_CameraViewTransform = @import("../zig.zig").Guid.initString("4e251fa4-830f-4770-859a-4b8d99aa809b");
pub const MFSampleExtension_Spatial_CameraCoordinateSystem = @import("../zig.zig").Guid.initString("9d13c82f-2199-4e67-91cd-d1a4181f2534");
pub const MFSampleExtension_Spatial_CameraProjectionTransform = @import("../zig.zig").Guid.initString("47f9fcb5-2a02-4f26-a477-792fdf95886a");
pub const MF_MEDIASOURCE_SERVICE = @import("../zig.zig").Guid.initString("f09992f7-9fba-4c4a-a37f-8c47b4e1dfe7");
pub const MF_ACCESS_CONTROLLED_MEDIASOURCE_SERVICE = @import("../zig.zig").Guid.initString("014a5031-2f05-4c6a-9f9c-7d0dc4eda5f4");
pub const MF_CONTENT_DECRYPTOR_SERVICE = @import("../zig.zig").Guid.initString("68a72927-fc7b-44ee-85f4-7c51bd55a659");
pub const MF_CONTENT_PROTECTION_DEVICE_SERVICE = @import("../zig.zig").Guid.initString("ff58436f-76a0-41fe-b566-10cc53962edd");
pub const MF_SD_AUDIO_ENCODER_DELAY = @import("../zig.zig").Guid.initString("8e85422c-73de-403f-9a35-550ad6e8b951");
pub const MF_SD_AUDIO_ENCODER_PADDING = @import("../zig.zig").Guid.initString("529c7f2c-ac4b-4e3f-bfc3-0902194982cb");
pub const CLSID_MSH264DecoderMFT = @import("../zig.zig").Guid.initString("62ce7e72-4c71-4d20-b15d-452831a87d9d");
pub const CLSID_MSH264EncoderMFT = @import("../zig.zig").Guid.initString("6ca50344-051a-4ded-9779-a43305165e35");
pub const CLSID_MSDDPlusDecMFT = @import("../zig.zig").Guid.initString("177c0afe-900b-48d4-9e4c-57add250b3d4");
pub const CLSID_MP3DecMediaObject = @import("../zig.zig").Guid.initString("bbeea841-0a63-4f52-a7ab-a9b3a84ed38a");
pub const CLSID_MSAACDecMFT = @import("../zig.zig").Guid.initString("32d186a7-218f-4c75-8876-dd77273a8999");
pub const CLSID_MSH265DecoderMFT = @import("../zig.zig").Guid.initString("420a51a3-d605-430c-b4fc-45274fa6c562");
pub const CLSID_WMVDecoderMFT = @import("../zig.zig").Guid.initString("82d353df-90bd-4382-8bc2-3f6192b76e34");
pub const CLSID_WMADecMediaObject = @import("../zig.zig").Guid.initString("2eeb4adf-4578-4d10-bca7-bb955f56320a");
pub const CLSID_MSMPEGAudDecMFT = @import("../zig.zig").Guid.initString("70707b39-b2ca-4015-abea-f8447d22d88b");
pub const CLSID_MSMPEGDecoderMFT = @import("../zig.zig").Guid.initString("2d709e52-123f-49b5-9cbc-9af5cde28fb9");
pub const CLSID_AudioResamplerMediaObject = @import("../zig.zig").Guid.initString("f447b69e-1884-4a7e-8055-346f74d6edb3");
pub const CLSID_MSVPxDecoder = @import("../zig.zig").Guid.initString("e3aaf548-c9a4-4c6e-234d-5ada374b0000");
pub const CLSID_MSOpusDecoder = @import("../zig.zig").Guid.initString("63e17c10-2d43-4c42-8fe3-8d8b63e46a6a");
pub const CLSID_VideoProcessorMFT = @import("../zig.zig").Guid.initString("88753b26-5b24-49bd-b2e7-0c445c78c982");
pub const MFNETSOURCE_CROSS_ORIGIN_SUPPORT = @import("../zig.zig").Guid.initString("9842207c-b02c-4271-a2fc-72e49308e5c2");
pub const MFNETSOURCE_HTTP_DOWNLOAD_SESSION_PROVIDER = @import("../zig.zig").Guid.initString("7d55081e-307d-4d6d-a663-a93be97c4b5c");
pub const MF_SD_MEDIASOURCE_STATUS = @import("../zig.zig").Guid.initString("1913678b-fc0f-44da-8f43-1ba3b526f4ae");
pub const MF_SD_VIDEO_SPHERICAL = @import("../zig.zig").Guid.initString("a51da449-3fdc-478c-bcb5-30be76595f55");
pub const MF_SD_VIDEO_SPHERICAL_FORMAT = @import("../zig.zig").Guid.initString("4a8fc407-6ea1-46c8-b567-6971d4a139c3");
pub const MF_SD_VIDEO_SPHERICAL_INITIAL_VIEWDIRECTION = @import("../zig.zig").Guid.initString("11d25a49-bb62-467f-9db1-c17165716c49");
pub const MF_MEDIASOURCE_EXPOSE_ALL_STREAMS = @import("../zig.zig").Guid.initString("e7f250b8-8fd9-4a09-b6c1-6a315c7c720e");
pub const MF_ST_MEDIASOURCE_COLLECTION = @import("../zig.zig").Guid.initString("616de972-83ad-4950-8170-630d19cbe307");
pub const MF_DEVICESTREAM_FILTER_KSCONTROL = @import("../zig.zig").Guid.initString("46783cca-3df5-4923-a9ef-36b7223edde0");
pub const MF_DEVICESTREAM_PIN_KSCONTROL = @import("../zig.zig").Guid.initString("ef3ef9a7-87f2-48ca-be02-674878918e98");
pub const MF_DEVICESTREAM_SOURCE_ATTRIBUTES = @import("../zig.zig").Guid.initString("2f8cb617-361b-434f-85ea-99a03e1ce4e0");
pub const MF_DEVICESTREAM_FRAMESERVER_HIDDEN = @import("../zig.zig").Guid.initString("f402567b-4d91-4179-96d1-74c8480c2034");
pub const MF_STF_VERSION_INFO = @import("../zig.zig").Guid.initString("6770bd39-ef82-44ee-a49b-934beb24aef7");
pub const MF_STF_VERSION_DATE = @import("../zig.zig").Guid.initString("31a165d5-df67-4095-8e44-8868fc20dbfd");
pub const MF_DEVICESTREAM_REQUIRED_CAPABILITIES = @import("../zig.zig").Guid.initString("6d8b957e-7cf6-43f4-af56-9c0e1e4fcbe1");
pub const MF_DEVICESTREAM_REQUIRED_SDDL = @import("../zig.zig").Guid.initString("331ae85d-c0d3-49ba-83ba-82a12d63cdd6");
pub const MF_DEVICEMFT_SENSORPROFILE_COLLECTION = @import("../zig.zig").Guid.initString("36ebdc44-b12c-441b-89f4-08b2f41a9cfc");
pub const MF_DEVICESTREAM_SENSORSTREAM_ID = @import("../zig.zig").Guid.initString("e35b9fe4-0659-4cad-bb51-33160be7e413");
pub const MF_PD_ASF_FILEPROPERTIES_FILE_ID = @import("../zig.zig").Guid.initString("3de649b4-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_CREATION_TIME = @import("../zig.zig").Guid.initString("3de649b6-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_PACKETS = @import("../zig.zig").Guid.initString("3de649b7-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_PLAY_DURATION = @import("../zig.zig").Guid.initString("3de649b8-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_SEND_DURATION = @import("../zig.zig").Guid.initString("3de649b9-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_PREROLL = @import("../zig.zig").Guid.initString("3de649ba-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_FLAGS = @import("../zig.zig").Guid.initString("3de649bb-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_MIN_PACKET_SIZE = @import("../zig.zig").Guid.initString("3de649bc-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_MAX_PACKET_SIZE = @import("../zig.zig").Guid.initString("3de649bd-d76d-4e66-9ec9-78120fb4c7e3");
pub const MF_PD_ASF_FILEPROPERTIES_MAX_BITRATE = @import("../zig.zig").Guid.initString("3de649be-d76d-4e66-9ec9-78120fb4c7e3");
pub const CLSID_WMDRMSystemID = @import("../zig.zig").Guid.initString("8948bb22-11bd-4796-93e3-974d1b575678");
pub const MF_PD_ASF_CONTENTENCRYPTION_TYPE = @import("../zig.zig").Guid.initString("8520fe3d-277e-46ea-99e4-e30a86db12be");
pub const MF_PD_ASF_CONTENTENCRYPTION_KEYID = @import("../zig.zig").Guid.initString("8520fe3e-277e-46ea-99e4-e30a86db12be");
pub const MF_PD_ASF_CONTENTENCRYPTION_SECRET_DATA = @import("../zig.zig").Guid.initString("8520fe3f-277e-46ea-99e4-e30a86db12be");
pub const MF_PD_ASF_CONTENTENCRYPTION_LICENSE_URL = @import("../zig.zig").Guid.initString("8520fe40-277e-46ea-99e4-e30a86db12be");
pub const MF_PD_ASF_CONTENTENCRYPTIONEX_ENCRYPTION_DATA = @import("../zig.zig").Guid.initString("62508be5-ecdf-4924-a359-72bab3397b9d");
pub const MF_PD_ASF_LANGLIST = @import("../zig.zig").Guid.initString("f23de43c-9977-460d-a6ec-32937f160f7d");
pub const MF_PD_ASF_LANGLIST_LEGACYORDER = @import("../zig.zig").Guid.initString("f23de43d-9977-460d-a6ec-32937f160f7d");
pub const MF_PD_ASF_MARKER = @import("../zig.zig").Guid.initString("5134330e-83a6-475e-a9d5-4fb875fb2e31");
pub const MF_PD_ASF_SCRIPT = @import("../zig.zig").Guid.initString("e29cd0d7-d602-4923-a7fe-73fd97ecc650");
pub const MF_PD_ASF_CODECLIST = @import("../zig.zig").Guid.initString("e4bb3509-c18d-4df1-bb99-7a36b3cc4119");
pub const MF_PD_ASF_METADATA_IS_VBR = @import("../zig.zig").Guid.initString("5fc6947a-ef60-445d-b449-442ecc78b4c1");
pub const MF_PD_ASF_METADATA_V8_VBRPEAK = @import("../zig.zig").Guid.initString("5fc6947b-ef60-445d-b449-442ecc78b4c1");
pub const MF_PD_ASF_METADATA_V8_BUFFERAVERAGE = @import("../zig.zig").Guid.initString("5fc6947c-ef60-445d-b449-442ecc78b4c1");
pub const MF_PD_ASF_METADATA_LEAKY_BUCKET_PAIRS = @import("../zig.zig").Guid.initString("5fc6947d-ef60-445d-b449-442ecc78b4c1");
pub const MF_PD_ASF_DATA_START_OFFSET = @import("../zig.zig").Guid.initString("e7d5b3e7-1f29-45d3-8822-3e78fae272ed");
pub const MF_PD_ASF_DATA_LENGTH = @import("../zig.zig").Guid.initString("e7d5b3e8-1f29-45d3-8822-3e78fae272ed");
pub const MF_SD_ASF_EXTSTRMPROP_LANGUAGE_ID_INDEX = @import("../zig.zig").Guid.initString("48f8a522-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_EXTSTRMPROP_AVG_DATA_BITRATE = @import("../zig.zig").Guid.initString("48f8a523-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_EXTSTRMPROP_AVG_BUFFERSIZE = @import("../zig.zig").Guid.initString("48f8a524-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_EXTSTRMPROP_MAX_DATA_BITRATE = @import("../zig.zig").Guid.initString("48f8a525-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_EXTSTRMPROP_MAX_BUFFERSIZE = @import("../zig.zig").Guid.initString("48f8a526-305d-422d-8524-2502dda33680");
pub const MF_SD_ASF_STREAMBITRATES_BITRATE = @import("../zig.zig").Guid.initString("a8e182ed-afc8-43d0-b0d1-f65bad9da558");
pub const MF_SD_ASF_METADATA_DEVICE_CONFORMANCE_TEMPLATE = @import("../zig.zig").Guid.initString("245e929d-c44e-4f7e-bb3c-77d4dfd27f8a");
pub const MF_PD_ASF_INFO_HAS_AUDIO = @import("../zig.zig").Guid.initString("80e62295-2296-4a44-b31c-d103c6fed23c");
pub const MF_PD_ASF_INFO_HAS_VIDEO = @import("../zig.zig").Guid.initString("80e62296-2296-4a44-b31c-d103c6fed23c");
pub const MF_PD_ASF_INFO_HAS_NON_AUDIO_VIDEO = @import("../zig.zig").Guid.initString("80e62297-2296-4a44-b31c-d103c6fed23c");
pub const MF_ASFPROFILE_MINPACKETSIZE = @import("../zig.zig").Guid.initString("22587626-47de-4168-87f5-b5aa9b12a8f0");
pub const MF_ASFPROFILE_MAXPACKETSIZE = @import("../zig.zig").Guid.initString("22587627-47de-4168-87f5-b5aa9b12a8f0");
pub const MF_ASFSTREAMCONFIG_LEAKYBUCKET1 = @import("../zig.zig").Guid.initString("c69b5901-ea1a-4c9b-b692-e2a0d29a8add");
pub const MF_ASFSTREAMCONFIG_LEAKYBUCKET2 = @import("../zig.zig").Guid.initString("c69b5902-ea1a-4c9b-b692-e2a0d29a8add");
pub const MFASFSampleExtension_SampleDuration = @import("../zig.zig").Guid.initString("c6bd9450-867f-4907-83a3-c77921b733ad");
pub const MFASFSampleExtension_OutputCleanPoint = @import("../zig.zig").Guid.initString("f72a3c6f-6eb4-4ebc-b192-09ad9759e828");
pub const MFASFSampleExtension_SMPTE = @import("../zig.zig").Guid.initString("399595ec-8667-4e2d-8fdb-98814ce76c1e");
pub const MFASFSampleExtension_FileName = @import("../zig.zig").Guid.initString("e165ec0e-19ed-45d7-b4a7-25cbd1e28e9b");
pub const MFASFSampleExtension_ContentType = @import("../zig.zig").Guid.initString("d590dc20-07bc-436c-9cf7-f3bbfbf1a4dc");
pub const MFASFSampleExtension_PixelAspectRatio = @import("../zig.zig").Guid.initString("1b1ee554-f9ea-4bc8-821a-376b74e4c4b8");
pub const MFASFSampleExtension_Encryption_SampleID = @import("../zig.zig").Guid.initString("6698b84e-0afa-4330-aeb2-1c0a98d7a44d");
pub const MFASFSampleExtension_Encryption_KeyID = @import("../zig.zig").Guid.initString("76376591-795f-4da1-86ed-9d46eca109a9");
pub const MFASFMutexType_Language = @import("../zig.zig").Guid.initString("72178c2b-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFASFMutexType_Bitrate = @import("../zig.zig").Guid.initString("72178c2c-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFASFMutexType_Presentation = @import("../zig.zig").Guid.initString("72178c2d-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFASFMutexType_Unknown = @import("../zig.zig").Guid.initString("72178c2e-e45b-11d5-bc2a-00b0d0f3f4ab");
pub const MFASFSPLITTER_PACKET_BOUNDARY = @import("../zig.zig").Guid.initString("fe584a05-e8d6-42e3-b176-f1211705fb6f");
pub const MFASFINDEXER_TYPE_TIMECODE = @import("../zig.zig").Guid.initString("49815231-6bad-44fd-810a-3f60984ec7fd");
pub const MF_CAPTURE_ENGINE_INITIALIZED = @import("../zig.zig").Guid.initString("219992bc-cf92-4531-a1ae-96e1e886c8f1");
pub const MF_CAPTURE_ENGINE_PREVIEW_STARTED = @import("../zig.zig").Guid.initString("a416df21-f9d3-4a74-991b-b817298952c4");
pub const MF_CAPTURE_ENGINE_PREVIEW_STOPPED = @import("../zig.zig").Guid.initString("13d5143c-1edd-4e50-a2ef-350a47678060");
pub const MF_CAPTURE_ENGINE_RECORD_STARTED = @import("../zig.zig").Guid.initString("ac2b027b-ddf9-48a0-89be-38ab35ef45c0");
pub const MF_CAPTURE_ENGINE_RECORD_STOPPED = @import("../zig.zig").Guid.initString("55e5200a-f98f-4c0d-a9ec-9eb25ed3d773");
pub const MF_CAPTURE_ENGINE_PHOTO_TAKEN = @import("../zig.zig").Guid.initString("3c50c445-7304-48eb-865d-bba19ba3af5c");
pub const MF_CAPTURE_SOURCE_CURRENT_DEVICE_MEDIA_TYPE_SET = @import("../zig.zig").Guid.initString("e7e75e4c-039c-4410-815b-8741307b63aa");
pub const MF_CAPTURE_ENGINE_ERROR = @import("../zig.zig").Guid.initString("46b89fc6-33cc-4399-9dad-784de77d587c");
pub const MF_CAPTURE_ENGINE_EFFECT_ADDED = @import("../zig.zig").Guid.initString("aa8dc7b5-a048-4e13-8ebe-f23c46c830c1");
pub const MF_CAPTURE_ENGINE_EFFECT_REMOVED = @import("../zig.zig").Guid.initString("c6e8db07-fb09-4a48-89c6-bf92a04222c9");
pub const MF_CAPTURE_ENGINE_ALL_EFFECTS_REMOVED = @import("../zig.zig").Guid.initString("fded7521-8ed8-431a-a96b-f3e2565e981c");
pub const MF_CAPTURE_SINK_PREPARED = @import("../zig.zig").Guid.initString("7bfce257-12b1-4409-8c34-d445daab7578");
pub const MF_CAPTURE_ENGINE_OUTPUT_MEDIA_TYPE_SET = @import("../zig.zig").Guid.initString("caaad994-83ec-45e9-a30a-1f20aadb9831");
pub const MF_CAPTURE_ENGINE_CAMERA_STREAM_BLOCKED = @import("../zig.zig").Guid.initString("a4209417-8d39-46f3-b759-5912528f4207");
pub const MF_CAPTURE_ENGINE_CAMERA_STREAM_UNBLOCKED = @import("../zig.zig").Guid.initString("9be9eef0-cdaf-4717-8564-834aae66415c");
pub const MF_CAPTURE_ENGINE_D3D_MANAGER = @import("../zig.zig").Guid.initString("76e25e7b-d595-4283-962c-c594afd78ddf");
pub const MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_UNPROCESSED_SAMPLES = @import("../zig.zig").Guid.initString("b467f705-7913-4894-9d42-a215fea23da9");
pub const MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_UNPROCESSED_SAMPLES = @import("../zig.zig").Guid.initString("1cddb141-a7f4-4d58-9896-4d15a53c4efe");
pub const MF_CAPTURE_ENGINE_RECORD_SINK_VIDEO_MAX_PROCESSED_SAMPLES = @import("../zig.zig").Guid.initString("e7b4a49e-382c-4aef-a946-aed5490b7111");
pub const MF_CAPTURE_ENGINE_RECORD_SINK_AUDIO_MAX_PROCESSED_SAMPLES = @import("../zig.zig").Guid.initString("9896e12a-f707-4500-b6bd-db8eb810b50f");
pub const MF_CAPTURE_ENGINE_USE_AUDIO_DEVICE_ONLY = @import("../zig.zig").Guid.initString("1c8077da-8466-4dc4-8b8e-276b3f85923b");
pub const MF_CAPTURE_ENGINE_USE_VIDEO_DEVICE_ONLY = @import("../zig.zig").Guid.initString("7e025171-cf32-4f2e-8f19-410577b73a66");
pub const MF_CAPTURE_ENGINE_DISABLE_HARDWARE_TRANSFORMS = @import("../zig.zig").Guid.initString("b7c42a6b-3207-4495-b4e7-81f9c35d5991");
pub const MF_CAPTURE_ENGINE_DISABLE_DXVA = @import("../zig.zig").Guid.initString("f9818862-179d-433f-a32f-74cbcf74466d");
pub const MF_CAPTURE_ENGINE_MEDIASOURCE_CONFIG = @import("../zig.zig").Guid.initString("bc6989d2-0fc1-46e1-a74f-efd36bc788de");
pub const MF_CAPTURE_ENGINE_DECODER_MFT_FIELDOFUSE_UNLOCK_Attribute = @import("../zig.zig").Guid.initString("2b8ad2e8-7acb-4321-a606-325c4249f4fc");
pub const MF_CAPTURE_ENGINE_ENCODER_MFT_FIELDOFUSE_UNLOCK_Attribute = @import("../zig.zig").Guid.initString("54c63a00-78d5-422f-aa3e-5e99ac649269");
pub const MF_CAPTURE_ENGINE_ENABLE_CAMERA_STREAMSTATE_NOTIFICATION = @import("../zig.zig").Guid.initString("4c808e9d-aaed-4713-90fb-cb24064ab8da");
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY = @import("../zig.zig").Guid.initString("8e3f5bd5-dbbf-42f0-8542-d07a3971762a");
pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING = @import("../zig.zig").Guid.initString("10f1be5e-7e11-410b-973d-f4b6109000fe");
pub const MF_CAPTURE_ENGINE_EVENT_GENERATOR_GUID = @import("../zig.zig").Guid.initString("abfa8ad5-fc6d-4911-87e0-961945f8f7ce");
pub const MF_CAPTURE_ENGINE_EVENT_STREAM_INDEX = @import("../zig.zig").Guid.initString("82697f44-b1cf-42eb-9753-f86d649c8865");
pub const MF_CAPTURE_ENGINE_SELECTEDCAMERAPROFILE = @import("../zig.zig").Guid.initString("03160b7e-1c6f-4db2-ad56-a7c430f82392");
pub const MF_CAPTURE_ENGINE_SELECTEDCAMERAPROFILE_INDEX = @import("../zig.zig").Guid.initString("3ce88613-2214-46c3-b417-82f8a313c9c3");
pub const CLSID_MFCaptureEngine = @import("../zig.zig").Guid.initString("efce38d3-8914-4674-a7df-ae1b3d654b8a");
pub const CLSID_MFCaptureEngineClassFactory = @import("../zig.zig").Guid.initString("efce38d3-8914-4674-a7df-ae1b3d654b8a");
pub const MFSampleExtension_DeviceReferenceSystemTime = @import("../zig.zig").Guid.initString("6523775a-ba2d-405f-b2c5-01ff88e2e8f6");
pub const MF_MSE_CALLBACK = @import("../zig.zig").Guid.initString("9063a7c0-42c5-4ffd-a8a8-6fcf9ea3d00c");
pub const MF_MSE_ACTIVELIST_CALLBACK = @import("../zig.zig").Guid.initString("949bda0f-4549-46d5-ad7f-b846e1ab1652");
pub const MF_MSE_BUFFERLIST_CALLBACK = @import("../zig.zig").Guid.initString("42e669b0-d60e-4afb-a85b-d8e5fe6bdab5");
pub const MF_MSE_VP9_SUPPORT = @import("../zig.zig").Guid.initString("92d78429-d88b-4ff0-8322-803efa6e9626");
pub const MF_MSE_OPUS_SUPPORT = @import("../zig.zig").Guid.initString("4d224cc1-8cc4-48a3-a7a7-e4c16ce6388a");
pub const MF_MEDIA_ENGINE_NEEDKEY_CALLBACK = @import("../zig.zig").Guid.initString("7ea80843-b6e4-432c-8ea4-7848ffe4220e");
pub const MF_MEDIA_ENGINE_CALLBACK = @import("../zig.zig").Guid.initString("c60381b8-83a4-41f8-a3d0-de05076849a9");
pub const MF_MEDIA_ENGINE_DXGI_MANAGER = @import("../zig.zig").Guid.initString("065702da-1094-486d-8617-ee7cc4ee4648");
pub const MF_MEDIA_ENGINE_EXTENSION = @import("../zig.zig").Guid.initString("3109fd46-060d-4b62-8dcf-faff811318d2");
pub const MF_MEDIA_ENGINE_PLAYBACK_HWND = @import("../zig.zig").Guid.initString("d988879b-67c9-4d92-baa7-6eadd446039d");
pub const MF_MEDIA_ENGINE_OPM_HWND = @import("../zig.zig").Guid.initString("a0be8ee7-0572-4f2c-a801-2a151bd3e726");
pub const MF_MEDIA_ENGINE_PLAYBACK_VISUAL = @import("../zig.zig").Guid.initString("6debd26f-6ab9-4d7e-b0ee-c61a73ffad15");
pub const MF_MEDIA_ENGINE_COREWINDOW = @import("../zig.zig").Guid.initString("fccae4dc-0b7f-41c2-9f96-4659948acddc");
pub const MF_MEDIA_ENGINE_VIDEO_OUTPUT_FORMAT = @import("../zig.zig").Guid.initString("5066893c-8cf9-42bc-8b8a-472212e52726");
pub const MF_MEDIA_ENGINE_CONTENT_PROTECTION_FLAGS = @import("../zig.zig").Guid.initString("e0350223-5aaf-4d76-a7c3-06de70894db4");
pub const MF_MEDIA_ENGINE_CONTENT_PROTECTION_MANAGER = @import("../zig.zig").Guid.initString("fdd6dfaa-bd85-4af3-9e0f-a01d539d876a");
pub const MF_MEDIA_ENGINE_AUDIO_ENDPOINT_ROLE = @import("../zig.zig").Guid.initString("d2cb93d1-116a-44f2-9385-f7d0fda2fb46");
pub const MF_MEDIA_ENGINE_AUDIO_CATEGORY = @import("../zig.zig").Guid.initString("c8d4c51d-350e-41f2-ba46-faebbb0857f6");
pub const MF_MEDIA_ENGINE_STREAM_CONTAINS_ALPHA_CHANNEL = @import("../zig.zig").Guid.initString("5cbfaf44-d2b2-4cfb-80a7-d429c74c789d");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE = @import("../zig.zig").Guid.initString("4e0212e2-e18f-41e1-95e5-c0e7e9235bc3");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE9 = @import("../zig.zig").Guid.initString("052c2d39-40c0-4188-ab86-f828273b7522");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE10 = @import("../zig.zig").Guid.initString("11a47afd-6589-4124-b312-6158ec517fc3");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE11 = @import("../zig.zig").Guid.initString("1cf1315f-ce3f-4035-9391-16142f775189");
pub const MF_MEDIA_ENGINE_BROWSER_COMPATIBILITY_MODE_IE_EDGE = @import("../zig.zig").Guid.initString("a6f3e465-3aca-442c-a3f0-ad6ddad839ae");
pub const MF_MEDIA_ENGINE_COMPATIBILITY_MODE = @import("../zig.zig").Guid.initString("3ef26ad4-dc54-45de-b9af-76c8c66bfa8e");
pub const MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WWA_EDGE = @import("../zig.zig").Guid.initString("15b29098-9f01-4e4d-b65a-c06c6c89da2a");
pub const MF_MEDIA_ENGINE_COMPATIBILITY_MODE_WIN10 = @import("../zig.zig").Guid.initString("5b25e089-6ca7-4139-a2cb-fcaab39552a3");
pub const MF_MEDIA_ENGINE_SOURCE_RESOLVER_CONFIG_STORE = @import("../zig.zig").Guid.initString("0ac0c497-b3c4-48c9-9cde-bb8ca2442ca3");
pub const MF_MEDIA_ENGINE_TRACK_ID = @import("../zig.zig").Guid.initString("65bea312-4043-4815-8eab-44dce2ef8f2a");
pub const MF_MEDIA_ENGINE_TELEMETRY_APPLICATION_ID = @import("../zig.zig").Guid.initString("1e7b273b-a7e4-402a-8f51-c48e88a2cabc");
pub const MF_MEDIA_ENGINE_SYNCHRONOUS_CLOSE = @import("../zig.zig").Guid.initString("c3c2e12f-7e0e-4e43-b91c-dc992ccdfa5e");
pub const MF_MEDIA_ENGINE_MEDIA_PLAYER_MODE = @import("../zig.zig").Guid.initString("3ddd8d45-5aa1-4112-82e5-36f6a2197e6e");
pub const CLSID_MFMediaEngineClassFactory = @import("../zig.zig").Guid.initString("b44392da-499b-446b-a4cb-005fead0e6d5");
pub const MF_MEDIA_ENGINE_TIMEDTEXT = @import("../zig.zig").Guid.initString("805ea411-92e0-4e59-9b6e-5c7d7915e64f");
pub const MF_MEDIA_ENGINE_CONTINUE_ON_CODEC_ERROR = @import("../zig.zig").Guid.initString("dbcdb7f9-48e4-4295-b70d-d518234eeb38");
pub const MF_MEDIA_ENGINE_EME_CALLBACK = @import("../zig.zig").Guid.initString("494553a7-a481-4cb7-bec5-380903513731");
pub const CLSID_MPEG2DLNASink = @import("../zig.zig").Guid.initString("fa5fe7c5-6a1d-4b11-b41f-f959d6c76500");
pub const MF_MP2DLNA_USE_MMCSS = @import("../zig.zig").Guid.initString("54f3e2ee-a2a2-497d-9834-973afde521eb");
pub const MF_MP2DLNA_VIDEO_BIT_RATE = @import("../zig.zig").Guid.initString("e88548de-73b4-42d7-9c75-adfa0a2a6e4c");
pub const MF_MP2DLNA_AUDIO_BIT_RATE = @import("../zig.zig").Guid.initString("2d1c070e-2b5f-4ab3-a7e6-8d943ba8d00a");
pub const MF_MP2DLNA_ENCODE_QUALITY = @import("../zig.zig").Guid.initString("b52379d7-1d46-4fb6-a317-a4a5f60959f8");
pub const MF_MP2DLNA_STATISTICS = @import("../zig.zig").Guid.initString("75e488a3-d5ad-4898-85e0-bcce24a722d7");
pub const CLSID_MFReadWriteClassFactory = @import("../zig.zig").Guid.initString("48e2ed0f-98c2-4a37-bed5-166312ddd83f");
pub const CLSID_MFSourceReader = @import("../zig.zig").Guid.initString("1777133c-0881-411b-a577-ad545f0714c4");
pub const MF_SOURCE_READER_ASYNC_CALLBACK = @import("../zig.zig").Guid.initString("1e3dbeac-bb43-4c35-b507-cd644464c965");
pub const MF_SOURCE_READER_D3D_MANAGER = @import("../zig.zig").Guid.initString("ec822da2-e1e9-4b29-a0d8-563c719f5269");
pub const MF_SOURCE_READER_DISABLE_DXVA = @import("../zig.zig").Guid.initString("aa456cfd-3943-4a1e-a77d-1838c0ea2e35");
pub const MF_SOURCE_READER_MEDIASOURCE_CONFIG = @import("../zig.zig").Guid.initString("9085abeb-0354-48f9-abb5-200df838c68e");
pub const MF_SOURCE_READER_MEDIASOURCE_CHARACTERISTICS = @import("../zig.zig").Guid.initString("6d23f5c8-c5d7-4a9b-9971-5d11f8bca880");
pub const MF_SOURCE_READER_ENABLE_VIDEO_PROCESSING = @import("../zig.zig").Guid.initString("fb394f3d-ccf1-42ee-bbb3-f9b845d5681d");
pub const MF_SOURCE_READER_ENABLE_ADVANCED_VIDEO_PROCESSING = @import("../zig.zig").Guid.initString("0f81da2c-b537-4672-a8b2-a681b17307a3");
pub const MF_SOURCE_READER_DISABLE_CAMERA_PLUGINS = @import("../zig.zig").Guid.initString("9d3365dd-058f-4cfb-9f97-b314cc99c8ad");
pub const MF_SOURCE_READER_DISCONNECT_MEDIASOURCE_ON_SHUTDOWN = @import("../zig.zig").Guid.initString("56b67165-219e-456d-a22e-2d3004c7fe56");
pub const MF_SOURCE_READER_ENABLE_TRANSCODE_ONLY_TRANSFORMS = @import("../zig.zig").Guid.initString("dfd4f008-b5fd-4e78-ae44-62a1e67bbe27");
pub const MF_SOURCE_READER_D3D11_BIND_FLAGS = @import("../zig.zig").Guid.initString("33f3197b-f73a-4e14-8d85-0e4c4368788d");
pub const CLSID_MFSinkWriter = @import("../zig.zig").Guid.initString("a3bbfb17-8273-4e52-9e0e-9739dc887990");
pub const MF_SINK_WRITER_ASYNC_CALLBACK = @import("../zig.zig").Guid.initString("48cb183e-7b0b-46f4-822e-5e1d2dda4354");
pub const MF_SINK_WRITER_DISABLE_THROTTLING = @import("../zig.zig").Guid.initString("08b845d8-2b74-4afe-9d53-be16d2d5ae4f");
pub const MF_SINK_WRITER_D3D_MANAGER = @import("../zig.zig").Guid.initString("ec822da2-e1e9-4b29-a0d8-563c719f5269");
pub const MF_SINK_WRITER_ENCODER_CONFIG = @import("../zig.zig").Guid.initString("ad91cd04-a7cc-4ac7-99b6-a57b9a4a7c70");
pub const MF_READWRITE_DISABLE_CONVERTERS = @import("../zig.zig").Guid.initString("98d5b065-1374-4847-8d5d-31520fee7156");
pub const MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS = @import("../zig.zig").Guid.initString("a634a91c-822b-41b9-a494-4de4643612b0");
pub const MF_READWRITE_MMCSS_CLASS = @import("../zig.zig").Guid.initString("39384300-d0eb-40b1-87a0-3318871b5a53");
pub const MF_READWRITE_MMCSS_PRIORITY = @import("../zig.zig").Guid.initString("43ad19ce-f33f-4ba9-a580-e4cd12f2d144");
pub const MF_READWRITE_MMCSS_CLASS_AUDIO = @import("../zig.zig").Guid.initString("430847da-0890-4b0e-938c-054332c547e1");
pub const MF_READWRITE_MMCSS_PRIORITY_AUDIO = @import("../zig.zig").Guid.initString("273db885-2de2-4db2-a6a7-fdb66fb40b61");
pub const MF_READWRITE_D3D_OPTIONAL = @import("../zig.zig").Guid.initString("216479d9-3071-42ca-bb6c-4c22102e1d18");
pub const MF_MEDIASINK_AUTOFINALIZE_SUPPORTED = @import("../zig.zig").Guid.initString("48c131be-135a-41cb-8290-03652509c999");
pub const MF_MEDIASINK_ENABLE_AUTOFINALIZE = @import("../zig.zig").Guid.initString("34014265-cb7e-4cde-ac7c-effd3b3c2530");
pub const MF_READWRITE_ENABLE_AUTOFINALIZE = @import("../zig.zig").Guid.initString("dd7ca129-8cd1-4dc5-9dde-ce168675de61");
pub const MFP_POSITIONTYPE_100NS = @import("../zig.zig").Guid.initString("00000000-0000-0000-0000-000000000000");
pub const MF_MEDIA_SHARING_ENGINE_DEVICE_NAME = @import("../zig.zig").Guid.initString("771e05d1-862f-4299-95ac-ae81fd14f3e7");
pub const MF_MEDIA_SHARING_ENGINE_DEVICE = @import("../zig.zig").Guid.initString("b461c58a-7a08-4b98-99a8-70fd5f3badfd");
pub const CLSID_MFMediaSharingEngineClassFactory = @import("../zig.zig").Guid.initString("f8e307fb-6d45-4ad3-9993-66cd5a529659");
pub const CLSID_MFImageSharingEngineClassFactory = @import("../zig.zig").Guid.initString("b22c3339-87f3-4059-a0c5-037aa9707eaf");
pub const CLSID_PlayToSourceClassFactory = @import("../zig.zig").Guid.initString("da17539a-3dc3-42c1-a749-a183b51f085e");
pub const GUID_PlayToService = @import("../zig.zig").Guid.initString("f6a8ff9d-9e14-41c9-bf0f-120a2b3ce120");
pub const GUID_NativeDeviceService = @import("../zig.zig").Guid.initString("ef71e53c-52f4-43c5-b86a-ad6cb216a61e");
pub const MF_CONTENTDECRYPTIONMODULE_SERVICE = @import("../zig.zig").Guid.initString("15320c45-ff80-484a-9dcb-0df894e69a01");

//--------------------------------------------------------------------------------
// Section: Types (1099)
//--------------------------------------------------------------------------------
pub const MF_Plugin_Type = extern enum(i32) {
    MFT = 0,
    MediaSource = 1,
    MFT_MatchOutputType = 2,
    Other = -1,
};
pub const MF_Plugin_Type_MFT = MF_Plugin_Type.MFT;
pub const MF_Plugin_Type_MediaSource = MF_Plugin_Type.MediaSource;
pub const MF_Plugin_Type_MFT_MatchOutputType = MF_Plugin_Type.MFT_MatchOutputType;
pub const MF_Plugin_Type_Other = MF_Plugin_Type.Other;

pub const D3DOVERLAYCAPS = extern struct {
    Caps: u32,
    MaxOverlayDisplayWidth: u32,
    MaxOverlayDisplayHeight: u32,
};

pub const D3DCONTENTPROTECTIONCAPS = extern struct {
    Caps: u32,
    KeyExchangeType: Guid,
    BufferAlignmentStart: u32,
    BlockAlignmentSize: u32,
    ProtectedMemorySize: u64,
};

const IID_IDirect3D9ExOverlayExtension_Value = @import("../zig.zig").Guid.initString("187AEB13-AAF5-4C59-876D-E059088C0DF8");
pub const IID_IDirect3D9ExOverlayExtension = &IID_IDirect3D9ExOverlayExtension_Value;
pub const IDirect3D9ExOverlayExtension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CheckDeviceOverlayType: fn(
            self: *const IDirect3D9ExOverlayExtension,
            Adapter: u32,
            DevType: D3DDEVTYPE,
            OverlayWidth: u32,
            OverlayHeight: u32,
            OverlayFormat: D3DFORMAT,
            pDisplayMode: *D3DDISPLAYMODEEX,
            DisplayRotation: D3DDISPLAYROTATION,
            pOverlayCaps: *D3DOVERLAYCAPS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3D9ExOverlayExtension_CheckDeviceOverlayType(self: *const T, Adapter: u32, DevType: D3DDEVTYPE, OverlayWidth: u32, OverlayHeight: u32, OverlayFormat: D3DFORMAT, pDisplayMode: *D3DDISPLAYMODEEX, DisplayRotation: D3DDISPLAYROTATION, pOverlayCaps: *D3DOVERLAYCAPS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3D9ExOverlayExtension.VTable, self.vtable).CheckDeviceOverlayType(@ptrCast(*const IDirect3D9ExOverlayExtension, self), Adapter, DevType, OverlayWidth, OverlayHeight, OverlayFormat, pDisplayMode, DisplayRotation, pOverlayCaps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirect3DDevice9Video_Value = @import("../zig.zig").Guid.initString("26DC4561-A1EE-4AE7-96DA-118A36C0EC95");
pub const IID_IDirect3DDevice9Video = &IID_IDirect3DDevice9Video_Value;
pub const IDirect3DDevice9Video = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContentProtectionCaps: fn(
            self: *const IDirect3DDevice9Video,
            pCryptoType: *const Guid,
            pDecodeProfile: *const Guid,
            pCaps: *D3DCONTENTPROTECTIONCAPS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAuthenticatedChannel: fn(
            self: *const IDirect3DDevice9Video,
            ChannelType: D3DAUTHENTICATEDCHANNELTYPE,
            ppAuthenticatedChannel: **IDirect3DAuthenticatedChannel9,
            pChannelHandle: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCryptoSession: fn(
            self: *const IDirect3DDevice9Video,
            pCryptoType: *const Guid,
            pDecodeProfile: *const Guid,
            ppCryptoSession: **IDirect3DCryptoSession9,
            pCryptoHandle: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDevice9Video_GetContentProtectionCaps(self: *const T, pCryptoType: *const Guid, pDecodeProfile: *const Guid, pCaps: *D3DCONTENTPROTECTIONCAPS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDevice9Video.VTable, self.vtable).GetContentProtectionCaps(@ptrCast(*const IDirect3DDevice9Video, self), pCryptoType, pDecodeProfile, pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDevice9Video_CreateAuthenticatedChannel(self: *const T, ChannelType: D3DAUTHENTICATEDCHANNELTYPE, ppAuthenticatedChannel: **IDirect3DAuthenticatedChannel9, pChannelHandle: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDevice9Video.VTable, self.vtable).CreateAuthenticatedChannel(@ptrCast(*const IDirect3DDevice9Video, self), ChannelType, ppAuthenticatedChannel, pChannelHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDevice9Video_CreateCryptoSession(self: *const T, pCryptoType: *const Guid, pDecodeProfile: *const Guid, ppCryptoSession: **IDirect3DCryptoSession9, pCryptoHandle: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDevice9Video.VTable, self.vtable).CreateCryptoSession(@ptrCast(*const IDirect3DDevice9Video, self), pCryptoType, pDecodeProfile, ppCryptoSession, pCryptoHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirect3DAuthenticatedChannel9_Value = @import("../zig.zig").Guid.initString("FF24BEEE-DA21-4BEB-98B5-D2F899F98AF9");
pub const IID_IDirect3DAuthenticatedChannel9 = &IID_IDirect3DAuthenticatedChannel9_Value;
pub const IDirect3DAuthenticatedChannel9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCertificateSize: fn(
            self: *const IDirect3DAuthenticatedChannel9,
            pCertificateSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificate: fn(
            self: *const IDirect3DAuthenticatedChannel9,
            CertifacteSize: u32,
            ppCertificate: *u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NegotiateKeyExchange: fn(
            self: *const IDirect3DAuthenticatedChannel9,
            DataSize: u32,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IDirect3DAuthenticatedChannel9,
            InputSize: u32,
            pInput: *const c_void,
            OutputSize: u32,
            pOutput: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Configure: fn(
            self: *const IDirect3DAuthenticatedChannel9,
            InputSize: u32,
            pInput: *const c_void,
            pOutput: *D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DAuthenticatedChannel9_GetCertificateSize(self: *const T, pCertificateSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DAuthenticatedChannel9.VTable, self.vtable).GetCertificateSize(@ptrCast(*const IDirect3DAuthenticatedChannel9, self), pCertificateSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DAuthenticatedChannel9_GetCertificate(self: *const T, CertifacteSize: u32, ppCertificate: *u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DAuthenticatedChannel9.VTable, self.vtable).GetCertificate(@ptrCast(*const IDirect3DAuthenticatedChannel9, self), CertifacteSize, ppCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DAuthenticatedChannel9_NegotiateKeyExchange(self: *const T, DataSize: u32, pData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DAuthenticatedChannel9.VTable, self.vtable).NegotiateKeyExchange(@ptrCast(*const IDirect3DAuthenticatedChannel9, self), DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DAuthenticatedChannel9_Query(self: *const T, InputSize: u32, pInput: *const c_void, OutputSize: u32, pOutput: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DAuthenticatedChannel9.VTable, self.vtable).Query(@ptrCast(*const IDirect3DAuthenticatedChannel9, self), InputSize, pInput, OutputSize, pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DAuthenticatedChannel9_Configure(self: *const T, InputSize: u32, pInput: *const c_void, pOutput: *D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DAuthenticatedChannel9.VTable, self.vtable).Configure(@ptrCast(*const IDirect3DAuthenticatedChannel9, self), InputSize, pInput, pOutput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirect3DCryptoSession9_Value = @import("../zig.zig").Guid.initString("FA0AB799-7A9C-48CA-8C5B-237E71A54434");
pub const IID_IDirect3DCryptoSession9 = &IID_IDirect3DCryptoSession9_Value;
pub const IDirect3DCryptoSession9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCertificateSize: fn(
            self: *const IDirect3DCryptoSession9,
            pCertificateSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificate: fn(
            self: *const IDirect3DCryptoSession9,
            CertifacteSize: u32,
            ppCertificate: *u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NegotiateKeyExchange: fn(
            self: *const IDirect3DCryptoSession9,
            DataSize: u32,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncryptionBlt: fn(
            self: *const IDirect3DCryptoSession9,
            pSrcSurface: *IDirect3DSurface9,
            pDstSurface: *IDirect3DSurface9,
            DstSurfaceSize: u32,
            pIV: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecryptionBlt: fn(
            self: *const IDirect3DCryptoSession9,
            pSrcSurface: *IDirect3DSurface9,
            pDstSurface: *IDirect3DSurface9,
            SrcSurfaceSize: u32,
            pEncryptedBlockInfo: *D3DENCRYPTED_BLOCK_INFO,
            pContentKey: *c_void,
            pIV: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSurfacePitch: fn(
            self: *const IDirect3DCryptoSession9,
            pSrcSurface: *IDirect3DSurface9,
            pSurfacePitch: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSessionKeyRefresh: fn(
            self: *const IDirect3DCryptoSession9,
            pRandomNumber: *c_void,
            RandomNumberSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FinishSessionKeyRefresh: fn(
            self: *const IDirect3DCryptoSession9,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEncryptionBltKey: fn(
            self: *const IDirect3DCryptoSession9,
            pReadbackKey: *c_void,
            KeySize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DCryptoSession9_GetCertificateSize(self: *const T, pCertificateSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DCryptoSession9.VTable, self.vtable).GetCertificateSize(@ptrCast(*const IDirect3DCryptoSession9, self), pCertificateSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DCryptoSession9_GetCertificate(self: *const T, CertifacteSize: u32, ppCertificate: *u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DCryptoSession9.VTable, self.vtable).GetCertificate(@ptrCast(*const IDirect3DCryptoSession9, self), CertifacteSize, ppCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DCryptoSession9_NegotiateKeyExchange(self: *const T, DataSize: u32, pData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DCryptoSession9.VTable, self.vtable).NegotiateKeyExchange(@ptrCast(*const IDirect3DCryptoSession9, self), DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DCryptoSession9_EncryptionBlt(self: *const T, pSrcSurface: *IDirect3DSurface9, pDstSurface: *IDirect3DSurface9, DstSurfaceSize: u32, pIV: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DCryptoSession9.VTable, self.vtable).EncryptionBlt(@ptrCast(*const IDirect3DCryptoSession9, self), pSrcSurface, pDstSurface, DstSurfaceSize, pIV);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DCryptoSession9_DecryptionBlt(self: *const T, pSrcSurface: *IDirect3DSurface9, pDstSurface: *IDirect3DSurface9, SrcSurfaceSize: u32, pEncryptedBlockInfo: *D3DENCRYPTED_BLOCK_INFO, pContentKey: *c_void, pIV: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DCryptoSession9.VTable, self.vtable).DecryptionBlt(@ptrCast(*const IDirect3DCryptoSession9, self), pSrcSurface, pDstSurface, SrcSurfaceSize, pEncryptedBlockInfo, pContentKey, pIV);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DCryptoSession9_GetSurfacePitch(self: *const T, pSrcSurface: *IDirect3DSurface9, pSurfacePitch: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DCryptoSession9.VTable, self.vtable).GetSurfacePitch(@ptrCast(*const IDirect3DCryptoSession9, self), pSrcSurface, pSurfacePitch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DCryptoSession9_StartSessionKeyRefresh(self: *const T, pRandomNumber: *c_void, RandomNumberSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DCryptoSession9.VTable, self.vtable).StartSessionKeyRefresh(@ptrCast(*const IDirect3DCryptoSession9, self), pRandomNumber, RandomNumberSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DCryptoSession9_FinishSessionKeyRefresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DCryptoSession9.VTable, self.vtable).FinishSessionKeyRefresh(@ptrCast(*const IDirect3DCryptoSession9, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DCryptoSession9_GetEncryptionBltKey(self: *const T, pReadbackKey: *c_void, KeySize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DCryptoSession9.VTable, self.vtable).GetEncryptionBltKey(@ptrCast(*const IDirect3DCryptoSession9, self), pReadbackKey, KeySize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CodecAPIEventData = extern struct {
    guid: Guid,
    dataLength: u32,
    reserved: [3]u32,
};

const IID_ICodecAPI_Value = @import("../zig.zig").Guid.initString("901DB4C7-31CE-41A2-85DC-8FA0BF41B8DA");
pub const IID_ICodecAPI = &IID_ICodecAPI_Value;
pub const ICodecAPI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsSupported: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsModifiable: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameterRange: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
            ValueMin: *VARIANT,
            ValueMax: *VARIANT,
            SteppingDelta: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameterValues: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
            Values: [*]*VARIANT,
            ValuesCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultValue: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
            Value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
            Value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
            Value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForEvent: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
            userData: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterForEvent: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllDefaults: fn(
            self: *const ICodecAPI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValueWithNotify: fn(
            self: *const ICodecAPI,
            Api: *const Guid,
            Value: *VARIANT,
            ChangedParam: [*]*Guid,
            ChangedParamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllDefaultsWithNotify: fn(
            self: *const ICodecAPI,
            ChangedParam: [*]*Guid,
            ChangedParamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllSettings: fn(
            self: *const ICodecAPI,
            __MIDL__ICodecAPI0000: *IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllSettings: fn(
            self: *const ICodecAPI,
            __MIDL__ICodecAPI0001: *IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllSettingsWithNotify: fn(
            self: *const ICodecAPI,
            __MIDL__ICodecAPI0002: *IStream,
            ChangedParam: [*]*Guid,
            ChangedParamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_IsSupported(self: *const T, Api: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).IsSupported(@ptrCast(*const ICodecAPI, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_IsModifiable(self: *const T, Api: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).IsModifiable(@ptrCast(*const ICodecAPI, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_GetParameterRange(self: *const T, Api: *const Guid, ValueMin: *VARIANT, ValueMax: *VARIANT, SteppingDelta: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).GetParameterRange(@ptrCast(*const ICodecAPI, self), Api, ValueMin, ValueMax, SteppingDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_GetParameterValues(self: *const T, Api: *const Guid, Values: [*]*VARIANT, ValuesCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).GetParameterValues(@ptrCast(*const ICodecAPI, self), Api, Values, ValuesCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_GetDefaultValue(self: *const T, Api: *const Guid, Value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).GetDefaultValue(@ptrCast(*const ICodecAPI, self), Api, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_GetValue(self: *const T, Api: *const Guid, Value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).GetValue(@ptrCast(*const ICodecAPI, self), Api, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_SetValue(self: *const T, Api: *const Guid, Value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).SetValue(@ptrCast(*const ICodecAPI, self), Api, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_RegisterForEvent(self: *const T, Api: *const Guid, userData: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).RegisterForEvent(@ptrCast(*const ICodecAPI, self), Api, userData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_UnregisterForEvent(self: *const T, Api: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).UnregisterForEvent(@ptrCast(*const ICodecAPI, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_SetAllDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).SetAllDefaults(@ptrCast(*const ICodecAPI, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_SetValueWithNotify(self: *const T, Api: *const Guid, Value: *VARIANT, ChangedParam: [*]*Guid, ChangedParamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).SetValueWithNotify(@ptrCast(*const ICodecAPI, self), Api, Value, ChangedParam, ChangedParamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_SetAllDefaultsWithNotify(self: *const T, ChangedParam: [*]*Guid, ChangedParamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).SetAllDefaultsWithNotify(@ptrCast(*const ICodecAPI, self), ChangedParam, ChangedParamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_GetAllSettings(self: *const T, __MIDL__ICodecAPI0000: *IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).GetAllSettings(@ptrCast(*const ICodecAPI, self), __MIDL__ICodecAPI0000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_SetAllSettings(self: *const T, __MIDL__ICodecAPI0001: *IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).SetAllSettings(@ptrCast(*const ICodecAPI, self), __MIDL__ICodecAPI0001);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICodecAPI_SetAllSettingsWithNotify(self: *const T, __MIDL__ICodecAPI0002: *IStream, ChangedParam: [*]*Guid, ChangedParamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICodecAPI.VTable, self.vtable).SetAllSettingsWithNotify(@ptrCast(*const ICodecAPI, self), __MIDL__ICodecAPI0002, ChangedParam, ChangedParamCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_FIELD_TYPE = extern enum(i32) {
    NONE = 0,
    INTERLACED_TOP_FIELD_FIRST = 1,
    INTERLACED_BOTTOM_FIELD_FIRST = 2,
};
pub const D3D12_VIDEO_FIELD_TYPE_NONE = D3D12_VIDEO_FIELD_TYPE.NONE;
pub const D3D12_VIDEO_FIELD_TYPE_INTERLACED_TOP_FIELD_FIRST = D3D12_VIDEO_FIELD_TYPE.INTERLACED_TOP_FIELD_FIRST;
pub const D3D12_VIDEO_FIELD_TYPE_INTERLACED_BOTTOM_FIELD_FIRST = D3D12_VIDEO_FIELD_TYPE.INTERLACED_BOTTOM_FIELD_FIRST;

pub const D3D12_VIDEO_FRAME_STEREO_FORMAT = extern enum(i32) {
    NONE = 0,
    MONO = 1,
    HORIZONTAL = 2,
    VERTICAL = 3,
    SEPARATE = 4,
};
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_NONE = D3D12_VIDEO_FRAME_STEREO_FORMAT.NONE;
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_MONO = D3D12_VIDEO_FRAME_STEREO_FORMAT.MONO;
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_HORIZONTAL = D3D12_VIDEO_FRAME_STEREO_FORMAT.HORIZONTAL;
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_VERTICAL = D3D12_VIDEO_FRAME_STEREO_FORMAT.VERTICAL;
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_SEPARATE = D3D12_VIDEO_FRAME_STEREO_FORMAT.SEPARATE;

pub const D3D12_VIDEO_FORMAT = extern struct {
    Format: DXGI_FORMAT,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
};

pub const D3D12_VIDEO_SAMPLE = extern struct {
    Width: u32,
    Height: u32,
    Format: D3D12_VIDEO_FORMAT,
};

pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE = extern enum(i32) {
    NONE = 0,
    FIELD_BASED = 1,
};
pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_NONE = D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE.NONE;
pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_FIELD_BASED = D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE.FIELD_BASED;

pub const D3D12_FEATURE_VIDEO = extern enum(i32) {
    DECODE_SUPPORT = 0,
    DECODE_PROFILES = 1,
    DECODE_FORMATS = 2,
    DECODE_CONVERSION_SUPPORT = 3,
    PROCESS_SUPPORT = 5,
    PROCESS_MAX_INPUT_STREAMS = 6,
    PROCESS_REFERENCE_INFO = 7,
    DECODER_HEAP_SIZE = 8,
    PROCESSOR_SIZE = 9,
    DECODE_PROFILE_COUNT = 10,
    DECODE_FORMAT_COUNT = 11,
    ARCHITECTURE = 17,
    DECODE_HISTOGRAM = 18,
    FEATURE_AREA_SUPPORT = 19,
    MOTION_ESTIMATOR = 20,
    MOTION_ESTIMATOR_SIZE = 21,
    EXTENSION_COMMAND_COUNT = 22,
    EXTENSION_COMMANDS = 23,
    EXTENSION_COMMAND_PARAMETER_COUNT = 24,
    EXTENSION_COMMAND_PARAMETERS = 25,
    EXTENSION_COMMAND_SUPPORT = 26,
    EXTENSION_COMMAND_SIZE = 27,
    DECODE_PROTECTED_RESOURCES = 28,
    PROCESS_PROTECTED_RESOURCES = 29,
    MOTION_ESTIMATOR_PROTECTED_RESOURCES = 30,
    DECODER_HEAP_SIZE1 = 31,
    PROCESSOR_SIZE1 = 32,
};
pub const D3D12_FEATURE_VIDEO_DECODE_SUPPORT = D3D12_FEATURE_VIDEO.DECODE_SUPPORT;
pub const D3D12_FEATURE_VIDEO_DECODE_PROFILES = D3D12_FEATURE_VIDEO.DECODE_PROFILES;
pub const D3D12_FEATURE_VIDEO_DECODE_FORMATS = D3D12_FEATURE_VIDEO.DECODE_FORMATS;
pub const D3D12_FEATURE_VIDEO_DECODE_CONVERSION_SUPPORT = D3D12_FEATURE_VIDEO.DECODE_CONVERSION_SUPPORT;
pub const D3D12_FEATURE_VIDEO_PROCESS_SUPPORT = D3D12_FEATURE_VIDEO.PROCESS_SUPPORT;
pub const D3D12_FEATURE_VIDEO_PROCESS_MAX_INPUT_STREAMS = D3D12_FEATURE_VIDEO.PROCESS_MAX_INPUT_STREAMS;
pub const D3D12_FEATURE_VIDEO_PROCESS_REFERENCE_INFO = D3D12_FEATURE_VIDEO.PROCESS_REFERENCE_INFO;
pub const D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE = D3D12_FEATURE_VIDEO.DECODER_HEAP_SIZE;
pub const D3D12_FEATURE_VIDEO_PROCESSOR_SIZE = D3D12_FEATURE_VIDEO.PROCESSOR_SIZE;
pub const D3D12_FEATURE_VIDEO_DECODE_PROFILE_COUNT = D3D12_FEATURE_VIDEO.DECODE_PROFILE_COUNT;
pub const D3D12_FEATURE_VIDEO_DECODE_FORMAT_COUNT = D3D12_FEATURE_VIDEO.DECODE_FORMAT_COUNT;
pub const D3D12_FEATURE_VIDEO_ARCHITECTURE = D3D12_FEATURE_VIDEO.ARCHITECTURE;
pub const D3D12_FEATURE_VIDEO_DECODE_HISTOGRAM = D3D12_FEATURE_VIDEO.DECODE_HISTOGRAM;
pub const D3D12_FEATURE_VIDEO_FEATURE_AREA_SUPPORT = D3D12_FEATURE_VIDEO.FEATURE_AREA_SUPPORT;
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR = D3D12_FEATURE_VIDEO.MOTION_ESTIMATOR;
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_SIZE = D3D12_FEATURE_VIDEO.MOTION_ESTIMATOR_SIZE;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_COUNT = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_COUNT;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMANDS = D3D12_FEATURE_VIDEO.EXTENSION_COMMANDS;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_PARAMETER_COUNT;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_PARAMETERS;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SUPPORT = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_SUPPORT;
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SIZE = D3D12_FEATURE_VIDEO.EXTENSION_COMMAND_SIZE;
pub const D3D12_FEATURE_VIDEO_DECODE_PROTECTED_RESOURCES = D3D12_FEATURE_VIDEO.DECODE_PROTECTED_RESOURCES;
pub const D3D12_FEATURE_VIDEO_PROCESS_PROTECTED_RESOURCES = D3D12_FEATURE_VIDEO.PROCESS_PROTECTED_RESOURCES;
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES = D3D12_FEATURE_VIDEO.MOTION_ESTIMATOR_PROTECTED_RESOURCES;
pub const D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE1 = D3D12_FEATURE_VIDEO.DECODER_HEAP_SIZE1;
pub const D3D12_FEATURE_VIDEO_PROCESSOR_SIZE1 = D3D12_FEATURE_VIDEO.PROCESSOR_SIZE1;

pub const D3D12_BITSTREAM_ENCRYPTION_TYPE = extern enum(i32) {
    NONE = 0,
};
pub const D3D12_BITSTREAM_ENCRYPTION_TYPE_NONE = D3D12_BITSTREAM_ENCRYPTION_TYPE.NONE;

pub const D3D12_VIDEO_DECODE_CONFIGURATION = extern struct {
    DecodeProfile: Guid,
    BitstreamEncryption: D3D12_BITSTREAM_ENCRYPTION_TYPE,
    InterlaceType: D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE,
};

pub const D3D12_VIDEO_DECODER_DESC = extern struct {
    NodeMask: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
};

pub const D3D12_VIDEO_DECODER_HEAP_DESC = extern struct {
    NodeMask: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    DecodeWidth: u32,
    DecodeHeight: u32,
    Format: DXGI_FORMAT,
    FrameRate: DXGI_RATIONAL,
    BitRate: u32,
    MaxDecodePictureBufferCount: u32,
};

pub const D3D12_VIDEO_SIZE_RANGE = extern struct {
    MaxWidth: u32,
    MaxHeight: u32,
    MinWidth: u32,
    MinHeight: u32,
};

pub const D3D12_VIDEO_PROCESS_FILTER = extern enum(i32) {
    BRIGHTNESS = 0,
    CONTRAST = 1,
    HUE = 2,
    SATURATION = 3,
    NOISE_REDUCTION = 4,
    EDGE_ENHANCEMENT = 5,
    ANAMORPHIC_SCALING = 6,
    STEREO_ADJUSTMENT = 7,
};
pub const D3D12_VIDEO_PROCESS_FILTER_BRIGHTNESS = D3D12_VIDEO_PROCESS_FILTER.BRIGHTNESS;
pub const D3D12_VIDEO_PROCESS_FILTER_CONTRAST = D3D12_VIDEO_PROCESS_FILTER.CONTRAST;
pub const D3D12_VIDEO_PROCESS_FILTER_HUE = D3D12_VIDEO_PROCESS_FILTER.HUE;
pub const D3D12_VIDEO_PROCESS_FILTER_SATURATION = D3D12_VIDEO_PROCESS_FILTER.SATURATION;
pub const D3D12_VIDEO_PROCESS_FILTER_NOISE_REDUCTION = D3D12_VIDEO_PROCESS_FILTER.NOISE_REDUCTION;
pub const D3D12_VIDEO_PROCESS_FILTER_EDGE_ENHANCEMENT = D3D12_VIDEO_PROCESS_FILTER.EDGE_ENHANCEMENT;
pub const D3D12_VIDEO_PROCESS_FILTER_ANAMORPHIC_SCALING = D3D12_VIDEO_PROCESS_FILTER.ANAMORPHIC_SCALING;
pub const D3D12_VIDEO_PROCESS_FILTER_STEREO_ADJUSTMENT = D3D12_VIDEO_PROCESS_FILTER.STEREO_ADJUSTMENT;

pub const D3D12_VIDEO_PROCESS_FILTER_FLAGS = extern enum(i32) {
    D3D12_VIDEO_PROCESS_FILTER_FLAG_NONE = 0,
    D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS = 1,
    D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST = 2,
    D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE = 4,
    D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION = 8,
    D3D12_VIDEO_PROCESS_FILTER_FLAG_NOISE_REDUCTION = 16,
    D3D12_VIDEO_PROCESS_FILTER_FLAG_EDGE_ENHANCEMENT = 32,
    D3D12_VIDEO_PROCESS_FILTER_FLAG_ANAMORPHIC_SCALING = 64,
    D3D12_VIDEO_PROCESS_FILTER_FLAG_STEREO_ADJUSTMENT = 128,
};
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_NONE = D3D12_VIDEO_PROCESS_FILTER_FLAGS.D3D12_VIDEO_PROCESS_FILTER_FLAG_NONE;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS = D3D12_VIDEO_PROCESS_FILTER_FLAGS.D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST = D3D12_VIDEO_PROCESS_FILTER_FLAGS.D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE = D3D12_VIDEO_PROCESS_FILTER_FLAGS.D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION = D3D12_VIDEO_PROCESS_FILTER_FLAGS.D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_NOISE_REDUCTION = D3D12_VIDEO_PROCESS_FILTER_FLAGS.D3D12_VIDEO_PROCESS_FILTER_FLAG_NOISE_REDUCTION;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_EDGE_ENHANCEMENT = D3D12_VIDEO_PROCESS_FILTER_FLAGS.D3D12_VIDEO_PROCESS_FILTER_FLAG_EDGE_ENHANCEMENT;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_ANAMORPHIC_SCALING = D3D12_VIDEO_PROCESS_FILTER_FLAGS.D3D12_VIDEO_PROCESS_FILTER_FLAG_ANAMORPHIC_SCALING;
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_STEREO_ADJUSTMENT = D3D12_VIDEO_PROCESS_FILTER_FLAGS.D3D12_VIDEO_PROCESS_FILTER_FLAG_STEREO_ADJUSTMENT;

pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS = extern enum(i32) {
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_NONE = 0,
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB = 1,
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM = -2147483648,
};
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_NONE = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS.D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_NONE;
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS.D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB;
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM = D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS.D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM;

pub const D3D12_VIDEO_PROCESS_ALPHA_BLENDING = extern struct {
    Enable: BOOL,
    Alpha: f32,
};

pub const D3D12_VIDEO_PROCESS_LUMA_KEY = extern struct {
    Enable: BOOL,
    Lower: f32,
    Upper: f32,
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC = extern struct {
    Format: DXGI_FORMAT,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
    SourceAspectRatio: DXGI_RATIONAL,
    DestinationAspectRatio: DXGI_RATIONAL,
    FrameRate: DXGI_RATIONAL,
    SourceSizeRange: D3D12_VIDEO_SIZE_RANGE,
    DestinationSizeRange: D3D12_VIDEO_SIZE_RANGE,
    EnableOrientation: BOOL,
    FilterFlags: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    StereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    FieldType: D3D12_VIDEO_FIELD_TYPE,
    DeinterlaceMode: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    EnableAlphaBlending: BOOL,
    LumaKey: D3D12_VIDEO_PROCESS_LUMA_KEY,
    NumPastFrames: u32,
    NumFutureFrames: u32,
    EnableAutoProcessing: BOOL,
};

pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE = extern enum(i32) {
    OPAQUE = 0,
    BACKGROUND = 1,
    DESTINATION = 2,
    SOURCE_STREAM = 3,
};
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_OPAQUE = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE.OPAQUE;
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_BACKGROUND = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE.BACKGROUND;
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_DESTINATION = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE.DESTINATION;
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_SOURCE_STREAM = D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE.SOURCE_STREAM;

pub const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC = extern struct {
    Format: DXGI_FORMAT,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
    AlphaFillMode: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE,
    AlphaFillModeSourceStreamIndex: u32,
    BackgroundColor: [4]f32,
    FrameRate: DXGI_RATIONAL,
    EnableStereo: BOOL,
};

const IID_ID3D12VideoDecoderHeap_Value = @import("../zig.zig").Guid.initString("0946B7C9-EBF6-4047-BB73-8683E27DBB1F");
pub const IID_ID3D12VideoDecoderHeap = &IID_ID3D12VideoDecoderHeap_Value;
pub const ID3D12VideoDecoderHeap = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: fn(
            self: *const ID3D12VideoDecoderHeap,
        ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_DECODER_HEAP_DESC,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12Pageable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecoderHeap_GetDesc(self: *const T) callconv(.Inline) D3D12_VIDEO_DECODER_HEAP_DESC {
            return @ptrCast(*const ID3D12VideoDecoderHeap.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D12VideoDecoderHeap, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDevice_Value = @import("../zig.zig").Guid.initString("1F052807-0B46-4ACC-8A89-364F793718A4");
pub const IID_ID3D12VideoDevice = &IID_ID3D12VideoDevice_Value;
pub const ID3D12VideoDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CheckFeatureSupport: fn(
            self: *const ID3D12VideoDevice,
            FeatureVideo: D3D12_FEATURE_VIDEO,
            pFeatureSupportData: [*]u8,
            FeatureSupportDataSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoDecoder: fn(
            self: *const ID3D12VideoDevice,
            pDesc: *const D3D12_VIDEO_DECODER_DESC,
            riid: *const Guid,
            ppVideoDecoder: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoDecoderHeap: fn(
            self: *const ID3D12VideoDevice,
            pVideoDecoderHeapDesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
            riid: *const Guid,
            ppVideoDecoderHeap: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoProcessor: fn(
            self: *const ID3D12VideoDevice,
            NodeMask: u32,
            pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
            NumInputStreamDescs: u32,
            pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
            riid: *const Guid,
            ppVideoProcessor: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice_CheckFeatureSupport(self: *const T, FeatureVideo: D3D12_FEATURE_VIDEO, pFeatureSupportData: [*]u8, FeatureSupportDataSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice.VTable, self.vtable).CheckFeatureSupport(@ptrCast(*const ID3D12VideoDevice, self), FeatureVideo, pFeatureSupportData, FeatureSupportDataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice_CreateVideoDecoder(self: *const T, pDesc: *const D3D12_VIDEO_DECODER_DESC, riid: *const Guid, ppVideoDecoder: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice.VTable, self.vtable).CreateVideoDecoder(@ptrCast(*const ID3D12VideoDevice, self), pDesc, riid, ppVideoDecoder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice_CreateVideoDecoderHeap(self: *const T, pVideoDecoderHeapDesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, riid: *const Guid, ppVideoDecoderHeap: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice.VTable, self.vtable).CreateVideoDecoderHeap(@ptrCast(*const ID3D12VideoDevice, self), pVideoDecoderHeapDesc, riid, ppVideoDecoderHeap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice_CreateVideoProcessor(self: *const T, NodeMask: u32, pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, NumInputStreamDescs: u32, pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, riid: *const Guid, ppVideoProcessor: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice.VTable, self.vtable).CreateVideoProcessor(@ptrCast(*const ID3D12VideoDevice, self), NodeMask, pOutputStreamDesc, NumInputStreamDescs, pInputStreamDescs, riid, ppVideoProcessor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDecoder_Value = @import("../zig.zig").Guid.initString("C59B6BDC-7720-4074-A136-17A156037470");
pub const IID_ID3D12VideoDecoder = &IID_ID3D12VideoDecoder_Value;
pub const ID3D12VideoDecoder = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: fn(
            self: *const ID3D12VideoDecoder,
        ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_DECODER_DESC,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12Pageable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecoder_GetDesc(self: *const T) callconv(.Inline) D3D12_VIDEO_DECODER_DESC {
            return @ptrCast(*const ID3D12VideoDecoder.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D12VideoDecoder, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_DECODE_TIER = extern enum(i32) {
    NOT_SUPPORTED = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
};
pub const D3D12_VIDEO_DECODE_TIER_NOT_SUPPORTED = D3D12_VIDEO_DECODE_TIER.NOT_SUPPORTED;
pub const D3D12_VIDEO_DECODE_TIER_1 = D3D12_VIDEO_DECODE_TIER._1;
pub const D3D12_VIDEO_DECODE_TIER_2 = D3D12_VIDEO_DECODE_TIER._2;
pub const D3D12_VIDEO_DECODE_TIER_3 = D3D12_VIDEO_DECODE_TIER._3;

pub const D3D12_VIDEO_DECODE_SUPPORT_FLAGS = extern enum(i32) {
    D3D12_VIDEO_DECODE_SUPPORT_FLAG_NONE = 0,
    D3D12_VIDEO_DECODE_SUPPORT_FLAG_SUPPORTED = 1,
};
pub const D3D12_VIDEO_DECODE_SUPPORT_FLAG_NONE = D3D12_VIDEO_DECODE_SUPPORT_FLAGS.D3D12_VIDEO_DECODE_SUPPORT_FLAG_NONE;
pub const D3D12_VIDEO_DECODE_SUPPORT_FLAG_SUPPORTED = D3D12_VIDEO_DECODE_SUPPORT_FLAGS.D3D12_VIDEO_DECODE_SUPPORT_FLAG_SUPPORTED;

pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = extern enum(i32) {
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_NONE = 0,
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED = 1,
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_POST_PROCESSING_SUPPORTED = 2,
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_REFERENCE_ONLY_ALLOCATIONS_REQUIRED = 4,
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME = 8,
};
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_NONE = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_NONE;
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED;
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_POST_PROCESSING_SUPPORTED = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_POST_PROCESSING_SUPPORTED;
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_REFERENCE_ONLY_ALLOCATIONS_REQUIRED = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_REFERENCE_ONLY_ALLOCATIONS_REQUIRED;
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS.D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME;

pub const D3D12_VIDEO_DECODE_STATUS = extern enum(i32) {
    OK = 0,
    CONTINUE = 1,
    CONTINUE_SKIP_DISPLAY = 2,
    RESTART = 3,
    RATE_EXCEEDED = 4,
};
pub const D3D12_VIDEO_DECODE_STATUS_OK = D3D12_VIDEO_DECODE_STATUS.OK;
pub const D3D12_VIDEO_DECODE_STATUS_CONTINUE = D3D12_VIDEO_DECODE_STATUS.CONTINUE;
pub const D3D12_VIDEO_DECODE_STATUS_CONTINUE_SKIP_DISPLAY = D3D12_VIDEO_DECODE_STATUS.CONTINUE_SKIP_DISPLAY;
pub const D3D12_VIDEO_DECODE_STATUS_RESTART = D3D12_VIDEO_DECODE_STATUS.RESTART;
pub const D3D12_VIDEO_DECODE_STATUS_RATE_EXCEEDED = D3D12_VIDEO_DECODE_STATUS.RATE_EXCEEDED;

pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE = extern enum(i32) {
    PICTURE_PARAMETERS = 0,
    INVERSE_QUANTIZATION_MATRIX = 1,
    SLICE_CONTROL = 2,
    MAX_VALID = 3,
};
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_PICTURE_PARAMETERS = D3D12_VIDEO_DECODE_ARGUMENT_TYPE.PICTURE_PARAMETERS;
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_INVERSE_QUANTIZATION_MATRIX = D3D12_VIDEO_DECODE_ARGUMENT_TYPE.INVERSE_QUANTIZATION_MATRIX;
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_SLICE_CONTROL = D3D12_VIDEO_DECODE_ARGUMENT_TYPE.SLICE_CONTROL;
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_MAX_VALID = D3D12_VIDEO_DECODE_ARGUMENT_TYPE.MAX_VALID;

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    Width: u32,
    Height: u32,
    DecodeFormat: DXGI_FORMAT,
    FrameRate: DXGI_RATIONAL,
    BitRate: u32,
    SupportFlags: D3D12_VIDEO_DECODE_SUPPORT_FLAGS,
    ConfigurationFlags: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS,
    DecodeTier: D3D12_VIDEO_DECODE_TIER,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT = extern struct {
    NodeIndex: u32,
    ProfileCount: u32,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES = extern struct {
    NodeIndex: u32,
    ProfileCount: u32,
    pProfiles: *Guid,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    FormatCount: u32,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    FormatCount: u32,
    pOutputFormats: *DXGI_FORMAT,
};

pub const D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE = extern struct {
    IOCoherent: BOOL,
};

pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT = extern enum(i32) {
    Y = 0,
    U = 1,
    V = 2,
    R = 0,
    G = 1,
    B = 2,
    A = 3,
};
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_Y = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.Y;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_U = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.U;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_V = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.V;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_R = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.R;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_G = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.G;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_B = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.B;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_A = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT.A;

pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS = extern enum(i32) {
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_NONE = 0,
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_Y = 1,
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_U = 2,
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_V = 4,
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_R = 1,
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_G = 2,
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_B = 4,
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_A = 8,
};
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_NONE = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_NONE;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_Y = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_Y;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_U = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_U;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_V = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_V;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_R = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_R;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_G = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_G;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_B = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_B;
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_A = D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS.D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_A;

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM = extern struct {
    NodeIndex: u32,
    DecodeProfile: Guid,
    Width: u32,
    Height: u32,
    DecodeFormat: DXGI_FORMAT,
    Components: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS,
    BinCount: u32,
    CounterBitDepth: u32,
};

pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS = extern enum(i32) {
    D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_NONE = 0,
    D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_SUPPORTED = 1,
};
pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_NONE = D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS.D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_NONE;
pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_SUPPORTED = D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS.D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_SUPPORTED;

pub const D3D12_VIDEO_SCALE_SUPPORT_FLAGS = extern enum(i32) {
    D3D12_VIDEO_SCALE_SUPPORT_FLAG_NONE = 0,
    D3D12_VIDEO_SCALE_SUPPORT_FLAG_POW2_ONLY = 1,
    D3D12_VIDEO_SCALE_SUPPORT_FLAG_EVEN_DIMENSIONS_ONLY = 2,
};
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_NONE = D3D12_VIDEO_SCALE_SUPPORT_FLAGS.D3D12_VIDEO_SCALE_SUPPORT_FLAG_NONE;
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_POW2_ONLY = D3D12_VIDEO_SCALE_SUPPORT_FLAGS.D3D12_VIDEO_SCALE_SUPPORT_FLAG_POW2_ONLY;
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_EVEN_DIMENSIONS_ONLY = D3D12_VIDEO_SCALE_SUPPORT_FLAGS.D3D12_VIDEO_SCALE_SUPPORT_FLAG_EVEN_DIMENSIONS_ONLY;

pub const D3D12_VIDEO_SCALE_SUPPORT = extern struct {
    OutputSizeRange: D3D12_VIDEO_SIZE_RANGE,
    Flags: D3D12_VIDEO_SCALE_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    DecodeSample: D3D12_VIDEO_SAMPLE,
    OutputFormat: D3D12_VIDEO_FORMAT,
    FrameRate: DXGI_RATIONAL,
    BitRate: u32,
    SupportFlags: D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS,
    ScaleSupport: D3D12_VIDEO_SCALE_SUPPORT,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE = extern struct {
    VideoDecoderHeapDesc: D3D12_VIDEO_DECODER_HEAP_DESC,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE = extern struct {
    NodeMask: u32,
    pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    NumInputStreamDescs: u32,
    pInputStreamDescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS = extern struct {
    Status: u64,
    NumMacroblocksAffected: u64,
    FrameRate: DXGI_RATIONAL,
    BitRate: u32,
};

pub const D3D12_VIDEO_DECODE_FRAME_ARGUMENT = extern struct {
    Type: D3D12_VIDEO_DECODE_ARGUMENT_TYPE,
    Size: u32,
    pData: *c_void,
};

pub const D3D12_VIDEO_DECODE_REFERENCE_FRAMES = extern struct {
    NumTexture2Ds: u32,
    ppTexture2Ds: **ID3D12Resource,
    pSubresources: *u32,
    ppHeaps: **ID3D12VideoDecoderHeap,
};

pub const D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM = extern struct {
    pBuffer: *ID3D12Resource,
    Offset: u64,
    Size: u64,
};

pub const D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS = extern struct {
    Enable: BOOL,
    pReferenceTexture2D: *ID3D12Resource,
    ReferenceSubresource: u32,
    OutputColorSpace: DXGI_COLOR_SPACE_TYPE,
    DecodeColorSpace: DXGI_COLOR_SPACE_TYPE,
};

pub const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS = extern struct {
    NumFrameArguments: u32,
    FrameArguments: [10]D3D12_VIDEO_DECODE_FRAME_ARGUMENT,
    ReferenceFrames: D3D12_VIDEO_DECODE_REFERENCE_FRAMES,
    CompressedBitstream: D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM,
    pHeap: *ID3D12VideoDecoderHeap,
};

pub const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS = extern struct {
    pOutputTexture2D: *ID3D12Resource,
    OutputSubresource: u32,
    ConversionArguments: D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS,
};

const IID_ID3D12VideoProcessor_Value = @import("../zig.zig").Guid.initString("304FDB32-BEDE-410A-8545-943AC6A46138");
pub const IID_ID3D12VideoProcessor = &IID_ID3D12VideoProcessor_Value;
pub const ID3D12VideoProcessor = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetNodeMask: fn(
            self: *const ID3D12VideoProcessor,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetNumInputStreamDescs: fn(
            self: *const ID3D12VideoProcessor,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetInputStreamDescs: fn(
            self: *const ID3D12VideoProcessor,
            NumInputStreamDescs: u32,
            pInputStreamDescs: [*]D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStreamDesc: fn(
            self: *const ID3D12VideoProcessor,
        ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12Pageable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessor_GetNodeMask(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D12VideoProcessor.VTable, self.vtable).GetNodeMask(@ptrCast(*const ID3D12VideoProcessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessor_GetNumInputStreamDescs(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D12VideoProcessor.VTable, self.vtable).GetNumInputStreamDescs(@ptrCast(*const ID3D12VideoProcessor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessor_GetInputStreamDescs(self: *const T, NumInputStreamDescs: u32, pInputStreamDescs: [*]D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoProcessor.VTable, self.vtable).GetInputStreamDescs(@ptrCast(*const ID3D12VideoProcessor, self), NumInputStreamDescs, pInputStreamDescs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessor_GetOutputStreamDesc(self: *const T) callconv(.Inline) D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
            return @ptrCast(*const ID3D12VideoProcessor.VTable, self.vtable).GetOutputStreamDesc(@ptrCast(*const ID3D12VideoProcessor, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_PROCESS_FEATURE_FLAGS = extern enum(i32) {
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_NONE = 0,
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL = 1,
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY = 2,
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_STEREO = 4,
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_ROTATION = 8,
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_FLIP = 16,
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING = 32,
    D3D12_VIDEO_PROCESS_FEATURE_FLAG_PIXEL_ASPECT_RATIO = 64,
};
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_NONE = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.D3D12_VIDEO_PROCESS_FEATURE_FLAG_NONE;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_STEREO = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.D3D12_VIDEO_PROCESS_FEATURE_FLAG_STEREO;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ROTATION = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.D3D12_VIDEO_PROCESS_FEATURE_FLAG_ROTATION;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_FLIP = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.D3D12_VIDEO_PROCESS_FEATURE_FLAG_FLIP;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING;
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_PIXEL_ASPECT_RATIO = D3D12_VIDEO_PROCESS_FEATURE_FLAGS.D3D12_VIDEO_PROCESS_FEATURE_FLAG_PIXEL_ASPECT_RATIO;

pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = extern enum(i32) {
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_NONE = 0,
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DENOISE = 1,
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DERINGING = 2,
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_EDGE_ENHANCEMENT = 4,
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_COLOR_CORRECTION = 8,
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_FLESH_TONE_MAPPING = 16,
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_IMAGE_STABILIZATION = 32,
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_SUPER_RESOLUTION = 64,
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_ANAMORPHIC_SCALING = 128,
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_CUSTOM = -2147483648,
};
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_NONE = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_NONE;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DENOISE = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DENOISE;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DERINGING = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DERINGING;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_EDGE_ENHANCEMENT = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_EDGE_ENHANCEMENT;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_COLOR_CORRECTION = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_COLOR_CORRECTION;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_FLESH_TONE_MAPPING = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_FLESH_TONE_MAPPING;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_IMAGE_STABILIZATION = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_IMAGE_STABILIZATION;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_SUPER_RESOLUTION = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_SUPER_RESOLUTION;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_ANAMORPHIC_SCALING = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_ANAMORPHIC_SCALING;
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_CUSTOM = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS.D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_CUSTOM;

pub const D3D12_VIDEO_PROCESS_ORIENTATION = extern enum(i32) {
    DEFAULT = 0,
    FLIP_HORIZONTAL = 1,
    CLOCKWISE_90 = 2,
    CLOCKWISE_90_FLIP_HORIZONTAL = 3,
    CLOCKWISE_180 = 4,
    FLIP_VERTICAL = 5,
    CLOCKWISE_270 = 6,
    CLOCKWISE_270_FLIP_HORIZONTAL = 7,
};
pub const D3D12_VIDEO_PROCESS_ORIENTATION_DEFAULT = D3D12_VIDEO_PROCESS_ORIENTATION.DEFAULT;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_HORIZONTAL = D3D12_VIDEO_PROCESS_ORIENTATION.FLIP_HORIZONTAL;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90 = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_90;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90_FLIP_HORIZONTAL = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_90_FLIP_HORIZONTAL;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_180 = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_180;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_VERTICAL = D3D12_VIDEO_PROCESS_ORIENTATION.FLIP_VERTICAL;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270 = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_270;
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270_FLIP_HORIZONTAL = D3D12_VIDEO_PROCESS_ORIENTATION.CLOCKWISE_270_FLIP_HORIZONTAL;

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS = extern enum(i32) {
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_NONE = 0,
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_DISCONTINUITY = 1,
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_REPEAT = 2,
};
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_NONE = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS.D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_NONE;
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_DISCONTINUITY = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS.D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_DISCONTINUITY;
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_REPEAT = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS.D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_REPEAT;

pub const D3D12_VIDEO_PROCESS_FILTER_RANGE = extern struct {
    Minimum: i32,
    Maximum: i32,
    Default: i32,
    Multiplier: f32,
};

pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAGS = extern enum(i32) {
    D3D12_VIDEO_PROCESS_SUPPORT_FLAG_NONE = 0,
    D3D12_VIDEO_PROCESS_SUPPORT_FLAG_SUPPORTED = 1,
};
pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAG_NONE = D3D12_VIDEO_PROCESS_SUPPORT_FLAGS.D3D12_VIDEO_PROCESS_SUPPORT_FLAG_NONE;
pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAG_SUPPORTED = D3D12_VIDEO_PROCESS_SUPPORT_FLAGS.D3D12_VIDEO_PROCESS_SUPPORT_FLAG_SUPPORTED;

pub const D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT = extern struct {
    NodeIndex: u32,
    InputSample: D3D12_VIDEO_SAMPLE,
    InputFieldType: D3D12_VIDEO_FIELD_TYPE,
    InputStereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    InputFrameRate: DXGI_RATIONAL,
    OutputFormat: D3D12_VIDEO_FORMAT,
    OutputStereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    OutputFrameRate: DXGI_RATIONAL,
    SupportFlags: D3D12_VIDEO_PROCESS_SUPPORT_FLAGS,
    ScaleSupport: D3D12_VIDEO_SCALE_SUPPORT,
    FeatureSupport: D3D12_VIDEO_PROCESS_FEATURE_FLAGS,
    DeinterlaceSupport: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    AutoProcessingSupport: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS,
    FilterSupport: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    FilterRangeSupport: [32]D3D12_VIDEO_PROCESS_FILTER_RANGE,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS = extern struct {
    NodeIndex: u32,
    MaxInputStreams: u32,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO = extern struct {
    NodeIndex: u32,
    DeinterlaceMode: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    Filters: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    FeatureSupport: D3D12_VIDEO_PROCESS_FEATURE_FLAGS,
    InputFrameRate: DXGI_RATIONAL,
    OutputFrameRate: DXGI_RATIONAL,
    EnableAutoProcessing: BOOL,
    PastFrames: u32,
    FutureFrames: u32,
};

pub const D3D12_VIDEO_PROCESS_REFERENCE_SET = extern struct {
    NumPastFrames: u32,
    ppPastFrames: **ID3D12Resource,
    pPastSubresources: *u32,
    NumFutureFrames: u32,
    ppFutureFrames: **ID3D12Resource,
    pFutureSubresources: *u32,
};

pub const D3D12_VIDEO_PROCESS_TRANSFORM = extern struct {
    SourceRectangle: RECT,
    DestinationRectangle: RECT,
    Orientation: D3D12_VIDEO_PROCESS_ORIENTATION,
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE = extern struct {
    OutputIndex: u32,
    InputFrameOrField: u32,
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM = extern struct {
    pTexture2D: *ID3D12Resource,
    Subresource: u32,
    ReferenceSet: D3D12_VIDEO_PROCESS_REFERENCE_SET,
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS = extern struct {
    InputStream: [2]D3D12_VIDEO_PROCESS_INPUT_STREAM,
    Transform: D3D12_VIDEO_PROCESS_TRANSFORM,
    Flags: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS,
    RateInfo: D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE,
    FilterLevels: [32]i32,
    AlphaBlending: D3D12_VIDEO_PROCESS_ALPHA_BLENDING,
};

pub const D3D12_VIDEO_PROCESS_OUTPUT_STREAM = extern struct {
    pTexture2D: *ID3D12Resource,
    Subresource: u32,
};

pub const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS = extern struct {
    OutputStream: [2]D3D12_VIDEO_PROCESS_OUTPUT_STREAM,
    TargetRectangle: RECT,
};

const IID_ID3D12VideoDecodeCommandList_Value = @import("../zig.zig").Guid.initString("3B60536E-AD29-4E64-A269-F853837E5E53");
pub const IID_ID3D12VideoDecodeCommandList = &IID_ID3D12VideoDecodeCommandList_Value;
pub const ID3D12VideoDecodeCommandList = extern struct {
    pub const VTable = extern struct {
        base: ID3D12CommandList.VTable,
        Close: fn(
            self: *const ID3D12VideoDecodeCommandList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ID3D12VideoDecodeCommandList,
            pAllocator: *ID3D12CommandAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearState: fn(
            self: *const ID3D12VideoDecodeCommandList,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ResourceBarrier: fn(
            self: *const ID3D12VideoDecodeCommandList,
            NumBarriers: u32,
            pBarriers: [*]const D3D12_RESOURCE_BARRIER,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DiscardResource: fn(
            self: *const ID3D12VideoDecodeCommandList,
            pResource: *ID3D12Resource,
            pRegion: ?*const D3D12_DISCARD_REGION,
        ) callconv(@import("std").os.windows.WINAPI) void,
        BeginQuery: fn(
            self: *const ID3D12VideoDecodeCommandList,
            pQueryHeap: *ID3D12QueryHeap,
            Type: D3D12_QUERY_TYPE,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        EndQuery: fn(
            self: *const ID3D12VideoDecodeCommandList,
            pQueryHeap: *ID3D12QueryHeap,
            Type: D3D12_QUERY_TYPE,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ResolveQueryData: fn(
            self: *const ID3D12VideoDecodeCommandList,
            pQueryHeap: *ID3D12QueryHeap,
            Type: D3D12_QUERY_TYPE,
            StartIndex: u32,
            NumQueries: u32,
            pDestinationBuffer: *ID3D12Resource,
            AlignedDestinationBufferOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetPredication: fn(
            self: *const ID3D12VideoDecodeCommandList,
            pBuffer: ?*ID3D12Resource,
            AlignedBufferOffset: u64,
            Operation: D3D12_PREDICATION_OP,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetMarker: fn(
            self: *const ID3D12VideoDecodeCommandList,
            Metadata: u32,
            pData: ?[*]const u8,
            Size: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        BeginEvent: fn(
            self: *const ID3D12VideoDecodeCommandList,
            Metadata: u32,
            pData: ?[*]const u8,
            Size: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        EndEvent: fn(
            self: *const ID3D12VideoDecodeCommandList,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DecodeFrame: fn(
            self: *const ID3D12VideoDecodeCommandList,
            pDecoder: *ID3D12VideoDecoder,
            pOutputArguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
            pInputArguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        WriteBufferImmediate: fn(
            self: *const ID3D12VideoDecodeCommandList,
            Count: u32,
            pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
            pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12CommandList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).Close(@ptrCast(*const ID3D12VideoDecodeCommandList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_Reset(self: *const T, pAllocator: *ID3D12CommandAllocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).Reset(@ptrCast(*const ID3D12VideoDecodeCommandList, self), pAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_ClearState(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).ClearState(@ptrCast(*const ID3D12VideoDecodeCommandList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_ResourceBarrier(self: *const T, NumBarriers: u32, pBarriers: [*]const D3D12_RESOURCE_BARRIER) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).ResourceBarrier(@ptrCast(*const ID3D12VideoDecodeCommandList, self), NumBarriers, pBarriers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_DiscardResource(self: *const T, pResource: *ID3D12Resource, pRegion: ?*const D3D12_DISCARD_REGION) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).DiscardResource(@ptrCast(*const ID3D12VideoDecodeCommandList, self), pResource, pRegion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_BeginQuery(self: *const T, pQueryHeap: *ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).BeginQuery(@ptrCast(*const ID3D12VideoDecodeCommandList, self), pQueryHeap, Type, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_EndQuery(self: *const T, pQueryHeap: *ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).EndQuery(@ptrCast(*const ID3D12VideoDecodeCommandList, self), pQueryHeap, Type, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_ResolveQueryData(self: *const T, pQueryHeap: *ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, StartIndex: u32, NumQueries: u32, pDestinationBuffer: *ID3D12Resource, AlignedDestinationBufferOffset: u64) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).ResolveQueryData(@ptrCast(*const ID3D12VideoDecodeCommandList, self), pQueryHeap, Type, StartIndex, NumQueries, pDestinationBuffer, AlignedDestinationBufferOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_SetPredication(self: *const T, pBuffer: ?*ID3D12Resource, AlignedBufferOffset: u64, Operation: D3D12_PREDICATION_OP) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).SetPredication(@ptrCast(*const ID3D12VideoDecodeCommandList, self), pBuffer, AlignedBufferOffset, Operation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_SetMarker(self: *const T, Metadata: u32, pData: ?[*]const u8, Size: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).SetMarker(@ptrCast(*const ID3D12VideoDecodeCommandList, self), Metadata, pData, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_BeginEvent(self: *const T, Metadata: u32, pData: ?[*]const u8, Size: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).BeginEvent(@ptrCast(*const ID3D12VideoDecodeCommandList, self), Metadata, pData, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_EndEvent(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).EndEvent(@ptrCast(*const ID3D12VideoDecodeCommandList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_DecodeFrame(self: *const T, pDecoder: *ID3D12VideoDecoder, pOutputArguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS, pInputArguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).DecodeFrame(@ptrCast(*const ID3D12VideoDecodeCommandList, self), pDecoder, pOutputArguments, pInputArguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList_WriteBufferImmediate(self: *const T, Count: u32, pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList.VTable, self.vtable).WriteBufferImmediate(@ptrCast(*const ID3D12VideoDecodeCommandList, self), Count, pParams, pModes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoProcessCommandList_Value = @import("../zig.zig").Guid.initString("AEB2543A-167F-4682-ACC8-D159ED4A6209");
pub const IID_ID3D12VideoProcessCommandList = &IID_ID3D12VideoProcessCommandList_Value;
pub const ID3D12VideoProcessCommandList = extern struct {
    pub const VTable = extern struct {
        base: ID3D12CommandList.VTable,
        Close: fn(
            self: *const ID3D12VideoProcessCommandList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ID3D12VideoProcessCommandList,
            pAllocator: *ID3D12CommandAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearState: fn(
            self: *const ID3D12VideoProcessCommandList,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ResourceBarrier: fn(
            self: *const ID3D12VideoProcessCommandList,
            NumBarriers: u32,
            pBarriers: [*]const D3D12_RESOURCE_BARRIER,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DiscardResource: fn(
            self: *const ID3D12VideoProcessCommandList,
            pResource: *ID3D12Resource,
            pRegion: ?*const D3D12_DISCARD_REGION,
        ) callconv(@import("std").os.windows.WINAPI) void,
        BeginQuery: fn(
            self: *const ID3D12VideoProcessCommandList,
            pQueryHeap: *ID3D12QueryHeap,
            Type: D3D12_QUERY_TYPE,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        EndQuery: fn(
            self: *const ID3D12VideoProcessCommandList,
            pQueryHeap: *ID3D12QueryHeap,
            Type: D3D12_QUERY_TYPE,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ResolveQueryData: fn(
            self: *const ID3D12VideoProcessCommandList,
            pQueryHeap: *ID3D12QueryHeap,
            Type: D3D12_QUERY_TYPE,
            StartIndex: u32,
            NumQueries: u32,
            pDestinationBuffer: *ID3D12Resource,
            AlignedDestinationBufferOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetPredication: fn(
            self: *const ID3D12VideoProcessCommandList,
            pBuffer: ?*ID3D12Resource,
            AlignedBufferOffset: u64,
            Operation: D3D12_PREDICATION_OP,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetMarker: fn(
            self: *const ID3D12VideoProcessCommandList,
            Metadata: u32,
            pData: ?[*]const u8,
            Size: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        BeginEvent: fn(
            self: *const ID3D12VideoProcessCommandList,
            Metadata: u32,
            pData: ?[*]const u8,
            Size: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        EndEvent: fn(
            self: *const ID3D12VideoProcessCommandList,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ProcessFrames: fn(
            self: *const ID3D12VideoProcessCommandList,
            pVideoProcessor: *ID3D12VideoProcessor,
            pOutputArguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
            NumInputStreams: u32,
            pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS,
        ) callconv(@import("std").os.windows.WINAPI) void,
        WriteBufferImmediate: fn(
            self: *const ID3D12VideoProcessCommandList,
            Count: u32,
            pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
            pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12CommandList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).Close(@ptrCast(*const ID3D12VideoProcessCommandList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_Reset(self: *const T, pAllocator: *ID3D12CommandAllocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).Reset(@ptrCast(*const ID3D12VideoProcessCommandList, self), pAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_ClearState(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).ClearState(@ptrCast(*const ID3D12VideoProcessCommandList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_ResourceBarrier(self: *const T, NumBarriers: u32, pBarriers: [*]const D3D12_RESOURCE_BARRIER) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).ResourceBarrier(@ptrCast(*const ID3D12VideoProcessCommandList, self), NumBarriers, pBarriers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_DiscardResource(self: *const T, pResource: *ID3D12Resource, pRegion: ?*const D3D12_DISCARD_REGION) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).DiscardResource(@ptrCast(*const ID3D12VideoProcessCommandList, self), pResource, pRegion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_BeginQuery(self: *const T, pQueryHeap: *ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).BeginQuery(@ptrCast(*const ID3D12VideoProcessCommandList, self), pQueryHeap, Type, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_EndQuery(self: *const T, pQueryHeap: *ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).EndQuery(@ptrCast(*const ID3D12VideoProcessCommandList, self), pQueryHeap, Type, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_ResolveQueryData(self: *const T, pQueryHeap: *ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, StartIndex: u32, NumQueries: u32, pDestinationBuffer: *ID3D12Resource, AlignedDestinationBufferOffset: u64) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).ResolveQueryData(@ptrCast(*const ID3D12VideoProcessCommandList, self), pQueryHeap, Type, StartIndex, NumQueries, pDestinationBuffer, AlignedDestinationBufferOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_SetPredication(self: *const T, pBuffer: ?*ID3D12Resource, AlignedBufferOffset: u64, Operation: D3D12_PREDICATION_OP) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).SetPredication(@ptrCast(*const ID3D12VideoProcessCommandList, self), pBuffer, AlignedBufferOffset, Operation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_SetMarker(self: *const T, Metadata: u32, pData: ?[*]const u8, Size: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).SetMarker(@ptrCast(*const ID3D12VideoProcessCommandList, self), Metadata, pData, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_BeginEvent(self: *const T, Metadata: u32, pData: ?[*]const u8, Size: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).BeginEvent(@ptrCast(*const ID3D12VideoProcessCommandList, self), Metadata, pData, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_EndEvent(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).EndEvent(@ptrCast(*const ID3D12VideoProcessCommandList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_ProcessFrames(self: *const T, pVideoProcessor: *ID3D12VideoProcessor, pOutputArguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, NumInputStreams: u32, pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).ProcessFrames(@ptrCast(*const ID3D12VideoProcessCommandList, self), pVideoProcessor, pOutputArguments, NumInputStreams, pInputArguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList_WriteBufferImmediate(self: *const T, Count: u32, pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList.VTable, self.vtable).WriteBufferImmediate(@ptrCast(*const ID3D12VideoProcessCommandList, self), Count, pParams, pModes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM = extern struct {
    Offset: u64,
    pBuffer: *ID3D12Resource,
};

pub const D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 = extern struct {
    Enable: BOOL,
    pReferenceTexture2D: *ID3D12Resource,
    ReferenceSubresource: u32,
    OutputColorSpace: DXGI_COLOR_SPACE_TYPE,
    DecodeColorSpace: DXGI_COLOR_SPACE_TYPE,
    OutputWidth: u32,
    OutputHeight: u32,
};

pub const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 = extern struct {
    pOutputTexture2D: *ID3D12Resource,
    OutputSubresource: u32,
    ConversionArguments: D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1,
    Histograms: [4]D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM,
};

const IID_ID3D12VideoDecodeCommandList1_Value = @import("../zig.zig").Guid.initString("D52F011B-B56E-453C-A05A-A7F311C8F472");
pub const IID_ID3D12VideoDecodeCommandList1 = &IID_ID3D12VideoDecodeCommandList1_Value;
pub const ID3D12VideoDecodeCommandList1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDecodeCommandList.VTable,
        DecodeFrame1: fn(
            self: *const ID3D12VideoDecodeCommandList1,
            pDecoder: *ID3D12VideoDecoder,
            pOutputArguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1,
            pInputArguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoDecodeCommandList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList1_DecodeFrame1(self: *const T, pDecoder: *ID3D12VideoDecoder, pOutputArguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1, pInputArguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList1.VTable, self.vtable).DecodeFrame1(@ptrCast(*const ID3D12VideoDecodeCommandList1, self), pDecoder, pOutputArguments, pInputArguments);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 = extern struct {
    InputStream: [2]D3D12_VIDEO_PROCESS_INPUT_STREAM,
    Transform: D3D12_VIDEO_PROCESS_TRANSFORM,
    Flags: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS,
    RateInfo: D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE,
    FilterLevels: [32]i32,
    AlphaBlending: D3D12_VIDEO_PROCESS_ALPHA_BLENDING,
    FieldType: D3D12_VIDEO_FIELD_TYPE,
};

const IID_ID3D12VideoProcessCommandList1_Value = @import("../zig.zig").Guid.initString("542C5C4D-7596-434F-8C93-4EFA6766F267");
pub const IID_ID3D12VideoProcessCommandList1 = &IID_ID3D12VideoProcessCommandList1_Value;
pub const ID3D12VideoProcessCommandList1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoProcessCommandList.VTable,
        ProcessFrames1: fn(
            self: *const ID3D12VideoProcessCommandList1,
            pVideoProcessor: *ID3D12VideoProcessor,
            pOutputArguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
            NumInputStreams: u32,
            pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoProcessCommandList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList1_ProcessFrames1(self: *const T, pVideoProcessor: *ID3D12VideoProcessor, pOutputArguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS, NumInputStreams: u32, pInputArguments: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList1.VTable, self.vtable).ProcessFrames1(@ptrCast(*const ID3D12VideoProcessCommandList1, self), pVideoProcessor, pOutputArguments, NumInputStreams, pInputArguments);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE = extern enum(i32) {
    _8X8 = 0,
    _16X16 = 1,
};
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_8X8 = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE._8X8;
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_16X16 = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE._16X16;

pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS = extern enum(i32) {
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_NONE = 0,
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_8X8 = 1,
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_16X16 = 2,
};
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_NONE = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS.D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_NONE;
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_8X8 = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS.D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_8X8;
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_16X16 = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS.D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_16X16;

pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION = extern enum(i32) {
    QUARTER_PEL = 0,
};
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_QUARTER_PEL = D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION.QUARTER_PEL;

pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS = extern enum(i32) {
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_NONE = 0,
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_QUARTER_PEL = 1,
};
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_NONE = D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS.D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_NONE;
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_QUARTER_PEL = D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS.D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_QUARTER_PEL;

pub const D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT = extern struct {
    NodeIndex: u32,
    VideoDecodeSupport: BOOL,
    VideoProcessSupport: BOOL,
    VideoEncodeSupport: BOOL,
};

pub const D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR = extern struct {
    NodeIndex: u32,
    InputFormat: DXGI_FORMAT,
    BlockSizeFlags: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS,
    PrecisionFlags: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS,
    SizeRange: D3D12_VIDEO_SIZE_RANGE,
};

pub const D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE = extern struct {
    NodeIndex: u32,
    InputFormat: DXGI_FORMAT,
    BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    SizeRange: D3D12_VIDEO_SIZE_RANGE,
    Protected: BOOL,
    MotionVectorHeapMemoryPoolL0Size: u64,
    MotionVectorHeapMemoryPoolL1Size: u64,
    MotionEstimatorMemoryPoolL0Size: u64,
    MotionEstimatorMemoryPoolL1Size: u64,
};

pub const D3D12_VIDEO_MOTION_ESTIMATOR_DESC = extern struct {
    NodeMask: u32,
    InputFormat: DXGI_FORMAT,
    BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    SizeRange: D3D12_VIDEO_SIZE_RANGE,
};

const IID_ID3D12VideoMotionEstimator_Value = @import("../zig.zig").Guid.initString("33FDAE0E-098B-428F-87BB-34B695DE08F8");
pub const IID_ID3D12VideoMotionEstimator = &IID_ID3D12VideoMotionEstimator_Value;
pub const ID3D12VideoMotionEstimator = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: fn(
            self: *const ID3D12VideoMotionEstimator,
        ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
        GetProtectedResourceSession: fn(
            self: *const ID3D12VideoMotionEstimator,
            riid: *const Guid,
            ppProtectedSession: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12Pageable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoMotionEstimator_GetDesc(self: *const T) callconv(.Inline) D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
            return @ptrCast(*const ID3D12VideoMotionEstimator.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D12VideoMotionEstimator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoMotionEstimator_GetProtectedResourceSession(self: *const T, riid: *const Guid, ppProtectedSession: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoMotionEstimator.VTable, self.vtable).GetProtectedResourceSession(@ptrCast(*const ID3D12VideoMotionEstimator, self), riid, ppProtectedSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC = extern struct {
    NodeMask: u32,
    InputFormat: DXGI_FORMAT,
    BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    SizeRange: D3D12_VIDEO_SIZE_RANGE,
};

const IID_ID3D12VideoMotionVectorHeap_Value = @import("../zig.zig").Guid.initString("5BE17987-743A-4061-834B-23D22DAEA505");
pub const IID_ID3D12VideoMotionVectorHeap = &IID_ID3D12VideoMotionVectorHeap_Value;
pub const ID3D12VideoMotionVectorHeap = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: fn(
            self: *const ID3D12VideoMotionVectorHeap,
        ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
        GetProtectedResourceSession: fn(
            self: *const ID3D12VideoMotionVectorHeap,
            riid: *const Guid,
            ppProtectedSession: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12Pageable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoMotionVectorHeap_GetDesc(self: *const T) callconv(.Inline) D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
            return @ptrCast(*const ID3D12VideoMotionVectorHeap.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D12VideoMotionVectorHeap, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoMotionVectorHeap_GetProtectedResourceSession(self: *const T, riid: *const Guid, ppProtectedSession: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoMotionVectorHeap.VTable, self.vtable).GetProtectedResourceSession(@ptrCast(*const ID3D12VideoMotionVectorHeap, self), riid, ppProtectedSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDevice1_Value = @import("../zig.zig").Guid.initString("981611AD-A144-4C83-9890-F30E26D658AB");
pub const IID_ID3D12VideoDevice1 = &IID_ID3D12VideoDevice1_Value;
pub const ID3D12VideoDevice1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDevice.VTable,
        CreateVideoMotionEstimator: fn(
            self: *const ID3D12VideoDevice1,
            pDesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
            pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            riid: *const Guid,
            ppVideoMotionEstimator: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoMotionVectorHeap: fn(
            self: *const ID3D12VideoDevice1,
            pDesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
            pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            riid: *const Guid,
            ppVideoMotionVectorHeap: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice1_CreateVideoMotionEstimator(self: *const T, pDesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: *const Guid, ppVideoMotionEstimator: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice1.VTable, self.vtable).CreateVideoMotionEstimator(@ptrCast(*const ID3D12VideoDevice1, self), pDesc, pProtectedResourceSession, riid, ppVideoMotionEstimator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice1_CreateVideoMotionVectorHeap(self: *const T, pDesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: *const Guid, ppVideoMotionVectorHeap: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice1.VTable, self.vtable).CreateVideoMotionVectorHeap(@ptrCast(*const ID3D12VideoDevice1, self), pDesc, pProtectedResourceSession, riid, ppVideoMotionVectorHeap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_RESOURCE_COORDINATE = extern struct {
    X: u64,
    Y: u32,
    Z: u32,
    SubresourceIndex: u32,
};

pub const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT = extern struct {
    pMotionVectorHeap: *ID3D12VideoMotionVectorHeap,
};

pub const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT = extern struct {
    pInputTexture2D: *ID3D12Resource,
    InputSubresourceIndex: u32,
    pReferenceTexture2D: *ID3D12Resource,
    ReferenceSubresourceIndex: u32,
    pHintMotionVectorHeap: *ID3D12VideoMotionVectorHeap,
};

pub const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT = extern struct {
    pMotionVectorTexture2D: *ID3D12Resource,
    MotionVectorCoordinate: D3D12_RESOURCE_COORDINATE,
};

pub const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT = extern struct {
    pMotionVectorHeap: *ID3D12VideoMotionVectorHeap,
    PixelWidth: u32,
    PixelHeight: u32,
};

const IID_ID3D12VideoEncodeCommandList_Value = @import("../zig.zig").Guid.initString("8455293A-0CBD-4831-9B39-FBDBAB724723");
pub const IID_ID3D12VideoEncodeCommandList = &IID_ID3D12VideoEncodeCommandList_Value;
pub const ID3D12VideoEncodeCommandList = extern struct {
    pub const VTable = extern struct {
        base: ID3D12CommandList.VTable,
        Close: fn(
            self: *const ID3D12VideoEncodeCommandList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ID3D12VideoEncodeCommandList,
            pAllocator: *ID3D12CommandAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearState: fn(
            self: *const ID3D12VideoEncodeCommandList,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ResourceBarrier: fn(
            self: *const ID3D12VideoEncodeCommandList,
            NumBarriers: u32,
            pBarriers: [*]const D3D12_RESOURCE_BARRIER,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DiscardResource: fn(
            self: *const ID3D12VideoEncodeCommandList,
            pResource: *ID3D12Resource,
            pRegion: ?*const D3D12_DISCARD_REGION,
        ) callconv(@import("std").os.windows.WINAPI) void,
        BeginQuery: fn(
            self: *const ID3D12VideoEncodeCommandList,
            pQueryHeap: *ID3D12QueryHeap,
            Type: D3D12_QUERY_TYPE,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        EndQuery: fn(
            self: *const ID3D12VideoEncodeCommandList,
            pQueryHeap: *ID3D12QueryHeap,
            Type: D3D12_QUERY_TYPE,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ResolveQueryData: fn(
            self: *const ID3D12VideoEncodeCommandList,
            pQueryHeap: *ID3D12QueryHeap,
            Type: D3D12_QUERY_TYPE,
            StartIndex: u32,
            NumQueries: u32,
            pDestinationBuffer: *ID3D12Resource,
            AlignedDestinationBufferOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetPredication: fn(
            self: *const ID3D12VideoEncodeCommandList,
            pBuffer: ?*ID3D12Resource,
            AlignedBufferOffset: u64,
            Operation: D3D12_PREDICATION_OP,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetMarker: fn(
            self: *const ID3D12VideoEncodeCommandList,
            Metadata: u32,
            pData: ?[*]const u8,
            Size: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        BeginEvent: fn(
            self: *const ID3D12VideoEncodeCommandList,
            Metadata: u32,
            pData: ?[*]const u8,
            Size: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        EndEvent: fn(
            self: *const ID3D12VideoEncodeCommandList,
        ) callconv(@import("std").os.windows.WINAPI) void,
        EstimateMotion: fn(
            self: *const ID3D12VideoEncodeCommandList,
            pMotionEstimator: *ID3D12VideoMotionEstimator,
            pOutputArguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
            pInputArguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ResolveMotionVectorHeap: fn(
            self: *const ID3D12VideoEncodeCommandList,
            pOutputArguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
            pInputArguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        WriteBufferImmediate: fn(
            self: *const ID3D12VideoEncodeCommandList,
            Count: u32,
            pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
            pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        SetProtectedResourceSession: fn(
            self: *const ID3D12VideoEncodeCommandList,
            pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12CommandList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).Close(@ptrCast(*const ID3D12VideoEncodeCommandList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_Reset(self: *const T, pAllocator: *ID3D12CommandAllocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).Reset(@ptrCast(*const ID3D12VideoEncodeCommandList, self), pAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_ClearState(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).ClearState(@ptrCast(*const ID3D12VideoEncodeCommandList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_ResourceBarrier(self: *const T, NumBarriers: u32, pBarriers: [*]const D3D12_RESOURCE_BARRIER) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).ResourceBarrier(@ptrCast(*const ID3D12VideoEncodeCommandList, self), NumBarriers, pBarriers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_DiscardResource(self: *const T, pResource: *ID3D12Resource, pRegion: ?*const D3D12_DISCARD_REGION) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).DiscardResource(@ptrCast(*const ID3D12VideoEncodeCommandList, self), pResource, pRegion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_BeginQuery(self: *const T, pQueryHeap: *ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).BeginQuery(@ptrCast(*const ID3D12VideoEncodeCommandList, self), pQueryHeap, Type, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_EndQuery(self: *const T, pQueryHeap: *ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, Index: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).EndQuery(@ptrCast(*const ID3D12VideoEncodeCommandList, self), pQueryHeap, Type, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_ResolveQueryData(self: *const T, pQueryHeap: *ID3D12QueryHeap, Type: D3D12_QUERY_TYPE, StartIndex: u32, NumQueries: u32, pDestinationBuffer: *ID3D12Resource, AlignedDestinationBufferOffset: u64) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).ResolveQueryData(@ptrCast(*const ID3D12VideoEncodeCommandList, self), pQueryHeap, Type, StartIndex, NumQueries, pDestinationBuffer, AlignedDestinationBufferOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_SetPredication(self: *const T, pBuffer: ?*ID3D12Resource, AlignedBufferOffset: u64, Operation: D3D12_PREDICATION_OP) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).SetPredication(@ptrCast(*const ID3D12VideoEncodeCommandList, self), pBuffer, AlignedBufferOffset, Operation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_SetMarker(self: *const T, Metadata: u32, pData: ?[*]const u8, Size: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).SetMarker(@ptrCast(*const ID3D12VideoEncodeCommandList, self), Metadata, pData, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_BeginEvent(self: *const T, Metadata: u32, pData: ?[*]const u8, Size: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).BeginEvent(@ptrCast(*const ID3D12VideoEncodeCommandList, self), Metadata, pData, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_EndEvent(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).EndEvent(@ptrCast(*const ID3D12VideoEncodeCommandList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_EstimateMotion(self: *const T, pMotionEstimator: *ID3D12VideoMotionEstimator, pOutputArguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT, pInputArguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).EstimateMotion(@ptrCast(*const ID3D12VideoEncodeCommandList, self), pMotionEstimator, pOutputArguments, pInputArguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_ResolveMotionVectorHeap(self: *const T, pOutputArguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT, pInputArguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).ResolveMotionVectorHeap(@ptrCast(*const ID3D12VideoEncodeCommandList, self), pOutputArguments, pInputArguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_WriteBufferImmediate(self: *const T, Count: u32, pParams: [*]const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER, pModes: ?[*]const D3D12_WRITEBUFFERIMMEDIATE_MODE) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).WriteBufferImmediate(@ptrCast(*const ID3D12VideoEncodeCommandList, self), Count, pParams, pModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList_SetProtectedResourceSession(self: *const T, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList.VTable, self.vtable).SetProtectedResourceSession(@ptrCast(*const ID3D12VideoEncodeCommandList, self), pProtectedResourceSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS = extern enum(i32) {
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_NONE = 0,
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_SUPPORTED = 1,
};
pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_NONE = D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS.D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_NONE;
pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_SUPPORTED = D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS.D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_SUPPORTED;

pub const D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES = extern struct {
    NodeIndex: u32,
    Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES = extern struct {
    NodeIndex: u32,
    SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES = extern struct {
    NodeIndex: u32,
    SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 = extern struct {
    VideoDecoderHeapDesc: D3D12_VIDEO_DECODER_HEAP_DESC,
    Protected: BOOL,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 = extern struct {
    NodeMask: u32,
    pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    NumInputStreamDescs: u32,
    pInputStreamDescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    Protected: BOOL,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE = extern enum(i32) {
    CREATION = 0,
    INITIALIZATION = 1,
    EXECUTION = 2,
    CAPS_INPUT = 3,
    CAPS_OUTPUT = 4,
    DEVICE_EXECUTE_INPUT = 5,
    DEVICE_EXECUTE_OUTPUT = 6,
};
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CREATION = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.CREATION;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_INITIALIZATION = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.INITIALIZATION;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_EXECUTION = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.EXECUTION;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_INPUT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.CAPS_INPUT;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_OUTPUT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.CAPS_OUTPUT;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_INPUT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.DEVICE_EXECUTE_INPUT;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_OUTPUT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE.DEVICE_EXECUTE_OUTPUT;

pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE = extern enum(i32) {
    UINT8 = 0,
    UINT16 = 1,
    UINT32 = 2,
    UINT64 = 3,
    SINT8 = 4,
    SINT16 = 5,
    SINT32 = 6,
    SINT64 = 7,
    FLOAT = 8,
    DOUBLE = 9,
    RESOURCE = 10,
};
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT8 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.UINT8;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT16 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.UINT16;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT32 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.UINT32;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT64 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.UINT64;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT8 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.SINT8;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT16 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.SINT16;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT32 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.SINT32;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT64 = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.SINT64;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_FLOAT = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.FLOAT;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_DOUBLE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.DOUBLE;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_RESOURCE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE.RESOURCE;

pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS = extern enum(i32) {
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_NONE = 0,
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_READ = 1,
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_WRITE = 2,
};
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_NONE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS.D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_NONE;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_READ = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS.D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_READ;
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_WRITE = D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS.D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_WRITE;

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT = extern struct {
    NodeIndex: u32,
    CommandCount: u32,
};

pub const D3D12_VIDEO_EXTENSION_COMMAND_INFO = extern struct {
    CommandId: Guid,
    Name: [*:0]const u16,
    CommandListSupportFlags: D3D12_COMMAND_LIST_SUPPORT_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS = extern struct {
    NodeIndex: u32,
    CommandCount: u32,
    pCommandInfos: *D3D12_VIDEO_EXTENSION_COMMAND_INFO,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT = extern struct {
    CommandId: Guid,
    Stage: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE,
    ParameterCount: u32,
    ParameterPacking: u32,
};

pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO = extern struct {
    Name: [*:0]const u16,
    Type: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE,
    Flags: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS = extern struct {
    CommandId: Guid,
    Stage: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE,
    ParameterCount: u32,
    pParameterInfos: *D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT = extern struct {
    NodeIndex: u32,
    CommandId: Guid,
    pInputData: *const c_void,
    InputDataSizeInBytes: ?*c_void,
    pOutputData: *c_void,
    OutputDataSizeInBytes: ?*c_void,
};

pub const D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE = extern struct {
    NodeIndex: u32,
    CommandId: Guid,
    pCreationParameters: *const c_void,
    CreationParametersSizeInBytes: ?*c_void,
    MemoryPoolL0Size: u64,
    MemoryPoolL1Size: u64,
};

pub const D3D12_VIDEO_EXTENSION_COMMAND_DESC = extern struct {
    NodeMask: u32,
    CommandId: Guid,
};

const IID_ID3D12VideoDecoder1_Value = @import("../zig.zig").Guid.initString("79A2E5FB-CCD2-469A-9FDE-195D10951F7E");
pub const IID_ID3D12VideoDecoder1 = &IID_ID3D12VideoDecoder1_Value;
pub const ID3D12VideoDecoder1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDecoder.VTable,
        GetProtectedResourceSession: fn(
            self: *const ID3D12VideoDecoder1,
            riid: *const Guid,
            ppProtectedSession: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoDecoder.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecoder1_GetProtectedResourceSession(self: *const T, riid: *const Guid, ppProtectedSession: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDecoder1.VTable, self.vtable).GetProtectedResourceSession(@ptrCast(*const ID3D12VideoDecoder1, self), riid, ppProtectedSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDecoderHeap1_Value = @import("../zig.zig").Guid.initString("DA1D98C5-539F-41B2-BF6B-1198A03B6D26");
pub const IID_ID3D12VideoDecoderHeap1 = &IID_ID3D12VideoDecoderHeap1_Value;
pub const ID3D12VideoDecoderHeap1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDecoderHeap.VTable,
        GetProtectedResourceSession: fn(
            self: *const ID3D12VideoDecoderHeap1,
            riid: *const Guid,
            ppProtectedSession: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoDecoderHeap.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecoderHeap1_GetProtectedResourceSession(self: *const T, riid: *const Guid, ppProtectedSession: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDecoderHeap1.VTable, self.vtable).GetProtectedResourceSession(@ptrCast(*const ID3D12VideoDecoderHeap1, self), riid, ppProtectedSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoProcessor1_Value = @import("../zig.zig").Guid.initString("F3CFE615-553F-425C-86D8-EE8C1B1FB01C");
pub const IID_ID3D12VideoProcessor1 = &IID_ID3D12VideoProcessor1_Value;
pub const ID3D12VideoProcessor1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoProcessor.VTable,
        GetProtectedResourceSession: fn(
            self: *const ID3D12VideoProcessor1,
            riid: *const Guid,
            ppProtectedSession: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoProcessor.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessor1_GetProtectedResourceSession(self: *const T, riid: *const Guid, ppProtectedSession: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoProcessor1.VTable, self.vtable).GetProtectedResourceSession(@ptrCast(*const ID3D12VideoProcessor1, self), riid, ppProtectedSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoExtensionCommand_Value = @import("../zig.zig").Guid.initString("554E41E8-AE8E-4A8C-B7D2-5B4F274A30E4");
pub const IID_ID3D12VideoExtensionCommand = &IID_ID3D12VideoExtensionCommand_Value;
pub const ID3D12VideoExtensionCommand = extern struct {
    pub const VTable = extern struct {
        base: ID3D12Pageable.VTable,
        GetDesc: fn(
            self: *const ID3D12VideoExtensionCommand,
        ) callconv(@import("std").os.windows.WINAPI) D3D12_VIDEO_EXTENSION_COMMAND_DESC,
        GetProtectedResourceSession: fn(
            self: *const ID3D12VideoExtensionCommand,
            riid: *const Guid,
            ppProtectedSession: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12Pageable.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoExtensionCommand_GetDesc(self: *const T) callconv(.Inline) D3D12_VIDEO_EXTENSION_COMMAND_DESC {
            return @ptrCast(*const ID3D12VideoExtensionCommand.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D12VideoExtensionCommand, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoExtensionCommand_GetProtectedResourceSession(self: *const T, riid: *const Guid, ppProtectedSession: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoExtensionCommand.VTable, self.vtable).GetProtectedResourceSession(@ptrCast(*const ID3D12VideoExtensionCommand, self), riid, ppProtectedSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDevice2_Value = @import("../zig.zig").Guid.initString("F019AC49-F838-4A95-9B17-579437C8F513");
pub const IID_ID3D12VideoDevice2 = &IID_ID3D12VideoDevice2_Value;
pub const ID3D12VideoDevice2 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDevice1.VTable,
        CreateVideoDecoder1: fn(
            self: *const ID3D12VideoDevice2,
            pDesc: *const D3D12_VIDEO_DECODER_DESC,
            pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            riid: *const Guid,
            ppVideoDecoder: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoDecoderHeap1: fn(
            self: *const ID3D12VideoDevice2,
            pVideoDecoderHeapDesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
            pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            riid: *const Guid,
            ppVideoDecoderHeap: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoProcessor1: fn(
            self: *const ID3D12VideoDevice2,
            NodeMask: u32,
            pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
            NumInputStreamDescs: u32,
            pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
            pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            riid: *const Guid,
            ppVideoProcessor: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoExtensionCommand: fn(
            self: *const ID3D12VideoDevice2,
            pDesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC,
            pCreationParameters: [*]const u8,
            CreationParametersDataSizeInBytes: ?*c_void,
            pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
            riid: *const Guid,
            ppVideoExtensionCommand: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteExtensionCommand: fn(
            self: *const ID3D12VideoDevice2,
            pExtensionCommand: *ID3D12VideoExtensionCommand,
            pExecutionParameters: [*]const u8,
            ExecutionParametersSizeInBytes: ?*c_void,
            pOutputData: [*]u8,
            OutputDataSizeInBytes: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoDevice1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice2_CreateVideoDecoder1(self: *const T, pDesc: *const D3D12_VIDEO_DECODER_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: *const Guid, ppVideoDecoder: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice2.VTable, self.vtable).CreateVideoDecoder1(@ptrCast(*const ID3D12VideoDevice2, self), pDesc, pProtectedResourceSession, riid, ppVideoDecoder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice2_CreateVideoDecoderHeap1(self: *const T, pVideoDecoderHeapDesc: *const D3D12_VIDEO_DECODER_HEAP_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: *const Guid, ppVideoDecoderHeap: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice2.VTable, self.vtable).CreateVideoDecoderHeap1(@ptrCast(*const ID3D12VideoDevice2, self), pVideoDecoderHeapDesc, pProtectedResourceSession, riid, ppVideoDecoderHeap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice2_CreateVideoProcessor1(self: *const T, NodeMask: u32, pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC, NumInputStreamDescs: u32, pInputStreamDescs: [*]const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: *const Guid, ppVideoProcessor: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice2.VTable, self.vtable).CreateVideoProcessor1(@ptrCast(*const ID3D12VideoDevice2, self), NodeMask, pOutputStreamDesc, NumInputStreamDescs, pInputStreamDescs, pProtectedResourceSession, riid, ppVideoProcessor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice2_CreateVideoExtensionCommand(self: *const T, pDesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC, pCreationParameters: [*]const u8, CreationParametersDataSizeInBytes: ?*c_void, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession, riid: *const Guid, ppVideoExtensionCommand: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice2.VTable, self.vtable).CreateVideoExtensionCommand(@ptrCast(*const ID3D12VideoDevice2, self), pDesc, pCreationParameters, CreationParametersDataSizeInBytes, pProtectedResourceSession, riid, ppVideoExtensionCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDevice2_ExecuteExtensionCommand(self: *const T, pExtensionCommand: *ID3D12VideoExtensionCommand, pExecutionParameters: [*]const u8, ExecutionParametersSizeInBytes: ?*c_void, pOutputData: [*]u8, OutputDataSizeInBytes: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D12VideoDevice2.VTable, self.vtable).ExecuteExtensionCommand(@ptrCast(*const ID3D12VideoDevice2, self), pExtensionCommand, pExecutionParameters, ExecutionParametersSizeInBytes, pOutputData, OutputDataSizeInBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoDecodeCommandList2_Value = @import("../zig.zig").Guid.initString("6E120880-C114-4153-8036-D247051E1729");
pub const IID_ID3D12VideoDecodeCommandList2 = &IID_ID3D12VideoDecodeCommandList2_Value;
pub const ID3D12VideoDecodeCommandList2 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoDecodeCommandList1.VTable,
        SetProtectedResourceSession: fn(
            self: *const ID3D12VideoDecodeCommandList2,
            pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
        ) callconv(@import("std").os.windows.WINAPI) void,
        InitializeExtensionCommand: fn(
            self: *const ID3D12VideoDecodeCommandList2,
            pExtensionCommand: *ID3D12VideoExtensionCommand,
            pInitializationParameters: [*]const u8,
            InitializationParametersSizeInBytes: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ExecuteExtensionCommand: fn(
            self: *const ID3D12VideoDecodeCommandList2,
            pExtensionCommand: *ID3D12VideoExtensionCommand,
            pExecutionParameters: [*]const u8,
            ExecutionParametersSizeInBytes: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoDecodeCommandList1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList2_SetProtectedResourceSession(self: *const T, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList2.VTable, self.vtable).SetProtectedResourceSession(@ptrCast(*const ID3D12VideoDecodeCommandList2, self), pProtectedResourceSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList2_InitializeExtensionCommand(self: *const T, pExtensionCommand: *ID3D12VideoExtensionCommand, pInitializationParameters: [*]const u8, InitializationParametersSizeInBytes: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList2.VTable, self.vtable).InitializeExtensionCommand(@ptrCast(*const ID3D12VideoDecodeCommandList2, self), pExtensionCommand, pInitializationParameters, InitializationParametersSizeInBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoDecodeCommandList2_ExecuteExtensionCommand(self: *const T, pExtensionCommand: *ID3D12VideoExtensionCommand, pExecutionParameters: [*]const u8, ExecutionParametersSizeInBytes: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoDecodeCommandList2.VTable, self.vtable).ExecuteExtensionCommand(@ptrCast(*const ID3D12VideoDecodeCommandList2, self), pExtensionCommand, pExecutionParameters, ExecutionParametersSizeInBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoProcessCommandList2_Value = @import("../zig.zig").Guid.initString("DB525AE4-6AD6-473C-BAA7-59B2E37082E4");
pub const IID_ID3D12VideoProcessCommandList2 = &IID_ID3D12VideoProcessCommandList2_Value;
pub const ID3D12VideoProcessCommandList2 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoProcessCommandList1.VTable,
        SetProtectedResourceSession: fn(
            self: *const ID3D12VideoProcessCommandList2,
            pProtectedResourceSession: ?*ID3D12ProtectedResourceSession,
        ) callconv(@import("std").os.windows.WINAPI) void,
        InitializeExtensionCommand: fn(
            self: *const ID3D12VideoProcessCommandList2,
            pExtensionCommand: *ID3D12VideoExtensionCommand,
            pInitializationParameters: [*]const u8,
            InitializationParametersSizeInBytes: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ExecuteExtensionCommand: fn(
            self: *const ID3D12VideoProcessCommandList2,
            pExtensionCommand: *ID3D12VideoExtensionCommand,
            pExecutionParameters: [*]const u8,
            ExecutionParametersSizeInBytes: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoProcessCommandList1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList2_SetProtectedResourceSession(self: *const T, pProtectedResourceSession: ?*ID3D12ProtectedResourceSession) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList2.VTable, self.vtable).SetProtectedResourceSession(@ptrCast(*const ID3D12VideoProcessCommandList2, self), pProtectedResourceSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList2_InitializeExtensionCommand(self: *const T, pExtensionCommand: *ID3D12VideoExtensionCommand, pInitializationParameters: [*]const u8, InitializationParametersSizeInBytes: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList2.VTable, self.vtable).InitializeExtensionCommand(@ptrCast(*const ID3D12VideoProcessCommandList2, self), pExtensionCommand, pInitializationParameters, InitializationParametersSizeInBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoProcessCommandList2_ExecuteExtensionCommand(self: *const T, pExtensionCommand: *ID3D12VideoExtensionCommand, pExecutionParameters: [*]const u8, ExecutionParametersSizeInBytes: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoProcessCommandList2.VTable, self.vtable).ExecuteExtensionCommand(@ptrCast(*const ID3D12VideoProcessCommandList2, self), pExtensionCommand, pExecutionParameters, ExecutionParametersSizeInBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D12VideoEncodeCommandList1_Value = @import("../zig.zig").Guid.initString("94971ECA-2BDB-4769-88CF-3675EA757EBC");
pub const IID_ID3D12VideoEncodeCommandList1 = &IID_ID3D12VideoEncodeCommandList1_Value;
pub const ID3D12VideoEncodeCommandList1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D12VideoEncodeCommandList.VTable,
        InitializeExtensionCommand: fn(
            self: *const ID3D12VideoEncodeCommandList1,
            pExtensionCommand: *ID3D12VideoExtensionCommand,
            pInitializationParameters: [*]const u8,
            InitializationParametersSizeInBytes: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
        ExecuteExtensionCommand: fn(
            self: *const ID3D12VideoEncodeCommandList1,
            pExtensionCommand: *ID3D12VideoExtensionCommand,
            pExecutionParameters: [*]const u8,
            ExecutionParametersSizeInBytes: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D12VideoEncodeCommandList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList1_InitializeExtensionCommand(self: *const T, pExtensionCommand: *ID3D12VideoExtensionCommand, pInitializationParameters: [*]const u8, InitializationParametersSizeInBytes: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList1.VTable, self.vtable).InitializeExtensionCommand(@ptrCast(*const ID3D12VideoEncodeCommandList1, self), pExtensionCommand, pInitializationParameters, InitializationParametersSizeInBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D12VideoEncodeCommandList1_ExecuteExtensionCommand(self: *const T, pExtensionCommand: *ID3D12VideoExtensionCommand, pExecutionParameters: [*]const u8, ExecutionParametersSizeInBytes: ?*c_void) callconv(.Inline) void {
            return @ptrCast(*const ID3D12VideoEncodeCommandList1.VTable, self.vtable).ExecuteExtensionCommand(@ptrCast(*const ID3D12VideoEncodeCommandList1, self), pExtensionCommand, pExecutionParameters, ExecutionParametersSizeInBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_CMpeg4DecMediaObject_Value = @import("../zig.zig").Guid.initString("F371728A-6052-4D47-827C-D039335DFE0A");
pub const CLSID_CMpeg4DecMediaObject = &CLSID_CMpeg4DecMediaObject_Value;

const CLSID_CMpeg43DecMediaObject_Value = @import("../zig.zig").Guid.initString("CBA9E78B-49A3-49EA-93D4-6BCBA8C4DE07");
pub const CLSID_CMpeg43DecMediaObject = &CLSID_CMpeg43DecMediaObject_Value;

const CLSID_CMpeg4sDecMediaObject_Value = @import("../zig.zig").Guid.initString("2A11BAE2-FE6E-4249-864B-9E9ED6E8DBC2");
pub const CLSID_CMpeg4sDecMediaObject = &CLSID_CMpeg4sDecMediaObject_Value;

const CLSID_CMpeg4sDecMFT_Value = @import("../zig.zig").Guid.initString("5686A0D9-FE39-409F-9DFF-3FDBC849F9F5");
pub const CLSID_CMpeg4sDecMFT = &CLSID_CMpeg4sDecMFT_Value;

const CLSID_CZuneM4S2DecMediaObject_Value = @import("../zig.zig").Guid.initString("C56FC25C-0FC6-404A-9503-B10BF51A8AB9");
pub const CLSID_CZuneM4S2DecMediaObject = &CLSID_CZuneM4S2DecMediaObject_Value;

const CLSID_CMpeg4EncMediaObject_Value = @import("../zig.zig").Guid.initString("24F258D8-C651-4042-93E4-CA654ABB682C");
pub const CLSID_CMpeg4EncMediaObject = &CLSID_CMpeg4EncMediaObject_Value;

const CLSID_CMpeg4sEncMediaObject_Value = @import("../zig.zig").Guid.initString("6EC5A7BE-D81E-4F9E-ADA3-CD1BF262B6D8");
pub const CLSID_CMpeg4sEncMediaObject = &CLSID_CMpeg4sEncMediaObject_Value;

const CLSID_CMSSCDecMediaObject_Value = @import("../zig.zig").Guid.initString("7BAFB3B1-D8F4-4279-9253-27DA423108DE");
pub const CLSID_CMSSCDecMediaObject = &CLSID_CMSSCDecMediaObject_Value;

const CLSID_CMSSCEncMediaObject_Value = @import("../zig.zig").Guid.initString("8CB9CC06-D139-4AE6-8BB4-41E612E141D5");
pub const CLSID_CMSSCEncMediaObject = &CLSID_CMSSCEncMediaObject_Value;

const CLSID_CMSSCEncMediaObject2_Value = @import("../zig.zig").Guid.initString("F7FFE0A0-A4F5-44B5-949E-15ED2BC66F9D");
pub const CLSID_CMSSCEncMediaObject2 = &CLSID_CMSSCEncMediaObject2_Value;

const CLSID_CWMADecMediaObject_Value = @import("../zig.zig").Guid.initString("2EEB4ADF-4578-4D10-BCA7-BB955F56320A");
pub const CLSID_CWMADecMediaObject = &CLSID_CWMADecMediaObject_Value;

const CLSID_CWMAEncMediaObject_Value = @import("../zig.zig").Guid.initString("70F598E9-F4AB-495A-99E2-A7C4D3D89ABF");
pub const CLSID_CWMAEncMediaObject = &CLSID_CWMAEncMediaObject_Value;

const CLSID_CWMATransMediaObject_Value = @import("../zig.zig").Guid.initString("EDCAD9CB-3127-40DF-B527-0152CCB3F6F5");
pub const CLSID_CWMATransMediaObject = &CLSID_CWMATransMediaObject_Value;

const CLSID_CWMSPDecMediaObject_Value = @import("../zig.zig").Guid.initString("874131CB-4ECC-443B-8948-746B89595D20");
pub const CLSID_CWMSPDecMediaObject = &CLSID_CWMSPDecMediaObject_Value;

const CLSID_CWMSPEncMediaObject_Value = @import("../zig.zig").Guid.initString("67841B03-C689-4188-AD3F-4C9EBEEC710B");
pub const CLSID_CWMSPEncMediaObject = &CLSID_CWMSPEncMediaObject_Value;

const CLSID_CWMSPEncMediaObject2_Value = @import("../zig.zig").Guid.initString("1F1F4E1A-2252-4063-84BB-EEE75F8856D5");
pub const CLSID_CWMSPEncMediaObject2 = &CLSID_CWMSPEncMediaObject2_Value;

const CLSID_CWMTDecMediaObject_Value = @import("../zig.zig").Guid.initString("F9DBC64E-2DD0-45DD-9B52-66642EF94431");
pub const CLSID_CWMTDecMediaObject = &CLSID_CWMTDecMediaObject_Value;

const CLSID_CWMTEncMediaObject_Value = @import("../zig.zig").Guid.initString("60B67652-E46B-4E44-8609-F74BFFDC083C");
pub const CLSID_CWMTEncMediaObject = &CLSID_CWMTEncMediaObject_Value;

const CLSID_CWMVDecMediaObject_Value = @import("../zig.zig").Guid.initString("82D353DF-90BD-4382-8BC2-3F6192B76E34");
pub const CLSID_CWMVDecMediaObject = &CLSID_CWMVDecMediaObject_Value;

const CLSID_CWMVEncMediaObject2_Value = @import("../zig.zig").Guid.initString("96B57CDD-8966-410C-BB1F-C97EEA765C04");
pub const CLSID_CWMVEncMediaObject2 = &CLSID_CWMVEncMediaObject2_Value;

const CLSID_CWMVXEncMediaObject_Value = @import("../zig.zig").Guid.initString("7E320092-596A-41B2-BBEB-175D10504EB6");
pub const CLSID_CWMVXEncMediaObject = &CLSID_CWMVXEncMediaObject_Value;

const CLSID_CWMV9EncMediaObject_Value = @import("../zig.zig").Guid.initString("D23B90D0-144F-46BD-841D-59E4EB19DC59");
pub const CLSID_CWMV9EncMediaObject = &CLSID_CWMV9EncMediaObject_Value;

const CLSID_CWVC1DecMediaObject_Value = @import("../zig.zig").Guid.initString("C9BFBCCF-E60E-4588-A3DF-5A03B1FD9585");
pub const CLSID_CWVC1DecMediaObject = &CLSID_CWVC1DecMediaObject_Value;

const CLSID_CWVC1EncMediaObject_Value = @import("../zig.zig").Guid.initString("44653D0D-8CCA-41E7-BACA-884337B747AC");
pub const CLSID_CWVC1EncMediaObject = &CLSID_CWVC1EncMediaObject_Value;

const CLSID_CDeColorConvMediaObject_Value = @import("../zig.zig").Guid.initString("49034C05-F43C-400F-84C1-90A683195A3A");
pub const CLSID_CDeColorConvMediaObject = &CLSID_CDeColorConvMediaObject_Value;

const CLSID_CDVDecoderMediaObject_Value = @import("../zig.zig").Guid.initString("E54709C5-1E17-4C8D-94E7-478940433584");
pub const CLSID_CDVDecoderMediaObject = &CLSID_CDVDecoderMediaObject_Value;

const CLSID_CDVEncoderMediaObject_Value = @import("../zig.zig").Guid.initString("C82AE729-C327-4CCE-914D-8171FEFEBEFB");
pub const CLSID_CDVEncoderMediaObject = &CLSID_CDVEncoderMediaObject_Value;

const CLSID_CMpeg2DecMediaObject_Value = @import("../zig.zig").Guid.initString("863D66CD-CDCE-4617-B47F-C8929CFC28A6");
pub const CLSID_CMpeg2DecMediaObject = &CLSID_CMpeg2DecMediaObject_Value;

const CLSID_CPK_DS_MPEG2Decoder_Value = @import("../zig.zig").Guid.initString("9910C5CD-95C9-4E06-865A-EFA1C8016BF4");
pub const CLSID_CPK_DS_MPEG2Decoder = &CLSID_CPK_DS_MPEG2Decoder_Value;

const CLSID_CAC3DecMediaObject_Value = @import("../zig.zig").Guid.initString("03D7C802-ECFA-47D9-B268-5FB3E310DEE4");
pub const CLSID_CAC3DecMediaObject = &CLSID_CAC3DecMediaObject_Value;

const CLSID_CPK_DS_AC3Decoder_Value = @import("../zig.zig").Guid.initString("6C9C69D6-0FFC-4481-AFDB-CDF1C79C6F3E");
pub const CLSID_CPK_DS_AC3Decoder = &CLSID_CPK_DS_AC3Decoder_Value;

const CLSID_CMP3DecMediaObject_Value = @import("../zig.zig").Guid.initString("BBEEA841-0A63-4F52-A7AB-A9B3A84ED38A");
pub const CLSID_CMP3DecMediaObject = &CLSID_CMP3DecMediaObject_Value;

const CLSID_CResamplerMediaObject_Value = @import("../zig.zig").Guid.initString("F447B69E-1884-4A7E-8055-346F74D6EDB3");
pub const CLSID_CResamplerMediaObject = &CLSID_CResamplerMediaObject_Value;

const CLSID_CResizerMediaObject_Value = @import("../zig.zig").Guid.initString("D3EC8B8B-7728-4FD8-9FE0-7B67D19F73A3");
pub const CLSID_CResizerMediaObject = &CLSID_CResizerMediaObject_Value;

const CLSID_CInterlaceMediaObject_Value = @import("../zig.zig").Guid.initString("B5A89C80-4901-407B-9ABC-90D9A644BB46");
pub const CLSID_CInterlaceMediaObject = &CLSID_CInterlaceMediaObject_Value;

const CLSID_CWMAudioLFXAPO_Value = @import("../zig.zig").Guid.initString("62DC1A93-AE24-464C-A43E-452F824C4250");
pub const CLSID_CWMAudioLFXAPO = &CLSID_CWMAudioLFXAPO_Value;

const CLSID_CWMAudioGFXAPO_Value = @import("../zig.zig").Guid.initString("637C490D-EEE3-4C0A-973F-371958802DA2");
pub const CLSID_CWMAudioGFXAPO = &CLSID_CWMAudioGFXAPO_Value;

const CLSID_CWMAudioSpdTxDMO_Value = @import("../zig.zig").Guid.initString("5210F8E4-B0BB-47C3-A8D9-7B2282CC79ED");
pub const CLSID_CWMAudioSpdTxDMO = &CLSID_CWMAudioSpdTxDMO_Value;

const CLSID_CWMAudioAEC_Value = @import("../zig.zig").Guid.initString("745057C7-F353-4F2D-A7EE-58434477730E");
pub const CLSID_CWMAudioAEC = &CLSID_CWMAudioAEC_Value;

const CLSID_CClusterDetectorDmo_Value = @import("../zig.zig").Guid.initString("36E820C4-165A-4521-863C-619E1160D4D4");
pub const CLSID_CClusterDetectorDmo = &CLSID_CClusterDetectorDmo_Value;

const CLSID_CColorControlDmo_Value = @import("../zig.zig").Guid.initString("798059F0-89CA-4160-B325-AEB48EFE4F9A");
pub const CLSID_CColorControlDmo = &CLSID_CColorControlDmo_Value;

const CLSID_CColorConvertDMO_Value = @import("../zig.zig").Guid.initString("98230571-0087-4204-B020-3282538E57D3");
pub const CLSID_CColorConvertDMO = &CLSID_CColorConvertDMO_Value;

const CLSID_CColorLegalizerDmo_Value = @import("../zig.zig").Guid.initString("FDFAA753-E48E-4E33-9C74-98A27FC6726A");
pub const CLSID_CColorLegalizerDmo = &CLSID_CColorLegalizerDmo_Value;

const CLSID_CFrameInterpDMO_Value = @import("../zig.zig").Guid.initString("0A7CFE1B-6AB5-4334-9ED8-3F97CB37DAA1");
pub const CLSID_CFrameInterpDMO = &CLSID_CFrameInterpDMO_Value;

const CLSID_CFrameRateConvertDmo_Value = @import("../zig.zig").Guid.initString("01F36CE2-0907-4D8B-979D-F151BE91C883");
pub const CLSID_CFrameRateConvertDmo = &CLSID_CFrameRateConvertDmo_Value;

const CLSID_CResizerDMO_Value = @import("../zig.zig").Guid.initString("1EA1EA14-48F4-4054-AD1A-E8AEE10AC805");
pub const CLSID_CResizerDMO = &CLSID_CResizerDMO_Value;

const CLSID_CShotDetectorDmo_Value = @import("../zig.zig").Guid.initString("56AEFACD-110C-4397-9292-B0A0C61B6750");
pub const CLSID_CShotDetectorDmo = &CLSID_CShotDetectorDmo_Value;

const CLSID_CSmpteTransformsDmo_Value = @import("../zig.zig").Guid.initString("BDE6388B-DA25-485D-BA7F-FABC28B20318");
pub const CLSID_CSmpteTransformsDmo = &CLSID_CSmpteTransformsDmo_Value;

const CLSID_CThumbnailGeneratorDmo_Value = @import("../zig.zig").Guid.initString("559C6BAD-1EA8-4963-A087-8A6810F9218B");
pub const CLSID_CThumbnailGeneratorDmo = &CLSID_CThumbnailGeneratorDmo_Value;

const CLSID_CTocGeneratorDmo_Value = @import("../zig.zig").Guid.initString("4DDA1941-77A0-4FB1-A518-E2185041D70C");
pub const CLSID_CTocGeneratorDmo = &CLSID_CTocGeneratorDmo_Value;

const CLSID_CMPEGAACDecMediaObject_Value = @import("../zig.zig").Guid.initString("8DDE1772-EDAD-41C3-B4BE-1F30FB4EE0D6");
pub const CLSID_CMPEGAACDecMediaObject = &CLSID_CMPEGAACDecMediaObject_Value;

const CLSID_CNokiaAACDecMediaObject_Value = @import("../zig.zig").Guid.initString("3CB2BDE4-4E29-4C44-A73E-2D7C2C46D6EC");
pub const CLSID_CNokiaAACDecMediaObject = &CLSID_CNokiaAACDecMediaObject_Value;

const CLSID_CVodafoneAACDecMediaObject_Value = @import("../zig.zig").Guid.initString("7F36F942-DCF3-4D82-9289-5B1820278F7C");
pub const CLSID_CVodafoneAACDecMediaObject = &CLSID_CVodafoneAACDecMediaObject_Value;

const CLSID_CZuneAACCCDecMediaObject_Value = @import("../zig.zig").Guid.initString("A74E98F2-52D6-4B4E-885B-E0A6CA4F187A");
pub const CLSID_CZuneAACCCDecMediaObject = &CLSID_CZuneAACCCDecMediaObject_Value;

const CLSID_CNokiaAACCCDecMediaObject_Value = @import("../zig.zig").Guid.initString("EABF7A6F-CCBA-4D60-8620-B152CC977263");
pub const CLSID_CNokiaAACCCDecMediaObject = &CLSID_CNokiaAACCCDecMediaObject_Value;

const CLSID_CVodafoneAACCCDecMediaObject_Value = @import("../zig.zig").Guid.initString("7E76BF7F-C993-4E26-8FAB-470A70C0D59C");
pub const CLSID_CVodafoneAACCCDecMediaObject = &CLSID_CVodafoneAACCCDecMediaObject_Value;

const CLSID_CMPEG2EncoderDS_Value = @import("../zig.zig").Guid.initString("5F5AFF4A-2F7F-4279-88C2-CD88EB39D144");
pub const CLSID_CMPEG2EncoderDS = &CLSID_CMPEG2EncoderDS_Value;

const CLSID_CMPEG2EncoderVideoDS_Value = @import("../zig.zig").Guid.initString("42150CD9-CA9A-4EA5-9939-30EE037F6E74");
pub const CLSID_CMPEG2EncoderVideoDS = &CLSID_CMPEG2EncoderVideoDS_Value;

const CLSID_CMPEG2EncoderAudioDS_Value = @import("../zig.zig").Guid.initString("ACD453BC-C58A-44D1-BBF5-BFB325BE2D78");
pub const CLSID_CMPEG2EncoderAudioDS = &CLSID_CMPEG2EncoderAudioDS_Value;

const CLSID_CMPEG2AudDecoderDS_Value = @import("../zig.zig").Guid.initString("E1F1A0B8-BEEE-490D-BA7C-066C40B5E2B9");
pub const CLSID_CMPEG2AudDecoderDS = &CLSID_CMPEG2AudDecoderDS_Value;

const CLSID_CMPEG2VidDecoderDS_Value = @import("../zig.zig").Guid.initString("212690FB-83E5-4526-8FD7-74478B7939CD");
pub const CLSID_CMPEG2VidDecoderDS = &CLSID_CMPEG2VidDecoderDS_Value;

const CLSID_CDTVAudDecoderDS_Value = @import("../zig.zig").Guid.initString("8E269032-FE03-4753-9B17-18253C21722E");
pub const CLSID_CDTVAudDecoderDS = &CLSID_CDTVAudDecoderDS_Value;

const CLSID_CDTVVidDecoderDS_Value = @import("../zig.zig").Guid.initString("64777DC8-4E24-4BEB-9D19-60A35BE1DAAF");
pub const CLSID_CDTVVidDecoderDS = &CLSID_CDTVVidDecoderDS_Value;

const CLSID_CMSAC3Enc_Value = @import("../zig.zig").Guid.initString("C6B400E2-20A7-4E58-A2FE-24619682CE6C");
pub const CLSID_CMSAC3Enc = &CLSID_CMSAC3Enc_Value;

const CLSID_CMSH264DecoderMFT_Value = @import("../zig.zig").Guid.initString("62CE7E72-4C71-4D20-B15D-452831A87D9D");
pub const CLSID_CMSH264DecoderMFT = &CLSID_CMSH264DecoderMFT_Value;

const CLSID_CMSH263EncoderMFT_Value = @import("../zig.zig").Guid.initString("BC47FCFE-98A0-4F27-BB07-698AF24F2B38");
pub const CLSID_CMSH263EncoderMFT = &CLSID_CMSH263EncoderMFT_Value;

const CLSID_CMSH264EncoderMFT_Value = @import("../zig.zig").Guid.initString("6CA50344-051A-4DED-9779-A43305165E35");
pub const CLSID_CMSH264EncoderMFT = &CLSID_CMSH264EncoderMFT_Value;

const CLSID_CMSH265EncoderMFT_Value = @import("../zig.zig").Guid.initString("F2F84074-8BCA-40BD-9159-E880F673DD3B");
pub const CLSID_CMSH265EncoderMFT = &CLSID_CMSH265EncoderMFT_Value;

const CLSID_CMSVPXEncoderMFT_Value = @import("../zig.zig").Guid.initString("AEB6C755-2546-4881-82CC-E15AE5EBFF3D");
pub const CLSID_CMSVPXEncoderMFT = &CLSID_CMSVPXEncoderMFT_Value;

const CLSID_CMSH264RemuxMFT_Value = @import("../zig.zig").Guid.initString("05A47EBB-8BF0-4CBF-AD2F-3B71D75866F5");
pub const CLSID_CMSH264RemuxMFT = &CLSID_CMSH264RemuxMFT_Value;

const CLSID_CMSAACDecMFT_Value = @import("../zig.zig").Guid.initString("32D186A7-218F-4C75-8876-DD77273A8999");
pub const CLSID_CMSAACDecMFT = &CLSID_CMSAACDecMFT_Value;

const CLSID_AACMFTEncoder_Value = @import("../zig.zig").Guid.initString("93AF0C51-2275-45D2-A35B-F2BA21CAED00");
pub const CLSID_AACMFTEncoder = &CLSID_AACMFTEncoder_Value;

const CLSID_CMSDDPlusDecMFT_Value = @import("../zig.zig").Guid.initString("177C0AFE-900B-48D4-9E4C-57ADD250B3D4");
pub const CLSID_CMSDDPlusDecMFT = &CLSID_CMSDDPlusDecMFT_Value;

const CLSID_CMPEG2VideoEncoderMFT_Value = @import("../zig.zig").Guid.initString("E6335F02-80B7-4DC4-ADFA-DFE7210D20D5");
pub const CLSID_CMPEG2VideoEncoderMFT = &CLSID_CMPEG2VideoEncoderMFT_Value;

const CLSID_CMPEG2AudioEncoderMFT_Value = @import("../zig.zig").Guid.initString("46A4DD5C-73F8-4304-94DF-308F760974F4");
pub const CLSID_CMPEG2AudioEncoderMFT = &CLSID_CMPEG2AudioEncoderMFT_Value;

const CLSID_CMSMPEGDecoderMFT_Value = @import("../zig.zig").Guid.initString("2D709E52-123F-49B5-9CBC-9AF5CDE28FB9");
pub const CLSID_CMSMPEGDecoderMFT = &CLSID_CMSMPEGDecoderMFT_Value;

const CLSID_CMSMPEGAudDecMFT_Value = @import("../zig.zig").Guid.initString("70707B39-B2CA-4015-ABEA-F8447D22D88B");
pub const CLSID_CMSMPEGAudDecMFT = &CLSID_CMSMPEGAudDecMFT_Value;

const CLSID_CMSDolbyDigitalEncMFT_Value = @import("../zig.zig").Guid.initString("AC3315C9-F481-45D7-826C-0B406C1F64B8");
pub const CLSID_CMSDolbyDigitalEncMFT = &CLSID_CMSDolbyDigitalEncMFT_Value;

const CLSID_MP3ACMCodecWrapper_Value = @import("../zig.zig").Guid.initString("11103421-354C-4CCA-A7A3-1AFF9A5B6701");
pub const CLSID_MP3ACMCodecWrapper = &CLSID_MP3ACMCodecWrapper_Value;

const CLSID_ALawCodecWrapper_Value = @import("../zig.zig").Guid.initString("36CB6E0C-78C1-42B2-9943-846262F31786");
pub const CLSID_ALawCodecWrapper = &CLSID_ALawCodecWrapper_Value;

const CLSID_MULawCodecWrapper_Value = @import("../zig.zig").Guid.initString("92B66080-5E2D-449E-90C4-C41F268E5514");
pub const CLSID_MULawCodecWrapper = &CLSID_MULawCodecWrapper_Value;

const CLSID_CMSVideoDSPMFT_Value = @import("../zig.zig").Guid.initString("51571744-7FE4-4FF2-A498-2DC34FF74F1B");
pub const CLSID_CMSVideoDSPMFT = &CLSID_CMSVideoDSPMFT_Value;

const CLSID_VorbisDecoderMFT_Value = @import("../zig.zig").Guid.initString("1A198EF2-60E5-4EA8-90D8-DA1F2832C288");
pub const CLSID_VorbisDecoderMFT = &CLSID_VorbisDecoderMFT_Value;

const CLSID_CMSFLACDecMFT_Value = @import("../zig.zig").Guid.initString("6B0B3E6B-A2C5-4514-8055-AFE8A95242D9");
pub const CLSID_CMSFLACDecMFT = &CLSID_CMSFLACDecMFT_Value;

const CLSID_CMSFLACEncMFT_Value = @import("../zig.zig").Guid.initString("128509E9-C44E-45DC-95E9-C255B8F466A6");
pub const CLSID_CMSFLACEncMFT = &CLSID_CMSFLACEncMFT_Value;

const CLSID_MFFLACBytestreamHandler_Value = @import("../zig.zig").Guid.initString("0E41CFB8-0506-40F4-A516-77CC23642D91");
pub const CLSID_MFFLACBytestreamHandler = &CLSID_MFFLACBytestreamHandler_Value;

const CLSID_MFFLACSinkClassFactory_Value = @import("../zig.zig").Guid.initString("7D39C56F-6075-47C9-9BAE-8CF9E531B5F5");
pub const CLSID_MFFLACSinkClassFactory = &CLSID_MFFLACSinkClassFactory_Value;

const CLSID_CMSALACDecMFT_Value = @import("../zig.zig").Guid.initString("C0CD7D12-31FC-4BBC-B363-7322EE3E1879");
pub const CLSID_CMSALACDecMFT = &CLSID_CMSALACDecMFT_Value;

const CLSID_CMSALACEncMFT_Value = @import("../zig.zig").Guid.initString("9AB6A28C-748E-4B6A-BFFF-CC443B8E8FB4");
pub const CLSID_CMSALACEncMFT = &CLSID_CMSALACEncMFT_Value;

const CLSID_CMSOpusDecMFT_Value = @import("../zig.zig").Guid.initString("63E17C10-2D43-4C42-8FE3-8D8B63E46A6A");
pub const CLSID_CMSOpusDecMFT = &CLSID_CMSOpusDecMFT_Value;

const CLSID_MSAMRNBDecoder_Value = @import("../zig.zig").Guid.initString("265011AE-5481-4F77-A295-ABB6FFE8D63E");
pub const CLSID_MSAMRNBDecoder = &CLSID_MSAMRNBDecoder_Value;

const CLSID_MSAMRNBEncoder_Value = @import("../zig.zig").Guid.initString("2FAE8AFE-04A3-423A-A814-85DB454712B0");
pub const CLSID_MSAMRNBEncoder = &CLSID_MSAMRNBEncoder_Value;

const CLSID_MFAMRNBByteStreamHandler_Value = @import("../zig.zig").Guid.initString("EFE6208A-0A2C-49FA-8A01-3768B559B6DA");
pub const CLSID_MFAMRNBByteStreamHandler = &CLSID_MFAMRNBByteStreamHandler_Value;

const CLSID_MFAMRNBSinkClassFactory_Value = @import("../zig.zig").Guid.initString("B0271158-70D2-4C5B-9F94-76F549D90FDF");
pub const CLSID_MFAMRNBSinkClassFactory = &CLSID_MFAMRNBSinkClassFactory_Value;

pub const _DMO_INPUT_DATA_BUFFER_FLAGS = extern enum(i32) {
    DMO_INPUT_DATA_BUFFERF_SYNCPOINT = 1,
    DMO_INPUT_DATA_BUFFERF_TIME = 2,
    DMO_INPUT_DATA_BUFFERF_TIMELENGTH = 4,
    DMO_INPUT_DATA_BUFFERF_DISCONTINUITY = 8,
};
pub const DMO_INPUT_DATA_BUFFERF_SYNCPOINT = _DMO_INPUT_DATA_BUFFER_FLAGS.DMO_INPUT_DATA_BUFFERF_SYNCPOINT;
pub const DMO_INPUT_DATA_BUFFERF_TIME = _DMO_INPUT_DATA_BUFFER_FLAGS.DMO_INPUT_DATA_BUFFERF_TIME;
pub const DMO_INPUT_DATA_BUFFERF_TIMELENGTH = _DMO_INPUT_DATA_BUFFER_FLAGS.DMO_INPUT_DATA_BUFFERF_TIMELENGTH;
pub const DMO_INPUT_DATA_BUFFERF_DISCONTINUITY = _DMO_INPUT_DATA_BUFFER_FLAGS.DMO_INPUT_DATA_BUFFERF_DISCONTINUITY;

pub const _DMO_OUTPUT_DATA_BUFFER_FLAGS = extern enum(i32) {
    DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT = 1,
    DMO_OUTPUT_DATA_BUFFERF_TIME = 2,
    DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH = 4,
    DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY = 8,
    DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE = 16777216,
};
pub const DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT = _DMO_OUTPUT_DATA_BUFFER_FLAGS.DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT;
pub const DMO_OUTPUT_DATA_BUFFERF_TIME = _DMO_OUTPUT_DATA_BUFFER_FLAGS.DMO_OUTPUT_DATA_BUFFERF_TIME;
pub const DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH = _DMO_OUTPUT_DATA_BUFFER_FLAGS.DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH;
pub const DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY = _DMO_OUTPUT_DATA_BUFFER_FLAGS.DMO_OUTPUT_DATA_BUFFERF_DISCONTINUITY;
pub const DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE = _DMO_OUTPUT_DATA_BUFFER_FLAGS.DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE;

pub const _DMO_INPUT_STATUS_FLAGS = extern enum(i32) {
    DMO_INPUT_STATUSF_ACCEPT_DATA = 1,
};
pub const DMO_INPUT_STATUSF_ACCEPT_DATA = _DMO_INPUT_STATUS_FLAGS.DMO_INPUT_STATUSF_ACCEPT_DATA;

pub const _DMO_INPUT_STREAM_INFO_FLAGS = extern enum(i32) {
    DMO_INPUT_STREAMF_WHOLE_SAMPLES = 1,
    DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = 2,
    DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE = 4,
    DMO_INPUT_STREAMF_HOLDS_BUFFERS = 8,
};
pub const DMO_INPUT_STREAMF_WHOLE_SAMPLES = _DMO_INPUT_STREAM_INFO_FLAGS.DMO_INPUT_STREAMF_WHOLE_SAMPLES;
pub const DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = _DMO_INPUT_STREAM_INFO_FLAGS.DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
pub const DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE = _DMO_INPUT_STREAM_INFO_FLAGS.DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE;
pub const DMO_INPUT_STREAMF_HOLDS_BUFFERS = _DMO_INPUT_STREAM_INFO_FLAGS.DMO_INPUT_STREAMF_HOLDS_BUFFERS;

pub const _DMO_OUTPUT_STREAM_INFO_FLAGS = extern enum(i32) {
    DMO_OUTPUT_STREAMF_WHOLE_SAMPLES = 1,
    DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = 2,
    DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE = 4,
    DMO_OUTPUT_STREAMF_DISCARDABLE = 8,
    DMO_OUTPUT_STREAMF_OPTIONAL = 16,
};
pub const DMO_OUTPUT_STREAMF_WHOLE_SAMPLES = _DMO_OUTPUT_STREAM_INFO_FLAGS.DMO_OUTPUT_STREAMF_WHOLE_SAMPLES;
pub const DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER = _DMO_OUTPUT_STREAM_INFO_FLAGS.DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER;
pub const DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE = _DMO_OUTPUT_STREAM_INFO_FLAGS.DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE;
pub const DMO_OUTPUT_STREAMF_DISCARDABLE = _DMO_OUTPUT_STREAM_INFO_FLAGS.DMO_OUTPUT_STREAMF_DISCARDABLE;
pub const DMO_OUTPUT_STREAMF_OPTIONAL = _DMO_OUTPUT_STREAM_INFO_FLAGS.DMO_OUTPUT_STREAMF_OPTIONAL;

pub const _DMO_SET_TYPE_FLAGS = extern enum(i32) {
    DMO_SET_TYPEF_TEST_ONLY = 1,
    DMO_SET_TYPEF_CLEAR = 2,
};
pub const DMO_SET_TYPEF_TEST_ONLY = _DMO_SET_TYPE_FLAGS.DMO_SET_TYPEF_TEST_ONLY;
pub const DMO_SET_TYPEF_CLEAR = _DMO_SET_TYPE_FLAGS.DMO_SET_TYPEF_CLEAR;

pub const _DMO_PROCESS_OUTPUT_FLAGS = extern enum(i32) {
    DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = 1,
};
pub const DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = _DMO_PROCESS_OUTPUT_FLAGS.DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER;

pub const _DMO_INPLACE_PROCESS_FLAGS = extern enum(i32) {
    DMO_INPLACE_NORMAL = 0,
    DMO_INPLACE_ZERO = 1,
};
pub const DMO_INPLACE_NORMAL = _DMO_INPLACE_PROCESS_FLAGS.DMO_INPLACE_NORMAL;
pub const DMO_INPLACE_ZERO = _DMO_INPLACE_PROCESS_FLAGS.DMO_INPLACE_ZERO;

pub const _DMO_QUALITY_STATUS_FLAGS = extern enum(i32) {
    DMO_QUALITY_STATUS_ENABLED = 1,
};
pub const DMO_QUALITY_STATUS_ENABLED = _DMO_QUALITY_STATUS_FLAGS.DMO_QUALITY_STATUS_ENABLED;

pub const _DMO_VIDEO_OUTPUT_STREAM_FLAGS = extern enum(i32) {
    DMO_VOSF_NEEDS_PREVIOUS_SAMPLE = 1,
};
pub const DMO_VOSF_NEEDS_PREVIOUS_SAMPLE = _DMO_VIDEO_OUTPUT_STREAM_FLAGS.DMO_VOSF_NEEDS_PREVIOUS_SAMPLE;

pub const WMT_PROP_DATATYPE = extern enum(i32) {
    WMT_PROP_TYPE_DWORD = 0,
    WMT_PROP_TYPE_STRING = 1,
    WMT_PROP_TYPE_BINARY = 2,
    WMT_PROP_TYPE_BOOL = 3,
    WMT_PROP_TYPE_QWORD = 4,
    WMT_PROP_TYPE_WORD = 5,
    WMT_PROP_TYPE_GUID = 6,
};
pub const WMT_PROP_TYPE_DWORD = WMT_PROP_DATATYPE.WMT_PROP_TYPE_DWORD;
pub const WMT_PROP_TYPE_STRING = WMT_PROP_DATATYPE.WMT_PROP_TYPE_STRING;
pub const WMT_PROP_TYPE_BINARY = WMT_PROP_DATATYPE.WMT_PROP_TYPE_BINARY;
pub const WMT_PROP_TYPE_BOOL = WMT_PROP_DATATYPE.WMT_PROP_TYPE_BOOL;
pub const WMT_PROP_TYPE_QWORD = WMT_PROP_DATATYPE.WMT_PROP_TYPE_QWORD;
pub const WMT_PROP_TYPE_WORD = WMT_PROP_DATATYPE.WMT_PROP_TYPE_WORD;
pub const WMT_PROP_TYPE_GUID = WMT_PROP_DATATYPE.WMT_PROP_TYPE_GUID;

const IID_IWMValidate_Value = @import("../zig.zig").Guid.initString("CEE3DEF2-3808-414D-BE66-FAFD472210BC");
pub const IID_IWMValidate = &IID_IWMValidate_Value;
pub const IWMValidate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetIdentifier: fn(
            self: *const IWMValidate,
            guidValidationID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMValidate_SetIdentifier(self: *const T, guidValidationID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMValidate.VTable, self.vtable).SetIdentifier(@ptrCast(*const IWMValidate, self), guidValidationID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IValidateBinding_Value = @import("../zig.zig").Guid.initString("04A578B2-E778-422A-A805-B3EE54D90BD9");
pub const IID_IValidateBinding = &IID_IValidateBinding_Value;
pub const IValidateBinding = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdentifier: fn(
            self: *const IValidateBinding,
            guidLicensorID: Guid,
            pbEphemeron: [*:0]u8,
            cbEphemeron: u32,
            ppbBlobValidationID: ?[*]?*u8,
            pcbBlobSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidateBinding_GetIdentifier(self: *const T, guidLicensorID: Guid, pbEphemeron: [*:0]u8, cbEphemeron: u32, ppbBlobValidationID: ?[*]?*u8, pcbBlobSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidateBinding.VTable, self.vtable).GetIdentifier(@ptrCast(*const IValidateBinding, self), guidLicensorID, pbEphemeron, cbEphemeron, ppbBlobValidationID, pcbBlobSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMVideoDecoderHurryup_Value = @import("../zig.zig").Guid.initString("352BB3BD-2D4D-4323-9E71-DCDCFBD53CA6");
pub const IID_IWMVideoDecoderHurryup = &IID_IWMVideoDecoderHurryup_Value;
pub const IWMVideoDecoderHurryup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHurryup: fn(
            self: *const IWMVideoDecoderHurryup,
            lHurryup: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHurryup: fn(
            self: *const IWMVideoDecoderHurryup,
            plHurryup: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMVideoDecoderHurryup_SetHurryup(self: *const T, lHurryup: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMVideoDecoderHurryup.VTable, self.vtable).SetHurryup(@ptrCast(*const IWMVideoDecoderHurryup, self), lHurryup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMVideoDecoderHurryup_GetHurryup(self: *const T, plHurryup: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMVideoDecoderHurryup.VTable, self.vtable).GetHurryup(@ptrCast(*const IWMVideoDecoderHurryup, self), plHurryup);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMVideoForceKeyFrame_Value = @import("../zig.zig").Guid.initString("9F8496BE-5B9A-41B9-A9E8-F21CD80596C2");
pub const IID_IWMVideoForceKeyFrame = &IID_IWMVideoForceKeyFrame_Value;
pub const IWMVideoForceKeyFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetKeyFrame: fn(
            self: *const IWMVideoForceKeyFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMVideoForceKeyFrame_SetKeyFrame(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMVideoForceKeyFrame.VTable, self.vtable).SetKeyFrame(@ptrCast(*const IWMVideoForceKeyFrame, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecStrings_Value = @import("../zig.zig").Guid.initString("A7B2504B-E58A-47FB-958B-CAC7165A057D");
pub const IID_IWMCodecStrings = &IID_IWMCodecStrings_Value;
pub const IWMCodecStrings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IWMCodecStrings,
            pmt: *DMO_MEDIA_TYPE,
            cchLength: u32,
            szName: ?[*:0]u16,
            pcchLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IWMCodecStrings,
            pmt: *DMO_MEDIA_TYPE,
            cchLength: u32,
            szDescription: ?[*:0]u16,
            pcchLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecStrings_GetName(self: *const T, pmt: *DMO_MEDIA_TYPE, cchLength: u32, szName: ?[*:0]u16, pcchLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecStrings.VTable, self.vtable).GetName(@ptrCast(*const IWMCodecStrings, self), pmt, cchLength, szName, pcchLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecStrings_GetDescription(self: *const T, pmt: *DMO_MEDIA_TYPE, cchLength: u32, szDescription: ?[*:0]u16, pcchLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecStrings.VTable, self.vtable).GetDescription(@ptrCast(*const IWMCodecStrings, self), pmt, cchLength, szDescription, pcchLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecProps_Value = @import("../zig.zig").Guid.initString("2573E11A-F01A-4FDD-A98D-63B8E0BA9589");
pub const IID_IWMCodecProps = &IID_IWMCodecProps_Value;
pub const IWMCodecProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFormatProp: fn(
            self: *const IWMCodecProps,
            pmt: *DMO_MEDIA_TYPE,
            pszName: [*:0]const u16,
            pType: *WMT_PROP_DATATYPE,
            pValue: *u8,
            pdwSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodecProp: fn(
            self: *const IWMCodecProps,
            dwFormat: u32,
            pszName: [*:0]const u16,
            pType: *WMT_PROP_DATATYPE,
            pValue: *u8,
            pdwSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecProps_GetFormatProp(self: *const T, pmt: *DMO_MEDIA_TYPE, pszName: [*:0]const u16, pType: *WMT_PROP_DATATYPE, pValue: *u8, pdwSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecProps.VTable, self.vtable).GetFormatProp(@ptrCast(*const IWMCodecProps, self), pmt, pszName, pType, pValue, pdwSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecProps_GetCodecProp(self: *const T, dwFormat: u32, pszName: [*:0]const u16, pType: *WMT_PROP_DATATYPE, pValue: *u8, pdwSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecProps.VTable, self.vtable).GetCodecProp(@ptrCast(*const IWMCodecProps, self), dwFormat, pszName, pType, pValue, pdwSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecLeakyBucket_Value = @import("../zig.zig").Guid.initString("A81BA647-6227-43B7-B231-C7B15135DD7D");
pub const IID_IWMCodecLeakyBucket = &IID_IWMCodecLeakyBucket_Value;
pub const IWMCodecLeakyBucket = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBufferSizeBits: fn(
            self: *const IWMCodecLeakyBucket,
            ulBufferSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferSizeBits: fn(
            self: *const IWMCodecLeakyBucket,
            pulBufferSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBufferFullnessBits: fn(
            self: *const IWMCodecLeakyBucket,
            ulBufferFullness: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferFullnessBits: fn(
            self: *const IWMCodecLeakyBucket,
            pulBufferFullness: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecLeakyBucket_SetBufferSizeBits(self: *const T, ulBufferSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecLeakyBucket.VTable, self.vtable).SetBufferSizeBits(@ptrCast(*const IWMCodecLeakyBucket, self), ulBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecLeakyBucket_GetBufferSizeBits(self: *const T, pulBufferSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecLeakyBucket.VTable, self.vtable).GetBufferSizeBits(@ptrCast(*const IWMCodecLeakyBucket, self), pulBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecLeakyBucket_SetBufferFullnessBits(self: *const T, ulBufferFullness: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecLeakyBucket.VTable, self.vtable).SetBufferFullnessBits(@ptrCast(*const IWMCodecLeakyBucket, self), ulBufferFullness);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecLeakyBucket_GetBufferFullnessBits(self: *const T, pulBufferFullness: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecLeakyBucket.VTable, self.vtable).GetBufferFullnessBits(@ptrCast(*const IWMCodecLeakyBucket, self), pulBufferFullness);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecOutputTimestamp_Value = @import("../zig.zig").Guid.initString("B72ADF95-7ADC-4A72-BC05-577D8EA6BF68");
pub const IID_IWMCodecOutputTimestamp = &IID_IWMCodecOutputTimestamp_Value;
pub const IWMCodecOutputTimestamp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextOutputTime: fn(
            self: *const IWMCodecOutputTimestamp,
            prtTime: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecOutputTimestamp_GetNextOutputTime(self: *const T, prtTime: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecOutputTimestamp.VTable, self.vtable).GetNextOutputTime(@ptrCast(*const IWMCodecOutputTimestamp, self), prtTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMVideoDecoderReconBuffer_Value = @import("../zig.zig").Guid.initString("45BDA2AC-88E2-4923-98BA-3949080711A3");
pub const IID_IWMVideoDecoderReconBuffer = &IID_IWMVideoDecoderReconBuffer_Value;
pub const IWMVideoDecoderReconBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetReconstructedVideoFrameSize: fn(
            self: *const IWMVideoDecoderReconBuffer,
            pdwSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReconstructedVideoFrame: fn(
            self: *const IWMVideoDecoderReconBuffer,
            pBuf: *IMediaBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetReconstructedVideoFrame: fn(
            self: *const IWMVideoDecoderReconBuffer,
            pBuf: *IMediaBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMVideoDecoderReconBuffer_GetReconstructedVideoFrameSize(self: *const T, pdwSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMVideoDecoderReconBuffer.VTable, self.vtable).GetReconstructedVideoFrameSize(@ptrCast(*const IWMVideoDecoderReconBuffer, self), pdwSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMVideoDecoderReconBuffer_GetReconstructedVideoFrame(self: *const T, pBuf: *IMediaBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMVideoDecoderReconBuffer.VTable, self.vtable).GetReconstructedVideoFrame(@ptrCast(*const IWMVideoDecoderReconBuffer, self), pBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMVideoDecoderReconBuffer_SetReconstructedVideoFrame(self: *const T, pBuf: *IMediaBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMVideoDecoderReconBuffer.VTable, self.vtable).SetReconstructedVideoFrame(@ptrCast(*const IWMVideoDecoderReconBuffer, self), pBuf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMCodecPrivateData_Value = @import("../zig.zig").Guid.initString("73F0BE8E-57F7-4F01-AA66-9F57340CFE0E");
pub const IID_IWMCodecPrivateData = &IID_IWMCodecPrivateData_Value;
pub const IWMCodecPrivateData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPartialOutputType: fn(
            self: *const IWMCodecPrivateData,
            pmt: *DMO_MEDIA_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateData: fn(
            self: *const IWMCodecPrivateData,
            pbData: *u8,
            pcbData: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecPrivateData_SetPartialOutputType(self: *const T, pmt: *DMO_MEDIA_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecPrivateData.VTable, self.vtable).SetPartialOutputType(@ptrCast(*const IWMCodecPrivateData, self), pmt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMCodecPrivateData_GetPrivateData(self: *const T, pbData: *u8, pcbData: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMCodecPrivateData.VTable, self.vtable).GetPrivateData(@ptrCast(*const IWMCodecPrivateData, self), pbData, pcbData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMSampleExtensionSupport_Value = @import("../zig.zig").Guid.initString("9BCA9884-0604-4C2A-87DA-793FF4D586C3");
pub const IID_IWMSampleExtensionSupport = &IID_IWMSampleExtensionSupport_Value;
pub const IWMSampleExtensionSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUseSampleExtensions: fn(
            self: *const IWMSampleExtensionSupport,
            fUseExtensions: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMSampleExtensionSupport_SetUseSampleExtensions(self: *const T, fUseExtensions: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMSampleExtensionSupport.VTable, self.vtable).SetUseSampleExtensions(@ptrCast(*const IWMSampleExtensionSupport, self), fUseExtensions);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMResamplerProps_Value = @import("../zig.zig").Guid.initString("E7E9984F-F09F-4DA4-903F-6E2E0EFE56B5");
pub const IID_IWMResamplerProps = &IID_IWMResamplerProps_Value;
pub const IWMResamplerProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetHalfFilterLength: fn(
            self: *const IWMResamplerProps,
            lhalfFilterLen: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUserChannelMtx: fn(
            self: *const IWMResamplerProps,
            userChannelMtx: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMResamplerProps_SetHalfFilterLength(self: *const T, lhalfFilterLen: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMResamplerProps.VTable, self.vtable).SetHalfFilterLength(@ptrCast(*const IWMResamplerProps, self), lhalfFilterLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMResamplerProps_SetUserChannelMtx(self: *const T, userChannelMtx: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMResamplerProps.VTable, self.vtable).SetUserChannelMtx(@ptrCast(*const IWMResamplerProps, self), userChannelMtx);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMResizerProps_Value = @import("../zig.zig").Guid.initString("57665D4C-0414-4FAA-905B-10E546F81C33");
pub const IID_IWMResizerProps = &IID_IWMResizerProps_Value;
pub const IWMResizerProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetResizerQuality: fn(
            self: *const IWMResizerProps,
            lquality: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterlaceMode: fn(
            self: *const IWMResizerProps,
            lmode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClipRegion: fn(
            self: *const IWMResizerProps,
            lClipOriXSrc: i32,
            lClipOriYSrc: i32,
            lClipWidthSrc: i32,
            lClipHeightSrc: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFullCropRegion: fn(
            self: *const IWMResizerProps,
            lClipOriXSrc: i32,
            lClipOriYSrc: i32,
            lClipWidthSrc: i32,
            lClipHeightSrc: i32,
            lClipOriXDst: i32,
            lClipOriYDst: i32,
            lClipWidthDst: i32,
            lClipHeightDst: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFullCropRegion: fn(
            self: *const IWMResizerProps,
            lClipOriXSrc: *i32,
            lClipOriYSrc: *i32,
            lClipWidthSrc: *i32,
            lClipHeightSrc: *i32,
            lClipOriXDst: *i32,
            lClipOriYDst: *i32,
            lClipWidthDst: *i32,
            lClipHeightDst: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMResizerProps_SetResizerQuality(self: *const T, lquality: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMResizerProps.VTable, self.vtable).SetResizerQuality(@ptrCast(*const IWMResizerProps, self), lquality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMResizerProps_SetInterlaceMode(self: *const T, lmode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMResizerProps.VTable, self.vtable).SetInterlaceMode(@ptrCast(*const IWMResizerProps, self), lmode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMResizerProps_SetClipRegion(self: *const T, lClipOriXSrc: i32, lClipOriYSrc: i32, lClipWidthSrc: i32, lClipHeightSrc: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMResizerProps.VTable, self.vtable).SetClipRegion(@ptrCast(*const IWMResizerProps, self), lClipOriXSrc, lClipOriYSrc, lClipWidthSrc, lClipHeightSrc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMResizerProps_SetFullCropRegion(self: *const T, lClipOriXSrc: i32, lClipOriYSrc: i32, lClipWidthSrc: i32, lClipHeightSrc: i32, lClipOriXDst: i32, lClipOriYDst: i32, lClipWidthDst: i32, lClipHeightDst: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMResizerProps.VTable, self.vtable).SetFullCropRegion(@ptrCast(*const IWMResizerProps, self), lClipOriXSrc, lClipOriYSrc, lClipWidthSrc, lClipHeightSrc, lClipOriXDst, lClipOriYDst, lClipWidthDst, lClipHeightDst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMResizerProps_GetFullCropRegion(self: *const T, lClipOriXSrc: *i32, lClipOriYSrc: *i32, lClipWidthSrc: *i32, lClipHeightSrc: *i32, lClipOriXDst: *i32, lClipOriYDst: *i32, lClipWidthDst: *i32, lClipHeightDst: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMResizerProps.VTable, self.vtable).GetFullCropRegion(@ptrCast(*const IWMResizerProps, self), lClipOriXSrc, lClipOriYSrc, lClipWidthSrc, lClipHeightSrc, lClipOriXDst, lClipOriYDst, lClipWidthDst, lClipHeightDst);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMColorLegalizerProps_Value = @import("../zig.zig").Guid.initString("776C93B3-B72D-4508-B6D0-208785F553E7");
pub const IID_IWMColorLegalizerProps = &IID_IWMColorLegalizerProps_Value;
pub const IWMColorLegalizerProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColorLegalizerQuality: fn(
            self: *const IWMColorLegalizerProps,
            lquality: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMColorLegalizerProps_SetColorLegalizerQuality(self: *const T, lquality: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMColorLegalizerProps.VTable, self.vtable).SetColorLegalizerQuality(@ptrCast(*const IWMColorLegalizerProps, self), lquality);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMInterlaceProps_Value = @import("../zig.zig").Guid.initString("7B12E5D1-BD22-48EA-BC06-98E893221C89");
pub const IID_IWMInterlaceProps = &IID_IWMInterlaceProps_Value;
pub const IWMInterlaceProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProcessType: fn(
            self: *const IWMInterlaceProps,
            iProcessType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInitInverseTeleCinePattern: fn(
            self: *const IWMInterlaceProps,
            iInitPattern: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLastFrame: fn(
            self: *const IWMInterlaceProps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMInterlaceProps_SetProcessType(self: *const T, iProcessType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMInterlaceProps.VTable, self.vtable).SetProcessType(@ptrCast(*const IWMInterlaceProps, self), iProcessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMInterlaceProps_SetInitInverseTeleCinePattern(self: *const T, iInitPattern: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMInterlaceProps.VTable, self.vtable).SetInitInverseTeleCinePattern(@ptrCast(*const IWMInterlaceProps, self), iInitPattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMInterlaceProps_SetLastFrame(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMInterlaceProps.VTable, self.vtable).SetLastFrame(@ptrCast(*const IWMInterlaceProps, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMFrameInterpProps_Value = @import("../zig.zig").Guid.initString("4C06BB9B-626C-4614-8329-CC6A21B93FA0");
pub const IID_IWMFrameInterpProps = &IID_IWMFrameInterpProps_Value;
pub const IWMFrameInterpProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFrameRateIn: fn(
            self: *const IWMFrameInterpProps,
            lFrameRate: i32,
            lScale: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFrameRateOut: fn(
            self: *const IWMFrameInterpProps,
            lFrameRate: i32,
            lScale: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFrameInterpEnabled: fn(
            self: *const IWMFrameInterpProps,
            bFIEnabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetComplexityLevel: fn(
            self: *const IWMFrameInterpProps,
            iComplexity: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMFrameInterpProps_SetFrameRateIn(self: *const T, lFrameRate: i32, lScale: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMFrameInterpProps.VTable, self.vtable).SetFrameRateIn(@ptrCast(*const IWMFrameInterpProps, self), lFrameRate, lScale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMFrameInterpProps_SetFrameRateOut(self: *const T, lFrameRate: i32, lScale: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMFrameInterpProps.VTable, self.vtable).SetFrameRateOut(@ptrCast(*const IWMFrameInterpProps, self), lFrameRate, lScale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMFrameInterpProps_SetFrameInterpEnabled(self: *const T, bFIEnabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMFrameInterpProps.VTable, self.vtable).SetFrameInterpEnabled(@ptrCast(*const IWMFrameInterpProps, self), bFIEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMFrameInterpProps_SetComplexityLevel(self: *const T, iComplexity: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMFrameInterpProps.VTable, self.vtable).SetComplexityLevel(@ptrCast(*const IWMFrameInterpProps, self), iComplexity);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWMColorConvProps_Value = @import("../zig.zig").Guid.initString("E6A49E22-C099-421D-AAD3-C061FB4AE85B");
pub const IID_IWMColorConvProps = &IID_IWMColorConvProps_Value;
pub const IWMColorConvProps = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMode: fn(
            self: *const IWMColorConvProps,
            lMode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFullCroppingParam: fn(
            self: *const IWMColorConvProps,
            lSrcCropLeft: i32,
            lSrcCropTop: i32,
            lDstCropLeft: i32,
            lDstCropTop: i32,
            lCropWidth: i32,
            lCropHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMColorConvProps_SetMode(self: *const T, lMode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMColorConvProps.VTable, self.vtable).SetMode(@ptrCast(*const IWMColorConvProps, self), lMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWMColorConvProps_SetFullCroppingParam(self: *const T, lSrcCropLeft: i32, lSrcCropTop: i32, lDstCropLeft: i32, lDstCropTop: i32, lCropWidth: i32, lCropHeight: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWMColorConvProps.VTable, self.vtable).SetFullCroppingParam(@ptrCast(*const IWMColorConvProps, self), lSrcCropLeft, lSrcCropTop, lDstCropLeft, lDstCropTop, lCropWidth, lCropHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WMV_DYNAMIC_FLAGS = extern enum(i32) {
    WMV_DYNAMIC_BITRATE = 1,
    WMV_DYNAMIC_RESOLUTION = 2,
    WMV_DYNAMIC_COMPLEXITY = 4,
};
pub const WMV_DYNAMIC_BITRATE = WMV_DYNAMIC_FLAGS.WMV_DYNAMIC_BITRATE;
pub const WMV_DYNAMIC_RESOLUTION = WMV_DYNAMIC_FLAGS.WMV_DYNAMIC_RESOLUTION;
pub const WMV_DYNAMIC_COMPLEXITY = WMV_DYNAMIC_FLAGS.WMV_DYNAMIC_COMPLEXITY;

pub const MF_AUVRHP_ROOMMODEL = extern enum(i32) {
    VRHP_SMALLROOM = 0,
    VRHP_MEDIUMROOM = 1,
    VRHP_BIGROOM = 2,
    VRHP_CUSTUMIZEDROOM = 3,
};
pub const VRHP_SMALLROOM = MF_AUVRHP_ROOMMODEL.VRHP_SMALLROOM;
pub const VRHP_MEDIUMROOM = MF_AUVRHP_ROOMMODEL.VRHP_MEDIUMROOM;
pub const VRHP_BIGROOM = MF_AUVRHP_ROOMMODEL.VRHP_BIGROOM;
pub const VRHP_CUSTUMIZEDROOM = MF_AUVRHP_ROOMMODEL.VRHP_CUSTUMIZEDROOM;

pub const AEC_SYSTEM_MODE = extern enum(i32) {
    SINGLE_CHANNEL_AEC = 0,
    ADAPTIVE_ARRAY_ONLY = 1,
    OPTIBEAM_ARRAY_ONLY = 2,
    ADAPTIVE_ARRAY_AND_AEC = 3,
    OPTIBEAM_ARRAY_AND_AEC = 4,
    SINGLE_CHANNEL_NSAGC = 5,
    MODE_NOT_SET = 6,
};
pub const SINGLE_CHANNEL_AEC = AEC_SYSTEM_MODE.SINGLE_CHANNEL_AEC;
pub const ADAPTIVE_ARRAY_ONLY = AEC_SYSTEM_MODE.ADAPTIVE_ARRAY_ONLY;
pub const OPTIBEAM_ARRAY_ONLY = AEC_SYSTEM_MODE.OPTIBEAM_ARRAY_ONLY;
pub const ADAPTIVE_ARRAY_AND_AEC = AEC_SYSTEM_MODE.ADAPTIVE_ARRAY_AND_AEC;
pub const OPTIBEAM_ARRAY_AND_AEC = AEC_SYSTEM_MODE.OPTIBEAM_ARRAY_AND_AEC;
pub const SINGLE_CHANNEL_NSAGC = AEC_SYSTEM_MODE.SINGLE_CHANNEL_NSAGC;
pub const MODE_NOT_SET = AEC_SYSTEM_MODE.MODE_NOT_SET;

pub const AecQualityMetrics_Struct = extern struct {
    i64Timestamp: i64,
    ConvergenceFlag: u8,
    MicClippedFlag: u8,
    MicSilenceFlag: u8,
    PstvFeadbackFlag: u8,
    SpkClippedFlag: u8,
    SpkMuteFlag: u8,
    GlitchFlag: u8,
    DoubleTalkFlag: u8,
    uGlitchCount: u32,
    uMicClipCount: u32,
    fDuration: f32,
    fTSVariance: f32,
    fTSDriftRate: f32,
    fVoiceLevel: f32,
    fNoiseLevel: f32,
    fERLE: f32,
    fAvgERLE: f32,
    dwReserved: u32,
};

pub const AEC_VAD_MODE = extern enum(i32) {
    AEC_VAD_DISABLED = 0,
    AEC_VAD_NORMAL = 1,
    AEC_VAD_FOR_AGC = 2,
    AEC_VAD_FOR_SILENCE_SUPPRESSION = 3,
};
pub const AEC_VAD_DISABLED = AEC_VAD_MODE.AEC_VAD_DISABLED;
pub const AEC_VAD_NORMAL = AEC_VAD_MODE.AEC_VAD_NORMAL;
pub const AEC_VAD_FOR_AGC = AEC_VAD_MODE.AEC_VAD_FOR_AGC;
pub const AEC_VAD_FOR_SILENCE_SUPPRESSION = AEC_VAD_MODE.AEC_VAD_FOR_SILENCE_SUPPRESSION;

pub const AEC_INPUT_STREAM = extern enum(i32) {
    AEC_CAPTURE_STREAM = 0,
    AEC_REFERENCE_STREAM = 1,
};
pub const AEC_CAPTURE_STREAM = AEC_INPUT_STREAM.AEC_CAPTURE_STREAM;
pub const AEC_REFERENCE_STREAM = AEC_INPUT_STREAM.AEC_REFERENCE_STREAM;

pub const MIC_ARRAY_MODE = extern enum(i32) {
    MICARRAY_SINGLE_CHAN = 0,
    MICARRAY_SIMPLE_SUM = 256,
    MICARRAY_SINGLE_BEAM = 512,
    MICARRAY_FIXED_BEAM = 1024,
    MICARRAY_EXTERN_BEAM = 2048,
};
pub const MICARRAY_SINGLE_CHAN = MIC_ARRAY_MODE.MICARRAY_SINGLE_CHAN;
pub const MICARRAY_SIMPLE_SUM = MIC_ARRAY_MODE.MICARRAY_SIMPLE_SUM;
pub const MICARRAY_SINGLE_BEAM = MIC_ARRAY_MODE.MICARRAY_SINGLE_BEAM;
pub const MICARRAY_FIXED_BEAM = MIC_ARRAY_MODE.MICARRAY_FIXED_BEAM;
pub const MICARRAY_EXTERN_BEAM = MIC_ARRAY_MODE.MICARRAY_EXTERN_BEAM;

pub const MFVideoDSPMode = extern enum(i32) {
    Passthrough = 1,
    Stabilization = 4,
};
pub const MFVideoDSPMode_Passthrough = MFVideoDSPMode.Passthrough;
pub const MFVideoDSPMode_Stabilization = MFVideoDSPMode.Stabilization;

pub const TOC_DESCRIPTOR = extern struct {
    guidID: Guid,
    wStreamNumber: u16,
    guidType: Guid,
    wLanguageIndex: u16,
};

pub const TOC_ENTRY_DESCRIPTOR = extern struct {
    qwStartTime: u64,
    qwEndTime: u64,
    qwStartPacketOffset: u64,
    qwEndPacketOffset: u64,
    qwRepresentativeFrameTime: u64,
};

pub const TOC_POS_TYPE = extern enum(i32) {
    TOC_POS_INHEADER = 0,
    TOC_POS_TOPLEVELOBJECT = 1,
};
pub const TOC_POS_INHEADER = TOC_POS_TYPE.TOC_POS_INHEADER;
pub const TOC_POS_TOPLEVELOBJECT = TOC_POS_TYPE.TOC_POS_TOPLEVELOBJECT;

const IID_ITocEntry_Value = @import("../zig.zig").Guid.initString("F22F5E06-585C-4DEF-8523-6555CFBC0CB3");
pub const IID_ITocEntry = &IID_ITocEntry_Value;
pub const ITocEntry = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTitle: fn(
            self: *const ITocEntry,
            pwszTitle: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTitle: fn(
            self: *const ITocEntry,
            pwTitleSize: *u16,
            pwszTitle: ?[*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescriptor: fn(
            self: *const ITocEntry,
            pDescriptor: *TOC_ENTRY_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptor: fn(
            self: *const ITocEntry,
            pDescriptor: *TOC_ENTRY_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubEntries: fn(
            self: *const ITocEntry,
            dwNumSubEntries: u32,
            pwSubEntryIndices: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubEntries: fn(
            self: *const ITocEntry,
            pdwNumSubEntries: *u32,
            pwSubEntryIndices: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescriptionData: fn(
            self: *const ITocEntry,
            dwDescriptionDataSize: u32,
            pbtDescriptionData: *u8,
            pguidType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionData: fn(
            self: *const ITocEntry,
            pdwDescriptionDataSize: *u32,
            pbtDescriptionData: *u8,
            pGuidType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntry_SetTitle(self: *const T, pwszTitle: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntry.VTable, self.vtable).SetTitle(@ptrCast(*const ITocEntry, self), pwszTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntry_GetTitle(self: *const T, pwTitleSize: *u16, pwszTitle: ?[*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntry.VTable, self.vtable).GetTitle(@ptrCast(*const ITocEntry, self), pwTitleSize, pwszTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntry_SetDescriptor(self: *const T, pDescriptor: *TOC_ENTRY_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntry.VTable, self.vtable).SetDescriptor(@ptrCast(*const ITocEntry, self), pDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntry_GetDescriptor(self: *const T, pDescriptor: *TOC_ENTRY_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntry.VTable, self.vtable).GetDescriptor(@ptrCast(*const ITocEntry, self), pDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntry_SetSubEntries(self: *const T, dwNumSubEntries: u32, pwSubEntryIndices: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntry.VTable, self.vtable).SetSubEntries(@ptrCast(*const ITocEntry, self), dwNumSubEntries, pwSubEntryIndices);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntry_GetSubEntries(self: *const T, pdwNumSubEntries: *u32, pwSubEntryIndices: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntry.VTable, self.vtable).GetSubEntries(@ptrCast(*const ITocEntry, self), pdwNumSubEntries, pwSubEntryIndices);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntry_SetDescriptionData(self: *const T, dwDescriptionDataSize: u32, pbtDescriptionData: *u8, pguidType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntry.VTable, self.vtable).SetDescriptionData(@ptrCast(*const ITocEntry, self), dwDescriptionDataSize, pbtDescriptionData, pguidType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntry_GetDescriptionData(self: *const T, pdwDescriptionDataSize: *u32, pbtDescriptionData: *u8, pGuidType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntry.VTable, self.vtable).GetDescriptionData(@ptrCast(*const ITocEntry, self), pdwDescriptionDataSize, pbtDescriptionData, pGuidType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITocEntryList_Value = @import("../zig.zig").Guid.initString("3A8CCCBD-0EFD-43A3-B838-F38A552BA237");
pub const IID_ITocEntryList = &IID_ITocEntryList_Value;
pub const ITocEntryList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEntryCount: fn(
            self: *const ITocEntryList,
            pdwEntryCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntryByIndex: fn(
            self: *const ITocEntryList,
            dwEntryIndex: u32,
            ppEntry: **ITocEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEntry: fn(
            self: *const ITocEntryList,
            pEntry: *ITocEntry,
            pdwEntryIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEntryByIndex: fn(
            self: *const ITocEntryList,
            dwEntryIndex: u32,
            pEntry: *ITocEntry,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEntryByIndex: fn(
            self: *const ITocEntryList,
            dwEntryIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntryList_GetEntryCount(self: *const T, pdwEntryCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntryList.VTable, self.vtable).GetEntryCount(@ptrCast(*const ITocEntryList, self), pdwEntryCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntryList_GetEntryByIndex(self: *const T, dwEntryIndex: u32, ppEntry: **ITocEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntryList.VTable, self.vtable).GetEntryByIndex(@ptrCast(*const ITocEntryList, self), dwEntryIndex, ppEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntryList_AddEntry(self: *const T, pEntry: *ITocEntry, pdwEntryIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntryList.VTable, self.vtable).AddEntry(@ptrCast(*const ITocEntryList, self), pEntry, pdwEntryIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntryList_AddEntryByIndex(self: *const T, dwEntryIndex: u32, pEntry: *ITocEntry) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntryList.VTable, self.vtable).AddEntryByIndex(@ptrCast(*const ITocEntryList, self), dwEntryIndex, pEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocEntryList_RemoveEntryByIndex(self: *const T, dwEntryIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocEntryList.VTable, self.vtable).RemoveEntryByIndex(@ptrCast(*const ITocEntryList, self), dwEntryIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IToc_Value = @import("../zig.zig").Guid.initString("D6F05441-A919-423B-91A0-89D5B4A8AB77");
pub const IID_IToc = &IID_IToc_Value;
pub const IToc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDescriptor: fn(
            self: *const IToc,
            pDescriptor: *TOC_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptor: fn(
            self: *const IToc,
            pDescriptor: *TOC_DESCRIPTOR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescription: fn(
            self: *const IToc,
            pwszDescription: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IToc,
            pwDescriptionSize: *u16,
            pwszDescription: ?[*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetContext: fn(
            self: *const IToc,
            dwContextSize: u32,
            pbtContext: *u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContext: fn(
            self: *const IToc,
            pdwContextSize: *u32,
            pbtContext: *u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntryListCount: fn(
            self: *const IToc,
            pwCount: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntryListByIndex: fn(
            self: *const IToc,
            wEntryListIndex: u16,
            ppEntryList: **ITocEntryList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEntryList: fn(
            self: *const IToc,
            pEntryList: *ITocEntryList,
            pwEntryListIndex: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEntryListByIndex: fn(
            self: *const IToc,
            wEntryListIndex: u16,
            pEntryList: *ITocEntryList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEntryListByIndex: fn(
            self: *const IToc,
            wEntryListIndex: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_SetDescriptor(self: *const T, pDescriptor: *TOC_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).SetDescriptor(@ptrCast(*const IToc, self), pDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_GetDescriptor(self: *const T, pDescriptor: *TOC_DESCRIPTOR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).GetDescriptor(@ptrCast(*const IToc, self), pDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_SetDescription(self: *const T, pwszDescription: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).SetDescription(@ptrCast(*const IToc, self), pwszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_GetDescription(self: *const T, pwDescriptionSize: *u16, pwszDescription: ?[*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).GetDescription(@ptrCast(*const IToc, self), pwDescriptionSize, pwszDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_SetContext(self: *const T, dwContextSize: u32, pbtContext: *u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).SetContext(@ptrCast(*const IToc, self), dwContextSize, pbtContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_GetContext(self: *const T, pdwContextSize: *u32, pbtContext: *u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).GetContext(@ptrCast(*const IToc, self), pdwContextSize, pbtContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_GetEntryListCount(self: *const T, pwCount: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).GetEntryListCount(@ptrCast(*const IToc, self), pwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_GetEntryListByIndex(self: *const T, wEntryListIndex: u16, ppEntryList: **ITocEntryList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).GetEntryListByIndex(@ptrCast(*const IToc, self), wEntryListIndex, ppEntryList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_AddEntryList(self: *const T, pEntryList: *ITocEntryList, pwEntryListIndex: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).AddEntryList(@ptrCast(*const IToc, self), pEntryList, pwEntryListIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_AddEntryListByIndex(self: *const T, wEntryListIndex: u16, pEntryList: *ITocEntryList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).AddEntryListByIndex(@ptrCast(*const IToc, self), wEntryListIndex, pEntryList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IToc_RemoveEntryListByIndex(self: *const T, wEntryListIndex: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IToc.VTable, self.vtable).RemoveEntryListByIndex(@ptrCast(*const IToc, self), wEntryListIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITocCollection_Value = @import("../zig.zig").Guid.initString("23FEE831-AE96-42DF-B170-25A04847A3CA");
pub const IID_ITocCollection = &IID_ITocCollection_Value;
pub const ITocCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEntryCount: fn(
            self: *const ITocCollection,
            pdwEntryCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEntryByIndex: fn(
            self: *const ITocCollection,
            dwEntryIndex: u32,
            ppToc: **IToc,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEntry: fn(
            self: *const ITocCollection,
            pToc: *IToc,
            pdwEntryIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEntryByIndex: fn(
            self: *const ITocCollection,
            dwEntryIndex: u32,
            pToc: *IToc,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEntryByIndex: fn(
            self: *const ITocCollection,
            dwEntryIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocCollection_GetEntryCount(self: *const T, pdwEntryCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocCollection.VTable, self.vtable).GetEntryCount(@ptrCast(*const ITocCollection, self), pdwEntryCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocCollection_GetEntryByIndex(self: *const T, dwEntryIndex: u32, ppToc: **IToc) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocCollection.VTable, self.vtable).GetEntryByIndex(@ptrCast(*const ITocCollection, self), dwEntryIndex, ppToc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocCollection_AddEntry(self: *const T, pToc: *IToc, pdwEntryIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocCollection.VTable, self.vtable).AddEntry(@ptrCast(*const ITocCollection, self), pToc, pdwEntryIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocCollection_AddEntryByIndex(self: *const T, dwEntryIndex: u32, pToc: *IToc) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocCollection.VTable, self.vtable).AddEntryByIndex(@ptrCast(*const ITocCollection, self), dwEntryIndex, pToc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocCollection_RemoveEntryByIndex(self: *const T, dwEntryIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocCollection.VTable, self.vtable).RemoveEntryByIndex(@ptrCast(*const ITocCollection, self), dwEntryIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITocParser_Value = @import("../zig.zig").Guid.initString("ECFB9A55-9298-4F49-887F-0B36206599D2");
pub const IID_ITocParser = &IID_ITocParser_Value;
pub const ITocParser = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const ITocParser,
            pwszFileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTocCount: fn(
            self: *const ITocParser,
            enumTocPosType: TOC_POS_TYPE,
            pdwTocCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTocByIndex: fn(
            self: *const ITocParser,
            enumTocPosType: TOC_POS_TYPE,
            dwTocIndex: u32,
            ppToc: **IToc,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTocByType: fn(
            self: *const ITocParser,
            enumTocPosType: TOC_POS_TYPE,
            guidTocType: Guid,
            ppTocs: **ITocCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddToc: fn(
            self: *const ITocParser,
            enumTocPosType: TOC_POS_TYPE,
            pToc: *IToc,
            pdwTocIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTocByIndex: fn(
            self: *const ITocParser,
            enumTocPosType: TOC_POS_TYPE,
            dwTocIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTocByType: fn(
            self: *const ITocParser,
            enumTocPosType: TOC_POS_TYPE,
            guidTocType: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const ITocParser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocParser_Init(self: *const T, pwszFileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocParser.VTable, self.vtable).Init(@ptrCast(*const ITocParser, self), pwszFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocParser_GetTocCount(self: *const T, enumTocPosType: TOC_POS_TYPE, pdwTocCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocParser.VTable, self.vtable).GetTocCount(@ptrCast(*const ITocParser, self), enumTocPosType, pdwTocCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocParser_GetTocByIndex(self: *const T, enumTocPosType: TOC_POS_TYPE, dwTocIndex: u32, ppToc: **IToc) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocParser.VTable, self.vtable).GetTocByIndex(@ptrCast(*const ITocParser, self), enumTocPosType, dwTocIndex, ppToc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocParser_GetTocByType(self: *const T, enumTocPosType: TOC_POS_TYPE, guidTocType: Guid, ppTocs: **ITocCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocParser.VTable, self.vtable).GetTocByType(@ptrCast(*const ITocParser, self), enumTocPosType, guidTocType, ppTocs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocParser_AddToc(self: *const T, enumTocPosType: TOC_POS_TYPE, pToc: *IToc, pdwTocIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocParser.VTable, self.vtable).AddToc(@ptrCast(*const ITocParser, self), enumTocPosType, pToc, pdwTocIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocParser_RemoveTocByIndex(self: *const T, enumTocPosType: TOC_POS_TYPE, dwTocIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocParser.VTable, self.vtable).RemoveTocByIndex(@ptrCast(*const ITocParser, self), enumTocPosType, dwTocIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocParser_RemoveTocByType(self: *const T, enumTocPosType: TOC_POS_TYPE, guidTocType: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocParser.VTable, self.vtable).RemoveTocByType(@ptrCast(*const ITocParser, self), enumTocPosType, guidTocType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITocParser_Commit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITocParser.VTable, self.vtable).Commit(@ptrCast(*const ITocParser, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FILE_OPENMODE = extern enum(i32) {
    OPENMODE_FAIL_IF_NOT_EXIST = 0,
    OPENMODE_FAIL_IF_EXIST = 1,
    OPENMODE_RESET_IF_EXIST = 2,
    OPENMODE_APPEND_IF_EXIST = 3,
    OPENMODE_DELETE_IF_EXIST = 4,
};
pub const OPENMODE_FAIL_IF_NOT_EXIST = FILE_OPENMODE.OPENMODE_FAIL_IF_NOT_EXIST;
pub const OPENMODE_FAIL_IF_EXIST = FILE_OPENMODE.OPENMODE_FAIL_IF_EXIST;
pub const OPENMODE_RESET_IF_EXIST = FILE_OPENMODE.OPENMODE_RESET_IF_EXIST;
pub const OPENMODE_APPEND_IF_EXIST = FILE_OPENMODE.OPENMODE_APPEND_IF_EXIST;
pub const OPENMODE_DELETE_IF_EXIST = FILE_OPENMODE.OPENMODE_DELETE_IF_EXIST;

pub const SEEK_ORIGIN = extern enum(i32) {
    _msoBegin = 0,
    _msoCurrent = 1,
};
pub const _msoBegin = SEEK_ORIGIN._msoBegin;
pub const _msoCurrent = SEEK_ORIGIN._msoCurrent;

pub const FILE_ACCESSMODE = extern enum(i32) {
    ACCESSMODE_READ = 1,
    ACCESSMODE_WRITE = 2,
    ACCESSMODE_READWRITE = 3,
    ACCESSMODE_WRITE_EXCLUSIVE = 4,
};
pub const ACCESSMODE_READ = FILE_ACCESSMODE.ACCESSMODE_READ;
pub const ACCESSMODE_WRITE = FILE_ACCESSMODE.ACCESSMODE_WRITE;
pub const ACCESSMODE_READWRITE = FILE_ACCESSMODE.ACCESSMODE_READWRITE;
pub const ACCESSMODE_WRITE_EXCLUSIVE = FILE_ACCESSMODE.ACCESSMODE_WRITE_EXCLUSIVE;

const IID_IFileIo_Value = @import("../zig.zig").Guid.initString("11993196-1244-4840-AB44-480975C4FFE4");
pub const IID_IFileIo = &IID_IFileIo_Value;
pub const IFileIo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IFileIo,
            eAccessMode: FILE_ACCESSMODE,
            eOpenMode: FILE_OPENMODE,
            pwszFileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IFileIo,
            pqwLength: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLength: fn(
            self: *const IFileIo,
            qwLength: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPosition: fn(
            self: *const IFileIo,
            pqwPosition: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentPosition: fn(
            self: *const IFileIo,
            qwPosition: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEndOfStream: fn(
            self: *const IFileIo,
            pbEndOfStream: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Read: fn(
            self: *const IFileIo,
            pbt: *u8,
            ul: u32,
            pulRead: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const IFileIo,
            pbt: *u8,
            ul: u32,
            pulWritten: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Seek: fn(
            self: *const IFileIo,
            eSeekOrigin: SEEK_ORIGIN,
            qwSeekOffset: u64,
            dwSeekFlags: u32,
            pqwCurrentPosition: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IFileIo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_Initialize(self: *const T, eAccessMode: FILE_ACCESSMODE, eOpenMode: FILE_OPENMODE, pwszFileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).Initialize(@ptrCast(*const IFileIo, self), eAccessMode, eOpenMode, pwszFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_GetLength(self: *const T, pqwLength: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).GetLength(@ptrCast(*const IFileIo, self), pqwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_SetLength(self: *const T, qwLength: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).SetLength(@ptrCast(*const IFileIo, self), qwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_GetCurrentPosition(self: *const T, pqwPosition: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).GetCurrentPosition(@ptrCast(*const IFileIo, self), pqwPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_SetCurrentPosition(self: *const T, qwPosition: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).SetCurrentPosition(@ptrCast(*const IFileIo, self), qwPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_IsEndOfStream(self: *const T, pbEndOfStream: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).IsEndOfStream(@ptrCast(*const IFileIo, self), pbEndOfStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_Read(self: *const T, pbt: *u8, ul: u32, pulRead: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).Read(@ptrCast(*const IFileIo, self), pbt, ul, pulRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_Write(self: *const T, pbt: *u8, ul: u32, pulWritten: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).Write(@ptrCast(*const IFileIo, self), pbt, ul, pulWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_Seek(self: *const T, eSeekOrigin: SEEK_ORIGIN, qwSeekOffset: u64, dwSeekFlags: u32, pqwCurrentPosition: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).Seek(@ptrCast(*const IFileIo, self), eSeekOrigin, qwSeekOffset, dwSeekFlags, pqwCurrentPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileIo_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileIo.VTable, self.vtable).Close(@ptrCast(*const IFileIo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFileClient_Value = @import("../zig.zig").Guid.initString("BFCCD196-1244-4840-AB44-480975C4FFE4");
pub const IID_IFileClient = &IID_IFileClient_Value;
pub const IFileClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObjectDiskSize: fn(
            self: *const IFileClient,
            pqwSize: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const IFileClient,
            pFio: *IFileIo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Read: fn(
            self: *const IFileClient,
            pFio: *IFileIo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileClient_GetObjectDiskSize(self: *const T, pqwSize: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileClient.VTable, self.vtable).GetObjectDiskSize(@ptrCast(*const IFileClient, self), pqwSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileClient_Write(self: *const T, pFio: *IFileIo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileClient.VTable, self.vtable).Write(@ptrCast(*const IFileClient, self), pFio);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFileClient_Read(self: *const T, pFio: *IFileIo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFileClient.VTable, self.vtable).Read(@ptrCast(*const IFileClient, self), pFio);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IClusterDetector_Value = @import("../zig.zig").Guid.initString("3F07F7B7-C680-41D9-9423-915107EC9FF9");
pub const IID_IClusterDetector = &IID_IClusterDetector_Value;
pub const IClusterDetector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IClusterDetector,
            wBaseEntryLevel: u16,
            wClusterEntryLevel: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detect: fn(
            self: *const IClusterDetector,
            dwMaxNumClusters: u32,
            fMinClusterDuration: f32,
            fMaxClusterDuration: f32,
            pSrcToc: *IToc,
            ppDstToc: **IToc,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClusterDetector_Initialize(self: *const T, wBaseEntryLevel: u16, wClusterEntryLevel: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClusterDetector.VTable, self.vtable).Initialize(@ptrCast(*const IClusterDetector, self), wBaseEntryLevel, wClusterEntryLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClusterDetector_Detect(self: *const T, dwMaxNumClusters: u32, fMinClusterDuration: f32, fMaxClusterDuration: f32, pSrcToc: *IToc, ppDstToc: **IToc) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClusterDetector.VTable, self.vtable).Detect(@ptrCast(*const IClusterDetector, self), dwMaxNumClusters, fMinClusterDuration, fMaxClusterDuration, pSrcToc, ppDstToc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXVA_AYUVsample2 = extern struct {
    bCrValue: u8,
    bCbValue: u8,
    bY_Value: u8,
    bSampleAlpha8: u8,
};

pub const DXVA_BufferDescription = extern struct {
    dwTypeIndex: u32,
    dwBufferIndex: u32,
    dwDataOffset: u32,
    dwDataSize: u32,
    dwFirstMBaddress: u32,
    dwNumMBsInBuffer: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwStride: u32,
    dwReservedBits: u32,
};

pub const DXVA_ConfigPictureDecode = extern struct {
    dwFunction: u32,
    dwReservedBits: [3]u32,
    guidConfigBitstreamEncryption: Guid,
    guidConfigMBcontrolEncryption: Guid,
    guidConfigResidDiffEncryption: Guid,
    bConfigBitstreamRaw: u8,
    bConfigMBcontrolRasterOrder: u8,
    bConfigResidDiffHost: u8,
    bConfigSpatialResid8: u8,
    bConfigResid8Subtraction: u8,
    bConfigSpatialHost8or9Clipping: u8,
    bConfigSpatialResidInterleaved: u8,
    bConfigIntraResidUnsigned: u8,
    bConfigResidDiffAccelerator: u8,
    bConfigHostInverseScan: u8,
    bConfigSpecificIDCT: u8,
    bConfig4GroupedCoefs: u8,
};

pub const DXVA_PictureParameters = extern struct {
    wDecodedPictureIndex: u16,
    wDeblockedPictureIndex: u16,
    wForwardRefPictureIndex: u16,
    wBackwardRefPictureIndex: u16,
    wPicWidthInMBminus1: u16,
    wPicHeightInMBminus1: u16,
    bMacroblockWidthMinus1: u8,
    bMacroblockHeightMinus1: u8,
    bBlockWidthMinus1: u8,
    bBlockHeightMinus1: u8,
    bBPPminus1: u8,
    bPicStructure: u8,
    bSecondField: u8,
    bPicIntra: u8,
    bPicBackwardPrediction: u8,
    bBidirectionalAveragingMode: u8,
    bMVprecisionAndChromaRelation: u8,
    bChromaFormat: u8,
    bPicScanFixed: u8,
    bPicScanMethod: u8,
    bPicReadbackRequests: u8,
    bRcontrol: u8,
    bPicSpatialResid8: u8,
    bPicOverflowBlocks: u8,
    bPicExtrapolation: u8,
    bPicDeblocked: u8,
    bPicDeblockConfined: u8,
    bPic4MVallowed: u8,
    bPicOBMC: u8,
    bPicBinPB: u8,
    bMV_RPS: u8,
    bReservedBits: u8,
    wBitstreamFcodes: u16,
    wBitstreamPCEelements: u16,
    bBitstreamConcealmentNeed: u8,
    bBitstreamConcealmentMethod: u8,
};

pub const DXVAUncompDataInfo = extern struct {
    UncompWidth: u32,
    UncompHeight: u32,
    UncompFormat: D3DFORMAT,
};

pub const DXVACompBufferInfo = extern struct {
    NumCompBuffers: u32,
    WidthToCreate: u32,
    HeightToCreate: u32,
    BytesToAllocate: u32,
    Usage: u32,
    Pool: D3DPOOL,
    Format: D3DFORMAT,
};

pub const DXVABufferInfo = extern struct {
    pCompSurface: *c_void,
    DataOffset: u32,
    DataSize: u32,
};

pub const DXVA_SampleFormat = extern enum(i32) {
    DXVA_SampleFormatMask = 255,
    DXVA_SampleUnknown = 0,
    DXVA_SamplePreviousFrame = 1,
    DXVA_SampleProgressiveFrame = 2,
    DXVA_SampleFieldInterleavedEvenFirst = 3,
    DXVA_SampleFieldInterleavedOddFirst = 4,
    DXVA_SampleFieldSingleEven = 5,
    DXVA_SampleFieldSingleOdd = 6,
    DXVA_SampleSubStream = 7,
};
pub const DXVA_SampleFormatMask = DXVA_SampleFormat.DXVA_SampleFormatMask;
pub const DXVA_SampleUnknown = DXVA_SampleFormat.DXVA_SampleUnknown;
pub const DXVA_SamplePreviousFrame = DXVA_SampleFormat.DXVA_SamplePreviousFrame;
pub const DXVA_SampleProgressiveFrame = DXVA_SampleFormat.DXVA_SampleProgressiveFrame;
pub const DXVA_SampleFieldInterleavedEvenFirst = DXVA_SampleFormat.DXVA_SampleFieldInterleavedEvenFirst;
pub const DXVA_SampleFieldInterleavedOddFirst = DXVA_SampleFormat.DXVA_SampleFieldInterleavedOddFirst;
pub const DXVA_SampleFieldSingleEven = DXVA_SampleFormat.DXVA_SampleFieldSingleEven;
pub const DXVA_SampleFieldSingleOdd = DXVA_SampleFormat.DXVA_SampleFieldSingleOdd;
pub const DXVA_SampleSubStream = DXVA_SampleFormat.DXVA_SampleSubStream;

pub const DXVA_VideoTransferFunction = extern enum(i32) {
    DXVA_VideoTransFuncShift = 27,
    DXVA_VideoTransFuncMask = -134217728,
    DXVA_VideoTransFunc_Unknown = 0,
    DXVA_VideoTransFunc_10 = 1,
    DXVA_VideoTransFunc_18 = 2,
    DXVA_VideoTransFunc_20 = 3,
    DXVA_VideoTransFunc_22 = 4,
    DXVA_VideoTransFunc_22_709 = 5,
    DXVA_VideoTransFunc_22_240M = 6,
    DXVA_VideoTransFunc_22_8bit_sRGB = 7,
    DXVA_VideoTransFunc_28 = 8,
};
pub const DXVA_VideoTransFuncShift = DXVA_VideoTransferFunction.DXVA_VideoTransFuncShift;
pub const DXVA_VideoTransFuncMask = DXVA_VideoTransferFunction.DXVA_VideoTransFuncMask;
pub const DXVA_VideoTransFunc_Unknown = DXVA_VideoTransferFunction.DXVA_VideoTransFunc_Unknown;
pub const DXVA_VideoTransFunc_10 = DXVA_VideoTransferFunction.DXVA_VideoTransFunc_10;
pub const DXVA_VideoTransFunc_18 = DXVA_VideoTransferFunction.DXVA_VideoTransFunc_18;
pub const DXVA_VideoTransFunc_20 = DXVA_VideoTransferFunction.DXVA_VideoTransFunc_20;
pub const DXVA_VideoTransFunc_22 = DXVA_VideoTransferFunction.DXVA_VideoTransFunc_22;
pub const DXVA_VideoTransFunc_22_709 = DXVA_VideoTransferFunction.DXVA_VideoTransFunc_22_709;
pub const DXVA_VideoTransFunc_22_240M = DXVA_VideoTransferFunction.DXVA_VideoTransFunc_22_240M;
pub const DXVA_VideoTransFunc_22_8bit_sRGB = DXVA_VideoTransferFunction.DXVA_VideoTransFunc_22_8bit_sRGB;
pub const DXVA_VideoTransFunc_28 = DXVA_VideoTransferFunction.DXVA_VideoTransFunc_28;

pub const DXVA_VideoPrimaries = extern enum(i32) {
    DXVA_VideoPrimariesShift = 22,
    DXVA_VideoPrimariesMask = 130023424,
    Unknown = 0,
    reserved = 1,
    BT709 = 2,
    BT470_2_SysM = 3,
    BT470_2_SysBG = 4,
    SMPTE170M = 5,
    SMPTE240M = 6,
    EBU3213 = 7,
    SMPTE_C = 8,
};
pub const DXVA_VideoPrimariesShift = DXVA_VideoPrimaries.DXVA_VideoPrimariesShift;
pub const DXVA_VideoPrimariesMask = DXVA_VideoPrimaries.DXVA_VideoPrimariesMask;
pub const DXVA_VideoPrimaries_Unknown = DXVA_VideoPrimaries.Unknown;
pub const DXVA_VideoPrimaries_reserved = DXVA_VideoPrimaries.reserved;
pub const DXVA_VideoPrimaries_BT709 = DXVA_VideoPrimaries.BT709;
pub const DXVA_VideoPrimaries_BT470_2_SysM = DXVA_VideoPrimaries.BT470_2_SysM;
pub const DXVA_VideoPrimaries_BT470_2_SysBG = DXVA_VideoPrimaries.BT470_2_SysBG;
pub const DXVA_VideoPrimaries_SMPTE170M = DXVA_VideoPrimaries.SMPTE170M;
pub const DXVA_VideoPrimaries_SMPTE240M = DXVA_VideoPrimaries.SMPTE240M;
pub const DXVA_VideoPrimaries_EBU3213 = DXVA_VideoPrimaries.EBU3213;
pub const DXVA_VideoPrimaries_SMPTE_C = DXVA_VideoPrimaries.SMPTE_C;

pub const DXVA_VideoLighting = extern enum(i32) {
    DXVA_VideoLightingShift = 18,
    DXVA_VideoLightingMask = 3932160,
    Unknown = 0,
    bright = 1,
    office = 2,
    dim = 3,
    dark = 4,
};
pub const DXVA_VideoLightingShift = DXVA_VideoLighting.DXVA_VideoLightingShift;
pub const DXVA_VideoLightingMask = DXVA_VideoLighting.DXVA_VideoLightingMask;
pub const DXVA_VideoLighting_Unknown = DXVA_VideoLighting.Unknown;
pub const DXVA_VideoLighting_bright = DXVA_VideoLighting.bright;
pub const DXVA_VideoLighting_office = DXVA_VideoLighting.office;
pub const DXVA_VideoLighting_dim = DXVA_VideoLighting.dim;
pub const DXVA_VideoLighting_dark = DXVA_VideoLighting.dark;

pub const DXVA_VideoTransferMatrix = extern enum(i32) {
    DXVA_VideoTransferMatrixShift = 15,
    DXVA_VideoTransferMatrixMask = 229376,
    Unknown = 0,
    BT709 = 1,
    BT601 = 2,
    SMPTE240M = 3,
};
pub const DXVA_VideoTransferMatrixShift = DXVA_VideoTransferMatrix.DXVA_VideoTransferMatrixShift;
pub const DXVA_VideoTransferMatrixMask = DXVA_VideoTransferMatrix.DXVA_VideoTransferMatrixMask;
pub const DXVA_VideoTransferMatrix_Unknown = DXVA_VideoTransferMatrix.Unknown;
pub const DXVA_VideoTransferMatrix_BT709 = DXVA_VideoTransferMatrix.BT709;
pub const DXVA_VideoTransferMatrix_BT601 = DXVA_VideoTransferMatrix.BT601;
pub const DXVA_VideoTransferMatrix_SMPTE240M = DXVA_VideoTransferMatrix.SMPTE240M;

pub const DXVA_NominalRange = extern enum(i32) {
    DXVA_NominalRangeShift = 12,
    DXVA_NominalRangeMask = 28672,
    Unknown = 0,
    Normal = 1,
    Wide = 2,
    _0_255 = 1,
    _16_235 = 2,
    _48_208 = 3,
};
pub const DXVA_NominalRangeShift = DXVA_NominalRange.DXVA_NominalRangeShift;
pub const DXVA_NominalRangeMask = DXVA_NominalRange.DXVA_NominalRangeMask;
pub const DXVA_NominalRange_Unknown = DXVA_NominalRange.Unknown;
pub const DXVA_NominalRange_Normal = DXVA_NominalRange.Normal;
pub const DXVA_NominalRange_Wide = DXVA_NominalRange.Wide;
pub const DXVA_NominalRange_0_255 = DXVA_NominalRange._0_255;
pub const DXVA_NominalRange_16_235 = DXVA_NominalRange._16_235;
pub const DXVA_NominalRange_48_208 = DXVA_NominalRange._48_208;

pub const DXVA_VideoChromaSubsampling = extern enum(i32) {
    DXVA_VideoChromaSubsamplingShift = 8,
    DXVA_VideoChromaSubsamplingMask = 3840,
    Unknown = 0,
    ProgressiveChroma = 8,
    Horizontally_Cosited = 4,
    Vertically_Cosited = 2,
    Vertically_AlignedChromaPlanes = 1,
    MPEG2 = 5,
    MPEG1 = 1,
    DV_PAL = 6,
    Cosited = 7,
};
pub const DXVA_VideoChromaSubsamplingShift = DXVA_VideoChromaSubsampling.DXVA_VideoChromaSubsamplingShift;
pub const DXVA_VideoChromaSubsamplingMask = DXVA_VideoChromaSubsampling.DXVA_VideoChromaSubsamplingMask;
pub const DXVA_VideoChromaSubsampling_Unknown = DXVA_VideoChromaSubsampling.Unknown;
pub const DXVA_VideoChromaSubsampling_ProgressiveChroma = DXVA_VideoChromaSubsampling.ProgressiveChroma;
pub const DXVA_VideoChromaSubsampling_Horizontally_Cosited = DXVA_VideoChromaSubsampling.Horizontally_Cosited;
pub const DXVA_VideoChromaSubsampling_Vertically_Cosited = DXVA_VideoChromaSubsampling.Vertically_Cosited;
pub const DXVA_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = DXVA_VideoChromaSubsampling.Vertically_AlignedChromaPlanes;
pub const DXVA_VideoChromaSubsampling_MPEG2 = DXVA_VideoChromaSubsampling.MPEG2;
pub const DXVA_VideoChromaSubsampling_MPEG1 = DXVA_VideoChromaSubsampling.MPEG1;
pub const DXVA_VideoChromaSubsampling_DV_PAL = DXVA_VideoChromaSubsampling.DV_PAL;
pub const DXVA_VideoChromaSubsampling_Cosited = DXVA_VideoChromaSubsampling.Cosited;

pub const DXVA_ExtendedFormat = extern struct {
    _bitfield: u32,
};

pub const DXVA_Frequency = extern struct {
    Numerator: u32,
    Denominator: u32,
};

pub const DXVA_VideoDesc = extern struct {
    Size: u32,
    SampleWidth: u32,
    SampleHeight: u32,
    SampleFormat: u32,
    d3dFormat: D3DFORMAT,
    InputSampleFreq: DXVA_Frequency,
    OutputFrameFreq: DXVA_Frequency,
};

pub const DXVA_VideoProcessCaps = extern enum(i32) {
    DXVA_VideoProcess_None = 0,
    DXVA_VideoProcess_YUV2RGB = 1,
    DXVA_VideoProcess_StretchX = 2,
    DXVA_VideoProcess_StretchY = 4,
    DXVA_VideoProcess_AlphaBlend = 8,
    DXVA_VideoProcess_SubRects = 16,
    DXVA_VideoProcess_SubStreams = 32,
    DXVA_VideoProcess_SubStreamsExtended = 64,
    DXVA_VideoProcess_YUV2RGBExtended = 128,
    DXVA_VideoProcess_AlphaBlendExtended = 256,
};
pub const DXVA_VideoProcess_None = DXVA_VideoProcessCaps.DXVA_VideoProcess_None;
pub const DXVA_VideoProcess_YUV2RGB = DXVA_VideoProcessCaps.DXVA_VideoProcess_YUV2RGB;
pub const DXVA_VideoProcess_StretchX = DXVA_VideoProcessCaps.DXVA_VideoProcess_StretchX;
pub const DXVA_VideoProcess_StretchY = DXVA_VideoProcessCaps.DXVA_VideoProcess_StretchY;
pub const DXVA_VideoProcess_AlphaBlend = DXVA_VideoProcessCaps.DXVA_VideoProcess_AlphaBlend;
pub const DXVA_VideoProcess_SubRects = DXVA_VideoProcessCaps.DXVA_VideoProcess_SubRects;
pub const DXVA_VideoProcess_SubStreams = DXVA_VideoProcessCaps.DXVA_VideoProcess_SubStreams;
pub const DXVA_VideoProcess_SubStreamsExtended = DXVA_VideoProcessCaps.DXVA_VideoProcess_SubStreamsExtended;
pub const DXVA_VideoProcess_YUV2RGBExtended = DXVA_VideoProcessCaps.DXVA_VideoProcess_YUV2RGBExtended;
pub const DXVA_VideoProcess_AlphaBlendExtended = DXVA_VideoProcessCaps.DXVA_VideoProcess_AlphaBlendExtended;

pub const DXVA_DeinterlaceTech = extern enum(i32) {
    Unknown = 0,
    BOBLineReplicate = 1,
    BOBVerticalStretch = 2,
    BOBVerticalStretch4Tap = 256,
    MedianFiltering = 4,
    EdgeFiltering = 16,
    FieldAdaptive = 32,
    PixelAdaptive = 64,
    MotionVectorSteered = 128,
};
pub const DXVA_DeinterlaceTech_Unknown = DXVA_DeinterlaceTech.Unknown;
pub const DXVA_DeinterlaceTech_BOBLineReplicate = DXVA_DeinterlaceTech.BOBLineReplicate;
pub const DXVA_DeinterlaceTech_BOBVerticalStretch = DXVA_DeinterlaceTech.BOBVerticalStretch;
pub const DXVA_DeinterlaceTech_BOBVerticalStretch4Tap = DXVA_DeinterlaceTech.BOBVerticalStretch4Tap;
pub const DXVA_DeinterlaceTech_MedianFiltering = DXVA_DeinterlaceTech.MedianFiltering;
pub const DXVA_DeinterlaceTech_EdgeFiltering = DXVA_DeinterlaceTech.EdgeFiltering;
pub const DXVA_DeinterlaceTech_FieldAdaptive = DXVA_DeinterlaceTech.FieldAdaptive;
pub const DXVA_DeinterlaceTech_PixelAdaptive = DXVA_DeinterlaceTech.PixelAdaptive;
pub const DXVA_DeinterlaceTech_MotionVectorSteered = DXVA_DeinterlaceTech.MotionVectorSteered;

pub const DXVA_VideoSample = extern struct {
    rtStart: i64,
    rtEnd: i64,
    SampleFormat: DXVA_SampleFormat,
    lpDDSSrcSurface: *c_void,
};

pub const DXVA_SampleFlags = extern enum(i32) {
    DXVA_SampleFlagsMask = 15,
    DXVA_SampleFlag_Palette_Changed = 1,
    DXVA_SampleFlag_SrcRect_Changed = 2,
    DXVA_SampleFlag_DstRect_Changed = 4,
    DXVA_SampleFlag_ColorData_Changed = 8,
};
pub const DXVA_SampleFlagsMask = DXVA_SampleFlags.DXVA_SampleFlagsMask;
pub const DXVA_SampleFlag_Palette_Changed = DXVA_SampleFlags.DXVA_SampleFlag_Palette_Changed;
pub const DXVA_SampleFlag_SrcRect_Changed = DXVA_SampleFlags.DXVA_SampleFlag_SrcRect_Changed;
pub const DXVA_SampleFlag_DstRect_Changed = DXVA_SampleFlags.DXVA_SampleFlag_DstRect_Changed;
pub const DXVA_SampleFlag_ColorData_Changed = DXVA_SampleFlags.DXVA_SampleFlag_ColorData_Changed;

pub const DXVA_DestinationFlags = extern enum(i32) {
    DXVA_DestinationFlagMask = 15,
    DXVA_DestinationFlag_Background_Changed = 1,
    DXVA_DestinationFlag_TargetRect_Changed = 2,
    DXVA_DestinationFlag_ColorData_Changed = 4,
    DXVA_DestinationFlag_Alpha_Changed = 8,
};
pub const DXVA_DestinationFlagMask = DXVA_DestinationFlags.DXVA_DestinationFlagMask;
pub const DXVA_DestinationFlag_Background_Changed = DXVA_DestinationFlags.DXVA_DestinationFlag_Background_Changed;
pub const DXVA_DestinationFlag_TargetRect_Changed = DXVA_DestinationFlags.DXVA_DestinationFlag_TargetRect_Changed;
pub const DXVA_DestinationFlag_ColorData_Changed = DXVA_DestinationFlags.DXVA_DestinationFlag_ColorData_Changed;
pub const DXVA_DestinationFlag_Alpha_Changed = DXVA_DestinationFlags.DXVA_DestinationFlag_Alpha_Changed;

pub const DXVA_VideoSample2 = extern struct {
    rtStart: i64,
    rtEnd: i64,
    SampleFormat: u32,
    SampleFlags: u32,
    lpDDSSrcSurface: *c_void,
    rcSrc: RECT,
    rcDst: RECT,
    Palette: [16]DXVA_AYUVsample2,
};

pub const DXVA_DeinterlaceCaps = extern struct {
    Size: u32,
    NumPreviousOutputFrames: u32,
    InputPool: u32,
    NumForwardRefSamples: u32,
    NumBackwardRefSamples: u32,
    d3dOutputFormat: D3DFORMAT,
    VideoProcessingCaps: DXVA_VideoProcessCaps,
    DeinterlaceTechnology: DXVA_DeinterlaceTech,
};

pub const DXVA_DeinterlaceBlt = extern struct {
    Size: u32,
    Reserved: u32,
    rtTarget: i64,
    DstRect: RECT,
    SrcRect: RECT,
    NumSourceSurfaces: u32,
    Alpha: f32,
    Source: [32]DXVA_VideoSample,
};

pub const DXVA_DeinterlaceBltEx = extern struct {
    Size: u32,
    BackgroundColor: DXVA_AYUVsample2,
    rcTarget: RECT,
    rtTarget: i64,
    NumSourceSurfaces: u32,
    Alpha: f32,
    Source: [32]DXVA_VideoSample2,
    DestinationFormat: u32,
    DestinationFlags: u32,
};

pub const DXVA_DeinterlaceQueryAvailableModes = extern struct {
    Size: u32,
    NumGuids: u32,
    Guids: [32]Guid,
};

pub const DXVA_DeinterlaceQueryModeCaps = extern struct {
    Size: u32,
    Guid: Guid,
    VideoDesc: DXVA_VideoDesc,
};

pub const DXVA_ProcAmpControlProp = extern enum(i32) {
    DXVA_ProcAmp_None = 0,
    DXVA_ProcAmp_Brightness = 1,
    DXVA_ProcAmp_Contrast = 2,
    DXVA_ProcAmp_Hue = 4,
    DXVA_ProcAmp_Saturation = 8,
};
pub const DXVA_ProcAmp_None = DXVA_ProcAmpControlProp.DXVA_ProcAmp_None;
pub const DXVA_ProcAmp_Brightness = DXVA_ProcAmpControlProp.DXVA_ProcAmp_Brightness;
pub const DXVA_ProcAmp_Contrast = DXVA_ProcAmpControlProp.DXVA_ProcAmp_Contrast;
pub const DXVA_ProcAmp_Hue = DXVA_ProcAmpControlProp.DXVA_ProcAmp_Hue;
pub const DXVA_ProcAmp_Saturation = DXVA_ProcAmpControlProp.DXVA_ProcAmp_Saturation;

pub const DXVA_ProcAmpControlCaps = extern struct {
    Size: u32,
    InputPool: u32,
    d3dOutputFormat: D3DFORMAT,
    ProcAmpControlProps: u32,
    VideoProcessingCaps: u32,
};

pub const DXVA_ProcAmpControlQueryRange = extern struct {
    Size: u32,
    ProcAmpControlProp: DXVA_ProcAmpControlProp,
    VideoDesc: DXVA_VideoDesc,
};

pub const DXVA_VideoPropertyRange = extern struct {
    MinValue: f32,
    MaxValue: f32,
    DefaultValue: f32,
    StepSize: f32,
};

pub const DXVA_ProcAmpControlBlt = extern struct {
    Size: u32,
    DstRect: RECT,
    SrcRect: RECT,
    Alpha: f32,
    Brightness: f32,
    Contrast: f32,
    Hue: f32,
    Saturation: f32,
};

pub const DXVA_COPPSignature = extern struct {
    Signature: [256]u8,
};

pub const DXVA_COPPCommand = extern struct {
    macKDI: Guid,
    guidCommandID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    CommandData: [4056]u8,
};

pub const DXVA_COPPStatusInput = extern struct {
    rApp: Guid,
    guidStatusRequestID: Guid,
    dwSequence: u32,
    cbSizeData: u32,
    StatusData: [4056]u8,
};

pub const DXVA_COPPStatusOutput = extern struct {
    macKDI: Guid,
    cbSizeData: u32,
    COPPStatus: [4076]u8,
};

pub const DXVAHD_FRAME_FORMAT = extern enum(i32) {
    PROGRESSIVE = 0,
    INTERLACED_TOP_FIELD_FIRST = 1,
    INTERLACED_BOTTOM_FIELD_FIRST = 2,
};
pub const DXVAHD_FRAME_FORMAT_PROGRESSIVE = DXVAHD_FRAME_FORMAT.PROGRESSIVE;
pub const DXVAHD_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST = DXVAHD_FRAME_FORMAT.INTERLACED_TOP_FIELD_FIRST;
pub const DXVAHD_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST = DXVAHD_FRAME_FORMAT.INTERLACED_BOTTOM_FIELD_FIRST;

pub const DXVAHD_DEVICE_USAGE = extern enum(i32) {
    PLAYBACK_NORMAL = 0,
    OPTIMAL_SPEED = 1,
    OPTIMAL_QUALITY = 2,
};
pub const DXVAHD_DEVICE_USAGE_PLAYBACK_NORMAL = DXVAHD_DEVICE_USAGE.PLAYBACK_NORMAL;
pub const DXVAHD_DEVICE_USAGE_OPTIMAL_SPEED = DXVAHD_DEVICE_USAGE.OPTIMAL_SPEED;
pub const DXVAHD_DEVICE_USAGE_OPTIMAL_QUALITY = DXVAHD_DEVICE_USAGE.OPTIMAL_QUALITY;

pub const DXVAHD_SURFACE_TYPE = extern enum(i32) {
    VIDEO_INPUT = 0,
    VIDEO_INPUT_PRIVATE = 1,
    VIDEO_OUTPUT = 2,
};
pub const DXVAHD_SURFACE_TYPE_VIDEO_INPUT = DXVAHD_SURFACE_TYPE.VIDEO_INPUT;
pub const DXVAHD_SURFACE_TYPE_VIDEO_INPUT_PRIVATE = DXVAHD_SURFACE_TYPE.VIDEO_INPUT_PRIVATE;
pub const DXVAHD_SURFACE_TYPE_VIDEO_OUTPUT = DXVAHD_SURFACE_TYPE.VIDEO_OUTPUT;

pub const DXVAHD_DEVICE_TYPE = extern enum(i32) {
    HARDWARE = 0,
    SOFTWARE = 1,
    REFERENCE = 2,
    OTHER = 3,
};
pub const DXVAHD_DEVICE_TYPE_HARDWARE = DXVAHD_DEVICE_TYPE.HARDWARE;
pub const DXVAHD_DEVICE_TYPE_SOFTWARE = DXVAHD_DEVICE_TYPE.SOFTWARE;
pub const DXVAHD_DEVICE_TYPE_REFERENCE = DXVAHD_DEVICE_TYPE.REFERENCE;
pub const DXVAHD_DEVICE_TYPE_OTHER = DXVAHD_DEVICE_TYPE.OTHER;

pub const DXVAHD_DEVICE_CAPS = extern enum(i32) {
    LINEAR_SPACE = 1,
    xvYCC = 2,
    RGB_RANGE_CONVERSION = 4,
    YCbCr_MATRIX_CONVERSION = 8,
};
pub const DXVAHD_DEVICE_CAPS_LINEAR_SPACE = DXVAHD_DEVICE_CAPS.LINEAR_SPACE;
pub const DXVAHD_DEVICE_CAPS_xvYCC = DXVAHD_DEVICE_CAPS.xvYCC;
pub const DXVAHD_DEVICE_CAPS_RGB_RANGE_CONVERSION = DXVAHD_DEVICE_CAPS.RGB_RANGE_CONVERSION;
pub const DXVAHD_DEVICE_CAPS_YCbCr_MATRIX_CONVERSION = DXVAHD_DEVICE_CAPS.YCbCr_MATRIX_CONVERSION;

pub const DXVAHD_FEATURE_CAPS = extern enum(i32) {
    ALPHA_FILL = 1,
    CONSTRICTION = 2,
    LUMA_KEY = 4,
    ALPHA_PALETTE = 8,
};
pub const DXVAHD_FEATURE_CAPS_ALPHA_FILL = DXVAHD_FEATURE_CAPS.ALPHA_FILL;
pub const DXVAHD_FEATURE_CAPS_CONSTRICTION = DXVAHD_FEATURE_CAPS.CONSTRICTION;
pub const DXVAHD_FEATURE_CAPS_LUMA_KEY = DXVAHD_FEATURE_CAPS.LUMA_KEY;
pub const DXVAHD_FEATURE_CAPS_ALPHA_PALETTE = DXVAHD_FEATURE_CAPS.ALPHA_PALETTE;

pub const DXVAHD_FILTER_CAPS = extern enum(i32) {
    BRIGHTNESS = 1,
    CONTRAST = 2,
    HUE = 4,
    SATURATION = 8,
    NOISE_REDUCTION = 16,
    EDGE_ENHANCEMENT = 32,
    ANAMORPHIC_SCALING = 64,
};
pub const DXVAHD_FILTER_CAPS_BRIGHTNESS = DXVAHD_FILTER_CAPS.BRIGHTNESS;
pub const DXVAHD_FILTER_CAPS_CONTRAST = DXVAHD_FILTER_CAPS.CONTRAST;
pub const DXVAHD_FILTER_CAPS_HUE = DXVAHD_FILTER_CAPS.HUE;
pub const DXVAHD_FILTER_CAPS_SATURATION = DXVAHD_FILTER_CAPS.SATURATION;
pub const DXVAHD_FILTER_CAPS_NOISE_REDUCTION = DXVAHD_FILTER_CAPS.NOISE_REDUCTION;
pub const DXVAHD_FILTER_CAPS_EDGE_ENHANCEMENT = DXVAHD_FILTER_CAPS.EDGE_ENHANCEMENT;
pub const DXVAHD_FILTER_CAPS_ANAMORPHIC_SCALING = DXVAHD_FILTER_CAPS.ANAMORPHIC_SCALING;

pub const DXVAHD_INPUT_FORMAT_CAPS = extern enum(i32) {
    RGB_INTERLACED = 1,
    RGB_PROCAMP = 2,
    RGB_LUMA_KEY = 4,
    PALETTE_INTERLACED = 8,
};
pub const DXVAHD_INPUT_FORMAT_CAPS_RGB_INTERLACED = DXVAHD_INPUT_FORMAT_CAPS.RGB_INTERLACED;
pub const DXVAHD_INPUT_FORMAT_CAPS_RGB_PROCAMP = DXVAHD_INPUT_FORMAT_CAPS.RGB_PROCAMP;
pub const DXVAHD_INPUT_FORMAT_CAPS_RGB_LUMA_KEY = DXVAHD_INPUT_FORMAT_CAPS.RGB_LUMA_KEY;
pub const DXVAHD_INPUT_FORMAT_CAPS_PALETTE_INTERLACED = DXVAHD_INPUT_FORMAT_CAPS.PALETTE_INTERLACED;

pub const DXVAHD_PROCESSOR_CAPS = extern enum(i32) {
    DEINTERLACE_BLEND = 1,
    DEINTERLACE_BOB = 2,
    DEINTERLACE_ADAPTIVE = 4,
    DEINTERLACE_MOTION_COMPENSATION = 8,
    INVERSE_TELECINE = 16,
    FRAME_RATE_CONVERSION = 32,
};
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BLEND = DXVAHD_PROCESSOR_CAPS.DEINTERLACE_BLEND;
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_BOB = DXVAHD_PROCESSOR_CAPS.DEINTERLACE_BOB;
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE = DXVAHD_PROCESSOR_CAPS.DEINTERLACE_ADAPTIVE;
pub const DXVAHD_PROCESSOR_CAPS_DEINTERLACE_MOTION_COMPENSATION = DXVAHD_PROCESSOR_CAPS.DEINTERLACE_MOTION_COMPENSATION;
pub const DXVAHD_PROCESSOR_CAPS_INVERSE_TELECINE = DXVAHD_PROCESSOR_CAPS.INVERSE_TELECINE;
pub const DXVAHD_PROCESSOR_CAPS_FRAME_RATE_CONVERSION = DXVAHD_PROCESSOR_CAPS.FRAME_RATE_CONVERSION;

pub const DXVAHD_ITELECINE_CAPS = extern enum(i32) {
    _32 = 1,
    _22 = 2,
    _2224 = 4,
    _2332 = 8,
    _32322 = 16,
    _55 = 32,
    _64 = 64,
    _87 = 128,
    _222222222223 = 256,
    OTHER = -2147483648,
};
pub const DXVAHD_ITELECINE_CAPS_32 = DXVAHD_ITELECINE_CAPS._32;
pub const DXVAHD_ITELECINE_CAPS_22 = DXVAHD_ITELECINE_CAPS._22;
pub const DXVAHD_ITELECINE_CAPS_2224 = DXVAHD_ITELECINE_CAPS._2224;
pub const DXVAHD_ITELECINE_CAPS_2332 = DXVAHD_ITELECINE_CAPS._2332;
pub const DXVAHD_ITELECINE_CAPS_32322 = DXVAHD_ITELECINE_CAPS._32322;
pub const DXVAHD_ITELECINE_CAPS_55 = DXVAHD_ITELECINE_CAPS._55;
pub const DXVAHD_ITELECINE_CAPS_64 = DXVAHD_ITELECINE_CAPS._64;
pub const DXVAHD_ITELECINE_CAPS_87 = DXVAHD_ITELECINE_CAPS._87;
pub const DXVAHD_ITELECINE_CAPS_222222222223 = DXVAHD_ITELECINE_CAPS._222222222223;
pub const DXVAHD_ITELECINE_CAPS_OTHER = DXVAHD_ITELECINE_CAPS.OTHER;

pub const DXVAHD_FILTER = extern enum(i32) {
    BRIGHTNESS = 0,
    CONTRAST = 1,
    HUE = 2,
    SATURATION = 3,
    NOISE_REDUCTION = 4,
    EDGE_ENHANCEMENT = 5,
    ANAMORPHIC_SCALING = 6,
};
pub const DXVAHD_FILTER_BRIGHTNESS = DXVAHD_FILTER.BRIGHTNESS;
pub const DXVAHD_FILTER_CONTRAST = DXVAHD_FILTER.CONTRAST;
pub const DXVAHD_FILTER_HUE = DXVAHD_FILTER.HUE;
pub const DXVAHD_FILTER_SATURATION = DXVAHD_FILTER.SATURATION;
pub const DXVAHD_FILTER_NOISE_REDUCTION = DXVAHD_FILTER.NOISE_REDUCTION;
pub const DXVAHD_FILTER_EDGE_ENHANCEMENT = DXVAHD_FILTER.EDGE_ENHANCEMENT;
pub const DXVAHD_FILTER_ANAMORPHIC_SCALING = DXVAHD_FILTER.ANAMORPHIC_SCALING;

pub const DXVAHD_BLT_STATE = extern enum(i32) {
    TARGET_RECT = 0,
    BACKGROUND_COLOR = 1,
    OUTPUT_COLOR_SPACE = 2,
    ALPHA_FILL = 3,
    CONSTRICTION = 4,
    PRIVATE = 1000,
};
pub const DXVAHD_BLT_STATE_TARGET_RECT = DXVAHD_BLT_STATE.TARGET_RECT;
pub const DXVAHD_BLT_STATE_BACKGROUND_COLOR = DXVAHD_BLT_STATE.BACKGROUND_COLOR;
pub const DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE = DXVAHD_BLT_STATE.OUTPUT_COLOR_SPACE;
pub const DXVAHD_BLT_STATE_ALPHA_FILL = DXVAHD_BLT_STATE.ALPHA_FILL;
pub const DXVAHD_BLT_STATE_CONSTRICTION = DXVAHD_BLT_STATE.CONSTRICTION;
pub const DXVAHD_BLT_STATE_PRIVATE = DXVAHD_BLT_STATE.PRIVATE;

pub const DXVAHD_ALPHA_FILL_MODE = extern enum(i32) {
    OPAQUE = 0,
    BACKGROUND = 1,
    DESTINATION = 2,
    SOURCE_STREAM = 3,
};
pub const DXVAHD_ALPHA_FILL_MODE_OPAQUE = DXVAHD_ALPHA_FILL_MODE.OPAQUE;
pub const DXVAHD_ALPHA_FILL_MODE_BACKGROUND = DXVAHD_ALPHA_FILL_MODE.BACKGROUND;
pub const DXVAHD_ALPHA_FILL_MODE_DESTINATION = DXVAHD_ALPHA_FILL_MODE.DESTINATION;
pub const DXVAHD_ALPHA_FILL_MODE_SOURCE_STREAM = DXVAHD_ALPHA_FILL_MODE.SOURCE_STREAM;

pub const DXVAHD_STREAM_STATE = extern enum(i32) {
    D3DFORMAT = 0,
    FRAME_FORMAT = 1,
    INPUT_COLOR_SPACE = 2,
    OUTPUT_RATE = 3,
    SOURCE_RECT = 4,
    DESTINATION_RECT = 5,
    ALPHA = 6,
    PALETTE = 7,
    LUMA_KEY = 8,
    ASPECT_RATIO = 9,
    FILTER_BRIGHTNESS = 100,
    FILTER_CONTRAST = 101,
    FILTER_HUE = 102,
    FILTER_SATURATION = 103,
    FILTER_NOISE_REDUCTION = 104,
    FILTER_EDGE_ENHANCEMENT = 105,
    FILTER_ANAMORPHIC_SCALING = 106,
    PRIVATE = 1000,
};
pub const DXVAHD_STREAM_STATE_D3DFORMAT = DXVAHD_STREAM_STATE.D3DFORMAT;
pub const DXVAHD_STREAM_STATE_FRAME_FORMAT = DXVAHD_STREAM_STATE.FRAME_FORMAT;
pub const DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE = DXVAHD_STREAM_STATE.INPUT_COLOR_SPACE;
pub const DXVAHD_STREAM_STATE_OUTPUT_RATE = DXVAHD_STREAM_STATE.OUTPUT_RATE;
pub const DXVAHD_STREAM_STATE_SOURCE_RECT = DXVAHD_STREAM_STATE.SOURCE_RECT;
pub const DXVAHD_STREAM_STATE_DESTINATION_RECT = DXVAHD_STREAM_STATE.DESTINATION_RECT;
pub const DXVAHD_STREAM_STATE_ALPHA = DXVAHD_STREAM_STATE.ALPHA;
pub const DXVAHD_STREAM_STATE_PALETTE = DXVAHD_STREAM_STATE.PALETTE;
pub const DXVAHD_STREAM_STATE_LUMA_KEY = DXVAHD_STREAM_STATE.LUMA_KEY;
pub const DXVAHD_STREAM_STATE_ASPECT_RATIO = DXVAHD_STREAM_STATE.ASPECT_RATIO;
pub const DXVAHD_STREAM_STATE_FILTER_BRIGHTNESS = DXVAHD_STREAM_STATE.FILTER_BRIGHTNESS;
pub const DXVAHD_STREAM_STATE_FILTER_CONTRAST = DXVAHD_STREAM_STATE.FILTER_CONTRAST;
pub const DXVAHD_STREAM_STATE_FILTER_HUE = DXVAHD_STREAM_STATE.FILTER_HUE;
pub const DXVAHD_STREAM_STATE_FILTER_SATURATION = DXVAHD_STREAM_STATE.FILTER_SATURATION;
pub const DXVAHD_STREAM_STATE_FILTER_NOISE_REDUCTION = DXVAHD_STREAM_STATE.FILTER_NOISE_REDUCTION;
pub const DXVAHD_STREAM_STATE_FILTER_EDGE_ENHANCEMENT = DXVAHD_STREAM_STATE.FILTER_EDGE_ENHANCEMENT;
pub const DXVAHD_STREAM_STATE_FILTER_ANAMORPHIC_SCALING = DXVAHD_STREAM_STATE.FILTER_ANAMORPHIC_SCALING;
pub const DXVAHD_STREAM_STATE_PRIVATE = DXVAHD_STREAM_STATE.PRIVATE;

pub const DXVAHD_OUTPUT_RATE = extern enum(i32) {
    NORMAL = 0,
    HALF = 1,
    CUSTOM = 2,
};
pub const DXVAHD_OUTPUT_RATE_NORMAL = DXVAHD_OUTPUT_RATE.NORMAL;
pub const DXVAHD_OUTPUT_RATE_HALF = DXVAHD_OUTPUT_RATE.HALF;
pub const DXVAHD_OUTPUT_RATE_CUSTOM = DXVAHD_OUTPUT_RATE.CUSTOM;

pub const DXVAHD_RATIONAL = extern struct {
    Numerator: u32,
    Denominator: u32,
};

pub const DXVAHD_COLOR_RGBA = extern struct {
    R: f32,
    G: f32,
    B: f32,
    A: f32,
};

pub const DXVAHD_COLOR_YCbCrA = extern struct {
    Y: f32,
    Cb: f32,
    Cr: f32,
    A: f32,
};

pub const DXVAHD_COLOR = u32; // TODO: implement StructOrUnion types?

pub const DXVAHD_CONTENT_DESC = extern struct {
    InputFrameFormat: DXVAHD_FRAME_FORMAT,
    InputFrameRate: DXVAHD_RATIONAL,
    InputWidth: u32,
    InputHeight: u32,
    OutputFrameRate: DXVAHD_RATIONAL,
    OutputWidth: u32,
    OutputHeight: u32,
};

pub const DXVAHD_VPDEVCAPS = extern struct {
    DeviceType: DXVAHD_DEVICE_TYPE,
    DeviceCaps: u32,
    FeatureCaps: u32,
    FilterCaps: u32,
    InputFormatCaps: u32,
    InputPool: D3DPOOL,
    OutputFormatCount: u32,
    InputFormatCount: u32,
    VideoProcessorCount: u32,
    MaxInputStreams: u32,
    MaxStreamStates: u32,
};

pub const DXVAHD_VPCAPS = extern struct {
    VPGuid: Guid,
    PastFrames: u32,
    FutureFrames: u32,
    ProcessorCaps: u32,
    ITelecineCaps: u32,
    CustomRateCount: u32,
};

pub const DXVAHD_CUSTOM_RATE_DATA = extern struct {
    CustomRate: DXVAHD_RATIONAL,
    OutputFrames: u32,
    InputInterlaced: BOOL,
    InputFramesOrFields: u32,
};

pub const DXVAHD_FILTER_RANGE_DATA = extern struct {
    Minimum: i32,
    Maximum: i32,
    Default: i32,
    Multiplier: f32,
};

pub const DXVAHD_BLT_STATE_TARGET_RECT_DATA = extern struct {
    Enable: BOOL,
    TargetRect: RECT,
};

pub const DXVAHD_BLT_STATE_BACKGROUND_COLOR_DATA = extern struct {
    YCbCr: BOOL,
    BackgroundColor: DXVAHD_COLOR,
};

pub const DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA = extern struct {
    Anonymous: DXVAHD_BLT_STATE_OUTPUT_COLOR_SPACE_DATA._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DXVAHD_BLT_STATE_ALPHA_FILL_DATA = extern struct {
    Mode: DXVAHD_ALPHA_FILL_MODE,
    StreamNumber: u32,
};

pub const DXVAHD_BLT_STATE_CONSTRICTION_DATA = extern struct {
    Enable: BOOL,
    Size: SIZE,
};

pub const DXVAHD_BLT_STATE_PRIVATE_DATA = extern struct {
    Guid: Guid,
    DataSize: u32,
    pData: *c_void,
};

pub const DXVAHD_STREAM_STATE_D3DFORMAT_DATA = extern struct {
    Format: D3DFORMAT,
};

pub const DXVAHD_STREAM_STATE_FRAME_FORMAT_DATA = extern struct {
    FrameFormat: DXVAHD_FRAME_FORMAT,
};

pub const DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA = extern struct {
    Anonymous: DXVAHD_STREAM_STATE_INPUT_COLOR_SPACE_DATA._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DXVAHD_STREAM_STATE_OUTPUT_RATE_DATA = extern struct {
    RepeatFrame: BOOL,
    OutputRate: DXVAHD_OUTPUT_RATE,
    CustomRate: DXVAHD_RATIONAL,
};

pub const DXVAHD_STREAM_STATE_SOURCE_RECT_DATA = extern struct {
    Enable: BOOL,
    SourceRect: RECT,
};

pub const DXVAHD_STREAM_STATE_DESTINATION_RECT_DATA = extern struct {
    Enable: BOOL,
    DestinationRect: RECT,
};

pub const DXVAHD_STREAM_STATE_ALPHA_DATA = extern struct {
    Enable: BOOL,
    Alpha: f32,
};

pub const DXVAHD_STREAM_STATE_PALETTE_DATA = extern struct {
    Count: u32,
    pEntries: *u32,
};

pub const DXVAHD_STREAM_STATE_LUMA_KEY_DATA = extern struct {
    Enable: BOOL,
    Lower: f32,
    Upper: f32,
};

pub const DXVAHD_STREAM_STATE_ASPECT_RATIO_DATA = extern struct {
    Enable: BOOL,
    SourceAspectRatio: DXVAHD_RATIONAL,
    DestinationAspectRatio: DXVAHD_RATIONAL,
};

pub const DXVAHD_STREAM_STATE_FILTER_DATA = extern struct {
    Enable: BOOL,
    Level: i32,
};

pub const DXVAHD_STREAM_STATE_PRIVATE_DATA = extern struct {
    Guid: Guid,
    DataSize: u32,
    pData: *c_void,
};

pub const DXVAHD_STREAM_DATA = extern struct {
    Enable: BOOL,
    OutputIndex: u32,
    InputFrameOrField: u32,
    PastFrames: u32,
    FutureFrames: u32,
    ppPastSurfaces: **IDirect3DSurface9,
    pInputSurface: *IDirect3DSurface9,
    ppFutureSurfaces: **IDirect3DSurface9,
};

pub const DXVAHD_STREAM_STATE_PRIVATE_IVTC_DATA = extern struct {
    Enable: BOOL,
    ITelecineFlags: u32,
    Frames: u32,
    InputField: u32,
};

const IID_IDXVAHD_Device_Value = @import("../zig.zig").Guid.initString("95F12DFD-D77E-49BE-815F-57D579634D6D");
pub const IID_IDXVAHD_Device = &IID_IDXVAHD_Device_Value;
pub const IDXVAHD_Device = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateVideoSurface: fn(
            self: *const IDXVAHD_Device,
            Width: u32,
            Height: u32,
            Format: D3DFORMAT,
            Pool: D3DPOOL,
            Usage: u32,
            Type: DXVAHD_SURFACE_TYPE,
            NumSurfaces: u32,
            ppSurfaces: [*]*IDirect3DSurface9,
            pSharedHandle: ?*HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorDeviceCaps: fn(
            self: *const IDXVAHD_Device,
            pCaps: *DXVAHD_VPDEVCAPS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorOutputFormats: fn(
            self: *const IDXVAHD_Device,
            Count: u32,
            pFormats: [*]D3DFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorInputFormats: fn(
            self: *const IDXVAHD_Device,
            Count: u32,
            pFormats: [*]D3DFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorCaps: fn(
            self: *const IDXVAHD_Device,
            Count: u32,
            pCaps: [*]DXVAHD_VPCAPS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorCustomRates: fn(
            self: *const IDXVAHD_Device,
            pVPGuid: *const Guid,
            Count: u32,
            pRates: [*]DXVAHD_CUSTOM_RATE_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorFilterRange: fn(
            self: *const IDXVAHD_Device,
            Filter: DXVAHD_FILTER,
            pRange: *DXVAHD_FILTER_RANGE_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoProcessor: fn(
            self: *const IDXVAHD_Device,
            pVPGuid: *const Guid,
            ppVideoProcessor: **IDXVAHD_VideoProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_Device_CreateVideoSurface(self: *const T, Width: u32, Height: u32, Format: D3DFORMAT, Pool: D3DPOOL, Usage: u32, Type: DXVAHD_SURFACE_TYPE, NumSurfaces: u32, ppSurfaces: [*]*IDirect3DSurface9, pSharedHandle: ?*HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_Device.VTable, self.vtable).CreateVideoSurface(@ptrCast(*const IDXVAHD_Device, self), Width, Height, Format, Pool, Usage, Type, NumSurfaces, ppSurfaces, pSharedHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_Device_GetVideoProcessorDeviceCaps(self: *const T, pCaps: *DXVAHD_VPDEVCAPS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_Device.VTable, self.vtable).GetVideoProcessorDeviceCaps(@ptrCast(*const IDXVAHD_Device, self), pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_Device_GetVideoProcessorOutputFormats(self: *const T, Count: u32, pFormats: [*]D3DFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_Device.VTable, self.vtable).GetVideoProcessorOutputFormats(@ptrCast(*const IDXVAHD_Device, self), Count, pFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_Device_GetVideoProcessorInputFormats(self: *const T, Count: u32, pFormats: [*]D3DFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_Device.VTable, self.vtable).GetVideoProcessorInputFormats(@ptrCast(*const IDXVAHD_Device, self), Count, pFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_Device_GetVideoProcessorCaps(self: *const T, Count: u32, pCaps: [*]DXVAHD_VPCAPS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_Device.VTable, self.vtable).GetVideoProcessorCaps(@ptrCast(*const IDXVAHD_Device, self), Count, pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_Device_GetVideoProcessorCustomRates(self: *const T, pVPGuid: *const Guid, Count: u32, pRates: [*]DXVAHD_CUSTOM_RATE_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_Device.VTable, self.vtable).GetVideoProcessorCustomRates(@ptrCast(*const IDXVAHD_Device, self), pVPGuid, Count, pRates);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_Device_GetVideoProcessorFilterRange(self: *const T, Filter: DXVAHD_FILTER, pRange: *DXVAHD_FILTER_RANGE_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_Device.VTable, self.vtable).GetVideoProcessorFilterRange(@ptrCast(*const IDXVAHD_Device, self), Filter, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_Device_CreateVideoProcessor(self: *const T, pVPGuid: *const Guid, ppVideoProcessor: **IDXVAHD_VideoProcessor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_Device.VTable, self.vtable).CreateVideoProcessor(@ptrCast(*const IDXVAHD_Device, self), pVPGuid, ppVideoProcessor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDXVAHD_VideoProcessor_Value = @import("../zig.zig").Guid.initString("95F4EDF4-6E03-4CD7-BE1B-3075D665AA52");
pub const IID_IDXVAHD_VideoProcessor = &IID_IDXVAHD_VideoProcessor_Value;
pub const IDXVAHD_VideoProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetVideoProcessBltState: fn(
            self: *const IDXVAHD_VideoProcessor,
            State: DXVAHD_BLT_STATE,
            DataSize: u32,
            pData: [*]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessBltState: fn(
            self: *const IDXVAHD_VideoProcessor,
            State: DXVAHD_BLT_STATE,
            DataSize: u32,
            pData: [*]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoProcessStreamState: fn(
            self: *const IDXVAHD_VideoProcessor,
            StreamNumber: u32,
            State: DXVAHD_STREAM_STATE,
            DataSize: u32,
            pData: [*]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessStreamState: fn(
            self: *const IDXVAHD_VideoProcessor,
            StreamNumber: u32,
            State: DXVAHD_STREAM_STATE,
            DataSize: u32,
            pData: [*]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VideoProcessBltHD: fn(
            self: *const IDXVAHD_VideoProcessor,
            pOutputSurface: *IDirect3DSurface9,
            OutputFrame: u32,
            StreamCount: u32,
            pStreams: [*]const DXVAHD_STREAM_DATA,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_VideoProcessor_SetVideoProcessBltState(self: *const T, State: DXVAHD_BLT_STATE, DataSize: u32, pData: [*]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_VideoProcessor.VTable, self.vtable).SetVideoProcessBltState(@ptrCast(*const IDXVAHD_VideoProcessor, self), State, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_VideoProcessor_GetVideoProcessBltState(self: *const T, State: DXVAHD_BLT_STATE, DataSize: u32, pData: [*]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_VideoProcessor.VTable, self.vtable).GetVideoProcessBltState(@ptrCast(*const IDXVAHD_VideoProcessor, self), State, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_VideoProcessor_SetVideoProcessStreamState(self: *const T, StreamNumber: u32, State: DXVAHD_STREAM_STATE, DataSize: u32, pData: [*]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_VideoProcessor.VTable, self.vtable).SetVideoProcessStreamState(@ptrCast(*const IDXVAHD_VideoProcessor, self), StreamNumber, State, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_VideoProcessor_GetVideoProcessStreamState(self: *const T, StreamNumber: u32, State: DXVAHD_STREAM_STATE, DataSize: u32, pData: [*]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_VideoProcessor.VTable, self.vtable).GetVideoProcessStreamState(@ptrCast(*const IDXVAHD_VideoProcessor, self), StreamNumber, State, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDXVAHD_VideoProcessor_VideoProcessBltHD(self: *const T, pOutputSurface: *IDirect3DSurface9, OutputFrame: u32, StreamCount: u32, pStreams: [*]const DXVAHD_STREAM_DATA) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDXVAHD_VideoProcessor.VTable, self.vtable).VideoProcessBltHD(@ptrCast(*const IDXVAHD_VideoProcessor, self), pOutputSurface, OutputFrame, StreamCount, pStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PDXVAHDSW_CreateDevice = fn(
    pD3DDevice: *IDirect3DDevice9Ex,
    phDevice: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_ProposeVideoPrivateFormat = fn(
    hDevice: HANDLE,
    pFormat: *D3DFORMAT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_GetVideoProcessorDeviceCaps = fn(
    hDevice: HANDLE,
    pContentDesc: *const DXVAHD_CONTENT_DESC,
    Usage: DXVAHD_DEVICE_USAGE,
    pCaps: *DXVAHD_VPDEVCAPS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_GetVideoProcessorOutputFormats = fn(
    hDevice: HANDLE,
    pContentDesc: *const DXVAHD_CONTENT_DESC,
    Usage: DXVAHD_DEVICE_USAGE,
    Count: u32,
    pFormats: [*]D3DFORMAT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_GetVideoProcessorInputFormats = fn(
    hDevice: HANDLE,
    pContentDesc: *const DXVAHD_CONTENT_DESC,
    Usage: DXVAHD_DEVICE_USAGE,
    Count: u32,
    pFormats: [*]D3DFORMAT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_GetVideoProcessorCaps = fn(
    hDevice: HANDLE,
    pContentDesc: *const DXVAHD_CONTENT_DESC,
    Usage: DXVAHD_DEVICE_USAGE,
    Count: u32,
    pCaps: [*]DXVAHD_VPCAPS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_GetVideoProcessorCustomRates = fn(
    hDevice: HANDLE,
    pVPGuid: *const Guid,
    Count: u32,
    pRates: [*]DXVAHD_CUSTOM_RATE_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_GetVideoProcessorFilterRange = fn(
    hDevice: HANDLE,
    Filter: DXVAHD_FILTER,
    pRange: *DXVAHD_FILTER_RANGE_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_DestroyDevice = fn(
    hDevice: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_CreateVideoProcessor = fn(
    hDevice: HANDLE,
    pVPGuid: *const Guid,
    phVideoProcessor: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_SetVideoProcessBltState = fn(
    hVideoProcessor: HANDLE,
    State: DXVAHD_BLT_STATE,
    DataSize: u32,
    pData: [*]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_GetVideoProcessBltStatePrivate = fn(
    hVideoProcessor: HANDLE,
    pData: *DXVAHD_BLT_STATE_PRIVATE_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_SetVideoProcessStreamState = fn(
    hVideoProcessor: HANDLE,
    StreamNumber: u32,
    State: DXVAHD_STREAM_STATE,
    DataSize: u32,
    pData: [*]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_GetVideoProcessStreamStatePrivate = fn(
    hVideoProcessor: HANDLE,
    StreamNumber: u32,
    pData: *DXVAHD_STREAM_STATE_PRIVATE_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_VideoProcessBltHD = fn(
    hVideoProcessor: HANDLE,
    pOutputSurface: *IDirect3DSurface9,
    OutputFrame: u32,
    StreamCount: u32,
    pStreams: [*]const DXVAHD_STREAM_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDXVAHDSW_DestroyVideoProcessor = fn(
    hVideoProcessor: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DXVAHDSW_CALLBACKS = extern struct {
    CreateDevice: PDXVAHDSW_CreateDevice,
    ProposeVideoPrivateFormat: PDXVAHDSW_ProposeVideoPrivateFormat,
    GetVideoProcessorDeviceCaps: PDXVAHDSW_GetVideoProcessorDeviceCaps,
    GetVideoProcessorOutputFormats: PDXVAHDSW_GetVideoProcessorOutputFormats,
    GetVideoProcessorInputFormats: PDXVAHDSW_GetVideoProcessorInputFormats,
    GetVideoProcessorCaps: PDXVAHDSW_GetVideoProcessorCaps,
    GetVideoProcessorCustomRates: PDXVAHDSW_GetVideoProcessorCustomRates,
    GetVideoProcessorFilterRange: PDXVAHDSW_GetVideoProcessorFilterRange,
    DestroyDevice: PDXVAHDSW_DestroyDevice,
    CreateVideoProcessor: PDXVAHDSW_CreateVideoProcessor,
    SetVideoProcessBltState: PDXVAHDSW_SetVideoProcessBltState,
    GetVideoProcessBltStatePrivate: PDXVAHDSW_GetVideoProcessBltStatePrivate,
    SetVideoProcessStreamState: PDXVAHDSW_SetVideoProcessStreamState,
    GetVideoProcessStreamStatePrivate: PDXVAHDSW_GetVideoProcessStreamStatePrivate,
    VideoProcessBltHD: PDXVAHDSW_VideoProcessBltHD,
    DestroyVideoProcessor: PDXVAHDSW_DestroyVideoProcessor,
};

pub const PDXVAHDSW_Plugin = fn(
    Size: u32,
    pCallbacks: [*]u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DXVAHDETW_CREATEVIDEOPROCESSOR = extern struct {
    pObject: u64,
    pD3D9Ex: u64,
    VPGuid: Guid,
};

pub const DXVAHDETW_VIDEOPROCESSBLTSTATE = extern struct {
    pObject: u64,
    State: DXVAHD_BLT_STATE,
    DataSize: u32,
    SetState: BOOL,
};

pub const DXVAHDETW_VIDEOPROCESSSTREAMSTATE = extern struct {
    pObject: u64,
    StreamNumber: u32,
    State: DXVAHD_STREAM_STATE,
    DataSize: u32,
    SetState: BOOL,
};

pub const DXVAHDETW_VIDEOPROCESSBLTHD = extern struct {
    pObject: u64,
    pOutputSurface: u64,
    TargetRect: RECT,
    OutputFormat: D3DFORMAT,
    ColorSpace: u32,
    OutputFrame: u32,
    StreamCount: u32,
    Enter: BOOL,
};

pub const DXVAHDETW_VIDEOPROCESSBLTHD_STREAM = extern struct {
    pObject: u64,
    pInputSurface: u64,
    SourceRect: RECT,
    DestinationRect: RECT,
    InputFormat: D3DFORMAT,
    FrameFormat: DXVAHD_FRAME_FORMAT,
    ColorSpace: u32,
    StreamNumber: u32,
    OutputIndex: u32,
    InputFrameOrField: u32,
    PastFrames: u32,
    FutureFrames: u32,
};

pub const DXVAHDETW_DESTROYVIDEOPROCESSOR = extern struct {
    pObject: u64,
};

pub const PDXVAHD_CreateDevice = fn(
    pD3DDevice: *IDirect3DDevice9Ex,
    pContentDesc: *const DXVAHD_CONTENT_DESC,
    Usage: DXVAHD_DEVICE_USAGE,
    pPlugin: ?PDXVAHDSW_Plugin,
    ppDevice: **IDXVAHD_Device,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DXVA2_ExtendedFormat = extern struct {
    Anonymous: DXVA2_ExtendedFormat._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DXVA2_SampleFormat = extern enum(i32) {
    DXVA2_SampleFormatMask = 255,
    DXVA2_SampleUnknown = 0,
    DXVA2_SampleProgressiveFrame = 2,
    DXVA2_SampleFieldInterleavedEvenFirst = 3,
    DXVA2_SampleFieldInterleavedOddFirst = 4,
    DXVA2_SampleFieldSingleEven = 5,
    DXVA2_SampleFieldSingleOdd = 6,
    DXVA2_SampleSubStream = 7,
};
pub const DXVA2_SampleFormatMask = DXVA2_SampleFormat.DXVA2_SampleFormatMask;
pub const DXVA2_SampleUnknown = DXVA2_SampleFormat.DXVA2_SampleUnknown;
pub const DXVA2_SampleProgressiveFrame = DXVA2_SampleFormat.DXVA2_SampleProgressiveFrame;
pub const DXVA2_SampleFieldInterleavedEvenFirst = DXVA2_SampleFormat.DXVA2_SampleFieldInterleavedEvenFirst;
pub const DXVA2_SampleFieldInterleavedOddFirst = DXVA2_SampleFormat.DXVA2_SampleFieldInterleavedOddFirst;
pub const DXVA2_SampleFieldSingleEven = DXVA2_SampleFormat.DXVA2_SampleFieldSingleEven;
pub const DXVA2_SampleFieldSingleOdd = DXVA2_SampleFormat.DXVA2_SampleFieldSingleOdd;
pub const DXVA2_SampleSubStream = DXVA2_SampleFormat.DXVA2_SampleSubStream;

pub const DXVA2_VideoChromaSubSampling = extern enum(i32) {
    DXVA2_VideoChromaSubsamplingMask = 15,
    DXVA2_VideoChromaSubsampling_Unknown = 0,
    DXVA2_VideoChromaSubsampling_ProgressiveChroma = 8,
    DXVA2_VideoChromaSubsampling_Horizontally_Cosited = 4,
    DXVA2_VideoChromaSubsampling_Vertically_Cosited = 2,
    DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = 1,
    DXVA2_VideoChromaSubsampling_MPEG2 = 5,
    DXVA2_VideoChromaSubsampling_MPEG1 = 1,
    DXVA2_VideoChromaSubsampling_DV_PAL = 6,
    DXVA2_VideoChromaSubsampling_Cosited = 7,
};
pub const DXVA2_VideoChromaSubsamplingMask = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsamplingMask;
pub const DXVA2_VideoChromaSubsampling_Unknown = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsampling_Unknown;
pub const DXVA2_VideoChromaSubsampling_ProgressiveChroma = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsampling_ProgressiveChroma;
pub const DXVA2_VideoChromaSubsampling_Horizontally_Cosited = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsampling_Horizontally_Cosited;
pub const DXVA2_VideoChromaSubsampling_Vertically_Cosited = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsampling_Vertically_Cosited;
pub const DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsampling_Vertically_AlignedChromaPlanes;
pub const DXVA2_VideoChromaSubsampling_MPEG2 = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsampling_MPEG2;
pub const DXVA2_VideoChromaSubsampling_MPEG1 = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsampling_MPEG1;
pub const DXVA2_VideoChromaSubsampling_DV_PAL = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsampling_DV_PAL;
pub const DXVA2_VideoChromaSubsampling_Cosited = DXVA2_VideoChromaSubSampling.DXVA2_VideoChromaSubsampling_Cosited;

pub const DXVA2_NominalRange = extern enum(i32) {
    DXVA2_NominalRangeMask = 7,
    Unknown = 0,
    Normal = 1,
    Wide = 2,
    _0_255 = 1,
    _16_235 = 2,
    _48_208 = 3,
};
pub const DXVA2_NominalRangeMask = DXVA2_NominalRange.DXVA2_NominalRangeMask;
pub const DXVA2_NominalRange_Unknown = DXVA2_NominalRange.Unknown;
pub const DXVA2_NominalRange_Normal = DXVA2_NominalRange.Normal;
pub const DXVA2_NominalRange_Wide = DXVA2_NominalRange.Wide;
pub const DXVA2_NominalRange_0_255 = DXVA2_NominalRange._0_255;
pub const DXVA2_NominalRange_16_235 = DXVA2_NominalRange._16_235;
pub const DXVA2_NominalRange_48_208 = DXVA2_NominalRange._48_208;

pub const DXVA2_VideoTransferMatrix = extern enum(i32) {
    DXVA2_VideoTransferMatrixMask = 7,
    Unknown = 0,
    BT709 = 1,
    BT601 = 2,
    SMPTE240M = 3,
};
pub const DXVA2_VideoTransferMatrixMask = DXVA2_VideoTransferMatrix.DXVA2_VideoTransferMatrixMask;
pub const DXVA2_VideoTransferMatrix_Unknown = DXVA2_VideoTransferMatrix.Unknown;
pub const DXVA2_VideoTransferMatrix_BT709 = DXVA2_VideoTransferMatrix.BT709;
pub const DXVA2_VideoTransferMatrix_BT601 = DXVA2_VideoTransferMatrix.BT601;
pub const DXVA2_VideoTransferMatrix_SMPTE240M = DXVA2_VideoTransferMatrix.SMPTE240M;

pub const DXVA2_VideoLighting = extern enum(i32) {
    DXVA2_VideoLightingMask = 15,
    Unknown = 0,
    bright = 1,
    office = 2,
    dim = 3,
    dark = 4,
};
pub const DXVA2_VideoLightingMask = DXVA2_VideoLighting.DXVA2_VideoLightingMask;
pub const DXVA2_VideoLighting_Unknown = DXVA2_VideoLighting.Unknown;
pub const DXVA2_VideoLighting_bright = DXVA2_VideoLighting.bright;
pub const DXVA2_VideoLighting_office = DXVA2_VideoLighting.office;
pub const DXVA2_VideoLighting_dim = DXVA2_VideoLighting.dim;
pub const DXVA2_VideoLighting_dark = DXVA2_VideoLighting.dark;

pub const DXVA2_VideoPrimaries = extern enum(i32) {
    DXVA2_VideoPrimariesMask = 31,
    Unknown = 0,
    reserved = 1,
    BT709 = 2,
    BT470_2_SysM = 3,
    BT470_2_SysBG = 4,
    SMPTE170M = 5,
    SMPTE240M = 6,
    EBU3213 = 7,
    SMPTE_C = 8,
};
pub const DXVA2_VideoPrimariesMask = DXVA2_VideoPrimaries.DXVA2_VideoPrimariesMask;
pub const DXVA2_VideoPrimaries_Unknown = DXVA2_VideoPrimaries.Unknown;
pub const DXVA2_VideoPrimaries_reserved = DXVA2_VideoPrimaries.reserved;
pub const DXVA2_VideoPrimaries_BT709 = DXVA2_VideoPrimaries.BT709;
pub const DXVA2_VideoPrimaries_BT470_2_SysM = DXVA2_VideoPrimaries.BT470_2_SysM;
pub const DXVA2_VideoPrimaries_BT470_2_SysBG = DXVA2_VideoPrimaries.BT470_2_SysBG;
pub const DXVA2_VideoPrimaries_SMPTE170M = DXVA2_VideoPrimaries.SMPTE170M;
pub const DXVA2_VideoPrimaries_SMPTE240M = DXVA2_VideoPrimaries.SMPTE240M;
pub const DXVA2_VideoPrimaries_EBU3213 = DXVA2_VideoPrimaries.EBU3213;
pub const DXVA2_VideoPrimaries_SMPTE_C = DXVA2_VideoPrimaries.SMPTE_C;

pub const DXVA2_VideoTransferFunction = extern enum(i32) {
    DXVA2_VideoTransFuncMask = 31,
    DXVA2_VideoTransFunc_Unknown = 0,
    DXVA2_VideoTransFunc_10 = 1,
    DXVA2_VideoTransFunc_18 = 2,
    DXVA2_VideoTransFunc_20 = 3,
    DXVA2_VideoTransFunc_22 = 4,
    DXVA2_VideoTransFunc_709 = 5,
    DXVA2_VideoTransFunc_240M = 6,
    DXVA2_VideoTransFunc_sRGB = 7,
    DXVA2_VideoTransFunc_28 = 8,
};
pub const DXVA2_VideoTransFuncMask = DXVA2_VideoTransferFunction.DXVA2_VideoTransFuncMask;
pub const DXVA2_VideoTransFunc_Unknown = DXVA2_VideoTransferFunction.DXVA2_VideoTransFunc_Unknown;
pub const DXVA2_VideoTransFunc_10 = DXVA2_VideoTransferFunction.DXVA2_VideoTransFunc_10;
pub const DXVA2_VideoTransFunc_18 = DXVA2_VideoTransferFunction.DXVA2_VideoTransFunc_18;
pub const DXVA2_VideoTransFunc_20 = DXVA2_VideoTransferFunction.DXVA2_VideoTransFunc_20;
pub const DXVA2_VideoTransFunc_22 = DXVA2_VideoTransferFunction.DXVA2_VideoTransFunc_22;
pub const DXVA2_VideoTransFunc_709 = DXVA2_VideoTransferFunction.DXVA2_VideoTransFunc_709;
pub const DXVA2_VideoTransFunc_240M = DXVA2_VideoTransferFunction.DXVA2_VideoTransFunc_240M;
pub const DXVA2_VideoTransFunc_sRGB = DXVA2_VideoTransferFunction.DXVA2_VideoTransFunc_sRGB;
pub const DXVA2_VideoTransFunc_28 = DXVA2_VideoTransferFunction.DXVA2_VideoTransFunc_28;

pub const DXVA2_Frequency = extern struct {
    Numerator: u32,
    Denominator: u32,
};

pub const DXVA2_VideoDesc = extern struct {
    SampleWidth: u32,
    SampleHeight: u32,
    SampleFormat: DXVA2_ExtendedFormat,
    Format: D3DFORMAT,
    InputSampleFreq: DXVA2_Frequency,
    OutputFrameFreq: DXVA2_Frequency,
    UABProtectionLevel: u32,
    Reserved: u32,
};

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0003 = extern enum(i32) {
    DXVA2_DeinterlaceTech_Unknown = 0,
    DXVA2_DeinterlaceTech_BOBLineReplicate = 1,
    DXVA2_DeinterlaceTech_BOBVerticalStretch = 2,
    DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap = 4,
    DXVA2_DeinterlaceTech_MedianFiltering = 8,
    DXVA2_DeinterlaceTech_EdgeFiltering = 16,
    DXVA2_DeinterlaceTech_FieldAdaptive = 32,
    DXVA2_DeinterlaceTech_PixelAdaptive = 64,
    DXVA2_DeinterlaceTech_MotionVectorSteered = 128,
    DXVA2_DeinterlaceTech_InverseTelecine = 256,
    DXVA2_DeinterlaceTech_Mask = 511,
};
pub const DXVA2_DeinterlaceTech_Unknown = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_Unknown;
pub const DXVA2_DeinterlaceTech_BOBLineReplicate = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_BOBLineReplicate;
pub const DXVA2_DeinterlaceTech_BOBVerticalStretch = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_BOBVerticalStretch;
pub const DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_BOBVerticalStretch4Tap;
pub const DXVA2_DeinterlaceTech_MedianFiltering = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_MedianFiltering;
pub const DXVA2_DeinterlaceTech_EdgeFiltering = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_EdgeFiltering;
pub const DXVA2_DeinterlaceTech_FieldAdaptive = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_FieldAdaptive;
pub const DXVA2_DeinterlaceTech_PixelAdaptive = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_PixelAdaptive;
pub const DXVA2_DeinterlaceTech_MotionVectorSteered = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_MotionVectorSteered;
pub const DXVA2_DeinterlaceTech_InverseTelecine = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_InverseTelecine;
pub const DXVA2_DeinterlaceTech_Mask = __MIDL___MIDL_itf_dxva2api_0000_0000_0003.DXVA2_DeinterlaceTech_Mask;

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0004 = extern enum(i32) {
    DXVA2_NoiseFilterLumaLevel = 1,
    DXVA2_NoiseFilterLumaThreshold = 2,
    DXVA2_NoiseFilterLumaRadius = 3,
    DXVA2_NoiseFilterChromaLevel = 4,
    DXVA2_NoiseFilterChromaThreshold = 5,
    DXVA2_NoiseFilterChromaRadius = 6,
    DXVA2_DetailFilterLumaLevel = 7,
    DXVA2_DetailFilterLumaThreshold = 8,
    DXVA2_DetailFilterLumaRadius = 9,
    DXVA2_DetailFilterChromaLevel = 10,
    DXVA2_DetailFilterChromaThreshold = 11,
    DXVA2_DetailFilterChromaRadius = 12,
};
pub const DXVA2_NoiseFilterLumaLevel = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_NoiseFilterLumaLevel;
pub const DXVA2_NoiseFilterLumaThreshold = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_NoiseFilterLumaThreshold;
pub const DXVA2_NoiseFilterLumaRadius = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_NoiseFilterLumaRadius;
pub const DXVA2_NoiseFilterChromaLevel = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_NoiseFilterChromaLevel;
pub const DXVA2_NoiseFilterChromaThreshold = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_NoiseFilterChromaThreshold;
pub const DXVA2_NoiseFilterChromaRadius = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_NoiseFilterChromaRadius;
pub const DXVA2_DetailFilterLumaLevel = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_DetailFilterLumaLevel;
pub const DXVA2_DetailFilterLumaThreshold = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_DetailFilterLumaThreshold;
pub const DXVA2_DetailFilterLumaRadius = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_DetailFilterLumaRadius;
pub const DXVA2_DetailFilterChromaLevel = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_DetailFilterChromaLevel;
pub const DXVA2_DetailFilterChromaThreshold = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_DetailFilterChromaThreshold;
pub const DXVA2_DetailFilterChromaRadius = __MIDL___MIDL_itf_dxva2api_0000_0000_0004.DXVA2_DetailFilterChromaRadius;

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0005 = extern enum(i32) {
    DXVA2_NoiseFilterTech_Unsupported = 0,
    DXVA2_NoiseFilterTech_Unknown = 1,
    DXVA2_NoiseFilterTech_Median = 2,
    DXVA2_NoiseFilterTech_Temporal = 4,
    DXVA2_NoiseFilterTech_BlockNoise = 8,
    DXVA2_NoiseFilterTech_MosquitoNoise = 16,
    DXVA2_NoiseFilterTech_Mask = 31,
};
pub const DXVA2_NoiseFilterTech_Unsupported = __MIDL___MIDL_itf_dxva2api_0000_0000_0005.DXVA2_NoiseFilterTech_Unsupported;
pub const DXVA2_NoiseFilterTech_Unknown = __MIDL___MIDL_itf_dxva2api_0000_0000_0005.DXVA2_NoiseFilterTech_Unknown;
pub const DXVA2_NoiseFilterTech_Median = __MIDL___MIDL_itf_dxva2api_0000_0000_0005.DXVA2_NoiseFilterTech_Median;
pub const DXVA2_NoiseFilterTech_Temporal = __MIDL___MIDL_itf_dxva2api_0000_0000_0005.DXVA2_NoiseFilterTech_Temporal;
pub const DXVA2_NoiseFilterTech_BlockNoise = __MIDL___MIDL_itf_dxva2api_0000_0000_0005.DXVA2_NoiseFilterTech_BlockNoise;
pub const DXVA2_NoiseFilterTech_MosquitoNoise = __MIDL___MIDL_itf_dxva2api_0000_0000_0005.DXVA2_NoiseFilterTech_MosquitoNoise;
pub const DXVA2_NoiseFilterTech_Mask = __MIDL___MIDL_itf_dxva2api_0000_0000_0005.DXVA2_NoiseFilterTech_Mask;

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0006 = extern enum(i32) {
    DXVA2_DetailFilterTech_Unsupported = 0,
    DXVA2_DetailFilterTech_Unknown = 1,
    DXVA2_DetailFilterTech_Edge = 2,
    DXVA2_DetailFilterTech_Sharpening = 4,
    DXVA2_DetailFilterTech_Mask = 7,
};
pub const DXVA2_DetailFilterTech_Unsupported = __MIDL___MIDL_itf_dxva2api_0000_0000_0006.DXVA2_DetailFilterTech_Unsupported;
pub const DXVA2_DetailFilterTech_Unknown = __MIDL___MIDL_itf_dxva2api_0000_0000_0006.DXVA2_DetailFilterTech_Unknown;
pub const DXVA2_DetailFilterTech_Edge = __MIDL___MIDL_itf_dxva2api_0000_0000_0006.DXVA2_DetailFilterTech_Edge;
pub const DXVA2_DetailFilterTech_Sharpening = __MIDL___MIDL_itf_dxva2api_0000_0000_0006.DXVA2_DetailFilterTech_Sharpening;
pub const DXVA2_DetailFilterTech_Mask = __MIDL___MIDL_itf_dxva2api_0000_0000_0006.DXVA2_DetailFilterTech_Mask;

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0007 = extern enum(i32) {
    DXVA2_ProcAmp_None = 0,
    DXVA2_ProcAmp_Brightness = 1,
    DXVA2_ProcAmp_Contrast = 2,
    DXVA2_ProcAmp_Hue = 4,
    DXVA2_ProcAmp_Saturation = 8,
    DXVA2_ProcAmp_Mask = 15,
};
pub const DXVA2_ProcAmp_None = __MIDL___MIDL_itf_dxva2api_0000_0000_0007.DXVA2_ProcAmp_None;
pub const DXVA2_ProcAmp_Brightness = __MIDL___MIDL_itf_dxva2api_0000_0000_0007.DXVA2_ProcAmp_Brightness;
pub const DXVA2_ProcAmp_Contrast = __MIDL___MIDL_itf_dxva2api_0000_0000_0007.DXVA2_ProcAmp_Contrast;
pub const DXVA2_ProcAmp_Hue = __MIDL___MIDL_itf_dxva2api_0000_0000_0007.DXVA2_ProcAmp_Hue;
pub const DXVA2_ProcAmp_Saturation = __MIDL___MIDL_itf_dxva2api_0000_0000_0007.DXVA2_ProcAmp_Saturation;
pub const DXVA2_ProcAmp_Mask = __MIDL___MIDL_itf_dxva2api_0000_0000_0007.DXVA2_ProcAmp_Mask;

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0008 = extern enum(i32) {
    DXVA2_VideoProcess_None = 0,
    DXVA2_VideoProcess_YUV2RGB = 1,
    DXVA2_VideoProcess_StretchX = 2,
    DXVA2_VideoProcess_StretchY = 4,
    DXVA2_VideoProcess_AlphaBlend = 8,
    DXVA2_VideoProcess_SubRects = 16,
    DXVA2_VideoProcess_SubStreams = 32,
    DXVA2_VideoProcess_SubStreamsExtended = 64,
    DXVA2_VideoProcess_YUV2RGBExtended = 128,
    DXVA2_VideoProcess_AlphaBlendExtended = 256,
    DXVA2_VideoProcess_Constriction = 512,
    DXVA2_VideoProcess_NoiseFilter = 1024,
    DXVA2_VideoProcess_DetailFilter = 2048,
    DXVA2_VideoProcess_PlanarAlpha = 4096,
    DXVA2_VideoProcess_LinearScaling = 8192,
    DXVA2_VideoProcess_GammaCompensated = 16384,
    DXVA2_VideoProcess_MaintainsOriginalFieldData = 32768,
    DXVA2_VideoProcess_Mask = 65535,
};
pub const DXVA2_VideoProcess_None = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_None;
pub const DXVA2_VideoProcess_YUV2RGB = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_YUV2RGB;
pub const DXVA2_VideoProcess_StretchX = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_StretchX;
pub const DXVA2_VideoProcess_StretchY = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_StretchY;
pub const DXVA2_VideoProcess_AlphaBlend = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_AlphaBlend;
pub const DXVA2_VideoProcess_SubRects = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_SubRects;
pub const DXVA2_VideoProcess_SubStreams = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_SubStreams;
pub const DXVA2_VideoProcess_SubStreamsExtended = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_SubStreamsExtended;
pub const DXVA2_VideoProcess_YUV2RGBExtended = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_YUV2RGBExtended;
pub const DXVA2_VideoProcess_AlphaBlendExtended = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_AlphaBlendExtended;
pub const DXVA2_VideoProcess_Constriction = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_Constriction;
pub const DXVA2_VideoProcess_NoiseFilter = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_NoiseFilter;
pub const DXVA2_VideoProcess_DetailFilter = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_DetailFilter;
pub const DXVA2_VideoProcess_PlanarAlpha = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_PlanarAlpha;
pub const DXVA2_VideoProcess_LinearScaling = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_LinearScaling;
pub const DXVA2_VideoProcess_GammaCompensated = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_GammaCompensated;
pub const DXVA2_VideoProcess_MaintainsOriginalFieldData = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_MaintainsOriginalFieldData;
pub const DXVA2_VideoProcess_Mask = __MIDL___MIDL_itf_dxva2api_0000_0000_0008.DXVA2_VideoProcess_Mask;

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0009 = extern enum(i32) {
    DXVA2_VPDev_HardwareDevice = 1,
    DXVA2_VPDev_EmulatedDXVA1 = 2,
    DXVA2_VPDev_SoftwareDevice = 4,
    DXVA2_VPDev_Mask = 7,
};
pub const DXVA2_VPDev_HardwareDevice = __MIDL___MIDL_itf_dxva2api_0000_0000_0009.DXVA2_VPDev_HardwareDevice;
pub const DXVA2_VPDev_EmulatedDXVA1 = __MIDL___MIDL_itf_dxva2api_0000_0000_0009.DXVA2_VPDev_EmulatedDXVA1;
pub const DXVA2_VPDev_SoftwareDevice = __MIDL___MIDL_itf_dxva2api_0000_0000_0009.DXVA2_VPDev_SoftwareDevice;
pub const DXVA2_VPDev_Mask = __MIDL___MIDL_itf_dxva2api_0000_0000_0009.DXVA2_VPDev_Mask;

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0010 = extern enum(i32) {
    DXVA2_SampleData_RFF = 1,
    DXVA2_SampleData_TFF = 2,
    DXVA2_SampleData_RFF_TFF_Present = 4,
    DXVA2_SampleData_Mask = 65535,
};
pub const DXVA2_SampleData_RFF = __MIDL___MIDL_itf_dxva2api_0000_0000_0010.DXVA2_SampleData_RFF;
pub const DXVA2_SampleData_TFF = __MIDL___MIDL_itf_dxva2api_0000_0000_0010.DXVA2_SampleData_TFF;
pub const DXVA2_SampleData_RFF_TFF_Present = __MIDL___MIDL_itf_dxva2api_0000_0000_0010.DXVA2_SampleData_RFF_TFF_Present;
pub const DXVA2_SampleData_Mask = __MIDL___MIDL_itf_dxva2api_0000_0000_0010.DXVA2_SampleData_Mask;

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0011 = extern enum(i32) {
    DXVA2_DestData_RFF = 1,
    DXVA2_DestData_TFF = 2,
    DXVA2_DestData_RFF_TFF_Present = 4,
    DXVA2_DestData_Mask = 65535,
};
pub const DXVA2_DestData_RFF = __MIDL___MIDL_itf_dxva2api_0000_0000_0011.DXVA2_DestData_RFF;
pub const DXVA2_DestData_TFF = __MIDL___MIDL_itf_dxva2api_0000_0000_0011.DXVA2_DestData_TFF;
pub const DXVA2_DestData_RFF_TFF_Present = __MIDL___MIDL_itf_dxva2api_0000_0000_0011.DXVA2_DestData_RFF_TFF_Present;
pub const DXVA2_DestData_Mask = __MIDL___MIDL_itf_dxva2api_0000_0000_0011.DXVA2_DestData_Mask;

pub const DXVA2_VideoProcessorCaps = extern struct {
    DeviceCaps: u32,
    InputPool: D3DPOOL,
    NumForwardRefSamples: u32,
    NumBackwardRefSamples: u32,
    Reserved: u32,
    DeinterlaceTechnology: u32,
    ProcAmpControlCaps: u32,
    VideoProcessorOperations: u32,
    NoiseFilterTechnology: u32,
    DetailFilterTechnology: u32,
};

pub const DXVA2_Fixed32 = extern struct {
    Anonymous: DXVA2_Fixed32._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DXVA2_AYUVSample8 = extern struct {
    Cr: u8,
    Cb: u8,
    Y: u8,
    Alpha: u8,
};

pub const DXVA2_AYUVSample16 = extern struct {
    Cr: u16,
    Cb: u16,
    Y: u16,
    Alpha: u16,
};

pub const DXVA2_VideoSample = extern struct {
    Start: i64,
    End: i64,
    SampleFormat: DXVA2_ExtendedFormat,
    SrcSurface: *IDirect3DSurface9,
    SrcRect: RECT,
    DstRect: RECT,
    Pal: [16]DXVA2_AYUVSample8,
    PlanarAlpha: DXVA2_Fixed32,
    SampleData: u32,
};

pub const DXVA2_ValueRange = extern struct {
    MinValue: DXVA2_Fixed32,
    MaxValue: DXVA2_Fixed32,
    DefaultValue: DXVA2_Fixed32,
    StepSize: DXVA2_Fixed32,
};

pub const DXVA2_ProcAmpValues = extern struct {
    Brightness: DXVA2_Fixed32,
    Contrast: DXVA2_Fixed32,
    Hue: DXVA2_Fixed32,
    Saturation: DXVA2_Fixed32,
};

pub const DXVA2_FilterValues = extern struct {
    Level: DXVA2_Fixed32,
    Threshold: DXVA2_Fixed32,
    Radius: DXVA2_Fixed32,
};

pub const DXVA2_VideoProcessBltParams = extern struct {
    TargetFrame: i64,
    TargetRect: RECT,
    ConstrictionSize: SIZE,
    StreamingFlags: u32,
    BackgroundColor: DXVA2_AYUVSample16,
    DestFormat: DXVA2_ExtendedFormat,
    ProcAmpValues: DXVA2_ProcAmpValues,
    Alpha: DXVA2_Fixed32,
    NoiseFilterLuma: DXVA2_FilterValues,
    NoiseFilterChroma: DXVA2_FilterValues,
    DetailFilterLuma: DXVA2_FilterValues,
    DetailFilterChroma: DXVA2_FilterValues,
    DestData: u32,
};

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0012 = extern enum(i32) {
    DXVA2_PictureParametersBufferType = 0,
    DXVA2_MacroBlockControlBufferType = 1,
    DXVA2_ResidualDifferenceBufferType = 2,
    DXVA2_DeblockingControlBufferType = 3,
    DXVA2_InverseQuantizationMatrixBufferType = 4,
    DXVA2_SliceControlBufferType = 5,
    DXVA2_BitStreamDateBufferType = 6,
    DXVA2_MotionVectorBuffer = 7,
    DXVA2_FilmGrainBuffer = 8,
};
pub const DXVA2_PictureParametersBufferType = __MIDL___MIDL_itf_dxva2api_0000_0000_0012.DXVA2_PictureParametersBufferType;
pub const DXVA2_MacroBlockControlBufferType = __MIDL___MIDL_itf_dxva2api_0000_0000_0012.DXVA2_MacroBlockControlBufferType;
pub const DXVA2_ResidualDifferenceBufferType = __MIDL___MIDL_itf_dxva2api_0000_0000_0012.DXVA2_ResidualDifferenceBufferType;
pub const DXVA2_DeblockingControlBufferType = __MIDL___MIDL_itf_dxva2api_0000_0000_0012.DXVA2_DeblockingControlBufferType;
pub const DXVA2_InverseQuantizationMatrixBufferType = __MIDL___MIDL_itf_dxva2api_0000_0000_0012.DXVA2_InverseQuantizationMatrixBufferType;
pub const DXVA2_SliceControlBufferType = __MIDL___MIDL_itf_dxva2api_0000_0000_0012.DXVA2_SliceControlBufferType;
pub const DXVA2_BitStreamDateBufferType = __MIDL___MIDL_itf_dxva2api_0000_0000_0012.DXVA2_BitStreamDateBufferType;
pub const DXVA2_MotionVectorBuffer = __MIDL___MIDL_itf_dxva2api_0000_0000_0012.DXVA2_MotionVectorBuffer;
pub const DXVA2_FilmGrainBuffer = __MIDL___MIDL_itf_dxva2api_0000_0000_0012.DXVA2_FilmGrainBuffer;

pub const __MIDL___MIDL_itf_dxva2api_0000_0000_0013 = extern enum(i32) {
    DXVA2_VideoDecoderRenderTarget = 0,
    DXVA2_VideoProcessorRenderTarget = 1,
    DXVA2_VideoSoftwareRenderTarget = 2,
};
pub const DXVA2_VideoDecoderRenderTarget = __MIDL___MIDL_itf_dxva2api_0000_0000_0013.DXVA2_VideoDecoderRenderTarget;
pub const DXVA2_VideoProcessorRenderTarget = __MIDL___MIDL_itf_dxva2api_0000_0000_0013.DXVA2_VideoProcessorRenderTarget;
pub const DXVA2_VideoSoftwareRenderTarget = __MIDL___MIDL_itf_dxva2api_0000_0000_0013.DXVA2_VideoSoftwareRenderTarget;

pub const DXVA2_ConfigPictureDecode = extern struct {
    guidConfigBitstreamEncryption: Guid,
    guidConfigMBcontrolEncryption: Guid,
    guidConfigResidDiffEncryption: Guid,
    ConfigBitstreamRaw: u32,
    ConfigMBcontrolRasterOrder: u32,
    ConfigResidDiffHost: u32,
    ConfigSpatialResid8: u32,
    ConfigResid8Subtraction: u32,
    ConfigSpatialHost8or9Clipping: u32,
    ConfigSpatialResidInterleaved: u32,
    ConfigIntraResidUnsigned: u32,
    ConfigResidDiffAccelerator: u32,
    ConfigHostInverseScan: u32,
    ConfigSpecificIDCT: u32,
    Config4GroupedCoefs: u32,
    ConfigMinRenderTargetBuffCount: u16,
    ConfigDecoderSpecific: u16,
};

pub const DXVA2_DecodeBufferDesc = extern struct {
    CompressedBufferType: u32,
    BufferIndex: u32,
    DataOffset: u32,
    DataSize: u32,
    FirstMBaddress: u32,
    NumMBsInBuffer: u32,
    Width: u32,
    Height: u32,
    Stride: u32,
    ReservedBits: u32,
    pvPVPState: *c_void,
};

pub const DXVA2_AES_CTR_IV = extern struct {
    IV: u64,
    Count: u64,
};

pub const DXVA2_DecodeExtensionData = extern struct {
    Function: u32,
    pPrivateInputData: *c_void,
    PrivateInputDataSize: u32,
    pPrivateOutputData: *c_void,
    PrivateOutputDataSize: u32,
};

pub const DXVA2_DecodeExecuteParams = extern struct {
    NumCompBuffers: u32,
    pCompressedBuffers: *DXVA2_DecodeBufferDesc,
    pExtensionData: *DXVA2_DecodeExtensionData,
};

const IID_IDirect3DDeviceManager9_Value = @import("../zig.zig").Guid.initString("A0CADE0F-06D5-4CF4-A1C7-F3CDD725AA75");
pub const IID_IDirect3DDeviceManager9 = &IID_IDirect3DDeviceManager9_Value;
pub const IDirect3DDeviceManager9 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResetDevice: fn(
            self: *const IDirect3DDeviceManager9,
            pDevice: *IDirect3DDevice9,
            resetToken: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDeviceHandle: fn(
            self: *const IDirect3DDeviceManager9,
            phDevice: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDeviceHandle: fn(
            self: *const IDirect3DDeviceManager9,
            hDevice: HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestDevice: fn(
            self: *const IDirect3DDeviceManager9,
            hDevice: HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockDevice: fn(
            self: *const IDirect3DDeviceManager9,
            hDevice: HANDLE,
            ppDevice: **IDirect3DDevice9,
            fBlock: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockDevice: fn(
            self: *const IDirect3DDeviceManager9,
            hDevice: HANDLE,
            fSaveState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoService: fn(
            self: *const IDirect3DDeviceManager9,
            hDevice: HANDLE,
            riid: *const Guid,
            ppService: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDeviceManager9_ResetDevice(self: *const T, pDevice: *IDirect3DDevice9, resetToken: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDeviceManager9.VTable, self.vtable).ResetDevice(@ptrCast(*const IDirect3DDeviceManager9, self), pDevice, resetToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDeviceManager9_OpenDeviceHandle(self: *const T, phDevice: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDeviceManager9.VTable, self.vtable).OpenDeviceHandle(@ptrCast(*const IDirect3DDeviceManager9, self), phDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDeviceManager9_CloseDeviceHandle(self: *const T, hDevice: HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDeviceManager9.VTable, self.vtable).CloseDeviceHandle(@ptrCast(*const IDirect3DDeviceManager9, self), hDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDeviceManager9_TestDevice(self: *const T, hDevice: HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDeviceManager9.VTable, self.vtable).TestDevice(@ptrCast(*const IDirect3DDeviceManager9, self), hDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDeviceManager9_LockDevice(self: *const T, hDevice: HANDLE, ppDevice: **IDirect3DDevice9, fBlock: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDeviceManager9.VTable, self.vtable).LockDevice(@ptrCast(*const IDirect3DDeviceManager9, self), hDevice, ppDevice, fBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDeviceManager9_UnlockDevice(self: *const T, hDevice: HANDLE, fSaveState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDeviceManager9.VTable, self.vtable).UnlockDevice(@ptrCast(*const IDirect3DDeviceManager9, self), hDevice, fSaveState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirect3DDeviceManager9_GetVideoService(self: *const T, hDevice: HANDLE, riid: *const Guid, ppService: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirect3DDeviceManager9.VTable, self.vtable).GetVideoService(@ptrCast(*const IDirect3DDeviceManager9, self), hDevice, riid, ppService);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectXVideoAccelerationService_Value = @import("../zig.zig").Guid.initString("FC51A550-D5E7-11D9-AF55-00054E43FF02");
pub const IID_IDirectXVideoAccelerationService = &IID_IDirectXVideoAccelerationService_Value;
pub const IDirectXVideoAccelerationService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSurface: fn(
            self: *const IDirectXVideoAccelerationService,
            Width: u32,
            Height: u32,
            BackBuffers: u32,
            Format: D3DFORMAT,
            Pool: D3DPOOL,
            Usage: u32,
            DxvaType: u32,
            ppSurface: **IDirect3DSurface9,
            pSharedHandle: ?*HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoAccelerationService_CreateSurface(self: *const T, Width: u32, Height: u32, BackBuffers: u32, Format: D3DFORMAT, Pool: D3DPOOL, Usage: u32, DxvaType: u32, ppSurface: **IDirect3DSurface9, pSharedHandle: ?*HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoAccelerationService.VTable, self.vtable).CreateSurface(@ptrCast(*const IDirectXVideoAccelerationService, self), Width, Height, BackBuffers, Format, Pool, Usage, DxvaType, ppSurface, pSharedHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectXVideoDecoderService_Value = @import("../zig.zig").Guid.initString("FC51A551-D5E7-11D9-AF55-00054E43FF02");
pub const IID_IDirectXVideoDecoderService = &IID_IDirectXVideoDecoderService_Value;
pub const IDirectXVideoDecoderService = extern struct {
    pub const VTable = extern struct {
        base: IDirectXVideoAccelerationService.VTable,
        GetDecoderDeviceGuids: fn(
            self: *const IDirectXVideoDecoderService,
            pCount: *u32,
            pGuids: ?*?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDecoderRenderTargets: fn(
            self: *const IDirectXVideoDecoderService,
            Guid: *const Guid,
            pCount: *u32,
            pFormats: ?*?*D3DFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDecoderConfigurations: fn(
            self: *const IDirectXVideoDecoderService,
            Guid: *const Guid,
            pVideoDesc: *const DXVA2_VideoDesc,
            pReserved: *c_void,
            pCount: *u32,
            ppConfigs: ?*?*DXVA2_ConfigPictureDecode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoDecoder: fn(
            self: *const IDirectXVideoDecoderService,
            Guid: *const Guid,
            pVideoDesc: *const DXVA2_VideoDesc,
            pConfig: *const DXVA2_ConfigPictureDecode,
            ppDecoderRenderTargets: [*]*IDirect3DSurface9,
            NumRenderTargets: u32,
            ppDecode: **IDirectXVideoDecoder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDirectXVideoAccelerationService.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoderService_GetDecoderDeviceGuids(self: *const T, pCount: *u32, pGuids: ?*?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoderService.VTable, self.vtable).GetDecoderDeviceGuids(@ptrCast(*const IDirectXVideoDecoderService, self), pCount, pGuids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoderService_GetDecoderRenderTargets(self: *const T, Guid: *const Guid, pCount: *u32, pFormats: ?*?*D3DFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoderService.VTable, self.vtable).GetDecoderRenderTargets(@ptrCast(*const IDirectXVideoDecoderService, self), Guid, pCount, pFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoderService_GetDecoderConfigurations(self: *const T, Guid: *const Guid, pVideoDesc: *const DXVA2_VideoDesc, pReserved: *c_void, pCount: *u32, ppConfigs: ?*?*DXVA2_ConfigPictureDecode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoderService.VTable, self.vtable).GetDecoderConfigurations(@ptrCast(*const IDirectXVideoDecoderService, self), Guid, pVideoDesc, pReserved, pCount, ppConfigs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoderService_CreateVideoDecoder(self: *const T, Guid: *const Guid, pVideoDesc: *const DXVA2_VideoDesc, pConfig: *const DXVA2_ConfigPictureDecode, ppDecoderRenderTargets: [*]*IDirect3DSurface9, NumRenderTargets: u32, ppDecode: **IDirectXVideoDecoder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoderService.VTable, self.vtable).CreateVideoDecoder(@ptrCast(*const IDirectXVideoDecoderService, self), Guid, pVideoDesc, pConfig, ppDecoderRenderTargets, NumRenderTargets, ppDecode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectXVideoProcessorService_Value = @import("../zig.zig").Guid.initString("FC51A552-D5E7-11D9-AF55-00054E43FF02");
pub const IID_IDirectXVideoProcessorService = &IID_IDirectXVideoProcessorService_Value;
pub const IDirectXVideoProcessorService = extern struct {
    pub const VTable = extern struct {
        base: IDirectXVideoAccelerationService.VTable,
        RegisterVideoProcessorSoftwareDevice: fn(
            self: *const IDirectXVideoProcessorService,
            pCallbacks: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorDeviceGuids: fn(
            self: *const IDirectXVideoProcessorService,
            pVideoDesc: *const DXVA2_VideoDesc,
            pCount: *u32,
            pGuids: ?*?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorRenderTargets: fn(
            self: *const IDirectXVideoProcessorService,
            VideoProcDeviceGuid: *const Guid,
            pVideoDesc: *const DXVA2_VideoDesc,
            pCount: *u32,
            pFormats: ?*?*D3DFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorSubStreamFormats: fn(
            self: *const IDirectXVideoProcessorService,
            VideoProcDeviceGuid: *const Guid,
            pVideoDesc: *const DXVA2_VideoDesc,
            RenderTargetFormat: D3DFORMAT,
            pCount: *u32,
            pFormats: ?*?*D3DFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorCaps: fn(
            self: *const IDirectXVideoProcessorService,
            VideoProcDeviceGuid: *const Guid,
            pVideoDesc: *const DXVA2_VideoDesc,
            RenderTargetFormat: D3DFORMAT,
            pCaps: *DXVA2_VideoProcessorCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcAmpRange: fn(
            self: *const IDirectXVideoProcessorService,
            VideoProcDeviceGuid: *const Guid,
            pVideoDesc: *const DXVA2_VideoDesc,
            RenderTargetFormat: D3DFORMAT,
            ProcAmpCap: u32,
            pRange: *DXVA2_ValueRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterPropertyRange: fn(
            self: *const IDirectXVideoProcessorService,
            VideoProcDeviceGuid: *const Guid,
            pVideoDesc: *const DXVA2_VideoDesc,
            RenderTargetFormat: D3DFORMAT,
            FilterSetting: u32,
            pRange: *DXVA2_ValueRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoProcessor: fn(
            self: *const IDirectXVideoProcessorService,
            VideoProcDeviceGuid: *const Guid,
            pVideoDesc: *const DXVA2_VideoDesc,
            RenderTargetFormat: D3DFORMAT,
            MaxNumSubStreams: u32,
            ppVidProcess: **IDirectXVideoProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDirectXVideoAccelerationService.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessorService_RegisterVideoProcessorSoftwareDevice(self: *const T, pCallbacks: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessorService.VTable, self.vtable).RegisterVideoProcessorSoftwareDevice(@ptrCast(*const IDirectXVideoProcessorService, self), pCallbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessorService_GetVideoProcessorDeviceGuids(self: *const T, pVideoDesc: *const DXVA2_VideoDesc, pCount: *u32, pGuids: ?*?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessorService.VTable, self.vtable).GetVideoProcessorDeviceGuids(@ptrCast(*const IDirectXVideoProcessorService, self), pVideoDesc, pCount, pGuids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessorService_GetVideoProcessorRenderTargets(self: *const T, VideoProcDeviceGuid: *const Guid, pVideoDesc: *const DXVA2_VideoDesc, pCount: *u32, pFormats: ?*?*D3DFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessorService.VTable, self.vtable).GetVideoProcessorRenderTargets(@ptrCast(*const IDirectXVideoProcessorService, self), VideoProcDeviceGuid, pVideoDesc, pCount, pFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessorService_GetVideoProcessorSubStreamFormats(self: *const T, VideoProcDeviceGuid: *const Guid, pVideoDesc: *const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, pCount: *u32, pFormats: ?*?*D3DFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessorService.VTable, self.vtable).GetVideoProcessorSubStreamFormats(@ptrCast(*const IDirectXVideoProcessorService, self), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, pCount, pFormats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessorService_GetVideoProcessorCaps(self: *const T, VideoProcDeviceGuid: *const Guid, pVideoDesc: *const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, pCaps: *DXVA2_VideoProcessorCaps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessorService.VTable, self.vtable).GetVideoProcessorCaps(@ptrCast(*const IDirectXVideoProcessorService, self), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessorService_GetProcAmpRange(self: *const T, VideoProcDeviceGuid: *const Guid, pVideoDesc: *const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, ProcAmpCap: u32, pRange: *DXVA2_ValueRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessorService.VTable, self.vtable).GetProcAmpRange(@ptrCast(*const IDirectXVideoProcessorService, self), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, ProcAmpCap, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessorService_GetFilterPropertyRange(self: *const T, VideoProcDeviceGuid: *const Guid, pVideoDesc: *const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, FilterSetting: u32, pRange: *DXVA2_ValueRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessorService.VTable, self.vtable).GetFilterPropertyRange(@ptrCast(*const IDirectXVideoProcessorService, self), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, FilterSetting, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessorService_CreateVideoProcessor(self: *const T, VideoProcDeviceGuid: *const Guid, pVideoDesc: *const DXVA2_VideoDesc, RenderTargetFormat: D3DFORMAT, MaxNumSubStreams: u32, ppVidProcess: **IDirectXVideoProcessor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessorService.VTable, self.vtable).CreateVideoProcessor(@ptrCast(*const IDirectXVideoProcessorService, self), VideoProcDeviceGuid, pVideoDesc, RenderTargetFormat, MaxNumSubStreams, ppVidProcess);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectXVideoDecoder_Value = @import("../zig.zig").Guid.initString("F2B0810A-FD00-43C9-918C-DF94E2D8EF7D");
pub const IID_IDirectXVideoDecoder = &IID_IDirectXVideoDecoder_Value;
pub const IDirectXVideoDecoder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVideoDecoderService: fn(
            self: *const IDirectXVideoDecoder,
            ppService: **IDirectXVideoDecoderService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCreationParameters: fn(
            self: *const IDirectXVideoDecoder,
            pDeviceGuid: ?*Guid,
            pVideoDesc: ?*DXVA2_VideoDesc,
            pConfig: ?*DXVA2_ConfigPictureDecode,
            pDecoderRenderTargets: [*]**IDirect3DSurface9,
            pNumSurfaces: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffer: fn(
            self: *const IDirectXVideoDecoder,
            BufferType: u32,
            ppBuffer: **c_void,
            pBufferSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseBuffer: fn(
            self: *const IDirectXVideoDecoder,
            BufferType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginFrame: fn(
            self: *const IDirectXVideoDecoder,
            pRenderTarget: *IDirect3DSurface9,
            pvPVPData: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndFrame: fn(
            self: *const IDirectXVideoDecoder,
            pHandleComplete: ?*HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDirectXVideoDecoder,
            pExecuteParams: *const DXVA2_DecodeExecuteParams,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoder_GetVideoDecoderService(self: *const T, ppService: **IDirectXVideoDecoderService) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoder.VTable, self.vtable).GetVideoDecoderService(@ptrCast(*const IDirectXVideoDecoder, self), ppService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoder_GetCreationParameters(self: *const T, pDeviceGuid: ?*Guid, pVideoDesc: ?*DXVA2_VideoDesc, pConfig: ?*DXVA2_ConfigPictureDecode, pDecoderRenderTargets: [*]**IDirect3DSurface9, pNumSurfaces: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoder.VTable, self.vtable).GetCreationParameters(@ptrCast(*const IDirectXVideoDecoder, self), pDeviceGuid, pVideoDesc, pConfig, pDecoderRenderTargets, pNumSurfaces);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoder_GetBuffer(self: *const T, BufferType: u32, ppBuffer: **c_void, pBufferSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoder.VTable, self.vtable).GetBuffer(@ptrCast(*const IDirectXVideoDecoder, self), BufferType, ppBuffer, pBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoder_ReleaseBuffer(self: *const T, BufferType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoder.VTable, self.vtable).ReleaseBuffer(@ptrCast(*const IDirectXVideoDecoder, self), BufferType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoder_BeginFrame(self: *const T, pRenderTarget: *IDirect3DSurface9, pvPVPData: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoder.VTable, self.vtable).BeginFrame(@ptrCast(*const IDirectXVideoDecoder, self), pRenderTarget, pvPVPData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoder_EndFrame(self: *const T, pHandleComplete: ?*HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoder.VTable, self.vtable).EndFrame(@ptrCast(*const IDirectXVideoDecoder, self), pHandleComplete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoDecoder_Execute(self: *const T, pExecuteParams: *const DXVA2_DecodeExecuteParams) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoDecoder.VTable, self.vtable).Execute(@ptrCast(*const IDirectXVideoDecoder, self), pExecuteParams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDirectXVideoProcessor_Value = @import("../zig.zig").Guid.initString("8C3A39F0-916E-4690-804F-4C8001355D25");
pub const IID_IDirectXVideoProcessor = &IID_IDirectXVideoProcessor_Value;
pub const IDirectXVideoProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVideoProcessorService: fn(
            self: *const IDirectXVideoProcessor,
            ppService: **IDirectXVideoProcessorService,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCreationParameters: fn(
            self: *const IDirectXVideoProcessor,
            pDeviceGuid: ?*Guid,
            pVideoDesc: ?*DXVA2_VideoDesc,
            pRenderTargetFormat: ?*D3DFORMAT,
            pMaxNumSubStreams: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorCaps: fn(
            self: *const IDirectXVideoProcessor,
            pCaps: *DXVA2_VideoProcessorCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcAmpRange: fn(
            self: *const IDirectXVideoProcessor,
            ProcAmpCap: u32,
            pRange: *DXVA2_ValueRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilterPropertyRange: fn(
            self: *const IDirectXVideoProcessor,
            FilterSetting: u32,
            pRange: *DXVA2_ValueRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VideoProcessBlt: fn(
            self: *const IDirectXVideoProcessor,
            pRenderTarget: *IDirect3DSurface9,
            pBltParams: *const DXVA2_VideoProcessBltParams,
            pSamples: [*]const DXVA2_VideoSample,
            NumSamples: u32,
            pHandleComplete: ?*HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessor_GetVideoProcessorService(self: *const T, ppService: **IDirectXVideoProcessorService) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessor.VTable, self.vtable).GetVideoProcessorService(@ptrCast(*const IDirectXVideoProcessor, self), ppService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessor_GetCreationParameters(self: *const T, pDeviceGuid: ?*Guid, pVideoDesc: ?*DXVA2_VideoDesc, pRenderTargetFormat: ?*D3DFORMAT, pMaxNumSubStreams: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessor.VTable, self.vtable).GetCreationParameters(@ptrCast(*const IDirectXVideoProcessor, self), pDeviceGuid, pVideoDesc, pRenderTargetFormat, pMaxNumSubStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessor_GetVideoProcessorCaps(self: *const T, pCaps: *DXVA2_VideoProcessorCaps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessor.VTable, self.vtable).GetVideoProcessorCaps(@ptrCast(*const IDirectXVideoProcessor, self), pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessor_GetProcAmpRange(self: *const T, ProcAmpCap: u32, pRange: *DXVA2_ValueRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessor.VTable, self.vtable).GetProcAmpRange(@ptrCast(*const IDirectXVideoProcessor, self), ProcAmpCap, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessor_GetFilterPropertyRange(self: *const T, FilterSetting: u32, pRange: *DXVA2_ValueRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessor.VTable, self.vtable).GetFilterPropertyRange(@ptrCast(*const IDirectXVideoProcessor, self), FilterSetting, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoProcessor_VideoProcessBlt(self: *const T, pRenderTarget: *IDirect3DSurface9, pBltParams: *const DXVA2_VideoProcessBltParams, pSamples: [*]const DXVA2_VideoSample, NumSamples: u32, pHandleComplete: ?*HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoProcessor.VTable, self.vtable).VideoProcessBlt(@ptrCast(*const IDirectXVideoProcessor, self), pRenderTarget, pBltParams, pSamples, NumSamples, pHandleComplete);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DXVA2_SurfaceType = extern enum(i32) {
    DecoderRenderTarget = 0,
    ProcessorRenderTarget = 1,
    D3DRenderTargetTexture = 2,
};
pub const DXVA2_SurfaceType_DecoderRenderTarget = DXVA2_SurfaceType.DecoderRenderTarget;
pub const DXVA2_SurfaceType_ProcessorRenderTarget = DXVA2_SurfaceType.ProcessorRenderTarget;
pub const DXVA2_SurfaceType_D3DRenderTargetTexture = DXVA2_SurfaceType.D3DRenderTargetTexture;

const IID_IDirectXVideoMemoryConfiguration_Value = @import("../zig.zig").Guid.initString("B7F916DD-DB3B-49C1-84D7-E45EF99EC726");
pub const IID_IDirectXVideoMemoryConfiguration = &IID_IDirectXVideoMemoryConfiguration_Value;
pub const IDirectXVideoMemoryConfiguration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableSurfaceTypeByIndex: fn(
            self: *const IDirectXVideoMemoryConfiguration,
            dwTypeIndex: u32,
            pdwType: *DXVA2_SurfaceType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSurfaceType: fn(
            self: *const IDirectXVideoMemoryConfiguration,
            dwType: DXVA2_SurfaceType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoMemoryConfiguration_GetAvailableSurfaceTypeByIndex(self: *const T, dwTypeIndex: u32, pdwType: *DXVA2_SurfaceType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoMemoryConfiguration.VTable, self.vtable).GetAvailableSurfaceTypeByIndex(@ptrCast(*const IDirectXVideoMemoryConfiguration, self), dwTypeIndex, pdwType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDirectXVideoMemoryConfiguration_SetSurfaceType(self: *const T, dwType: DXVA2_SurfaceType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDirectXVideoMemoryConfiguration.VTable, self.vtable).SetSurfaceType(@ptrCast(*const IDirectXVideoMemoryConfiguration, self), dwType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_opmapi_0000_0000_0001 = extern enum(i32) {
    OPM_OMAC_SIZE = 16,
    OPM_128_BIT_RANDOM_NUMBER_SIZE = 16,
    OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE = 256,
    OPM_CONFIGURE_SETTING_DATA_SIZE = 4056,
    OPM_GET_INFORMATION_PARAMETERS_SIZE = 4056,
    OPM_REQUESTED_INFORMATION_SIZE = 4076,
    OPM_HDCP_KEY_SELECTION_VECTOR_SIZE = 5,
    OPM_PROTECTION_TYPE_SIZE = 4,
    OPM_BUS_TYPE_MASK = 65535,
    OPM_BUS_IMPLEMENTATION_MODIFIER_MASK = 32767,
};
pub const OPM_OMAC_SIZE = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_OMAC_SIZE;
pub const OPM_128_BIT_RANDOM_NUMBER_SIZE = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_128_BIT_RANDOM_NUMBER_SIZE;
pub const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE;
pub const OPM_CONFIGURE_SETTING_DATA_SIZE = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_CONFIGURE_SETTING_DATA_SIZE;
pub const OPM_GET_INFORMATION_PARAMETERS_SIZE = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_GET_INFORMATION_PARAMETERS_SIZE;
pub const OPM_REQUESTED_INFORMATION_SIZE = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_REQUESTED_INFORMATION_SIZE;
pub const OPM_HDCP_KEY_SELECTION_VECTOR_SIZE = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_HDCP_KEY_SELECTION_VECTOR_SIZE;
pub const OPM_PROTECTION_TYPE_SIZE = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_PROTECTION_TYPE_SIZE;
pub const OPM_BUS_TYPE_MASK = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_BUS_TYPE_MASK;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_MASK = __MIDL___MIDL_itf_opmapi_0000_0000_0001.OPM_BUS_IMPLEMENTATION_MODIFIER_MASK;

pub const OPM_VIDEO_OUTPUT_SEMANTICS = extern enum(i32) {
    OPM_VOS_COPP_SEMANTICS = 0,
    OPM_VOS_OPM_SEMANTICS = 1,
    OPM_VOS_OPM_INDIRECT_DISPLAY = 2,
};
pub const OPM_VOS_COPP_SEMANTICS = OPM_VIDEO_OUTPUT_SEMANTICS.OPM_VOS_COPP_SEMANTICS;
pub const OPM_VOS_OPM_SEMANTICS = OPM_VIDEO_OUTPUT_SEMANTICS.OPM_VOS_OPM_SEMANTICS;
pub const OPM_VOS_OPM_INDIRECT_DISPLAY = OPM_VIDEO_OUTPUT_SEMANTICS.OPM_VOS_OPM_INDIRECT_DISPLAY;

pub const __MIDL___MIDL_itf_opmapi_0000_0000_0002 = extern enum(i32) {
    OPM_HDCP_FLAG_NONE = 0,
    OPM_HDCP_FLAG_REPEATER = 1,
};
pub const OPM_HDCP_FLAG_NONE = __MIDL___MIDL_itf_opmapi_0000_0000_0002.OPM_HDCP_FLAG_NONE;
pub const OPM_HDCP_FLAG_REPEATER = __MIDL___MIDL_itf_opmapi_0000_0000_0002.OPM_HDCP_FLAG_REPEATER;

pub const __MIDL___MIDL_itf_opmapi_0000_0000_0003 = extern enum(i32) {
    OPM_STATUS_NORMAL = 0,
    OPM_STATUS_LINK_LOST = 1,
    OPM_STATUS_RENEGOTIATION_REQUIRED = 2,
    OPM_STATUS_TAMPERING_DETECTED = 4,
    OPM_STATUS_REVOKED_HDCP_DEVICE_ATTACHED = 8,
};
pub const OPM_STATUS_NORMAL = __MIDL___MIDL_itf_opmapi_0000_0000_0003.OPM_STATUS_NORMAL;
pub const OPM_STATUS_LINK_LOST = __MIDL___MIDL_itf_opmapi_0000_0000_0003.OPM_STATUS_LINK_LOST;
pub const OPM_STATUS_RENEGOTIATION_REQUIRED = __MIDL___MIDL_itf_opmapi_0000_0000_0003.OPM_STATUS_RENEGOTIATION_REQUIRED;
pub const OPM_STATUS_TAMPERING_DETECTED = __MIDL___MIDL_itf_opmapi_0000_0000_0003.OPM_STATUS_TAMPERING_DETECTED;
pub const OPM_STATUS_REVOKED_HDCP_DEVICE_ATTACHED = __MIDL___MIDL_itf_opmapi_0000_0000_0003.OPM_STATUS_REVOKED_HDCP_DEVICE_ATTACHED;

pub const __MIDL___MIDL_itf_opmapi_0000_0000_0004 = extern enum(i32) {
    OPM_CONNECTOR_TYPE_OTHER = -1,
    OPM_CONNECTOR_TYPE_VGA = 0,
    OPM_CONNECTOR_TYPE_SVIDEO = 1,
    OPM_CONNECTOR_TYPE_COMPOSITE_VIDEO = 2,
    OPM_CONNECTOR_TYPE_COMPONENT_VIDEO = 3,
    OPM_CONNECTOR_TYPE_DVI = 4,
    OPM_CONNECTOR_TYPE_HDMI = 5,
    OPM_CONNECTOR_TYPE_LVDS = 6,
    OPM_CONNECTOR_TYPE_D_JPN = 8,
    OPM_CONNECTOR_TYPE_SDI = 9,
    OPM_CONNECTOR_TYPE_DISPLAYPORT_EXTERNAL = 10,
    OPM_CONNECTOR_TYPE_DISPLAYPORT_EMBEDDED = 11,
    OPM_CONNECTOR_TYPE_UDI_EXTERNAL = 12,
    OPM_CONNECTOR_TYPE_UDI_EMBEDDED = 13,
    OPM_CONNECTOR_TYPE_RESERVED = 14,
    OPM_CONNECTOR_TYPE_MIRACAST = 15,
    OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A = 16,
    OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B = 17,
    OPM_COPP_COMPATIBLE_CONNECTOR_TYPE_INTERNAL = -2147483648,
};
pub const OPM_CONNECTOR_TYPE_OTHER = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_OTHER;
pub const OPM_CONNECTOR_TYPE_VGA = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_VGA;
pub const OPM_CONNECTOR_TYPE_SVIDEO = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_SVIDEO;
pub const OPM_CONNECTOR_TYPE_COMPOSITE_VIDEO = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_COMPOSITE_VIDEO;
pub const OPM_CONNECTOR_TYPE_COMPONENT_VIDEO = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_COMPONENT_VIDEO;
pub const OPM_CONNECTOR_TYPE_DVI = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_DVI;
pub const OPM_CONNECTOR_TYPE_HDMI = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_HDMI;
pub const OPM_CONNECTOR_TYPE_LVDS = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_LVDS;
pub const OPM_CONNECTOR_TYPE_D_JPN = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_D_JPN;
pub const OPM_CONNECTOR_TYPE_SDI = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_SDI;
pub const OPM_CONNECTOR_TYPE_DISPLAYPORT_EXTERNAL = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_DISPLAYPORT_EXTERNAL;
pub const OPM_CONNECTOR_TYPE_DISPLAYPORT_EMBEDDED = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_DISPLAYPORT_EMBEDDED;
pub const OPM_CONNECTOR_TYPE_UDI_EXTERNAL = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_UDI_EXTERNAL;
pub const OPM_CONNECTOR_TYPE_UDI_EMBEDDED = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_UDI_EMBEDDED;
pub const OPM_CONNECTOR_TYPE_RESERVED = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_RESERVED;
pub const OPM_CONNECTOR_TYPE_MIRACAST = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_MIRACAST;
pub const OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_A;
pub const OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_CONNECTOR_TYPE_TRANSPORT_AGNOSTIC_DIGITAL_MODE_B;
pub const OPM_COPP_COMPATIBLE_CONNECTOR_TYPE_INTERNAL = __MIDL___MIDL_itf_opmapi_0000_0000_0004.OPM_COPP_COMPATIBLE_CONNECTOR_TYPE_INTERNAL;

pub const __MIDL___MIDL_itf_opmapi_0000_0000_0005 = extern enum(i32) {
    OPM_DVI_CHARACTERISTIC_1_0 = 1,
    OPM_DVI_CHARACTERISTIC_1_1_OR_ABOVE = 2,
};
pub const OPM_DVI_CHARACTERISTIC_1_0 = __MIDL___MIDL_itf_opmapi_0000_0000_0005.OPM_DVI_CHARACTERISTIC_1_0;
pub const OPM_DVI_CHARACTERISTIC_1_1_OR_ABOVE = __MIDL___MIDL_itf_opmapi_0000_0000_0005.OPM_DVI_CHARACTERISTIC_1_1_OR_ABOVE;

pub const OPM_OUTPUT_HARDWARE_PROTECTION = extern enum(i32) {
    NOT_SUPPORTED = 0,
    SUPPORTED = 1,
};
pub const OPM_OUTPUT_HARDWARE_PROTECTION_NOT_SUPPORTED = OPM_OUTPUT_HARDWARE_PROTECTION.NOT_SUPPORTED;
pub const OPM_OUTPUT_HARDWARE_PROTECTION_SUPPORTED = OPM_OUTPUT_HARDWARE_PROTECTION.SUPPORTED;

pub const __MIDL___MIDL_itf_opmapi_0000_0000_0006 = extern enum(i32) {
    OPM_BUS_TYPE_OTHER = 0,
    OPM_BUS_TYPE_PCI = 1,
    OPM_BUS_TYPE_PCIX = 2,
    OPM_BUS_TYPE_PCIEXPRESS = 3,
    OPM_BUS_TYPE_AGP = 4,
    OPM_BUS_IMPLEMENTATION_MODIFIER_INSIDE_OF_CHIPSET = 65536,
    OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP = 131072,
    OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = 196608,
    OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR = 262144,
    OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = 327680,
    OPM_BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD = -2147483648,
    OPM_COPP_COMPATIBLE_BUS_TYPE_INTEGRATED = -2147483648,
};
pub const OPM_BUS_TYPE_OTHER = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_TYPE_OTHER;
pub const OPM_BUS_TYPE_PCI = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_TYPE_PCI;
pub const OPM_BUS_TYPE_PCIX = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_TYPE_PCIX;
pub const OPM_BUS_TYPE_PCIEXPRESS = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_TYPE_PCIEXPRESS;
pub const OPM_BUS_TYPE_AGP = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_TYPE_AGP;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_INSIDE_OF_CHIPSET = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_IMPLEMENTATION_MODIFIER_INSIDE_OF_CHIPSET;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_IMPLEMENTATION_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_IMPLEMENTATION_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE;
pub const OPM_BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_BUS_IMPLEMENTATION_MODIFIER_NON_STANDARD;
pub const OPM_COPP_COMPATIBLE_BUS_TYPE_INTEGRATED = __MIDL___MIDL_itf_opmapi_0000_0000_0006.OPM_COPP_COMPATIBLE_BUS_TYPE_INTEGRATED;

pub const OPM_DPCP_PROTECTION_LEVEL = extern enum(i32) {
    OPM_DPCP_OFF = 0,
    OPM_DPCP_ON = 1,
    OPM_DPCP_FORCE_ULONG = 2147483647,
};
pub const OPM_DPCP_OFF = OPM_DPCP_PROTECTION_LEVEL.OPM_DPCP_OFF;
pub const OPM_DPCP_ON = OPM_DPCP_PROTECTION_LEVEL.OPM_DPCP_ON;
pub const OPM_DPCP_FORCE_ULONG = OPM_DPCP_PROTECTION_LEVEL.OPM_DPCP_FORCE_ULONG;

pub const OPM_HDCP_PROTECTION_LEVEL = extern enum(i32) {
    OPM_HDCP_OFF = 0,
    OPM_HDCP_ON = 1,
    OPM_HDCP_FORCE_ULONG = 2147483647,
};
pub const OPM_HDCP_OFF = OPM_HDCP_PROTECTION_LEVEL.OPM_HDCP_OFF;
pub const OPM_HDCP_ON = OPM_HDCP_PROTECTION_LEVEL.OPM_HDCP_ON;
pub const OPM_HDCP_FORCE_ULONG = OPM_HDCP_PROTECTION_LEVEL.OPM_HDCP_FORCE_ULONG;

pub const OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL = extern enum(i32) {
    OPM_TYPE_ENFORCEMENT_HDCP_OFF = 0,
    OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_NO_TYPE_RESTRICTION = 1,
    OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_TYPE1_RESTRICTION = 2,
    OPM_TYPE_ENFORCEMENT_HDCP_FORCE_ULONG = 2147483647,
};
pub const OPM_TYPE_ENFORCEMENT_HDCP_OFF = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL.OPM_TYPE_ENFORCEMENT_HDCP_OFF;
pub const OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_NO_TYPE_RESTRICTION = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL.OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_NO_TYPE_RESTRICTION;
pub const OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_TYPE1_RESTRICTION = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL.OPM_TYPE_ENFORCEMENT_HDCP_ON_WITH_TYPE1_RESTRICTION;
pub const OPM_TYPE_ENFORCEMENT_HDCP_FORCE_ULONG = OPM_TYPE_ENFORCEMENT_HDCP_PROTECTION_LEVEL.OPM_TYPE_ENFORCEMENT_HDCP_FORCE_ULONG;

pub const __MIDL___MIDL_itf_opmapi_0000_0000_0007 = extern enum(i32) {
    OPM_CGMSA_OFF = 0,
    OPM_CGMSA_COPY_FREELY = 1,
    OPM_CGMSA_COPY_NO_MORE = 2,
    OPM_CGMSA_COPY_ONE_GENERATION = 3,
    OPM_CGMSA_COPY_NEVER = 4,
    OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED = 8,
};
pub const OPM_CGMSA_OFF = __MIDL___MIDL_itf_opmapi_0000_0000_0007.OPM_CGMSA_OFF;
pub const OPM_CGMSA_COPY_FREELY = __MIDL___MIDL_itf_opmapi_0000_0000_0007.OPM_CGMSA_COPY_FREELY;
pub const OPM_CGMSA_COPY_NO_MORE = __MIDL___MIDL_itf_opmapi_0000_0000_0007.OPM_CGMSA_COPY_NO_MORE;
pub const OPM_CGMSA_COPY_ONE_GENERATION = __MIDL___MIDL_itf_opmapi_0000_0000_0007.OPM_CGMSA_COPY_ONE_GENERATION;
pub const OPM_CGMSA_COPY_NEVER = __MIDL___MIDL_itf_opmapi_0000_0000_0007.OPM_CGMSA_COPY_NEVER;
pub const OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED = __MIDL___MIDL_itf_opmapi_0000_0000_0007.OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED;

pub const OPM_ACP_PROTECTION_LEVEL = extern enum(i32) {
    OPM_ACP_OFF = 0,
    OPM_ACP_LEVEL_ONE = 1,
    OPM_ACP_LEVEL_TWO = 2,
    OPM_ACP_LEVEL_THREE = 3,
    OPM_ACP_FORCE_ULONG = 2147483647,
};
pub const OPM_ACP_OFF = OPM_ACP_PROTECTION_LEVEL.OPM_ACP_OFF;
pub const OPM_ACP_LEVEL_ONE = OPM_ACP_PROTECTION_LEVEL.OPM_ACP_LEVEL_ONE;
pub const OPM_ACP_LEVEL_TWO = OPM_ACP_PROTECTION_LEVEL.OPM_ACP_LEVEL_TWO;
pub const OPM_ACP_LEVEL_THREE = OPM_ACP_PROTECTION_LEVEL.OPM_ACP_LEVEL_THREE;
pub const OPM_ACP_FORCE_ULONG = OPM_ACP_PROTECTION_LEVEL.OPM_ACP_FORCE_ULONG;

pub const __MIDL___MIDL_itf_opmapi_0000_0000_0008 = extern enum(i32) {
    OPM_PROTECTION_TYPE_OTHER = -2147483648,
    OPM_PROTECTION_TYPE_NONE = 0,
    OPM_PROTECTION_TYPE_COPP_COMPATIBLE_HDCP = 1,
    OPM_PROTECTION_TYPE_ACP = 2,
    OPM_PROTECTION_TYPE_CGMSA = 4,
    OPM_PROTECTION_TYPE_HDCP = 8,
    OPM_PROTECTION_TYPE_DPCP = 16,
    OPM_PROTECTION_TYPE_TYPE_ENFORCEMENT_HDCP = 32,
};
pub const OPM_PROTECTION_TYPE_OTHER = __MIDL___MIDL_itf_opmapi_0000_0000_0008.OPM_PROTECTION_TYPE_OTHER;
pub const OPM_PROTECTION_TYPE_NONE = __MIDL___MIDL_itf_opmapi_0000_0000_0008.OPM_PROTECTION_TYPE_NONE;
pub const OPM_PROTECTION_TYPE_COPP_COMPATIBLE_HDCP = __MIDL___MIDL_itf_opmapi_0000_0000_0008.OPM_PROTECTION_TYPE_COPP_COMPATIBLE_HDCP;
pub const OPM_PROTECTION_TYPE_ACP = __MIDL___MIDL_itf_opmapi_0000_0000_0008.OPM_PROTECTION_TYPE_ACP;
pub const OPM_PROTECTION_TYPE_CGMSA = __MIDL___MIDL_itf_opmapi_0000_0000_0008.OPM_PROTECTION_TYPE_CGMSA;
pub const OPM_PROTECTION_TYPE_HDCP = __MIDL___MIDL_itf_opmapi_0000_0000_0008.OPM_PROTECTION_TYPE_HDCP;
pub const OPM_PROTECTION_TYPE_DPCP = __MIDL___MIDL_itf_opmapi_0000_0000_0008.OPM_PROTECTION_TYPE_DPCP;
pub const OPM_PROTECTION_TYPE_TYPE_ENFORCEMENT_HDCP = __MIDL___MIDL_itf_opmapi_0000_0000_0008.OPM_PROTECTION_TYPE_TYPE_ENFORCEMENT_HDCP;

pub const __MIDL___MIDL_itf_opmapi_0000_0000_0009 = extern enum(i32) {
    OPM_PROTECTION_STANDARD_OTHER = -2147483648,
    OPM_PROTECTION_STANDARD_NONE = 0,
    OPM_PROTECTION_STANDARD_IEC61880_525I = 1,
    OPM_PROTECTION_STANDARD_IEC61880_2_525I = 2,
    OPM_PROTECTION_STANDARD_IEC62375_625P = 4,
    OPM_PROTECTION_STANDARD_EIA608B_525 = 8,
    OPM_PROTECTION_STANDARD_EN300294_625I = 16,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEA_525P = 32,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEA_750P = 64,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEA_1125I = 128,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEB_525P = 256,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEB_750P = 512,
    OPM_PROTECTION_STANDARD_CEA805A_TYPEB_1125I = 1024,
    OPM_PROTECTION_STANDARD_ARIBTRB15_525I = 2048,
    OPM_PROTECTION_STANDARD_ARIBTRB15_525P = 4096,
    OPM_PROTECTION_STANDARD_ARIBTRB15_750P = 8192,
    OPM_PROTECTION_STANDARD_ARIBTRB15_1125I = 16384,
};
pub const OPM_PROTECTION_STANDARD_OTHER = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_OTHER;
pub const OPM_PROTECTION_STANDARD_NONE = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_NONE;
pub const OPM_PROTECTION_STANDARD_IEC61880_525I = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_IEC61880_525I;
pub const OPM_PROTECTION_STANDARD_IEC61880_2_525I = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_IEC61880_2_525I;
pub const OPM_PROTECTION_STANDARD_IEC62375_625P = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_IEC62375_625P;
pub const OPM_PROTECTION_STANDARD_EIA608B_525 = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_EIA608B_525;
pub const OPM_PROTECTION_STANDARD_EN300294_625I = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_EN300294_625I;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEA_525P = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_CEA805A_TYPEA_525P;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEA_750P = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_CEA805A_TYPEA_750P;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEA_1125I = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_CEA805A_TYPEA_1125I;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEB_525P = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_CEA805A_TYPEB_525P;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEB_750P = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_CEA805A_TYPEB_750P;
pub const OPM_PROTECTION_STANDARD_CEA805A_TYPEB_1125I = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_CEA805A_TYPEB_1125I;
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_525I = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_ARIBTRB15_525I;
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_525P = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_ARIBTRB15_525P;
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_750P = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_ARIBTRB15_750P;
pub const OPM_PROTECTION_STANDARD_ARIBTRB15_1125I = __MIDL___MIDL_itf_opmapi_0000_0000_0009.OPM_PROTECTION_STANDARD_ARIBTRB15_1125I;

pub const OPM_IMAGE_ASPECT_RATIO_EN300294 = extern enum(i32) {
    OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3 = 0,
    OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_CENTER = 1,
    OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_TOP = 2,
    OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_CENTER = 3,
    OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_TOP = 4,
    OPM_ASPECT_RATIO_EN300294_BOX_GT_16_BY_9_CENTER = 5,
    OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3_PROTECTED_CENTER = 6,
    OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_16_BY_9_ANAMORPHIC = 7,
    OPM_ASPECT_RATIO_FORCE_ULONG = 2147483647,
};
pub const OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3 = OPM_IMAGE_ASPECT_RATIO_EN300294.OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3;
pub const OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_CENTER = OPM_IMAGE_ASPECT_RATIO_EN300294.OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_CENTER;
pub const OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_TOP = OPM_IMAGE_ASPECT_RATIO_EN300294.OPM_ASPECT_RATIO_EN300294_BOX_14_BY_9_TOP;
pub const OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_CENTER = OPM_IMAGE_ASPECT_RATIO_EN300294.OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_CENTER;
pub const OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_TOP = OPM_IMAGE_ASPECT_RATIO_EN300294.OPM_ASPECT_RATIO_EN300294_BOX_16_BY_9_TOP;
pub const OPM_ASPECT_RATIO_EN300294_BOX_GT_16_BY_9_CENTER = OPM_IMAGE_ASPECT_RATIO_EN300294.OPM_ASPECT_RATIO_EN300294_BOX_GT_16_BY_9_CENTER;
pub const OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3_PROTECTED_CENTER = OPM_IMAGE_ASPECT_RATIO_EN300294.OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_4_BY_3_PROTECTED_CENTER;
pub const OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_16_BY_9_ANAMORPHIC = OPM_IMAGE_ASPECT_RATIO_EN300294.OPM_ASPECT_RATIO_EN300294_FULL_FORMAT_16_BY_9_ANAMORPHIC;
pub const OPM_ASPECT_RATIO_FORCE_ULONG = OPM_IMAGE_ASPECT_RATIO_EN300294.OPM_ASPECT_RATIO_FORCE_ULONG;

pub const OPM_RANDOM_NUMBER = extern struct {
    abRandomNumber: [16]u8,
};

pub const OPM_OMAC = extern struct {
    abOMAC: [16]u8,
};

pub const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS = extern struct {
    abEncryptedInitializationParameters: [256]u8,
};

pub const OPM_GET_INFO_PARAMETERS = extern struct {
    omac: OPM_OMAC,
    rnRandomNumber: OPM_RANDOM_NUMBER,
    guidInformation: Guid,
    ulSequenceNumber: u32,
    cbParametersSize: u32,
    abParameters: [4056]u8,
};

pub const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER,
    guidInformation: Guid,
    ulSequenceNumber: u32,
    cbParametersSize: u32,
    abParameters: [4056]u8,
};

pub const OPM_HDCP_KEY_SELECTION_VECTOR = extern struct {
    abKeySelectionVector: [5]u8,
};

pub const OPM_CONNECTED_HDCP_DEVICE_INFORMATION = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER,
    ulStatusFlags: u32,
    ulHDCPFlags: u32,
    ksvB: OPM_HDCP_KEY_SELECTION_VECTOR,
    Reserved: [11]u8,
    Reserved2: [16]u8,
    Reserved3: [16]u8,
};

pub const OPM_REQUESTED_INFORMATION = extern struct {
    omac: OPM_OMAC,
    cbRequestedInformationSize: u32,
    abRequestedInformation: [4076]u8,
};

pub const OPM_STANDARD_INFORMATION = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER,
    ulStatusFlags: u32,
    ulInformation: u32,
    ulReserved: u32,
    ulReserved2: u32,
};

pub const OPM_ACTUAL_OUTPUT_FORMAT = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER,
    ulStatusFlags: u32,
    ulDisplayWidth: u32,
    ulDisplayHeight: u32,
    dsfSampleInterleaveFormat: DXVA2_SampleFormat,
    d3dFormat: D3DFORMAT,
    ulFrequencyNumerator: u32,
    ulFrequencyDenominator: u32,
};

pub const OPM_ACP_AND_CGMSA_SIGNALING = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER,
    ulStatusFlags: u32,
    ulAvailableTVProtectionStandards: u32,
    ulActiveTVProtectionStandard: u32,
    ulReserved: u32,
    ulAspectRatioValidMask1: u32,
    ulAspectRatioData1: u32,
    ulAspectRatioValidMask2: u32,
    ulAspectRatioData2: u32,
    ulAspectRatioValidMask3: u32,
    ulAspectRatioData3: u32,
    ulReserved2: [4]u32,
    ulReserved3: [4]u32,
};

pub const OPM_OUTPUT_ID_DATA = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER,
    ulStatusFlags: u32,
    OutputId: u64,
};

pub const OPM_CONFIGURE_PARAMETERS = extern struct {
    omac: OPM_OMAC,
    guidSetting: Guid,
    ulSequenceNumber: u32,
    cbParametersSize: u32,
    abParameters: [4056]u8,
};

pub const OPM_SET_PROTECTION_LEVEL_PARAMETERS = extern struct {
    ulProtectionType: u32,
    ulProtectionLevel: u32,
    Reserved: u32,
    Reserved2: u32,
};

pub const OPM_SET_ACP_AND_CGMSA_SIGNALING_PARAMETERS = extern struct {
    ulNewTVProtectionStandard: u32,
    ulAspectRatioChangeMask1: u32,
    ulAspectRatioData1: u32,
    ulAspectRatioChangeMask2: u32,
    ulAspectRatioData2: u32,
    ulAspectRatioChangeMask3: u32,
    ulAspectRatioData3: u32,
    ulReserved: [4]u32,
    ulReserved2: [4]u32,
    ulReserved3: u32,
};

pub const OPM_SET_HDCP_SRM_PARAMETERS = extern struct {
    ulSRMVersion: u32,
};

pub const OPM_GET_CODEC_INFO_PARAMETERS = extern struct {
    cbVerifier: u32,
    Verifier: [4052]u8,
};

pub const OPM_GET_CODEC_INFO_INFORMATION = extern struct {
    rnRandomNumber: OPM_RANDOM_NUMBER,
    Merit: u32,
};

const IID_IOPMVideoOutput_Value = @import("../zig.zig").Guid.initString("0A15159D-41C7-4456-93E1-284CD61D4E8D");
pub const IID_IOPMVideoOutput = &IID_IOPMVideoOutput_Value;
pub const IOPMVideoOutput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartInitialization: fn(
            self: *const IOPMVideoOutput,
            prnRandomNumber: *OPM_RANDOM_NUMBER,
            ppbCertificate: **u8,
            pulCertificateLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FinishInitialization: fn(
            self: *const IOPMVideoOutput,
            pParameters: *const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInformation: fn(
            self: *const IOPMVideoOutput,
            pParameters: *const OPM_GET_INFO_PARAMETERS,
            pRequestedInformation: *OPM_REQUESTED_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        COPPCompatibleGetInformation: fn(
            self: *const IOPMVideoOutput,
            pParameters: *const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS,
            pRequestedInformation: *OPM_REQUESTED_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Configure: fn(
            self: *const IOPMVideoOutput,
            pParameters: *const OPM_CONFIGURE_PARAMETERS,
            ulAdditionalParametersSize: u32,
            pbAdditionalParameters: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOPMVideoOutput_StartInitialization(self: *const T, prnRandomNumber: *OPM_RANDOM_NUMBER, ppbCertificate: **u8, pulCertificateLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOPMVideoOutput.VTable, self.vtable).StartInitialization(@ptrCast(*const IOPMVideoOutput, self), prnRandomNumber, ppbCertificate, pulCertificateLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOPMVideoOutput_FinishInitialization(self: *const T, pParameters: *const OPM_ENCRYPTED_INITIALIZATION_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOPMVideoOutput.VTable, self.vtable).FinishInitialization(@ptrCast(*const IOPMVideoOutput, self), pParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOPMVideoOutput_GetInformation(self: *const T, pParameters: *const OPM_GET_INFO_PARAMETERS, pRequestedInformation: *OPM_REQUESTED_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOPMVideoOutput.VTable, self.vtable).GetInformation(@ptrCast(*const IOPMVideoOutput, self), pParameters, pRequestedInformation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOPMVideoOutput_COPPCompatibleGetInformation(self: *const T, pParameters: *const OPM_COPP_COMPATIBLE_GET_INFO_PARAMETERS, pRequestedInformation: *OPM_REQUESTED_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOPMVideoOutput.VTable, self.vtable).COPPCompatibleGetInformation(@ptrCast(*const IOPMVideoOutput, self), pParameters, pRequestedInformation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOPMVideoOutput_Configure(self: *const T, pParameters: *const OPM_CONFIGURE_PARAMETERS, ulAdditionalParametersSize: u32, pbAdditionalParameters: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOPMVideoOutput.VTable, self.vtable).Configure(@ptrCast(*const IOPMVideoOutput, self), pParameters, ulAdditionalParametersSize, pbAdditionalParameters);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_KSPROPSETID_OPMVideoOutput_Value = @import("../zig.zig").Guid.initString("06F414BB-F43A-4FE2-A566-774B4C81F0DB");
pub const CLSID_KSPROPSETID_OPMVideoOutput = &CLSID_KSPROPSETID_OPMVideoOutput_Value;

pub const KSMETHOD_OPMVIDEOOUTPUT = extern enum(i32) {
    STARTINITIALIZATION = 0,
    FINISHINITIALIZATION = 1,
    GETINFORMATION = 2,
};
pub const KSMETHOD_OPMVIDEOOUTPUT_STARTINITIALIZATION = KSMETHOD_OPMVIDEOOUTPUT.STARTINITIALIZATION;
pub const KSMETHOD_OPMVIDEOOUTPUT_FINISHINITIALIZATION = KSMETHOD_OPMVIDEOOUTPUT.FINISHINITIALIZATION;
pub const KSMETHOD_OPMVIDEOOUTPUT_GETINFORMATION = KSMETHOD_OPMVIDEOOUTPUT.GETINFORMATION;

pub const MF_ATTRIBUTE_TYPE = extern enum(i32) {
    MF_ATTRIBUTE_UINT32 = 19,
    MF_ATTRIBUTE_UINT64 = 21,
    MF_ATTRIBUTE_DOUBLE = 5,
    MF_ATTRIBUTE_GUID = 72,
    MF_ATTRIBUTE_STRING = 31,
    MF_ATTRIBUTE_BLOB = 4113,
    MF_ATTRIBUTE_IUNKNOWN = 13,
};
pub const MF_ATTRIBUTE_UINT32 = MF_ATTRIBUTE_TYPE.MF_ATTRIBUTE_UINT32;
pub const MF_ATTRIBUTE_UINT64 = MF_ATTRIBUTE_TYPE.MF_ATTRIBUTE_UINT64;
pub const MF_ATTRIBUTE_DOUBLE = MF_ATTRIBUTE_TYPE.MF_ATTRIBUTE_DOUBLE;
pub const MF_ATTRIBUTE_GUID = MF_ATTRIBUTE_TYPE.MF_ATTRIBUTE_GUID;
pub const MF_ATTRIBUTE_STRING = MF_ATTRIBUTE_TYPE.MF_ATTRIBUTE_STRING;
pub const MF_ATTRIBUTE_BLOB = MF_ATTRIBUTE_TYPE.MF_ATTRIBUTE_BLOB;
pub const MF_ATTRIBUTE_IUNKNOWN = MF_ATTRIBUTE_TYPE.MF_ATTRIBUTE_IUNKNOWN;

pub const MF_ATTRIBUTES_MATCH_TYPE = extern enum(i32) {
    MF_ATTRIBUTES_MATCH_OUR_ITEMS = 0,
    MF_ATTRIBUTES_MATCH_THEIR_ITEMS = 1,
    MF_ATTRIBUTES_MATCH_ALL_ITEMS = 2,
    MF_ATTRIBUTES_MATCH_INTERSECTION = 3,
    MF_ATTRIBUTES_MATCH_SMALLER = 4,
};
pub const MF_ATTRIBUTES_MATCH_OUR_ITEMS = MF_ATTRIBUTES_MATCH_TYPE.MF_ATTRIBUTES_MATCH_OUR_ITEMS;
pub const MF_ATTRIBUTES_MATCH_THEIR_ITEMS = MF_ATTRIBUTES_MATCH_TYPE.MF_ATTRIBUTES_MATCH_THEIR_ITEMS;
pub const MF_ATTRIBUTES_MATCH_ALL_ITEMS = MF_ATTRIBUTES_MATCH_TYPE.MF_ATTRIBUTES_MATCH_ALL_ITEMS;
pub const MF_ATTRIBUTES_MATCH_INTERSECTION = MF_ATTRIBUTES_MATCH_TYPE.MF_ATTRIBUTES_MATCH_INTERSECTION;
pub const MF_ATTRIBUTES_MATCH_SMALLER = MF_ATTRIBUTES_MATCH_TYPE.MF_ATTRIBUTES_MATCH_SMALLER;

const IID_IMFAttributes_Value = @import("../zig.zig").Guid.initString("2CD2D921-C447-44A7-A13C-4ADABFC247E3");
pub const IID_IMFAttributes = &IID_IMFAttributes_Value;
pub const IMFAttributes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetItem: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pValue: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemType: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pType: *MF_ATTRIBUTE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareItem: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            Value: *const PROPVARIANT,
            pbResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Compare: fn(
            self: *const IMFAttributes,
            pTheirs: ?*IMFAttributes,
            MatchType: MF_ATTRIBUTES_MATCH_TYPE,
            pbResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUINT32: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            punValue: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUINT64: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            punValue: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDouble: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pfValue: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGUID: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pguidValue: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringLength: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pcchLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetString: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pwszValue: [*:0]u16,
            cchBufSize: u32,
            pcchLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllocatedString: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            ppwszValue: *PWSTR,
            pcchLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBlobSize: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pcbBlobSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBlob: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pBuf: [*:0]u8,
            cbBufSize: u32,
            pcbBlobSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllocatedBlob: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            ppBuf: [*]*u8,
            pcbSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnknown: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItem: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            Value: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteItem: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteAllItems: fn(
            self: *const IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUINT32: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            unValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUINT64: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            unValue: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDouble: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            fValue: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGUID: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            guidValue: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetString: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            wszValue: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBlob: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pBuf: [*:0]const u8,
            cbBufSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnknown: fn(
            self: *const IMFAttributes,
            guidKey: *const Guid,
            pUnknown: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockStore: fn(
            self: *const IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockStore: fn(
            self: *const IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const IMFAttributes,
            pcItems: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemByIndex: fn(
            self: *const IMFAttributes,
            unIndex: u32,
            pguidKey: *Guid,
            pValue: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyAllItems: fn(
            self: *const IMFAttributes,
            pDest: *IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetItem(self: *const T, guidKey: *const Guid, pValue: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetItem(@ptrCast(*const IMFAttributes, self), guidKey, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetItemType(self: *const T, guidKey: *const Guid, pType: *MF_ATTRIBUTE_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetItemType(@ptrCast(*const IMFAttributes, self), guidKey, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_CompareItem(self: *const T, guidKey: *const Guid, Value: *const PROPVARIANT, pbResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).CompareItem(@ptrCast(*const IMFAttributes, self), guidKey, Value, pbResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_Compare(self: *const T, pTheirs: ?*IMFAttributes, MatchType: MF_ATTRIBUTES_MATCH_TYPE, pbResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).Compare(@ptrCast(*const IMFAttributes, self), pTheirs, MatchType, pbResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetUINT32(self: *const T, guidKey: *const Guid, punValue: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetUINT32(@ptrCast(*const IMFAttributes, self), guidKey, punValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetUINT64(self: *const T, guidKey: *const Guid, punValue: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetUINT64(@ptrCast(*const IMFAttributes, self), guidKey, punValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetDouble(self: *const T, guidKey: *const Guid, pfValue: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetDouble(@ptrCast(*const IMFAttributes, self), guidKey, pfValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetGUID(self: *const T, guidKey: *const Guid, pguidValue: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetGUID(@ptrCast(*const IMFAttributes, self), guidKey, pguidValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetStringLength(self: *const T, guidKey: *const Guid, pcchLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetStringLength(@ptrCast(*const IMFAttributes, self), guidKey, pcchLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetString(self: *const T, guidKey: *const Guid, pwszValue: [*:0]u16, cchBufSize: u32, pcchLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetString(@ptrCast(*const IMFAttributes, self), guidKey, pwszValue, cchBufSize, pcchLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetAllocatedString(self: *const T, guidKey: *const Guid, ppwszValue: *PWSTR, pcchLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetAllocatedString(@ptrCast(*const IMFAttributes, self), guidKey, ppwszValue, pcchLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetBlobSize(self: *const T, guidKey: *const Guid, pcbBlobSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetBlobSize(@ptrCast(*const IMFAttributes, self), guidKey, pcbBlobSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetBlob(self: *const T, guidKey: *const Guid, pBuf: [*:0]u8, cbBufSize: u32, pcbBlobSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetBlob(@ptrCast(*const IMFAttributes, self), guidKey, pBuf, cbBufSize, pcbBlobSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetAllocatedBlob(self: *const T, guidKey: *const Guid, ppBuf: [*]*u8, pcbSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetAllocatedBlob(@ptrCast(*const IMFAttributes, self), guidKey, ppBuf, pcbSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetUnknown(self: *const T, guidKey: *const Guid, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetUnknown(@ptrCast(*const IMFAttributes, self), guidKey, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_SetItem(self: *const T, guidKey: *const Guid, Value: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).SetItem(@ptrCast(*const IMFAttributes, self), guidKey, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_DeleteItem(self: *const T, guidKey: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).DeleteItem(@ptrCast(*const IMFAttributes, self), guidKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_DeleteAllItems(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).DeleteAllItems(@ptrCast(*const IMFAttributes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_SetUINT32(self: *const T, guidKey: *const Guid, unValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).SetUINT32(@ptrCast(*const IMFAttributes, self), guidKey, unValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_SetUINT64(self: *const T, guidKey: *const Guid, unValue: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).SetUINT64(@ptrCast(*const IMFAttributes, self), guidKey, unValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_SetDouble(self: *const T, guidKey: *const Guid, fValue: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).SetDouble(@ptrCast(*const IMFAttributes, self), guidKey, fValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_SetGUID(self: *const T, guidKey: *const Guid, guidValue: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).SetGUID(@ptrCast(*const IMFAttributes, self), guidKey, guidValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_SetString(self: *const T, guidKey: *const Guid, wszValue: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).SetString(@ptrCast(*const IMFAttributes, self), guidKey, wszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_SetBlob(self: *const T, guidKey: *const Guid, pBuf: [*:0]const u8, cbBufSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).SetBlob(@ptrCast(*const IMFAttributes, self), guidKey, pBuf, cbBufSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_SetUnknown(self: *const T, guidKey: *const Guid, pUnknown: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).SetUnknown(@ptrCast(*const IMFAttributes, self), guidKey, pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_LockStore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).LockStore(@ptrCast(*const IMFAttributes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_UnlockStore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).UnlockStore(@ptrCast(*const IMFAttributes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetCount(self: *const T, pcItems: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetCount(@ptrCast(*const IMFAttributes, self), pcItems);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_GetItemByIndex(self: *const T, unIndex: u32, pguidKey: *Guid, pValue: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).GetItemByIndex(@ptrCast(*const IMFAttributes, self), unIndex, pguidKey, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAttributes_CopyAllItems(self: *const T, pDest: *IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAttributes.VTable, self.vtable).CopyAllItems(@ptrCast(*const IMFAttributes, self), pDest);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_ATTRIBUTE_SERIALIZE_OPTIONS = extern enum(i32) {
    MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF = 1,
};
pub const MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF = MF_ATTRIBUTE_SERIALIZE_OPTIONS.MF_ATTRIBUTE_SERIALIZE_UNKNOWN_BYREF;

const IID_IMFMediaBuffer_Value = @import("../zig.zig").Guid.initString("045FA593-8799-42B8-BC8D-8968C6453507");
pub const IID_IMFMediaBuffer = &IID_IMFMediaBuffer_Value;
pub const IMFMediaBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Lock: fn(
            self: *const IMFMediaBuffer,
            ppbBuffer: [*]*u8,
            pcbMaxLength: ?*u32,
            pcbCurrentLength: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unlock: fn(
            self: *const IMFMediaBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentLength: fn(
            self: *const IMFMediaBuffer,
            pcbCurrentLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentLength: fn(
            self: *const IMFMediaBuffer,
            cbCurrentLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxLength: fn(
            self: *const IMFMediaBuffer,
            pcbMaxLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaBuffer_Lock(self: *const T, ppbBuffer: [*]*u8, pcbMaxLength: ?*u32, pcbCurrentLength: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaBuffer.VTable, self.vtable).Lock(@ptrCast(*const IMFMediaBuffer, self), ppbBuffer, pcbMaxLength, pcbCurrentLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaBuffer_Unlock(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaBuffer.VTable, self.vtable).Unlock(@ptrCast(*const IMFMediaBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaBuffer_GetCurrentLength(self: *const T, pcbCurrentLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaBuffer.VTable, self.vtable).GetCurrentLength(@ptrCast(*const IMFMediaBuffer, self), pcbCurrentLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaBuffer_SetCurrentLength(self: *const T, cbCurrentLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaBuffer.VTable, self.vtable).SetCurrentLength(@ptrCast(*const IMFMediaBuffer, self), cbCurrentLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaBuffer_GetMaxLength(self: *const T, pcbMaxLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaBuffer.VTable, self.vtable).GetMaxLength(@ptrCast(*const IMFMediaBuffer, self), pcbMaxLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSample_Value = @import("../zig.zig").Guid.initString("C40A00F2-B93A-4D80-AE8C-5A1C634F58E4");
pub const IID_IMFSample = &IID_IMFSample_Value;
pub const IMFSample = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetSampleFlags: fn(
            self: *const IMFSample,
            pdwSampleFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSampleFlags: fn(
            self: *const IMFSample,
            dwSampleFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSampleTime: fn(
            self: *const IMFSample,
            phnsSampleTime: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSampleTime: fn(
            self: *const IMFSample,
            hnsSampleTime: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSampleDuration: fn(
            self: *const IMFSample,
            phnsSampleDuration: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSampleDuration: fn(
            self: *const IMFSample,
            hnsSampleDuration: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferCount: fn(
            self: *const IMFSample,
            pdwBufferCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferByIndex: fn(
            self: *const IMFSample,
            dwIndex: u32,
            ppBuffer: **IMFMediaBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertToContiguousBuffer: fn(
            self: *const IMFSample,
            ppBuffer: **IMFMediaBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBuffer: fn(
            self: *const IMFSample,
            pBuffer: *IMFMediaBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBufferByIndex: fn(
            self: *const IMFSample,
            dwIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllBuffers: fn(
            self: *const IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalLength: fn(
            self: *const IMFSample,
            pcbTotalLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CopyToBuffer: fn(
            self: *const IMFSample,
            pBuffer: *IMFMediaBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_GetSampleFlags(self: *const T, pdwSampleFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).GetSampleFlags(@ptrCast(*const IMFSample, self), pdwSampleFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_SetSampleFlags(self: *const T, dwSampleFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).SetSampleFlags(@ptrCast(*const IMFSample, self), dwSampleFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_GetSampleTime(self: *const T, phnsSampleTime: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).GetSampleTime(@ptrCast(*const IMFSample, self), phnsSampleTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_SetSampleTime(self: *const T, hnsSampleTime: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).SetSampleTime(@ptrCast(*const IMFSample, self), hnsSampleTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_GetSampleDuration(self: *const T, phnsSampleDuration: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).GetSampleDuration(@ptrCast(*const IMFSample, self), phnsSampleDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_SetSampleDuration(self: *const T, hnsSampleDuration: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).SetSampleDuration(@ptrCast(*const IMFSample, self), hnsSampleDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_GetBufferCount(self: *const T, pdwBufferCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).GetBufferCount(@ptrCast(*const IMFSample, self), pdwBufferCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_GetBufferByIndex(self: *const T, dwIndex: u32, ppBuffer: **IMFMediaBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).GetBufferByIndex(@ptrCast(*const IMFSample, self), dwIndex, ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_ConvertToContiguousBuffer(self: *const T, ppBuffer: **IMFMediaBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).ConvertToContiguousBuffer(@ptrCast(*const IMFSample, self), ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_AddBuffer(self: *const T, pBuffer: *IMFMediaBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).AddBuffer(@ptrCast(*const IMFSample, self), pBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_RemoveBufferByIndex(self: *const T, dwIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).RemoveBufferByIndex(@ptrCast(*const IMFSample, self), dwIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_RemoveAllBuffers(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).RemoveAllBuffers(@ptrCast(*const IMFSample, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_GetTotalLength(self: *const T, pcbTotalLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).GetTotalLength(@ptrCast(*const IMFSample, self), pcbTotalLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSample_CopyToBuffer(self: *const T, pBuffer: *IMFMediaBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSample.VTable, self.vtable).CopyToBuffer(@ptrCast(*const IMFSample, self), pBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMF2DBuffer_Value = @import("../zig.zig").Guid.initString("7DC9D5F9-9ED9-44EC-9BBF-0600BB589FBB");
pub const IID_IMF2DBuffer = &IID_IMF2DBuffer_Value;
pub const IMF2DBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Lock2D: fn(
            self: *const IMF2DBuffer,
            ppbScanline0: **u8,
            plPitch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unlock2D: fn(
            self: *const IMF2DBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScanline0AndPitch: fn(
            self: *const IMF2DBuffer,
            pbScanline0: **u8,
            plPitch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsContiguousFormat: fn(
            self: *const IMF2DBuffer,
            pfIsContiguous: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContiguousLength: fn(
            self: *const IMF2DBuffer,
            pcbLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContiguousCopyTo: fn(
            self: *const IMF2DBuffer,
            pbDestBuffer: [*:0]u8,
            cbDestBuffer: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContiguousCopyFrom: fn(
            self: *const IMF2DBuffer,
            pbSrcBuffer: [*:0]const u8,
            cbSrcBuffer: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMF2DBuffer_Lock2D(self: *const T, ppbScanline0: **u8, plPitch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMF2DBuffer.VTable, self.vtable).Lock2D(@ptrCast(*const IMF2DBuffer, self), ppbScanline0, plPitch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMF2DBuffer_Unlock2D(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMF2DBuffer.VTable, self.vtable).Unlock2D(@ptrCast(*const IMF2DBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMF2DBuffer_GetScanline0AndPitch(self: *const T, pbScanline0: **u8, plPitch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMF2DBuffer.VTable, self.vtable).GetScanline0AndPitch(@ptrCast(*const IMF2DBuffer, self), pbScanline0, plPitch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMF2DBuffer_IsContiguousFormat(self: *const T, pfIsContiguous: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMF2DBuffer.VTable, self.vtable).IsContiguousFormat(@ptrCast(*const IMF2DBuffer, self), pfIsContiguous);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMF2DBuffer_GetContiguousLength(self: *const T, pcbLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMF2DBuffer.VTable, self.vtable).GetContiguousLength(@ptrCast(*const IMF2DBuffer, self), pcbLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMF2DBuffer_ContiguousCopyTo(self: *const T, pbDestBuffer: [*:0]u8, cbDestBuffer: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMF2DBuffer.VTable, self.vtable).ContiguousCopyTo(@ptrCast(*const IMF2DBuffer, self), pbDestBuffer, cbDestBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMF2DBuffer_ContiguousCopyFrom(self: *const T, pbSrcBuffer: [*:0]const u8, cbSrcBuffer: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMF2DBuffer.VTable, self.vtable).ContiguousCopyFrom(@ptrCast(*const IMF2DBuffer, self), pbSrcBuffer, cbSrcBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF2DBuffer_LockFlags = extern enum(i32) {
    LockTypeMask = 3,
    Read = 1,
    Write = 2,
    ReadWrite = 3,
    ForceDWORD = 2147483647,
};
pub const MF2DBuffer_LockFlags_LockTypeMask = MF2DBuffer_LockFlags.LockTypeMask;
pub const MF2DBuffer_LockFlags_Read = MF2DBuffer_LockFlags.Read;
pub const MF2DBuffer_LockFlags_Write = MF2DBuffer_LockFlags.Write;
pub const MF2DBuffer_LockFlags_ReadWrite = MF2DBuffer_LockFlags.ReadWrite;
pub const MF2DBuffer_LockFlags_ForceDWORD = MF2DBuffer_LockFlags.ForceDWORD;

const IID_IMF2DBuffer2_Value = @import("../zig.zig").Guid.initString("33AE5EA6-4316-436F-8DDD-D73D22F829EC");
pub const IID_IMF2DBuffer2 = &IID_IMF2DBuffer2_Value;
pub const IMF2DBuffer2 = extern struct {
    pub const VTable = extern struct {
        base: IMF2DBuffer.VTable,
        Lock2DSize: fn(
            self: *const IMF2DBuffer2,
            lockFlags: MF2DBuffer_LockFlags,
            ppbScanline0: **u8,
            plPitch: *i32,
            ppbBufferStart: **u8,
            pcbBufferLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy2DTo: fn(
            self: *const IMF2DBuffer2,
            pDestBuffer: *IMF2DBuffer2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMF2DBuffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMF2DBuffer2_Lock2DSize(self: *const T, lockFlags: MF2DBuffer_LockFlags, ppbScanline0: **u8, plPitch: *i32, ppbBufferStart: **u8, pcbBufferLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMF2DBuffer2.VTable, self.vtable).Lock2DSize(@ptrCast(*const IMF2DBuffer2, self), lockFlags, ppbScanline0, plPitch, ppbBufferStart, pcbBufferLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMF2DBuffer2_Copy2DTo(self: *const T, pDestBuffer: *IMF2DBuffer2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMF2DBuffer2.VTable, self.vtable).Copy2DTo(@ptrCast(*const IMF2DBuffer2, self), pDestBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFDXGIBuffer_Value = @import("../zig.zig").Guid.initString("E7174CFA-1C9E-48B1-8866-626226BFC258");
pub const IID_IMFDXGIBuffer = &IID_IMFDXGIBuffer_Value;
pub const IMFDXGIBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetResource: fn(
            self: *const IMFDXGIBuffer,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubresourceIndex: fn(
            self: *const IMFDXGIBuffer,
            puSubresource: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnknown: fn(
            self: *const IMFDXGIBuffer,
            guid: *const Guid,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnknown: fn(
            self: *const IMFDXGIBuffer,
            guid: *const Guid,
            pUnkData: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIBuffer_GetResource(self: *const T, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIBuffer.VTable, self.vtable).GetResource(@ptrCast(*const IMFDXGIBuffer, self), riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIBuffer_GetSubresourceIndex(self: *const T, puSubresource: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIBuffer.VTable, self.vtable).GetSubresourceIndex(@ptrCast(*const IMFDXGIBuffer, self), puSubresource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIBuffer_GetUnknown(self: *const T, guid: *const Guid, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIBuffer.VTable, self.vtable).GetUnknown(@ptrCast(*const IMFDXGIBuffer, self), guid, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIBuffer_SetUnknown(self: *const T, guid: *const Guid, pUnkData: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIBuffer.VTable, self.vtable).SetUnknown(@ptrCast(*const IMFDXGIBuffer, self), guid, pUnkData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaType_Value = @import("../zig.zig").Guid.initString("44AE0FA8-EA31-4109-8D2E-4CAE4997C555");
pub const IID_IMFMediaType = &IID_IMFMediaType_Value;
pub const IMFMediaType = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetMajorType: fn(
            self: *const IMFMediaType,
            pguidMajorType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCompressedFormat: fn(
            self: *const IMFMediaType,
            pfCompressed: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IMFMediaType,
            pIMediaType: *IMFMediaType,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRepresentation: fn(
            self: *const IMFMediaType,
            guidRepresentation: Guid,
            ppvRepresentation: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeRepresentation: fn(
            self: *const IMFMediaType,
            guidRepresentation: Guid,
            pvRepresentation: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaType_GetMajorType(self: *const T, pguidMajorType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaType.VTable, self.vtable).GetMajorType(@ptrCast(*const IMFMediaType, self), pguidMajorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaType_IsCompressedFormat(self: *const T, pfCompressed: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaType.VTable, self.vtable).IsCompressedFormat(@ptrCast(*const IMFMediaType, self), pfCompressed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaType_IsEqual(self: *const T, pIMediaType: *IMFMediaType, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaType.VTable, self.vtable).IsEqual(@ptrCast(*const IMFMediaType, self), pIMediaType, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaType_GetRepresentation(self: *const T, guidRepresentation: Guid, ppvRepresentation: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaType.VTable, self.vtable).GetRepresentation(@ptrCast(*const IMFMediaType, self), guidRepresentation, ppvRepresentation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaType_FreeRepresentation(self: *const T, guidRepresentation: Guid, pvRepresentation: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaType.VTable, self.vtable).FreeRepresentation(@ptrCast(*const IMFMediaType, self), guidRepresentation, pvRepresentation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFAudioMediaType_Value = @import("../zig.zig").Guid.initString("26A0ADC3-CE26-4672-9304-69552EDD3FAF");
pub const IID_IMFAudioMediaType = &IID_IMFAudioMediaType_Value;
pub const IMFAudioMediaType = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaType.VTable,
        GetAudioFormat: fn(
            self: *const IMFAudioMediaType,
        ) callconv(@import("std").os.windows.WINAPI) *WAVEFORMATEX,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioMediaType_GetAudioFormat(self: *const T) callconv(.Inline) *WAVEFORMATEX {
            return @ptrCast(*const IMFAudioMediaType.VTable, self.vtable).GetAudioFormat(@ptrCast(*const IMFAudioMediaType, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFT_REGISTER_TYPE_INFO = extern struct {
    guidMajorType: Guid,
    guidSubtype: Guid,
};

pub const MFVideoInterlaceMode = extern enum(i32) {
    MFVideoInterlace_Unknown = 0,
    MFVideoInterlace_Progressive = 2,
    MFVideoInterlace_FieldInterleavedUpperFirst = 3,
    MFVideoInterlace_FieldInterleavedLowerFirst = 4,
    MFVideoInterlace_FieldSingleUpper = 5,
    MFVideoInterlace_FieldSingleLower = 6,
    MFVideoInterlace_MixedInterlaceOrProgressive = 7,
    MFVideoInterlace_Last = 8,
    MFVideoInterlace_ForceDWORD = 2147483647,
};
pub const MFVideoInterlace_Unknown = MFVideoInterlaceMode.MFVideoInterlace_Unknown;
pub const MFVideoInterlace_Progressive = MFVideoInterlaceMode.MFVideoInterlace_Progressive;
pub const MFVideoInterlace_FieldInterleavedUpperFirst = MFVideoInterlaceMode.MFVideoInterlace_FieldInterleavedUpperFirst;
pub const MFVideoInterlace_FieldInterleavedLowerFirst = MFVideoInterlaceMode.MFVideoInterlace_FieldInterleavedLowerFirst;
pub const MFVideoInterlace_FieldSingleUpper = MFVideoInterlaceMode.MFVideoInterlace_FieldSingleUpper;
pub const MFVideoInterlace_FieldSingleLower = MFVideoInterlaceMode.MFVideoInterlace_FieldSingleLower;
pub const MFVideoInterlace_MixedInterlaceOrProgressive = MFVideoInterlaceMode.MFVideoInterlace_MixedInterlaceOrProgressive;
pub const MFVideoInterlace_Last = MFVideoInterlaceMode.MFVideoInterlace_Last;
pub const MFVideoInterlace_ForceDWORD = MFVideoInterlaceMode.MFVideoInterlace_ForceDWORD;

pub const MFVideoTransferFunction = extern enum(i32) {
    MFVideoTransFunc_Unknown = 0,
    MFVideoTransFunc_10 = 1,
    MFVideoTransFunc_18 = 2,
    MFVideoTransFunc_20 = 3,
    MFVideoTransFunc_22 = 4,
    MFVideoTransFunc_709 = 5,
    MFVideoTransFunc_240M = 6,
    MFVideoTransFunc_sRGB = 7,
    MFVideoTransFunc_28 = 8,
    MFVideoTransFunc_Log_100 = 9,
    MFVideoTransFunc_Log_316 = 10,
    MFVideoTransFunc_709_sym = 11,
    MFVideoTransFunc_2020_const = 12,
    MFVideoTransFunc_2020 = 13,
    MFVideoTransFunc_26 = 14,
    MFVideoTransFunc_2084 = 15,
    MFVideoTransFunc_HLG = 16,
    MFVideoTransFunc_10_rel = 17,
    MFVideoTransFunc_Last = 18,
    MFVideoTransFunc_ForceDWORD = 2147483647,
};
pub const MFVideoTransFunc_Unknown = MFVideoTransferFunction.MFVideoTransFunc_Unknown;
pub const MFVideoTransFunc_10 = MFVideoTransferFunction.MFVideoTransFunc_10;
pub const MFVideoTransFunc_18 = MFVideoTransferFunction.MFVideoTransFunc_18;
pub const MFVideoTransFunc_20 = MFVideoTransferFunction.MFVideoTransFunc_20;
pub const MFVideoTransFunc_22 = MFVideoTransferFunction.MFVideoTransFunc_22;
pub const MFVideoTransFunc_709 = MFVideoTransferFunction.MFVideoTransFunc_709;
pub const MFVideoTransFunc_240M = MFVideoTransferFunction.MFVideoTransFunc_240M;
pub const MFVideoTransFunc_sRGB = MFVideoTransferFunction.MFVideoTransFunc_sRGB;
pub const MFVideoTransFunc_28 = MFVideoTransferFunction.MFVideoTransFunc_28;
pub const MFVideoTransFunc_Log_100 = MFVideoTransferFunction.MFVideoTransFunc_Log_100;
pub const MFVideoTransFunc_Log_316 = MFVideoTransferFunction.MFVideoTransFunc_Log_316;
pub const MFVideoTransFunc_709_sym = MFVideoTransferFunction.MFVideoTransFunc_709_sym;
pub const MFVideoTransFunc_2020_const = MFVideoTransferFunction.MFVideoTransFunc_2020_const;
pub const MFVideoTransFunc_2020 = MFVideoTransferFunction.MFVideoTransFunc_2020;
pub const MFVideoTransFunc_26 = MFVideoTransferFunction.MFVideoTransFunc_26;
pub const MFVideoTransFunc_2084 = MFVideoTransferFunction.MFVideoTransFunc_2084;
pub const MFVideoTransFunc_HLG = MFVideoTransferFunction.MFVideoTransFunc_HLG;
pub const MFVideoTransFunc_10_rel = MFVideoTransferFunction.MFVideoTransFunc_10_rel;
pub const MFVideoTransFunc_Last = MFVideoTransferFunction.MFVideoTransFunc_Last;
pub const MFVideoTransFunc_ForceDWORD = MFVideoTransferFunction.MFVideoTransFunc_ForceDWORD;

pub const MFVideoPrimaries = extern enum(i32) {
    Unknown = 0,
    reserved = 1,
    BT709 = 2,
    BT470_2_SysM = 3,
    BT470_2_SysBG = 4,
    SMPTE170M = 5,
    SMPTE240M = 6,
    EBU3213 = 7,
    SMPTE_C = 8,
    BT2020 = 9,
    XYZ = 10,
    DCI_P3 = 11,
    ACES = 12,
    Last = 13,
    ForceDWORD = 2147483647,
};
pub const MFVideoPrimaries_Unknown = MFVideoPrimaries.Unknown;
pub const MFVideoPrimaries_reserved = MFVideoPrimaries.reserved;
pub const MFVideoPrimaries_BT709 = MFVideoPrimaries.BT709;
pub const MFVideoPrimaries_BT470_2_SysM = MFVideoPrimaries.BT470_2_SysM;
pub const MFVideoPrimaries_BT470_2_SysBG = MFVideoPrimaries.BT470_2_SysBG;
pub const MFVideoPrimaries_SMPTE170M = MFVideoPrimaries.SMPTE170M;
pub const MFVideoPrimaries_SMPTE240M = MFVideoPrimaries.SMPTE240M;
pub const MFVideoPrimaries_EBU3213 = MFVideoPrimaries.EBU3213;
pub const MFVideoPrimaries_SMPTE_C = MFVideoPrimaries.SMPTE_C;
pub const MFVideoPrimaries_BT2020 = MFVideoPrimaries.BT2020;
pub const MFVideoPrimaries_XYZ = MFVideoPrimaries.XYZ;
pub const MFVideoPrimaries_DCI_P3 = MFVideoPrimaries.DCI_P3;
pub const MFVideoPrimaries_ACES = MFVideoPrimaries.ACES;
pub const MFVideoPrimaries_Last = MFVideoPrimaries.Last;
pub const MFVideoPrimaries_ForceDWORD = MFVideoPrimaries.ForceDWORD;

pub const MFVideoLighting = extern enum(i32) {
    Unknown = 0,
    bright = 1,
    office = 2,
    dim = 3,
    dark = 4,
    Last = 5,
    ForceDWORD = 2147483647,
};
pub const MFVideoLighting_Unknown = MFVideoLighting.Unknown;
pub const MFVideoLighting_bright = MFVideoLighting.bright;
pub const MFVideoLighting_office = MFVideoLighting.office;
pub const MFVideoLighting_dim = MFVideoLighting.dim;
pub const MFVideoLighting_dark = MFVideoLighting.dark;
pub const MFVideoLighting_Last = MFVideoLighting.Last;
pub const MFVideoLighting_ForceDWORD = MFVideoLighting.ForceDWORD;

pub const MFVideoTransferMatrix = extern enum(i32) {
    Unknown = 0,
    BT709 = 1,
    BT601 = 2,
    SMPTE240M = 3,
    BT2020_10 = 4,
    BT2020_12 = 5,
    Last = 6,
    ForceDWORD = 2147483647,
};
pub const MFVideoTransferMatrix_Unknown = MFVideoTransferMatrix.Unknown;
pub const MFVideoTransferMatrix_BT709 = MFVideoTransferMatrix.BT709;
pub const MFVideoTransferMatrix_BT601 = MFVideoTransferMatrix.BT601;
pub const MFVideoTransferMatrix_SMPTE240M = MFVideoTransferMatrix.SMPTE240M;
pub const MFVideoTransferMatrix_BT2020_10 = MFVideoTransferMatrix.BT2020_10;
pub const MFVideoTransferMatrix_BT2020_12 = MFVideoTransferMatrix.BT2020_12;
pub const MFVideoTransferMatrix_Last = MFVideoTransferMatrix.Last;
pub const MFVideoTransferMatrix_ForceDWORD = MFVideoTransferMatrix.ForceDWORD;

pub const MFVideoChromaSubsampling = extern enum(i32) {
    Unknown = 0,
    ProgressiveChroma = 8,
    Horizontally_Cosited = 4,
    Vertically_Cosited = 2,
    Vertically_AlignedChromaPlanes = 1,
    MPEG2 = 5,
    MPEG1 = 1,
    DV_PAL = 6,
    Cosited = 7,
    Last = 8,
    ForceDWORD = 2147483647,
};
pub const MFVideoChromaSubsampling_Unknown = MFVideoChromaSubsampling.Unknown;
pub const MFVideoChromaSubsampling_ProgressiveChroma = MFVideoChromaSubsampling.ProgressiveChroma;
pub const MFVideoChromaSubsampling_Horizontally_Cosited = MFVideoChromaSubsampling.Horizontally_Cosited;
pub const MFVideoChromaSubsampling_Vertically_Cosited = MFVideoChromaSubsampling.Vertically_Cosited;
pub const MFVideoChromaSubsampling_Vertically_AlignedChromaPlanes = MFVideoChromaSubsampling.Vertically_AlignedChromaPlanes;
pub const MFVideoChromaSubsampling_MPEG2 = MFVideoChromaSubsampling.MPEG2;
pub const MFVideoChromaSubsampling_MPEG1 = MFVideoChromaSubsampling.MPEG1;
pub const MFVideoChromaSubsampling_DV_PAL = MFVideoChromaSubsampling.DV_PAL;
pub const MFVideoChromaSubsampling_Cosited = MFVideoChromaSubsampling.Cosited;
pub const MFVideoChromaSubsampling_Last = MFVideoChromaSubsampling.Last;
pub const MFVideoChromaSubsampling_ForceDWORD = MFVideoChromaSubsampling.ForceDWORD;

pub const MFNominalRange = extern enum(i32) {
    Unknown = 0,
    Normal = 1,
    Wide = 2,
    _0_255 = 1,
    _16_235 = 2,
    _48_208 = 3,
    _64_127 = 4,
    Last = 5,
    ForceDWORD = 2147483647,
};
pub const MFNominalRange_Unknown = MFNominalRange.Unknown;
pub const MFNominalRange_Normal = MFNominalRange.Normal;
pub const MFNominalRange_Wide = MFNominalRange.Wide;
pub const MFNominalRange_0_255 = MFNominalRange._0_255;
pub const MFNominalRange_16_235 = MFNominalRange._16_235;
pub const MFNominalRange_48_208 = MFNominalRange._48_208;
pub const MFNominalRange_64_127 = MFNominalRange._64_127;
pub const MFNominalRange_Last = MFNominalRange.Last;
pub const MFNominalRange_ForceDWORD = MFNominalRange.ForceDWORD;

pub const MFVideoFlags = extern enum(i32) {
    MFVideoFlag_PAD_TO_Mask = 3,
    MFVideoFlag_PAD_TO_None = 0,
    MFVideoFlag_PAD_TO_4x3 = 1,
    MFVideoFlag_PAD_TO_16x9 = 2,
    MFVideoFlag_SrcContentHintMask = 28,
    MFVideoFlag_SrcContentHintNone = 0,
    MFVideoFlag_SrcContentHint16x9 = 4,
    MFVideoFlag_SrcContentHint235_1 = 8,
    MFVideoFlag_AnalogProtected = 32,
    MFVideoFlag_DigitallyProtected = 64,
    MFVideoFlag_ProgressiveContent = 128,
    MFVideoFlag_FieldRepeatCountMask = 1792,
    MFVideoFlag_FieldRepeatCountShift = 8,
    MFVideoFlag_ProgressiveSeqReset = 2048,
    MFVideoFlag_PanScanEnabled = 131072,
    MFVideoFlag_LowerFieldFirst = 262144,
    MFVideoFlag_BottomUpLinearRep = 524288,
    DXVASurface = 1048576,
    RenderTargetSurface = 4194304,
    ForceQWORD = 2147483647,
};
pub const MFVideoFlag_PAD_TO_Mask = MFVideoFlags.MFVideoFlag_PAD_TO_Mask;
pub const MFVideoFlag_PAD_TO_None = MFVideoFlags.MFVideoFlag_PAD_TO_None;
pub const MFVideoFlag_PAD_TO_4x3 = MFVideoFlags.MFVideoFlag_PAD_TO_4x3;
pub const MFVideoFlag_PAD_TO_16x9 = MFVideoFlags.MFVideoFlag_PAD_TO_16x9;
pub const MFVideoFlag_SrcContentHintMask = MFVideoFlags.MFVideoFlag_SrcContentHintMask;
pub const MFVideoFlag_SrcContentHintNone = MFVideoFlags.MFVideoFlag_SrcContentHintNone;
pub const MFVideoFlag_SrcContentHint16x9 = MFVideoFlags.MFVideoFlag_SrcContentHint16x9;
pub const MFVideoFlag_SrcContentHint235_1 = MFVideoFlags.MFVideoFlag_SrcContentHint235_1;
pub const MFVideoFlag_AnalogProtected = MFVideoFlags.MFVideoFlag_AnalogProtected;
pub const MFVideoFlag_DigitallyProtected = MFVideoFlags.MFVideoFlag_DigitallyProtected;
pub const MFVideoFlag_ProgressiveContent = MFVideoFlags.MFVideoFlag_ProgressiveContent;
pub const MFVideoFlag_FieldRepeatCountMask = MFVideoFlags.MFVideoFlag_FieldRepeatCountMask;
pub const MFVideoFlag_FieldRepeatCountShift = MFVideoFlags.MFVideoFlag_FieldRepeatCountShift;
pub const MFVideoFlag_ProgressiveSeqReset = MFVideoFlags.MFVideoFlag_ProgressiveSeqReset;
pub const MFVideoFlag_PanScanEnabled = MFVideoFlags.MFVideoFlag_PanScanEnabled;
pub const MFVideoFlag_LowerFieldFirst = MFVideoFlags.MFVideoFlag_LowerFieldFirst;
pub const MFVideoFlag_BottomUpLinearRep = MFVideoFlags.MFVideoFlag_BottomUpLinearRep;
pub const MFVideoFlags_DXVASurface = MFVideoFlags.DXVASurface;
pub const MFVideoFlags_RenderTargetSurface = MFVideoFlags.RenderTargetSurface;
pub const MFVideoFlags_ForceQWORD = MFVideoFlags.ForceQWORD;

pub const MFRatio = extern struct {
    Numerator: u32,
    Denominator: u32,
};

pub const MFOffset = extern struct {
    fract: u16,
    value: i16,
};

pub const MFVideoArea = extern struct {
    OffsetX: MFOffset,
    OffsetY: MFOffset,
    Area: SIZE,
};

pub const MFVideoInfo = extern struct {
    dwWidth: u32,
    dwHeight: u32,
    PixelAspectRatio: MFRatio,
    SourceChromaSubsampling: MFVideoChromaSubsampling,
    InterlaceMode: MFVideoInterlaceMode,
    TransferFunction: MFVideoTransferFunction,
    ColorPrimaries: MFVideoPrimaries,
    TransferMatrix: MFVideoTransferMatrix,
    SourceLighting: MFVideoLighting,
    FramesPerSecond: MFRatio,
    NominalRange: MFNominalRange,
    GeometricAperture: MFVideoArea,
    MinimumDisplayAperture: MFVideoArea,
    PanScanAperture: MFVideoArea,
    VideoFlags: u64,
};

pub const MFAYUVSample = extern struct {
    bCrValue: u8,
    bCbValue: u8,
    bYValue: u8,
    bSampleAlpha8: u8,
};

pub const MFARGB = extern struct {
    rgbBlue: u8,
    rgbGreen: u8,
    rgbRed: u8,
    rgbAlpha: u8,
};

pub const MFPaletteEntry = u32; // TODO: implement StructOrUnion types?

pub const MFVideoSurfaceInfo = extern struct {
    Format: u32,
    PaletteEntries: u32,
    Palette: [1]MFPaletteEntry,
};

pub const MFVideoCompressedInfo = extern struct {
    AvgBitrate: i64,
    AvgBitErrorRate: i64,
    MaxKeyFrameSpacing: u32,
};

pub const MFVIDEOFORMAT = extern struct {
    dwSize: u32,
    videoInfo: MFVideoInfo,
    guidFormat: Guid,
    compressedInfo: MFVideoCompressedInfo,
    surfaceInfo: MFVideoSurfaceInfo,
};

pub const MFStandardVideoFormat = extern enum(i32) {
    MFStdVideoFormat_reserved = 0,
    MFStdVideoFormat_NTSC = 1,
    MFStdVideoFormat_PAL = 2,
    MFStdVideoFormat_DVD_NTSC = 3,
    MFStdVideoFormat_DVD_PAL = 4,
    MFStdVideoFormat_DV_PAL = 5,
    MFStdVideoFormat_DV_NTSC = 6,
    MFStdVideoFormat_ATSC_SD480i = 7,
    MFStdVideoFormat_ATSC_HD1080i = 8,
    MFStdVideoFormat_ATSC_HD720p = 9,
};
pub const MFStdVideoFormat_reserved = MFStandardVideoFormat.MFStdVideoFormat_reserved;
pub const MFStdVideoFormat_NTSC = MFStandardVideoFormat.MFStdVideoFormat_NTSC;
pub const MFStdVideoFormat_PAL = MFStandardVideoFormat.MFStdVideoFormat_PAL;
pub const MFStdVideoFormat_DVD_NTSC = MFStandardVideoFormat.MFStdVideoFormat_DVD_NTSC;
pub const MFStdVideoFormat_DVD_PAL = MFStandardVideoFormat.MFStdVideoFormat_DVD_PAL;
pub const MFStdVideoFormat_DV_PAL = MFStandardVideoFormat.MFStdVideoFormat_DV_PAL;
pub const MFStdVideoFormat_DV_NTSC = MFStandardVideoFormat.MFStdVideoFormat_DV_NTSC;
pub const MFStdVideoFormat_ATSC_SD480i = MFStandardVideoFormat.MFStdVideoFormat_ATSC_SD480i;
pub const MFStdVideoFormat_ATSC_HD1080i = MFStandardVideoFormat.MFStdVideoFormat_ATSC_HD1080i;
pub const MFStdVideoFormat_ATSC_HD720p = MFStandardVideoFormat.MFStdVideoFormat_ATSC_HD720p;

const IID_IMFVideoMediaType_Value = @import("../zig.zig").Guid.initString("B99F381F-A8F9-47A2-A5AF-CA3A225A3890");
pub const IID_IMFVideoMediaType = &IID_IMFVideoMediaType_Value;
pub const IMFVideoMediaType = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaType.VTable,
        GetVideoFormat: fn(
            self: *const IMFVideoMediaType,
        ) callconv(@import("std").os.windows.WINAPI) *MFVIDEOFORMAT,
        GetVideoRepresentation: fn(
            self: *const IMFVideoMediaType,
            guidRepresentation: Guid,
            ppvRepresentation: **c_void,
            lStride: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMediaType_GetVideoFormat(self: *const T) callconv(.Inline) *MFVIDEOFORMAT {
            return @ptrCast(*const IMFVideoMediaType.VTable, self.vtable).GetVideoFormat(@ptrCast(*const IMFVideoMediaType, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMediaType_GetVideoRepresentation(self: *const T, guidRepresentation: Guid, ppvRepresentation: **c_void, lStride: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMediaType.VTable, self.vtable).GetVideoRepresentation(@ptrCast(*const IMFVideoMediaType, self), guidRepresentation, ppvRepresentation, lStride);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFAsyncResult_Value = @import("../zig.zig").Guid.initString("AC6B7889-0740-4D51-8619-905994A55CC6");
pub const IID_IMFAsyncResult = &IID_IMFAsyncResult_Value;
pub const IMFAsyncResult = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetState: fn(
            self: *const IMFAsyncResult,
            ppunkState: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IMFAsyncResult,
            hrStatus: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const IMFAsyncResult,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStateNoAddRef: fn(
            self: *const IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) *IUnknown,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAsyncResult_GetState(self: *const T, ppunkState: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAsyncResult.VTable, self.vtable).GetState(@ptrCast(*const IMFAsyncResult, self), ppunkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAsyncResult_GetStatus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAsyncResult.VTable, self.vtable).GetStatus(@ptrCast(*const IMFAsyncResult, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAsyncResult_SetStatus(self: *const T, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAsyncResult.VTable, self.vtable).SetStatus(@ptrCast(*const IMFAsyncResult, self), hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAsyncResult_GetObject(self: *const T, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAsyncResult.VTable, self.vtable).GetObject(@ptrCast(*const IMFAsyncResult, self), ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAsyncResult_GetStateNoAddRef(self: *const T) callconv(.Inline) *IUnknown {
            return @ptrCast(*const IMFAsyncResult.VTable, self.vtable).GetStateNoAddRef(@ptrCast(*const IMFAsyncResult, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFAsyncCallback_Value = @import("../zig.zig").Guid.initString("A27003CF-2354-4F2A-8D6A-AB7CFF15437E");
pub const IID_IMFAsyncCallback = &IID_IMFAsyncCallback_Value;
pub const IMFAsyncCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetParameters: fn(
            self: *const IMFAsyncCallback,
            pdwFlags: *u32,
            pdwQueue: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const IMFAsyncCallback,
            pAsyncResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAsyncCallback_GetParameters(self: *const T, pdwFlags: *u32, pdwQueue: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAsyncCallback.VTable, self.vtable).GetParameters(@ptrCast(*const IMFAsyncCallback, self), pdwFlags, pdwQueue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAsyncCallback_Invoke(self: *const T, pAsyncResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAsyncCallback.VTable, self.vtable).Invoke(@ptrCast(*const IMFAsyncCallback, self), pAsyncResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFAsyncCallbackLogging_Value = @import("../zig.zig").Guid.initString("C7A4DCA1-F5F0-47B6-B92B-BF0106D25791");
pub const IID_IMFAsyncCallbackLogging = &IID_IMFAsyncCallbackLogging_Value;
pub const IMFAsyncCallbackLogging = extern struct {
    pub const VTable = extern struct {
        base: IMFAsyncCallback.VTable,
        GetObjectPointer: fn(
            self: *const IMFAsyncCallbackLogging,
        ) callconv(@import("std").os.windows.WINAPI) *c_void,
        GetObjectTag: fn(
            self: *const IMFAsyncCallbackLogging,
        ) callconv(@import("std").os.windows.WINAPI) u32,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAsyncCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAsyncCallbackLogging_GetObjectPointer(self: *const T) callconv(.Inline) *c_void {
            return @ptrCast(*const IMFAsyncCallbackLogging.VTable, self.vtable).GetObjectPointer(@ptrCast(*const IMFAsyncCallbackLogging, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAsyncCallbackLogging_GetObjectTag(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFAsyncCallbackLogging.VTable, self.vtable).GetObjectTag(@ptrCast(*const IMFAsyncCallbackLogging, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_mfobjects_0000_0012_0001 = extern enum(i32) {
    MEUnknown = 0,
    MEError = 1,
    MEExtendedType = 2,
    MENonFatalError = 3,
    MEGenericV1Anchor = 3,
    MESessionUnknown = 100,
    MESessionTopologySet = 101,
    MESessionTopologiesCleared = 102,
    MESessionStarted = 103,
    MESessionPaused = 104,
    MESessionStopped = 105,
    MESessionClosed = 106,
    MESessionEnded = 107,
    MESessionRateChanged = 108,
    MESessionScrubSampleComplete = 109,
    MESessionCapabilitiesChanged = 110,
    MESessionTopologyStatus = 111,
    MESessionNotifyPresentationTime = 112,
    MENewPresentation = 113,
    MELicenseAcquisitionStart = 114,
    MELicenseAcquisitionCompleted = 115,
    MEIndividualizationStart = 116,
    MEIndividualizationCompleted = 117,
    MEEnablerProgress = 118,
    MEEnablerCompleted = 119,
    MEPolicyError = 120,
    MEPolicyReport = 121,
    MEBufferingStarted = 122,
    MEBufferingStopped = 123,
    MEConnectStart = 124,
    MEConnectEnd = 125,
    MEReconnectStart = 126,
    MEReconnectEnd = 127,
    MERendererEvent = 128,
    MESessionStreamSinkFormatChanged = 129,
    MESessionV1Anchor = 129,
    MESourceUnknown = 200,
    MESourceStarted = 201,
    MEStreamStarted = 202,
    MESourceSeeked = 203,
    MEStreamSeeked = 204,
    MENewStream = 205,
    MEUpdatedStream = 206,
    MESourceStopped = 207,
    MEStreamStopped = 208,
    MESourcePaused = 209,
    MEStreamPaused = 210,
    MEEndOfPresentation = 211,
    MEEndOfStream = 212,
    MEMediaSample = 213,
    MEStreamTick = 214,
    MEStreamThinMode = 215,
    MEStreamFormatChanged = 216,
    MESourceRateChanged = 217,
    MEEndOfPresentationSegment = 218,
    MESourceCharacteristicsChanged = 219,
    MESourceRateChangeRequested = 220,
    MESourceMetadataChanged = 221,
    MESequencerSourceTopologyUpdated = 222,
    MESourceV1Anchor = 222,
    MESinkUnknown = 300,
    MEStreamSinkStarted = 301,
    MEStreamSinkStopped = 302,
    MEStreamSinkPaused = 303,
    MEStreamSinkRateChanged = 304,
    MEStreamSinkRequestSample = 305,
    MEStreamSinkMarker = 306,
    MEStreamSinkPrerolled = 307,
    MEStreamSinkScrubSampleComplete = 308,
    MEStreamSinkFormatChanged = 309,
    MEStreamSinkDeviceChanged = 310,
    MEQualityNotify = 311,
    MESinkInvalidated = 312,
    MEAudioSessionNameChanged = 313,
    MEAudioSessionVolumeChanged = 314,
    MEAudioSessionDeviceRemoved = 315,
    MEAudioSessionServerShutdown = 316,
    MEAudioSessionGroupingParamChanged = 317,
    MEAudioSessionIconChanged = 318,
    MEAudioSessionFormatChanged = 319,
    MEAudioSessionDisconnected = 320,
    MEAudioSessionExclusiveModeOverride = 321,
    MESinkV1Anchor = 321,
    MECaptureAudioSessionVolumeChanged = 322,
    MECaptureAudioSessionDeviceRemoved = 323,
    MECaptureAudioSessionFormatChanged = 324,
    MECaptureAudioSessionDisconnected = 325,
    MECaptureAudioSessionExclusiveModeOverride = 326,
    MECaptureAudioSessionServerShutdown = 327,
    MESinkV2Anchor = 327,
    METrustUnknown = 400,
    MEPolicyChanged = 401,
    MEContentProtectionMessage = 402,
    MEPolicySet = 403,
    METrustV1Anchor = 403,
    MEWMDRMLicenseBackupCompleted = 500,
    MEWMDRMLicenseBackupProgress = 501,
    MEWMDRMLicenseRestoreCompleted = 502,
    MEWMDRMLicenseRestoreProgress = 503,
    MEWMDRMLicenseAcquisitionCompleted = 506,
    MEWMDRMIndividualizationCompleted = 508,
    MEWMDRMIndividualizationProgress = 513,
    MEWMDRMProximityCompleted = 514,
    MEWMDRMLicenseStoreCleaned = 515,
    MEWMDRMRevocationDownloadCompleted = 516,
    MEWMDRMV1Anchor = 516,
    METransformUnknown = 600,
    METransformNeedInput = 601,
    METransformHaveOutput = 602,
    METransformDrainComplete = 603,
    METransformMarker = 604,
    METransformInputStreamStateChanged = 605,
    MEByteStreamCharacteristicsChanged = 700,
    MEVideoCaptureDeviceRemoved = 800,
    MEVideoCaptureDevicePreempted = 801,
    MEStreamSinkFormatInvalidated = 802,
    MEEncodingParameters = 803,
    MEContentProtectionMetadata = 900,
    MEDeviceThermalStateChanged = 950,
    MEReservedMax = 10000,
};
pub const MEUnknown = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEUnknown;
pub const MEError = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEError;
pub const MEExtendedType = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEExtendedType;
pub const MENonFatalError = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MENonFatalError;
pub const MEGenericV1Anchor = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEGenericV1Anchor;
pub const MESessionUnknown = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionUnknown;
pub const MESessionTopologySet = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionTopologySet;
pub const MESessionTopologiesCleared = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionTopologiesCleared;
pub const MESessionStarted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionStarted;
pub const MESessionPaused = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionPaused;
pub const MESessionStopped = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionStopped;
pub const MESessionClosed = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionClosed;
pub const MESessionEnded = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionEnded;
pub const MESessionRateChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionRateChanged;
pub const MESessionScrubSampleComplete = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionScrubSampleComplete;
pub const MESessionCapabilitiesChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionCapabilitiesChanged;
pub const MESessionTopologyStatus = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionTopologyStatus;
pub const MESessionNotifyPresentationTime = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionNotifyPresentationTime;
pub const MENewPresentation = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MENewPresentation;
pub const MELicenseAcquisitionStart = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MELicenseAcquisitionStart;
pub const MELicenseAcquisitionCompleted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MELicenseAcquisitionCompleted;
pub const MEIndividualizationStart = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEIndividualizationStart;
pub const MEIndividualizationCompleted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEIndividualizationCompleted;
pub const MEEnablerProgress = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEEnablerProgress;
pub const MEEnablerCompleted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEEnablerCompleted;
pub const MEPolicyError = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEPolicyError;
pub const MEPolicyReport = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEPolicyReport;
pub const MEBufferingStarted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEBufferingStarted;
pub const MEBufferingStopped = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEBufferingStopped;
pub const MEConnectStart = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEConnectStart;
pub const MEConnectEnd = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEConnectEnd;
pub const MEReconnectStart = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEReconnectStart;
pub const MEReconnectEnd = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEReconnectEnd;
pub const MERendererEvent = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MERendererEvent;
pub const MESessionStreamSinkFormatChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionStreamSinkFormatChanged;
pub const MESessionV1Anchor = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESessionV1Anchor;
pub const MESourceUnknown = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourceUnknown;
pub const MESourceStarted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourceStarted;
pub const MEStreamStarted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamStarted;
pub const MESourceSeeked = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourceSeeked;
pub const MEStreamSeeked = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSeeked;
pub const MENewStream = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MENewStream;
pub const MEUpdatedStream = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEUpdatedStream;
pub const MESourceStopped = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourceStopped;
pub const MEStreamStopped = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamStopped;
pub const MESourcePaused = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourcePaused;
pub const MEStreamPaused = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamPaused;
pub const MEEndOfPresentation = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEEndOfPresentation;
pub const MEEndOfStream = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEEndOfStream;
pub const MEMediaSample = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEMediaSample;
pub const MEStreamTick = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamTick;
pub const MEStreamThinMode = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamThinMode;
pub const MEStreamFormatChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamFormatChanged;
pub const MESourceRateChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourceRateChanged;
pub const MEEndOfPresentationSegment = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEEndOfPresentationSegment;
pub const MESourceCharacteristicsChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourceCharacteristicsChanged;
pub const MESourceRateChangeRequested = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourceRateChangeRequested;
pub const MESourceMetadataChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourceMetadataChanged;
pub const MESequencerSourceTopologyUpdated = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESequencerSourceTopologyUpdated;
pub const MESourceV1Anchor = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESourceV1Anchor;
pub const MESinkUnknown = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESinkUnknown;
pub const MEStreamSinkStarted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkStarted;
pub const MEStreamSinkStopped = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkStopped;
pub const MEStreamSinkPaused = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkPaused;
pub const MEStreamSinkRateChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkRateChanged;
pub const MEStreamSinkRequestSample = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkRequestSample;
pub const MEStreamSinkMarker = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkMarker;
pub const MEStreamSinkPrerolled = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkPrerolled;
pub const MEStreamSinkScrubSampleComplete = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkScrubSampleComplete;
pub const MEStreamSinkFormatChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkFormatChanged;
pub const MEStreamSinkDeviceChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkDeviceChanged;
pub const MEQualityNotify = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEQualityNotify;
pub const MESinkInvalidated = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESinkInvalidated;
pub const MEAudioSessionNameChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEAudioSessionNameChanged;
pub const MEAudioSessionVolumeChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEAudioSessionVolumeChanged;
pub const MEAudioSessionDeviceRemoved = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEAudioSessionDeviceRemoved;
pub const MEAudioSessionServerShutdown = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEAudioSessionServerShutdown;
pub const MEAudioSessionGroupingParamChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEAudioSessionGroupingParamChanged;
pub const MEAudioSessionIconChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEAudioSessionIconChanged;
pub const MEAudioSessionFormatChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEAudioSessionFormatChanged;
pub const MEAudioSessionDisconnected = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEAudioSessionDisconnected;
pub const MEAudioSessionExclusiveModeOverride = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEAudioSessionExclusiveModeOverride;
pub const MESinkV1Anchor = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESinkV1Anchor;
pub const MECaptureAudioSessionVolumeChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MECaptureAudioSessionVolumeChanged;
pub const MECaptureAudioSessionDeviceRemoved = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MECaptureAudioSessionDeviceRemoved;
pub const MECaptureAudioSessionFormatChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MECaptureAudioSessionFormatChanged;
pub const MECaptureAudioSessionDisconnected = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MECaptureAudioSessionDisconnected;
pub const MECaptureAudioSessionExclusiveModeOverride = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MECaptureAudioSessionExclusiveModeOverride;
pub const MECaptureAudioSessionServerShutdown = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MECaptureAudioSessionServerShutdown;
pub const MESinkV2Anchor = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MESinkV2Anchor;
pub const METrustUnknown = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.METrustUnknown;
pub const MEPolicyChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEPolicyChanged;
pub const MEContentProtectionMessage = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEContentProtectionMessage;
pub const MEPolicySet = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEPolicySet;
pub const METrustV1Anchor = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.METrustV1Anchor;
pub const MEWMDRMLicenseBackupCompleted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMLicenseBackupCompleted;
pub const MEWMDRMLicenseBackupProgress = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMLicenseBackupProgress;
pub const MEWMDRMLicenseRestoreCompleted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMLicenseRestoreCompleted;
pub const MEWMDRMLicenseRestoreProgress = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMLicenseRestoreProgress;
pub const MEWMDRMLicenseAcquisitionCompleted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMLicenseAcquisitionCompleted;
pub const MEWMDRMIndividualizationCompleted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMIndividualizationCompleted;
pub const MEWMDRMIndividualizationProgress = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMIndividualizationProgress;
pub const MEWMDRMProximityCompleted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMProximityCompleted;
pub const MEWMDRMLicenseStoreCleaned = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMLicenseStoreCleaned;
pub const MEWMDRMRevocationDownloadCompleted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMRevocationDownloadCompleted;
pub const MEWMDRMV1Anchor = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEWMDRMV1Anchor;
pub const METransformUnknown = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.METransformUnknown;
pub const METransformNeedInput = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.METransformNeedInput;
pub const METransformHaveOutput = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.METransformHaveOutput;
pub const METransformDrainComplete = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.METransformDrainComplete;
pub const METransformMarker = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.METransformMarker;
pub const METransformInputStreamStateChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.METransformInputStreamStateChanged;
pub const MEByteStreamCharacteristicsChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEByteStreamCharacteristicsChanged;
pub const MEVideoCaptureDeviceRemoved = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEVideoCaptureDeviceRemoved;
pub const MEVideoCaptureDevicePreempted = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEVideoCaptureDevicePreempted;
pub const MEStreamSinkFormatInvalidated = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEStreamSinkFormatInvalidated;
pub const MEEncodingParameters = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEEncodingParameters;
pub const MEContentProtectionMetadata = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEContentProtectionMetadata;
pub const MEDeviceThermalStateChanged = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEDeviceThermalStateChanged;
pub const MEReservedMax = __MIDL___MIDL_itf_mfobjects_0000_0012_0001.MEReservedMax;

const IID_IMFMediaEvent_Value = @import("../zig.zig").Guid.initString("DF598932-F10C-4E39-BBA2-C308F101DAA3");
pub const IID_IMFMediaEvent = &IID_IMFMediaEvent_Value;
pub const IMFMediaEvent = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetType: fn(
            self: *const IMFMediaEvent,
            pmet: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtendedType: fn(
            self: *const IMFMediaEvent,
            pguidExtendedType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatus: fn(
            self: *const IMFMediaEvent,
            phrStatus: *HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IMFMediaEvent,
            pvValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEvent_GetType(self: *const T, pmet: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEvent.VTable, self.vtable).GetType(@ptrCast(*const IMFMediaEvent, self), pmet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEvent_GetExtendedType(self: *const T, pguidExtendedType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEvent.VTable, self.vtable).GetExtendedType(@ptrCast(*const IMFMediaEvent, self), pguidExtendedType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEvent_GetStatus(self: *const T, phrStatus: *HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEvent.VTable, self.vtable).GetStatus(@ptrCast(*const IMFMediaEvent, self), phrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEvent_GetValue(self: *const T, pvValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEvent.VTable, self.vtable).GetValue(@ptrCast(*const IMFMediaEvent, self), pvValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEventGenerator_Value = @import("../zig.zig").Guid.initString("2CD0BD52-BCD5-4B89-B62C-EADC0C031E7D");
pub const IID_IMFMediaEventGenerator = &IID_IMFMediaEventGenerator_Value;
pub const IMFMediaEventGenerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: fn(
            self: *const IMFMediaEventGenerator,
            dwFlags: u32,
            ppEvent: **IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginGetEvent: fn(
            self: *const IMFMediaEventGenerator,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndGetEvent: fn(
            self: *const IMFMediaEventGenerator,
            pResult: *IMFAsyncResult,
            ppEvent: **IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueueEvent: fn(
            self: *const IMFMediaEventGenerator,
            met: u32,
            guidExtendedType: *const Guid,
            hrStatus: HRESULT,
            pvValue: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventGenerator_GetEvent(self: *const T, dwFlags: u32, ppEvent: **IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventGenerator.VTable, self.vtable).GetEvent(@ptrCast(*const IMFMediaEventGenerator, self), dwFlags, ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventGenerator_BeginGetEvent(self: *const T, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventGenerator.VTable, self.vtable).BeginGetEvent(@ptrCast(*const IMFMediaEventGenerator, self), pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventGenerator_EndGetEvent(self: *const T, pResult: *IMFAsyncResult, ppEvent: **IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventGenerator.VTable, self.vtable).EndGetEvent(@ptrCast(*const IMFMediaEventGenerator, self), pResult, ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventGenerator_QueueEvent(self: *const T, met: u32, guidExtendedType: *const Guid, hrStatus: HRESULT, pvValue: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventGenerator.VTable, self.vtable).QueueEvent(@ptrCast(*const IMFMediaEventGenerator, self), met, guidExtendedType, hrStatus, pvValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFRemoteAsyncCallback_Value = @import("../zig.zig").Guid.initString("A27003D0-2354-4F2A-8D6A-AB7CFF15437E");
pub const IID_IMFRemoteAsyncCallback = &IID_IMFRemoteAsyncCallback_Value;
pub const IMFRemoteAsyncCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invoke: fn(
            self: *const IMFRemoteAsyncCallback,
            hr: HRESULT,
            pRemoteResult: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRemoteAsyncCallback_Invoke(self: *const T, hr: HRESULT, pRemoteResult: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRemoteAsyncCallback.VTable, self.vtable).Invoke(@ptrCast(*const IMFRemoteAsyncCallback, self), hr, pRemoteResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFBYTESTREAM_SEEK_ORIGIN = extern enum(i32) {
    msoBegin = 0,
    msoCurrent = 1,
};
pub const msoBegin = MFBYTESTREAM_SEEK_ORIGIN.msoBegin;
pub const msoCurrent = MFBYTESTREAM_SEEK_ORIGIN.msoCurrent;

const IID_IMFByteStream_Value = @import("../zig.zig").Guid.initString("AD4C1B00-4BF7-422F-9175-756693D9130D");
pub const IID_IMFByteStream = &IID_IMFByteStream_Value;
pub const IMFByteStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilities: fn(
            self: *const IMFByteStream,
            pdwCapabilities: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLength: fn(
            self: *const IMFByteStream,
            pqwLength: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLength: fn(
            self: *const IMFByteStream,
            qwLength: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPosition: fn(
            self: *const IMFByteStream,
            pqwPosition: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentPosition: fn(
            self: *const IMFByteStream,
            qwPosition: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEndOfStream: fn(
            self: *const IMFByteStream,
            pfEndOfStream: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Read: fn(
            self: *const IMFByteStream,
            pb: [*:0]u8,
            cb: u32,
            pcbRead: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginRead: fn(
            self: *const IMFByteStream,
            pb: [*:0]u8,
            cb: u32,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndRead: fn(
            self: *const IMFByteStream,
            pResult: *IMFAsyncResult,
            pcbRead: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Write: fn(
            self: *const IMFByteStream,
            pb: [*:0]const u8,
            cb: u32,
            pcbWritten: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginWrite: fn(
            self: *const IMFByteStream,
            pb: [*:0]const u8,
            cb: u32,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndWrite: fn(
            self: *const IMFByteStream,
            pResult: *IMFAsyncResult,
            pcbWritten: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Seek: fn(
            self: *const IMFByteStream,
            SeekOrigin: MFBYTESTREAM_SEEK_ORIGIN,
            llSeekOffset: i64,
            dwSeekFlags: u32,
            pqwCurrentPosition: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IMFByteStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IMFByteStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_GetCapabilities(self: *const T, pdwCapabilities: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).GetCapabilities(@ptrCast(*const IMFByteStream, self), pdwCapabilities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_GetLength(self: *const T, pqwLength: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).GetLength(@ptrCast(*const IMFByteStream, self), pqwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_SetLength(self: *const T, qwLength: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).SetLength(@ptrCast(*const IMFByteStream, self), qwLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_GetCurrentPosition(self: *const T, pqwPosition: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).GetCurrentPosition(@ptrCast(*const IMFByteStream, self), pqwPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_SetCurrentPosition(self: *const T, qwPosition: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).SetCurrentPosition(@ptrCast(*const IMFByteStream, self), qwPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_IsEndOfStream(self: *const T, pfEndOfStream: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).IsEndOfStream(@ptrCast(*const IMFByteStream, self), pfEndOfStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_Read(self: *const T, pb: [*:0]u8, cb: u32, pcbRead: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).Read(@ptrCast(*const IMFByteStream, self), pb, cb, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_BeginRead(self: *const T, pb: [*:0]u8, cb: u32, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).BeginRead(@ptrCast(*const IMFByteStream, self), pb, cb, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_EndRead(self: *const T, pResult: *IMFAsyncResult, pcbRead: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).EndRead(@ptrCast(*const IMFByteStream, self), pResult, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_Write(self: *const T, pb: [*:0]const u8, cb: u32, pcbWritten: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).Write(@ptrCast(*const IMFByteStream, self), pb, cb, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_BeginWrite(self: *const T, pb: [*:0]const u8, cb: u32, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).BeginWrite(@ptrCast(*const IMFByteStream, self), pb, cb, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_EndWrite(self: *const T, pResult: *IMFAsyncResult, pcbWritten: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).EndWrite(@ptrCast(*const IMFByteStream, self), pResult, pcbWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_Seek(self: *const T, SeekOrigin: MFBYTESTREAM_SEEK_ORIGIN, llSeekOffset: i64, dwSeekFlags: u32, pqwCurrentPosition: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).Seek(@ptrCast(*const IMFByteStream, self), SeekOrigin, llSeekOffset, dwSeekFlags, pqwCurrentPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).Flush(@ptrCast(*const IMFByteStream, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStream_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStream.VTable, self.vtable).Close(@ptrCast(*const IMFByteStream, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFByteStreamProxyClassFactory_Value = @import("../zig.zig").Guid.initString("A6B43F84-5C0A-42E8-A44D-B1857A76992F");
pub const IID_IMFByteStreamProxyClassFactory = &IID_IMFByteStreamProxyClassFactory_Value;
pub const IMFByteStreamProxyClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateByteStreamProxy: fn(
            self: *const IMFByteStreamProxyClassFactory,
            pByteStream: *IMFByteStream,
            pAttributes: *IMFAttributes,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamProxyClassFactory_CreateByteStreamProxy(self: *const T, pByteStream: *IMFByteStream, pAttributes: *IMFAttributes, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamProxyClassFactory.VTable, self.vtable).CreateByteStreamProxy(@ptrCast(*const IMFByteStreamProxyClassFactory, self), pByteStream, pAttributes, riid, ppvObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_FILE_ACCESSMODE = extern enum(i32) {
    MF_ACCESSMODE_READ = 1,
    MF_ACCESSMODE_WRITE = 2,
    MF_ACCESSMODE_READWRITE = 3,
};
pub const MF_ACCESSMODE_READ = MF_FILE_ACCESSMODE.MF_ACCESSMODE_READ;
pub const MF_ACCESSMODE_WRITE = MF_FILE_ACCESSMODE.MF_ACCESSMODE_WRITE;
pub const MF_ACCESSMODE_READWRITE = MF_FILE_ACCESSMODE.MF_ACCESSMODE_READWRITE;

pub const MF_FILE_OPENMODE = extern enum(i32) {
    MF_OPENMODE_FAIL_IF_NOT_EXIST = 0,
    MF_OPENMODE_FAIL_IF_EXIST = 1,
    MF_OPENMODE_RESET_IF_EXIST = 2,
    MF_OPENMODE_APPEND_IF_EXIST = 3,
    MF_OPENMODE_DELETE_IF_EXIST = 4,
};
pub const MF_OPENMODE_FAIL_IF_NOT_EXIST = MF_FILE_OPENMODE.MF_OPENMODE_FAIL_IF_NOT_EXIST;
pub const MF_OPENMODE_FAIL_IF_EXIST = MF_FILE_OPENMODE.MF_OPENMODE_FAIL_IF_EXIST;
pub const MF_OPENMODE_RESET_IF_EXIST = MF_FILE_OPENMODE.MF_OPENMODE_RESET_IF_EXIST;
pub const MF_OPENMODE_APPEND_IF_EXIST = MF_FILE_OPENMODE.MF_OPENMODE_APPEND_IF_EXIST;
pub const MF_OPENMODE_DELETE_IF_EXIST = MF_FILE_OPENMODE.MF_OPENMODE_DELETE_IF_EXIST;

pub const MF_FILE_FLAGS = extern enum(i32) {
    MF_FILEFLAGS_NONE = 0,
    MF_FILEFLAGS_NOBUFFERING = 1,
    MF_FILEFLAGS_ALLOW_WRITE_SHARING = 2,
};
pub const MF_FILEFLAGS_NONE = MF_FILE_FLAGS.MF_FILEFLAGS_NONE;
pub const MF_FILEFLAGS_NOBUFFERING = MF_FILE_FLAGS.MF_FILEFLAGS_NOBUFFERING;
pub const MF_FILEFLAGS_ALLOW_WRITE_SHARING = MF_FILE_FLAGS.MF_FILEFLAGS_ALLOW_WRITE_SHARING;

const IID_IMFSampleOutputStream_Value = @import("../zig.zig").Guid.initString("8FEED468-6F7E-440D-869A-49BDD283AD0D");
pub const IID_IMFSampleOutputStream = &IID_IMFSampleOutputStream_Value;
pub const IMFSampleOutputStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginWriteSample: fn(
            self: *const IMFSampleOutputStream,
            pSample: *IMFSample,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndWriteSample: fn(
            self: *const IMFSampleOutputStream,
            pResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IMFSampleOutputStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleOutputStream_BeginWriteSample(self: *const T, pSample: *IMFSample, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleOutputStream.VTable, self.vtable).BeginWriteSample(@ptrCast(*const IMFSampleOutputStream, self), pSample, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleOutputStream_EndWriteSample(self: *const T, pResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleOutputStream.VTable, self.vtable).EndWriteSample(@ptrCast(*const IMFSampleOutputStream, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleOutputStream_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleOutputStream.VTable, self.vtable).Close(@ptrCast(*const IMFSampleOutputStream, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCollection_Value = @import("../zig.zig").Guid.initString("5BC8A76B-869A-46A3-9B03-FA218A66AEBE");
pub const IID_IMFCollection = &IID_IMFCollection_Value;
pub const IMFCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetElementCount: fn(
            self: *const IMFCollection,
            pcElements: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElement: fn(
            self: *const IMFCollection,
            dwElementIndex: u32,
            ppUnkElement: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddElement: fn(
            self: *const IMFCollection,
            pUnkElement: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveElement: fn(
            self: *const IMFCollection,
            dwElementIndex: u32,
            ppUnkElement: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertElementAt: fn(
            self: *const IMFCollection,
            dwIndex: u32,
            pUnknown: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllElements: fn(
            self: *const IMFCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCollection_GetElementCount(self: *const T, pcElements: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCollection.VTable, self.vtable).GetElementCount(@ptrCast(*const IMFCollection, self), pcElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCollection_GetElement(self: *const T, dwElementIndex: u32, ppUnkElement: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCollection.VTable, self.vtable).GetElement(@ptrCast(*const IMFCollection, self), dwElementIndex, ppUnkElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCollection_AddElement(self: *const T, pUnkElement: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCollection.VTable, self.vtable).AddElement(@ptrCast(*const IMFCollection, self), pUnkElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCollection_RemoveElement(self: *const T, dwElementIndex: u32, ppUnkElement: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCollection.VTable, self.vtable).RemoveElement(@ptrCast(*const IMFCollection, self), dwElementIndex, ppUnkElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCollection_InsertElementAt(self: *const T, dwIndex: u32, pUnknown: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCollection.VTable, self.vtable).InsertElementAt(@ptrCast(*const IMFCollection, self), dwIndex, pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCollection_RemoveAllElements(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCollection.VTable, self.vtable).RemoveAllElements(@ptrCast(*const IMFCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEventQueue_Value = @import("../zig.zig").Guid.initString("36F846FC-2256-48B6-B58E-E2B638316581");
pub const IID_IMFMediaEventQueue = &IID_IMFMediaEventQueue_Value;
pub const IMFMediaEventQueue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEvent: fn(
            self: *const IMFMediaEventQueue,
            dwFlags: u32,
            ppEvent: **IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginGetEvent: fn(
            self: *const IMFMediaEventQueue,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndGetEvent: fn(
            self: *const IMFMediaEventQueue,
            pResult: *IMFAsyncResult,
            ppEvent: **IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueueEvent: fn(
            self: *const IMFMediaEventQueue,
            pEvent: *IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueueEventParamVar: fn(
            self: *const IMFMediaEventQueue,
            met: u32,
            guidExtendedType: *const Guid,
            hrStatus: HRESULT,
            pvValue: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueueEventParamUnk: fn(
            self: *const IMFMediaEventQueue,
            met: u32,
            guidExtendedType: *const Guid,
            hrStatus: HRESULT,
            pUnk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFMediaEventQueue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventQueue_GetEvent(self: *const T, dwFlags: u32, ppEvent: **IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventQueue.VTable, self.vtable).GetEvent(@ptrCast(*const IMFMediaEventQueue, self), dwFlags, ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventQueue_BeginGetEvent(self: *const T, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventQueue.VTable, self.vtable).BeginGetEvent(@ptrCast(*const IMFMediaEventQueue, self), pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventQueue_EndGetEvent(self: *const T, pResult: *IMFAsyncResult, ppEvent: **IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventQueue.VTable, self.vtable).EndGetEvent(@ptrCast(*const IMFMediaEventQueue, self), pResult, ppEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventQueue_QueueEvent(self: *const T, pEvent: *IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventQueue.VTable, self.vtable).QueueEvent(@ptrCast(*const IMFMediaEventQueue, self), pEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventQueue_QueueEventParamVar(self: *const T, met: u32, guidExtendedType: *const Guid, hrStatus: HRESULT, pvValue: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventQueue.VTable, self.vtable).QueueEventParamVar(@ptrCast(*const IMFMediaEventQueue, self), met, guidExtendedType, hrStatus, pvValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventQueue_QueueEventParamUnk(self: *const T, met: u32, guidExtendedType: *const Guid, hrStatus: HRESULT, pUnk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventQueue.VTable, self.vtable).QueueEventParamUnk(@ptrCast(*const IMFMediaEventQueue, self), met, guidExtendedType, hrStatus, pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEventQueue_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEventQueue.VTable, self.vtable).Shutdown(@ptrCast(*const IMFMediaEventQueue, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFActivate_Value = @import("../zig.zig").Guid.initString("7FEE9E9A-4A89-47A6-899C-B6A53A70FB67");
pub const IID_IMFActivate = &IID_IMFActivate_Value;
pub const IMFActivate = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        ActivateObject: fn(
            self: *const IMFActivate,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShutdownObject: fn(
            self: *const IMFActivate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachObject: fn(
            self: *const IMFActivate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFActivate_ActivateObject(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFActivate.VTable, self.vtable).ActivateObject(@ptrCast(*const IMFActivate, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFActivate_ShutdownObject(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFActivate.VTable, self.vtable).ShutdownObject(@ptrCast(*const IMFActivate, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFActivate_DetachObject(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFActivate.VTable, self.vtable).DetachObject(@ptrCast(*const IMFActivate, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPluginControl_Value = @import("../zig.zig").Guid.initString("5C6C44BF-1DB6-435B-9249-E8CD10FDEC96");
pub const IID_IMFPluginControl = &IID_IMFPluginControl_Value;
pub const IMFPluginControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPreferredClsid: fn(
            self: *const IMFPluginControl,
            pluginType: u32,
            selector: [*:0]const u16,
            clsid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredClsidByIndex: fn(
            self: *const IMFPluginControl,
            pluginType: u32,
            index: u32,
            selector: *PWSTR,
            clsid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreferredClsid: fn(
            self: *const IMFPluginControl,
            pluginType: u32,
            selector: [*:0]const u16,
            clsid: ?*const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDisabled: fn(
            self: *const IMFPluginControl,
            pluginType: u32,
            clsid: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisabledByIndex: fn(
            self: *const IMFPluginControl,
            pluginType: u32,
            index: u32,
            clsid: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisabled: fn(
            self: *const IMFPluginControl,
            pluginType: u32,
            clsid: *const Guid,
            disabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPluginControl_GetPreferredClsid(self: *const T, pluginType: u32, selector: [*:0]const u16, clsid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPluginControl.VTable, self.vtable).GetPreferredClsid(@ptrCast(*const IMFPluginControl, self), pluginType, selector, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPluginControl_GetPreferredClsidByIndex(self: *const T, pluginType: u32, index: u32, selector: *PWSTR, clsid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPluginControl.VTable, self.vtable).GetPreferredClsidByIndex(@ptrCast(*const IMFPluginControl, self), pluginType, index, selector, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPluginControl_SetPreferredClsid(self: *const T, pluginType: u32, selector: [*:0]const u16, clsid: ?*const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPluginControl.VTable, self.vtable).SetPreferredClsid(@ptrCast(*const IMFPluginControl, self), pluginType, selector, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPluginControl_IsDisabled(self: *const T, pluginType: u32, clsid: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPluginControl.VTable, self.vtable).IsDisabled(@ptrCast(*const IMFPluginControl, self), pluginType, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPluginControl_GetDisabledByIndex(self: *const T, pluginType: u32, index: u32, clsid: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPluginControl.VTable, self.vtable).GetDisabledByIndex(@ptrCast(*const IMFPluginControl, self), pluginType, index, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPluginControl_SetDisabled(self: *const T, pluginType: u32, clsid: *const Guid, disabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPluginControl.VTable, self.vtable).SetDisabled(@ptrCast(*const IMFPluginControl, self), pluginType, clsid, disabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_PLUGIN_CONTROL_POLICY = extern enum(i32) {
    USE_ALL_PLUGINS = 0,
    USE_APPROVED_PLUGINS = 1,
    USE_WEB_PLUGINS = 2,
    USE_WEB_PLUGINS_EDGEMODE = 3,
};
pub const MF_PLUGIN_CONTROL_POLICY_USE_ALL_PLUGINS = MF_PLUGIN_CONTROL_POLICY.USE_ALL_PLUGINS;
pub const MF_PLUGIN_CONTROL_POLICY_USE_APPROVED_PLUGINS = MF_PLUGIN_CONTROL_POLICY.USE_APPROVED_PLUGINS;
pub const MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS = MF_PLUGIN_CONTROL_POLICY.USE_WEB_PLUGINS;
pub const MF_PLUGIN_CONTROL_POLICY_USE_WEB_PLUGINS_EDGEMODE = MF_PLUGIN_CONTROL_POLICY.USE_WEB_PLUGINS_EDGEMODE;

const IID_IMFPluginControl2_Value = @import("../zig.zig").Guid.initString("C6982083-3DDC-45CB-AF5E-0F7A8CE4DE77");
pub const IID_IMFPluginControl2 = &IID_IMFPluginControl2_Value;
pub const IMFPluginControl2 = extern struct {
    pub const VTable = extern struct {
        base: IMFPluginControl.VTable,
        SetPolicy: fn(
            self: *const IMFPluginControl2,
            policy: MF_PLUGIN_CONTROL_POLICY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFPluginControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPluginControl2_SetPolicy(self: *const T, policy: MF_PLUGIN_CONTROL_POLICY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPluginControl2.VTable, self.vtable).SetPolicy(@ptrCast(*const IMFPluginControl2, self), policy);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFDXGIDeviceManager_Value = @import("../zig.zig").Guid.initString("EB533D5D-2DB6-40F8-97A9-494692014F07");
pub const IID_IMFDXGIDeviceManager = &IID_IMFDXGIDeviceManager_Value;
pub const IMFDXGIDeviceManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CloseDeviceHandle: fn(
            self: *const IMFDXGIDeviceManager,
            hDevice: HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoService: fn(
            self: *const IMFDXGIDeviceManager,
            hDevice: HANDLE,
            riid: *const Guid,
            ppService: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LockDevice: fn(
            self: *const IMFDXGIDeviceManager,
            hDevice: HANDLE,
            riid: *const Guid,
            ppUnkDevice: **c_void,
            fBlock: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDeviceHandle: fn(
            self: *const IMFDXGIDeviceManager,
            phDevice: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetDevice: fn(
            self: *const IMFDXGIDeviceManager,
            pUnkDevice: *IUnknown,
            resetToken: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TestDevice: fn(
            self: *const IMFDXGIDeviceManager,
            hDevice: HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockDevice: fn(
            self: *const IMFDXGIDeviceManager,
            hDevice: HANDLE,
            fSaveState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIDeviceManager_CloseDeviceHandle(self: *const T, hDevice: HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIDeviceManager.VTable, self.vtable).CloseDeviceHandle(@ptrCast(*const IMFDXGIDeviceManager, self), hDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIDeviceManager_GetVideoService(self: *const T, hDevice: HANDLE, riid: *const Guid, ppService: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIDeviceManager.VTable, self.vtable).GetVideoService(@ptrCast(*const IMFDXGIDeviceManager, self), hDevice, riid, ppService);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIDeviceManager_LockDevice(self: *const T, hDevice: HANDLE, riid: *const Guid, ppUnkDevice: **c_void, fBlock: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIDeviceManager.VTable, self.vtable).LockDevice(@ptrCast(*const IMFDXGIDeviceManager, self), hDevice, riid, ppUnkDevice, fBlock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIDeviceManager_OpenDeviceHandle(self: *const T, phDevice: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIDeviceManager.VTable, self.vtable).OpenDeviceHandle(@ptrCast(*const IMFDXGIDeviceManager, self), phDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIDeviceManager_ResetDevice(self: *const T, pUnkDevice: *IUnknown, resetToken: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIDeviceManager.VTable, self.vtable).ResetDevice(@ptrCast(*const IMFDXGIDeviceManager, self), pUnkDevice, resetToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIDeviceManager_TestDevice(self: *const T, hDevice: HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIDeviceManager.VTable, self.vtable).TestDevice(@ptrCast(*const IMFDXGIDeviceManager, self), hDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIDeviceManager_UnlockDevice(self: *const T, hDevice: HANDLE, fSaveState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIDeviceManager.VTable, self.vtable).UnlockDevice(@ptrCast(*const IMFDXGIDeviceManager, self), hDevice, fSaveState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_STREAM_STATE = extern enum(i32) {
    STOPPED = 0,
    PAUSED = 1,
    RUNNING = 2,
};
pub const MF_STREAM_STATE_STOPPED = MF_STREAM_STATE.STOPPED;
pub const MF_STREAM_STATE_PAUSED = MF_STREAM_STATE.PAUSED;
pub const MF_STREAM_STATE_RUNNING = MF_STREAM_STATE.RUNNING;

const IID_IMFMuxStreamAttributesManager_Value = @import("../zig.zig").Guid.initString("CE8BD576-E440-43B3-BE34-1E53F565F7E8");
pub const IID_IMFMuxStreamAttributesManager = &IID_IMFMuxStreamAttributesManager_Value;
pub const IMFMuxStreamAttributesManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: fn(
            self: *const IMFMuxStreamAttributesManager,
            pdwMuxStreamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributes: fn(
            self: *const IMFMuxStreamAttributesManager,
            dwMuxStreamIndex: u32,
            ppStreamAttributes: **IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamAttributesManager_GetStreamCount(self: *const T, pdwMuxStreamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamAttributesManager.VTable, self.vtable).GetStreamCount(@ptrCast(*const IMFMuxStreamAttributesManager, self), pdwMuxStreamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamAttributesManager_GetAttributes(self: *const T, dwMuxStreamIndex: u32, ppStreamAttributes: **IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamAttributesManager.VTable, self.vtable).GetAttributes(@ptrCast(*const IMFMuxStreamAttributesManager, self), dwMuxStreamIndex, ppStreamAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMuxStreamMediaTypeManager_Value = @import("../zig.zig").Guid.initString("505A2C72-42F7-4690-AEAB-8F513D0FFDB8");
pub const IID_IMFMuxStreamMediaTypeManager = &IID_IMFMuxStreamMediaTypeManager_Value;
pub const IMFMuxStreamMediaTypeManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: fn(
            self: *const IMFMuxStreamMediaTypeManager,
            pdwMuxStreamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaType: fn(
            self: *const IMFMuxStreamMediaTypeManager,
            dwMuxStreamIndex: u32,
            ppMediaType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamConfigurationCount: fn(
            self: *const IMFMuxStreamMediaTypeManager,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStreamConfiguration: fn(
            self: *const IMFMuxStreamMediaTypeManager,
            ullStreamMask: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStreamConfiguration: fn(
            self: *const IMFMuxStreamMediaTypeManager,
            ullStreamMask: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamConfiguration: fn(
            self: *const IMFMuxStreamMediaTypeManager,
            ulIndex: u32,
            pullStreamMask: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamMediaTypeManager_GetStreamCount(self: *const T, pdwMuxStreamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamMediaTypeManager.VTable, self.vtable).GetStreamCount(@ptrCast(*const IMFMuxStreamMediaTypeManager, self), pdwMuxStreamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamMediaTypeManager_GetMediaType(self: *const T, dwMuxStreamIndex: u32, ppMediaType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamMediaTypeManager.VTable, self.vtable).GetMediaType(@ptrCast(*const IMFMuxStreamMediaTypeManager, self), dwMuxStreamIndex, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamMediaTypeManager_GetStreamConfigurationCount(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamMediaTypeManager.VTable, self.vtable).GetStreamConfigurationCount(@ptrCast(*const IMFMuxStreamMediaTypeManager, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamMediaTypeManager_AddStreamConfiguration(self: *const T, ullStreamMask: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamMediaTypeManager.VTable, self.vtable).AddStreamConfiguration(@ptrCast(*const IMFMuxStreamMediaTypeManager, self), ullStreamMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamMediaTypeManager_RemoveStreamConfiguration(self: *const T, ullStreamMask: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamMediaTypeManager.VTable, self.vtable).RemoveStreamConfiguration(@ptrCast(*const IMFMuxStreamMediaTypeManager, self), ullStreamMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamMediaTypeManager_GetStreamConfiguration(self: *const T, ulIndex: u32, pullStreamMask: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamMediaTypeManager.VTable, self.vtable).GetStreamConfiguration(@ptrCast(*const IMFMuxStreamMediaTypeManager, self), ulIndex, pullStreamMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMuxStreamSampleManager_Value = @import("../zig.zig").Guid.initString("74ABBC19-B1CC-4E41-BB8B-9D9B86A8F6CA");
pub const IID_IMFMuxStreamSampleManager = &IID_IMFMuxStreamSampleManager_Value;
pub const IMFMuxStreamSampleManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: fn(
            self: *const IMFMuxStreamSampleManager,
            pdwMuxStreamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSample: fn(
            self: *const IMFMuxStreamSampleManager,
            dwMuxStreamIndex: u32,
            ppSample: **IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamConfiguration: fn(
            self: *const IMFMuxStreamSampleManager,
        ) callconv(@import("std").os.windows.WINAPI) u64,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamSampleManager_GetStreamCount(self: *const T, pdwMuxStreamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamSampleManager.VTable, self.vtable).GetStreamCount(@ptrCast(*const IMFMuxStreamSampleManager, self), pdwMuxStreamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamSampleManager_GetSample(self: *const T, dwMuxStreamIndex: u32, ppSample: **IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMuxStreamSampleManager.VTable, self.vtable).GetSample(@ptrCast(*const IMFMuxStreamSampleManager, self), dwMuxStreamIndex, ppSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMuxStreamSampleManager_GetStreamConfiguration(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const IMFMuxStreamSampleManager.VTable, self.vtable).GetStreamConfiguration(@ptrCast(*const IMFMuxStreamSampleManager, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSecureBuffer_Value = @import("../zig.zig").Guid.initString("C1209904-E584-4752-A2D6-7F21693F8B21");
pub const IID_IMFSecureBuffer = &IID_IMFSecureBuffer_Value;
pub const IMFSecureBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetIdentifier: fn(
            self: *const IMFSecureBuffer,
            pGuidIdentifier: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSecureBuffer_GetIdentifier(self: *const T, pGuidIdentifier: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSecureBuffer.VTable, self.vtable).GetIdentifier(@ptrCast(*const IMFSecureBuffer, self), pGuidIdentifier);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const _MFT_INPUT_DATA_BUFFER_FLAGS = extern enum(i32) {
    MFT_INPUT_DATA_BUFFER_PLACEHOLDER = -1,
};
pub const MFT_INPUT_DATA_BUFFER_PLACEHOLDER = _MFT_INPUT_DATA_BUFFER_FLAGS.MFT_INPUT_DATA_BUFFER_PLACEHOLDER;

pub const _MFT_OUTPUT_DATA_BUFFER_FLAGS = extern enum(i32) {
    MFT_OUTPUT_DATA_BUFFER_INCOMPLETE = 16777216,
    MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE = 256,
    MFT_OUTPUT_DATA_BUFFER_STREAM_END = 512,
    MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE = 768,
};
pub const MFT_OUTPUT_DATA_BUFFER_INCOMPLETE = _MFT_OUTPUT_DATA_BUFFER_FLAGS.MFT_OUTPUT_DATA_BUFFER_INCOMPLETE;
pub const MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE = _MFT_OUTPUT_DATA_BUFFER_FLAGS.MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE;
pub const MFT_OUTPUT_DATA_BUFFER_STREAM_END = _MFT_OUTPUT_DATA_BUFFER_FLAGS.MFT_OUTPUT_DATA_BUFFER_STREAM_END;
pub const MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE = _MFT_OUTPUT_DATA_BUFFER_FLAGS.MFT_OUTPUT_DATA_BUFFER_NO_SAMPLE;

pub const _MFT_INPUT_STATUS_FLAGS = extern enum(i32) {
    MFT_INPUT_STATUS_ACCEPT_DATA = 1,
};
pub const MFT_INPUT_STATUS_ACCEPT_DATA = _MFT_INPUT_STATUS_FLAGS.MFT_INPUT_STATUS_ACCEPT_DATA;

pub const _MFT_OUTPUT_STATUS_FLAGS = extern enum(i32) {
    MFT_OUTPUT_STATUS_SAMPLE_READY = 1,
};
pub const MFT_OUTPUT_STATUS_SAMPLE_READY = _MFT_OUTPUT_STATUS_FLAGS.MFT_OUTPUT_STATUS_SAMPLE_READY;

pub const _MFT_INPUT_STREAM_INFO_FLAGS = extern enum(i32) {
    MFT_INPUT_STREAM_WHOLE_SAMPLES = 1,
    MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = 2,
    MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE = 4,
    MFT_INPUT_STREAM_HOLDS_BUFFERS = 8,
    MFT_INPUT_STREAM_DOES_NOT_ADDREF = 256,
    MFT_INPUT_STREAM_REMOVABLE = 512,
    MFT_INPUT_STREAM_OPTIONAL = 1024,
    MFT_INPUT_STREAM_PROCESSES_IN_PLACE = 2048,
};
pub const MFT_INPUT_STREAM_WHOLE_SAMPLES = _MFT_INPUT_STREAM_INFO_FLAGS.MFT_INPUT_STREAM_WHOLE_SAMPLES;
pub const MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = _MFT_INPUT_STREAM_INFO_FLAGS.MFT_INPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER;
pub const MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE = _MFT_INPUT_STREAM_INFO_FLAGS.MFT_INPUT_STREAM_FIXED_SAMPLE_SIZE;
pub const MFT_INPUT_STREAM_HOLDS_BUFFERS = _MFT_INPUT_STREAM_INFO_FLAGS.MFT_INPUT_STREAM_HOLDS_BUFFERS;
pub const MFT_INPUT_STREAM_DOES_NOT_ADDREF = _MFT_INPUT_STREAM_INFO_FLAGS.MFT_INPUT_STREAM_DOES_NOT_ADDREF;
pub const MFT_INPUT_STREAM_REMOVABLE = _MFT_INPUT_STREAM_INFO_FLAGS.MFT_INPUT_STREAM_REMOVABLE;
pub const MFT_INPUT_STREAM_OPTIONAL = _MFT_INPUT_STREAM_INFO_FLAGS.MFT_INPUT_STREAM_OPTIONAL;
pub const MFT_INPUT_STREAM_PROCESSES_IN_PLACE = _MFT_INPUT_STREAM_INFO_FLAGS.MFT_INPUT_STREAM_PROCESSES_IN_PLACE;

pub const _MFT_OUTPUT_STREAM_INFO_FLAGS = extern enum(i32) {
    MFT_OUTPUT_STREAM_WHOLE_SAMPLES = 1,
    MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = 2,
    MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE = 4,
    MFT_OUTPUT_STREAM_DISCARDABLE = 8,
    MFT_OUTPUT_STREAM_OPTIONAL = 16,
    MFT_OUTPUT_STREAM_PROVIDES_SAMPLES = 256,
    MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES = 512,
    MFT_OUTPUT_STREAM_LAZY_READ = 1024,
    MFT_OUTPUT_STREAM_REMOVABLE = 2048,
};
pub const MFT_OUTPUT_STREAM_WHOLE_SAMPLES = _MFT_OUTPUT_STREAM_INFO_FLAGS.MFT_OUTPUT_STREAM_WHOLE_SAMPLES;
pub const MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER = _MFT_OUTPUT_STREAM_INFO_FLAGS.MFT_OUTPUT_STREAM_SINGLE_SAMPLE_PER_BUFFER;
pub const MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE = _MFT_OUTPUT_STREAM_INFO_FLAGS.MFT_OUTPUT_STREAM_FIXED_SAMPLE_SIZE;
pub const MFT_OUTPUT_STREAM_DISCARDABLE = _MFT_OUTPUT_STREAM_INFO_FLAGS.MFT_OUTPUT_STREAM_DISCARDABLE;
pub const MFT_OUTPUT_STREAM_OPTIONAL = _MFT_OUTPUT_STREAM_INFO_FLAGS.MFT_OUTPUT_STREAM_OPTIONAL;
pub const MFT_OUTPUT_STREAM_PROVIDES_SAMPLES = _MFT_OUTPUT_STREAM_INFO_FLAGS.MFT_OUTPUT_STREAM_PROVIDES_SAMPLES;
pub const MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES = _MFT_OUTPUT_STREAM_INFO_FLAGS.MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES;
pub const MFT_OUTPUT_STREAM_LAZY_READ = _MFT_OUTPUT_STREAM_INFO_FLAGS.MFT_OUTPUT_STREAM_LAZY_READ;
pub const MFT_OUTPUT_STREAM_REMOVABLE = _MFT_OUTPUT_STREAM_INFO_FLAGS.MFT_OUTPUT_STREAM_REMOVABLE;

pub const _MFT_SET_TYPE_FLAGS = extern enum(i32) {
    MFT_SET_TYPE_TEST_ONLY = 1,
};
pub const MFT_SET_TYPE_TEST_ONLY = _MFT_SET_TYPE_FLAGS.MFT_SET_TYPE_TEST_ONLY;

pub const _MFT_PROCESS_OUTPUT_FLAGS = extern enum(i32) {
    MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = 1,
    MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT = 2,
};
pub const MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER = _MFT_PROCESS_OUTPUT_FLAGS.MFT_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER;
pub const MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT = _MFT_PROCESS_OUTPUT_FLAGS.MFT_PROCESS_OUTPUT_REGENERATE_LAST_OUTPUT;

pub const _MFT_PROCESS_OUTPUT_STATUS = extern enum(i32) {
    MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS = 256,
};
pub const MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS = _MFT_PROCESS_OUTPUT_STATUS.MFT_PROCESS_OUTPUT_STATUS_NEW_STREAMS;

pub const MFT_DRAIN_TYPE = extern enum(i32) {
    MFT_DRAIN_PRODUCE_TAILS = 0,
    MFT_DRAIN_NO_TAILS = 1,
};
pub const MFT_DRAIN_PRODUCE_TAILS = MFT_DRAIN_TYPE.MFT_DRAIN_PRODUCE_TAILS;
pub const MFT_DRAIN_NO_TAILS = MFT_DRAIN_TYPE.MFT_DRAIN_NO_TAILS;

pub const MFT_MESSAGE_TYPE = extern enum(i32) {
    MFT_MESSAGE_COMMAND_FLUSH = 0,
    MFT_MESSAGE_COMMAND_DRAIN = 1,
    MFT_MESSAGE_SET_D3D_MANAGER = 2,
    MFT_MESSAGE_DROP_SAMPLES = 3,
    MFT_MESSAGE_COMMAND_TICK = 4,
    MFT_MESSAGE_NOTIFY_BEGIN_STREAMING = 268435456,
    MFT_MESSAGE_NOTIFY_END_STREAMING = 268435457,
    MFT_MESSAGE_NOTIFY_END_OF_STREAM = 268435458,
    MFT_MESSAGE_NOTIFY_START_OF_STREAM = 268435459,
    MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES = 268435460,
    MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES = 268435461,
    MFT_MESSAGE_NOTIFY_EVENT = 268435462,
    MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE = 268435463,
    MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM = 268435464,
    MFT_MESSAGE_COMMAND_MARKER = 536870912,
};
pub const MFT_MESSAGE_COMMAND_FLUSH = MFT_MESSAGE_TYPE.MFT_MESSAGE_COMMAND_FLUSH;
pub const MFT_MESSAGE_COMMAND_DRAIN = MFT_MESSAGE_TYPE.MFT_MESSAGE_COMMAND_DRAIN;
pub const MFT_MESSAGE_SET_D3D_MANAGER = MFT_MESSAGE_TYPE.MFT_MESSAGE_SET_D3D_MANAGER;
pub const MFT_MESSAGE_DROP_SAMPLES = MFT_MESSAGE_TYPE.MFT_MESSAGE_DROP_SAMPLES;
pub const MFT_MESSAGE_COMMAND_TICK = MFT_MESSAGE_TYPE.MFT_MESSAGE_COMMAND_TICK;
pub const MFT_MESSAGE_NOTIFY_BEGIN_STREAMING = MFT_MESSAGE_TYPE.MFT_MESSAGE_NOTIFY_BEGIN_STREAMING;
pub const MFT_MESSAGE_NOTIFY_END_STREAMING = MFT_MESSAGE_TYPE.MFT_MESSAGE_NOTIFY_END_STREAMING;
pub const MFT_MESSAGE_NOTIFY_END_OF_STREAM = MFT_MESSAGE_TYPE.MFT_MESSAGE_NOTIFY_END_OF_STREAM;
pub const MFT_MESSAGE_NOTIFY_START_OF_STREAM = MFT_MESSAGE_TYPE.MFT_MESSAGE_NOTIFY_START_OF_STREAM;
pub const MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES = MFT_MESSAGE_TYPE.MFT_MESSAGE_NOTIFY_RELEASE_RESOURCES;
pub const MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES = MFT_MESSAGE_TYPE.MFT_MESSAGE_NOTIFY_REACQUIRE_RESOURCES;
pub const MFT_MESSAGE_NOTIFY_EVENT = MFT_MESSAGE_TYPE.MFT_MESSAGE_NOTIFY_EVENT;
pub const MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE = MFT_MESSAGE_TYPE.MFT_MESSAGE_COMMAND_SET_OUTPUT_STREAM_STATE;
pub const MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM = MFT_MESSAGE_TYPE.MFT_MESSAGE_COMMAND_FLUSH_OUTPUT_STREAM;
pub const MFT_MESSAGE_COMMAND_MARKER = MFT_MESSAGE_TYPE.MFT_MESSAGE_COMMAND_MARKER;

pub const MFT_INPUT_STREAM_INFO = extern struct {
    hnsMaxLatency: i64,
    dwFlags: u32,
    cbSize: u32,
    cbMaxLookahead: u32,
    cbAlignment: u32,
};

pub const MFT_OUTPUT_STREAM_INFO = extern struct {
    dwFlags: u32,
    cbSize: u32,
    cbAlignment: u32,
};

pub const MFT_OUTPUT_DATA_BUFFER = extern struct {
    dwStreamID: u32,
    pSample: *IMFSample,
    dwStatus: u32,
    pEvents: *IMFCollection,
};

const IID_IMFTransform_Value = @import("../zig.zig").Guid.initString("BF94C121-5B05-4E6F-8000-BA598961414D");
pub const IID_IMFTransform = &IID_IMFTransform_Value;
pub const IMFTransform = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamLimits: fn(
            self: *const IMFTransform,
            pdwInputMinimum: *u32,
            pdwInputMaximum: *u32,
            pdwOutputMinimum: *u32,
            pdwOutputMaximum: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamCount: fn(
            self: *const IMFTransform,
            pcInputStreams: *u32,
            pcOutputStreams: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamIDs: fn(
            self: *const IMFTransform,
            dwInputIDArraySize: u32,
            pdwInputIDs: [*]u32,
            dwOutputIDArraySize: u32,
            pdwOutputIDs: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputStreamInfo: fn(
            self: *const IMFTransform,
            dwInputStreamID: u32,
            pStreamInfo: *MFT_INPUT_STREAM_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStreamInfo: fn(
            self: *const IMFTransform,
            dwOutputStreamID: u32,
            pStreamInfo: *MFT_OUTPUT_STREAM_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributes: fn(
            self: *const IMFTransform,
            pAttributes: **IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputStreamAttributes: fn(
            self: *const IMFTransform,
            dwInputStreamID: u32,
            pAttributes: **IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStreamAttributes: fn(
            self: *const IMFTransform,
            dwOutputStreamID: u32,
            pAttributes: **IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteInputStream: fn(
            self: *const IMFTransform,
            dwStreamID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddInputStreams: fn(
            self: *const IMFTransform,
            cStreams: u32,
            adwStreamIDs: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputAvailableType: fn(
            self: *const IMFTransform,
            dwInputStreamID: u32,
            dwTypeIndex: u32,
            ppType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputAvailableType: fn(
            self: *const IMFTransform,
            dwOutputStreamID: u32,
            dwTypeIndex: u32,
            ppType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputType: fn(
            self: *const IMFTransform,
            dwInputStreamID: u32,
            pType: *IMFMediaType,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputType: fn(
            self: *const IMFTransform,
            dwOutputStreamID: u32,
            pType: *IMFMediaType,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCurrentType: fn(
            self: *const IMFTransform,
            dwInputStreamID: u32,
            ppType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCurrentType: fn(
            self: *const IMFTransform,
            dwOutputStreamID: u32,
            ppType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputStatus: fn(
            self: *const IMFTransform,
            dwInputStreamID: u32,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStatus: fn(
            self: *const IMFTransform,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputBounds: fn(
            self: *const IMFTransform,
            hnsLowerBound: i64,
            hnsUpperBound: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessEvent: fn(
            self: *const IMFTransform,
            dwInputStreamID: u32,
            pEvent: *IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessMessage: fn(
            self: *const IMFTransform,
            eMessage: MFT_MESSAGE_TYPE,
            ulParam: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessInput: fn(
            self: *const IMFTransform,
            dwInputStreamID: u32,
            pSample: *IMFSample,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessOutput: fn(
            self: *const IMFTransform,
            dwFlags: u32,
            cOutputBufferCount: u32,
            pOutputSamples: [*]MFT_OUTPUT_DATA_BUFFER,
            pdwStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetStreamLimits(self: *const T, pdwInputMinimum: *u32, pdwInputMaximum: *u32, pdwOutputMinimum: *u32, pdwOutputMaximum: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetStreamLimits(@ptrCast(*const IMFTransform, self), pdwInputMinimum, pdwInputMaximum, pdwOutputMinimum, pdwOutputMaximum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetStreamCount(self: *const T, pcInputStreams: *u32, pcOutputStreams: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetStreamCount(@ptrCast(*const IMFTransform, self), pcInputStreams, pcOutputStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetStreamIDs(self: *const T, dwInputIDArraySize: u32, pdwInputIDs: [*]u32, dwOutputIDArraySize: u32, pdwOutputIDs: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetStreamIDs(@ptrCast(*const IMFTransform, self), dwInputIDArraySize, pdwInputIDs, dwOutputIDArraySize, pdwOutputIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetInputStreamInfo(self: *const T, dwInputStreamID: u32, pStreamInfo: *MFT_INPUT_STREAM_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetInputStreamInfo(@ptrCast(*const IMFTransform, self), dwInputStreamID, pStreamInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetOutputStreamInfo(self: *const T, dwOutputStreamID: u32, pStreamInfo: *MFT_OUTPUT_STREAM_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetOutputStreamInfo(@ptrCast(*const IMFTransform, self), dwOutputStreamID, pStreamInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetAttributes(self: *const T, pAttributes: **IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetAttributes(@ptrCast(*const IMFTransform, self), pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetInputStreamAttributes(self: *const T, dwInputStreamID: u32, pAttributes: **IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetInputStreamAttributes(@ptrCast(*const IMFTransform, self), dwInputStreamID, pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetOutputStreamAttributes(self: *const T, dwOutputStreamID: u32, pAttributes: **IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetOutputStreamAttributes(@ptrCast(*const IMFTransform, self), dwOutputStreamID, pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_DeleteInputStream(self: *const T, dwStreamID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).DeleteInputStream(@ptrCast(*const IMFTransform, self), dwStreamID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_AddInputStreams(self: *const T, cStreams: u32, adwStreamIDs: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).AddInputStreams(@ptrCast(*const IMFTransform, self), cStreams, adwStreamIDs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetInputAvailableType(self: *const T, dwInputStreamID: u32, dwTypeIndex: u32, ppType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetInputAvailableType(@ptrCast(*const IMFTransform, self), dwInputStreamID, dwTypeIndex, ppType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetOutputAvailableType(self: *const T, dwOutputStreamID: u32, dwTypeIndex: u32, ppType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetOutputAvailableType(@ptrCast(*const IMFTransform, self), dwOutputStreamID, dwTypeIndex, ppType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_SetInputType(self: *const T, dwInputStreamID: u32, pType: *IMFMediaType, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).SetInputType(@ptrCast(*const IMFTransform, self), dwInputStreamID, pType, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_SetOutputType(self: *const T, dwOutputStreamID: u32, pType: *IMFMediaType, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).SetOutputType(@ptrCast(*const IMFTransform, self), dwOutputStreamID, pType, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetInputCurrentType(self: *const T, dwInputStreamID: u32, ppType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetInputCurrentType(@ptrCast(*const IMFTransform, self), dwInputStreamID, ppType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetOutputCurrentType(self: *const T, dwOutputStreamID: u32, ppType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetOutputCurrentType(@ptrCast(*const IMFTransform, self), dwOutputStreamID, ppType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetInputStatus(self: *const T, dwInputStreamID: u32, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetInputStatus(@ptrCast(*const IMFTransform, self), dwInputStreamID, pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_GetOutputStatus(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).GetOutputStatus(@ptrCast(*const IMFTransform, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_SetOutputBounds(self: *const T, hnsLowerBound: i64, hnsUpperBound: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).SetOutputBounds(@ptrCast(*const IMFTransform, self), hnsLowerBound, hnsUpperBound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_ProcessEvent(self: *const T, dwInputStreamID: u32, pEvent: *IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).ProcessEvent(@ptrCast(*const IMFTransform, self), dwInputStreamID, pEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_ProcessMessage(self: *const T, eMessage: MFT_MESSAGE_TYPE, ulParam: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).ProcessMessage(@ptrCast(*const IMFTransform, self), eMessage, ulParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_ProcessInput(self: *const T, dwInputStreamID: u32, pSample: *IMFSample, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).ProcessInput(@ptrCast(*const IMFTransform, self), dwInputStreamID, pSample, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTransform_ProcessOutput(self: *const T, dwFlags: u32, cOutputBufferCount: u32, pOutputSamples: [*]MFT_OUTPUT_DATA_BUFFER, pdwStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTransform.VTable, self.vtable).ProcessOutput(@ptrCast(*const IMFTransform, self), dwFlags, cOutputBufferCount, pOutputSamples, pdwStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DeviceStreamState = extern enum(i32) {
    Stop = 0,
    Pause = 1,
    Run = 2,
    Disabled = 3,
};
pub const DeviceStreamState_Stop = DeviceStreamState.Stop;
pub const DeviceStreamState_Pause = DeviceStreamState.Pause;
pub const DeviceStreamState_Run = DeviceStreamState.Run;
pub const DeviceStreamState_Disabled = DeviceStreamState.Disabled;

pub const STREAM_MEDIUM = extern struct {
    gidMedium: Guid,
    unMediumInstance: u32,
};

pub const MF3DVideoOutputType = extern enum(i32) {
    BaseView = 0,
    Stereo = 1,
};
pub const MF3DVideoOutputType_BaseView = MF3DVideoOutputType.BaseView;
pub const MF3DVideoOutputType_Stereo = MF3DVideoOutputType.Stereo;

pub const MFT_AUDIO_DECODER_DEGRADATION_REASON = extern enum(i32) {
    NONE = 0,
    LICENSING_REQUIREMENT = 1,
};
pub const MFT_AUDIO_DECODER_DEGRADATION_REASON_NONE = MFT_AUDIO_DECODER_DEGRADATION_REASON.NONE;
pub const MFT_AUDIO_DECODER_DEGRADATION_REASON_LICENSING_REQUIREMENT = MFT_AUDIO_DECODER_DEGRADATION_REASON.LICENSING_REQUIREMENT;

pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE = extern enum(i32) {
    NONE = 0,
    DOWNMIX2CHANNEL = 1,
    DOWNMIX6CHANNEL = 2,
    DOWNMIX8CHANNEL = 3,
};
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_NONE = MFT_AUDIO_DECODER_DEGRADATION_TYPE.NONE;
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX2CHANNEL = MFT_AUDIO_DECODER_DEGRADATION_TYPE.DOWNMIX2CHANNEL;
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX6CHANNEL = MFT_AUDIO_DECODER_DEGRADATION_TYPE.DOWNMIX6CHANNEL;
pub const MFT_AUDIO_DECODER_DEGRADATION_TYPE_DOWNMIX8CHANNEL = MFT_AUDIO_DECODER_DEGRADATION_TYPE.DOWNMIX8CHANNEL;

pub const MFAudioDecoderDegradationInfo = extern struct {
    eDegradationReason: MFT_AUDIO_DECODER_DEGRADATION_REASON,
    eType: MFT_AUDIO_DECODER_DEGRADATION_TYPE,
};

pub const MFT_STREAM_STATE_PARAM = extern struct {
    StreamId: u32,
    State: MF_STREAM_STATE,
};

pub const MFSESSION_SETTOPOLOGY_FLAGS = extern enum(i32) {
    MFSESSION_SETTOPOLOGY_IMMEDIATE = 1,
    MFSESSION_SETTOPOLOGY_NORESOLUTION = 2,
    MFSESSION_SETTOPOLOGY_CLEAR_CURRENT = 4,
};
pub const MFSESSION_SETTOPOLOGY_IMMEDIATE = MFSESSION_SETTOPOLOGY_FLAGS.MFSESSION_SETTOPOLOGY_IMMEDIATE;
pub const MFSESSION_SETTOPOLOGY_NORESOLUTION = MFSESSION_SETTOPOLOGY_FLAGS.MFSESSION_SETTOPOLOGY_NORESOLUTION;
pub const MFSESSION_SETTOPOLOGY_CLEAR_CURRENT = MFSESSION_SETTOPOLOGY_FLAGS.MFSESSION_SETTOPOLOGY_CLEAR_CURRENT;

pub const MFSESSION_GETFULLTOPOLOGY_FLAGS = extern enum(i32) {
    MFSESSION_GETFULLTOPOLOGY_CURRENT = 1,
};
pub const MFSESSION_GETFULLTOPOLOGY_CURRENT = MFSESSION_GETFULLTOPOLOGY_FLAGS.MFSESSION_GETFULLTOPOLOGY_CURRENT;

pub const MFPMPSESSION_CREATION_FLAGS = extern enum(i32) {
    MFPMPSESSION_UNPROTECTED_PROCESS = 1,
    MFPMPSESSION_IN_PROCESS = 2,
};
pub const MFPMPSESSION_UNPROTECTED_PROCESS = MFPMPSESSION_CREATION_FLAGS.MFPMPSESSION_UNPROTECTED_PROCESS;
pub const MFPMPSESSION_IN_PROCESS = MFPMPSESSION_CREATION_FLAGS.MFPMPSESSION_IN_PROCESS;

const IID_IMFMediaSession_Value = @import("../zig.zig").Guid.initString("90377834-21D0-4DEE-8214-BA2E3E6C1127");
pub const IID_IMFMediaSession = &IID_IMFMediaSession_Value;
pub const IMFMediaSession = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEventGenerator.VTable,
        SetTopology: fn(
            self: *const IMFMediaSession,
            dwSetTopologyFlags: u32,
            pTopology: *IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearTopologies: fn(
            self: *const IMFMediaSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: fn(
            self: *const IMFMediaSession,
            pguidTimeFormat: *const Guid,
            pvarStartPosition: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IMFMediaSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IMFMediaSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IMFMediaSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFMediaSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClock: fn(
            self: *const IMFMediaSession,
            ppClock: **IMFClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSessionCapabilities: fn(
            self: *const IMFMediaSession,
            pdwCaps: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFullTopology: fn(
            self: *const IMFMediaSession,
            dwGetFullTopologyFlags: u32,
            TopoId: u64,
            ppFullTopology: **IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaEventGenerator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_SetTopology(self: *const T, dwSetTopologyFlags: u32, pTopology: *IMFTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).SetTopology(@ptrCast(*const IMFMediaSession, self), dwSetTopologyFlags, pTopology);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_ClearTopologies(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).ClearTopologies(@ptrCast(*const IMFMediaSession, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_Start(self: *const T, pguidTimeFormat: *const Guid, pvarStartPosition: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).Start(@ptrCast(*const IMFMediaSession, self), pguidTimeFormat, pvarStartPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).Pause(@ptrCast(*const IMFMediaSession, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).Stop(@ptrCast(*const IMFMediaSession, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).Close(@ptrCast(*const IMFMediaSession, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).Shutdown(@ptrCast(*const IMFMediaSession, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_GetClock(self: *const T, ppClock: **IMFClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).GetClock(@ptrCast(*const IMFMediaSession, self), ppClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_GetSessionCapabilities(self: *const T, pdwCaps: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).GetSessionCapabilities(@ptrCast(*const IMFMediaSession, self), pdwCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSession_GetFullTopology(self: *const T, dwGetFullTopologyFlags: u32, TopoId: u64, ppFullTopology: **IMFTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSession.VTable, self.vtable).GetFullTopology(@ptrCast(*const IMFMediaSession, self), dwGetFullTopologyFlags, TopoId, ppFullTopology);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_OBJECT_TYPE = extern enum(i32) {
    MF_OBJECT_MEDIASOURCE = 0,
    MF_OBJECT_BYTESTREAM = 1,
    MF_OBJECT_INVALID = 2,
};
pub const MF_OBJECT_MEDIASOURCE = MF_OBJECT_TYPE.MF_OBJECT_MEDIASOURCE;
pub const MF_OBJECT_BYTESTREAM = MF_OBJECT_TYPE.MF_OBJECT_BYTESTREAM;
pub const MF_OBJECT_INVALID = MF_OBJECT_TYPE.MF_OBJECT_INVALID;

pub const __MIDL___MIDL_itf_mfidl_0000_0001_0001 = extern enum(i32) {
    MF_RESOLUTION_MEDIASOURCE = 1,
    MF_RESOLUTION_BYTESTREAM = 2,
    MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE = 16,
    MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL = 32,
    MF_RESOLUTION_DISABLE_LOCAL_PLUGINS = 64,
    MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY = 128,
    MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY = 256,
    MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE = 512,
    MF_RESOLUTION_ENABLE_STORE_PLUGINS = 1024,
    MF_RESOLUTION_READ = 65536,
    MF_RESOLUTION_WRITE = 131072,
};
pub const MF_RESOLUTION_MEDIASOURCE = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_MEDIASOURCE;
pub const MF_RESOLUTION_BYTESTREAM = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_BYTESTREAM;
pub const MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE;
pub const MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL;
pub const MF_RESOLUTION_DISABLE_LOCAL_PLUGINS = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_DISABLE_LOCAL_PLUGINS;
pub const MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_PLUGIN_CONTROL_POLICY_APPROVED_ONLY;
pub const MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY;
pub const MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_PLUGIN_CONTROL_POLICY_WEB_ONLY_EDGEMODE;
pub const MF_RESOLUTION_ENABLE_STORE_PLUGINS = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_ENABLE_STORE_PLUGINS;
pub const MF_RESOLUTION_READ = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_READ;
pub const MF_RESOLUTION_WRITE = __MIDL___MIDL_itf_mfidl_0000_0001_0001.MF_RESOLUTION_WRITE;

pub const MF_CONNECT_METHOD = extern enum(i32) {
    MF_CONNECT_DIRECT = 0,
    MF_CONNECT_ALLOW_CONVERTER = 1,
    MF_CONNECT_ALLOW_DECODER = 3,
    MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES = 4,
    MF_CONNECT_AS_OPTIONAL = 65536,
    MF_CONNECT_AS_OPTIONAL_BRANCH = 131072,
};
pub const MF_CONNECT_DIRECT = MF_CONNECT_METHOD.MF_CONNECT_DIRECT;
pub const MF_CONNECT_ALLOW_CONVERTER = MF_CONNECT_METHOD.MF_CONNECT_ALLOW_CONVERTER;
pub const MF_CONNECT_ALLOW_DECODER = MF_CONNECT_METHOD.MF_CONNECT_ALLOW_DECODER;
pub const MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES = MF_CONNECT_METHOD.MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES;
pub const MF_CONNECT_AS_OPTIONAL = MF_CONNECT_METHOD.MF_CONNECT_AS_OPTIONAL;
pub const MF_CONNECT_AS_OPTIONAL_BRANCH = MF_CONNECT_METHOD.MF_CONNECT_AS_OPTIONAL_BRANCH;

pub const MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS = extern enum(i32) {
    MF_TOPOLOGY_RESOLUTION_SUCCEEDED = 0,
    MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE = 1,
    MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS = 2,
};
pub const MF_TOPOLOGY_RESOLUTION_SUCCEEDED = MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS.MF_TOPOLOGY_RESOLUTION_SUCCEEDED;
pub const MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE = MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS.MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE;
pub const MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS = MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS.MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS;

const IID_IMFSourceResolver_Value = @import("../zig.zig").Guid.initString("FBE5A32D-A497-4B61-BB85-97B1A848A6E3");
pub const IID_IMFSourceResolver = &IID_IMFSourceResolver_Value;
pub const IMFSourceResolver = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateObjectFromURL: fn(
            self: *const IMFSourceResolver,
            pwszURL: [*:0]const u16,
            dwFlags: u32,
            pProps: *IPropertyStore,
            pObjectType: *MF_OBJECT_TYPE,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateObjectFromByteStream: fn(
            self: *const IMFSourceResolver,
            pByteStream: *IMFByteStream,
            pwszURL: [*:0]const u16,
            dwFlags: u32,
            pProps: *IPropertyStore,
            pObjectType: *MF_OBJECT_TYPE,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginCreateObjectFromURL: fn(
            self: *const IMFSourceResolver,
            pwszURL: [*:0]const u16,
            dwFlags: u32,
            pProps: *IPropertyStore,
            ppIUnknownCancelCookie: ?*?*IUnknown,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndCreateObjectFromURL: fn(
            self: *const IMFSourceResolver,
            pResult: *IMFAsyncResult,
            pObjectType: *MF_OBJECT_TYPE,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginCreateObjectFromByteStream: fn(
            self: *const IMFSourceResolver,
            pByteStream: *IMFByteStream,
            pwszURL: [*:0]const u16,
            dwFlags: u32,
            pProps: *IPropertyStore,
            ppIUnknownCancelCookie: ?*?*IUnknown,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndCreateObjectFromByteStream: fn(
            self: *const IMFSourceResolver,
            pResult: *IMFAsyncResult,
            pObjectType: *MF_OBJECT_TYPE,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelObjectCreation: fn(
            self: *const IMFSourceResolver,
            pIUnknownCancelCookie: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceResolver_CreateObjectFromURL(self: *const T, pwszURL: [*:0]const u16, dwFlags: u32, pProps: *IPropertyStore, pObjectType: *MF_OBJECT_TYPE, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceResolver.VTable, self.vtable).CreateObjectFromURL(@ptrCast(*const IMFSourceResolver, self), pwszURL, dwFlags, pProps, pObjectType, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceResolver_CreateObjectFromByteStream(self: *const T, pByteStream: *IMFByteStream, pwszURL: [*:0]const u16, dwFlags: u32, pProps: *IPropertyStore, pObjectType: *MF_OBJECT_TYPE, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceResolver.VTable, self.vtable).CreateObjectFromByteStream(@ptrCast(*const IMFSourceResolver, self), pByteStream, pwszURL, dwFlags, pProps, pObjectType, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceResolver_BeginCreateObjectFromURL(self: *const T, pwszURL: [*:0]const u16, dwFlags: u32, pProps: *IPropertyStore, ppIUnknownCancelCookie: ?*?*IUnknown, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceResolver.VTable, self.vtable).BeginCreateObjectFromURL(@ptrCast(*const IMFSourceResolver, self), pwszURL, dwFlags, pProps, ppIUnknownCancelCookie, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceResolver_EndCreateObjectFromURL(self: *const T, pResult: *IMFAsyncResult, pObjectType: *MF_OBJECT_TYPE, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceResolver.VTable, self.vtable).EndCreateObjectFromURL(@ptrCast(*const IMFSourceResolver, self), pResult, pObjectType, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceResolver_BeginCreateObjectFromByteStream(self: *const T, pByteStream: *IMFByteStream, pwszURL: [*:0]const u16, dwFlags: u32, pProps: *IPropertyStore, ppIUnknownCancelCookie: ?*?*IUnknown, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceResolver.VTable, self.vtable).BeginCreateObjectFromByteStream(@ptrCast(*const IMFSourceResolver, self), pByteStream, pwszURL, dwFlags, pProps, ppIUnknownCancelCookie, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceResolver_EndCreateObjectFromByteStream(self: *const T, pResult: *IMFAsyncResult, pObjectType: *MF_OBJECT_TYPE, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceResolver.VTable, self.vtable).EndCreateObjectFromByteStream(@ptrCast(*const IMFSourceResolver, self), pResult, pObjectType, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceResolver_CancelObjectCreation(self: *const T, pIUnknownCancelCookie: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceResolver.VTable, self.vtable).CancelObjectCreation(@ptrCast(*const IMFSourceResolver, self), pIUnknownCancelCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFMEDIASOURCE_CHARACTERISTICS = extern enum(i32) {
    MFMEDIASOURCE_IS_LIVE = 1,
    MFMEDIASOURCE_CAN_SEEK = 2,
    MFMEDIASOURCE_CAN_PAUSE = 4,
    MFMEDIASOURCE_HAS_SLOW_SEEK = 8,
    MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS = 16,
    MFMEDIASOURCE_CAN_SKIPFORWARD = 32,
    MFMEDIASOURCE_CAN_SKIPBACKWARD = 64,
    MFMEDIASOURCE_DOES_NOT_USE_NETWORK = 128,
};
pub const MFMEDIASOURCE_IS_LIVE = MFMEDIASOURCE_CHARACTERISTICS.MFMEDIASOURCE_IS_LIVE;
pub const MFMEDIASOURCE_CAN_SEEK = MFMEDIASOURCE_CHARACTERISTICS.MFMEDIASOURCE_CAN_SEEK;
pub const MFMEDIASOURCE_CAN_PAUSE = MFMEDIASOURCE_CHARACTERISTICS.MFMEDIASOURCE_CAN_PAUSE;
pub const MFMEDIASOURCE_HAS_SLOW_SEEK = MFMEDIASOURCE_CHARACTERISTICS.MFMEDIASOURCE_HAS_SLOW_SEEK;
pub const MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS = MFMEDIASOURCE_CHARACTERISTICS.MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS;
pub const MFMEDIASOURCE_CAN_SKIPFORWARD = MFMEDIASOURCE_CHARACTERISTICS.MFMEDIASOURCE_CAN_SKIPFORWARD;
pub const MFMEDIASOURCE_CAN_SKIPBACKWARD = MFMEDIASOURCE_CHARACTERISTICS.MFMEDIASOURCE_CAN_SKIPBACKWARD;
pub const MFMEDIASOURCE_DOES_NOT_USE_NETWORK = MFMEDIASOURCE_CHARACTERISTICS.MFMEDIASOURCE_DOES_NOT_USE_NETWORK;

const IID_IMFMediaSource_Value = @import("../zig.zig").Guid.initString("279A808D-AEC7-40C8-9C6B-A6B492C78A66");
pub const IID_IMFMediaSource = &IID_IMFMediaSource_Value;
pub const IMFMediaSource = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEventGenerator.VTable,
        GetCharacteristics: fn(
            self: *const IMFMediaSource,
            pdwCharacteristics: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePresentationDescriptor: fn(
            self: *const IMFMediaSource,
            ppPresentationDescriptor: **IMFPresentationDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: fn(
            self: *const IMFMediaSource,
            pPresentationDescriptor: *IMFPresentationDescriptor,
            pguidTimeFormat: *const Guid,
            pvarStartPosition: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IMFMediaSource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IMFMediaSource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFMediaSource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaEventGenerator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSource_GetCharacteristics(self: *const T, pdwCharacteristics: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSource.VTable, self.vtable).GetCharacteristics(@ptrCast(*const IMFMediaSource, self), pdwCharacteristics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSource_CreatePresentationDescriptor(self: *const T, ppPresentationDescriptor: **IMFPresentationDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSource.VTable, self.vtable).CreatePresentationDescriptor(@ptrCast(*const IMFMediaSource, self), ppPresentationDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSource_Start(self: *const T, pPresentationDescriptor: *IMFPresentationDescriptor, pguidTimeFormat: *const Guid, pvarStartPosition: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSource.VTable, self.vtable).Start(@ptrCast(*const IMFMediaSource, self), pPresentationDescriptor, pguidTimeFormat, pvarStartPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSource_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSource.VTable, self.vtable).Stop(@ptrCast(*const IMFMediaSource, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSource_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSource.VTable, self.vtable).Pause(@ptrCast(*const IMFMediaSource, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSource_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSource.VTable, self.vtable).Shutdown(@ptrCast(*const IMFMediaSource, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaSourceEx_Value = @import("../zig.zig").Guid.initString("3C9B2EB9-86D5-4514-A394-F56664F9F0D8");
pub const IID_IMFMediaSourceEx = &IID_IMFMediaSourceEx_Value;
pub const IMFMediaSourceEx = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaSource.VTable,
        GetSourceAttributes: fn(
            self: *const IMFMediaSourceEx,
            ppAttributes: **IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamAttributes: fn(
            self: *const IMFMediaSourceEx,
            dwStreamIdentifier: u32,
            ppAttributes: **IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetD3DManager: fn(
            self: *const IMFMediaSourceEx,
            pManager: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaSource.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceEx_GetSourceAttributes(self: *const T, ppAttributes: **IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceEx.VTable, self.vtable).GetSourceAttributes(@ptrCast(*const IMFMediaSourceEx, self), ppAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceEx_GetStreamAttributes(self: *const T, dwStreamIdentifier: u32, ppAttributes: **IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceEx.VTable, self.vtable).GetStreamAttributes(@ptrCast(*const IMFMediaSourceEx, self), dwStreamIdentifier, ppAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceEx_SetD3DManager(self: *const T, pManager: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceEx.VTable, self.vtable).SetD3DManager(@ptrCast(*const IMFMediaSourceEx, self), pManager);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFClockConsumer_Value = @import("../zig.zig").Guid.initString("6EF2A662-47C0-4666-B13D-CBB717F2FA2C");
pub const IID_IMFClockConsumer = &IID_IMFClockConsumer_Value;
pub const IMFClockConsumer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPresentationClock: fn(
            self: *const IMFClockConsumer,
            pPresentationClock: *IMFPresentationClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPresentationClock: fn(
            self: *const IMFClockConsumer,
            ppPresentationClock: **IMFPresentationClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClockConsumer_SetPresentationClock(self: *const T, pPresentationClock: *IMFPresentationClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClockConsumer.VTable, self.vtable).SetPresentationClock(@ptrCast(*const IMFClockConsumer, self), pPresentationClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClockConsumer_GetPresentationClock(self: *const T, ppPresentationClock: **IMFPresentationClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClockConsumer.VTable, self.vtable).GetPresentationClock(@ptrCast(*const IMFClockConsumer, self), ppPresentationClock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaStream_Value = @import("../zig.zig").Guid.initString("D182108F-4EC6-443F-AA42-A71106EC825F");
pub const IID_IMFMediaStream = &IID_IMFMediaStream_Value;
pub const IMFMediaStream = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEventGenerator.VTable,
        GetMediaSource: fn(
            self: *const IMFMediaStream,
            ppMediaSource: **IMFMediaSource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamDescriptor: fn(
            self: *const IMFMediaStream,
            ppStreamDescriptor: **IMFStreamDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestSample: fn(
            self: *const IMFMediaStream,
            pToken: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaEventGenerator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaStream_GetMediaSource(self: *const T, ppMediaSource: **IMFMediaSource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaStream.VTable, self.vtable).GetMediaSource(@ptrCast(*const IMFMediaStream, self), ppMediaSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaStream_GetStreamDescriptor(self: *const T, ppStreamDescriptor: **IMFStreamDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaStream.VTable, self.vtable).GetStreamDescriptor(@ptrCast(*const IMFMediaStream, self), ppStreamDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaStream_RequestSample(self: *const T, pToken: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaStream.VTable, self.vtable).RequestSample(@ptrCast(*const IMFMediaStream, self), pToken);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaSink_Value = @import("../zig.zig").Guid.initString("6EF2A660-47C0-4666-B13D-CBB717F2FA2C");
pub const IID_IMFMediaSink = &IID_IMFMediaSink_Value;
pub const IMFMediaSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCharacteristics: fn(
            self: *const IMFMediaSink,
            pdwCharacteristics: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStreamSink: fn(
            self: *const IMFMediaSink,
            dwStreamSinkIdentifier: u32,
            pMediaType: *IMFMediaType,
            ppStreamSink: **IMFStreamSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStreamSink: fn(
            self: *const IMFMediaSink,
            dwStreamSinkIdentifier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamSinkCount: fn(
            self: *const IMFMediaSink,
            pcStreamSinkCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamSinkByIndex: fn(
            self: *const IMFMediaSink,
            dwIndex: u32,
            ppStreamSink: **IMFStreamSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamSinkById: fn(
            self: *const IMFMediaSink,
            dwStreamSinkIdentifier: u32,
            ppStreamSink: **IMFStreamSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPresentationClock: fn(
            self: *const IMFMediaSink,
            pPresentationClock: *IMFPresentationClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPresentationClock: fn(
            self: *const IMFMediaSink,
            ppPresentationClock: **IMFPresentationClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFMediaSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSink_GetCharacteristics(self: *const T, pdwCharacteristics: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSink.VTable, self.vtable).GetCharacteristics(@ptrCast(*const IMFMediaSink, self), pdwCharacteristics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSink_AddStreamSink(self: *const T, dwStreamSinkIdentifier: u32, pMediaType: *IMFMediaType, ppStreamSink: **IMFStreamSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSink.VTable, self.vtable).AddStreamSink(@ptrCast(*const IMFMediaSink, self), dwStreamSinkIdentifier, pMediaType, ppStreamSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSink_RemoveStreamSink(self: *const T, dwStreamSinkIdentifier: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSink.VTable, self.vtable).RemoveStreamSink(@ptrCast(*const IMFMediaSink, self), dwStreamSinkIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSink_GetStreamSinkCount(self: *const T, pcStreamSinkCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSink.VTable, self.vtable).GetStreamSinkCount(@ptrCast(*const IMFMediaSink, self), pcStreamSinkCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSink_GetStreamSinkByIndex(self: *const T, dwIndex: u32, ppStreamSink: **IMFStreamSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSink.VTable, self.vtable).GetStreamSinkByIndex(@ptrCast(*const IMFMediaSink, self), dwIndex, ppStreamSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSink_GetStreamSinkById(self: *const T, dwStreamSinkIdentifier: u32, ppStreamSink: **IMFStreamSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSink.VTable, self.vtable).GetStreamSinkById(@ptrCast(*const IMFMediaSink, self), dwStreamSinkIdentifier, ppStreamSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSink_SetPresentationClock(self: *const T, pPresentationClock: *IMFPresentationClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSink.VTable, self.vtable).SetPresentationClock(@ptrCast(*const IMFMediaSink, self), pPresentationClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSink_GetPresentationClock(self: *const T, ppPresentationClock: **IMFPresentationClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSink.VTable, self.vtable).GetPresentationClock(@ptrCast(*const IMFMediaSink, self), ppPresentationClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSink_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSink.VTable, self.vtable).Shutdown(@ptrCast(*const IMFMediaSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFSTREAMSINK_MARKER_TYPE = extern enum(i32) {
    MFSTREAMSINK_MARKER_DEFAULT = 0,
    MFSTREAMSINK_MARKER_ENDOFSEGMENT = 1,
    MFSTREAMSINK_MARKER_TICK = 2,
    MFSTREAMSINK_MARKER_EVENT = 3,
};
pub const MFSTREAMSINK_MARKER_DEFAULT = MFSTREAMSINK_MARKER_TYPE.MFSTREAMSINK_MARKER_DEFAULT;
pub const MFSTREAMSINK_MARKER_ENDOFSEGMENT = MFSTREAMSINK_MARKER_TYPE.MFSTREAMSINK_MARKER_ENDOFSEGMENT;
pub const MFSTREAMSINK_MARKER_TICK = MFSTREAMSINK_MARKER_TYPE.MFSTREAMSINK_MARKER_TICK;
pub const MFSTREAMSINK_MARKER_EVENT = MFSTREAMSINK_MARKER_TYPE.MFSTREAMSINK_MARKER_EVENT;

const IID_IMFStreamSink_Value = @import("../zig.zig").Guid.initString("0A97B3CF-8E7C-4A3D-8F8C-0C843DC247FB");
pub const IID_IMFStreamSink = &IID_IMFStreamSink_Value;
pub const IMFStreamSink = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEventGenerator.VTable,
        GetMediaSink: fn(
            self: *const IMFStreamSink,
            ppMediaSink: **IMFMediaSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentifier: fn(
            self: *const IMFStreamSink,
            pdwIdentifier: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaTypeHandler: fn(
            self: *const IMFStreamSink,
            ppHandler: **IMFMediaTypeHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessSample: fn(
            self: *const IMFStreamSink,
            pSample: *IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlaceMarker: fn(
            self: *const IMFStreamSink,
            eMarkerType: MFSTREAMSINK_MARKER_TYPE,
            pvarMarkerValue: *const PROPVARIANT,
            pvarContextValue: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IMFStreamSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaEventGenerator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFStreamSink_GetMediaSink(self: *const T, ppMediaSink: **IMFMediaSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFStreamSink.VTable, self.vtable).GetMediaSink(@ptrCast(*const IMFStreamSink, self), ppMediaSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFStreamSink_GetIdentifier(self: *const T, pdwIdentifier: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFStreamSink.VTable, self.vtable).GetIdentifier(@ptrCast(*const IMFStreamSink, self), pdwIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFStreamSink_GetMediaTypeHandler(self: *const T, ppHandler: **IMFMediaTypeHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFStreamSink.VTable, self.vtable).GetMediaTypeHandler(@ptrCast(*const IMFStreamSink, self), ppHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFStreamSink_ProcessSample(self: *const T, pSample: *IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFStreamSink.VTable, self.vtable).ProcessSample(@ptrCast(*const IMFStreamSink, self), pSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFStreamSink_PlaceMarker(self: *const T, eMarkerType: MFSTREAMSINK_MARKER_TYPE, pvarMarkerValue: *const PROPVARIANT, pvarContextValue: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFStreamSink.VTable, self.vtable).PlaceMarker(@ptrCast(*const IMFStreamSink, self), eMarkerType, pvarMarkerValue, pvarContextValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFStreamSink_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFStreamSink.VTable, self.vtable).Flush(@ptrCast(*const IMFStreamSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoSampleAllocator_Value = @import("../zig.zig").Guid.initString("86CBC910-E533-4751-8E3B-F19B5B806A03");
pub const IID_IMFVideoSampleAllocator = &IID_IMFVideoSampleAllocator_Value;
pub const IMFVideoSampleAllocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDirectXManager: fn(
            self: *const IMFVideoSampleAllocator,
            pManager: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UninitializeSampleAllocator: fn(
            self: *const IMFVideoSampleAllocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeSampleAllocator: fn(
            self: *const IMFVideoSampleAllocator,
            cRequestedFrames: u32,
            pMediaType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AllocateSample: fn(
            self: *const IMFVideoSampleAllocator,
            ppSample: **IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoSampleAllocator_SetDirectXManager(self: *const T, pManager: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoSampleAllocator.VTable, self.vtable).SetDirectXManager(@ptrCast(*const IMFVideoSampleAllocator, self), pManager);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoSampleAllocator_UninitializeSampleAllocator(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoSampleAllocator.VTable, self.vtable).UninitializeSampleAllocator(@ptrCast(*const IMFVideoSampleAllocator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoSampleAllocator_InitializeSampleAllocator(self: *const T, cRequestedFrames: u32, pMediaType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoSampleAllocator.VTable, self.vtable).InitializeSampleAllocator(@ptrCast(*const IMFVideoSampleAllocator, self), cRequestedFrames, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoSampleAllocator_AllocateSample(self: *const T, ppSample: **IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoSampleAllocator.VTable, self.vtable).AllocateSample(@ptrCast(*const IMFVideoSampleAllocator, self), ppSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoSampleAllocatorNotify_Value = @import("../zig.zig").Guid.initString("A792CDBE-C374-4E89-8335-278E7B9956A4");
pub const IID_IMFVideoSampleAllocatorNotify = &IID_IMFVideoSampleAllocatorNotify_Value;
pub const IMFVideoSampleAllocatorNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyRelease: fn(
            self: *const IMFVideoSampleAllocatorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoSampleAllocatorNotify_NotifyRelease(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoSampleAllocatorNotify.VTable, self.vtable).NotifyRelease(@ptrCast(*const IMFVideoSampleAllocatorNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoSampleAllocatorNotifyEx_Value = @import("../zig.zig").Guid.initString("3978AA1A-6D5B-4B7F-A340-90899189AE34");
pub const IID_IMFVideoSampleAllocatorNotifyEx = &IID_IMFVideoSampleAllocatorNotifyEx_Value;
pub const IMFVideoSampleAllocatorNotifyEx = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoSampleAllocatorNotify.VTable,
        NotifyPrune: fn(
            self: *const IMFVideoSampleAllocatorNotifyEx,
            __MIDL__IMFVideoSampleAllocatorNotifyEx0000: *IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFVideoSampleAllocatorNotify.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoSampleAllocatorNotifyEx_NotifyPrune(self: *const T, __MIDL__IMFVideoSampleAllocatorNotifyEx0000: *IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoSampleAllocatorNotifyEx.VTable, self.vtable).NotifyPrune(@ptrCast(*const IMFVideoSampleAllocatorNotifyEx, self), __MIDL__IMFVideoSampleAllocatorNotifyEx0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoSampleAllocatorCallback_Value = @import("../zig.zig").Guid.initString("992388B4-3372-4F67-8B6F-C84C071F4751");
pub const IID_IMFVideoSampleAllocatorCallback = &IID_IMFVideoSampleAllocatorCallback_Value;
pub const IMFVideoSampleAllocatorCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetCallback: fn(
            self: *const IMFVideoSampleAllocatorCallback,
            pNotify: *IMFVideoSampleAllocatorNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFreeSampleCount: fn(
            self: *const IMFVideoSampleAllocatorCallback,
            plSamples: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoSampleAllocatorCallback_SetCallback(self: *const T, pNotify: *IMFVideoSampleAllocatorNotify) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoSampleAllocatorCallback.VTable, self.vtable).SetCallback(@ptrCast(*const IMFVideoSampleAllocatorCallback, self), pNotify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoSampleAllocatorCallback_GetFreeSampleCount(self: *const T, plSamples: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoSampleAllocatorCallback.VTable, self.vtable).GetFreeSampleCount(@ptrCast(*const IMFVideoSampleAllocatorCallback, self), plSamples);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoSampleAllocatorEx_Value = @import("../zig.zig").Guid.initString("545B3A48-3283-4F62-866F-A62D8F598F9F");
pub const IID_IMFVideoSampleAllocatorEx = &IID_IMFVideoSampleAllocatorEx_Value;
pub const IMFVideoSampleAllocatorEx = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoSampleAllocator.VTable,
        InitializeSampleAllocatorEx: fn(
            self: *const IMFVideoSampleAllocatorEx,
            cInitialSamples: u32,
            cMaximumSamples: u32,
            pAttributes: ?*IMFAttributes,
            pMediaType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFVideoSampleAllocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoSampleAllocatorEx_InitializeSampleAllocatorEx(self: *const T, cInitialSamples: u32, cMaximumSamples: u32, pAttributes: ?*IMFAttributes, pMediaType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoSampleAllocatorEx.VTable, self.vtable).InitializeSampleAllocatorEx(@ptrCast(*const IMFVideoSampleAllocatorEx, self), cInitialSamples, cMaximumSamples, pAttributes, pMediaType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFDXGIDeviceManagerSource_Value = @import("../zig.zig").Guid.initString("20BC074B-7A8D-4609-8C3B-64A0A3B5D7CE");
pub const IID_IMFDXGIDeviceManagerSource = &IID_IMFDXGIDeviceManagerSource_Value;
pub const IMFDXGIDeviceManagerSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetManager: fn(
            self: *const IMFDXGIDeviceManagerSource,
            ppManager: **IMFDXGIDeviceManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDXGIDeviceManagerSource_GetManager(self: *const T, ppManager: **IMFDXGIDeviceManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDXGIDeviceManagerSource.VTable, self.vtable).GetManager(@ptrCast(*const IMFDXGIDeviceManagerSource, self), ppManager);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_VIDEO_PROCESSOR_ROTATION = extern enum(i32) {
    ROTATION_NONE = 0,
    ROTATION_NORMAL = 1,
};
pub const ROTATION_NONE = MF_VIDEO_PROCESSOR_ROTATION.ROTATION_NONE;
pub const ROTATION_NORMAL = MF_VIDEO_PROCESSOR_ROTATION.ROTATION_NORMAL;

pub const MF_VIDEO_PROCESSOR_MIRROR = extern enum(i32) {
    MIRROR_NONE = 0,
    MIRROR_HORIZONTAL = 1,
    MIRROR_VERTICAL = 2,
};
pub const MIRROR_NONE = MF_VIDEO_PROCESSOR_MIRROR.MIRROR_NONE;
pub const MIRROR_HORIZONTAL = MF_VIDEO_PROCESSOR_MIRROR.MIRROR_HORIZONTAL;
pub const MIRROR_VERTICAL = MF_VIDEO_PROCESSOR_MIRROR.MIRROR_VERTICAL;

const IID_IMFVideoProcessorControl_Value = @import("../zig.zig").Guid.initString("A3F675D5-6119-4F7F-A100-1D8B280F0EFB");
pub const IID_IMFVideoProcessorControl = &IID_IMFVideoProcessorControl_Value;
pub const IMFVideoProcessorControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBorderColor: fn(
            self: *const IMFVideoProcessorControl,
            pBorderColor: ?*MFARGB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceRectangle: fn(
            self: *const IMFVideoProcessorControl,
            pSrcRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDestinationRectangle: fn(
            self: *const IMFVideoProcessorControl,
            pDstRect: ?*RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMirror: fn(
            self: *const IMFVideoProcessorControl,
            eMirror: MF_VIDEO_PROCESSOR_MIRROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRotation: fn(
            self: *const IMFVideoProcessorControl,
            eRotation: MF_VIDEO_PROCESSOR_ROTATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConstrictionSize: fn(
            self: *const IMFVideoProcessorControl,
            pConstrictionSize: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl_SetBorderColor(self: *const T, pBorderColor: ?*MFARGB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl.VTable, self.vtable).SetBorderColor(@ptrCast(*const IMFVideoProcessorControl, self), pBorderColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl_SetSourceRectangle(self: *const T, pSrcRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl.VTable, self.vtable).SetSourceRectangle(@ptrCast(*const IMFVideoProcessorControl, self), pSrcRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl_SetDestinationRectangle(self: *const T, pDstRect: ?*RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl.VTable, self.vtable).SetDestinationRectangle(@ptrCast(*const IMFVideoProcessorControl, self), pDstRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl_SetMirror(self: *const T, eMirror: MF_VIDEO_PROCESSOR_MIRROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl.VTable, self.vtable).SetMirror(@ptrCast(*const IMFVideoProcessorControl, self), eMirror);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl_SetRotation(self: *const T, eRotation: MF_VIDEO_PROCESSOR_ROTATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl.VTable, self.vtable).SetRotation(@ptrCast(*const IMFVideoProcessorControl, self), eRotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl_SetConstrictionSize(self: *const T, pConstrictionSize: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl.VTable, self.vtable).SetConstrictionSize(@ptrCast(*const IMFVideoProcessorControl, self), pConstrictionSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoProcessorControl2_Value = @import("../zig.zig").Guid.initString("BDE633D3-E1DC-4A7F-A693-BBAE399C4A20");
pub const IID_IMFVideoProcessorControl2 = &IID_IMFVideoProcessorControl2_Value;
pub const IMFVideoProcessorControl2 = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoProcessorControl.VTable,
        SetRotationOverride: fn(
            self: *const IMFVideoProcessorControl2,
            uiRotation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableHardwareEffects: fn(
            self: *const IMFVideoProcessorControl2,
            fEnabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedHardwareEffects: fn(
            self: *const IMFVideoProcessorControl2,
            puiSupport: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFVideoProcessorControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl2_SetRotationOverride(self: *const T, uiRotation: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl2.VTable, self.vtable).SetRotationOverride(@ptrCast(*const IMFVideoProcessorControl2, self), uiRotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl2_EnableHardwareEffects(self: *const T, fEnabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl2.VTable, self.vtable).EnableHardwareEffects(@ptrCast(*const IMFVideoProcessorControl2, self), fEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl2_GetSupportedHardwareEffects(self: *const T, puiSupport: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl2.VTable, self.vtable).GetSupportedHardwareEffects(@ptrCast(*const IMFVideoProcessorControl2, self), puiSupport);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoSphericalFormat = extern enum(i32) {
    Unsupported = 0,
    Equirectangular = 1,
    CubeMap = 2,
    _3DMesh = 3,
};
pub const MFVideoSphericalFormat_Unsupported = MFVideoSphericalFormat.Unsupported;
pub const MFVideoSphericalFormat_Equirectangular = MFVideoSphericalFormat.Equirectangular;
pub const MFVideoSphericalFormat_CubeMap = MFVideoSphericalFormat.CubeMap;
pub const MFVideoSphericalFormat_3DMesh = MFVideoSphericalFormat._3DMesh;

pub const MFVideoSphericalProjectionMode = extern enum(i32) {
    Spherical = 0,
    Flat = 1,
};
pub const MFVideoSphericalProjectionMode_Spherical = MFVideoSphericalProjectionMode.Spherical;
pub const MFVideoSphericalProjectionMode_Flat = MFVideoSphericalProjectionMode.Flat;

const IID_IMFVideoProcessorControl3_Value = @import("../zig.zig").Guid.initString("2424B3F2-EB23-40F1-91AA-74BDDEEA0883");
pub const IID_IMFVideoProcessorControl3 = &IID_IMFVideoProcessorControl3_Value;
pub const IMFVideoProcessorControl3 = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoProcessorControl2.VTable,
        GetNaturalOutputType: fn(
            self: *const IMFVideoProcessorControl3,
            ppType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableSphericalVideoProcessing: fn(
            self: *const IMFVideoProcessorControl3,
            fEnable: BOOL,
            eFormat: MFVideoSphericalFormat,
            eProjectionMode: MFVideoSphericalProjectionMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSphericalVideoProperties: fn(
            self: *const IMFVideoProcessorControl3,
            X: f32,
            Y: f32,
            Z: f32,
            W: f32,
            fieldOfView: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputDevice: fn(
            self: *const IMFVideoProcessorControl3,
            pOutputDevice: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFVideoProcessorControl2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl3_GetNaturalOutputType(self: *const T, ppType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl3.VTable, self.vtable).GetNaturalOutputType(@ptrCast(*const IMFVideoProcessorControl3, self), ppType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl3_EnableSphericalVideoProcessing(self: *const T, fEnable: BOOL, eFormat: MFVideoSphericalFormat, eProjectionMode: MFVideoSphericalProjectionMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl3.VTable, self.vtable).EnableSphericalVideoProcessing(@ptrCast(*const IMFVideoProcessorControl3, self), fEnable, eFormat, eProjectionMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl3_SetSphericalVideoProperties(self: *const T, X: f32, Y: f32, Z: f32, W: f32, fieldOfView: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl3.VTable, self.vtable).SetSphericalVideoProperties(@ptrCast(*const IMFVideoProcessorControl3, self), X, Y, Z, W, fieldOfView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessorControl3_SetOutputDevice(self: *const T, pOutputDevice: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessorControl3.VTable, self.vtable).SetOutputDevice(@ptrCast(*const IMFVideoProcessorControl3, self), pOutputDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoRendererEffectControl_Value = @import("../zig.zig").Guid.initString("604D33D7-CF23-41D5-8224-5BBBB1A87475");
pub const IID_IMFVideoRendererEffectControl = &IID_IMFVideoRendererEffectControl_Value;
pub const IMFVideoRendererEffectControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAppServiceConnectionEstablished: fn(
            self: *const IMFVideoRendererEffectControl,
            pAppServiceConnection: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoRendererEffectControl_OnAppServiceConnectionEstablished(self: *const T, pAppServiceConnection: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoRendererEffectControl.VTable, self.vtable).OnAppServiceConnectionEstablished(@ptrCast(*const IMFVideoRendererEffectControl, self), pAppServiceConnection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTopology_Value = @import("../zig.zig").Guid.initString("83CF873A-F6DA-4BC8-823F-BACFD55DC433");
pub const IID_IMFTopology = &IID_IMFTopology_Value;
pub const IMFTopology = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetTopologyID: fn(
            self: *const IMFTopology,
            pID: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddNode: fn(
            self: *const IMFTopology,
            pNode: *IMFTopologyNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveNode: fn(
            self: *const IMFTopology,
            pNode: *IMFTopologyNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNodeCount: fn(
            self: *const IMFTopology,
            pwNodes: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNode: fn(
            self: *const IMFTopology,
            wIndex: u16,
            ppNode: **IMFTopologyNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloneFrom: fn(
            self: *const IMFTopology,
            pTopology: *IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNodeByID: fn(
            self: *const IMFTopology,
            qwTopoNodeID: u64,
            ppNode: **IMFTopologyNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceNodeCollection: fn(
            self: *const IMFTopology,
            ppCollection: **IMFCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputNodeCollection: fn(
            self: *const IMFTopology,
            ppCollection: **IMFCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_GetTopologyID(self: *const T, pID: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).GetTopologyID(@ptrCast(*const IMFTopology, self), pID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_AddNode(self: *const T, pNode: *IMFTopologyNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).AddNode(@ptrCast(*const IMFTopology, self), pNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_RemoveNode(self: *const T, pNode: *IMFTopologyNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).RemoveNode(@ptrCast(*const IMFTopology, self), pNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_GetNodeCount(self: *const T, pwNodes: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).GetNodeCount(@ptrCast(*const IMFTopology, self), pwNodes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_GetNode(self: *const T, wIndex: u16, ppNode: **IMFTopologyNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).GetNode(@ptrCast(*const IMFTopology, self), wIndex, ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).Clear(@ptrCast(*const IMFTopology, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_CloneFrom(self: *const T, pTopology: *IMFTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).CloneFrom(@ptrCast(*const IMFTopology, self), pTopology);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_GetNodeByID(self: *const T, qwTopoNodeID: u64, ppNode: **IMFTopologyNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).GetNodeByID(@ptrCast(*const IMFTopology, self), qwTopoNodeID, ppNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_GetSourceNodeCollection(self: *const T, ppCollection: **IMFCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).GetSourceNodeCollection(@ptrCast(*const IMFTopology, self), ppCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopology_GetOutputNodeCollection(self: *const T, ppCollection: **IMFCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopology.VTable, self.vtable).GetOutputNodeCollection(@ptrCast(*const IMFTopology, self), ppCollection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFTOPOLOGY_DXVA_MODE = extern enum(i32) {
    MFTOPOLOGY_DXVA_DEFAULT = 0,
    MFTOPOLOGY_DXVA_NONE = 1,
    MFTOPOLOGY_DXVA_FULL = 2,
};
pub const MFTOPOLOGY_DXVA_DEFAULT = MFTOPOLOGY_DXVA_MODE.MFTOPOLOGY_DXVA_DEFAULT;
pub const MFTOPOLOGY_DXVA_NONE = MFTOPOLOGY_DXVA_MODE.MFTOPOLOGY_DXVA_NONE;
pub const MFTOPOLOGY_DXVA_FULL = MFTOPOLOGY_DXVA_MODE.MFTOPOLOGY_DXVA_FULL;

pub const MFTOPOLOGY_HARDWARE_MODE = extern enum(i32) {
    MFTOPOLOGY_HWMODE_SOFTWARE_ONLY = 0,
    MFTOPOLOGY_HWMODE_USE_HARDWARE = 1,
    MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE = 2,
};
pub const MFTOPOLOGY_HWMODE_SOFTWARE_ONLY = MFTOPOLOGY_HARDWARE_MODE.MFTOPOLOGY_HWMODE_SOFTWARE_ONLY;
pub const MFTOPOLOGY_HWMODE_USE_HARDWARE = MFTOPOLOGY_HARDWARE_MODE.MFTOPOLOGY_HWMODE_USE_HARDWARE;
pub const MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE = MFTOPOLOGY_HARDWARE_MODE.MFTOPOLOGY_HWMODE_USE_ONLY_HARDWARE;

pub const MF_TOPOLOGY_TYPE = extern enum(i32) {
    MF_TOPOLOGY_OUTPUT_NODE = 0,
    MF_TOPOLOGY_SOURCESTREAM_NODE = 1,
    MF_TOPOLOGY_TRANSFORM_NODE = 2,
    MF_TOPOLOGY_TEE_NODE = 3,
    MF_TOPOLOGY_MAX = -1,
};
pub const MF_TOPOLOGY_OUTPUT_NODE = MF_TOPOLOGY_TYPE.MF_TOPOLOGY_OUTPUT_NODE;
pub const MF_TOPOLOGY_SOURCESTREAM_NODE = MF_TOPOLOGY_TYPE.MF_TOPOLOGY_SOURCESTREAM_NODE;
pub const MF_TOPOLOGY_TRANSFORM_NODE = MF_TOPOLOGY_TYPE.MF_TOPOLOGY_TRANSFORM_NODE;
pub const MF_TOPOLOGY_TEE_NODE = MF_TOPOLOGY_TYPE.MF_TOPOLOGY_TEE_NODE;
pub const MF_TOPOLOGY_MAX = MF_TOPOLOGY_TYPE.MF_TOPOLOGY_MAX;

const IID_IMFTopologyNode_Value = @import("../zig.zig").Guid.initString("83CF873A-F6DA-4BC8-823F-BACFD55DC430");
pub const IID_IMFTopologyNode = &IID_IMFTopologyNode_Value;
pub const IMFTopologyNode = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        SetObject: fn(
            self: *const IMFTopologyNode,
            pObject: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const IMFTopologyNode,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNodeType: fn(
            self: *const IMFTopologyNode,
            pType: *MF_TOPOLOGY_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTopoNodeID: fn(
            self: *const IMFTopologyNode,
            pID: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTopoNodeID: fn(
            self: *const IMFTopologyNode,
            ullTopoID: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCount: fn(
            self: *const IMFTopologyNode,
            pcInputs: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCount: fn(
            self: *const IMFTopologyNode,
            pcOutputs: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectOutput: fn(
            self: *const IMFTopologyNode,
            dwOutputIndex: u32,
            pDownstreamNode: *IMFTopologyNode,
            dwInputIndexOnDownstreamNode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectOutput: fn(
            self: *const IMFTopologyNode,
            dwOutputIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInput: fn(
            self: *const IMFTopologyNode,
            dwInputIndex: u32,
            ppUpstreamNode: **IMFTopologyNode,
            pdwOutputIndexOnUpstreamNode: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutput: fn(
            self: *const IMFTopologyNode,
            dwOutputIndex: u32,
            ppDownstreamNode: **IMFTopologyNode,
            pdwInputIndexOnDownstreamNode: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputPrefType: fn(
            self: *const IMFTopologyNode,
            dwOutputIndex: u32,
            pType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputPrefType: fn(
            self: *const IMFTopologyNode,
            dwOutputIndex: u32,
            ppType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputPrefType: fn(
            self: *const IMFTopologyNode,
            dwInputIndex: u32,
            pType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputPrefType: fn(
            self: *const IMFTopologyNode,
            dwInputIndex: u32,
            ppType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloneFrom: fn(
            self: *const IMFTopologyNode,
            pNode: *IMFTopologyNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_SetObject(self: *const T, pObject: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).SetObject(@ptrCast(*const IMFTopologyNode, self), pObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_GetObject(self: *const T, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).GetObject(@ptrCast(*const IMFTopologyNode, self), ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_GetNodeType(self: *const T, pType: *MF_TOPOLOGY_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).GetNodeType(@ptrCast(*const IMFTopologyNode, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_GetTopoNodeID(self: *const T, pID: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).GetTopoNodeID(@ptrCast(*const IMFTopologyNode, self), pID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_SetTopoNodeID(self: *const T, ullTopoID: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).SetTopoNodeID(@ptrCast(*const IMFTopologyNode, self), ullTopoID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_GetInputCount(self: *const T, pcInputs: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).GetInputCount(@ptrCast(*const IMFTopologyNode, self), pcInputs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_GetOutputCount(self: *const T, pcOutputs: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).GetOutputCount(@ptrCast(*const IMFTopologyNode, self), pcOutputs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_ConnectOutput(self: *const T, dwOutputIndex: u32, pDownstreamNode: *IMFTopologyNode, dwInputIndexOnDownstreamNode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).ConnectOutput(@ptrCast(*const IMFTopologyNode, self), dwOutputIndex, pDownstreamNode, dwInputIndexOnDownstreamNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_DisconnectOutput(self: *const T, dwOutputIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).DisconnectOutput(@ptrCast(*const IMFTopologyNode, self), dwOutputIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_GetInput(self: *const T, dwInputIndex: u32, ppUpstreamNode: **IMFTopologyNode, pdwOutputIndexOnUpstreamNode: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).GetInput(@ptrCast(*const IMFTopologyNode, self), dwInputIndex, ppUpstreamNode, pdwOutputIndexOnUpstreamNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_GetOutput(self: *const T, dwOutputIndex: u32, ppDownstreamNode: **IMFTopologyNode, pdwInputIndexOnDownstreamNode: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).GetOutput(@ptrCast(*const IMFTopologyNode, self), dwOutputIndex, ppDownstreamNode, pdwInputIndexOnDownstreamNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_SetOutputPrefType(self: *const T, dwOutputIndex: u32, pType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).SetOutputPrefType(@ptrCast(*const IMFTopologyNode, self), dwOutputIndex, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_GetOutputPrefType(self: *const T, dwOutputIndex: u32, ppType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).GetOutputPrefType(@ptrCast(*const IMFTopologyNode, self), dwOutputIndex, ppType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_SetInputPrefType(self: *const T, dwInputIndex: u32, pType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).SetInputPrefType(@ptrCast(*const IMFTopologyNode, self), dwInputIndex, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_GetInputPrefType(self: *const T, dwInputIndex: u32, ppType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).GetInputPrefType(@ptrCast(*const IMFTopologyNode, self), dwInputIndex, ppType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNode_CloneFrom(self: *const T, pNode: *IMFTopologyNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNode.VTable, self.vtable).CloneFrom(@ptrCast(*const IMFTopologyNode, self), pNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TOPONODE_FLUSH_MODE = extern enum(i32) {
    MF_TOPONODE_FLUSH_ALWAYS = 0,
    MF_TOPONODE_FLUSH_SEEK = 1,
    MF_TOPONODE_FLUSH_NEVER = 2,
};
pub const MF_TOPONODE_FLUSH_ALWAYS = MF_TOPONODE_FLUSH_MODE.MF_TOPONODE_FLUSH_ALWAYS;
pub const MF_TOPONODE_FLUSH_SEEK = MF_TOPONODE_FLUSH_MODE.MF_TOPONODE_FLUSH_SEEK;
pub const MF_TOPONODE_FLUSH_NEVER = MF_TOPONODE_FLUSH_MODE.MF_TOPONODE_FLUSH_NEVER;

pub const MF_TOPONODE_DRAIN_MODE = extern enum(i32) {
    MF_TOPONODE_DRAIN_DEFAULT = 0,
    MF_TOPONODE_DRAIN_ALWAYS = 1,
    MF_TOPONODE_DRAIN_NEVER = 2,
};
pub const MF_TOPONODE_DRAIN_DEFAULT = MF_TOPONODE_DRAIN_MODE.MF_TOPONODE_DRAIN_DEFAULT;
pub const MF_TOPONODE_DRAIN_ALWAYS = MF_TOPONODE_DRAIN_MODE.MF_TOPONODE_DRAIN_ALWAYS;
pub const MF_TOPONODE_DRAIN_NEVER = MF_TOPONODE_DRAIN_MODE.MF_TOPONODE_DRAIN_NEVER;

const IID_IMFGetService_Value = @import("../zig.zig").Guid.initString("FA993888-4383-415A-A930-DD472A8CF6F7");
pub const IID_IMFGetService = &IID_IMFGetService_Value;
pub const IMFGetService = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetService: fn(
            self: *const IMFGetService,
            guidService: *const Guid,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFGetService_GetService(self: *const T, guidService: *const Guid, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFGetService.VTable, self.vtable).GetService(@ptrCast(*const IMFGetService, self), guidService, riid, ppvObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFCLOCK_CHARACTERISTICS_FLAGS = extern enum(i32) {
    MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ = 2,
    MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING = 4,
    MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK = 8,
};
pub const MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ = MFCLOCK_CHARACTERISTICS_FLAGS.MFCLOCK_CHARACTERISTICS_FLAG_FREQUENCY_10MHZ;
pub const MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING = MFCLOCK_CHARACTERISTICS_FLAGS.MFCLOCK_CHARACTERISTICS_FLAG_ALWAYS_RUNNING;
pub const MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK = MFCLOCK_CHARACTERISTICS_FLAGS.MFCLOCK_CHARACTERISTICS_FLAG_IS_SYSTEM_CLOCK;

pub const MFCLOCK_STATE = extern enum(i32) {
    INVALID = 0,
    RUNNING = 1,
    STOPPED = 2,
    PAUSED = 3,
};
pub const MFCLOCK_STATE_INVALID = MFCLOCK_STATE.INVALID;
pub const MFCLOCK_STATE_RUNNING = MFCLOCK_STATE.RUNNING;
pub const MFCLOCK_STATE_STOPPED = MFCLOCK_STATE.STOPPED;
pub const MFCLOCK_STATE_PAUSED = MFCLOCK_STATE.PAUSED;

pub const MFCLOCK_RELATIONAL_FLAGS = extern enum(i32) {
    MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD = 1,
};
pub const MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD = MFCLOCK_RELATIONAL_FLAGS.MFCLOCK_RELATIONAL_FLAG_JITTER_NEVER_AHEAD;

pub const MFCLOCK_PROPERTIES = extern struct {
    qwCorrelationRate: u64,
    guidClockId: Guid,
    dwClockFlags: u32,
    qwClockFrequency: u64,
    dwClockTolerance: u32,
    dwClockJitter: u32,
};

const IID_IMFClock_Value = @import("../zig.zig").Guid.initString("2EB1E945-18B8-4139-9B1A-D5D584818530");
pub const IID_IMFClock = &IID_IMFClock_Value;
pub const IMFClock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClockCharacteristics: fn(
            self: *const IMFClock,
            pdwCharacteristics: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCorrelatedTime: fn(
            self: *const IMFClock,
            dwReserved: u32,
            pllClockTime: *i64,
            phnsSystemTime: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContinuityKey: fn(
            self: *const IMFClock,
            pdwContinuityKey: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IMFClock,
            dwReserved: u32,
            peClockState: *MFCLOCK_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const IMFClock,
            pClockProperties: *MFCLOCK_PROPERTIES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClock_GetClockCharacteristics(self: *const T, pdwCharacteristics: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClock.VTable, self.vtable).GetClockCharacteristics(@ptrCast(*const IMFClock, self), pdwCharacteristics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClock_GetCorrelatedTime(self: *const T, dwReserved: u32, pllClockTime: *i64, phnsSystemTime: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClock.VTable, self.vtable).GetCorrelatedTime(@ptrCast(*const IMFClock, self), dwReserved, pllClockTime, phnsSystemTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClock_GetContinuityKey(self: *const T, pdwContinuityKey: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClock.VTable, self.vtable).GetContinuityKey(@ptrCast(*const IMFClock, self), pdwContinuityKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClock_GetState(self: *const T, dwReserved: u32, peClockState: *MFCLOCK_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClock.VTable, self.vtable).GetState(@ptrCast(*const IMFClock, self), dwReserved, peClockState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClock_GetProperties(self: *const T, pClockProperties: *MFCLOCK_PROPERTIES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClock.VTable, self.vtable).GetProperties(@ptrCast(*const IMFClock, self), pClockProperties);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPresentationClock_Value = @import("../zig.zig").Guid.initString("868CE85C-8EA9-4F55-AB82-B009A910A805");
pub const IID_IMFPresentationClock = &IID_IMFPresentationClock_Value;
pub const IMFPresentationClock = extern struct {
    pub const VTable = extern struct {
        base: IMFClock.VTable,
        SetTimeSource: fn(
            self: *const IMFPresentationClock,
            pTimeSource: *IMFPresentationTimeSource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeSource: fn(
            self: *const IMFPresentationClock,
            ppTimeSource: **IMFPresentationTimeSource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTime: fn(
            self: *const IMFPresentationClock,
            phnsClockTime: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddClockStateSink: fn(
            self: *const IMFPresentationClock,
            pStateSink: *IMFClockStateSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveClockStateSink: fn(
            self: *const IMFPresentationClock,
            pStateSink: *IMFClockStateSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: fn(
            self: *const IMFPresentationClock,
            llClockStartOffset: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IMFPresentationClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IMFPresentationClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFClock.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationClock_SetTimeSource(self: *const T, pTimeSource: *IMFPresentationTimeSource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationClock.VTable, self.vtable).SetTimeSource(@ptrCast(*const IMFPresentationClock, self), pTimeSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationClock_GetTimeSource(self: *const T, ppTimeSource: **IMFPresentationTimeSource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationClock.VTable, self.vtable).GetTimeSource(@ptrCast(*const IMFPresentationClock, self), ppTimeSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationClock_GetTime(self: *const T, phnsClockTime: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationClock.VTable, self.vtable).GetTime(@ptrCast(*const IMFPresentationClock, self), phnsClockTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationClock_AddClockStateSink(self: *const T, pStateSink: *IMFClockStateSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationClock.VTable, self.vtable).AddClockStateSink(@ptrCast(*const IMFPresentationClock, self), pStateSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationClock_RemoveClockStateSink(self: *const T, pStateSink: *IMFClockStateSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationClock.VTable, self.vtable).RemoveClockStateSink(@ptrCast(*const IMFPresentationClock, self), pStateSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationClock_Start(self: *const T, llClockStartOffset: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationClock.VTable, self.vtable).Start(@ptrCast(*const IMFPresentationClock, self), llClockStartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationClock_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationClock.VTable, self.vtable).Stop(@ptrCast(*const IMFPresentationClock, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationClock_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationClock.VTable, self.vtable).Pause(@ptrCast(*const IMFPresentationClock, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPresentationTimeSource_Value = @import("../zig.zig").Guid.initString("7FF12CCE-F76F-41C2-863B-1666C8E5E139");
pub const IID_IMFPresentationTimeSource = &IID_IMFPresentationTimeSource_Value;
pub const IMFPresentationTimeSource = extern struct {
    pub const VTable = extern struct {
        base: IMFClock.VTable,
        GetUnderlyingClock: fn(
            self: *const IMFPresentationTimeSource,
            ppClock: **IMFClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFClock.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationTimeSource_GetUnderlyingClock(self: *const T, ppClock: **IMFClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationTimeSource.VTable, self.vtable).GetUnderlyingClock(@ptrCast(*const IMFPresentationTimeSource, self), ppClock);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFClockStateSink_Value = @import("../zig.zig").Guid.initString("F6696E82-74F7-4F3D-A178-8A5E09C3659F");
pub const IID_IMFClockStateSink = &IID_IMFClockStateSink_Value;
pub const IMFClockStateSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnClockStart: fn(
            self: *const IMFClockStateSink,
            hnsSystemTime: i64,
            llClockStartOffset: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnClockStop: fn(
            self: *const IMFClockStateSink,
            hnsSystemTime: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnClockPause: fn(
            self: *const IMFClockStateSink,
            hnsSystemTime: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnClockRestart: fn(
            self: *const IMFClockStateSink,
            hnsSystemTime: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnClockSetRate: fn(
            self: *const IMFClockStateSink,
            hnsSystemTime: i64,
            flRate: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClockStateSink_OnClockStart(self: *const T, hnsSystemTime: i64, llClockStartOffset: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClockStateSink.VTable, self.vtable).OnClockStart(@ptrCast(*const IMFClockStateSink, self), hnsSystemTime, llClockStartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClockStateSink_OnClockStop(self: *const T, hnsSystemTime: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClockStateSink.VTable, self.vtable).OnClockStop(@ptrCast(*const IMFClockStateSink, self), hnsSystemTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClockStateSink_OnClockPause(self: *const T, hnsSystemTime: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClockStateSink.VTable, self.vtable).OnClockPause(@ptrCast(*const IMFClockStateSink, self), hnsSystemTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClockStateSink_OnClockRestart(self: *const T, hnsSystemTime: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClockStateSink.VTable, self.vtable).OnClockRestart(@ptrCast(*const IMFClockStateSink, self), hnsSystemTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFClockStateSink_OnClockSetRate(self: *const T, hnsSystemTime: i64, flRate: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFClockStateSink.VTable, self.vtable).OnClockSetRate(@ptrCast(*const IMFClockStateSink, self), hnsSystemTime, flRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPresentationDescriptor_Value = @import("../zig.zig").Guid.initString("03CB2711-24D7-4DB6-A17F-F3A7A479A536");
pub const IID_IMFPresentationDescriptor = &IID_IMFPresentationDescriptor_Value;
pub const IMFPresentationDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetStreamDescriptorCount: fn(
            self: *const IMFPresentationDescriptor,
            pdwDescriptorCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamDescriptorByIndex: fn(
            self: *const IMFPresentationDescriptor,
            dwIndex: u32,
            pfSelected: *BOOL,
            ppDescriptor: **IMFStreamDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectStream: fn(
            self: *const IMFPresentationDescriptor,
            dwDescriptorIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeselectStream: fn(
            self: *const IMFPresentationDescriptor,
            dwDescriptorIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IMFPresentationDescriptor,
            ppPresentationDescriptor: **IMFPresentationDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationDescriptor_GetStreamDescriptorCount(self: *const T, pdwDescriptorCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationDescriptor.VTable, self.vtable).GetStreamDescriptorCount(@ptrCast(*const IMFPresentationDescriptor, self), pdwDescriptorCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationDescriptor_GetStreamDescriptorByIndex(self: *const T, dwIndex: u32, pfSelected: *BOOL, ppDescriptor: **IMFStreamDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationDescriptor.VTable, self.vtable).GetStreamDescriptorByIndex(@ptrCast(*const IMFPresentationDescriptor, self), dwIndex, pfSelected, ppDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationDescriptor_SelectStream(self: *const T, dwDescriptorIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationDescriptor.VTable, self.vtable).SelectStream(@ptrCast(*const IMFPresentationDescriptor, self), dwDescriptorIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationDescriptor_DeselectStream(self: *const T, dwDescriptorIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationDescriptor.VTable, self.vtable).DeselectStream(@ptrCast(*const IMFPresentationDescriptor, self), dwDescriptorIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPresentationDescriptor_Clone(self: *const T, ppPresentationDescriptor: **IMFPresentationDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPresentationDescriptor.VTable, self.vtable).Clone(@ptrCast(*const IMFPresentationDescriptor, self), ppPresentationDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFStreamDescriptor_Value = @import("../zig.zig").Guid.initString("56C03D9C-9DBB-45F5-AB4B-D80F47C05938");
pub const IID_IMFStreamDescriptor = &IID_IMFStreamDescriptor_Value;
pub const IMFStreamDescriptor = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetStreamIdentifier: fn(
            self: *const IMFStreamDescriptor,
            pdwStreamIdentifier: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaTypeHandler: fn(
            self: *const IMFStreamDescriptor,
            ppMediaTypeHandler: **IMFMediaTypeHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFStreamDescriptor_GetStreamIdentifier(self: *const T, pdwStreamIdentifier: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFStreamDescriptor.VTable, self.vtable).GetStreamIdentifier(@ptrCast(*const IMFStreamDescriptor, self), pdwStreamIdentifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFStreamDescriptor_GetMediaTypeHandler(self: *const T, ppMediaTypeHandler: **IMFMediaTypeHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFStreamDescriptor.VTable, self.vtable).GetMediaTypeHandler(@ptrCast(*const IMFStreamDescriptor, self), ppMediaTypeHandler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaTypeHandler_Value = @import("../zig.zig").Guid.initString("E93DCF6C-4B07-4E1E-8123-AA16ED6EADF5");
pub const IID_IMFMediaTypeHandler = &IID_IMFMediaTypeHandler_Value;
pub const IMFMediaTypeHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMediaTypeSupported: fn(
            self: *const IMFMediaTypeHandler,
            pMediaType: *IMFMediaType,
            ppMediaType: ?*?*IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaTypeCount: fn(
            self: *const IMFMediaTypeHandler,
            pdwTypeCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaTypeByIndex: fn(
            self: *const IMFMediaTypeHandler,
            dwIndex: u32,
            ppType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentMediaType: fn(
            self: *const IMFMediaTypeHandler,
            pMediaType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentMediaType: fn(
            self: *const IMFMediaTypeHandler,
            ppMediaType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMajorType: fn(
            self: *const IMFMediaTypeHandler,
            pguidMajorType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTypeHandler_IsMediaTypeSupported(self: *const T, pMediaType: *IMFMediaType, ppMediaType: ?*?*IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTypeHandler.VTable, self.vtable).IsMediaTypeSupported(@ptrCast(*const IMFMediaTypeHandler, self), pMediaType, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTypeHandler_GetMediaTypeCount(self: *const T, pdwTypeCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTypeHandler.VTable, self.vtable).GetMediaTypeCount(@ptrCast(*const IMFMediaTypeHandler, self), pdwTypeCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTypeHandler_GetMediaTypeByIndex(self: *const T, dwIndex: u32, ppType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTypeHandler.VTable, self.vtable).GetMediaTypeByIndex(@ptrCast(*const IMFMediaTypeHandler, self), dwIndex, ppType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTypeHandler_SetCurrentMediaType(self: *const T, pMediaType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTypeHandler.VTable, self.vtable).SetCurrentMediaType(@ptrCast(*const IMFMediaTypeHandler, self), pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTypeHandler_GetCurrentMediaType(self: *const T, ppMediaType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTypeHandler.VTable, self.vtable).GetCurrentMediaType(@ptrCast(*const IMFMediaTypeHandler, self), ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTypeHandler_GetMajorType(self: *const T, pguidMajorType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTypeHandler.VTable, self.vtable).GetMajorType(@ptrCast(*const IMFMediaTypeHandler, self), pguidMajorType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFTIMER_FLAGS = extern enum(i32) {
    MFTIMER_RELATIVE = 1,
};
pub const MFTIMER_RELATIVE = MFTIMER_FLAGS.MFTIMER_RELATIVE;

const IID_IMFTimer_Value = @import("../zig.zig").Guid.initString("E56E4CBD-8F70-49D8-A0F8-EDB3D6AB9BF2");
pub const IID_IMFTimer = &IID_IMFTimer_Value;
pub const IMFTimer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTimer: fn(
            self: *const IMFTimer,
            dwFlags: u32,
            llClockTime: i64,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
            ppunkKey: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelTimer: fn(
            self: *const IMFTimer,
            punkKey: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimer_SetTimer(self: *const T, dwFlags: u32, llClockTime: i64, pCallback: *IMFAsyncCallback, punkState: *IUnknown, ppunkKey: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimer.VTable, self.vtable).SetTimer(@ptrCast(*const IMFTimer, self), dwFlags, llClockTime, pCallback, punkState, ppunkKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimer_CancelTimer(self: *const T, punkKey: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimer.VTable, self.vtable).CancelTimer(@ptrCast(*const IMFTimer, self), punkKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_mfidl_0000_0029_0001 = extern enum(i32) {
    MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL = 1,
};
pub const MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL = __MIDL___MIDL_itf_mfidl_0000_0029_0001.MF_ACTIVATE_CUSTOM_MIXER_ALLOWFAIL;

pub const __MIDL___MIDL_itf_mfidl_0000_0029_0002 = extern enum(i32) {
    MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL = 1,
};
pub const MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL = __MIDL___MIDL_itf_mfidl_0000_0029_0002.MF_ACTIVATE_CUSTOM_PRESENTER_ALLOWFAIL;

pub const MFSHUTDOWN_STATUS = extern enum(i32) {
    MFSHUTDOWN_INITIATED = 0,
    MFSHUTDOWN_COMPLETED = 1,
};
pub const MFSHUTDOWN_INITIATED = MFSHUTDOWN_STATUS.MFSHUTDOWN_INITIATED;
pub const MFSHUTDOWN_COMPLETED = MFSHUTDOWN_STATUS.MFSHUTDOWN_COMPLETED;

const IID_IMFShutdown_Value = @import("../zig.zig").Guid.initString("97EC2EA4-0E42-4937-97AC-9D6D328824E1");
pub const IID_IMFShutdown = &IID_IMFShutdown_Value;
pub const IMFShutdown = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Shutdown: fn(
            self: *const IMFShutdown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShutdownStatus: fn(
            self: *const IMFShutdown,
            pStatus: *MFSHUTDOWN_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFShutdown_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFShutdown.VTable, self.vtable).Shutdown(@ptrCast(*const IMFShutdown, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFShutdown_GetShutdownStatus(self: *const T, pStatus: *MFSHUTDOWN_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFShutdown.VTable, self.vtable).GetShutdownStatus(@ptrCast(*const IMFShutdown, self), pStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTopoLoader_Value = @import("../zig.zig").Guid.initString("DE9A6157-F660-4643-B56A-DF9F7998C7CD");
pub const IID_IMFTopoLoader = &IID_IMFTopoLoader_Value;
pub const IMFTopoLoader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Load: fn(
            self: *const IMFTopoLoader,
            pInputTopo: *IMFTopology,
            ppOutputTopo: **IMFTopology,
            pCurrentTopo: *IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopoLoader_Load(self: *const T, pInputTopo: *IMFTopology, ppOutputTopo: **IMFTopology, pCurrentTopo: *IMFTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopoLoader.VTable, self.vtable).Load(@ptrCast(*const IMFTopoLoader, self), pInputTopo, ppOutputTopo, pCurrentTopo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFContentProtectionManager_Value = @import("../zig.zig").Guid.initString("ACF92459-6A61-42BD-B57C-B43E51203CB0");
pub const IID_IMFContentProtectionManager = &IID_IMFContentProtectionManager_Value;
pub const IMFContentProtectionManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginEnableContent: fn(
            self: *const IMFContentProtectionManager,
            pEnablerActivate: *IMFActivate,
            pTopo: *IMFTopology,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndEnableContent: fn(
            self: *const IMFContentProtectionManager,
            pResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentProtectionManager_BeginEnableContent(self: *const T, pEnablerActivate: *IMFActivate, pTopo: *IMFTopology, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentProtectionManager.VTable, self.vtable).BeginEnableContent(@ptrCast(*const IMFContentProtectionManager, self), pEnablerActivate, pTopo, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentProtectionManager_EndEnableContent(self: *const T, pResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentProtectionManager.VTable, self.vtable).EndEnableContent(@ptrCast(*const IMFContentProtectionManager, self), pResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_URL_TRUST_STATUS = extern enum(i32) {
    MF_LICENSE_URL_UNTRUSTED = 0,
    MF_LICENSE_URL_TRUSTED = 1,
    MF_LICENSE_URL_TAMPERED = 2,
};
pub const MF_LICENSE_URL_UNTRUSTED = MF_URL_TRUST_STATUS.MF_LICENSE_URL_UNTRUSTED;
pub const MF_LICENSE_URL_TRUSTED = MF_URL_TRUST_STATUS.MF_LICENSE_URL_TRUSTED;
pub const MF_LICENSE_URL_TAMPERED = MF_URL_TRUST_STATUS.MF_LICENSE_URL_TAMPERED;

const IID_IMFContentEnabler_Value = @import("../zig.zig").Guid.initString("D3C4EF59-49CE-4381-9071-D5BCD044C770");
pub const IID_IMFContentEnabler = &IID_IMFContentEnabler_Value;
pub const IMFContentEnabler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEnableType: fn(
            self: *const IMFContentEnabler,
            pType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnableURL: fn(
            self: *const IMFContentEnabler,
            ppwszURL: [*]PWSTR,
            pcchURL: *u32,
            pTrustStatus: *MF_URL_TRUST_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnableData: fn(
            self: *const IMFContentEnabler,
            ppbData: [*]*u8,
            pcbData: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAutomaticSupported: fn(
            self: *const IMFContentEnabler,
            pfAutomatic: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutomaticEnable: fn(
            self: *const IMFContentEnabler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MonitorEnable: fn(
            self: *const IMFContentEnabler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IMFContentEnabler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentEnabler_GetEnableType(self: *const T, pType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentEnabler.VTable, self.vtable).GetEnableType(@ptrCast(*const IMFContentEnabler, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentEnabler_GetEnableURL(self: *const T, ppwszURL: [*]PWSTR, pcchURL: *u32, pTrustStatus: *MF_URL_TRUST_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentEnabler.VTable, self.vtable).GetEnableURL(@ptrCast(*const IMFContentEnabler, self), ppwszURL, pcchURL, pTrustStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentEnabler_GetEnableData(self: *const T, ppbData: [*]*u8, pcbData: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentEnabler.VTable, self.vtable).GetEnableData(@ptrCast(*const IMFContentEnabler, self), ppbData, pcbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentEnabler_IsAutomaticSupported(self: *const T, pfAutomatic: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentEnabler.VTable, self.vtable).IsAutomaticSupported(@ptrCast(*const IMFContentEnabler, self), pfAutomatic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentEnabler_AutomaticEnable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentEnabler.VTable, self.vtable).AutomaticEnable(@ptrCast(*const IMFContentEnabler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentEnabler_MonitorEnable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentEnabler.VTable, self.vtable).MonitorEnable(@ptrCast(*const IMFContentEnabler, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentEnabler_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentEnabler.VTable, self.vtable).Cancel(@ptrCast(*const IMFContentEnabler, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFRR_COMPONENT_HASH_INFO = extern struct {
    ulReason: u32,
    rgHeaderHash: [43]u16,
    rgPublicKeyHash: [43]u16,
    wszName: [260]u16,
};

pub const MFRR_COMPONENTS = extern struct {
    dwRRInfoVersion: u32,
    dwRRComponents: u32,
    pRRComponents: *MFRR_COMPONENT_HASH_INFO,
};

pub const ASF_FLAT_PICTURE = extern struct {
    bPictureType: u8,
    dwDataLen: u32,
};

pub const ASF_FLAT_SYNCHRONISED_LYRICS = extern struct {
    bTimeStampFormat: u8,
    bContentType: u8,
    dwLyricsLen: u32,
};

const IID_IMFMetadata_Value = @import("../zig.zig").Guid.initString("F88CFB8C-EF16-4991-B450-CB8C69E51704");
pub const IID_IMFMetadata = &IID_IMFMetadata_Value;
pub const IMFMetadata = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLanguage: fn(
            self: *const IMFMetadata,
            pwszRFC1766: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguage: fn(
            self: *const IMFMetadata,
            ppwszRFC1766: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllLanguages: fn(
            self: *const IMFMetadata,
            ppvLanguages: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IMFMetadata,
            pwszName: [*:0]const u16,
            ppvValue: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IMFMetadata,
            pwszName: [*:0]const u16,
            ppvValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteProperty: fn(
            self: *const IMFMetadata,
            pwszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllPropertyNames: fn(
            self: *const IMFMetadata,
            ppvNames: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMetadata_SetLanguage(self: *const T, pwszRFC1766: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMetadata.VTable, self.vtable).SetLanguage(@ptrCast(*const IMFMetadata, self), pwszRFC1766);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMetadata_GetLanguage(self: *const T, ppwszRFC1766: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMetadata.VTable, self.vtable).GetLanguage(@ptrCast(*const IMFMetadata, self), ppwszRFC1766);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMetadata_GetAllLanguages(self: *const T, ppvLanguages: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMetadata.VTable, self.vtable).GetAllLanguages(@ptrCast(*const IMFMetadata, self), ppvLanguages);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMetadata_SetProperty(self: *const T, pwszName: [*:0]const u16, ppvValue: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMetadata.VTable, self.vtable).SetProperty(@ptrCast(*const IMFMetadata, self), pwszName, ppvValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMetadata_GetProperty(self: *const T, pwszName: [*:0]const u16, ppvValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMetadata.VTable, self.vtable).GetProperty(@ptrCast(*const IMFMetadata, self), pwszName, ppvValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMetadata_DeleteProperty(self: *const T, pwszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMetadata.VTable, self.vtable).DeleteProperty(@ptrCast(*const IMFMetadata, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMetadata_GetAllPropertyNames(self: *const T, ppvNames: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMetadata.VTable, self.vtable).GetAllPropertyNames(@ptrCast(*const IMFMetadata, self), ppvNames);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMetadataProvider_Value = @import("../zig.zig").Guid.initString("56181D2D-E221-4ADB-B1C8-3CEE6A53F76F");
pub const IID_IMFMetadataProvider = &IID_IMFMetadataProvider_Value;
pub const IMFMetadataProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMFMetadata: fn(
            self: *const IMFMetadataProvider,
            pPresentationDescriptor: *IMFPresentationDescriptor,
            dwStreamIdentifier: u32,
            dwFlags: u32,
            ppMFMetadata: **IMFMetadata,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMetadataProvider_GetMFMetadata(self: *const T, pPresentationDescriptor: *IMFPresentationDescriptor, dwStreamIdentifier: u32, dwFlags: u32, ppMFMetadata: **IMFMetadata) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMetadataProvider.VTable, self.vtable).GetMFMetadata(@ptrCast(*const IMFMetadataProvider, self), pPresentationDescriptor, dwStreamIdentifier, dwFlags, ppMFMetadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFRATE_DIRECTION = extern enum(i32) {
    MFRATE_FORWARD = 0,
    MFRATE_REVERSE = 1,
};
pub const MFRATE_FORWARD = MFRATE_DIRECTION.MFRATE_FORWARD;
pub const MFRATE_REVERSE = MFRATE_DIRECTION.MFRATE_REVERSE;

const IID_IMFRateSupport_Value = @import("../zig.zig").Guid.initString("0A9CCDBC-D797-4563-9667-94EC5D79292D");
pub const IID_IMFRateSupport = &IID_IMFRateSupport_Value;
pub const IMFRateSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSlowestRate: fn(
            self: *const IMFRateSupport,
            eDirection: MFRATE_DIRECTION,
            fThin: BOOL,
            pflRate: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFastestRate: fn(
            self: *const IMFRateSupport,
            eDirection: MFRATE_DIRECTION,
            fThin: BOOL,
            pflRate: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRateSupported: fn(
            self: *const IMFRateSupport,
            fThin: BOOL,
            flRate: f32,
            pflNearestSupportedRate: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRateSupport_GetSlowestRate(self: *const T, eDirection: MFRATE_DIRECTION, fThin: BOOL, pflRate: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRateSupport.VTable, self.vtable).GetSlowestRate(@ptrCast(*const IMFRateSupport, self), eDirection, fThin, pflRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRateSupport_GetFastestRate(self: *const T, eDirection: MFRATE_DIRECTION, fThin: BOOL, pflRate: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRateSupport.VTable, self.vtable).GetFastestRate(@ptrCast(*const IMFRateSupport, self), eDirection, fThin, pflRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRateSupport_IsRateSupported(self: *const T, fThin: BOOL, flRate: f32, pflNearestSupportedRate: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRateSupport.VTable, self.vtable).IsRateSupported(@ptrCast(*const IMFRateSupport, self), fThin, flRate, pflNearestSupportedRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFRateControl_Value = @import("../zig.zig").Guid.initString("88DDCD21-03C3-4275-91ED-55EE3929328F");
pub const IID_IMFRateControl = &IID_IMFRateControl_Value;
pub const IMFRateControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetRate: fn(
            self: *const IMFRateControl,
            fThin: BOOL,
            flRate: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRate: fn(
            self: *const IMFRateControl,
            pfThin: *BOOL,
            pflRate: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRateControl_SetRate(self: *const T, fThin: BOOL, flRate: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRateControl.VTable, self.vtable).SetRate(@ptrCast(*const IMFRateControl, self), fThin, flRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRateControl_GetRate(self: *const T, pfThin: *BOOL, pflRate: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRateControl.VTable, self.vtable).GetRate(@ptrCast(*const IMFRateControl, self), pfThin, pflRate);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimecodeTranslate_Value = @import("../zig.zig").Guid.initString("AB9D8661-F7E8-4EF4-9861-89F334F94E74");
pub const IID_IMFTimecodeTranslate = &IID_IMFTimecodeTranslate_Value;
pub const IMFTimecodeTranslate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginConvertTimecodeToHNS: fn(
            self: *const IMFTimecodeTranslate,
            pPropVarTimecode: *const PROPVARIANT,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndConvertTimecodeToHNS: fn(
            self: *const IMFTimecodeTranslate,
            pResult: *IMFAsyncResult,
            phnsTime: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginConvertHNSToTimecode: fn(
            self: *const IMFTimecodeTranslate,
            hnsTime: i64,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndConvertHNSToTimecode: fn(
            self: *const IMFTimecodeTranslate,
            pResult: *IMFAsyncResult,
            pPropVarTimecode: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimecodeTranslate_BeginConvertTimecodeToHNS(self: *const T, pPropVarTimecode: *const PROPVARIANT, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimecodeTranslate.VTable, self.vtable).BeginConvertTimecodeToHNS(@ptrCast(*const IMFTimecodeTranslate, self), pPropVarTimecode, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimecodeTranslate_EndConvertTimecodeToHNS(self: *const T, pResult: *IMFAsyncResult, phnsTime: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimecodeTranslate.VTable, self.vtable).EndConvertTimecodeToHNS(@ptrCast(*const IMFTimecodeTranslate, self), pResult, phnsTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimecodeTranslate_BeginConvertHNSToTimecode(self: *const T, hnsTime: i64, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimecodeTranslate.VTable, self.vtable).BeginConvertHNSToTimecode(@ptrCast(*const IMFTimecodeTranslate, self), hnsTime, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimecodeTranslate_EndConvertHNSToTimecode(self: *const T, pResult: *IMFAsyncResult, pPropVarTimecode: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimecodeTranslate.VTable, self.vtable).EndConvertHNSToTimecode(@ptrCast(*const IMFTimecodeTranslate, self), pResult, pPropVarTimecode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSeekInfo_Value = @import("../zig.zig").Guid.initString("26AFEA53-D9ED-42B5-AB80-E64F9EE34779");
pub const IID_IMFSeekInfo = &IID_IMFSeekInfo_Value;
pub const IMFSeekInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNearestKeyFrames: fn(
            self: *const IMFSeekInfo,
            pguidTimeFormat: *const Guid,
            pvarStartPosition: *const PROPVARIANT,
            pvarPreviousKeyFrame: *PROPVARIANT,
            pvarNextKeyFrame: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSeekInfo_GetNearestKeyFrames(self: *const T, pguidTimeFormat: *const Guid, pvarStartPosition: *const PROPVARIANT, pvarPreviousKeyFrame: *PROPVARIANT, pvarNextKeyFrame: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSeekInfo.VTable, self.vtable).GetNearestKeyFrames(@ptrCast(*const IMFSeekInfo, self), pguidTimeFormat, pvarStartPosition, pvarPreviousKeyFrame, pvarNextKeyFrame);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSimpleAudioVolume_Value = @import("../zig.zig").Guid.initString("089EDF13-CF71-4338-8D13-9E569DBDC319");
pub const IID_IMFSimpleAudioVolume = &IID_IMFSimpleAudioVolume_Value;
pub const IMFSimpleAudioVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetMasterVolume: fn(
            self: *const IMFSimpleAudioVolume,
            fLevel: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMasterVolume: fn(
            self: *const IMFSimpleAudioVolume,
            pfLevel: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMute: fn(
            self: *const IMFSimpleAudioVolume,
            bMute: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: fn(
            self: *const IMFSimpleAudioVolume,
            pbMute: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSimpleAudioVolume_SetMasterVolume(self: *const T, fLevel: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSimpleAudioVolume.VTable, self.vtable).SetMasterVolume(@ptrCast(*const IMFSimpleAudioVolume, self), fLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSimpleAudioVolume_GetMasterVolume(self: *const T, pfLevel: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSimpleAudioVolume.VTable, self.vtable).GetMasterVolume(@ptrCast(*const IMFSimpleAudioVolume, self), pfLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSimpleAudioVolume_SetMute(self: *const T, bMute: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSimpleAudioVolume.VTable, self.vtable).SetMute(@ptrCast(*const IMFSimpleAudioVolume, self), bMute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSimpleAudioVolume_GetMute(self: *const T, pbMute: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSimpleAudioVolume.VTable, self.vtable).GetMute(@ptrCast(*const IMFSimpleAudioVolume, self), pbMute);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFAudioStreamVolume_Value = @import("../zig.zig").Guid.initString("76B1BBDB-4EC8-4F36-B106-70A9316DF593");
pub const IID_IMFAudioStreamVolume = &IID_IMFAudioStreamVolume_Value;
pub const IMFAudioStreamVolume = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetChannelCount: fn(
            self: *const IMFAudioStreamVolume,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChannelVolume: fn(
            self: *const IMFAudioStreamVolume,
            dwIndex: u32,
            fLevel: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelVolume: fn(
            self: *const IMFAudioStreamVolume,
            dwIndex: u32,
            pfLevel: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllVolumes: fn(
            self: *const IMFAudioStreamVolume,
            dwCount: u32,
            pfVolumes: [*]const f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllVolumes: fn(
            self: *const IMFAudioStreamVolume,
            dwCount: u32,
            pfVolumes: [*]f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioStreamVolume_GetChannelCount(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioStreamVolume.VTable, self.vtable).GetChannelCount(@ptrCast(*const IMFAudioStreamVolume, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioStreamVolume_SetChannelVolume(self: *const T, dwIndex: u32, fLevel: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioStreamVolume.VTable, self.vtable).SetChannelVolume(@ptrCast(*const IMFAudioStreamVolume, self), dwIndex, fLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioStreamVolume_GetChannelVolume(self: *const T, dwIndex: u32, pfLevel: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioStreamVolume.VTable, self.vtable).GetChannelVolume(@ptrCast(*const IMFAudioStreamVolume, self), dwIndex, pfLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioStreamVolume_SetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]const f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioStreamVolume.VTable, self.vtable).SetAllVolumes(@ptrCast(*const IMFAudioStreamVolume, self), dwCount, pfVolumes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioStreamVolume_GetAllVolumes(self: *const T, dwCount: u32, pfVolumes: [*]f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioStreamVolume.VTable, self.vtable).GetAllVolumes(@ptrCast(*const IMFAudioStreamVolume, self), dwCount, pfVolumes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFAudioPolicy_Value = @import("../zig.zig").Guid.initString("A0638C2B-6465-4395-9AE7-A321A9FD2856");
pub const IID_IMFAudioPolicy = &IID_IMFAudioPolicy_Value;
pub const IMFAudioPolicy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGroupingParam: fn(
            self: *const IMFAudioPolicy,
            rguidClass: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroupingParam: fn(
            self: *const IMFAudioPolicy,
            pguidClass: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplayName: fn(
            self: *const IMFAudioPolicy,
            pszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const IMFAudioPolicy,
            pszName: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconPath: fn(
            self: *const IMFAudioPolicy,
            pszPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconPath: fn(
            self: *const IMFAudioPolicy,
            pszPath: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioPolicy_SetGroupingParam(self: *const T, rguidClass: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioPolicy.VTable, self.vtable).SetGroupingParam(@ptrCast(*const IMFAudioPolicy, self), rguidClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioPolicy_GetGroupingParam(self: *const T, pguidClass: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioPolicy.VTable, self.vtable).GetGroupingParam(@ptrCast(*const IMFAudioPolicy, self), pguidClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioPolicy_SetDisplayName(self: *const T, pszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioPolicy.VTable, self.vtable).SetDisplayName(@ptrCast(*const IMFAudioPolicy, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioPolicy_GetDisplayName(self: *const T, pszName: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioPolicy.VTable, self.vtable).GetDisplayName(@ptrCast(*const IMFAudioPolicy, self), pszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioPolicy_SetIconPath(self: *const T, pszPath: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioPolicy.VTable, self.vtable).SetIconPath(@ptrCast(*const IMFAudioPolicy, self), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFAudioPolicy_GetIconPath(self: *const T, pszPath: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFAudioPolicy.VTable, self.vtable).GetIconPath(@ptrCast(*const IMFAudioPolicy, self), pszPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSampleGrabberSinkCallback_Value = @import("../zig.zig").Guid.initString("8C7B80BF-EE42-4B59-B1DF-55668E1BDCA8");
pub const IID_IMFSampleGrabberSinkCallback = &IID_IMFSampleGrabberSinkCallback_Value;
pub const IMFSampleGrabberSinkCallback = extern struct {
    pub const VTable = extern struct {
        base: IMFClockStateSink.VTable,
        OnSetPresentationClock: fn(
            self: *const IMFSampleGrabberSinkCallback,
            pPresentationClock: *IMFPresentationClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnProcessSample: fn(
            self: *const IMFSampleGrabberSinkCallback,
            guidMajorMediaType: *const Guid,
            dwSampleFlags: u32,
            llSampleTime: i64,
            llSampleDuration: i64,
            pSampleBuffer: [*:0]const u8,
            dwSampleSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnShutdown: fn(
            self: *const IMFSampleGrabberSinkCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFClockStateSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleGrabberSinkCallback_OnSetPresentationClock(self: *const T, pPresentationClock: *IMFPresentationClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleGrabberSinkCallback.VTable, self.vtable).OnSetPresentationClock(@ptrCast(*const IMFSampleGrabberSinkCallback, self), pPresentationClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleGrabberSinkCallback_OnProcessSample(self: *const T, guidMajorMediaType: *const Guid, dwSampleFlags: u32, llSampleTime: i64, llSampleDuration: i64, pSampleBuffer: [*:0]const u8, dwSampleSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleGrabberSinkCallback.VTable, self.vtable).OnProcessSample(@ptrCast(*const IMFSampleGrabberSinkCallback, self), guidMajorMediaType, dwSampleFlags, llSampleTime, llSampleDuration, pSampleBuffer, dwSampleSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleGrabberSinkCallback_OnShutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleGrabberSinkCallback.VTable, self.vtable).OnShutdown(@ptrCast(*const IMFSampleGrabberSinkCallback, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSampleGrabberSinkCallback2_Value = @import("../zig.zig").Guid.initString("CA86AA50-C46E-429E-AB27-16D6AC6844CB");
pub const IID_IMFSampleGrabberSinkCallback2 = &IID_IMFSampleGrabberSinkCallback2_Value;
pub const IMFSampleGrabberSinkCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IMFSampleGrabberSinkCallback.VTable,
        OnProcessSampleEx: fn(
            self: *const IMFSampleGrabberSinkCallback2,
            guidMajorMediaType: *const Guid,
            dwSampleFlags: u32,
            llSampleTime: i64,
            llSampleDuration: i64,
            pSampleBuffer: [*:0]const u8,
            dwSampleSize: u32,
            pAttributes: *IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFSampleGrabberSinkCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleGrabberSinkCallback2_OnProcessSampleEx(self: *const T, guidMajorMediaType: *const Guid, dwSampleFlags: u32, llSampleTime: i64, llSampleDuration: i64, pSampleBuffer: [*:0]const u8, dwSampleSize: u32, pAttributes: *IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleGrabberSinkCallback2.VTable, self.vtable).OnProcessSampleEx(@ptrCast(*const IMFSampleGrabberSinkCallback2, self), guidMajorMediaType, dwSampleFlags, llSampleTime, llSampleDuration, pSampleBuffer, dwSampleSize, pAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFWorkQueueServices_Value = @import("../zig.zig").Guid.initString("35FE1BB8-A3A9-40FE-BBEC-EB569C9CCCA3");
pub const IID_IMFWorkQueueServices = &IID_IMFWorkQueueServices_Value;
pub const IMFWorkQueueServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginRegisterTopologyWorkQueuesWithMMCSS: fn(
            self: *const IMFWorkQueueServices,
            pCallback: *IMFAsyncCallback,
            pState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndRegisterTopologyWorkQueuesWithMMCSS: fn(
            self: *const IMFWorkQueueServices,
            pResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUnregisterTopologyWorkQueuesWithMMCSS: fn(
            self: *const IMFWorkQueueServices,
            pCallback: *IMFAsyncCallback,
            pState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUnregisterTopologyWorkQueuesWithMMCSS: fn(
            self: *const IMFWorkQueueServices,
            pResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTopologyWorkQueueMMCSSClass: fn(
            self: *const IMFWorkQueueServices,
            dwTopologyWorkQueueId: u32,
            pwszClass: [*:0]u16,
            pcchClass: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTopologyWorkQueueMMCSSTaskId: fn(
            self: *const IMFWorkQueueServices,
            dwTopologyWorkQueueId: u32,
            pdwTaskId: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginRegisterPlatformWorkQueueWithMMCSS: fn(
            self: *const IMFWorkQueueServices,
            dwPlatformWorkQueue: u32,
            wszClass: [*:0]const u16,
            dwTaskId: u32,
            pCallback: *IMFAsyncCallback,
            pState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndRegisterPlatformWorkQueueWithMMCSS: fn(
            self: *const IMFWorkQueueServices,
            pResult: *IMFAsyncResult,
            pdwTaskId: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUnregisterPlatformWorkQueueWithMMCSS: fn(
            self: *const IMFWorkQueueServices,
            dwPlatformWorkQueue: u32,
            pCallback: *IMFAsyncCallback,
            pState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUnregisterPlatformWorkQueueWithMMCSS: fn(
            self: *const IMFWorkQueueServices,
            pResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPlaftormWorkQueueMMCSSClass: fn(
            self: *const IMFWorkQueueServices,
            dwPlatformWorkQueueId: u32,
            pwszClass: [*:0]u16,
            pcchClass: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPlatformWorkQueueMMCSSTaskId: fn(
            self: *const IMFWorkQueueServices,
            dwPlatformWorkQueueId: u32,
            pdwTaskId: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_BeginRegisterTopologyWorkQueuesWithMMCSS(self: *const T, pCallback: *IMFAsyncCallback, pState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).BeginRegisterTopologyWorkQueuesWithMMCSS(@ptrCast(*const IMFWorkQueueServices, self), pCallback, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_EndRegisterTopologyWorkQueuesWithMMCSS(self: *const T, pResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).EndRegisterTopologyWorkQueuesWithMMCSS(@ptrCast(*const IMFWorkQueueServices, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_BeginUnregisterTopologyWorkQueuesWithMMCSS(self: *const T, pCallback: *IMFAsyncCallback, pState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).BeginUnregisterTopologyWorkQueuesWithMMCSS(@ptrCast(*const IMFWorkQueueServices, self), pCallback, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_EndUnregisterTopologyWorkQueuesWithMMCSS(self: *const T, pResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).EndUnregisterTopologyWorkQueuesWithMMCSS(@ptrCast(*const IMFWorkQueueServices, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_GetTopologyWorkQueueMMCSSClass(self: *const T, dwTopologyWorkQueueId: u32, pwszClass: [*:0]u16, pcchClass: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).GetTopologyWorkQueueMMCSSClass(@ptrCast(*const IMFWorkQueueServices, self), dwTopologyWorkQueueId, pwszClass, pcchClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_GetTopologyWorkQueueMMCSSTaskId(self: *const T, dwTopologyWorkQueueId: u32, pdwTaskId: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).GetTopologyWorkQueueMMCSSTaskId(@ptrCast(*const IMFWorkQueueServices, self), dwTopologyWorkQueueId, pdwTaskId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_BeginRegisterPlatformWorkQueueWithMMCSS(self: *const T, dwPlatformWorkQueue: u32, wszClass: [*:0]const u16, dwTaskId: u32, pCallback: *IMFAsyncCallback, pState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).BeginRegisterPlatformWorkQueueWithMMCSS(@ptrCast(*const IMFWorkQueueServices, self), dwPlatformWorkQueue, wszClass, dwTaskId, pCallback, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_EndRegisterPlatformWorkQueueWithMMCSS(self: *const T, pResult: *IMFAsyncResult, pdwTaskId: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).EndRegisterPlatformWorkQueueWithMMCSS(@ptrCast(*const IMFWorkQueueServices, self), pResult, pdwTaskId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_BeginUnregisterPlatformWorkQueueWithMMCSS(self: *const T, dwPlatformWorkQueue: u32, pCallback: *IMFAsyncCallback, pState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).BeginUnregisterPlatformWorkQueueWithMMCSS(@ptrCast(*const IMFWorkQueueServices, self), dwPlatformWorkQueue, pCallback, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_EndUnregisterPlatformWorkQueueWithMMCSS(self: *const T, pResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).EndUnregisterPlatformWorkQueueWithMMCSS(@ptrCast(*const IMFWorkQueueServices, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_GetPlaftormWorkQueueMMCSSClass(self: *const T, dwPlatformWorkQueueId: u32, pwszClass: [*:0]u16, pcchClass: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).GetPlaftormWorkQueueMMCSSClass(@ptrCast(*const IMFWorkQueueServices, self), dwPlatformWorkQueueId, pwszClass, pcchClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServices_GetPlatformWorkQueueMMCSSTaskId(self: *const T, dwPlatformWorkQueueId: u32, pdwTaskId: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServices.VTable, self.vtable).GetPlatformWorkQueueMMCSSTaskId(@ptrCast(*const IMFWorkQueueServices, self), dwPlatformWorkQueueId, pdwTaskId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFWorkQueueServicesEx_Value = @import("../zig.zig").Guid.initString("96BF961B-40FE-42F1-BA9D-320238B49700");
pub const IID_IMFWorkQueueServicesEx = &IID_IMFWorkQueueServicesEx_Value;
pub const IMFWorkQueueServicesEx = extern struct {
    pub const VTable = extern struct {
        base: IMFWorkQueueServices.VTable,
        GetTopologyWorkQueueMMCSSPriority: fn(
            self: *const IMFWorkQueueServicesEx,
            dwTopologyWorkQueueId: u32,
            plPriority: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginRegisterPlatformWorkQueueWithMMCSSEx: fn(
            self: *const IMFWorkQueueServicesEx,
            dwPlatformWorkQueue: u32,
            wszClass: [*:0]const u16,
            dwTaskId: u32,
            lPriority: i32,
            pCallback: *IMFAsyncCallback,
            pState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPlatformWorkQueueMMCSSPriority: fn(
            self: *const IMFWorkQueueServicesEx,
            dwPlatformWorkQueueId: u32,
            plPriority: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFWorkQueueServices.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServicesEx_GetTopologyWorkQueueMMCSSPriority(self: *const T, dwTopologyWorkQueueId: u32, plPriority: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServicesEx.VTable, self.vtable).GetTopologyWorkQueueMMCSSPriority(@ptrCast(*const IMFWorkQueueServicesEx, self), dwTopologyWorkQueueId, plPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServicesEx_BeginRegisterPlatformWorkQueueWithMMCSSEx(self: *const T, dwPlatformWorkQueue: u32, wszClass: [*:0]const u16, dwTaskId: u32, lPriority: i32, pCallback: *IMFAsyncCallback, pState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServicesEx.VTable, self.vtable).BeginRegisterPlatformWorkQueueWithMMCSSEx(@ptrCast(*const IMFWorkQueueServicesEx, self), dwPlatformWorkQueue, wszClass, dwTaskId, lPriority, pCallback, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFWorkQueueServicesEx_GetPlatformWorkQueueMMCSSPriority(self: *const T, dwPlatformWorkQueueId: u32, plPriority: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFWorkQueueServicesEx.VTable, self.vtable).GetPlatformWorkQueueMMCSSPriority(@ptrCast(*const IMFWorkQueueServicesEx, self), dwPlatformWorkQueueId, plPriority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_QUALITY_DROP_MODE = extern enum(i32) {
    MF_DROP_MODE_NONE = 0,
    MF_DROP_MODE_1 = 1,
    MF_DROP_MODE_2 = 2,
    MF_DROP_MODE_3 = 3,
    MF_DROP_MODE_4 = 4,
    MF_DROP_MODE_5 = 5,
    MF_NUM_DROP_MODES = 6,
};
pub const MF_DROP_MODE_NONE = MF_QUALITY_DROP_MODE.MF_DROP_MODE_NONE;
pub const MF_DROP_MODE_1 = MF_QUALITY_DROP_MODE.MF_DROP_MODE_1;
pub const MF_DROP_MODE_2 = MF_QUALITY_DROP_MODE.MF_DROP_MODE_2;
pub const MF_DROP_MODE_3 = MF_QUALITY_DROP_MODE.MF_DROP_MODE_3;
pub const MF_DROP_MODE_4 = MF_QUALITY_DROP_MODE.MF_DROP_MODE_4;
pub const MF_DROP_MODE_5 = MF_QUALITY_DROP_MODE.MF_DROP_MODE_5;
pub const MF_NUM_DROP_MODES = MF_QUALITY_DROP_MODE.MF_NUM_DROP_MODES;

pub const MF_QUALITY_LEVEL = extern enum(i32) {
    MF_QUALITY_NORMAL = 0,
    MF_QUALITY_NORMAL_MINUS_1 = 1,
    MF_QUALITY_NORMAL_MINUS_2 = 2,
    MF_QUALITY_NORMAL_MINUS_3 = 3,
    MF_QUALITY_NORMAL_MINUS_4 = 4,
    MF_QUALITY_NORMAL_MINUS_5 = 5,
    MF_NUM_QUALITY_LEVELS = 6,
};
pub const MF_QUALITY_NORMAL = MF_QUALITY_LEVEL.MF_QUALITY_NORMAL;
pub const MF_QUALITY_NORMAL_MINUS_1 = MF_QUALITY_LEVEL.MF_QUALITY_NORMAL_MINUS_1;
pub const MF_QUALITY_NORMAL_MINUS_2 = MF_QUALITY_LEVEL.MF_QUALITY_NORMAL_MINUS_2;
pub const MF_QUALITY_NORMAL_MINUS_3 = MF_QUALITY_LEVEL.MF_QUALITY_NORMAL_MINUS_3;
pub const MF_QUALITY_NORMAL_MINUS_4 = MF_QUALITY_LEVEL.MF_QUALITY_NORMAL_MINUS_4;
pub const MF_QUALITY_NORMAL_MINUS_5 = MF_QUALITY_LEVEL.MF_QUALITY_NORMAL_MINUS_5;
pub const MF_NUM_QUALITY_LEVELS = MF_QUALITY_LEVEL.MF_NUM_QUALITY_LEVELS;

pub const MF_QUALITY_ADVISE_FLAGS = extern enum(i32) {
    MF_QUALITY_CANNOT_KEEP_UP = 1,
};
pub const MF_QUALITY_CANNOT_KEEP_UP = MF_QUALITY_ADVISE_FLAGS.MF_QUALITY_CANNOT_KEEP_UP;

const IID_IMFQualityManager_Value = @import("../zig.zig").Guid.initString("8D009D86-5B9F-4115-B1FC-9F80D52AB8AB");
pub const IID_IMFQualityManager = &IID_IMFQualityManager_Value;
pub const IMFQualityManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyTopology: fn(
            self: *const IMFQualityManager,
            pTopology: *IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyPresentationClock: fn(
            self: *const IMFQualityManager,
            pClock: *IMFPresentationClock,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyProcessInput: fn(
            self: *const IMFQualityManager,
            pNode: *IMFTopologyNode,
            lInputIndex: i32,
            pSample: *IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyProcessOutput: fn(
            self: *const IMFQualityManager,
            pNode: *IMFTopologyNode,
            lOutputIndex: i32,
            pSample: *IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyQualityEvent: fn(
            self: *const IMFQualityManager,
            pObject: *IUnknown,
            pEvent: *IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFQualityManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityManager_NotifyTopology(self: *const T, pTopology: *IMFTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityManager.VTable, self.vtable).NotifyTopology(@ptrCast(*const IMFQualityManager, self), pTopology);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityManager_NotifyPresentationClock(self: *const T, pClock: *IMFPresentationClock) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityManager.VTable, self.vtable).NotifyPresentationClock(@ptrCast(*const IMFQualityManager, self), pClock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityManager_NotifyProcessInput(self: *const T, pNode: *IMFTopologyNode, lInputIndex: i32, pSample: *IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityManager.VTable, self.vtable).NotifyProcessInput(@ptrCast(*const IMFQualityManager, self), pNode, lInputIndex, pSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityManager_NotifyProcessOutput(self: *const T, pNode: *IMFTopologyNode, lOutputIndex: i32, pSample: *IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityManager.VTable, self.vtable).NotifyProcessOutput(@ptrCast(*const IMFQualityManager, self), pNode, lOutputIndex, pSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityManager_NotifyQualityEvent(self: *const T, pObject: *IUnknown, pEvent: *IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityManager.VTable, self.vtable).NotifyQualityEvent(@ptrCast(*const IMFQualityManager, self), pObject, pEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityManager_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityManager.VTable, self.vtable).Shutdown(@ptrCast(*const IMFQualityManager, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFQualityAdvise_Value = @import("../zig.zig").Guid.initString("EC15E2E9-E36B-4F7C-8758-77D452EF4CE7");
pub const IID_IMFQualityAdvise = &IID_IMFQualityAdvise_Value;
pub const IMFQualityAdvise = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDropMode: fn(
            self: *const IMFQualityAdvise,
            eDropMode: MF_QUALITY_DROP_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQualityLevel: fn(
            self: *const IMFQualityAdvise,
            eQualityLevel: MF_QUALITY_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropMode: fn(
            self: *const IMFQualityAdvise,
            peDropMode: *MF_QUALITY_DROP_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQualityLevel: fn(
            self: *const IMFQualityAdvise,
            peQualityLevel: *MF_QUALITY_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DropTime: fn(
            self: *const IMFQualityAdvise,
            hnsAmountToDrop: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityAdvise_SetDropMode(self: *const T, eDropMode: MF_QUALITY_DROP_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityAdvise.VTable, self.vtable).SetDropMode(@ptrCast(*const IMFQualityAdvise, self), eDropMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityAdvise_SetQualityLevel(self: *const T, eQualityLevel: MF_QUALITY_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityAdvise.VTable, self.vtable).SetQualityLevel(@ptrCast(*const IMFQualityAdvise, self), eQualityLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityAdvise_GetDropMode(self: *const T, peDropMode: *MF_QUALITY_DROP_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityAdvise.VTable, self.vtable).GetDropMode(@ptrCast(*const IMFQualityAdvise, self), peDropMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityAdvise_GetQualityLevel(self: *const T, peQualityLevel: *MF_QUALITY_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityAdvise.VTable, self.vtable).GetQualityLevel(@ptrCast(*const IMFQualityAdvise, self), peQualityLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityAdvise_DropTime(self: *const T, hnsAmountToDrop: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityAdvise.VTable, self.vtable).DropTime(@ptrCast(*const IMFQualityAdvise, self), hnsAmountToDrop);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFQualityAdvise2_Value = @import("../zig.zig").Guid.initString("F3706F0D-8EA2-4886-8000-7155E9EC2EAE");
pub const IID_IMFQualityAdvise2 = &IID_IMFQualityAdvise2_Value;
pub const IMFQualityAdvise2 = extern struct {
    pub const VTable = extern struct {
        base: IMFQualityAdvise.VTable,
        NotifyQualityEvent: fn(
            self: *const IMFQualityAdvise2,
            pEvent: *IMFMediaEvent,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFQualityAdvise.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityAdvise2_NotifyQualityEvent(self: *const T, pEvent: *IMFMediaEvent, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityAdvise2.VTable, self.vtable).NotifyQualityEvent(@ptrCast(*const IMFQualityAdvise2, self), pEvent, pdwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFQualityAdviseLimits_Value = @import("../zig.zig").Guid.initString("DFCD8E4D-30B5-4567-ACAA-8EB5B7853DC9");
pub const IID_IMFQualityAdviseLimits = &IID_IMFQualityAdviseLimits_Value;
pub const IMFQualityAdviseLimits = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMaximumDropMode: fn(
            self: *const IMFQualityAdviseLimits,
            peDropMode: *MF_QUALITY_DROP_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinimumQualityLevel: fn(
            self: *const IMFQualityAdviseLimits,
            peQualityLevel: *MF_QUALITY_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityAdviseLimits_GetMaximumDropMode(self: *const T, peDropMode: *MF_QUALITY_DROP_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityAdviseLimits.VTable, self.vtable).GetMaximumDropMode(@ptrCast(*const IMFQualityAdviseLimits, self), peDropMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFQualityAdviseLimits_GetMinimumQualityLevel(self: *const T, peQualityLevel: *MF_QUALITY_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFQualityAdviseLimits.VTable, self.vtable).GetMinimumQualityLevel(@ptrCast(*const IMFQualityAdviseLimits, self), peQualityLevel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFRealTimeClient_Value = @import("../zig.zig").Guid.initString("2347D60B-3FB5-480C-8803-8DF3ADCD3EF0");
pub const IID_IMFRealTimeClient = &IID_IMFRealTimeClient_Value;
pub const IMFRealTimeClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterThreads: fn(
            self: *const IMFRealTimeClient,
            dwTaskIndex: u32,
            wszClass: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterThreads: fn(
            self: *const IMFRealTimeClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWorkQueue: fn(
            self: *const IMFRealTimeClient,
            dwWorkQueueId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRealTimeClient_RegisterThreads(self: *const T, dwTaskIndex: u32, wszClass: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRealTimeClient.VTable, self.vtable).RegisterThreads(@ptrCast(*const IMFRealTimeClient, self), dwTaskIndex, wszClass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRealTimeClient_UnregisterThreads(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRealTimeClient.VTable, self.vtable).UnregisterThreads(@ptrCast(*const IMFRealTimeClient, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRealTimeClient_SetWorkQueue(self: *const T, dwWorkQueueId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRealTimeClient.VTable, self.vtable).SetWorkQueue(@ptrCast(*const IMFRealTimeClient, self), dwWorkQueueId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFRealTimeClientEx_Value = @import("../zig.zig").Guid.initString("03910848-AB16-4611-B100-17B88AE2F248");
pub const IID_IMFRealTimeClientEx = &IID_IMFRealTimeClientEx_Value;
pub const IMFRealTimeClientEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterThreadsEx: fn(
            self: *const IMFRealTimeClientEx,
            pdwTaskIndex: *u32,
            wszClassName: [*:0]const u16,
            lBasePriority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterThreads: fn(
            self: *const IMFRealTimeClientEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWorkQueueEx: fn(
            self: *const IMFRealTimeClientEx,
            dwMultithreadedWorkQueueId: u32,
            lWorkItemBasePriority: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRealTimeClientEx_RegisterThreadsEx(self: *const T, pdwTaskIndex: *u32, wszClassName: [*:0]const u16, lBasePriority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRealTimeClientEx.VTable, self.vtable).RegisterThreadsEx(@ptrCast(*const IMFRealTimeClientEx, self), pdwTaskIndex, wszClassName, lBasePriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRealTimeClientEx_UnregisterThreads(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRealTimeClientEx.VTable, self.vtable).UnregisterThreads(@ptrCast(*const IMFRealTimeClientEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRealTimeClientEx_SetWorkQueueEx(self: *const T, dwMultithreadedWorkQueueId: u32, lWorkItemBasePriority: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRealTimeClientEx.VTable, self.vtable).SetWorkQueueEx(@ptrCast(*const IMFRealTimeClientEx, self), dwMultithreadedWorkQueueId, lWorkItemBasePriority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFSequencerTopologyFlags = extern enum(i32) {
    SequencerTopologyFlags_Last = 1,
};
pub const SequencerTopologyFlags_Last = MFSequencerTopologyFlags.SequencerTopologyFlags_Last;

const IID_IMFSequencerSource_Value = @import("../zig.zig").Guid.initString("197CD219-19CB-4DE1-A64C-ACF2EDCBE59E");
pub const IID_IMFSequencerSource = &IID_IMFSequencerSource_Value;
pub const IMFSequencerSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AppendTopology: fn(
            self: *const IMFSequencerSource,
            pTopology: *IMFTopology,
            dwFlags: u32,
            pdwId: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTopology: fn(
            self: *const IMFSequencerSource,
            dwId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPresentationContext: fn(
            self: *const IMFSequencerSource,
            pPD: *IMFPresentationDescriptor,
            pId: ?*u32,
            ppTopology: ?*?*IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateTopology: fn(
            self: *const IMFSequencerSource,
            dwId: u32,
            pTopology: *IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateTopologyFlags: fn(
            self: *const IMFSequencerSource,
            dwId: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSequencerSource_AppendTopology(self: *const T, pTopology: *IMFTopology, dwFlags: u32, pdwId: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSequencerSource.VTable, self.vtable).AppendTopology(@ptrCast(*const IMFSequencerSource, self), pTopology, dwFlags, pdwId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSequencerSource_DeleteTopology(self: *const T, dwId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSequencerSource.VTable, self.vtable).DeleteTopology(@ptrCast(*const IMFSequencerSource, self), dwId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSequencerSource_GetPresentationContext(self: *const T, pPD: *IMFPresentationDescriptor, pId: ?*u32, ppTopology: ?*?*IMFTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSequencerSource.VTable, self.vtable).GetPresentationContext(@ptrCast(*const IMFSequencerSource, self), pPD, pId, ppTopology);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSequencerSource_UpdateTopology(self: *const T, dwId: u32, pTopology: *IMFTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSequencerSource.VTable, self.vtable).UpdateTopology(@ptrCast(*const IMFSequencerSource, self), dwId, pTopology);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSequencerSource_UpdateTopologyFlags(self: *const T, dwId: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSequencerSource.VTable, self.vtable).UpdateTopologyFlags(@ptrCast(*const IMFSequencerSource, self), dwId, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaSourceTopologyProvider_Value = @import("../zig.zig").Guid.initString("0E1D6009-C9F3-442D-8C51-A42D2D49452F");
pub const IID_IMFMediaSourceTopologyProvider = &IID_IMFMediaSourceTopologyProvider_Value;
pub const IMFMediaSourceTopologyProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMediaSourceTopology: fn(
            self: *const IMFMediaSourceTopologyProvider,
            pPresentationDescriptor: *IMFPresentationDescriptor,
            ppTopology: **IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceTopologyProvider_GetMediaSourceTopology(self: *const T, pPresentationDescriptor: *IMFPresentationDescriptor, ppTopology: **IMFTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceTopologyProvider.VTable, self.vtable).GetMediaSourceTopology(@ptrCast(*const IMFMediaSourceTopologyProvider, self), pPresentationDescriptor, ppTopology);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaSourcePresentationProvider_Value = @import("../zig.zig").Guid.initString("0E1D600A-C9F3-442D-8C51-A42D2D49452F");
pub const IID_IMFMediaSourcePresentationProvider = &IID_IMFMediaSourcePresentationProvider_Value;
pub const IMFMediaSourcePresentationProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ForceEndOfPresentation: fn(
            self: *const IMFMediaSourcePresentationProvider,
            pPresentationDescriptor: *IMFPresentationDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourcePresentationProvider_ForceEndOfPresentation(self: *const T, pPresentationDescriptor: *IMFPresentationDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourcePresentationProvider.VTable, self.vtable).ForceEndOfPresentation(@ptrCast(*const IMFMediaSourcePresentationProvider, self), pPresentationDescriptor);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFTOPONODE_ATTRIBUTE_UPDATE = extern struct {
    NodeId: u64,
    guidAttributeKey: Guid,
    attrType: MF_ATTRIBUTE_TYPE,
    Anonymous: MFTOPONODE_ATTRIBUTE_UPDATE._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

const IID_IMFTopologyNodeAttributeEditor_Value = @import("../zig.zig").Guid.initString("676AA6DD-238A-410D-BB99-65668D01605A");
pub const IID_IMFTopologyNodeAttributeEditor = &IID_IMFTopologyNodeAttributeEditor_Value;
pub const IMFTopologyNodeAttributeEditor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateNodeAttributes: fn(
            self: *const IMFTopologyNodeAttributeEditor,
            TopoId: u64,
            cUpdates: u32,
            pUpdates: [*]MFTOPONODE_ATTRIBUTE_UPDATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyNodeAttributeEditor_UpdateNodeAttributes(self: *const T, TopoId: u64, cUpdates: u32, pUpdates: [*]MFTOPONODE_ATTRIBUTE_UPDATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyNodeAttributeEditor.VTable, self.vtable).UpdateNodeAttributes(@ptrCast(*const IMFTopologyNodeAttributeEditor, self), TopoId, cUpdates, pUpdates);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_LEAKY_BUCKET_PAIR = extern struct {
    dwBitrate: u32,
    msBufferWindow: u32,
};

pub const MFBYTESTREAM_BUFFERING_PARAMS = extern struct {
    cbTotalFileSize: u64,
    cbPlayableDataSize: u64,
    prgBuckets: *MF_LEAKY_BUCKET_PAIR,
    cBuckets: u32,
    qwNetBufferingTime: u64,
    qwExtraBufferingTimeDuringSeek: u64,
    qwPlayDuration: u64,
    dRate: f32,
};

const IID_IMFByteStreamBuffering_Value = @import("../zig.zig").Guid.initString("6D66D782-1D4F-4DB7-8C63-CB8C77F1EF5E");
pub const IID_IMFByteStreamBuffering = &IID_IMFByteStreamBuffering_Value;
pub const IMFByteStreamBuffering = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetBufferingParams: fn(
            self: *const IMFByteStreamBuffering,
            pParams: *MFBYTESTREAM_BUFFERING_PARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableBuffering: fn(
            self: *const IMFByteStreamBuffering,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopBuffering: fn(
            self: *const IMFByteStreamBuffering,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamBuffering_SetBufferingParams(self: *const T, pParams: *MFBYTESTREAM_BUFFERING_PARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamBuffering.VTable, self.vtable).SetBufferingParams(@ptrCast(*const IMFByteStreamBuffering, self), pParams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamBuffering_EnableBuffering(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamBuffering.VTable, self.vtable).EnableBuffering(@ptrCast(*const IMFByteStreamBuffering, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamBuffering_StopBuffering(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamBuffering.VTable, self.vtable).StopBuffering(@ptrCast(*const IMFByteStreamBuffering, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFByteStreamCacheControl_Value = @import("../zig.zig").Guid.initString("F5042EA4-7A96-4A75-AA7B-2BE1EF7F88D5");
pub const IID_IMFByteStreamCacheControl = &IID_IMFByteStreamCacheControl_Value;
pub const IMFByteStreamCacheControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StopBackgroundTransfer: fn(
            self: *const IMFByteStreamCacheControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamCacheControl_StopBackgroundTransfer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamCacheControl.VTable, self.vtable).StopBackgroundTransfer(@ptrCast(*const IMFByteStreamCacheControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFByteStreamTimeSeek_Value = @import("../zig.zig").Guid.initString("64976BFA-FB61-4041-9069-8C9A5F659BEB");
pub const IID_IMFByteStreamTimeSeek = &IID_IMFByteStreamTimeSeek_Value;
pub const IMFByteStreamTimeSeek = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsTimeSeekSupported: fn(
            self: *const IMFByteStreamTimeSeek,
            pfTimeSeekIsSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TimeSeek: fn(
            self: *const IMFByteStreamTimeSeek,
            qwTimePosition: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeSeekResult: fn(
            self: *const IMFByteStreamTimeSeek,
            pqwStartTime: *u64,
            pqwStopTime: *u64,
            pqwDuration: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamTimeSeek_IsTimeSeekSupported(self: *const T, pfTimeSeekIsSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamTimeSeek.VTable, self.vtable).IsTimeSeekSupported(@ptrCast(*const IMFByteStreamTimeSeek, self), pfTimeSeekIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamTimeSeek_TimeSeek(self: *const T, qwTimePosition: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamTimeSeek.VTable, self.vtable).TimeSeek(@ptrCast(*const IMFByteStreamTimeSeek, self), qwTimePosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamTimeSeek_GetTimeSeekResult(self: *const T, pqwStartTime: *u64, pqwStopTime: *u64, pqwDuration: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamTimeSeek.VTable, self.vtable).GetTimeSeekResult(@ptrCast(*const IMFByteStreamTimeSeek, self), pqwStartTime, pqwStopTime, pqwDuration);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_BYTE_STREAM_CACHE_RANGE = extern struct {
    qwStartOffset: u64,
    qwEndOffset: u64,
};

const IID_IMFByteStreamCacheControl2_Value = @import("../zig.zig").Guid.initString("71CE469C-F34B-49EA-A56B-2D2A10E51149");
pub const IID_IMFByteStreamCacheControl2 = &IID_IMFByteStreamCacheControl2_Value;
pub const IMFByteStreamCacheControl2 = extern struct {
    pub const VTable = extern struct {
        base: IMFByteStreamCacheControl.VTable,
        GetByteRanges: fn(
            self: *const IMFByteStreamCacheControl2,
            pcRanges: *u32,
            ppRanges: [*]*MF_BYTE_STREAM_CACHE_RANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCacheLimit: fn(
            self: *const IMFByteStreamCacheControl2,
            qwBytes: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsBackgroundTransferActive: fn(
            self: *const IMFByteStreamCacheControl2,
            pfActive: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFByteStreamCacheControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamCacheControl2_GetByteRanges(self: *const T, pcRanges: *u32, ppRanges: [*]*MF_BYTE_STREAM_CACHE_RANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamCacheControl2.VTable, self.vtable).GetByteRanges(@ptrCast(*const IMFByteStreamCacheControl2, self), pcRanges, ppRanges);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamCacheControl2_SetCacheLimit(self: *const T, qwBytes: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamCacheControl2.VTable, self.vtable).SetCacheLimit(@ptrCast(*const IMFByteStreamCacheControl2, self), qwBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamCacheControl2_IsBackgroundTransferActive(self: *const T, pfActive: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamCacheControl2.VTable, self.vtable).IsBackgroundTransferActive(@ptrCast(*const IMFByteStreamCacheControl2, self), pfActive);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFNetCredential_Value = @import("../zig.zig").Guid.initString("5B87EF6A-7ED8-434F-BA0E-184FAC1628D1");
pub const IID_IMFNetCredential = &IID_IMFNetCredential_Value;
pub const IMFNetCredential = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetUser: fn(
            self: *const IMFNetCredential,
            pbData: [*:0]u8,
            cbData: u32,
            fDataIsEncrypted: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPassword: fn(
            self: *const IMFNetCredential,
            pbData: [*:0]u8,
            cbData: u32,
            fDataIsEncrypted: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUser: fn(
            self: *const IMFNetCredential,
            pbData: ?[*:0]u8,
            pcbData: *u32,
            fEncryptData: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassword: fn(
            self: *const IMFNetCredential,
            pbData: ?[*:0]u8,
            pcbData: *u32,
            fEncryptData: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoggedOnUser: fn(
            self: *const IMFNetCredential,
            pfLoggedOnUser: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredential_SetUser(self: *const T, pbData: [*:0]u8, cbData: u32, fDataIsEncrypted: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredential.VTable, self.vtable).SetUser(@ptrCast(*const IMFNetCredential, self), pbData, cbData, fDataIsEncrypted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredential_SetPassword(self: *const T, pbData: [*:0]u8, cbData: u32, fDataIsEncrypted: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredential.VTable, self.vtable).SetPassword(@ptrCast(*const IMFNetCredential, self), pbData, cbData, fDataIsEncrypted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredential_GetUser(self: *const T, pbData: ?[*:0]u8, pcbData: *u32, fEncryptData: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredential.VTable, self.vtable).GetUser(@ptrCast(*const IMFNetCredential, self), pbData, pcbData, fEncryptData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredential_GetPassword(self: *const T, pbData: ?[*:0]u8, pcbData: *u32, fEncryptData: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredential.VTable, self.vtable).GetPassword(@ptrCast(*const IMFNetCredential, self), pbData, pcbData, fEncryptData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredential_LoggedOnUser(self: *const T, pfLoggedOnUser: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredential.VTable, self.vtable).LoggedOnUser(@ptrCast(*const IMFNetCredential, self), pfLoggedOnUser);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFNetCredentialManagerGetParam = extern struct {
    hrOp: HRESULT,
    fAllowLoggedOnUser: BOOL,
    fClearTextPackage: BOOL,
    pszUrl: [*:0]const u16,
    pszSite: [*:0]const u16,
    pszRealm: [*:0]const u16,
    pszPackage: [*:0]const u16,
    nRetries: i32,
};

const IID_IMFNetCredentialManager_Value = @import("../zig.zig").Guid.initString("5B87EF6B-7ED8-434F-BA0E-184FAC1628D1");
pub const IID_IMFNetCredentialManager = &IID_IMFNetCredentialManager_Value;
pub const IMFNetCredentialManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginGetCredentials: fn(
            self: *const IMFNetCredentialManager,
            pParam: *MFNetCredentialManagerGetParam,
            pCallback: *IMFAsyncCallback,
            pState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndGetCredentials: fn(
            self: *const IMFNetCredentialManager,
            pResult: *IMFAsyncResult,
            ppCred: **IMFNetCredential,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGood: fn(
            self: *const IMFNetCredentialManager,
            pCred: *IMFNetCredential,
            fGood: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredentialManager_BeginGetCredentials(self: *const T, pParam: *MFNetCredentialManagerGetParam, pCallback: *IMFAsyncCallback, pState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredentialManager.VTable, self.vtable).BeginGetCredentials(@ptrCast(*const IMFNetCredentialManager, self), pParam, pCallback, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredentialManager_EndGetCredentials(self: *const T, pResult: *IMFAsyncResult, ppCred: **IMFNetCredential) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredentialManager.VTable, self.vtable).EndGetCredentials(@ptrCast(*const IMFNetCredentialManager, self), pResult, ppCred);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredentialManager_SetGood(self: *const T, pCred: *IMFNetCredential, fGood: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredentialManager.VTable, self.vtable).SetGood(@ptrCast(*const IMFNetCredentialManager, self), pCred, fGood);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFNetCredentialRequirements = extern enum(i32) {
    REQUIRE_PROMPT = 1,
    REQUIRE_SAVE_SELECTED = 2,
};
pub const REQUIRE_PROMPT = MFNetCredentialRequirements.REQUIRE_PROMPT;
pub const REQUIRE_SAVE_SELECTED = MFNetCredentialRequirements.REQUIRE_SAVE_SELECTED;

pub const MFNetCredentialOptions = extern enum(i32) {
    MFNET_CREDENTIAL_SAVE = 1,
    MFNET_CREDENTIAL_DONT_CACHE = 2,
    MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT = 4,
};
pub const MFNET_CREDENTIAL_SAVE = MFNetCredentialOptions.MFNET_CREDENTIAL_SAVE;
pub const MFNET_CREDENTIAL_DONT_CACHE = MFNetCredentialOptions.MFNET_CREDENTIAL_DONT_CACHE;
pub const MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT = MFNetCredentialOptions.MFNET_CREDENTIAL_ALLOW_CLEAR_TEXT;

pub const MFNetAuthenticationFlags = extern enum(i32) {
    MFNET_AUTHENTICATION_PROXY = 1,
    MFNET_AUTHENTICATION_CLEAR_TEXT = 2,
    MFNET_AUTHENTICATION_LOGGED_ON_USER = 4,
};
pub const MFNET_AUTHENTICATION_PROXY = MFNetAuthenticationFlags.MFNET_AUTHENTICATION_PROXY;
pub const MFNET_AUTHENTICATION_CLEAR_TEXT = MFNetAuthenticationFlags.MFNET_AUTHENTICATION_CLEAR_TEXT;
pub const MFNET_AUTHENTICATION_LOGGED_ON_USER = MFNetAuthenticationFlags.MFNET_AUTHENTICATION_LOGGED_ON_USER;

const IID_IMFNetCredentialCache_Value = @import("../zig.zig").Guid.initString("5B87EF6C-7ED8-434F-BA0E-184FAC1628D1");
pub const IID_IMFNetCredentialCache = &IID_IMFNetCredentialCache_Value;
pub const IMFNetCredentialCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCredential: fn(
            self: *const IMFNetCredentialCache,
            pszUrl: [*:0]const u16,
            pszRealm: [*:0]const u16,
            dwAuthenticationFlags: u32,
            ppCred: **IMFNetCredential,
            pdwRequirementsFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGood: fn(
            self: *const IMFNetCredentialCache,
            pCred: *IMFNetCredential,
            fGood: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUserOptions: fn(
            self: *const IMFNetCredentialCache,
            pCred: *IMFNetCredential,
            dwOptionsFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredentialCache_GetCredential(self: *const T, pszUrl: [*:0]const u16, pszRealm: [*:0]const u16, dwAuthenticationFlags: u32, ppCred: **IMFNetCredential, pdwRequirementsFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredentialCache.VTable, self.vtable).GetCredential(@ptrCast(*const IMFNetCredentialCache, self), pszUrl, pszRealm, dwAuthenticationFlags, ppCred, pdwRequirementsFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredentialCache_SetGood(self: *const T, pCred: *IMFNetCredential, fGood: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredentialCache.VTable, self.vtable).SetGood(@ptrCast(*const IMFNetCredentialCache, self), pCred, fGood);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCredentialCache_SetUserOptions(self: *const T, pCred: *IMFNetCredential, dwOptionsFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCredentialCache.VTable, self.vtable).SetUserOptions(@ptrCast(*const IMFNetCredentialCache, self), pCred, dwOptionsFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSSLCertificateManager_Value = @import("../zig.zig").Guid.initString("61F7D887-1230-4A8B-AEBA-8AD434D1A64D");
pub const IID_IMFSSLCertificateManager = &IID_IMFSSLCertificateManager_Value;
pub const IMFSSLCertificateManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientCertificate: fn(
            self: *const IMFSSLCertificateManager,
            pszURL: [*:0]const u16,
            ppbData: **u8,
            pcbData: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginGetClientCertificate: fn(
            self: *const IMFSSLCertificateManager,
            pszURL: [*:0]const u16,
            pCallback: *IMFAsyncCallback,
            pState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndGetClientCertificate: fn(
            self: *const IMFSSLCertificateManager,
            pResult: *IMFAsyncResult,
            ppbData: **u8,
            pcbData: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificatePolicy: fn(
            self: *const IMFSSLCertificateManager,
            pszURL: [*:0]const u16,
            pfOverrideAutomaticCheck: *BOOL,
            pfClientCertificateAvailable: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnServerCertificate: fn(
            self: *const IMFSSLCertificateManager,
            pszURL: [*:0]const u16,
            pbData: [*:0]u8,
            cbData: u32,
            pfIsGood: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSSLCertificateManager_GetClientCertificate(self: *const T, pszURL: [*:0]const u16, ppbData: **u8, pcbData: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSSLCertificateManager.VTable, self.vtable).GetClientCertificate(@ptrCast(*const IMFSSLCertificateManager, self), pszURL, ppbData, pcbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSSLCertificateManager_BeginGetClientCertificate(self: *const T, pszURL: [*:0]const u16, pCallback: *IMFAsyncCallback, pState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSSLCertificateManager.VTable, self.vtable).BeginGetClientCertificate(@ptrCast(*const IMFSSLCertificateManager, self), pszURL, pCallback, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSSLCertificateManager_EndGetClientCertificate(self: *const T, pResult: *IMFAsyncResult, ppbData: **u8, pcbData: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSSLCertificateManager.VTable, self.vtable).EndGetClientCertificate(@ptrCast(*const IMFSSLCertificateManager, self), pResult, ppbData, pcbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSSLCertificateManager_GetCertificatePolicy(self: *const T, pszURL: [*:0]const u16, pfOverrideAutomaticCheck: *BOOL, pfClientCertificateAvailable: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSSLCertificateManager.VTable, self.vtable).GetCertificatePolicy(@ptrCast(*const IMFSSLCertificateManager, self), pszURL, pfOverrideAutomaticCheck, pfClientCertificateAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSSLCertificateManager_OnServerCertificate(self: *const T, pszURL: [*:0]const u16, pbData: [*:0]u8, cbData: u32, pfIsGood: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSSLCertificateManager.VTable, self.vtable).OnServerCertificate(@ptrCast(*const IMFSSLCertificateManager, self), pszURL, pbData, cbData, pfIsGood);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFNetResourceFilter_Value = @import("../zig.zig").Guid.initString("091878A3-BF11-4A5C-BC9F-33995B06EF2D");
pub const IID_IMFNetResourceFilter = &IID_IMFNetResourceFilter_Value;
pub const IMFNetResourceFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnRedirect: fn(
            self: *const IMFNetResourceFilter,
            pszUrl: [*:0]const u16,
            pvbCancel: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSendingRequest: fn(
            self: *const IMFNetResourceFilter,
            pszUrl: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetResourceFilter_OnRedirect(self: *const T, pszUrl: [*:0]const u16, pvbCancel: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetResourceFilter.VTable, self.vtable).OnRedirect(@ptrCast(*const IMFNetResourceFilter, self), pszUrl, pvbCancel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetResourceFilter_OnSendingRequest(self: *const T, pszUrl: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetResourceFilter.VTable, self.vtable).OnSendingRequest(@ptrCast(*const IMFNetResourceFilter, self), pszUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSourceOpenMonitor_Value = @import("../zig.zig").Guid.initString("059054B3-027C-494C-A27D-9113291CF87F");
pub const IID_IMFSourceOpenMonitor = &IID_IMFSourceOpenMonitor_Value;
pub const IMFSourceOpenMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSourceEvent: fn(
            self: *const IMFSourceOpenMonitor,
            pEvent: *IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceOpenMonitor_OnSourceEvent(self: *const T, pEvent: *IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceOpenMonitor.VTable, self.vtable).OnSourceEvent(@ptrCast(*const IMFSourceOpenMonitor, self), pEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFNetProxyLocator_Value = @import("../zig.zig").Guid.initString("E9CD0383-A268-4BB4-82DE-658D53574D41");
pub const IID_IMFNetProxyLocator = &IID_IMFNetProxyLocator_Value;
pub const IMFNetProxyLocator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindFirstProxy: fn(
            self: *const IMFNetProxyLocator,
            pszHost: [*:0]const u16,
            pszUrl: [*:0]const u16,
            fReserved: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindNextProxy: fn(
            self: *const IMFNetProxyLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterProxyResult: fn(
            self: *const IMFNetProxyLocator,
            hrOp: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProxy: fn(
            self: *const IMFNetProxyLocator,
            pszStr: ?[*:0]u16,
            pcchStr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IMFNetProxyLocator,
            ppProxyLocator: **IMFNetProxyLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetProxyLocator_FindFirstProxy(self: *const T, pszHost: [*:0]const u16, pszUrl: [*:0]const u16, fReserved: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetProxyLocator.VTable, self.vtable).FindFirstProxy(@ptrCast(*const IMFNetProxyLocator, self), pszHost, pszUrl, fReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetProxyLocator_FindNextProxy(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetProxyLocator.VTable, self.vtable).FindNextProxy(@ptrCast(*const IMFNetProxyLocator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetProxyLocator_RegisterProxyResult(self: *const T, hrOp: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetProxyLocator.VTable, self.vtable).RegisterProxyResult(@ptrCast(*const IMFNetProxyLocator, self), hrOp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetProxyLocator_GetCurrentProxy(self: *const T, pszStr: ?[*:0]u16, pcchStr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetProxyLocator.VTable, self.vtable).GetCurrentProxy(@ptrCast(*const IMFNetProxyLocator, self), pszStr, pcchStr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetProxyLocator_Clone(self: *const T, ppProxyLocator: **IMFNetProxyLocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetProxyLocator.VTable, self.vtable).Clone(@ptrCast(*const IMFNetProxyLocator, self), ppProxyLocator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFNetProxyLocatorFactory_Value = @import("../zig.zig").Guid.initString("E9CD0384-A268-4BB4-82DE-658D53574D41");
pub const IID_IMFNetProxyLocatorFactory = &IID_IMFNetProxyLocatorFactory_Value;
pub const IMFNetProxyLocatorFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProxyLocator: fn(
            self: *const IMFNetProxyLocatorFactory,
            pszProtocol: [*:0]const u16,
            ppProxyLocator: **IMFNetProxyLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetProxyLocatorFactory_CreateProxyLocator(self: *const T, pszProtocol: [*:0]const u16, ppProxyLocator: **IMFNetProxyLocator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetProxyLocatorFactory.VTable, self.vtable).CreateProxyLocator(@ptrCast(*const IMFNetProxyLocatorFactory, self), pszProtocol, ppProxyLocator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSaveJob_Value = @import("../zig.zig").Guid.initString("E9931663-80BF-4C6E-98AF-5DCF58747D1F");
pub const IID_IMFSaveJob = &IID_IMFSaveJob_Value;
pub const IMFSaveJob = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginSave: fn(
            self: *const IMFSaveJob,
            pStream: *IMFByteStream,
            pCallback: *IMFAsyncCallback,
            pState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSave: fn(
            self: *const IMFSaveJob,
            pResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelSave: fn(
            self: *const IMFSaveJob,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProgress: fn(
            self: *const IMFSaveJob,
            pdwPercentComplete: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSaveJob_BeginSave(self: *const T, pStream: *IMFByteStream, pCallback: *IMFAsyncCallback, pState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSaveJob.VTable, self.vtable).BeginSave(@ptrCast(*const IMFSaveJob, self), pStream, pCallback, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSaveJob_EndSave(self: *const T, pResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSaveJob.VTable, self.vtable).EndSave(@ptrCast(*const IMFSaveJob, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSaveJob_CancelSave(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSaveJob.VTable, self.vtable).CancelSave(@ptrCast(*const IMFSaveJob, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSaveJob_GetProgress(self: *const T, pdwPercentComplete: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSaveJob.VTable, self.vtable).GetProgress(@ptrCast(*const IMFSaveJob, self), pdwPercentComplete);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFNETSOURCE_PROTOCOL_TYPE = extern enum(i32) {
    MFNETSOURCE_UNDEFINED = 0,
    MFNETSOURCE_HTTP = 1,
    MFNETSOURCE_RTSP = 2,
    MFNETSOURCE_FILE = 3,
    MFNETSOURCE_MULTICAST = 4,
};
pub const MFNETSOURCE_UNDEFINED = MFNETSOURCE_PROTOCOL_TYPE.MFNETSOURCE_UNDEFINED;
pub const MFNETSOURCE_HTTP = MFNETSOURCE_PROTOCOL_TYPE.MFNETSOURCE_HTTP;
pub const MFNETSOURCE_RTSP = MFNETSOURCE_PROTOCOL_TYPE.MFNETSOURCE_RTSP;
pub const MFNETSOURCE_FILE = MFNETSOURCE_PROTOCOL_TYPE.MFNETSOURCE_FILE;
pub const MFNETSOURCE_MULTICAST = MFNETSOURCE_PROTOCOL_TYPE.MFNETSOURCE_MULTICAST;

const IID_IMFNetSchemeHandlerConfig_Value = @import("../zig.zig").Guid.initString("7BE19E73-C9BF-468A-AC5A-A5E8653BEC87");
pub const IID_IMFNetSchemeHandlerConfig = &IID_IMFNetSchemeHandlerConfig_Value;
pub const IMFNetSchemeHandlerConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberOfSupportedProtocols: fn(
            self: *const IMFNetSchemeHandlerConfig,
            pcProtocols: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProtocolType: fn(
            self: *const IMFNetSchemeHandlerConfig,
            nProtocolIndex: u32,
            pnProtocolType: *MFNETSOURCE_PROTOCOL_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetProtocolRolloverSettings: fn(
            self: *const IMFNetSchemeHandlerConfig,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetSchemeHandlerConfig_GetNumberOfSupportedProtocols(self: *const T, pcProtocols: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetSchemeHandlerConfig.VTable, self.vtable).GetNumberOfSupportedProtocols(@ptrCast(*const IMFNetSchemeHandlerConfig, self), pcProtocols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetSchemeHandlerConfig_GetSupportedProtocolType(self: *const T, nProtocolIndex: u32, pnProtocolType: *MFNETSOURCE_PROTOCOL_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetSchemeHandlerConfig.VTable, self.vtable).GetSupportedProtocolType(@ptrCast(*const IMFNetSchemeHandlerConfig, self), nProtocolIndex, pnProtocolType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetSchemeHandlerConfig_ResetProtocolRolloverSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetSchemeHandlerConfig.VTable, self.vtable).ResetProtocolRolloverSettings(@ptrCast(*const IMFNetSchemeHandlerConfig, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFNETSOURCE_TRANSPORT_TYPE = extern enum(i32) {
    MFNETSOURCE_UDP = 0,
    MFNETSOURCE_TCP = 1,
};
pub const MFNETSOURCE_UDP = MFNETSOURCE_TRANSPORT_TYPE.MFNETSOURCE_UDP;
pub const MFNETSOURCE_TCP = MFNETSOURCE_TRANSPORT_TYPE.MFNETSOURCE_TCP;

pub const MFNETSOURCE_CACHE_STATE = extern enum(i32) {
    MFNETSOURCE_CACHE_UNAVAILABLE = 0,
    MFNETSOURCE_CACHE_ACTIVE_WRITING = 1,
    MFNETSOURCE_CACHE_ACTIVE_COMPLETE = 2,
};
pub const MFNETSOURCE_CACHE_UNAVAILABLE = MFNETSOURCE_CACHE_STATE.MFNETSOURCE_CACHE_UNAVAILABLE;
pub const MFNETSOURCE_CACHE_ACTIVE_WRITING = MFNETSOURCE_CACHE_STATE.MFNETSOURCE_CACHE_ACTIVE_WRITING;
pub const MFNETSOURCE_CACHE_ACTIVE_COMPLETE = MFNETSOURCE_CACHE_STATE.MFNETSOURCE_CACHE_ACTIVE_COMPLETE;

pub const MFNETSOURCE_STATISTICS_IDS = extern enum(i32) {
    MFNETSOURCE_RECVPACKETS_ID = 0,
    MFNETSOURCE_LOSTPACKETS_ID = 1,
    MFNETSOURCE_RESENDSREQUESTED_ID = 2,
    MFNETSOURCE_RESENDSRECEIVED_ID = 3,
    MFNETSOURCE_RECOVEREDBYECCPACKETS_ID = 4,
    MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID = 5,
    MFNETSOURCE_OUTPACKETS_ID = 6,
    MFNETSOURCE_RECVRATE_ID = 7,
    MFNETSOURCE_AVGBANDWIDTHBPS_ID = 8,
    MFNETSOURCE_BYTESRECEIVED_ID = 9,
    MFNETSOURCE_PROTOCOL_ID = 10,
    MFNETSOURCE_TRANSPORT_ID = 11,
    MFNETSOURCE_CACHE_STATE_ID = 12,
    MFNETSOURCE_LINKBANDWIDTH_ID = 13,
    MFNETSOURCE_CONTENTBITRATE_ID = 14,
    MFNETSOURCE_SPEEDFACTOR_ID = 15,
    MFNETSOURCE_BUFFERSIZE_ID = 16,
    MFNETSOURCE_BUFFERPROGRESS_ID = 17,
    MFNETSOURCE_LASTBWSWITCHTS_ID = 18,
    MFNETSOURCE_SEEKRANGESTART_ID = 19,
    MFNETSOURCE_SEEKRANGEEND_ID = 20,
    MFNETSOURCE_BUFFERINGCOUNT_ID = 21,
    MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID = 22,
    MFNETSOURCE_SIGNEDSESSION_ID = 23,
    MFNETSOURCE_MAXBITRATE_ID = 24,
    MFNETSOURCE_RECEPTION_QUALITY_ID = 25,
    MFNETSOURCE_RECOVEREDPACKETS_ID = 26,
    MFNETSOURCE_VBR_ID = 27,
    MFNETSOURCE_DOWNLOADPROGRESS_ID = 28,
    MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID = 29,
};
pub const MFNETSOURCE_RECVPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_RECVPACKETS_ID;
pub const MFNETSOURCE_LOSTPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_LOSTPACKETS_ID;
pub const MFNETSOURCE_RESENDSREQUESTED_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_RESENDSREQUESTED_ID;
pub const MFNETSOURCE_RESENDSRECEIVED_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_RESENDSRECEIVED_ID;
pub const MFNETSOURCE_RECOVEREDBYECCPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_RECOVEREDBYECCPACKETS_ID;
pub const MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_RECOVEREDBYRTXPACKETS_ID;
pub const MFNETSOURCE_OUTPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_OUTPACKETS_ID;
pub const MFNETSOURCE_RECVRATE_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_RECVRATE_ID;
pub const MFNETSOURCE_AVGBANDWIDTHBPS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_AVGBANDWIDTHBPS_ID;
pub const MFNETSOURCE_BYTESRECEIVED_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_BYTESRECEIVED_ID;
pub const MFNETSOURCE_PROTOCOL_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_PROTOCOL_ID;
pub const MFNETSOURCE_TRANSPORT_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_TRANSPORT_ID;
pub const MFNETSOURCE_CACHE_STATE_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_CACHE_STATE_ID;
pub const MFNETSOURCE_LINKBANDWIDTH_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_LINKBANDWIDTH_ID;
pub const MFNETSOURCE_CONTENTBITRATE_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_CONTENTBITRATE_ID;
pub const MFNETSOURCE_SPEEDFACTOR_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_SPEEDFACTOR_ID;
pub const MFNETSOURCE_BUFFERSIZE_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_BUFFERSIZE_ID;
pub const MFNETSOURCE_BUFFERPROGRESS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_BUFFERPROGRESS_ID;
pub const MFNETSOURCE_LASTBWSWITCHTS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_LASTBWSWITCHTS_ID;
pub const MFNETSOURCE_SEEKRANGESTART_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_SEEKRANGESTART_ID;
pub const MFNETSOURCE_SEEKRANGEEND_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_SEEKRANGEEND_ID;
pub const MFNETSOURCE_BUFFERINGCOUNT_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_BUFFERINGCOUNT_ID;
pub const MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_INCORRECTLYSIGNEDPACKETS_ID;
pub const MFNETSOURCE_SIGNEDSESSION_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_SIGNEDSESSION_ID;
pub const MFNETSOURCE_MAXBITRATE_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_MAXBITRATE_ID;
pub const MFNETSOURCE_RECEPTION_QUALITY_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_RECEPTION_QUALITY_ID;
pub const MFNETSOURCE_RECOVEREDPACKETS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_RECOVEREDPACKETS_ID;
pub const MFNETSOURCE_VBR_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_VBR_ID;
pub const MFNETSOURCE_DOWNLOADPROGRESS_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_DOWNLOADPROGRESS_ID;
pub const MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID = MFNETSOURCE_STATISTICS_IDS.MFNETSOURCE_UNPREDEFINEDPROTOCOLNAME_ID;

pub const MFNET_PROXYSETTINGS = extern enum(i32) {
    MFNET_PROXYSETTING_NONE = 0,
    MFNET_PROXYSETTING_MANUAL = 1,
    MFNET_PROXYSETTING_AUTO = 2,
    MFNET_PROXYSETTING_BROWSER = 3,
};
pub const MFNET_PROXYSETTING_NONE = MFNET_PROXYSETTINGS.MFNET_PROXYSETTING_NONE;
pub const MFNET_PROXYSETTING_MANUAL = MFNET_PROXYSETTINGS.MFNET_PROXYSETTING_MANUAL;
pub const MFNET_PROXYSETTING_AUTO = MFNET_PROXYSETTINGS.MFNET_PROXYSETTING_AUTO;
pub const MFNET_PROXYSETTING_BROWSER = MFNET_PROXYSETTINGS.MFNET_PROXYSETTING_BROWSER;

const IID_IMFSchemeHandler_Value = @import("../zig.zig").Guid.initString("6D4C7B74-52A0-4BB7-B0DB-55F29F47A668");
pub const IID_IMFSchemeHandler = &IID_IMFSchemeHandler_Value;
pub const IMFSchemeHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginCreateObject: fn(
            self: *const IMFSchemeHandler,
            pwszURL: [*:0]const u16,
            dwFlags: u32,
            pProps: *IPropertyStore,
            ppIUnknownCancelCookie: ?*?*IUnknown,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndCreateObject: fn(
            self: *const IMFSchemeHandler,
            pResult: *IMFAsyncResult,
            pObjectType: *MF_OBJECT_TYPE,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelObjectCreation: fn(
            self: *const IMFSchemeHandler,
            pIUnknownCancelCookie: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSchemeHandler_BeginCreateObject(self: *const T, pwszURL: [*:0]const u16, dwFlags: u32, pProps: *IPropertyStore, ppIUnknownCancelCookie: ?*?*IUnknown, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSchemeHandler.VTable, self.vtable).BeginCreateObject(@ptrCast(*const IMFSchemeHandler, self), pwszURL, dwFlags, pProps, ppIUnknownCancelCookie, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSchemeHandler_EndCreateObject(self: *const T, pResult: *IMFAsyncResult, pObjectType: *MF_OBJECT_TYPE, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSchemeHandler.VTable, self.vtable).EndCreateObject(@ptrCast(*const IMFSchemeHandler, self), pResult, pObjectType, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSchemeHandler_CancelObjectCreation(self: *const T, pIUnknownCancelCookie: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSchemeHandler.VTable, self.vtable).CancelObjectCreation(@ptrCast(*const IMFSchemeHandler, self), pIUnknownCancelCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFByteStreamHandler_Value = @import("../zig.zig").Guid.initString("BB420AA4-765B-4A1F-91FE-D6A8A143924C");
pub const IID_IMFByteStreamHandler = &IID_IMFByteStreamHandler_Value;
pub const IMFByteStreamHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginCreateObject: fn(
            self: *const IMFByteStreamHandler,
            pByteStream: *IMFByteStream,
            pwszURL: [*:0]const u16,
            dwFlags: u32,
            pProps: *IPropertyStore,
            ppIUnknownCancelCookie: ?*?*IUnknown,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndCreateObject: fn(
            self: *const IMFByteStreamHandler,
            pResult: *IMFAsyncResult,
            pObjectType: *MF_OBJECT_TYPE,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelObjectCreation: fn(
            self: *const IMFByteStreamHandler,
            pIUnknownCancelCookie: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMaxNumberOfBytesRequiredForResolution: fn(
            self: *const IMFByteStreamHandler,
            pqwBytes: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamHandler_BeginCreateObject(self: *const T, pByteStream: *IMFByteStream, pwszURL: [*:0]const u16, dwFlags: u32, pProps: *IPropertyStore, ppIUnknownCancelCookie: ?*?*IUnknown, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamHandler.VTable, self.vtable).BeginCreateObject(@ptrCast(*const IMFByteStreamHandler, self), pByteStream, pwszURL, dwFlags, pProps, ppIUnknownCancelCookie, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamHandler_EndCreateObject(self: *const T, pResult: *IMFAsyncResult, pObjectType: *MF_OBJECT_TYPE, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamHandler.VTable, self.vtable).EndCreateObject(@ptrCast(*const IMFByteStreamHandler, self), pResult, pObjectType, ppObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamHandler_CancelObjectCreation(self: *const T, pIUnknownCancelCookie: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamHandler.VTable, self.vtable).CancelObjectCreation(@ptrCast(*const IMFByteStreamHandler, self), pIUnknownCancelCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFByteStreamHandler_GetMaxNumberOfBytesRequiredForResolution(self: *const T, pqwBytes: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFByteStreamHandler.VTable, self.vtable).GetMaxNumberOfBytesRequiredForResolution(@ptrCast(*const IMFByteStreamHandler, self), pqwBytes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTrustedInput_Value = @import("../zig.zig").Guid.initString("542612C4-A1B8-4632-B521-DE11EA64A0B0");
pub const IID_IMFTrustedInput = &IID_IMFTrustedInput_Value;
pub const IMFTrustedInput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputTrustAuthority: fn(
            self: *const IMFTrustedInput,
            dwStreamID: u32,
            riid: *const Guid,
            ppunkObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTrustedInput_GetInputTrustAuthority(self: *const T, dwStreamID: u32, riid: *const Guid, ppunkObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTrustedInput.VTable, self.vtable).GetInputTrustAuthority(@ptrCast(*const IMFTrustedInput, self), dwStreamID, riid, ppunkObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFPOLICYMANAGER_ACTION = extern enum(i32) {
    PEACTION_NO = 0,
    PEACTION_PLAY = 1,
    PEACTION_COPY = 2,
    PEACTION_EXPORT = 3,
    PEACTION_EXTRACT = 4,
    PEACTION_RESERVED1 = 5,
    PEACTION_RESERVED2 = 6,
    PEACTION_RESERVED3 = 7,
    PEACTION_LAST = 7,
};
pub const PEACTION_NO = MFPOLICYMANAGER_ACTION.PEACTION_NO;
pub const PEACTION_PLAY = MFPOLICYMANAGER_ACTION.PEACTION_PLAY;
pub const PEACTION_COPY = MFPOLICYMANAGER_ACTION.PEACTION_COPY;
pub const PEACTION_EXPORT = MFPOLICYMANAGER_ACTION.PEACTION_EXPORT;
pub const PEACTION_EXTRACT = MFPOLICYMANAGER_ACTION.PEACTION_EXTRACT;
pub const PEACTION_RESERVED1 = MFPOLICYMANAGER_ACTION.PEACTION_RESERVED1;
pub const PEACTION_RESERVED2 = MFPOLICYMANAGER_ACTION.PEACTION_RESERVED2;
pub const PEACTION_RESERVED3 = MFPOLICYMANAGER_ACTION.PEACTION_RESERVED3;
pub const PEACTION_LAST = MFPOLICYMANAGER_ACTION.PEACTION_LAST;

pub const MFINPUTTRUSTAUTHORITY_ACCESS_ACTION = extern struct {
    Action: MFPOLICYMANAGER_ACTION,
    pbTicket: *u8,
    cbTicket: u32,
};

pub const MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS = extern struct {
    dwSize: u32,
    dwVer: u32,
    cbSignatureOffset: u32,
    cbSignatureSize: u32,
    cbExtensionOffset: u32,
    cbExtensionSize: u32,
    cActions: u32,
    rgOutputActions: [1]MFINPUTTRUSTAUTHORITY_ACCESS_ACTION,
};

const IID_IMFInputTrustAuthority_Value = @import("../zig.zig").Guid.initString("D19F8E98-B126-4446-890C-5DCB7AD71453");
pub const IID_IMFInputTrustAuthority = &IID_IMFInputTrustAuthority_Value;
pub const IMFInputTrustAuthority = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDecrypter: fn(
            self: *const IMFInputTrustAuthority,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestAccess: fn(
            self: *const IMFInputTrustAuthority,
            Action: MFPOLICYMANAGER_ACTION,
            ppContentEnablerActivate: **IMFActivate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPolicy: fn(
            self: *const IMFInputTrustAuthority,
            Action: MFPOLICYMANAGER_ACTION,
            ppPolicy: **IMFOutputPolicy,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindAccess: fn(
            self: *const IMFInputTrustAuthority,
            pParam: *MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAccess: fn(
            self: *const IMFInputTrustAuthority,
            pParam: *MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IMFInputTrustAuthority,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFInputTrustAuthority_GetDecrypter(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFInputTrustAuthority.VTable, self.vtable).GetDecrypter(@ptrCast(*const IMFInputTrustAuthority, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFInputTrustAuthority_RequestAccess(self: *const T, Action: MFPOLICYMANAGER_ACTION, ppContentEnablerActivate: **IMFActivate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFInputTrustAuthority.VTable, self.vtable).RequestAccess(@ptrCast(*const IMFInputTrustAuthority, self), Action, ppContentEnablerActivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFInputTrustAuthority_GetPolicy(self: *const T, Action: MFPOLICYMANAGER_ACTION, ppPolicy: **IMFOutputPolicy) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFInputTrustAuthority.VTable, self.vtable).GetPolicy(@ptrCast(*const IMFInputTrustAuthority, self), Action, ppPolicy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFInputTrustAuthority_BindAccess(self: *const T, pParam: *MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFInputTrustAuthority.VTable, self.vtable).BindAccess(@ptrCast(*const IMFInputTrustAuthority, self), pParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFInputTrustAuthority_UpdateAccess(self: *const T, pParam: *MFINPUTTRUSTAUTHORITY_ACCESS_PARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFInputTrustAuthority.VTable, self.vtable).UpdateAccess(@ptrCast(*const IMFInputTrustAuthority, self), pParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFInputTrustAuthority_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFInputTrustAuthority.VTable, self.vtable).Reset(@ptrCast(*const IMFInputTrustAuthority, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTrustedOutput_Value = @import("../zig.zig").Guid.initString("D19F8E95-B126-4446-890C-5DCB7AD71453");
pub const IID_IMFTrustedOutput = &IID_IMFTrustedOutput_Value;
pub const IMFTrustedOutput = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOutputTrustAuthorityCount: fn(
            self: *const IMFTrustedOutput,
            pcOutputTrustAuthorities: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputTrustAuthorityByIndex: fn(
            self: *const IMFTrustedOutput,
            dwIndex: u32,
            ppauthority: **IMFOutputTrustAuthority,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsFinal: fn(
            self: *const IMFTrustedOutput,
            pfIsFinal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTrustedOutput_GetOutputTrustAuthorityCount(self: *const T, pcOutputTrustAuthorities: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTrustedOutput.VTable, self.vtable).GetOutputTrustAuthorityCount(@ptrCast(*const IMFTrustedOutput, self), pcOutputTrustAuthorities);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTrustedOutput_GetOutputTrustAuthorityByIndex(self: *const T, dwIndex: u32, ppauthority: **IMFOutputTrustAuthority) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTrustedOutput.VTable, self.vtable).GetOutputTrustAuthorityByIndex(@ptrCast(*const IMFTrustedOutput, self), dwIndex, ppauthority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTrustedOutput_IsFinal(self: *const T, pfIsFinal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTrustedOutput.VTable, self.vtable).IsFinal(@ptrCast(*const IMFTrustedOutput, self), pfIsFinal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFOutputTrustAuthority_Value = @import("../zig.zig").Guid.initString("D19F8E94-B126-4446-890C-5DCB7AD71453");
pub const IID_IMFOutputTrustAuthority = &IID_IMFOutputTrustAuthority_Value;
pub const IMFOutputTrustAuthority = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAction: fn(
            self: *const IMFOutputTrustAuthority,
            pAction: *MFPOLICYMANAGER_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPolicy: fn(
            self: *const IMFOutputTrustAuthority,
            ppPolicy: ?[*]?*IMFOutputPolicy,
            nPolicy: u32,
            ppbTicket: ?*?*u8,
            pcbTicket: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFOutputTrustAuthority_GetAction(self: *const T, pAction: *MFPOLICYMANAGER_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFOutputTrustAuthority.VTable, self.vtable).GetAction(@ptrCast(*const IMFOutputTrustAuthority, self), pAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFOutputTrustAuthority_SetPolicy(self: *const T, ppPolicy: ?[*]?*IMFOutputPolicy, nPolicy: u32, ppbTicket: ?*?*u8, pcbTicket: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFOutputTrustAuthority.VTable, self.vtable).SetPolicy(@ptrCast(*const IMFOutputTrustAuthority, self), ppPolicy, nPolicy, ppbTicket, pcbTicket);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFOutputPolicy_Value = @import("../zig.zig").Guid.initString("7F00F10A-DAED-41AF-AB26-5FDFA4DFBA3C");
pub const IID_IMFOutputPolicy = &IID_IMFOutputPolicy_Value;
pub const IMFOutputPolicy = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GenerateRequiredSchemas: fn(
            self: *const IMFOutputPolicy,
            dwAttributes: u32,
            guidOutputSubType: Guid,
            rgGuidProtectionSchemasSupported: *Guid,
            cProtectionSchemasSupported: u32,
            ppRequiredProtectionSchemas: **IMFCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginatorID: fn(
            self: *const IMFOutputPolicy,
            pguidOriginatorID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMinimumGRLVersion: fn(
            self: *const IMFOutputPolicy,
            pdwMinimumGRLVersion: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFOutputPolicy_GenerateRequiredSchemas(self: *const T, dwAttributes: u32, guidOutputSubType: Guid, rgGuidProtectionSchemasSupported: *Guid, cProtectionSchemasSupported: u32, ppRequiredProtectionSchemas: **IMFCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFOutputPolicy.VTable, self.vtable).GenerateRequiredSchemas(@ptrCast(*const IMFOutputPolicy, self), dwAttributes, guidOutputSubType, rgGuidProtectionSchemasSupported, cProtectionSchemasSupported, ppRequiredProtectionSchemas);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFOutputPolicy_GetOriginatorID(self: *const T, pguidOriginatorID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFOutputPolicy.VTable, self.vtable).GetOriginatorID(@ptrCast(*const IMFOutputPolicy, self), pguidOriginatorID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFOutputPolicy_GetMinimumGRLVersion(self: *const T, pdwMinimumGRLVersion: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFOutputPolicy.VTable, self.vtable).GetMinimumGRLVersion(@ptrCast(*const IMFOutputPolicy, self), pdwMinimumGRLVersion);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFOutputSchema_Value = @import("../zig.zig").Guid.initString("7BE0FC5B-ABD9-44FB-A5C8-F50136E71599");
pub const IID_IMFOutputSchema = &IID_IMFOutputSchema_Value;
pub const IMFOutputSchema = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetSchemaType: fn(
            self: *const IMFOutputSchema,
            pguidSchemaType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfigurationData: fn(
            self: *const IMFOutputSchema,
            pdwVal: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginatorID: fn(
            self: *const IMFOutputSchema,
            pguidOriginatorID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFOutputSchema_GetSchemaType(self: *const T, pguidSchemaType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFOutputSchema.VTable, self.vtable).GetSchemaType(@ptrCast(*const IMFOutputSchema, self), pguidSchemaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFOutputSchema_GetConfigurationData(self: *const T, pdwVal: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFOutputSchema.VTable, self.vtable).GetConfigurationData(@ptrCast(*const IMFOutputSchema, self), pdwVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFOutputSchema_GetOriginatorID(self: *const T, pguidOriginatorID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFOutputSchema.VTable, self.vtable).GetOriginatorID(@ptrCast(*const IMFOutputSchema, self), pguidOriginatorID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_OPM_CGMSA_PROTECTION_LEVEL = extern enum(i32) {
    MF_OPM_CGMSA_OFF = 0,
    MF_OPM_CGMSA_COPY_FREELY = 1,
    MF_OPM_CGMSA_COPY_NO_MORE = 2,
    MF_OPM_CGMSA_COPY_ONE_GENERATION = 3,
    MF_OPM_CGMSA_COPY_NEVER = 4,
    MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED = 8,
};
pub const MF_OPM_CGMSA_OFF = MF_OPM_CGMSA_PROTECTION_LEVEL.MF_OPM_CGMSA_OFF;
pub const MF_OPM_CGMSA_COPY_FREELY = MF_OPM_CGMSA_PROTECTION_LEVEL.MF_OPM_CGMSA_COPY_FREELY;
pub const MF_OPM_CGMSA_COPY_NO_MORE = MF_OPM_CGMSA_PROTECTION_LEVEL.MF_OPM_CGMSA_COPY_NO_MORE;
pub const MF_OPM_CGMSA_COPY_ONE_GENERATION = MF_OPM_CGMSA_PROTECTION_LEVEL.MF_OPM_CGMSA_COPY_ONE_GENERATION;
pub const MF_OPM_CGMSA_COPY_NEVER = MF_OPM_CGMSA_PROTECTION_LEVEL.MF_OPM_CGMSA_COPY_NEVER;
pub const MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED = MF_OPM_CGMSA_PROTECTION_LEVEL.MF_OPM_CGMSA_REDISTRIBUTION_CONTROL_REQUIRED;

pub const MF_OPM_ACP_PROTECTION_LEVEL = extern enum(i32) {
    MF_OPM_ACP_OFF = 0,
    MF_OPM_ACP_LEVEL_ONE = 1,
    MF_OPM_ACP_LEVEL_TWO = 2,
    MF_OPM_ACP_LEVEL_THREE = 3,
    MF_OPM_ACP_FORCE_ULONG = 2147483647,
};
pub const MF_OPM_ACP_OFF = MF_OPM_ACP_PROTECTION_LEVEL.MF_OPM_ACP_OFF;
pub const MF_OPM_ACP_LEVEL_ONE = MF_OPM_ACP_PROTECTION_LEVEL.MF_OPM_ACP_LEVEL_ONE;
pub const MF_OPM_ACP_LEVEL_TWO = MF_OPM_ACP_PROTECTION_LEVEL.MF_OPM_ACP_LEVEL_TWO;
pub const MF_OPM_ACP_LEVEL_THREE = MF_OPM_ACP_PROTECTION_LEVEL.MF_OPM_ACP_LEVEL_THREE;
pub const MF_OPM_ACP_FORCE_ULONG = MF_OPM_ACP_PROTECTION_LEVEL.MF_OPM_ACP_FORCE_ULONG;

pub const MFAudioConstriction = extern enum(i32) {
    MFaudioConstrictionOff = 0,
    MFaudioConstriction48_16 = 1,
    MFaudioConstriction44_16 = 2,
    MFaudioConstriction14_14 = 3,
    MFaudioConstrictionMute = 4,
};
pub const MFaudioConstrictionOff = MFAudioConstriction.MFaudioConstrictionOff;
pub const MFaudioConstriction48_16 = MFAudioConstriction.MFaudioConstriction48_16;
pub const MFaudioConstriction44_16 = MFAudioConstriction.MFaudioConstriction44_16;
pub const MFaudioConstriction14_14 = MFAudioConstriction.MFaudioConstriction14_14;
pub const MFaudioConstrictionMute = MFAudioConstriction.MFaudioConstrictionMute;

const IID_IMFSecureChannel_Value = @import("../zig.zig").Guid.initString("D0AE555D-3B12-4D97-B060-0990BC5AEB67");
pub const IID_IMFSecureChannel = &IID_IMFSecureChannel_Value;
pub const IMFSecureChannel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCertificate: fn(
            self: *const IMFSecureChannel,
            ppCert: **u8,
            pcbCert: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetupSession: fn(
            self: *const IMFSecureChannel,
            pbEncryptedSessionKey: [*:0]u8,
            cbSessionKey: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSecureChannel_GetCertificate(self: *const T, ppCert: **u8, pcbCert: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSecureChannel.VTable, self.vtable).GetCertificate(@ptrCast(*const IMFSecureChannel, self), ppCert, pcbCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSecureChannel_SetupSession(self: *const T, pbEncryptedSessionKey: [*:0]u8, cbSessionKey: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSecureChannel.VTable, self.vtable).SetupSession(@ptrCast(*const IMFSecureChannel, self), pbEncryptedSessionKey, cbSessionKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SAMPLE_PROTECTION_VERSION = extern enum(i32) {
    NO = 0,
    BASIC_LOKI = 1,
    SCATTER = 2,
    RC4 = 3,
    AES128CTR = 4,
};
pub const SAMPLE_PROTECTION_VERSION_NO = SAMPLE_PROTECTION_VERSION.NO;
pub const SAMPLE_PROTECTION_VERSION_BASIC_LOKI = SAMPLE_PROTECTION_VERSION.BASIC_LOKI;
pub const SAMPLE_PROTECTION_VERSION_SCATTER = SAMPLE_PROTECTION_VERSION.SCATTER;
pub const SAMPLE_PROTECTION_VERSION_RC4 = SAMPLE_PROTECTION_VERSION.RC4;
pub const SAMPLE_PROTECTION_VERSION_AES128CTR = SAMPLE_PROTECTION_VERSION.AES128CTR;

const IID_IMFSampleProtection_Value = @import("../zig.zig").Guid.initString("8E36395F-C7B9-43C4-A54D-512B4AF63C95");
pub const IID_IMFSampleProtection = &IID_IMFSampleProtection_Value;
pub const IMFSampleProtection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInputProtectionVersion: fn(
            self: *const IMFSampleProtection,
            pdwVersion: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputProtectionVersion: fn(
            self: *const IMFSampleProtection,
            pdwVersion: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtectionCertificate: fn(
            self: *const IMFSampleProtection,
            dwVersion: u32,
            ppCert: **u8,
            pcbCert: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitOutputProtection: fn(
            self: *const IMFSampleProtection,
            dwVersion: u32,
            dwOutputId: u32,
            pbCert: *u8,
            cbCert: u32,
            ppbSeed: **u8,
            pcbSeed: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitInputProtection: fn(
            self: *const IMFSampleProtection,
            dwVersion: u32,
            dwInputId: u32,
            pbSeed: *u8,
            cbSeed: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleProtection_GetInputProtectionVersion(self: *const T, pdwVersion: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleProtection.VTable, self.vtable).GetInputProtectionVersion(@ptrCast(*const IMFSampleProtection, self), pdwVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleProtection_GetOutputProtectionVersion(self: *const T, pdwVersion: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleProtection.VTable, self.vtable).GetOutputProtectionVersion(@ptrCast(*const IMFSampleProtection, self), pdwVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleProtection_GetProtectionCertificate(self: *const T, dwVersion: u32, ppCert: **u8, pcbCert: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleProtection.VTable, self.vtable).GetProtectionCertificate(@ptrCast(*const IMFSampleProtection, self), dwVersion, ppCert, pcbCert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleProtection_InitOutputProtection(self: *const T, dwVersion: u32, dwOutputId: u32, pbCert: *u8, cbCert: u32, ppbSeed: **u8, pcbSeed: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleProtection.VTable, self.vtable).InitOutputProtection(@ptrCast(*const IMFSampleProtection, self), dwVersion, dwOutputId, pbCert, cbCert, ppbSeed, pcbSeed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleProtection_InitInputProtection(self: *const T, dwVersion: u32, dwInputId: u32, pbSeed: *u8, cbSeed: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleProtection.VTable, self.vtable).InitInputProtection(@ptrCast(*const IMFSampleProtection, self), dwVersion, dwInputId, pbSeed, cbSeed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaSinkPreroll_Value = @import("../zig.zig").Guid.initString("5DFD4B2A-7674-4110-A4E6-8A68FD5F3688");
pub const IID_IMFMediaSinkPreroll = &IID_IMFMediaSinkPreroll_Value;
pub const IMFMediaSinkPreroll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyPreroll: fn(
            self: *const IMFMediaSinkPreroll,
            hnsUpcomingStartTime: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSinkPreroll_NotifyPreroll(self: *const T, hnsUpcomingStartTime: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSinkPreroll.VTable, self.vtable).NotifyPreroll(@ptrCast(*const IMFMediaSinkPreroll, self), hnsUpcomingStartTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFFinalizableMediaSink_Value = @import("../zig.zig").Guid.initString("EAECB74A-9A50-42CE-9541-6A7F57AA4AD7");
pub const IID_IMFFinalizableMediaSink = &IID_IMFFinalizableMediaSink_Value;
pub const IMFFinalizableMediaSink = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaSink.VTable,
        BeginFinalize: fn(
            self: *const IMFFinalizableMediaSink,
            pCallback: *IMFAsyncCallback,
            punkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndFinalize: fn(
            self: *const IMFFinalizableMediaSink,
            pResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFFinalizableMediaSink_BeginFinalize(self: *const T, pCallback: *IMFAsyncCallback, punkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFFinalizableMediaSink.VTable, self.vtable).BeginFinalize(@ptrCast(*const IMFFinalizableMediaSink, self), pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFFinalizableMediaSink_EndFinalize(self: *const T, pResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFFinalizableMediaSink.VTable, self.vtable).EndFinalize(@ptrCast(*const IMFFinalizableMediaSink, self), pResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFStreamingSinkConfig_Value = @import("../zig.zig").Guid.initString("9DB7AA41-3CC5-40D4-8509-555804AD34CC");
pub const IID_IMFStreamingSinkConfig = &IID_IMFStreamingSinkConfig_Value;
pub const IMFStreamingSinkConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartStreaming: fn(
            self: *const IMFStreamingSinkConfig,
            fSeekOffsetIsByteOffset: BOOL,
            qwSeekOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFStreamingSinkConfig_StartStreaming(self: *const T, fSeekOffsetIsByteOffset: BOOL, qwSeekOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFStreamingSinkConfig.VTable, self.vtable).StartStreaming(@ptrCast(*const IMFStreamingSinkConfig, self), fSeekOffsetIsByteOffset, qwSeekOffset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFRemoteProxy_Value = @import("../zig.zig").Guid.initString("994E23AD-1CC2-493C-B9FA-46F1CB040FA4");
pub const IID_IMFRemoteProxy = &IID_IMFRemoteProxy_Value;
pub const IMFRemoteProxy = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRemoteObject: fn(
            self: *const IMFRemoteProxy,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRemoteHost: fn(
            self: *const IMFRemoteProxy,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRemoteProxy_GetRemoteObject(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRemoteProxy.VTable, self.vtable).GetRemoteObject(@ptrCast(*const IMFRemoteProxy, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRemoteProxy_GetRemoteHost(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRemoteProxy.VTable, self.vtable).GetRemoteHost(@ptrCast(*const IMFRemoteProxy, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFObjectReferenceStream_Value = @import("../zig.zig").Guid.initString("09EF5BE3-C8A7-469E-8B70-73BF25BB193F");
pub const IID_IMFObjectReferenceStream = &IID_IMFObjectReferenceStream_Value;
pub const IMFObjectReferenceStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SaveReference: fn(
            self: *const IMFObjectReferenceStream,
            riid: *const Guid,
            pUnk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadReference: fn(
            self: *const IMFObjectReferenceStream,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFObjectReferenceStream_SaveReference(self: *const T, riid: *const Guid, pUnk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFObjectReferenceStream.VTable, self.vtable).SaveReference(@ptrCast(*const IMFObjectReferenceStream, self), riid, pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFObjectReferenceStream_LoadReference(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFObjectReferenceStream.VTable, self.vtable).LoadReference(@ptrCast(*const IMFObjectReferenceStream, self), riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPMPHost_Value = @import("../zig.zig").Guid.initString("F70CA1A9-FDC7-4782-B994-ADFFB1C98606");
pub const IID_IMFPMPHost = &IID_IMFPMPHost_Value;
pub const IMFPMPHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockProcess: fn(
            self: *const IMFPMPHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockProcess: fn(
            self: *const IMFPMPHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateObjectByCLSID: fn(
            self: *const IMFPMPHost,
            clsid: *const Guid,
            pStream: *IStream,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPHost_LockProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPHost.VTable, self.vtable).LockProcess(@ptrCast(*const IMFPMPHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPHost_UnlockProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPHost.VTable, self.vtable).UnlockProcess(@ptrCast(*const IMFPMPHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPHost_CreateObjectByCLSID(self: *const T, clsid: *const Guid, pStream: *IStream, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPHost.VTable, self.vtable).CreateObjectByCLSID(@ptrCast(*const IMFPMPHost, self), clsid, pStream, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPMPClient_Value = @import("../zig.zig").Guid.initString("6C4E655D-EAD8-4421-B6B9-54DCDBBDF820");
pub const IID_IMFPMPClient = &IID_IMFPMPClient_Value;
pub const IMFPMPClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPMPHost: fn(
            self: *const IMFPMPClient,
            pPMPHost: *IMFPMPHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPClient_SetPMPHost(self: *const T, pPMPHost: *IMFPMPHost) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPClient.VTable, self.vtable).SetPMPHost(@ptrCast(*const IMFPMPClient, self), pPMPHost);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPMPServer_Value = @import("../zig.zig").Guid.initString("994E23AF-1CC2-493C-B9FA-46F1CB040FA4");
pub const IID_IMFPMPServer = &IID_IMFPMPServer_Value;
pub const IMFPMPServer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockProcess: fn(
            self: *const IMFPMPServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockProcess: fn(
            self: *const IMFPMPServer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateObjectByCLSID: fn(
            self: *const IMFPMPServer,
            clsid: *const Guid,
            riid: *const Guid,
            ppObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPServer_LockProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPServer.VTable, self.vtable).LockProcess(@ptrCast(*const IMFPMPServer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPServer_UnlockProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPServer.VTable, self.vtable).UnlockProcess(@ptrCast(*const IMFPMPServer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPServer_CreateObjectByCLSID(self: *const T, clsid: *const Guid, riid: *const Guid, ppObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPServer.VTable, self.vtable).CreateObjectByCLSID(@ptrCast(*const IMFPMPServer, self), clsid, riid, ppObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFRemoteDesktopPlugin_Value = @import("../zig.zig").Guid.initString("1CDE6309-CAE0-4940-907E-C1EC9C3D1D4A");
pub const IID_IMFRemoteDesktopPlugin = &IID_IMFRemoteDesktopPlugin_Value;
pub const IMFRemoteDesktopPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UpdateTopology: fn(
            self: *const IMFRemoteDesktopPlugin,
            pTopology: *IMFTopology,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRemoteDesktopPlugin_UpdateTopology(self: *const T, pTopology: *IMFTopology) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRemoteDesktopPlugin.VTable, self.vtable).UpdateTopology(@ptrCast(*const IMFRemoteDesktopPlugin, self), pTopology);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSAMIStyle_Value = @import("../zig.zig").Guid.initString("A7E025DD-5303-4A62-89D6-E747E1EFAC73");
pub const IID_IMFSAMIStyle = &IID_IMFSAMIStyle_Value;
pub const IMFSAMIStyle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStyleCount: fn(
            self: *const IMFSAMIStyle,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyles: fn(
            self: *const IMFSAMIStyle,
            pPropVarStyleArray: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelectedStyle: fn(
            self: *const IMFSAMIStyle,
            pwszStyle: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedStyle: fn(
            self: *const IMFSAMIStyle,
            ppwszStyle: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSAMIStyle_GetStyleCount(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSAMIStyle.VTable, self.vtable).GetStyleCount(@ptrCast(*const IMFSAMIStyle, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSAMIStyle_GetStyles(self: *const T, pPropVarStyleArray: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSAMIStyle.VTable, self.vtable).GetStyles(@ptrCast(*const IMFSAMIStyle, self), pPropVarStyleArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSAMIStyle_SetSelectedStyle(self: *const T, pwszStyle: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSAMIStyle.VTable, self.vtable).SetSelectedStyle(@ptrCast(*const IMFSAMIStyle, self), pwszStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSAMIStyle_GetSelectedStyle(self: *const T, ppwszStyle: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSAMIStyle.VTable, self.vtable).GetSelectedStyle(@ptrCast(*const IMFSAMIStyle, self), ppwszStyle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTranscodeProfile_Value = @import("../zig.zig").Guid.initString("4ADFDBA3-7AB0-4953-A62B-461E7FF3DA1E");
pub const IID_IMFTranscodeProfile = &IID_IMFTranscodeProfile_Value;
pub const IMFTranscodeProfile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAudioAttributes: fn(
            self: *const IMFTranscodeProfile,
            pAttrs: ?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioAttributes: fn(
            self: *const IMFTranscodeProfile,
            ppAttrs: ?*?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoAttributes: fn(
            self: *const IMFTranscodeProfile,
            pAttrs: ?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoAttributes: fn(
            self: *const IMFTranscodeProfile,
            ppAttrs: ?*?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetContainerAttributes: fn(
            self: *const IMFTranscodeProfile,
            pAttrs: ?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainerAttributes: fn(
            self: *const IMFTranscodeProfile,
            ppAttrs: ?*?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeProfile_SetAudioAttributes(self: *const T, pAttrs: ?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeProfile.VTable, self.vtable).SetAudioAttributes(@ptrCast(*const IMFTranscodeProfile, self), pAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeProfile_GetAudioAttributes(self: *const T, ppAttrs: ?*?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeProfile.VTable, self.vtable).GetAudioAttributes(@ptrCast(*const IMFTranscodeProfile, self), ppAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeProfile_SetVideoAttributes(self: *const T, pAttrs: ?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeProfile.VTable, self.vtable).SetVideoAttributes(@ptrCast(*const IMFTranscodeProfile, self), pAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeProfile_GetVideoAttributes(self: *const T, ppAttrs: ?*?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeProfile.VTable, self.vtable).GetVideoAttributes(@ptrCast(*const IMFTranscodeProfile, self), ppAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeProfile_SetContainerAttributes(self: *const T, pAttrs: ?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeProfile.VTable, self.vtable).SetContainerAttributes(@ptrCast(*const IMFTranscodeProfile, self), pAttrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeProfile_GetContainerAttributes(self: *const T, ppAttrs: ?*?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeProfile.VTable, self.vtable).GetContainerAttributes(@ptrCast(*const IMFTranscodeProfile, self), ppAttrs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TRANSCODE_TOPOLOGYMODE_FLAGS = extern enum(i32) {
    MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY = 0,
    MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED = 1,
};
pub const MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY = MF_TRANSCODE_TOPOLOGYMODE_FLAGS.MF_TRANSCODE_TOPOLOGYMODE_SOFTWARE_ONLY;
pub const MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED = MF_TRANSCODE_TOPOLOGYMODE_FLAGS.MF_TRANSCODE_TOPOLOGYMODE_HARDWARE_ALLOWED;

pub const MF_TRANSCODE_ADJUST_PROFILE_FLAGS = extern enum(i32) {
    MF_TRANSCODE_ADJUST_PROFILE_DEFAULT = 0,
    MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES = 1,
};
pub const MF_TRANSCODE_ADJUST_PROFILE_DEFAULT = MF_TRANSCODE_ADJUST_PROFILE_FLAGS.MF_TRANSCODE_ADJUST_PROFILE_DEFAULT;
pub const MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES = MF_TRANSCODE_ADJUST_PROFILE_FLAGS.MF_TRANSCODE_ADJUST_PROFILE_USE_SOURCE_ATTRIBUTES;

pub const MF_VIDEO_PROCESSOR_ALGORITHM_TYPE = extern enum(i32) {
    MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT = 0,
    MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444 = 1,
};
pub const MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT = MF_VIDEO_PROCESSOR_ALGORITHM_TYPE.MF_VIDEO_PROCESSOR_ALGORITHM_DEFAULT;
pub const MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444 = MF_VIDEO_PROCESSOR_ALGORITHM_TYPE.MF_VIDEO_PROCESSOR_ALGORITHM_MRF_CRF_444;

pub const MF_TRANSCODE_SINK_INFO = extern struct {
    dwVideoStreamID: u32,
    pVideoMediaType: *IMFMediaType,
    dwAudioStreamID: u32,
    pAudioMediaType: *IMFMediaType,
};

const IID_IMFTranscodeSinkInfoProvider_Value = @import("../zig.zig").Guid.initString("8CFFCD2E-5A03-4A3A-AFF7-EDCD107C620E");
pub const IID_IMFTranscodeSinkInfoProvider = &IID_IMFTranscodeSinkInfoProvider_Value;
pub const IMFTranscodeSinkInfoProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetOutputFile: fn(
            self: *const IMFTranscodeSinkInfoProvider,
            pwszFileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputByteStream: fn(
            self: *const IMFTranscodeSinkInfoProvider,
            pByteStreamActivate: *IMFActivate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProfile: fn(
            self: *const IMFTranscodeSinkInfoProvider,
            pProfile: *IMFTranscodeProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSinkInfo: fn(
            self: *const IMFTranscodeSinkInfoProvider,
            pSinkInfo: *MF_TRANSCODE_SINK_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeSinkInfoProvider_SetOutputFile(self: *const T, pwszFileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeSinkInfoProvider.VTable, self.vtable).SetOutputFile(@ptrCast(*const IMFTranscodeSinkInfoProvider, self), pwszFileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeSinkInfoProvider_SetOutputByteStream(self: *const T, pByteStreamActivate: *IMFActivate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeSinkInfoProvider.VTable, self.vtable).SetOutputByteStream(@ptrCast(*const IMFTranscodeSinkInfoProvider, self), pByteStreamActivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeSinkInfoProvider_SetProfile(self: *const T, pProfile: *IMFTranscodeProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeSinkInfoProvider.VTable, self.vtable).SetProfile(@ptrCast(*const IMFTranscodeSinkInfoProvider, self), pProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTranscodeSinkInfoProvider_GetSinkInfo(self: *const T, pSinkInfo: *MF_TRANSCODE_SINK_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTranscodeSinkInfoProvider.VTable, self.vtable).GetSinkInfo(@ptrCast(*const IMFTranscodeSinkInfoProvider, self), pSinkInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFFieldOfUseMFTUnlock_Value = @import("../zig.zig").Guid.initString("508E71D3-EC66-4FC3-8775-B4B9ED6BA847");
pub const IID_IMFFieldOfUseMFTUnlock = &IID_IMFFieldOfUseMFTUnlock_Value;
pub const IMFFieldOfUseMFTUnlock = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Unlock: fn(
            self: *const IMFFieldOfUseMFTUnlock,
            pUnkMFT: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFFieldOfUseMFTUnlock_Unlock(self: *const T, pUnkMFT: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFFieldOfUseMFTUnlock.VTable, self.vtable).Unlock(@ptrCast(*const IMFFieldOfUseMFTUnlock, self), pUnkMFT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFT_REGISTRATION_INFO = extern struct {
    clsid: Guid,
    guidCategory: Guid,
    uiFlags: u32,
    pszName: [*:0]const u16,
    cInTypes: u32,
    pInTypes: *MFT_REGISTER_TYPE_INFO,
    cOutTypes: u32,
    pOutTypes: *MFT_REGISTER_TYPE_INFO,
};

const IID_IMFLocalMFTRegistration_Value = @import("../zig.zig").Guid.initString("149C4D73-B4BE-4F8D-8B87-079E926B6ADD");
pub const IID_IMFLocalMFTRegistration = &IID_IMFLocalMFTRegistration_Value;
pub const IMFLocalMFTRegistration = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterMFTs: fn(
            self: *const IMFLocalMFTRegistration,
            pMFTs: [*]MFT_REGISTRATION_INFO,
            cMFTs: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFLocalMFTRegistration_RegisterMFTs(self: *const T, pMFTs: [*]MFT_REGISTRATION_INFO, cMFTs: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFLocalMFTRegistration.VTable, self.vtable).RegisterMFTs(@ptrCast(*const IMFLocalMFTRegistration, self), pMFTs, cMFTs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCapturePhotoConfirmation_Value = @import("../zig.zig").Guid.initString("19F68549-CA8A-4706-A4EF-481DBC95E12C");
pub const IID_IMFCapturePhotoConfirmation = &IID_IMFCapturePhotoConfirmation_Value;
pub const IMFCapturePhotoConfirmation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPhotoConfirmationCallback: fn(
            self: *const IMFCapturePhotoConfirmation,
            pNotificationCallback: *IMFAsyncCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPixelFormat: fn(
            self: *const IMFCapturePhotoConfirmation,
            subtype: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPixelFormat: fn(
            self: *const IMFCapturePhotoConfirmation,
            subtype: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePhotoConfirmation_SetPhotoConfirmationCallback(self: *const T, pNotificationCallback: *IMFAsyncCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePhotoConfirmation.VTable, self.vtable).SetPhotoConfirmationCallback(@ptrCast(*const IMFCapturePhotoConfirmation, self), pNotificationCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePhotoConfirmation_SetPixelFormat(self: *const T, subtype: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePhotoConfirmation.VTable, self.vtable).SetPixelFormat(@ptrCast(*const IMFCapturePhotoConfirmation, self), subtype);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePhotoConfirmation_GetPixelFormat(self: *const T, subtype: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePhotoConfirmation.VTable, self.vtable).GetPixelFormat(@ptrCast(*const IMFCapturePhotoConfirmation, self), subtype);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPMPHostApp_Value = @import("../zig.zig").Guid.initString("84D2054A-3AA1-4728-A3B0-440A418CF49C");
pub const IID_IMFPMPHostApp = &IID_IMFPMPHostApp_Value;
pub const IMFPMPHostApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LockProcess: fn(
            self: *const IMFPMPHostApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockProcess: fn(
            self: *const IMFPMPHostApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateClassById: fn(
            self: *const IMFPMPHostApp,
            id: [*:0]const u16,
            pStream: *IStream,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPHostApp_LockProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPHostApp.VTable, self.vtable).LockProcess(@ptrCast(*const IMFPMPHostApp, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPHostApp_UnlockProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPHostApp.VTable, self.vtable).UnlockProcess(@ptrCast(*const IMFPMPHostApp, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPHostApp_ActivateClassById(self: *const T, id: [*:0]const u16, pStream: *IStream, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPHostApp.VTable, self.vtable).ActivateClassById(@ptrCast(*const IMFPMPHostApp, self), id, pStream, riid, ppv);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPMPClientApp_Value = @import("../zig.zig").Guid.initString("C004F646-BE2C-48F3-93A2-A0983EBA1108");
pub const IID_IMFPMPClientApp = &IID_IMFPMPClientApp_Value;
pub const IMFPMPClientApp = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetPMPHost: fn(
            self: *const IMFPMPClientApp,
            pPMPHost: *IMFPMPHostApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMPClientApp_SetPMPHost(self: *const T, pPMPHost: *IMFPMPHostApp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMPClientApp.VTable, self.vtable).SetPMPHost(@ptrCast(*const IMFPMPClientApp, self), pPMPHost);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaStreamSourceSampleRequest_Value = @import("../zig.zig").Guid.initString("380B9AF9-A85B-4E78-A2AF-EA5CE645C6B4");
pub const IID_IMFMediaStreamSourceSampleRequest = &IID_IMFMediaStreamSourceSampleRequest_Value;
pub const IMFMediaStreamSourceSampleRequest = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSample: fn(
            self: *const IMFMediaStreamSourceSampleRequest,
            value: *IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaStreamSourceSampleRequest_SetSample(self: *const T, value: *IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaStreamSourceSampleRequest.VTable, self.vtable).SetSample(@ptrCast(*const IMFMediaStreamSourceSampleRequest, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTrackedSample_Value = @import("../zig.zig").Guid.initString("245BF8E9-0755-40F7-88A5-AE0F18D55E17");
pub const IID_IMFTrackedSample = &IID_IMFTrackedSample_Value;
pub const IMFTrackedSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAllocator: fn(
            self: *const IMFTrackedSample,
            pSampleAllocator: *IMFAsyncCallback,
            pUnkState: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTrackedSample_SetAllocator(self: *const T, pSampleAllocator: *IMFAsyncCallback, pUnkState: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTrackedSample.VTable, self.vtable).SetAllocator(@ptrCast(*const IMFTrackedSample, self), pSampleAllocator, pUnkState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFProtectedEnvironmentAccess_Value = @import("../zig.zig").Guid.initString("EF5DC845-F0D9-4EC9-B00C-CB5183D38434");
pub const IID_IMFProtectedEnvironmentAccess = &IID_IMFProtectedEnvironmentAccess_Value;
pub const IMFProtectedEnvironmentAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Call: fn(
            self: *const IMFProtectedEnvironmentAccess,
            inputLength: u32,
            input: [*:0]const u8,
            outputLength: u32,
            output: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadGRL: fn(
            self: *const IMFProtectedEnvironmentAccess,
            outputLength: *u32,
            output: **u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFProtectedEnvironmentAccess_Call(self: *const T, inputLength: u32, input: [*:0]const u8, outputLength: u32, output: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFProtectedEnvironmentAccess.VTable, self.vtable).Call(@ptrCast(*const IMFProtectedEnvironmentAccess, self), inputLength, input, outputLength, output);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFProtectedEnvironmentAccess_ReadGRL(self: *const T, outputLength: *u32, output: **u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFProtectedEnvironmentAccess.VTable, self.vtable).ReadGRL(@ptrCast(*const IMFProtectedEnvironmentAccess, self), outputLength, output);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSignedLibrary_Value = @import("../zig.zig").Guid.initString("4A724BCA-FF6A-4C07-8E0D-7A358421CF06");
pub const IID_IMFSignedLibrary = &IID_IMFSignedLibrary_Value;
pub const IMFSignedLibrary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProcedureAddress: fn(
            self: *const IMFSignedLibrary,
            name: [*:0]const u8,
            address: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSignedLibrary_GetProcedureAddress(self: *const T, name: [*:0]const u8, address: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSignedLibrary.VTable, self.vtable).GetProcedureAddress(@ptrCast(*const IMFSignedLibrary, self), name, address);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSystemId_Value = @import("../zig.zig").Guid.initString("FFF4AF3A-1FC1-4EF9-A29B-D26C49E2F31A");
pub const IID_IMFSystemId = &IID_IMFSystemId_Value;
pub const IMFSystemId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: fn(
            self: *const IMFSystemId,
            size: *u32,
            data: **u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Setup: fn(
            self: *const IMFSystemId,
            stage: u32,
            cbIn: u32,
            pbIn: [*:0]const u8,
            pcbOut: *u32,
            ppbOut: **u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSystemId_GetData(self: *const T, size: *u32, data: **u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSystemId.VTable, self.vtable).GetData(@ptrCast(*const IMFSystemId, self), size, data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSystemId_Setup(self: *const T, stage: u32, cbIn: u32, pbIn: [*:0]const u8, pcbOut: *u32, ppbOut: **u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSystemId.VTable, self.vtable).Setup(@ptrCast(*const IMFSystemId, self), stage, cbIn, pbIn, pcbOut, ppbOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFCONTENTPROTECTIONDEVICE_INPUT_DATA = extern struct {
    HWProtectionFunctionID: u32,
    PrivateDataByteCount: u32,
    HWProtectionDataByteCount: u32,
    Reserved: u32,
    InputData: [4]u8,
};

pub const MFCONTENTPROTECTIONDEVICE_OUTPUT_DATA = extern struct {
    PrivateDataByteCount: u32,
    MaxHWProtectionDataByteCount: u32,
    HWProtectionDataByteCount: u32,
    Status: HRESULT,
    TransportTimeInHundredsOfNanoseconds: i64,
    ExecutionTimeInHundredsOfNanoseconds: i64,
    OutputData: [4]u8,
};

pub const MFCONTENTPROTECTIONDEVICE_REALTIMECLIENT_DATA = extern struct {
    TaskIndex: u32,
    ClassName: [260]u16,
    BasePriority: i32,
};

const IID_IMFContentProtectionDevice_Value = @import("../zig.zig").Guid.initString("E6257174-A060-4C9A-A088-3B1B471CAD28");
pub const IID_IMFContentProtectionDevice = &IID_IMFContentProtectionDevice_Value;
pub const IMFContentProtectionDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvokeFunction: fn(
            self: *const IMFContentProtectionDevice,
            FunctionId: u32,
            InputBufferByteCount: u32,
            InputBuffer: [*:0]const u8,
            OutputBufferByteCount: *u32,
            OutputBuffer: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateDataByteCount: fn(
            self: *const IMFContentProtectionDevice,
            PrivateInputByteCount: *u32,
            PrivateOutputByteCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentProtectionDevice_InvokeFunction(self: *const T, FunctionId: u32, InputBufferByteCount: u32, InputBuffer: [*:0]const u8, OutputBufferByteCount: *u32, OutputBuffer: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentProtectionDevice.VTable, self.vtable).InvokeFunction(@ptrCast(*const IMFContentProtectionDevice, self), FunctionId, InputBufferByteCount, InputBuffer, OutputBufferByteCount, OutputBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentProtectionDevice_GetPrivateDataByteCount(self: *const T, PrivateInputByteCount: *u32, PrivateOutputByteCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentProtectionDevice.VTable, self.vtable).GetPrivateDataByteCount(@ptrCast(*const IMFContentProtectionDevice, self), PrivateInputByteCount, PrivateOutputByteCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFContentDecryptorContext_Value = @import("../zig.zig").Guid.initString("7EC4B1BD-43FB-4763-85D2-64FCB5C5F4CB");
pub const IID_IMFContentDecryptorContext = &IID_IMFContentDecryptorContext_Value;
pub const IMFContentDecryptorContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeHardwareKey: fn(
            self: *const IMFContentDecryptorContext,
            InputPrivateDataByteCount: u32,
            InputPrivateData: ?[*]const u8,
            OutputPrivateData: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptorContext_InitializeHardwareKey(self: *const T, InputPrivateDataByteCount: u32, InputPrivateData: ?[*]const u8, OutputPrivateData: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptorContext.VTable, self.vtable).InitializeHardwareKey(@ptrCast(*const IMFContentDecryptorContext, self), InputPrivateDataByteCount, InputPrivateData, OutputPrivateData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIAKEYSESSION_TYPE = extern enum(i32) {
    TEMPORARY = 0,
    PERSISTENT_LICENSE = 1,
    PERSISTENT_RELEASE_MESSAGE = 2,
    PERSISTENT_USAGE_RECORD = 3,
};
pub const MF_MEDIAKEYSESSION_TYPE_TEMPORARY = MF_MEDIAKEYSESSION_TYPE.TEMPORARY;
pub const MF_MEDIAKEYSESSION_TYPE_PERSISTENT_LICENSE = MF_MEDIAKEYSESSION_TYPE.PERSISTENT_LICENSE;
pub const MF_MEDIAKEYSESSION_TYPE_PERSISTENT_RELEASE_MESSAGE = MF_MEDIAKEYSESSION_TYPE.PERSISTENT_RELEASE_MESSAGE;
pub const MF_MEDIAKEYSESSION_TYPE_PERSISTENT_USAGE_RECORD = MF_MEDIAKEYSESSION_TYPE.PERSISTENT_USAGE_RECORD;

pub const MF_MEDIAKEY_STATUS = extern enum(i32) {
    USABLE = 0,
    EXPIRED = 1,
    OUTPUT_DOWNSCALED = 2,
    OUTPUT_NOT_ALLOWED = 3,
    STATUS_PENDING = 4,
    INTERNAL_ERROR = 5,
    RELEASED = 6,
    OUTPUT_RESTRICTED = 7,
};
pub const MF_MEDIAKEY_STATUS_USABLE = MF_MEDIAKEY_STATUS.USABLE;
pub const MF_MEDIAKEY_STATUS_EXPIRED = MF_MEDIAKEY_STATUS.EXPIRED;
pub const MF_MEDIAKEY_STATUS_OUTPUT_DOWNSCALED = MF_MEDIAKEY_STATUS.OUTPUT_DOWNSCALED;
pub const MF_MEDIAKEY_STATUS_OUTPUT_NOT_ALLOWED = MF_MEDIAKEY_STATUS.OUTPUT_NOT_ALLOWED;
pub const MF_MEDIAKEY_STATUS_STATUS_PENDING = MF_MEDIAKEY_STATUS.STATUS_PENDING;
pub const MF_MEDIAKEY_STATUS_INTERNAL_ERROR = MF_MEDIAKEY_STATUS.INTERNAL_ERROR;
pub const MF_MEDIAKEY_STATUS_RELEASED = MF_MEDIAKEY_STATUS.RELEASED;
pub const MF_MEDIAKEY_STATUS_OUTPUT_RESTRICTED = MF_MEDIAKEY_STATUS.OUTPUT_RESTRICTED;

pub const MFMediaKeyStatus = extern struct {
    pbKeyId: *u8,
    cbKeyId: u32,
    eMediaKeyStatus: MF_MEDIAKEY_STATUS,
};

pub const MF_MEDIAKEYSESSION_MESSAGETYPE = extern enum(i32) {
    LICENSE_REQUEST = 0,
    LICENSE_RENEWAL = 1,
    LICENSE_RELEASE = 2,
    INDIVIDUALIZATION_REQUEST = 3,
};
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_REQUEST = MF_MEDIAKEYSESSION_MESSAGETYPE.LICENSE_REQUEST;
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RENEWAL = MF_MEDIAKEYSESSION_MESSAGETYPE.LICENSE_RENEWAL;
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_LICENSE_RELEASE = MF_MEDIAKEYSESSION_MESSAGETYPE.LICENSE_RELEASE;
pub const MF_MEDIAKEYSESSION_MESSAGETYPE_INDIVIDUALIZATION_REQUEST = MF_MEDIAKEYSESSION_MESSAGETYPE.INDIVIDUALIZATION_REQUEST;

pub const MF_CROSS_ORIGIN_POLICY = extern enum(i32) {
    NONE = 0,
    ANONYMOUS = 1,
    USE_CREDENTIALS = 2,
};
pub const MF_CROSS_ORIGIN_POLICY_NONE = MF_CROSS_ORIGIN_POLICY.NONE;
pub const MF_CROSS_ORIGIN_POLICY_ANONYMOUS = MF_CROSS_ORIGIN_POLICY.ANONYMOUS;
pub const MF_CROSS_ORIGIN_POLICY_USE_CREDENTIALS = MF_CROSS_ORIGIN_POLICY.USE_CREDENTIALS;

const IID_IMFNetCrossOriginSupport_Value = @import("../zig.zig").Guid.initString("BC2B7D44-A72D-49D5-8376-1480DEE58B22");
pub const IID_IMFNetCrossOriginSupport = &IID_IMFNetCrossOriginSupport_Value;
pub const IMFNetCrossOriginSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCrossOriginPolicy: fn(
            self: *const IMFNetCrossOriginSupport,
            pPolicy: *MF_CROSS_ORIGIN_POLICY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceOrigin: fn(
            self: *const IMFNetCrossOriginSupport,
            wszSourceOrigin: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSameOrigin: fn(
            self: *const IMFNetCrossOriginSupport,
            wszURL: [*:0]const u16,
            pfIsSameOrigin: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCrossOriginSupport_GetCrossOriginPolicy(self: *const T, pPolicy: *MF_CROSS_ORIGIN_POLICY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCrossOriginSupport.VTable, self.vtable).GetCrossOriginPolicy(@ptrCast(*const IMFNetCrossOriginSupport, self), pPolicy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCrossOriginSupport_GetSourceOrigin(self: *const T, wszSourceOrigin: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCrossOriginSupport.VTable, self.vtable).GetSourceOrigin(@ptrCast(*const IMFNetCrossOriginSupport, self), wszSourceOrigin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFNetCrossOriginSupport_IsSameOrigin(self: *const T, wszURL: [*:0]const u16, pfIsSameOrigin: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFNetCrossOriginSupport.VTable, self.vtable).IsSameOrigin(@ptrCast(*const IMFNetCrossOriginSupport, self), wszURL, pfIsSameOrigin);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFHttpDownloadRequest_Value = @import("../zig.zig").Guid.initString("F779FDDF-26E7-4270-8A8B-B983D1859DE0");
pub const IID_IMFHttpDownloadRequest = &IID_IMFHttpDownloadRequest_Value;
pub const IMFHttpDownloadRequest = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddHeader: fn(
            self: *const IMFHttpDownloadRequest,
            szHeader: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginSendRequest: fn(
            self: *const IMFHttpDownloadRequest,
            pbPayload: ?[*:0]const u8,
            cbPayload: u32,
            pCallback: *IMFAsyncCallback,
            punkState: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSendRequest: fn(
            self: *const IMFHttpDownloadRequest,
            pResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginReceiveResponse: fn(
            self: *const IMFHttpDownloadRequest,
            pCallback: *IMFAsyncCallback,
            punkState: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndReceiveResponse: fn(
            self: *const IMFHttpDownloadRequest,
            pResult: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginReadPayload: fn(
            self: *const IMFHttpDownloadRequest,
            pb: [*:0]u8,
            cb: u32,
            pCallback: *IMFAsyncCallback,
            punkState: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndReadPayload: fn(
            self: *const IMFHttpDownloadRequest,
            pResult: *IMFAsyncResult,
            pqwOffset: *u64,
            pcbRead: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHeader: fn(
            self: *const IMFHttpDownloadRequest,
            szHeaderName: [*:0]const u16,
            dwIndex: u32,
            ppszHeaderValue: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: fn(
            self: *const IMFHttpDownloadRequest,
            ppszURL: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasNullSourceOrigin: fn(
            self: *const IMFHttpDownloadRequest,
            pfNullSourceOrigin: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeSeekResult: fn(
            self: *const IMFHttpDownloadRequest,
            pqwStartTime: *u64,
            pqwStopTime: *u64,
            pqwDuration: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHttpStatus: fn(
            self: *const IMFHttpDownloadRequest,
            pdwHttpStatus: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAtEndOfPayload: fn(
            self: *const IMFHttpDownloadRequest,
            pfAtEndOfPayload: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalLength: fn(
            self: *const IMFHttpDownloadRequest,
            pqwTotalLength: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRangeEndOffset: fn(
            self: *const IMFHttpDownloadRequest,
            pqwRangeEnd: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IMFHttpDownloadRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_AddHeader(self: *const T, szHeader: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).AddHeader(@ptrCast(*const IMFHttpDownloadRequest, self), szHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_BeginSendRequest(self: *const T, pbPayload: ?[*:0]const u8, cbPayload: u32, pCallback: *IMFAsyncCallback, punkState: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).BeginSendRequest(@ptrCast(*const IMFHttpDownloadRequest, self), pbPayload, cbPayload, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_EndSendRequest(self: *const T, pResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).EndSendRequest(@ptrCast(*const IMFHttpDownloadRequest, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_BeginReceiveResponse(self: *const T, pCallback: *IMFAsyncCallback, punkState: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).BeginReceiveResponse(@ptrCast(*const IMFHttpDownloadRequest, self), pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_EndReceiveResponse(self: *const T, pResult: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).EndReceiveResponse(@ptrCast(*const IMFHttpDownloadRequest, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_BeginReadPayload(self: *const T, pb: [*:0]u8, cb: u32, pCallback: *IMFAsyncCallback, punkState: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).BeginReadPayload(@ptrCast(*const IMFHttpDownloadRequest, self), pb, cb, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_EndReadPayload(self: *const T, pResult: *IMFAsyncResult, pqwOffset: *u64, pcbRead: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).EndReadPayload(@ptrCast(*const IMFHttpDownloadRequest, self), pResult, pqwOffset, pcbRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_QueryHeader(self: *const T, szHeaderName: [*:0]const u16, dwIndex: u32, ppszHeaderValue: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).QueryHeader(@ptrCast(*const IMFHttpDownloadRequest, self), szHeaderName, dwIndex, ppszHeaderValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_GetURL(self: *const T, ppszURL: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).GetURL(@ptrCast(*const IMFHttpDownloadRequest, self), ppszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_HasNullSourceOrigin(self: *const T, pfNullSourceOrigin: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).HasNullSourceOrigin(@ptrCast(*const IMFHttpDownloadRequest, self), pfNullSourceOrigin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_GetTimeSeekResult(self: *const T, pqwStartTime: *u64, pqwStopTime: *u64, pqwDuration: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).GetTimeSeekResult(@ptrCast(*const IMFHttpDownloadRequest, self), pqwStartTime, pqwStopTime, pqwDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_GetHttpStatus(self: *const T, pdwHttpStatus: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).GetHttpStatus(@ptrCast(*const IMFHttpDownloadRequest, self), pdwHttpStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_GetAtEndOfPayload(self: *const T, pfAtEndOfPayload: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).GetAtEndOfPayload(@ptrCast(*const IMFHttpDownloadRequest, self), pfAtEndOfPayload);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_GetTotalLength(self: *const T, pqwTotalLength: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).GetTotalLength(@ptrCast(*const IMFHttpDownloadRequest, self), pqwTotalLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_GetRangeEndOffset(self: *const T, pqwRangeEnd: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).GetRangeEndOffset(@ptrCast(*const IMFHttpDownloadRequest, self), pqwRangeEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadRequest_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadRequest.VTable, self.vtable).Close(@ptrCast(*const IMFHttpDownloadRequest, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFHttpDownloadSession_Value = @import("../zig.zig").Guid.initString("71FA9A2C-53CE-4662-A132-1A7E8CBF62DB");
pub const IID_IMFHttpDownloadSession = &IID_IMFHttpDownloadSession_Value;
pub const IMFHttpDownloadSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetServer: fn(
            self: *const IMFHttpDownloadSession,
            szServerName: [*:0]const u16,
            nPort: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateRequest: fn(
            self: *const IMFHttpDownloadSession,
            szObjectName: [*:0]const u16,
            fBypassProxyCache: BOOL,
            fSecure: BOOL,
            szVerb: ?[*:0]const u16,
            szReferrer: ?[*:0]const u16,
            ppRequest: **IMFHttpDownloadRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IMFHttpDownloadSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadSession_SetServer(self: *const T, szServerName: [*:0]const u16, nPort: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadSession.VTable, self.vtable).SetServer(@ptrCast(*const IMFHttpDownloadSession, self), szServerName, nPort);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadSession_CreateRequest(self: *const T, szObjectName: [*:0]const u16, fBypassProxyCache: BOOL, fSecure: BOOL, szVerb: ?[*:0]const u16, szReferrer: ?[*:0]const u16, ppRequest: **IMFHttpDownloadRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadSession.VTable, self.vtable).CreateRequest(@ptrCast(*const IMFHttpDownloadSession, self), szObjectName, fBypassProxyCache, fSecure, szVerb, szReferrer, ppRequest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadSession_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadSession.VTable, self.vtable).Close(@ptrCast(*const IMFHttpDownloadSession, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFHttpDownloadSessionProvider_Value = @import("../zig.zig").Guid.initString("1B4CF4B9-3A16-4115-839D-03CC5C99DF01");
pub const IID_IMFHttpDownloadSessionProvider = &IID_IMFHttpDownloadSessionProvider_Value;
pub const IMFHttpDownloadSessionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateHttpDownloadSession: fn(
            self: *const IMFHttpDownloadSessionProvider,
            wszScheme: [*:0]const u16,
            ppDownloadSession: **IMFHttpDownloadSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHttpDownloadSessionProvider_CreateHttpDownloadSession(self: *const T, wszScheme: [*:0]const u16, ppDownloadSession: **IMFHttpDownloadSession) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHttpDownloadSessionProvider.VTable, self.vtable).CreateHttpDownloadSession(@ptrCast(*const IMFHttpDownloadSessionProvider, self), wszScheme, ppDownloadSession);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_VIDEO_SPHERICAL_VIEWDIRECTION = extern struct {
    iHeading: i32,
    iPitch: i32,
    iRoll: i32,
};

const IID_IMFMediaSource2_Value = @import("../zig.zig").Guid.initString("FBB03414-D13B-4786-8319-5AC51FC0A136");
pub const IID_IMFMediaSource2 = &IID_IMFMediaSource2_Value;
pub const IMFMediaSource2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaSourceEx.VTable,
        SetMediaType: fn(
            self: *const IMFMediaSource2,
            dwStreamID: u32,
            pMediaType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaSourceEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSource2_SetMediaType(self: *const T, dwStreamID: u32, pMediaType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSource2.VTable, self.vtable).SetMediaType(@ptrCast(*const IMFMediaSource2, self), dwStreamID, pMediaType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaStream2_Value = @import("../zig.zig").Guid.initString("C5BC37D6-75C7-46A1-A132-81B5F723C20F");
pub const IID_IMFMediaStream2 = &IID_IMFMediaStream2_Value;
pub const IMFMediaStream2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaStream.VTable,
        SetStreamState: fn(
            self: *const IMFMediaStream2,
            value: MF_STREAM_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamState: fn(
            self: *const IMFMediaStream2,
            value: *MF_STREAM_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaStream.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaStream2_SetStreamState(self: *const T, value: MF_STREAM_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaStream2.VTable, self.vtable).SetStreamState(@ptrCast(*const IMFMediaStream2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaStream2_GetStreamState(self: *const T, value: *MF_STREAM_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaStream2.VTable, self.vtable).GetStreamState(@ptrCast(*const IMFMediaStream2, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFSensorDeviceType = extern enum(i32) {
    Unknown = 0,
    Device = 1,
    MediaSource = 2,
    FrameProvider = 3,
    SensorTransform = 4,
};
pub const MFSensorDeviceType_Unknown = MFSensorDeviceType.Unknown;
pub const MFSensorDeviceType_Device = MFSensorDeviceType.Device;
pub const MFSensorDeviceType_MediaSource = MFSensorDeviceType.MediaSource;
pub const MFSensorDeviceType_FrameProvider = MFSensorDeviceType.FrameProvider;
pub const MFSensorDeviceType_SensorTransform = MFSensorDeviceType.SensorTransform;

pub const MFSensorStreamType = extern enum(i32) {
    Unknown = 0,
    Input = 1,
    Output = 2,
};
pub const MFSensorStreamType_Unknown = MFSensorStreamType.Unknown;
pub const MFSensorStreamType_Input = MFSensorStreamType.Input;
pub const MFSensorStreamType_Output = MFSensorStreamType.Output;

pub const MFSensorDeviceMode = extern enum(i32) {
    Controller = 0,
    Shared = 1,
};
pub const MFSensorDeviceMode_Controller = MFSensorDeviceMode.Controller;
pub const MFSensorDeviceMode_Shared = MFSensorDeviceMode.Shared;

const IID_IMFSensorDevice_Value = @import("../zig.zig").Guid.initString("FB9F48F2-2A18-4E28-9730-786F30F04DC4");
pub const IID_IMFSensorDevice = &IID_IMFSensorDevice_Value;
pub const IMFSensorDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeviceId: fn(
            self: *const IMFSensorDevice,
            pDeviceId: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceType: fn(
            self: *const IMFSensorDevice,
            pType: *MFSensorDeviceType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IMFSensorDevice,
            pFlags: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolicLink: fn(
            self: *const IMFSensorDevice,
            SymbolicLink: [*:0]u16,
            cchSymbolicLink: i32,
            pcchWritten: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceAttributes: fn(
            self: *const IMFSensorDevice,
            ppAttributes: ?*?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamAttributesCount: fn(
            self: *const IMFSensorDevice,
            eType: MFSensorStreamType,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamAttributes: fn(
            self: *const IMFSensorDevice,
            eType: MFSensorStreamType,
            dwIndex: u32,
            ppAttributes: **IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSensorDeviceMode: fn(
            self: *const IMFSensorDevice,
            eMode: MFSensorDeviceMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorDeviceMode: fn(
            self: *const IMFSensorDevice,
            peMode: *MFSensorDeviceMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorDevice_GetDeviceId(self: *const T, pDeviceId: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorDevice.VTable, self.vtable).GetDeviceId(@ptrCast(*const IMFSensorDevice, self), pDeviceId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorDevice_GetDeviceType(self: *const T, pType: *MFSensorDeviceType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorDevice.VTable, self.vtable).GetDeviceType(@ptrCast(*const IMFSensorDevice, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorDevice_GetFlags(self: *const T, pFlags: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorDevice.VTable, self.vtable).GetFlags(@ptrCast(*const IMFSensorDevice, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorDevice_GetSymbolicLink(self: *const T, SymbolicLink: [*:0]u16, cchSymbolicLink: i32, pcchWritten: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorDevice.VTable, self.vtable).GetSymbolicLink(@ptrCast(*const IMFSensorDevice, self), SymbolicLink, cchSymbolicLink, pcchWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorDevice_GetDeviceAttributes(self: *const T, ppAttributes: ?*?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorDevice.VTable, self.vtable).GetDeviceAttributes(@ptrCast(*const IMFSensorDevice, self), ppAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorDevice_GetStreamAttributesCount(self: *const T, eType: MFSensorStreamType, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorDevice.VTable, self.vtable).GetStreamAttributesCount(@ptrCast(*const IMFSensorDevice, self), eType, pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorDevice_GetStreamAttributes(self: *const T, eType: MFSensorStreamType, dwIndex: u32, ppAttributes: **IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorDevice.VTable, self.vtable).GetStreamAttributes(@ptrCast(*const IMFSensorDevice, self), eType, dwIndex, ppAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorDevice_SetSensorDeviceMode(self: *const T, eMode: MFSensorDeviceMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorDevice.VTable, self.vtable).SetSensorDeviceMode(@ptrCast(*const IMFSensorDevice, self), eMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorDevice_GetSensorDeviceMode(self: *const T, peMode: *MFSensorDeviceMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorDevice.VTable, self.vtable).GetSensorDeviceMode(@ptrCast(*const IMFSensorDevice, self), peMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSensorGroup_Value = @import("../zig.zig").Guid.initString("4110243A-9757-461F-89F1-F22345BCAB4E");
pub const IID_IMFSensorGroup = &IID_IMFSensorGroup_Value;
pub const IMFSensorGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolicLink: fn(
            self: *const IMFSensorGroup,
            SymbolicLink: [*:0]u16,
            cchSymbolicLink: i32,
            pcchWritten: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IMFSensorGroup,
            pFlags: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorGroupAttributes: fn(
            self: *const IMFSensorGroup,
            ppAttributes: ?*?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorDeviceCount: fn(
            self: *const IMFSensorGroup,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorDevice: fn(
            self: *const IMFSensorGroup,
            dwIndex: u32,
            ppDevice: **IMFSensorDevice,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultSensorDeviceIndex: fn(
            self: *const IMFSensorGroup,
            dwIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultSensorDeviceIndex: fn(
            self: *const IMFSensorGroup,
            pdwIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMediaSource: fn(
            self: *const IMFSensorGroup,
            ppSource: **IMFMediaSource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorGroup_GetSymbolicLink(self: *const T, SymbolicLink: [*:0]u16, cchSymbolicLink: i32, pcchWritten: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorGroup.VTable, self.vtable).GetSymbolicLink(@ptrCast(*const IMFSensorGroup, self), SymbolicLink, cchSymbolicLink, pcchWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorGroup_GetFlags(self: *const T, pFlags: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorGroup.VTable, self.vtable).GetFlags(@ptrCast(*const IMFSensorGroup, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorGroup_GetSensorGroupAttributes(self: *const T, ppAttributes: ?*?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorGroup.VTable, self.vtable).GetSensorGroupAttributes(@ptrCast(*const IMFSensorGroup, self), ppAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorGroup_GetSensorDeviceCount(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorGroup.VTable, self.vtable).GetSensorDeviceCount(@ptrCast(*const IMFSensorGroup, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorGroup_GetSensorDevice(self: *const T, dwIndex: u32, ppDevice: **IMFSensorDevice) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorGroup.VTable, self.vtable).GetSensorDevice(@ptrCast(*const IMFSensorGroup, self), dwIndex, ppDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorGroup_SetDefaultSensorDeviceIndex(self: *const T, dwIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorGroup.VTable, self.vtable).SetDefaultSensorDeviceIndex(@ptrCast(*const IMFSensorGroup, self), dwIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorGroup_GetDefaultSensorDeviceIndex(self: *const T, pdwIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorGroup.VTable, self.vtable).GetDefaultSensorDeviceIndex(@ptrCast(*const IMFSensorGroup, self), pdwIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorGroup_CreateMediaSource(self: *const T, ppSource: **IMFMediaSource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorGroup.VTable, self.vtable).CreateMediaSource(@ptrCast(*const IMFSensorGroup, self), ppSource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSensorStream_Value = @import("../zig.zig").Guid.initString("E9A42171-C56E-498A-8B39-EDA5A070B7FC");
pub const IID_IMFSensorStream = &IID_IMFSensorStream_Value;
pub const IMFSensorStream = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetMediaTypeCount: fn(
            self: *const IMFSensorStream,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaType: fn(
            self: *const IMFSensorStream,
            dwIndex: u32,
            ppMediaType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloneSensorStream: fn(
            self: *const IMFSensorStream,
            ppStream: **IMFSensorStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorStream_GetMediaTypeCount(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorStream.VTable, self.vtable).GetMediaTypeCount(@ptrCast(*const IMFSensorStream, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorStream_GetMediaType(self: *const T, dwIndex: u32, ppMediaType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorStream.VTable, self.vtable).GetMediaType(@ptrCast(*const IMFSensorStream, self), dwIndex, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorStream_CloneSensorStream(self: *const T, ppStream: **IMFSensorStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorStream.VTable, self.vtable).CloneSensorStream(@ptrCast(*const IMFSensorStream, self), ppStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSensorTransformFactory_Value = @import("../zig.zig").Guid.initString("EED9C2EE-66B4-4F18-A697-AC7D3960215C");
pub const IID_IMFSensorTransformFactory = &IID_IMFSensorTransformFactory_Value;
pub const IMFSensorTransformFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFactoryAttributes: fn(
            self: *const IMFSensorTransformFactory,
            ppAttributes: **IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeFactory: fn(
            self: *const IMFSensorTransformFactory,
            dwMaxTransformCount: u32,
            pSensorDevices: *IMFCollection,
            pAttributes: ?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransformCount: fn(
            self: *const IMFSensorTransformFactory,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransformInformation: fn(
            self: *const IMFSensorTransformFactory,
            TransformIndex: u32,
            pguidTransformId: *Guid,
            ppAttributes: ?*?*IMFAttributes,
            ppStreamInformation: **IMFCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTransform: fn(
            self: *const IMFSensorTransformFactory,
            guidSensorTransformID: *const Guid,
            pAttributes: ?*IMFAttributes,
            ppDeviceMFT: **IMFDeviceTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorTransformFactory_GetFactoryAttributes(self: *const T, ppAttributes: **IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorTransformFactory.VTable, self.vtable).GetFactoryAttributes(@ptrCast(*const IMFSensorTransformFactory, self), ppAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorTransformFactory_InitializeFactory(self: *const T, dwMaxTransformCount: u32, pSensorDevices: *IMFCollection, pAttributes: ?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorTransformFactory.VTable, self.vtable).InitializeFactory(@ptrCast(*const IMFSensorTransformFactory, self), dwMaxTransformCount, pSensorDevices, pAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorTransformFactory_GetTransformCount(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorTransformFactory.VTable, self.vtable).GetTransformCount(@ptrCast(*const IMFSensorTransformFactory, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorTransformFactory_GetTransformInformation(self: *const T, TransformIndex: u32, pguidTransformId: *Guid, ppAttributes: ?*?*IMFAttributes, ppStreamInformation: **IMFCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorTransformFactory.VTable, self.vtable).GetTransformInformation(@ptrCast(*const IMFSensorTransformFactory, self), TransformIndex, pguidTransformId, ppAttributes, ppStreamInformation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorTransformFactory_CreateTransform(self: *const T, guidSensorTransformID: *const Guid, pAttributes: ?*IMFAttributes, ppDeviceMFT: **IMFDeviceTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorTransformFactory.VTable, self.vtable).CreateTransform(@ptrCast(*const IMFSensorTransformFactory, self), guidSensorTransformID, pAttributes, ppDeviceMFT);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SENSORPROFILEID = extern struct {
    Type: Guid,
    Index: u32,
    Unused: u32,
};

const IID_IMFSensorProfile_Value = @import("../zig.zig").Guid.initString("22F765D1-8DAB-4107-846D-56BAF72215E7");
pub const IID_IMFSensorProfile = &IID_IMFSensorProfile_Value;
pub const IMFSensorProfile = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProfileId: fn(
            self: *const IMFSensorProfile,
            pId: *SENSORPROFILEID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProfileFilter: fn(
            self: *const IMFSensorProfile,
            StreamId: u32,
            wzFilterSetString: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMediaTypeSupported: fn(
            self: *const IMFSensorProfile,
            StreamId: u32,
            pMediaType: *IMFMediaType,
            pfSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBlockedControl: fn(
            self: *const IMFSensorProfile,
            wzBlockedControl: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfile_GetProfileId(self: *const T, pId: *SENSORPROFILEID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProfile.VTable, self.vtable).GetProfileId(@ptrCast(*const IMFSensorProfile, self), pId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfile_AddProfileFilter(self: *const T, StreamId: u32, wzFilterSetString: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProfile.VTable, self.vtable).AddProfileFilter(@ptrCast(*const IMFSensorProfile, self), StreamId, wzFilterSetString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfile_IsMediaTypeSupported(self: *const T, StreamId: u32, pMediaType: *IMFMediaType, pfSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProfile.VTable, self.vtable).IsMediaTypeSupported(@ptrCast(*const IMFSensorProfile, self), StreamId, pMediaType, pfSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfile_AddBlockedControl(self: *const T, wzBlockedControl: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProfile.VTable, self.vtable).AddBlockedControl(@ptrCast(*const IMFSensorProfile, self), wzBlockedControl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSensorProfileCollection_Value = @import("../zig.zig").Guid.initString("C95EA55B-0187-48BE-9353-8D2507662351");
pub const IID_IMFSensorProfileCollection = &IID_IMFSensorProfileCollection_Value;
pub const IMFSensorProfileCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProfileCount: fn(
            self: *const IMFSensorProfileCollection,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetProfile: fn(
            self: *const IMFSensorProfileCollection,
            Index: u32,
            ppProfile: **IMFSensorProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProfile: fn(
            self: *const IMFSensorProfileCollection,
            pProfile: *IMFSensorProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindProfile: fn(
            self: *const IMFSensorProfileCollection,
            ProfileId: *SENSORPROFILEID,
            ppProfile: **IMFSensorProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProfileByIndex: fn(
            self: *const IMFSensorProfileCollection,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        RemoveProfile: fn(
            self: *const IMFSensorProfileCollection,
            ProfileId: *SENSORPROFILEID,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfileCollection_GetProfileCount(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFSensorProfileCollection.VTable, self.vtable).GetProfileCount(@ptrCast(*const IMFSensorProfileCollection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfileCollection_GetProfile(self: *const T, Index: u32, ppProfile: **IMFSensorProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProfileCollection.VTable, self.vtable).GetProfile(@ptrCast(*const IMFSensorProfileCollection, self), Index, ppProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfileCollection_AddProfile(self: *const T, pProfile: *IMFSensorProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProfileCollection.VTable, self.vtable).AddProfile(@ptrCast(*const IMFSensorProfileCollection, self), pProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfileCollection_FindProfile(self: *const T, ProfileId: *SENSORPROFILEID, ppProfile: **IMFSensorProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProfileCollection.VTable, self.vtable).FindProfile(@ptrCast(*const IMFSensorProfileCollection, self), ProfileId, ppProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfileCollection_RemoveProfileByIndex(self: *const T, Index: u32) callconv(.Inline) void {
            return @ptrCast(*const IMFSensorProfileCollection.VTable, self.vtable).RemoveProfileByIndex(@ptrCast(*const IMFSensorProfileCollection, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProfileCollection_RemoveProfile(self: *const T, ProfileId: *SENSORPROFILEID) callconv(.Inline) void {
            return @ptrCast(*const IMFSensorProfileCollection.VTable, self.vtable).RemoveProfile(@ptrCast(*const IMFSensorProfileCollection, self), ProfileId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSensorProcessActivity_Value = @import("../zig.zig").Guid.initString("39DC7F4A-B141-4719-813C-A7F46162A2B8");
pub const IID_IMFSensorProcessActivity = &IID_IMFSensorProcessActivity_Value;
pub const IMFSensorProcessActivity = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProcessId: fn(
            self: *const IMFSensorProcessActivity,
            pPID: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamingState: fn(
            self: *const IMFSensorProcessActivity,
            pfStreaming: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamingMode: fn(
            self: *const IMFSensorProcessActivity,
            pMode: *MFSensorDeviceMode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReportTime: fn(
            self: *const IMFSensorProcessActivity,
            pft: *FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProcessActivity_GetProcessId(self: *const T, pPID: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProcessActivity.VTable, self.vtable).GetProcessId(@ptrCast(*const IMFSensorProcessActivity, self), pPID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProcessActivity_GetStreamingState(self: *const T, pfStreaming: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProcessActivity.VTable, self.vtable).GetStreamingState(@ptrCast(*const IMFSensorProcessActivity, self), pfStreaming);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProcessActivity_GetStreamingMode(self: *const T, pMode: *MFSensorDeviceMode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProcessActivity.VTable, self.vtable).GetStreamingMode(@ptrCast(*const IMFSensorProcessActivity, self), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorProcessActivity_GetReportTime(self: *const T, pft: *FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorProcessActivity.VTable, self.vtable).GetReportTime(@ptrCast(*const IMFSensorProcessActivity, self), pft);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSensorActivityReport_Value = @import("../zig.zig").Guid.initString("3E8C4BE1-A8C2-4528-90DE-2851BDE5FEAD");
pub const IID_IMFSensorActivityReport = &IID_IMFSensorActivityReport_Value;
pub const IMFSensorActivityReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFriendlyName: fn(
            self: *const IMFSensorActivityReport,
            FriendlyName: [*:0]u16,
            cchFriendlyName: u32,
            pcchWritten: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolicLink: fn(
            self: *const IMFSensorActivityReport,
            SymbolicLink: [*:0]u16,
            cchSymbolicLink: u32,
            pcchWritten: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessCount: fn(
            self: *const IMFSensorActivityReport,
            pcCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessActivity: fn(
            self: *const IMFSensorActivityReport,
            Index: u32,
            ppProcessActivity: **IMFSensorProcessActivity,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivityReport_GetFriendlyName(self: *const T, FriendlyName: [*:0]u16, cchFriendlyName: u32, pcchWritten: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivityReport.VTable, self.vtable).GetFriendlyName(@ptrCast(*const IMFSensorActivityReport, self), FriendlyName, cchFriendlyName, pcchWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivityReport_GetSymbolicLink(self: *const T, SymbolicLink: [*:0]u16, cchSymbolicLink: u32, pcchWritten: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivityReport.VTable, self.vtable).GetSymbolicLink(@ptrCast(*const IMFSensorActivityReport, self), SymbolicLink, cchSymbolicLink, pcchWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivityReport_GetProcessCount(self: *const T, pcCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivityReport.VTable, self.vtable).GetProcessCount(@ptrCast(*const IMFSensorActivityReport, self), pcCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivityReport_GetProcessActivity(self: *const T, Index: u32, ppProcessActivity: **IMFSensorProcessActivity) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivityReport.VTable, self.vtable).GetProcessActivity(@ptrCast(*const IMFSensorActivityReport, self), Index, ppProcessActivity);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSensorActivitiesReport_Value = @import("../zig.zig").Guid.initString("683F7A5E-4A19-43CD-B1A9-DBF4AB3F7777");
pub const IID_IMFSensorActivitiesReport = &IID_IMFSensorActivitiesReport_Value;
pub const IMFSensorActivitiesReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IMFSensorActivitiesReport,
            pcCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActivityReport: fn(
            self: *const IMFSensorActivitiesReport,
            Index: u32,
            sensorActivityReport: **IMFSensorActivityReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActivityReportByDeviceName: fn(
            self: *const IMFSensorActivitiesReport,
            SymbolicName: [*:0]const u16,
            sensorActivityReport: **IMFSensorActivityReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivitiesReport_GetCount(self: *const T, pcCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivitiesReport.VTable, self.vtable).GetCount(@ptrCast(*const IMFSensorActivitiesReport, self), pcCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivitiesReport_GetActivityReport(self: *const T, Index: u32, sensorActivityReport: **IMFSensorActivityReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivitiesReport.VTable, self.vtable).GetActivityReport(@ptrCast(*const IMFSensorActivitiesReport, self), Index, sensorActivityReport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivitiesReport_GetActivityReportByDeviceName(self: *const T, SymbolicName: [*:0]const u16, sensorActivityReport: **IMFSensorActivityReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivitiesReport.VTable, self.vtable).GetActivityReportByDeviceName(@ptrCast(*const IMFSensorActivitiesReport, self), SymbolicName, sensorActivityReport);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSensorActivitiesReportCallback_Value = @import("../zig.zig").Guid.initString("DE5072EE-DBE3-46DC-8A87-B6F631194751");
pub const IID_IMFSensorActivitiesReportCallback = &IID_IMFSensorActivitiesReportCallback_Value;
pub const IMFSensorActivitiesReportCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnActivitiesReport: fn(
            self: *const IMFSensorActivitiesReportCallback,
            sensorActivitiesReport: *IMFSensorActivitiesReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivitiesReportCallback_OnActivitiesReport(self: *const T, sensorActivitiesReport: *IMFSensorActivitiesReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivitiesReportCallback.VTable, self.vtable).OnActivitiesReport(@ptrCast(*const IMFSensorActivitiesReportCallback, self), sensorActivitiesReport);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSensorActivityMonitor_Value = @import("../zig.zig").Guid.initString("D0CEF145-B3F4-4340-A2E5-7A5080CA05CB");
pub const IID_IMFSensorActivityMonitor = &IID_IMFSensorActivityMonitor_Value;
pub const IMFSensorActivityMonitor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const IMFSensorActivityMonitor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IMFSensorActivityMonitor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivityMonitor_Start(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivityMonitor.VTable, self.vtable).Start(@ptrCast(*const IMFSensorActivityMonitor, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSensorActivityMonitor_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSensorActivityMonitor.VTable, self.vtable).Stop(@ptrCast(*const IMFSensorActivityMonitor, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFCameraIntrinsic_CameraModel = extern struct {
    FocalLength_x: f32,
    FocalLength_y: f32,
    PrincipalPoint_x: f32,
    PrincipalPoint_y: f32,
};

pub const MFCameraIntrinsic_DistortionModel6KT = extern struct {
    Radial_k1: f32,
    Radial_k2: f32,
    Radial_k3: f32,
    Radial_k4: f32,
    Radial_k5: f32,
    Radial_k6: f32,
    Tangential_p1: f32,
    Tangential_p2: f32,
};

pub const MFCameraIntrinsic_DistortionModelArcTan = extern struct {
    Radial_k0: f32,
    DistortionCenter_x: f32,
    DistortionCenter_y: f32,
    Tangential_x: f32,
    Tangential_y: f32,
};

pub const MFCameraIntrinsic_DistortionModelType = extern enum(i32) {
    _6KT = 0,
    ArcTan = 1,
};
pub const MFCameraIntrinsic_DistortionModelType_6KT = MFCameraIntrinsic_DistortionModelType._6KT;
pub const MFCameraIntrinsic_DistortionModelType_ArcTan = MFCameraIntrinsic_DistortionModelType.ArcTan;

pub const MFExtendedCameraIntrinsic_IntrinsicModel = extern struct {
    Width: u32,
    Height: u32,
    SplitFrameId: u32,
    CameraModel: MFCameraIntrinsic_CameraModel,
};

const IID_IMFExtendedCameraIntrinsicModel_Value = @import("../zig.zig").Guid.initString("5C595E64-4630-4231-855A-12842F733245");
pub const IID_IMFExtendedCameraIntrinsicModel = &IID_IMFExtendedCameraIntrinsicModel_Value;
pub const IMFExtendedCameraIntrinsicModel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetModel: fn(
            self: *const IMFExtendedCameraIntrinsicModel,
            pIntrinsicModel: *MFExtendedCameraIntrinsic_IntrinsicModel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModel: fn(
            self: *const IMFExtendedCameraIntrinsicModel,
            pIntrinsicModel: *const MFExtendedCameraIntrinsic_IntrinsicModel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDistortionModelType: fn(
            self: *const IMFExtendedCameraIntrinsicModel,
            pDistortionModelType: *MFCameraIntrinsic_DistortionModelType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsicModel_GetModel(self: *const T, pIntrinsicModel: *MFExtendedCameraIntrinsic_IntrinsicModel) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsicModel.VTable, self.vtable).GetModel(@ptrCast(*const IMFExtendedCameraIntrinsicModel, self), pIntrinsicModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsicModel_SetModel(self: *const T, pIntrinsicModel: *const MFExtendedCameraIntrinsic_IntrinsicModel) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsicModel.VTable, self.vtable).SetModel(@ptrCast(*const IMFExtendedCameraIntrinsicModel, self), pIntrinsicModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsicModel_GetDistortionModelType(self: *const T, pDistortionModelType: *MFCameraIntrinsic_DistortionModelType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsicModel.VTable, self.vtable).GetDistortionModelType(@ptrCast(*const IMFExtendedCameraIntrinsicModel, self), pDistortionModelType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraIntrinsicsDistortionModel6KT_Value = @import("../zig.zig").Guid.initString("74C2653B-5F55-4EB1-9F0F-18B8F68B7D3D");
pub const IID_IMFExtendedCameraIntrinsicsDistortionModel6KT = &IID_IMFExtendedCameraIntrinsicsDistortionModel6KT_Value;
pub const IMFExtendedCameraIntrinsicsDistortionModel6KT = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDistortionModel: fn(
            self: *const IMFExtendedCameraIntrinsicsDistortionModel6KT,
            pDistortionModel: *MFCameraIntrinsic_DistortionModel6KT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDistortionModel: fn(
            self: *const IMFExtendedCameraIntrinsicsDistortionModel6KT,
            pDistortionModel: *const MFCameraIntrinsic_DistortionModel6KT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsicsDistortionModel6KT_GetDistortionModel(self: *const T, pDistortionModel: *MFCameraIntrinsic_DistortionModel6KT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsicsDistortionModel6KT.VTable, self.vtable).GetDistortionModel(@ptrCast(*const IMFExtendedCameraIntrinsicsDistortionModel6KT, self), pDistortionModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsicsDistortionModel6KT_SetDistortionModel(self: *const T, pDistortionModel: *const MFCameraIntrinsic_DistortionModel6KT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsicsDistortionModel6KT.VTable, self.vtable).SetDistortionModel(@ptrCast(*const IMFExtendedCameraIntrinsicsDistortionModel6KT, self), pDistortionModel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraIntrinsicsDistortionModelArcTan_Value = @import("../zig.zig").Guid.initString("812D5F95-B572-45DC-BAFC-AE24199DDDA8");
pub const IID_IMFExtendedCameraIntrinsicsDistortionModelArcTan = &IID_IMFExtendedCameraIntrinsicsDistortionModelArcTan_Value;
pub const IMFExtendedCameraIntrinsicsDistortionModelArcTan = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDistortionModel: fn(
            self: *const IMFExtendedCameraIntrinsicsDistortionModelArcTan,
            pDistortionModel: *MFCameraIntrinsic_DistortionModelArcTan,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDistortionModel: fn(
            self: *const IMFExtendedCameraIntrinsicsDistortionModelArcTan,
            pDistortionModel: *const MFCameraIntrinsic_DistortionModelArcTan,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsicsDistortionModelArcTan_GetDistortionModel(self: *const T, pDistortionModel: *MFCameraIntrinsic_DistortionModelArcTan) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsicsDistortionModelArcTan.VTable, self.vtable).GetDistortionModel(@ptrCast(*const IMFExtendedCameraIntrinsicsDistortionModelArcTan, self), pDistortionModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsicsDistortionModelArcTan_SetDistortionModel(self: *const T, pDistortionModel: *const MFCameraIntrinsic_DistortionModelArcTan) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsicsDistortionModelArcTan.VTable, self.vtable).SetDistortionModel(@ptrCast(*const IMFExtendedCameraIntrinsicsDistortionModelArcTan, self), pDistortionModel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraIntrinsics_Value = @import("../zig.zig").Guid.initString("687F6DAC-6987-4750-A16A-734D1E7A10FE");
pub const IID_IMFExtendedCameraIntrinsics = &IID_IMFExtendedCameraIntrinsics_Value;
pub const IMFExtendedCameraIntrinsics = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeFromBuffer: fn(
            self: *const IMFExtendedCameraIntrinsics,
            pbBuffer: [*:0]u8,
            dwBufferSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBufferSize: fn(
            self: *const IMFExtendedCameraIntrinsics,
            pdwBufferSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SerializeToBuffer: fn(
            self: *const IMFExtendedCameraIntrinsics,
            pbBuffer: [*:0]u8,
            pdwBufferSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIntrinsicModelCount: fn(
            self: *const IMFExtendedCameraIntrinsics,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIntrinsicModelByIndex: fn(
            self: *const IMFExtendedCameraIntrinsics,
            dwIndex: u32,
            ppIntrinsicModel: **IMFExtendedCameraIntrinsicModel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddIntrinsicModel: fn(
            self: *const IMFExtendedCameraIntrinsics,
            pIntrinsicModel: *IMFExtendedCameraIntrinsicModel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsics_InitializeFromBuffer(self: *const T, pbBuffer: [*:0]u8, dwBufferSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsics.VTable, self.vtable).InitializeFromBuffer(@ptrCast(*const IMFExtendedCameraIntrinsics, self), pbBuffer, dwBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsics_GetBufferSize(self: *const T, pdwBufferSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsics.VTable, self.vtable).GetBufferSize(@ptrCast(*const IMFExtendedCameraIntrinsics, self), pdwBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsics_SerializeToBuffer(self: *const T, pbBuffer: [*:0]u8, pdwBufferSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsics.VTable, self.vtable).SerializeToBuffer(@ptrCast(*const IMFExtendedCameraIntrinsics, self), pbBuffer, pdwBufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsics_GetIntrinsicModelCount(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsics.VTable, self.vtable).GetIntrinsicModelCount(@ptrCast(*const IMFExtendedCameraIntrinsics, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsics_GetIntrinsicModelByIndex(self: *const T, dwIndex: u32, ppIntrinsicModel: **IMFExtendedCameraIntrinsicModel) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsics.VTable, self.vtable).GetIntrinsicModelByIndex(@ptrCast(*const IMFExtendedCameraIntrinsics, self), dwIndex, ppIntrinsicModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraIntrinsics_AddIntrinsicModel(self: *const T, pIntrinsicModel: *IMFExtendedCameraIntrinsicModel) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraIntrinsics.VTable, self.vtable).AddIntrinsicModel(@ptrCast(*const IMFExtendedCameraIntrinsics, self), pIntrinsicModel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraControl_Value = @import("../zig.zig").Guid.initString("38E33520-FCA1-4845-A27A-68B7C6AB3789");
pub const IID_IMFExtendedCameraControl = &IID_IMFExtendedCameraControl_Value;
pub const IMFExtendedCameraControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCapabilities: fn(
            self: *const IMFExtendedCameraControl,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        SetFlags: fn(
            self: *const IMFExtendedCameraControl,
            ulFlags: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IMFExtendedCameraControl,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        LockPayload: fn(
            self: *const IMFExtendedCameraControl,
            ppPayload: **u8,
            pulPayload: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnlockPayload: fn(
            self: *const IMFExtendedCameraControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitSettings: fn(
            self: *const IMFExtendedCameraControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraControl_GetCapabilities(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const IMFExtendedCameraControl.VTable, self.vtable).GetCapabilities(@ptrCast(*const IMFExtendedCameraControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraControl_SetFlags(self: *const T, ulFlags: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraControl.VTable, self.vtable).SetFlags(@ptrCast(*const IMFExtendedCameraControl, self), ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraControl_GetFlags(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const IMFExtendedCameraControl.VTable, self.vtable).GetFlags(@ptrCast(*const IMFExtendedCameraControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraControl_LockPayload(self: *const T, ppPayload: **u8, pulPayload: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraControl.VTable, self.vtable).LockPayload(@ptrCast(*const IMFExtendedCameraControl, self), ppPayload, pulPayload);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraControl_UnlockPayload(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraControl.VTable, self.vtable).UnlockPayload(@ptrCast(*const IMFExtendedCameraControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraControl_CommitSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraControl.VTable, self.vtable).CommitSettings(@ptrCast(*const IMFExtendedCameraControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedCameraController_Value = @import("../zig.zig").Guid.initString("B91EBFEE-CA03-4AF4-8A82-A31752F4A0FC");
pub const IID_IMFExtendedCameraController = &IID_IMFExtendedCameraController_Value;
pub const IMFExtendedCameraController = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetExtendedCameraControl: fn(
            self: *const IMFExtendedCameraController,
            dwStreamIndex: u32,
            ulPropertyId: u32,
            ppControl: **IMFExtendedCameraControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedCameraController_GetExtendedCameraControl(self: *const T, dwStreamIndex: u32, ulPropertyId: u32, ppControl: **IMFExtendedCameraControl) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedCameraController.VTable, self.vtable).GetExtendedCameraControl(@ptrCast(*const IMFExtendedCameraController, self), dwStreamIndex, ulPropertyId, ppControl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFRelativePanelReport_Value = @import("../zig.zig").Guid.initString("F25362EA-2C0E-447F-81E2-755914CDC0C3");
pub const IID_IMFRelativePanelReport = &IID_IMFRelativePanelReport_Value;
pub const IMFRelativePanelReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRelativePanel: fn(
            self: *const IMFRelativePanelReport,
            panel: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRelativePanelReport_GetRelativePanel(self: *const T, panel: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRelativePanelReport.VTable, self.vtable).GetRelativePanel(@ptrCast(*const IMFRelativePanelReport, self), panel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFRelativePanelWatcher_Value = @import("../zig.zig").Guid.initString("421AF7F6-573E-4AD0-8FDA-2E57CEDB18C6");
pub const IID_IMFRelativePanelWatcher = &IID_IMFRelativePanelWatcher_Value;
pub const IMFRelativePanelWatcher = extern struct {
    pub const VTable = extern struct {
        base: IMFShutdown.VTable,
        BeginGetReport: fn(
            self: *const IMFRelativePanelWatcher,
            pCallback: *IMFAsyncCallback,
            pState: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndGetReport: fn(
            self: *const IMFRelativePanelWatcher,
            pResult: *IMFAsyncResult,
            ppRelativePanelReport: **IMFRelativePanelReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReport: fn(
            self: *const IMFRelativePanelWatcher,
            ppRelativePanelReport: **IMFRelativePanelReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFShutdown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRelativePanelWatcher_BeginGetReport(self: *const T, pCallback: *IMFAsyncCallback, pState: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRelativePanelWatcher.VTable, self.vtable).BeginGetReport(@ptrCast(*const IMFRelativePanelWatcher, self), pCallback, pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRelativePanelWatcher_EndGetReport(self: *const T, pResult: *IMFAsyncResult, ppRelativePanelReport: **IMFRelativePanelReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRelativePanelWatcher.VTable, self.vtable).EndGetReport(@ptrCast(*const IMFRelativePanelWatcher, self), pResult, ppRelativePanelReport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFRelativePanelWatcher_GetReport(self: *const T, ppRelativePanelReport: **IMFRelativePanelReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFRelativePanelWatcher.VTable, self.vtable).GetReport(@ptrCast(*const IMFRelativePanelWatcher, self), ppRelativePanelReport);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoCaptureSampleAllocator_Value = @import("../zig.zig").Guid.initString("725B77C7-CA9F-4FE5-9D72-9946BF9B3C70");
pub const IID_IMFVideoCaptureSampleAllocator = &IID_IMFVideoCaptureSampleAllocator_Value;
pub const IMFVideoCaptureSampleAllocator = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoSampleAllocator.VTable,
        InitializeCaptureSampleAllocator: fn(
            self: *const IMFVideoCaptureSampleAllocator,
            cbSampleSize: u32,
            cbCaptureMetadataSize: u32,
            cbAlignment: u32,
            cMinimumSamples: u32,
            pAttributes: ?*IMFAttributes,
            pMediaType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFVideoSampleAllocator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoCaptureSampleAllocator_InitializeCaptureSampleAllocator(self: *const T, cbSampleSize: u32, cbCaptureMetadataSize: u32, cbAlignment: u32, cMinimumSamples: u32, pAttributes: ?*IMFAttributes, pMediaType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoCaptureSampleAllocator.VTable, self.vtable).InitializeCaptureSampleAllocator(@ptrCast(*const IMFVideoCaptureSampleAllocator, self), cbSampleSize, cbCaptureMetadataSize, cbAlignment, cMinimumSamples, pAttributes, pMediaType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFSampleAllocatorUsage = extern enum(i32) {
    UsesProvidedAllocator = 0,
    UsesCustomAllocator = 1,
    DoesNotAllocate = 2,
};
pub const MFSampleAllocatorUsage_UsesProvidedAllocator = MFSampleAllocatorUsage.UsesProvidedAllocator;
pub const MFSampleAllocatorUsage_UsesCustomAllocator = MFSampleAllocatorUsage.UsesCustomAllocator;
pub const MFSampleAllocatorUsage_DoesNotAllocate = MFSampleAllocatorUsage.DoesNotAllocate;

const IID_IMFSampleAllocatorControl_Value = @import("../zig.zig").Guid.initString("DA62B958-3A38-4A97-BD27-149C640C0771");
pub const IID_IMFSampleAllocatorControl = &IID_IMFSampleAllocatorControl_Value;
pub const IMFSampleAllocatorControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDefaultAllocator: fn(
            self: *const IMFSampleAllocatorControl,
            dwOutputStreamID: u32,
            pAllocator: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllocatorUsage: fn(
            self: *const IMFSampleAllocatorControl,
            dwOutputStreamID: u32,
            pdwInputStreamID: *u32,
            peUsage: *MFSampleAllocatorUsage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleAllocatorControl_SetDefaultAllocator(self: *const T, dwOutputStreamID: u32, pAllocator: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleAllocatorControl.VTable, self.vtable).SetDefaultAllocator(@ptrCast(*const IMFSampleAllocatorControl, self), dwOutputStreamID, pAllocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSampleAllocatorControl_GetAllocatorUsage(self: *const T, dwOutputStreamID: u32, pdwInputStreamID: *u32, peUsage: *MFSampleAllocatorUsage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSampleAllocatorControl.VTable, self.vtable).GetAllocatorUsage(@ptrCast(*const IMFSampleAllocatorControl, self), dwOutputStreamID, pdwInputStreamID, peUsage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFASFContentInfo_Value = @import("../zig.zig").Guid.initString("B1DCA5CD-D5DA-4451-8E9E-DB5C59914EAD");
pub const IID_IMFASFContentInfo = &IID_IMFASFContentInfo_Value;
pub const IMFASFContentInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHeaderSize: fn(
            self: *const IMFASFContentInfo,
            pIStartOfContent: *IMFMediaBuffer,
            cbHeaderSize: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseHeader: fn(
            self: *const IMFASFContentInfo,
            pIHeaderBuffer: *IMFMediaBuffer,
            cbOffsetWithinHeader: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateHeader: fn(
            self: *const IMFASFContentInfo,
            pIHeader: *IMFMediaBuffer,
            pcbHeader: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProfile: fn(
            self: *const IMFASFContentInfo,
            ppIProfile: **IMFASFProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProfile: fn(
            self: *const IMFASFContentInfo,
            pIProfile: *IMFASFProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GeneratePresentationDescriptor: fn(
            self: *const IMFASFContentInfo,
            ppIPresentationDescriptor: **IMFPresentationDescriptor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEncodingConfigurationPropertyStore: fn(
            self: *const IMFASFContentInfo,
            wStreamNumber: u16,
            ppIStore: **IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFContentInfo_GetHeaderSize(self: *const T, pIStartOfContent: *IMFMediaBuffer, cbHeaderSize: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFContentInfo.VTable, self.vtable).GetHeaderSize(@ptrCast(*const IMFASFContentInfo, self), pIStartOfContent, cbHeaderSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFContentInfo_ParseHeader(self: *const T, pIHeaderBuffer: *IMFMediaBuffer, cbOffsetWithinHeader: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFContentInfo.VTable, self.vtable).ParseHeader(@ptrCast(*const IMFASFContentInfo, self), pIHeaderBuffer, cbOffsetWithinHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFContentInfo_GenerateHeader(self: *const T, pIHeader: *IMFMediaBuffer, pcbHeader: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFContentInfo.VTable, self.vtable).GenerateHeader(@ptrCast(*const IMFASFContentInfo, self), pIHeader, pcbHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFContentInfo_GetProfile(self: *const T, ppIProfile: **IMFASFProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFContentInfo.VTable, self.vtable).GetProfile(@ptrCast(*const IMFASFContentInfo, self), ppIProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFContentInfo_SetProfile(self: *const T, pIProfile: *IMFASFProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFContentInfo.VTable, self.vtable).SetProfile(@ptrCast(*const IMFASFContentInfo, self), pIProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFContentInfo_GeneratePresentationDescriptor(self: *const T, ppIPresentationDescriptor: **IMFPresentationDescriptor) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFContentInfo.VTable, self.vtable).GeneratePresentationDescriptor(@ptrCast(*const IMFASFContentInfo, self), ppIPresentationDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFContentInfo_GetEncodingConfigurationPropertyStore(self: *const T, wStreamNumber: u16, ppIStore: **IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFContentInfo.VTable, self.vtable).GetEncodingConfigurationPropertyStore(@ptrCast(*const IMFASFContentInfo, self), wStreamNumber, ppIStore);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFASFProfile_Value = @import("../zig.zig").Guid.initString("D267BF6A-028B-4E0D-903D-43F0EF82D0D4");
pub const IID_IMFASFProfile = &IID_IMFASFProfile_Value;
pub const IMFASFProfile = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetStreamCount: fn(
            self: *const IMFASFProfile,
            pcStreams: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: fn(
            self: *const IMFASFProfile,
            dwStreamIndex: u32,
            pwStreamNumber: *u16,
            ppIStream: **IMFASFStreamConfig,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamByNumber: fn(
            self: *const IMFASFProfile,
            wStreamNumber: u16,
            ppIStream: **IMFASFStreamConfig,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStream: fn(
            self: *const IMFASFProfile,
            pIStream: *IMFASFStreamConfig,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStream: fn(
            self: *const IMFASFProfile,
            wStreamNumber: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStream: fn(
            self: *const IMFASFProfile,
            pIMediaType: *IMFMediaType,
            ppIStream: **IMFASFStreamConfig,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMutualExclusionCount: fn(
            self: *const IMFASFProfile,
            pcMutexs: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMutualExclusion: fn(
            self: *const IMFASFProfile,
            dwMutexIndex: u32,
            ppIMutex: **IMFASFMutualExclusion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMutualExclusion: fn(
            self: *const IMFASFProfile,
            pIMutex: *IMFASFMutualExclusion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveMutualExclusion: fn(
            self: *const IMFASFProfile,
            dwMutexIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMutualExclusion: fn(
            self: *const IMFASFProfile,
            ppIMutex: **IMFASFMutualExclusion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamPrioritization: fn(
            self: *const IMFASFProfile,
            ppIStreamPrioritization: **IMFASFStreamPrioritization,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStreamPrioritization: fn(
            self: *const IMFASFProfile,
            pIStreamPrioritization: *IMFASFStreamPrioritization,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStreamPrioritization: fn(
            self: *const IMFASFProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateStreamPrioritization: fn(
            self: *const IMFASFProfile,
            ppIStreamPrioritization: **IMFASFStreamPrioritization,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IMFASFProfile,
            ppIProfile: **IMFASFProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_GetStreamCount(self: *const T, pcStreams: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).GetStreamCount(@ptrCast(*const IMFASFProfile, self), pcStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_GetStream(self: *const T, dwStreamIndex: u32, pwStreamNumber: *u16, ppIStream: **IMFASFStreamConfig) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).GetStream(@ptrCast(*const IMFASFProfile, self), dwStreamIndex, pwStreamNumber, ppIStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_GetStreamByNumber(self: *const T, wStreamNumber: u16, ppIStream: **IMFASFStreamConfig) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).GetStreamByNumber(@ptrCast(*const IMFASFProfile, self), wStreamNumber, ppIStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_SetStream(self: *const T, pIStream: *IMFASFStreamConfig) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).SetStream(@ptrCast(*const IMFASFProfile, self), pIStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_RemoveStream(self: *const T, wStreamNumber: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).RemoveStream(@ptrCast(*const IMFASFProfile, self), wStreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_CreateStream(self: *const T, pIMediaType: *IMFMediaType, ppIStream: **IMFASFStreamConfig) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).CreateStream(@ptrCast(*const IMFASFProfile, self), pIMediaType, ppIStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_GetMutualExclusionCount(self: *const T, pcMutexs: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).GetMutualExclusionCount(@ptrCast(*const IMFASFProfile, self), pcMutexs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_GetMutualExclusion(self: *const T, dwMutexIndex: u32, ppIMutex: **IMFASFMutualExclusion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).GetMutualExclusion(@ptrCast(*const IMFASFProfile, self), dwMutexIndex, ppIMutex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_AddMutualExclusion(self: *const T, pIMutex: *IMFASFMutualExclusion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).AddMutualExclusion(@ptrCast(*const IMFASFProfile, self), pIMutex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_RemoveMutualExclusion(self: *const T, dwMutexIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).RemoveMutualExclusion(@ptrCast(*const IMFASFProfile, self), dwMutexIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_CreateMutualExclusion(self: *const T, ppIMutex: **IMFASFMutualExclusion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).CreateMutualExclusion(@ptrCast(*const IMFASFProfile, self), ppIMutex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_GetStreamPrioritization(self: *const T, ppIStreamPrioritization: **IMFASFStreamPrioritization) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).GetStreamPrioritization(@ptrCast(*const IMFASFProfile, self), ppIStreamPrioritization);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_AddStreamPrioritization(self: *const T, pIStreamPrioritization: *IMFASFStreamPrioritization) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).AddStreamPrioritization(@ptrCast(*const IMFASFProfile, self), pIStreamPrioritization);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_RemoveStreamPrioritization(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).RemoveStreamPrioritization(@ptrCast(*const IMFASFProfile, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_CreateStreamPrioritization(self: *const T, ppIStreamPrioritization: **IMFASFStreamPrioritization) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).CreateStreamPrioritization(@ptrCast(*const IMFASFProfile, self), ppIStreamPrioritization);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFProfile_Clone(self: *const T, ppIProfile: **IMFASFProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFProfile.VTable, self.vtable).Clone(@ptrCast(*const IMFASFProfile, self), ppIProfile);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFASFStreamConfig_Value = @import("../zig.zig").Guid.initString("9E8AE8D2-DBBD-4200-9ACA-06E6DF484913");
pub const IID_IMFASFStreamConfig = &IID_IMFASFStreamConfig_Value;
pub const IMFASFStreamConfig = extern struct {
    pub const VTable = extern struct {
        base: IMFAttributes.VTable,
        GetStreamType: fn(
            self: *const IMFASFStreamConfig,
            pguidStreamType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamNumber: fn(
            self: *const IMFASFStreamConfig,
        ) callconv(@import("std").os.windows.WINAPI) u16,
        SetStreamNumber: fn(
            self: *const IMFASFStreamConfig,
            wStreamNum: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaType: fn(
            self: *const IMFASFStreamConfig,
            ppIMediaType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaType: fn(
            self: *const IMFASFStreamConfig,
            pIMediaType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadExtensionCount: fn(
            self: *const IMFASFStreamConfig,
            pcPayloadExtensions: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPayloadExtension: fn(
            self: *const IMFASFStreamConfig,
            wPayloadExtensionNumber: u16,
            pguidExtensionSystemID: *Guid,
            pcbExtensionDataSize: *u16,
            pbExtensionSystemInfo: *u8,
            pcbExtensionSystemInfo: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPayloadExtension: fn(
            self: *const IMFASFStreamConfig,
            guidExtensionSystemID: Guid,
            cbExtensionDataSize: u16,
            pbExtensionSystemInfo: [*:0]u8,
            cbExtensionSystemInfo: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllPayloadExtensions: fn(
            self: *const IMFASFStreamConfig,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IMFASFStreamConfig,
            ppIStreamConfig: **IMFASFStreamConfig,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAttributes.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_GetStreamType(self: *const T, pguidStreamType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).GetStreamType(@ptrCast(*const IMFASFStreamConfig, self), pguidStreamType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_GetStreamNumber(self: *const T) callconv(.Inline) u16 {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).GetStreamNumber(@ptrCast(*const IMFASFStreamConfig, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_SetStreamNumber(self: *const T, wStreamNum: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).SetStreamNumber(@ptrCast(*const IMFASFStreamConfig, self), wStreamNum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_GetMediaType(self: *const T, ppIMediaType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).GetMediaType(@ptrCast(*const IMFASFStreamConfig, self), ppIMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_SetMediaType(self: *const T, pIMediaType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).SetMediaType(@ptrCast(*const IMFASFStreamConfig, self), pIMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_GetPayloadExtensionCount(self: *const T, pcPayloadExtensions: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).GetPayloadExtensionCount(@ptrCast(*const IMFASFStreamConfig, self), pcPayloadExtensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_GetPayloadExtension(self: *const T, wPayloadExtensionNumber: u16, pguidExtensionSystemID: *Guid, pcbExtensionDataSize: *u16, pbExtensionSystemInfo: *u8, pcbExtensionSystemInfo: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).GetPayloadExtension(@ptrCast(*const IMFASFStreamConfig, self), wPayloadExtensionNumber, pguidExtensionSystemID, pcbExtensionDataSize, pbExtensionSystemInfo, pcbExtensionSystemInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_AddPayloadExtension(self: *const T, guidExtensionSystemID: Guid, cbExtensionDataSize: u16, pbExtensionSystemInfo: [*:0]u8, cbExtensionSystemInfo: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).AddPayloadExtension(@ptrCast(*const IMFASFStreamConfig, self), guidExtensionSystemID, cbExtensionDataSize, pbExtensionSystemInfo, cbExtensionSystemInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_RemoveAllPayloadExtensions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).RemoveAllPayloadExtensions(@ptrCast(*const IMFASFStreamConfig, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamConfig_Clone(self: *const T, ppIStreamConfig: **IMFASFStreamConfig) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamConfig.VTable, self.vtable).Clone(@ptrCast(*const IMFASFStreamConfig, self), ppIStreamConfig);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFASFMutualExclusion_Value = @import("../zig.zig").Guid.initString("12558291-E399-11D5-BC2A-00B0D0F3F4AB");
pub const IID_IMFASFMutualExclusion = &IID_IMFASFMutualExclusion_Value;
pub const IMFASFMutualExclusion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetType: fn(
            self: *const IMFASFMutualExclusion,
            pguidType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetType: fn(
            self: *const IMFASFMutualExclusion,
            guidType: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecordCount: fn(
            self: *const IMFASFMutualExclusion,
            pdwRecordCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamsForRecord: fn(
            self: *const IMFASFMutualExclusion,
            dwRecordNumber: u32,
            pwStreamNumArray: *u16,
            pcStreams: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStreamForRecord: fn(
            self: *const IMFASFMutualExclusion,
            dwRecordNumber: u32,
            wStreamNumber: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStreamFromRecord: fn(
            self: *const IMFASFMutualExclusion,
            dwRecordNumber: u32,
            wStreamNumber: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveRecord: fn(
            self: *const IMFASFMutualExclusion,
            dwRecordNumber: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRecord: fn(
            self: *const IMFASFMutualExclusion,
            pdwRecordNumber: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IMFASFMutualExclusion,
            ppIMutex: **IMFASFMutualExclusion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMutualExclusion_GetType(self: *const T, pguidType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMutualExclusion.VTable, self.vtable).GetType(@ptrCast(*const IMFASFMutualExclusion, self), pguidType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMutualExclusion_SetType(self: *const T, guidType: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMutualExclusion.VTable, self.vtable).SetType(@ptrCast(*const IMFASFMutualExclusion, self), guidType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMutualExclusion_GetRecordCount(self: *const T, pdwRecordCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMutualExclusion.VTable, self.vtable).GetRecordCount(@ptrCast(*const IMFASFMutualExclusion, self), pdwRecordCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMutualExclusion_GetStreamsForRecord(self: *const T, dwRecordNumber: u32, pwStreamNumArray: *u16, pcStreams: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMutualExclusion.VTable, self.vtable).GetStreamsForRecord(@ptrCast(*const IMFASFMutualExclusion, self), dwRecordNumber, pwStreamNumArray, pcStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMutualExclusion_AddStreamForRecord(self: *const T, dwRecordNumber: u32, wStreamNumber: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMutualExclusion.VTable, self.vtable).AddStreamForRecord(@ptrCast(*const IMFASFMutualExclusion, self), dwRecordNumber, wStreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMutualExclusion_RemoveStreamFromRecord(self: *const T, dwRecordNumber: u32, wStreamNumber: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMutualExclusion.VTable, self.vtable).RemoveStreamFromRecord(@ptrCast(*const IMFASFMutualExclusion, self), dwRecordNumber, wStreamNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMutualExclusion_RemoveRecord(self: *const T, dwRecordNumber: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMutualExclusion.VTable, self.vtable).RemoveRecord(@ptrCast(*const IMFASFMutualExclusion, self), dwRecordNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMutualExclusion_AddRecord(self: *const T, pdwRecordNumber: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMutualExclusion.VTable, self.vtable).AddRecord(@ptrCast(*const IMFASFMutualExclusion, self), pdwRecordNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMutualExclusion_Clone(self: *const T, ppIMutex: **IMFASFMutualExclusion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMutualExclusion.VTable, self.vtable).Clone(@ptrCast(*const IMFASFMutualExclusion, self), ppIMutex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFASFStreamPrioritization_Value = @import("../zig.zig").Guid.initString("699BDC27-BBAF-49FF-8E38-9C39C9B5E088");
pub const IID_IMFASFStreamPrioritization = &IID_IMFASFStreamPrioritization_Value;
pub const IMFASFStreamPrioritization = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: fn(
            self: *const IMFASFStreamPrioritization,
            pdwStreamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStream: fn(
            self: *const IMFASFStreamPrioritization,
            dwStreamIndex: u32,
            pwStreamNumber: *u16,
            pwStreamFlags: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStream: fn(
            self: *const IMFASFStreamPrioritization,
            wStreamNumber: u16,
            wStreamFlags: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStream: fn(
            self: *const IMFASFStreamPrioritization,
            dwStreamIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IMFASFStreamPrioritization,
            ppIStreamPrioritization: **IMFASFStreamPrioritization,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamPrioritization_GetStreamCount(self: *const T, pdwStreamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamPrioritization.VTable, self.vtable).GetStreamCount(@ptrCast(*const IMFASFStreamPrioritization, self), pdwStreamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamPrioritization_GetStream(self: *const T, dwStreamIndex: u32, pwStreamNumber: *u16, pwStreamFlags: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamPrioritization.VTable, self.vtable).GetStream(@ptrCast(*const IMFASFStreamPrioritization, self), dwStreamIndex, pwStreamNumber, pwStreamFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamPrioritization_AddStream(self: *const T, wStreamNumber: u16, wStreamFlags: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamPrioritization.VTable, self.vtable).AddStream(@ptrCast(*const IMFASFStreamPrioritization, self), wStreamNumber, wStreamFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamPrioritization_RemoveStream(self: *const T, dwStreamIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamPrioritization.VTable, self.vtable).RemoveStream(@ptrCast(*const IMFASFStreamPrioritization, self), dwStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamPrioritization_Clone(self: *const T, ppIStreamPrioritization: **IMFASFStreamPrioritization) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamPrioritization.VTable, self.vtable).Clone(@ptrCast(*const IMFASFStreamPrioritization, self), ppIStreamPrioritization);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFASF_INDEXER_FLAGS = extern enum(i32) {
    MFASF_INDEXER_WRITE_NEW_INDEX = 1,
    MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK = 2,
    MFASF_INDEXER_WRITE_FOR_LIVEREAD = 4,
};
pub const MFASF_INDEXER_WRITE_NEW_INDEX = MFASF_INDEXER_FLAGS.MFASF_INDEXER_WRITE_NEW_INDEX;
pub const MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK = MFASF_INDEXER_FLAGS.MFASF_INDEXER_READ_FOR_REVERSEPLAYBACK;
pub const MFASF_INDEXER_WRITE_FOR_LIVEREAD = MFASF_INDEXER_FLAGS.MFASF_INDEXER_WRITE_FOR_LIVEREAD;

pub const ASF_INDEX_IDENTIFIER = extern struct {
    guidIndexType: Guid,
    wStreamNumber: u16,
};

pub const ASF_INDEX_DESCRIPTOR = extern struct {
    Identifier: ASF_INDEX_IDENTIFIER,
    cPerEntryBytes: u16,
    szDescription: [32]u16,
    dwInterval: u32,
};

const IID_IMFASFIndexer_Value = @import("../zig.zig").Guid.initString("53590F48-DC3B-4297-813F-787761AD7B3E");
pub const IID_IMFASFIndexer = &IID_IMFASFIndexer_Value;
pub const IMFASFIndexer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFlags: fn(
            self: *const IMFASFIndexer,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IMFASFIndexer,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const IMFASFIndexer,
            pIContentInfo: *IMFASFContentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexPosition: fn(
            self: *const IMFASFIndexer,
            pIContentInfo: *IMFASFContentInfo,
            pcbIndexOffset: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndexByteStreams: fn(
            self: *const IMFASFIndexer,
            ppIByteStreams: **IMFByteStream,
            cByteStreams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexByteStreamCount: fn(
            self: *const IMFASFIndexer,
            pcByteStreams: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexStatus: fn(
            self: *const IMFASFIndexer,
            pIndexIdentifier: *ASF_INDEX_IDENTIFIER,
            pfIsIndexed: *BOOL,
            pbIndexDescriptor: *u8,
            pcbIndexDescriptor: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndexStatus: fn(
            self: *const IMFASFIndexer,
            pbIndexDescriptor: *u8,
            cbIndexDescriptor: u32,
            fGenerateIndex: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSeekPositionForValue: fn(
            self: *const IMFASFIndexer,
            pvarValue: *const PROPVARIANT,
            pIndexIdentifier: *ASF_INDEX_IDENTIFIER,
            pcbOffsetWithinData: *u64,
            phnsApproxTime: *i64,
            pdwPayloadNumberOfStreamWithinPacket: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateIndexEntries: fn(
            self: *const IMFASFIndexer,
            pIASFPacketSample: *IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitIndex: fn(
            self: *const IMFASFIndexer,
            pIContentInfo: *IMFASFContentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexWriteSpace: fn(
            self: *const IMFASFIndexer,
            pcbIndexWriteSpace: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompletedIndex: fn(
            self: *const IMFASFIndexer,
            pIIndexBuffer: *IMFMediaBuffer,
            cbOffsetWithinIndex: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_SetFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).SetFlags(@ptrCast(*const IMFASFIndexer, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_GetFlags(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).GetFlags(@ptrCast(*const IMFASFIndexer, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_Initialize(self: *const T, pIContentInfo: *IMFASFContentInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).Initialize(@ptrCast(*const IMFASFIndexer, self), pIContentInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_GetIndexPosition(self: *const T, pIContentInfo: *IMFASFContentInfo, pcbIndexOffset: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).GetIndexPosition(@ptrCast(*const IMFASFIndexer, self), pIContentInfo, pcbIndexOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_SetIndexByteStreams(self: *const T, ppIByteStreams: **IMFByteStream, cByteStreams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).SetIndexByteStreams(@ptrCast(*const IMFASFIndexer, self), ppIByteStreams, cByteStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_GetIndexByteStreamCount(self: *const T, pcByteStreams: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).GetIndexByteStreamCount(@ptrCast(*const IMFASFIndexer, self), pcByteStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_GetIndexStatus(self: *const T, pIndexIdentifier: *ASF_INDEX_IDENTIFIER, pfIsIndexed: *BOOL, pbIndexDescriptor: *u8, pcbIndexDescriptor: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).GetIndexStatus(@ptrCast(*const IMFASFIndexer, self), pIndexIdentifier, pfIsIndexed, pbIndexDescriptor, pcbIndexDescriptor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_SetIndexStatus(self: *const T, pbIndexDescriptor: *u8, cbIndexDescriptor: u32, fGenerateIndex: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).SetIndexStatus(@ptrCast(*const IMFASFIndexer, self), pbIndexDescriptor, cbIndexDescriptor, fGenerateIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_GetSeekPositionForValue(self: *const T, pvarValue: *const PROPVARIANT, pIndexIdentifier: *ASF_INDEX_IDENTIFIER, pcbOffsetWithinData: *u64, phnsApproxTime: *i64, pdwPayloadNumberOfStreamWithinPacket: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).GetSeekPositionForValue(@ptrCast(*const IMFASFIndexer, self), pvarValue, pIndexIdentifier, pcbOffsetWithinData, phnsApproxTime, pdwPayloadNumberOfStreamWithinPacket);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_GenerateIndexEntries(self: *const T, pIASFPacketSample: *IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).GenerateIndexEntries(@ptrCast(*const IMFASFIndexer, self), pIASFPacketSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_CommitIndex(self: *const T, pIContentInfo: *IMFASFContentInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).CommitIndex(@ptrCast(*const IMFASFIndexer, self), pIContentInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_GetIndexWriteSpace(self: *const T, pcbIndexWriteSpace: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).GetIndexWriteSpace(@ptrCast(*const IMFASFIndexer, self), pcbIndexWriteSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFIndexer_GetCompletedIndex(self: *const T, pIIndexBuffer: *IMFMediaBuffer, cbOffsetWithinIndex: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFIndexer.VTable, self.vtable).GetCompletedIndex(@ptrCast(*const IMFASFIndexer, self), pIIndexBuffer, cbOffsetWithinIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFASFSplitter_Value = @import("../zig.zig").Guid.initString("12558295-E399-11D5-BC2A-00B0D0F3F4AB");
pub const IID_IMFASFSplitter = &IID_IMFASFSplitter_Value;
pub const IMFASFSplitter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IMFASFSplitter,
            pIContentInfo: *IMFASFContentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IMFASFSplitter,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IMFASFSplitter,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectStreams: fn(
            self: *const IMFASFSplitter,
            pwStreamNumbers: *u16,
            wNumStreams: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedStreams: fn(
            self: *const IMFASFSplitter,
            pwStreamNumbers: *u16,
            pwNumStreams: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseData: fn(
            self: *const IMFASFSplitter,
            pIBuffer: *IMFMediaBuffer,
            cbBufferOffset: u32,
            cbLength: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSample: fn(
            self: *const IMFASFSplitter,
            pdwStatusFlags: *u32,
            pwStreamNumber: *u16,
            ppISample: **IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IMFASFSplitter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastSendTime: fn(
            self: *const IMFASFSplitter,
            pdwLastSendTime: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFSplitter_Initialize(self: *const T, pIContentInfo: *IMFASFContentInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFSplitter.VTable, self.vtable).Initialize(@ptrCast(*const IMFASFSplitter, self), pIContentInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFSplitter_SetFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFSplitter.VTable, self.vtable).SetFlags(@ptrCast(*const IMFASFSplitter, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFSplitter_GetFlags(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFSplitter.VTable, self.vtable).GetFlags(@ptrCast(*const IMFASFSplitter, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFSplitter_SelectStreams(self: *const T, pwStreamNumbers: *u16, wNumStreams: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFSplitter.VTable, self.vtable).SelectStreams(@ptrCast(*const IMFASFSplitter, self), pwStreamNumbers, wNumStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFSplitter_GetSelectedStreams(self: *const T, pwStreamNumbers: *u16, pwNumStreams: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFSplitter.VTable, self.vtable).GetSelectedStreams(@ptrCast(*const IMFASFSplitter, self), pwStreamNumbers, pwNumStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFSplitter_ParseData(self: *const T, pIBuffer: *IMFMediaBuffer, cbBufferOffset: u32, cbLength: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFSplitter.VTable, self.vtable).ParseData(@ptrCast(*const IMFASFSplitter, self), pIBuffer, cbBufferOffset, cbLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFSplitter_GetNextSample(self: *const T, pdwStatusFlags: *u32, pwStreamNumber: *u16, ppISample: **IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFSplitter.VTable, self.vtable).GetNextSample(@ptrCast(*const IMFASFSplitter, self), pdwStatusFlags, pwStreamNumber, ppISample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFSplitter_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFSplitter.VTable, self.vtable).Flush(@ptrCast(*const IMFASFSplitter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFSplitter_GetLastSendTime(self: *const T, pdwLastSendTime: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFSplitter.VTable, self.vtable).GetLastSendTime(@ptrCast(*const IMFASFSplitter, self), pdwLastSendTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFASF_SPLITTERFLAGS = extern enum(i32) {
    MFASF_SPLITTER_REVERSE = 1,
    MFASF_SPLITTER_WMDRM = 2,
};
pub const MFASF_SPLITTER_REVERSE = MFASF_SPLITTERFLAGS.MFASF_SPLITTER_REVERSE;
pub const MFASF_SPLITTER_WMDRM = MFASF_SPLITTERFLAGS.MFASF_SPLITTER_WMDRM;

pub const ASF_STATUSFLAGS = extern enum(i32) {
    INCOMPLETE = 1,
    NONFATAL_ERROR = 2,
};
pub const ASF_STATUSFLAGS_INCOMPLETE = ASF_STATUSFLAGS.INCOMPLETE;
pub const ASF_STATUSFLAGS_NONFATAL_ERROR = ASF_STATUSFLAGS.NONFATAL_ERROR;

pub const MFASF_MULTIPLEXERFLAGS = extern enum(i32) {
    MFASF_MULTIPLEXER_AUTOADJUST_BITRATE = 1,
};
pub const MFASF_MULTIPLEXER_AUTOADJUST_BITRATE = MFASF_MULTIPLEXERFLAGS.MFASF_MULTIPLEXER_AUTOADJUST_BITRATE;

pub const ASF_MUX_STATISTICS = extern struct {
    cFramesWritten: u32,
    cFramesDropped: u32,
};

const IID_IMFASFMultiplexer_Value = @import("../zig.zig").Guid.initString("57BDD80A-9B38-4838-B737-C58F670D7D4F");
pub const IID_IMFASFMultiplexer = &IID_IMFASFMultiplexer_Value;
pub const IMFASFMultiplexer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IMFASFMultiplexer,
            pIContentInfo: *IMFASFContentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IMFASFMultiplexer,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IMFASFMultiplexer,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProcessSample: fn(
            self: *const IMFASFMultiplexer,
            wStreamNumber: u16,
            pISample: *IMFSample,
            hnsTimestampAdjust: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextPacket: fn(
            self: *const IMFASFMultiplexer,
            pdwStatusFlags: *u32,
            ppIPacket: **IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IMFASFMultiplexer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: fn(
            self: *const IMFASFMultiplexer,
            pIContentInfo: *IMFASFContentInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatistics: fn(
            self: *const IMFASFMultiplexer,
            wStreamNumber: u16,
            pMuxStats: *ASF_MUX_STATISTICS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSyncTolerance: fn(
            self: *const IMFASFMultiplexer,
            msSyncTolerance: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMultiplexer_Initialize(self: *const T, pIContentInfo: *IMFASFContentInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMultiplexer.VTable, self.vtable).Initialize(@ptrCast(*const IMFASFMultiplexer, self), pIContentInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMultiplexer_SetFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMultiplexer.VTable, self.vtable).SetFlags(@ptrCast(*const IMFASFMultiplexer, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMultiplexer_GetFlags(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMultiplexer.VTable, self.vtable).GetFlags(@ptrCast(*const IMFASFMultiplexer, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMultiplexer_ProcessSample(self: *const T, wStreamNumber: u16, pISample: *IMFSample, hnsTimestampAdjust: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMultiplexer.VTable, self.vtable).ProcessSample(@ptrCast(*const IMFASFMultiplexer, self), wStreamNumber, pISample, hnsTimestampAdjust);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMultiplexer_GetNextPacket(self: *const T, pdwStatusFlags: *u32, ppIPacket: **IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMultiplexer.VTable, self.vtable).GetNextPacket(@ptrCast(*const IMFASFMultiplexer, self), pdwStatusFlags, ppIPacket);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMultiplexer_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMultiplexer.VTable, self.vtable).Flush(@ptrCast(*const IMFASFMultiplexer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMultiplexer_End(self: *const T, pIContentInfo: *IMFASFContentInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMultiplexer.VTable, self.vtable).End(@ptrCast(*const IMFASFMultiplexer, self), pIContentInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMultiplexer_GetStatistics(self: *const T, wStreamNumber: u16, pMuxStats: *ASF_MUX_STATISTICS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMultiplexer.VTable, self.vtable).GetStatistics(@ptrCast(*const IMFASFMultiplexer, self), wStreamNumber, pMuxStats);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFMultiplexer_SetSyncTolerance(self: *const T, msSyncTolerance: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFMultiplexer.VTable, self.vtable).SetSyncTolerance(@ptrCast(*const IMFASFMultiplexer, self), msSyncTolerance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFASF_STREAMSELECTOR_FLAGS = extern enum(i32) {
    MFASF_STREAMSELECTOR_DISABLE_THINNING = 1,
    MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE = 2,
};
pub const MFASF_STREAMSELECTOR_DISABLE_THINNING = MFASF_STREAMSELECTOR_FLAGS.MFASF_STREAMSELECTOR_DISABLE_THINNING;
pub const MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE = MFASF_STREAMSELECTOR_FLAGS.MFASF_STREAMSELECTOR_USE_AVERAGE_BITRATE;

pub const ASF_SELECTION_STATUS = extern enum(i32) {
    ASF_STATUS_NOTSELECTED = 0,
    ASF_STATUS_CLEANPOINTSONLY = 1,
    ASF_STATUS_ALLDATAUNITS = 2,
};
pub const ASF_STATUS_NOTSELECTED = ASF_SELECTION_STATUS.ASF_STATUS_NOTSELECTED;
pub const ASF_STATUS_CLEANPOINTSONLY = ASF_SELECTION_STATUS.ASF_STATUS_CLEANPOINTSONLY;
pub const ASF_STATUS_ALLDATAUNITS = ASF_SELECTION_STATUS.ASF_STATUS_ALLDATAUNITS;

const IID_IMFASFStreamSelector_Value = @import("../zig.zig").Guid.initString("D01BAD4A-4FA0-4A60-9349-C27E62DA9D41");
pub const IID_IMFASFStreamSelector = &IID_IMFASFStreamSelector_Value;
pub const IMFASFStreamSelector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamCount: fn(
            self: *const IMFASFStreamSelector,
            pcStreams: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCount: fn(
            self: *const IMFASFStreamSelector,
            pcOutputs: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStreamCount: fn(
            self: *const IMFASFStreamSelector,
            dwOutputNum: u32,
            pcStreams: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputStreamNumbers: fn(
            self: *const IMFASFStreamSelector,
            dwOutputNum: u32,
            rgwStreamNumbers: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputFromStream: fn(
            self: *const IMFASFStreamSelector,
            wStreamNum: u16,
            pdwOutput: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputOverride: fn(
            self: *const IMFASFStreamSelector,
            dwOutputNum: u32,
            pSelection: *ASF_SELECTION_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputOverride: fn(
            self: *const IMFASFStreamSelector,
            dwOutputNum: u32,
            Selection: ASF_SELECTION_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMutexCount: fn(
            self: *const IMFASFStreamSelector,
            dwOutputNum: u32,
            pcMutexes: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMutex: fn(
            self: *const IMFASFStreamSelector,
            dwOutputNum: u32,
            dwMutexNum: u32,
            ppMutex: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputMutexSelection: fn(
            self: *const IMFASFStreamSelector,
            dwOutputNum: u32,
            dwMutexNum: u32,
            wSelectedRecord: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBandwidthStepCount: fn(
            self: *const IMFASFStreamSelector,
            pcStepCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBandwidthStep: fn(
            self: *const IMFASFStreamSelector,
            dwStepNum: u32,
            pdwBitrate: *u32,
            rgwStreamNumbers: *u16,
            rgSelections: *ASF_SELECTION_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BitrateToStepNumber: fn(
            self: *const IMFASFStreamSelector,
            dwBitrate: u32,
            pdwStepNum: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamSelectorFlags: fn(
            self: *const IMFASFStreamSelector,
            dwStreamSelectorFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetStreamCount(self: *const T, pcStreams: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetStreamCount(@ptrCast(*const IMFASFStreamSelector, self), pcStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetOutputCount(self: *const T, pcOutputs: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetOutputCount(@ptrCast(*const IMFASFStreamSelector, self), pcOutputs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetOutputStreamCount(self: *const T, dwOutputNum: u32, pcStreams: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetOutputStreamCount(@ptrCast(*const IMFASFStreamSelector, self), dwOutputNum, pcStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetOutputStreamNumbers(self: *const T, dwOutputNum: u32, rgwStreamNumbers: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetOutputStreamNumbers(@ptrCast(*const IMFASFStreamSelector, self), dwOutputNum, rgwStreamNumbers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetOutputFromStream(self: *const T, wStreamNum: u16, pdwOutput: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetOutputFromStream(@ptrCast(*const IMFASFStreamSelector, self), wStreamNum, pdwOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetOutputOverride(self: *const T, dwOutputNum: u32, pSelection: *ASF_SELECTION_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetOutputOverride(@ptrCast(*const IMFASFStreamSelector, self), dwOutputNum, pSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_SetOutputOverride(self: *const T, dwOutputNum: u32, Selection: ASF_SELECTION_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).SetOutputOverride(@ptrCast(*const IMFASFStreamSelector, self), dwOutputNum, Selection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetOutputMutexCount(self: *const T, dwOutputNum: u32, pcMutexes: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetOutputMutexCount(@ptrCast(*const IMFASFStreamSelector, self), dwOutputNum, pcMutexes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetOutputMutex(self: *const T, dwOutputNum: u32, dwMutexNum: u32, ppMutex: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetOutputMutex(@ptrCast(*const IMFASFStreamSelector, self), dwOutputNum, dwMutexNum, ppMutex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_SetOutputMutexSelection(self: *const T, dwOutputNum: u32, dwMutexNum: u32, wSelectedRecord: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).SetOutputMutexSelection(@ptrCast(*const IMFASFStreamSelector, self), dwOutputNum, dwMutexNum, wSelectedRecord);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetBandwidthStepCount(self: *const T, pcStepCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetBandwidthStepCount(@ptrCast(*const IMFASFStreamSelector, self), pcStepCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_GetBandwidthStep(self: *const T, dwStepNum: u32, pdwBitrate: *u32, rgwStreamNumbers: *u16, rgSelections: *ASF_SELECTION_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).GetBandwidthStep(@ptrCast(*const IMFASFStreamSelector, self), dwStepNum, pdwBitrate, rgwStreamNumbers, rgSelections);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_BitrateToStepNumber(self: *const T, dwBitrate: u32, pdwStepNum: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).BitrateToStepNumber(@ptrCast(*const IMFASFStreamSelector, self), dwBitrate, pdwStepNum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFASFStreamSelector_SetStreamSelectorFlags(self: *const T, dwStreamSelectorFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFASFStreamSelector.VTable, self.vtable).SetStreamSelectorFlags(@ptrCast(*const IMFASFStreamSelector, self), dwStreamSelectorFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFSINK_WMDRMACTION = extern enum(i32) {
    UNDEFINED = 0,
    ENCODE = 1,
    TRANSCODE = 2,
    TRANSCRYPT = 3,
    LAST = 3,
};
pub const MFSINK_WMDRMACTION_UNDEFINED = MFSINK_WMDRMACTION.UNDEFINED;
pub const MFSINK_WMDRMACTION_ENCODE = MFSINK_WMDRMACTION.ENCODE;
pub const MFSINK_WMDRMACTION_TRANSCODE = MFSINK_WMDRMACTION.TRANSCODE;
pub const MFSINK_WMDRMACTION_TRANSCRYPT = MFSINK_WMDRMACTION.TRANSCRYPT;
pub const MFSINK_WMDRMACTION_LAST = MFSINK_WMDRMACTION.LAST;

const IID_IMFDRMNetHelper_Value = @import("../zig.zig").Guid.initString("3D1FF0EA-679A-4190-8D46-7FA69E8C7E15");
pub const IID_IMFDRMNetHelper = &IID_IMFDRMNetHelper_Value;
pub const IMFDRMNetHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProcessLicenseRequest: fn(
            self: *const IMFDRMNetHelper,
            pLicenseRequest: [*:0]u8,
            cbLicenseRequest: u32,
            ppLicenseResponse: [*]*u8,
            pcbLicenseResponse: *u32,
            pbstrKID: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChainedLicenseResponse: fn(
            self: *const IMFDRMNetHelper,
            ppLicenseResponse: [*]*u8,
            pcbLicenseResponse: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDRMNetHelper_ProcessLicenseRequest(self: *const T, pLicenseRequest: [*:0]u8, cbLicenseRequest: u32, ppLicenseResponse: [*]*u8, pcbLicenseResponse: *u32, pbstrKID: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDRMNetHelper.VTable, self.vtable).ProcessLicenseRequest(@ptrCast(*const IMFDRMNetHelper, self), pLicenseRequest, cbLicenseRequest, ppLicenseResponse, pcbLicenseResponse, pbstrKID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDRMNetHelper_GetChainedLicenseResponse(self: *const T, ppLicenseResponse: [*]*u8, pcbLicenseResponse: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDRMNetHelper.VTable, self.vtable).GetChainedLicenseResponse(@ptrCast(*const IMFDRMNetHelper, self), ppLicenseResponse, pcbLicenseResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoNormalizedRect = extern struct {
    left: f32,
    top: f32,
    right: f32,
    bottom: f32,
};

pub const MF_CAPTURE_ENGINE_DEVICE_TYPE = extern enum(i32) {
    AUDIO = 0,
    VIDEO = 1,
};
pub const MF_CAPTURE_ENGINE_DEVICE_TYPE_AUDIO = MF_CAPTURE_ENGINE_DEVICE_TYPE.AUDIO;
pub const MF_CAPTURE_ENGINE_DEVICE_TYPE_VIDEO = MF_CAPTURE_ENGINE_DEVICE_TYPE.VIDEO;

pub const MF_CAPTURE_ENGINE_SINK_TYPE = extern enum(i32) {
    RECORD = 0,
    PREVIEW = 1,
    PHOTO = 2,
};
pub const MF_CAPTURE_ENGINE_SINK_TYPE_RECORD = MF_CAPTURE_ENGINE_SINK_TYPE.RECORD;
pub const MF_CAPTURE_ENGINE_SINK_TYPE_PREVIEW = MF_CAPTURE_ENGINE_SINK_TYPE.PREVIEW;
pub const MF_CAPTURE_ENGINE_SINK_TYPE_PHOTO = MF_CAPTURE_ENGINE_SINK_TYPE.PHOTO;

pub const __MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001 = extern enum(i32) {
    MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW = -6,
    MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD = -7,
    MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO = -8,
    MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO = -9,
    MF_CAPTURE_ENGINE_MEDIASOURCE = -1,
};
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW = __MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001.MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_PREVIEW;
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD = __MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001.MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_VIDEO_RECORD;
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO = __MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001.MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_PHOTO;
pub const MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO = __MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001.MF_CAPTURE_ENGINE_PREFERRED_SOURCE_STREAM_FOR_AUDIO;
pub const MF_CAPTURE_ENGINE_MEDIASOURCE = __MIDL___MIDL_itf_mfcaptureengine_0000_0000_0001.MF_CAPTURE_ENGINE_MEDIASOURCE;

pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY = extern enum(i32) {
    VIDEO_PREVIEW = 0,
    VIDEO_CAPTURE = 1,
    PHOTO_INDEPENDENT = 2,
    PHOTO_DEPENDENT = 3,
    AUDIO = 4,
    UNSUPPORTED = 5,
};
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_PREVIEW = MF_CAPTURE_ENGINE_STREAM_CATEGORY.VIDEO_PREVIEW;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_VIDEO_CAPTURE = MF_CAPTURE_ENGINE_STREAM_CATEGORY.VIDEO_CAPTURE;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_INDEPENDENT = MF_CAPTURE_ENGINE_STREAM_CATEGORY.PHOTO_INDEPENDENT;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_PHOTO_DEPENDENT = MF_CAPTURE_ENGINE_STREAM_CATEGORY.PHOTO_DEPENDENT;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_AUDIO = MF_CAPTURE_ENGINE_STREAM_CATEGORY.AUDIO;
pub const MF_CAPTURE_ENGINE_STREAM_CATEGORY_UNSUPPORTED = MF_CAPTURE_ENGINE_STREAM_CATEGORY.UNSUPPORTED;

pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE = extern enum(i32) {
    OTHER = 0,
    COMMUNICATIONS = 1,
    MEDIA = 2,
    GAMECHAT = 3,
    SPEECH = 4,
};
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_OTHER = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.OTHER;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_COMMUNICATIONS = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.COMMUNICATIONS;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_MEDIA = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.MEDIA;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_GAMECHAT = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.GAMECHAT;
pub const MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE_SPEECH = MF_CAPTURE_ENGINE_MEDIA_CATEGORY_TYPE.SPEECH;

pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE = extern enum(i32) {
    MF_CAPTURE_ENGINE_AUDIO_PROCESSING_DEFAULT = 0,
    MF_CAPTURE_ENGINE_AUDIO_PROCESSING_RAW = 1,
};
pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING_DEFAULT = MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE.MF_CAPTURE_ENGINE_AUDIO_PROCESSING_DEFAULT;
pub const MF_CAPTURE_ENGINE_AUDIO_PROCESSING_RAW = MF_CAPTURE_ENGINE_AUDIO_PROCESSING_MODE.MF_CAPTURE_ENGINE_AUDIO_PROCESSING_RAW;

const IID_IMFCaptureEngineOnEventCallback_Value = @import("../zig.zig").Guid.initString("AEDA51C0-9025-4983-9012-DE597B88B089");
pub const IID_IMFCaptureEngineOnEventCallback = &IID_IMFCaptureEngineOnEventCallback_Value;
pub const IMFCaptureEngineOnEventCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnEvent: fn(
            self: *const IMFCaptureEngineOnEventCallback,
            pEvent: *IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngineOnEventCallback_OnEvent(self: *const T, pEvent: *IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngineOnEventCallback.VTable, self.vtable).OnEvent(@ptrCast(*const IMFCaptureEngineOnEventCallback, self), pEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCaptureEngineOnSampleCallback_Value = @import("../zig.zig").Guid.initString("52150B82-AB39-4467-980F-E48BF0822ECD");
pub const IID_IMFCaptureEngineOnSampleCallback = &IID_IMFCaptureEngineOnSampleCallback_Value;
pub const IMFCaptureEngineOnSampleCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSample: fn(
            self: *const IMFCaptureEngineOnSampleCallback,
            pSample: ?*IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngineOnSampleCallback_OnSample(self: *const T, pSample: ?*IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngineOnSampleCallback.VTable, self.vtable).OnSample(@ptrCast(*const IMFCaptureEngineOnSampleCallback, self), pSample);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCaptureSink_Value = @import("../zig.zig").Guid.initString("72D6135B-35E9-412C-B926-FD5265F2A885");
pub const IID_IMFCaptureSink = &IID_IMFCaptureSink_Value;
pub const IMFCaptureSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOutputMediaType: fn(
            self: *const IMFCaptureSink,
            dwSinkStreamIndex: u32,
            ppMediaType: ?*?*IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetService: fn(
            self: *const IMFCaptureSink,
            dwSinkStreamIndex: u32,
            rguidService: *const Guid,
            riid: *const Guid,
            ppUnknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStream: fn(
            self: *const IMFCaptureSink,
            dwSourceStreamIndex: u32,
            pMediaType: *IMFMediaType,
            pAttributes: ?*IMFAttributes,
            pdwSinkStreamIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Prepare: fn(
            self: *const IMFCaptureSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllStreams: fn(
            self: *const IMFCaptureSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSink_GetOutputMediaType(self: *const T, dwSinkStreamIndex: u32, ppMediaType: ?*?*IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSink.VTable, self.vtable).GetOutputMediaType(@ptrCast(*const IMFCaptureSink, self), dwSinkStreamIndex, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSink_GetService(self: *const T, dwSinkStreamIndex: u32, rguidService: *const Guid, riid: *const Guid, ppUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSink.VTable, self.vtable).GetService(@ptrCast(*const IMFCaptureSink, self), dwSinkStreamIndex, rguidService, riid, ppUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSink_AddStream(self: *const T, dwSourceStreamIndex: u32, pMediaType: *IMFMediaType, pAttributes: ?*IMFAttributes, pdwSinkStreamIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSink.VTable, self.vtable).AddStream(@ptrCast(*const IMFCaptureSink, self), dwSourceStreamIndex, pMediaType, pAttributes, pdwSinkStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSink_Prepare(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSink.VTable, self.vtable).Prepare(@ptrCast(*const IMFCaptureSink, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSink_RemoveAllStreams(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSink.VTable, self.vtable).RemoveAllStreams(@ptrCast(*const IMFCaptureSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCaptureRecordSink_Value = @import("../zig.zig").Guid.initString("3323B55A-F92A-4FE2-8EDC-E9BFC0634D77");
pub const IID_IMFCaptureRecordSink = &IID_IMFCaptureRecordSink_Value;
pub const IMFCaptureRecordSink = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureSink.VTable,
        SetOutputByteStream: fn(
            self: *const IMFCaptureRecordSink,
            pByteStream: *IMFByteStream,
            guidContainerType: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputFileName: fn(
            self: *const IMFCaptureRecordSink,
            fileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSampleCallback: fn(
            self: *const IMFCaptureRecordSink,
            dwStreamSinkIndex: u32,
            pCallback: *IMFCaptureEngineOnSampleCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCustomSink: fn(
            self: *const IMFCaptureRecordSink,
            pMediaSink: *IMFMediaSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRotation: fn(
            self: *const IMFCaptureRecordSink,
            dwStreamIndex: u32,
            pdwRotationValue: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRotation: fn(
            self: *const IMFCaptureRecordSink,
            dwStreamIndex: u32,
            dwRotationValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFCaptureSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureRecordSink_SetOutputByteStream(self: *const T, pByteStream: *IMFByteStream, guidContainerType: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureRecordSink.VTable, self.vtable).SetOutputByteStream(@ptrCast(*const IMFCaptureRecordSink, self), pByteStream, guidContainerType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureRecordSink_SetOutputFileName(self: *const T, fileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureRecordSink.VTable, self.vtable).SetOutputFileName(@ptrCast(*const IMFCaptureRecordSink, self), fileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureRecordSink_SetSampleCallback(self: *const T, dwStreamSinkIndex: u32, pCallback: *IMFCaptureEngineOnSampleCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureRecordSink.VTable, self.vtable).SetSampleCallback(@ptrCast(*const IMFCaptureRecordSink, self), dwStreamSinkIndex, pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureRecordSink_SetCustomSink(self: *const T, pMediaSink: *IMFMediaSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureRecordSink.VTable, self.vtable).SetCustomSink(@ptrCast(*const IMFCaptureRecordSink, self), pMediaSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureRecordSink_GetRotation(self: *const T, dwStreamIndex: u32, pdwRotationValue: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureRecordSink.VTable, self.vtable).GetRotation(@ptrCast(*const IMFCaptureRecordSink, self), dwStreamIndex, pdwRotationValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureRecordSink_SetRotation(self: *const T, dwStreamIndex: u32, dwRotationValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureRecordSink.VTable, self.vtable).SetRotation(@ptrCast(*const IMFCaptureRecordSink, self), dwStreamIndex, dwRotationValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCapturePreviewSink_Value = @import("../zig.zig").Guid.initString("77346CFD-5B49-4D73-ACE0-5B52A859F2E0");
pub const IID_IMFCapturePreviewSink = &IID_IMFCapturePreviewSink_Value;
pub const IMFCapturePreviewSink = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureSink.VTable,
        SetRenderHandle: fn(
            self: *const IMFCapturePreviewSink,
            handle: HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderSurface: fn(
            self: *const IMFCapturePreviewSink,
            pSurface: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateVideo: fn(
            self: *const IMFCapturePreviewSink,
            pSrc: ?*const MFVideoNormalizedRect,
            pDst: ?*const RECT,
            pBorderClr: ?*const u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSampleCallback: fn(
            self: *const IMFCapturePreviewSink,
            dwStreamSinkIndex: u32,
            pCallback: *IMFCaptureEngineOnSampleCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMirrorState: fn(
            self: *const IMFCapturePreviewSink,
            pfMirrorState: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMirrorState: fn(
            self: *const IMFCapturePreviewSink,
            fMirrorState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRotation: fn(
            self: *const IMFCapturePreviewSink,
            dwStreamIndex: u32,
            pdwRotationValue: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRotation: fn(
            self: *const IMFCapturePreviewSink,
            dwStreamIndex: u32,
            dwRotationValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCustomSink: fn(
            self: *const IMFCapturePreviewSink,
            pMediaSink: *IMFMediaSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFCaptureSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePreviewSink_SetRenderHandle(self: *const T, handle: HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePreviewSink.VTable, self.vtable).SetRenderHandle(@ptrCast(*const IMFCapturePreviewSink, self), handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePreviewSink_SetRenderSurface(self: *const T, pSurface: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePreviewSink.VTable, self.vtable).SetRenderSurface(@ptrCast(*const IMFCapturePreviewSink, self), pSurface);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePreviewSink_UpdateVideo(self: *const T, pSrc: ?*const MFVideoNormalizedRect, pDst: ?*const RECT, pBorderClr: ?*const u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePreviewSink.VTable, self.vtable).UpdateVideo(@ptrCast(*const IMFCapturePreviewSink, self), pSrc, pDst, pBorderClr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePreviewSink_SetSampleCallback(self: *const T, dwStreamSinkIndex: u32, pCallback: *IMFCaptureEngineOnSampleCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePreviewSink.VTable, self.vtable).SetSampleCallback(@ptrCast(*const IMFCapturePreviewSink, self), dwStreamSinkIndex, pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePreviewSink_GetMirrorState(self: *const T, pfMirrorState: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePreviewSink.VTable, self.vtable).GetMirrorState(@ptrCast(*const IMFCapturePreviewSink, self), pfMirrorState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePreviewSink_SetMirrorState(self: *const T, fMirrorState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePreviewSink.VTable, self.vtable).SetMirrorState(@ptrCast(*const IMFCapturePreviewSink, self), fMirrorState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePreviewSink_GetRotation(self: *const T, dwStreamIndex: u32, pdwRotationValue: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePreviewSink.VTable, self.vtable).GetRotation(@ptrCast(*const IMFCapturePreviewSink, self), dwStreamIndex, pdwRotationValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePreviewSink_SetRotation(self: *const T, dwStreamIndex: u32, dwRotationValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePreviewSink.VTable, self.vtable).SetRotation(@ptrCast(*const IMFCapturePreviewSink, self), dwStreamIndex, dwRotationValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePreviewSink_SetCustomSink(self: *const T, pMediaSink: *IMFMediaSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePreviewSink.VTable, self.vtable).SetCustomSink(@ptrCast(*const IMFCapturePreviewSink, self), pMediaSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCapturePhotoSink_Value = @import("../zig.zig").Guid.initString("D2D43CC8-48BB-4AA7-95DB-10C06977E777");
pub const IID_IMFCapturePhotoSink = &IID_IMFCapturePhotoSink_Value;
pub const IMFCapturePhotoSink = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureSink.VTable,
        SetOutputFileName: fn(
            self: *const IMFCapturePhotoSink,
            fileName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSampleCallback: fn(
            self: *const IMFCapturePhotoSink,
            pCallback: *IMFCaptureEngineOnSampleCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputByteStream: fn(
            self: *const IMFCapturePhotoSink,
            pByteStream: *IMFByteStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFCaptureSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePhotoSink_SetOutputFileName(self: *const T, fileName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePhotoSink.VTable, self.vtable).SetOutputFileName(@ptrCast(*const IMFCapturePhotoSink, self), fileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePhotoSink_SetSampleCallback(self: *const T, pCallback: *IMFCaptureEngineOnSampleCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePhotoSink.VTable, self.vtable).SetSampleCallback(@ptrCast(*const IMFCapturePhotoSink, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCapturePhotoSink_SetOutputByteStream(self: *const T, pByteStream: *IMFByteStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCapturePhotoSink.VTable, self.vtable).SetOutputByteStream(@ptrCast(*const IMFCapturePhotoSink, self), pByteStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCaptureSource_Value = @import("../zig.zig").Guid.initString("439A42A8-0D2C-4505-BE83-F79B2A05D5C4");
pub const IID_IMFCaptureSource = &IID_IMFCaptureSource_Value;
pub const IMFCaptureSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCaptureDeviceSource: fn(
            self: *const IMFCaptureSource,
            mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE,
            ppMediaSource: ?*?*IMFMediaSource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaptureDeviceActivate: fn(
            self: *const IMFCaptureSource,
            mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE,
            ppActivate: ?*?*IMFActivate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetService: fn(
            self: *const IMFCaptureSource,
            rguidService: *const Guid,
            riid: *const Guid,
            ppUnknown: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEffect: fn(
            self: *const IMFCaptureSource,
            dwSourceStreamIndex: u32,
            pUnknown: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEffect: fn(
            self: *const IMFCaptureSource,
            dwSourceStreamIndex: u32,
            pUnknown: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllEffects: fn(
            self: *const IMFCaptureSource,
            dwSourceStreamIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAvailableDeviceMediaType: fn(
            self: *const IMFCaptureSource,
            dwSourceStreamIndex: u32,
            dwMediaTypeIndex: u32,
            ppMediaType: ?*?*IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentDeviceMediaType: fn(
            self: *const IMFCaptureSource,
            dwSourceStreamIndex: u32,
            pMediaType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentDeviceMediaType: fn(
            self: *const IMFCaptureSource,
            dwSourceStreamIndex: u32,
            ppMediaType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceStreamCount: fn(
            self: *const IMFCaptureSource,
            pdwStreamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDeviceStreamCategory: fn(
            self: *const IMFCaptureSource,
            dwSourceStreamIndex: u32,
            pStreamCategory: *MF_CAPTURE_ENGINE_STREAM_CATEGORY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMirrorState: fn(
            self: *const IMFCaptureSource,
            dwStreamIndex: u32,
            pfMirrorState: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMirrorState: fn(
            self: *const IMFCaptureSource,
            dwStreamIndex: u32,
            fMirrorState: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamIndexFromFriendlyName: fn(
            self: *const IMFCaptureSource,
            uifriendlyName: u32,
            pdwActualStreamIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_GetCaptureDeviceSource(self: *const T, mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppMediaSource: ?*?*IMFMediaSource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).GetCaptureDeviceSource(@ptrCast(*const IMFCaptureSource, self), mfCaptureEngineDeviceType, ppMediaSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_GetCaptureDeviceActivate(self: *const T, mfCaptureEngineDeviceType: MF_CAPTURE_ENGINE_DEVICE_TYPE, ppActivate: ?*?*IMFActivate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).GetCaptureDeviceActivate(@ptrCast(*const IMFCaptureSource, self), mfCaptureEngineDeviceType, ppActivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_GetService(self: *const T, rguidService: *const Guid, riid: *const Guid, ppUnknown: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).GetService(@ptrCast(*const IMFCaptureSource, self), rguidService, riid, ppUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_AddEffect(self: *const T, dwSourceStreamIndex: u32, pUnknown: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).AddEffect(@ptrCast(*const IMFCaptureSource, self), dwSourceStreamIndex, pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_RemoveEffect(self: *const T, dwSourceStreamIndex: u32, pUnknown: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).RemoveEffect(@ptrCast(*const IMFCaptureSource, self), dwSourceStreamIndex, pUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_RemoveAllEffects(self: *const T, dwSourceStreamIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).RemoveAllEffects(@ptrCast(*const IMFCaptureSource, self), dwSourceStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_GetAvailableDeviceMediaType(self: *const T, dwSourceStreamIndex: u32, dwMediaTypeIndex: u32, ppMediaType: ?*?*IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).GetAvailableDeviceMediaType(@ptrCast(*const IMFCaptureSource, self), dwSourceStreamIndex, dwMediaTypeIndex, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_SetCurrentDeviceMediaType(self: *const T, dwSourceStreamIndex: u32, pMediaType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).SetCurrentDeviceMediaType(@ptrCast(*const IMFCaptureSource, self), dwSourceStreamIndex, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_GetCurrentDeviceMediaType(self: *const T, dwSourceStreamIndex: u32, ppMediaType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).GetCurrentDeviceMediaType(@ptrCast(*const IMFCaptureSource, self), dwSourceStreamIndex, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_GetDeviceStreamCount(self: *const T, pdwStreamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).GetDeviceStreamCount(@ptrCast(*const IMFCaptureSource, self), pdwStreamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_GetDeviceStreamCategory(self: *const T, dwSourceStreamIndex: u32, pStreamCategory: *MF_CAPTURE_ENGINE_STREAM_CATEGORY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).GetDeviceStreamCategory(@ptrCast(*const IMFCaptureSource, self), dwSourceStreamIndex, pStreamCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_GetMirrorState(self: *const T, dwStreamIndex: u32, pfMirrorState: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).GetMirrorState(@ptrCast(*const IMFCaptureSource, self), dwStreamIndex, pfMirrorState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_SetMirrorState(self: *const T, dwStreamIndex: u32, fMirrorState: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).SetMirrorState(@ptrCast(*const IMFCaptureSource, self), dwStreamIndex, fMirrorState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSource_GetStreamIndexFromFriendlyName(self: *const T, uifriendlyName: u32, pdwActualStreamIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSource.VTable, self.vtable).GetStreamIndexFromFriendlyName(@ptrCast(*const IMFCaptureSource, self), uifriendlyName, pdwActualStreamIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCaptureEngine_Value = @import("../zig.zig").Guid.initString("A6BBA433-176B-48B2-B375-53AA03473207");
pub const IID_IMFCaptureEngine = &IID_IMFCaptureEngine_Value;
pub const IMFCaptureEngine = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IMFCaptureEngine,
            pEventCallback: *IMFCaptureEngineOnEventCallback,
            pAttributes: ?*IMFAttributes,
            pAudioSource: ?*IUnknown,
            pVideoSource: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartPreview: fn(
            self: *const IMFCaptureEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopPreview: fn(
            self: *const IMFCaptureEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartRecord: fn(
            self: *const IMFCaptureEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopRecord: fn(
            self: *const IMFCaptureEngine,
            bFinalize: BOOL,
            bFlushUnprocessedSamples: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TakePhoto: fn(
            self: *const IMFCaptureEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSink: fn(
            self: *const IMFCaptureEngine,
            mfCaptureEngineSinkType: MF_CAPTURE_ENGINE_SINK_TYPE,
            ppSink: **IMFCaptureSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSource: fn(
            self: *const IMFCaptureEngine,
            ppSource: **IMFCaptureSource,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngine_Initialize(self: *const T, pEventCallback: *IMFCaptureEngineOnEventCallback, pAttributes: ?*IMFAttributes, pAudioSource: ?*IUnknown, pVideoSource: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngine.VTable, self.vtable).Initialize(@ptrCast(*const IMFCaptureEngine, self), pEventCallback, pAttributes, pAudioSource, pVideoSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngine_StartPreview(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngine.VTable, self.vtable).StartPreview(@ptrCast(*const IMFCaptureEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngine_StopPreview(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngine.VTable, self.vtable).StopPreview(@ptrCast(*const IMFCaptureEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngine_StartRecord(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngine.VTable, self.vtable).StartRecord(@ptrCast(*const IMFCaptureEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngine_StopRecord(self: *const T, bFinalize: BOOL, bFlushUnprocessedSamples: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngine.VTable, self.vtable).StopRecord(@ptrCast(*const IMFCaptureEngine, self), bFinalize, bFlushUnprocessedSamples);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngine_TakePhoto(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngine.VTable, self.vtable).TakePhoto(@ptrCast(*const IMFCaptureEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngine_GetSink(self: *const T, mfCaptureEngineSinkType: MF_CAPTURE_ENGINE_SINK_TYPE, ppSink: **IMFCaptureSink) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngine.VTable, self.vtable).GetSink(@ptrCast(*const IMFCaptureEngine, self), mfCaptureEngineSinkType, ppSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngine_GetSource(self: *const T, ppSource: **IMFCaptureSource) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngine.VTable, self.vtable).GetSource(@ptrCast(*const IMFCaptureEngine, self), ppSource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCaptureEngineClassFactory_Value = @import("../zig.zig").Guid.initString("8F02D140-56FC-4302-A705-3A97C78BE779");
pub const IID_IMFCaptureEngineClassFactory = &IID_IMFCaptureEngineClassFactory_Value;
pub const IMFCaptureEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: fn(
            self: *const IMFCaptureEngineClassFactory,
            clsid: *const Guid,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngineClassFactory_CreateInstance(self: *const T, clsid: *const Guid, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngineClassFactory.VTable, self.vtable).CreateInstance(@ptrCast(*const IMFCaptureEngineClassFactory, self), clsid, riid, ppvObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCaptureEngineOnSampleCallback2_Value = @import("../zig.zig").Guid.initString("E37CEED7-340F-4514-9F4D-9C2AE026100B");
pub const IID_IMFCaptureEngineOnSampleCallback2 = &IID_IMFCaptureEngineOnSampleCallback2_Value;
pub const IMFCaptureEngineOnSampleCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureEngineOnSampleCallback.VTable,
        OnSynchronizedEvent: fn(
            self: *const IMFCaptureEngineOnSampleCallback2,
            pEvent: *IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFCaptureEngineOnSampleCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureEngineOnSampleCallback2_OnSynchronizedEvent(self: *const T, pEvent: *IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureEngineOnSampleCallback2.VTable, self.vtable).OnSynchronizedEvent(@ptrCast(*const IMFCaptureEngineOnSampleCallback2, self), pEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCaptureSink2_Value = @import("../zig.zig").Guid.initString("F9E4219E-6197-4B5E-B888-BEE310AB2C59");
pub const IID_IMFCaptureSink2 = &IID_IMFCaptureSink2_Value;
pub const IMFCaptureSink2 = extern struct {
    pub const VTable = extern struct {
        base: IMFCaptureSink.VTable,
        SetOutputMediaType: fn(
            self: *const IMFCaptureSink2,
            dwStreamIndex: u32,
            pMediaType: *IMFMediaType,
            pEncodingAttributes: ?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFCaptureSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCaptureSink2_SetOutputMediaType(self: *const T, dwStreamIndex: u32, pMediaType: *IMFMediaType, pEncodingAttributes: ?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCaptureSink2.VTable, self.vtable).SetOutputMediaType(@ptrCast(*const IMFCaptureSink2, self), dwStreamIndex, pMediaType, pEncodingAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFPERIODICCALLBACK = fn(
    pContext: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MFASYNC_WORKQUEUE_TYPE = extern enum(i32) {
    MF_STANDARD_WORKQUEUE = 0,
    MF_WINDOW_WORKQUEUE = 1,
    MF_MULTITHREADED_WORKQUEUE = 2,
};
pub const MF_STANDARD_WORKQUEUE = MFASYNC_WORKQUEUE_TYPE.MF_STANDARD_WORKQUEUE;
pub const MF_WINDOW_WORKQUEUE = MFASYNC_WORKQUEUE_TYPE.MF_WINDOW_WORKQUEUE;
pub const MF_MULTITHREADED_WORKQUEUE = MFASYNC_WORKQUEUE_TYPE.MF_MULTITHREADED_WORKQUEUE;

pub const MFASYNCRESULT = extern struct {
    pub const VTable = extern struct {
        base: IMFAsyncResult.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFAsyncResult.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TOPOSTATUS = extern enum(i32) {
    INVALID = 0,
    READY = 100,
    STARTED_SOURCE = 200,
    DYNAMIC_CHANGED = 210,
    SINK_SWITCHED = 300,
    ENDED = 400,
};
pub const MF_TOPOSTATUS_INVALID = MF_TOPOSTATUS.INVALID;
pub const MF_TOPOSTATUS_READY = MF_TOPOSTATUS.READY;
pub const MF_TOPOSTATUS_STARTED_SOURCE = MF_TOPOSTATUS.STARTED_SOURCE;
pub const MF_TOPOSTATUS_DYNAMIC_CHANGED = MF_TOPOSTATUS.DYNAMIC_CHANGED;
pub const MF_TOPOSTATUS_SINK_SWITCHED = MF_TOPOSTATUS.SINK_SWITCHED;
pub const MF_TOPOSTATUS_ENDED = MF_TOPOSTATUS.ENDED;

pub const MFSampleEncryptionProtectionScheme = extern enum(i32) {
    MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE = 0,
    MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR = 1,
    MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC = 2,
};
pub const MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE = MFSampleEncryptionProtectionScheme.MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_NONE;
pub const MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR = MFSampleEncryptionProtectionScheme.MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CTR;
pub const MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC = MFSampleEncryptionProtectionScheme.MF_SAMPLE_ENCRYPTION_PROTECTION_SCHEME_AES_CBC;

pub const MOVE_RECT = extern struct {
    SourcePoint: POINT,
    DestRect: RECT,
};

pub const DIRTYRECT_INFO = extern struct {
    FrameNumber: u32,
    NumDirtyRects: u32,
    DirtyRects: [1]RECT,
};

pub const MOVEREGION_INFO = extern struct {
    FrameNumber: u32,
    NumMoveRegions: u32,
    MoveRegions: [1]MOVE_RECT,
};

pub const ROI_AREA = extern struct {
    rect: RECT,
    QPDelta: i32,
};

pub const MACROBLOCK_DATA = extern struct {
    flags: u32,
    motionVectorX: i16,
    motionVectorY: i16,
    QPDelta: i32,
};

pub const _MFT_ENUM_FLAG = extern enum(i32) {
    MFT_ENUM_FLAG_SYNCMFT = 1,
    MFT_ENUM_FLAG_ASYNCMFT = 2,
    MFT_ENUM_FLAG_HARDWARE = 4,
    MFT_ENUM_FLAG_FIELDOFUSE = 8,
    MFT_ENUM_FLAG_LOCALMFT = 16,
    MFT_ENUM_FLAG_TRANSCODE_ONLY = 32,
    MFT_ENUM_FLAG_SORTANDFILTER = 64,
    MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY = 192,
    MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY = 320,
    MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE = 576,
    MFT_ENUM_FLAG_UNTRUSTED_STOREMFT = 1024,
    MFT_ENUM_FLAG_ALL = 63,
};
pub const MFT_ENUM_FLAG_SYNCMFT = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_SYNCMFT;
pub const MFT_ENUM_FLAG_ASYNCMFT = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_ASYNCMFT;
pub const MFT_ENUM_FLAG_HARDWARE = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_HARDWARE;
pub const MFT_ENUM_FLAG_FIELDOFUSE = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_FIELDOFUSE;
pub const MFT_ENUM_FLAG_LOCALMFT = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_LOCALMFT;
pub const MFT_ENUM_FLAG_TRANSCODE_ONLY = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_TRANSCODE_ONLY;
pub const MFT_ENUM_FLAG_SORTANDFILTER = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_SORTANDFILTER;
pub const MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_SORTANDFILTER_APPROVED_ONLY;
pub const MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY;
pub const MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_SORTANDFILTER_WEB_ONLY_EDGEMODE;
pub const MFT_ENUM_FLAG_UNTRUSTED_STOREMFT = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_UNTRUSTED_STOREMFT;
pub const MFT_ENUM_FLAG_ALL = _MFT_ENUM_FLAG.MFT_ENUM_FLAG_ALL;

pub const MFFrameSourceTypes = extern enum(i32) {
    Color = 1,
    Infrared = 2,
    Depth = 4,
    Image = 8,
    Custom = 128,
};
pub const MFFrameSourceTypes_Color = MFFrameSourceTypes.Color;
pub const MFFrameSourceTypes_Infrared = MFFrameSourceTypes.Infrared;
pub const MFFrameSourceTypes_Depth = MFFrameSourceTypes.Depth;
pub const MFFrameSourceTypes_Image = MFFrameSourceTypes.Image;
pub const MFFrameSourceTypes_Custom = MFFrameSourceTypes.Custom;

pub const MFVideo3DFormat = extern enum(i32) {
    MFVideo3DSampleFormat_BaseView = 0,
    MFVideo3DSampleFormat_MultiView = 1,
    MFVideo3DSampleFormat_Packed_LeftRight = 2,
    MFVideo3DSampleFormat_Packed_TopBottom = 3,
};
pub const MFVideo3DSampleFormat_BaseView = MFVideo3DFormat.MFVideo3DSampleFormat_BaseView;
pub const MFVideo3DSampleFormat_MultiView = MFVideo3DFormat.MFVideo3DSampleFormat_MultiView;
pub const MFVideo3DSampleFormat_Packed_LeftRight = MFVideo3DFormat.MFVideo3DSampleFormat_Packed_LeftRight;
pub const MFVideo3DSampleFormat_Packed_TopBottom = MFVideo3DFormat.MFVideo3DSampleFormat_Packed_TopBottom;

pub const MFVideo3DSampleFormat = extern enum(i32) {
    MFSampleExtension_3DVideo_MultiView = 1,
    MFSampleExtension_3DVideo_Packed = 0,
};
pub const MFSampleExtension_3DVideo_MultiView = MFVideo3DSampleFormat.MFSampleExtension_3DVideo_MultiView;
pub const MFSampleExtension_3DVideo_Packed = MFVideo3DSampleFormat.MFSampleExtension_3DVideo_Packed;

pub const MFVideoRotationFormat = extern enum(i32) {
    _0 = 0,
    _90 = 90,
    _180 = 180,
    _270 = 270,
};
pub const MFVideoRotationFormat_0 = MFVideoRotationFormat._0;
pub const MFVideoRotationFormat_90 = MFVideoRotationFormat._90;
pub const MFVideoRotationFormat_180 = MFVideoRotationFormat._180;
pub const MFVideoRotationFormat_270 = MFVideoRotationFormat._270;

pub const MFDepthMeasurement = extern enum(i32) {
    DistanceToFocalPlane = 0,
    DistanceToOpticalCenter = 1,
};
pub const DistanceToFocalPlane = MFDepthMeasurement.DistanceToFocalPlane;
pub const DistanceToOpticalCenter = MFDepthMeasurement.DistanceToOpticalCenter;

pub const MF_CUSTOM_DECODE_UNIT_TYPE = extern enum(i32) {
    MF_DECODE_UNIT_NAL = 0,
    MF_DECODE_UNIT_SEI = 1,
};
pub const MF_DECODE_UNIT_NAL = MF_CUSTOM_DECODE_UNIT_TYPE.MF_DECODE_UNIT_NAL;
pub const MF_DECODE_UNIT_SEI = MF_CUSTOM_DECODE_UNIT_TYPE.MF_DECODE_UNIT_SEI;

pub const MFFOLDDOWN_MATRIX = extern struct {
    cbSize: u32,
    cSrcChannels: u32,
    cDstChannels: u32,
    dwChannelMask: u32,
    Coeff: [64]i32,
};

pub const MFVideoDRMFlags = extern enum(i32) {
    MFVideoDRMFlag_None = 0,
    MFVideoDRMFlag_AnalogProtected = 1,
    MFVideoDRMFlag_DigitallyProtected = 2,
};
pub const MFVideoDRMFlag_None = MFVideoDRMFlags.MFVideoDRMFlag_None;
pub const MFVideoDRMFlag_AnalogProtected = MFVideoDRMFlags.MFVideoDRMFlag_AnalogProtected;
pub const MFVideoDRMFlag_DigitallyProtected = MFVideoDRMFlags.MFVideoDRMFlag_DigitallyProtected;

pub const MFVideoPadFlags = extern enum(i32) {
    MFVideoPadFlag_PAD_TO_None = 0,
    MFVideoPadFlag_PAD_TO_4x3 = 1,
    MFVideoPadFlag_PAD_TO_16x9 = 2,
};
pub const MFVideoPadFlag_PAD_TO_None = MFVideoPadFlags.MFVideoPadFlag_PAD_TO_None;
pub const MFVideoPadFlag_PAD_TO_4x3 = MFVideoPadFlags.MFVideoPadFlag_PAD_TO_4x3;
pub const MFVideoPadFlag_PAD_TO_16x9 = MFVideoPadFlags.MFVideoPadFlag_PAD_TO_16x9;

pub const MFVideoSrcContentHintFlags = extern enum(i32) {
    MFVideoSrcContentHintFlag_None = 0,
    MFVideoSrcContentHintFlag_16x9 = 1,
    MFVideoSrcContentHintFlag_235_1 = 2,
};
pub const MFVideoSrcContentHintFlag_None = MFVideoSrcContentHintFlags.MFVideoSrcContentHintFlag_None;
pub const MFVideoSrcContentHintFlag_16x9 = MFVideoSrcContentHintFlags.MFVideoSrcContentHintFlag_16x9;
pub const MFVideoSrcContentHintFlag_235_1 = MFVideoSrcContentHintFlags.MFVideoSrcContentHintFlag_235_1;

pub const MT_CUSTOM_VIDEO_PRIMARIES = extern struct {
    fRx: f32,
    fRy: f32,
    fGx: f32,
    fGy: f32,
    fBx: f32,
    fBy: f32,
    fWx: f32,
    fWy: f32,
};

pub const MT_ARBITRARY_HEADER = extern struct {
    majortype: Guid,
    subtype: Guid,
    bFixedSizeSamples: BOOL,
    bTemporalCompression: BOOL,
    lSampleSize: u32,
    formattype: Guid,
};

pub const MF_FLOAT2 = extern struct {
    x: f32,
    y: f32,
};

pub const MF_FLOAT3 = extern struct {
    x: f32,
    y: f32,
    z: f32,
};

pub const MF_QUATERNION = extern struct {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
};

pub const MFCameraExtrinsic_CalibratedTransform = extern struct {
    CalibrationId: Guid,
    Position: MF_FLOAT3,
    Orientation: MF_QUATERNION,
};

pub const MFCameraExtrinsics = extern struct {
    TransformCount: u32,
    CalibratedTransforms: [1]MFCameraExtrinsic_CalibratedTransform,
};

pub const MFCameraIntrinsic_PinholeCameraModel = extern struct {
    FocalLength: MF_FLOAT2,
    PrincipalPoint: MF_FLOAT2,
};

pub const MFCameraIntrinsic_DistortionModel = extern struct {
    Radial_k1: f32,
    Radial_k2: f32,
    Radial_k3: f32,
    Tangential_p1: f32,
    Tangential_p2: f32,
};

pub const MFPinholeCameraIntrinsic_IntrinsicModel = extern struct {
    Width: u32,
    Height: u32,
    CameraModel: MFCameraIntrinsic_PinholeCameraModel,
    DistortionModel: MFCameraIntrinsic_DistortionModel,
};

pub const MFPinholeCameraIntrinsics = extern struct {
    IntrinsicModelCount: u32,
    IntrinsicModels: [1]MFPinholeCameraIntrinsic_IntrinsicModel,
};

pub const MFWaveFormatExConvertFlags = extern enum(i32) {
    MFWaveFormatExConvertFlag_Normal = 0,
    MFWaveFormatExConvertFlag_ForceExtensible = 1,
};
pub const MFWaveFormatExConvertFlag_Normal = MFWaveFormatExConvertFlags.MFWaveFormatExConvertFlag_Normal;
pub const MFWaveFormatExConvertFlag_ForceExtensible = MFWaveFormatExConvertFlags.MFWaveFormatExConvertFlag_ForceExtensible;

pub const EAllocationType = extern enum(i32) {
    eAllocationTypeDynamic = 0,
    eAllocationTypeRT = 1,
    eAllocationTypePageable = 2,
    eAllocationTypeIgnore = 3,
};
pub const eAllocationTypeDynamic = EAllocationType.eAllocationTypeDynamic;
pub const eAllocationTypeRT = EAllocationType.eAllocationTypeRT;
pub const eAllocationTypePageable = EAllocationType.eAllocationTypePageable;
pub const eAllocationTypeIgnore = EAllocationType.eAllocationTypeIgnore;

pub const MF_MEDIA_ENGINE_ERR = extern enum(i32) {
    NOERROR = 0,
    ABORTED = 1,
    NETWORK = 2,
    DECODE = 3,
    SRC_NOT_SUPPORTED = 4,
    ENCRYPTED = 5,
};
pub const MF_MEDIA_ENGINE_ERR_NOERROR = MF_MEDIA_ENGINE_ERR.NOERROR;
pub const MF_MEDIA_ENGINE_ERR_ABORTED = MF_MEDIA_ENGINE_ERR.ABORTED;
pub const MF_MEDIA_ENGINE_ERR_NETWORK = MF_MEDIA_ENGINE_ERR.NETWORK;
pub const MF_MEDIA_ENGINE_ERR_DECODE = MF_MEDIA_ENGINE_ERR.DECODE;
pub const MF_MEDIA_ENGINE_ERR_SRC_NOT_SUPPORTED = MF_MEDIA_ENGINE_ERR.SRC_NOT_SUPPORTED;
pub const MF_MEDIA_ENGINE_ERR_ENCRYPTED = MF_MEDIA_ENGINE_ERR.ENCRYPTED;

const IID_IMFMediaError_Value = @import("../zig.zig").Guid.initString("FC0E10D2-AB2A-4501-A951-06BB1075184C");
pub const IID_IMFMediaError = &IID_IMFMediaError_Value;
pub const IMFMediaError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorCode: fn(
            self: *const IMFMediaError,
        ) callconv(@import("std").os.windows.WINAPI) u16,
        GetExtendedErrorCode: fn(
            self: *const IMFMediaError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetErrorCode: fn(
            self: *const IMFMediaError,
            @"error": MF_MEDIA_ENGINE_ERR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExtendedErrorCode: fn(
            self: *const IMFMediaError,
            @"error": HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaError_GetErrorCode(self: *const T) callconv(.Inline) u16 {
            return @ptrCast(*const IMFMediaError.VTable, self.vtable).GetErrorCode(@ptrCast(*const IMFMediaError, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaError_GetExtendedErrorCode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaError.VTable, self.vtable).GetExtendedErrorCode(@ptrCast(*const IMFMediaError, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaError_SetErrorCode(self: *const T, @"error": MF_MEDIA_ENGINE_ERR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaError.VTable, self.vtable).SetErrorCode(@ptrCast(*const IMFMediaError, self), @"error");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaError_SetExtendedErrorCode(self: *const T, @"error": HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaError.VTable, self.vtable).SetExtendedErrorCode(@ptrCast(*const IMFMediaError, self), @"error");
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaTimeRange_Value = @import("../zig.zig").Guid.initString("DB71A2FC-078A-414E-9DF9-8C2531B0AA6C");
pub const IID_IMFMediaTimeRange = &IID_IMFMediaTimeRange_Value;
pub const IMFMediaTimeRange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: fn(
            self: *const IMFMediaTimeRange,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetStart: fn(
            self: *const IMFMediaTimeRange,
            index: u32,
            pStart: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: fn(
            self: *const IMFMediaTimeRange,
            index: u32,
            pEnd: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContainsTime: fn(
            self: *const IMFMediaTimeRange,
            time: f64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        AddRange: fn(
            self: *const IMFMediaTimeRange,
            startTime: f64,
            endTime: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IMFMediaTimeRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTimeRange_GetLength(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFMediaTimeRange.VTable, self.vtable).GetLength(@ptrCast(*const IMFMediaTimeRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTimeRange_GetStart(self: *const T, index: u32, pStart: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTimeRange.VTable, self.vtable).GetStart(@ptrCast(*const IMFMediaTimeRange, self), index, pStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTimeRange_GetEnd(self: *const T, index: u32, pEnd: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTimeRange.VTable, self.vtable).GetEnd(@ptrCast(*const IMFMediaTimeRange, self), index, pEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTimeRange_ContainsTime(self: *const T, time: f64) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaTimeRange.VTable, self.vtable).ContainsTime(@ptrCast(*const IMFMediaTimeRange, self), time);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTimeRange_AddRange(self: *const T, startTime: f64, endTime: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTimeRange.VTable, self.vtable).AddRange(@ptrCast(*const IMFMediaTimeRange, self), startTime, endTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaTimeRange_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaTimeRange.VTable, self.vtable).Clear(@ptrCast(*const IMFMediaTimeRange, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_EVENT = extern enum(i32) {
    LOADSTART = 1,
    PROGRESS = 2,
    SUSPEND = 3,
    ABORT = 4,
    ERROR = 5,
    EMPTIED = 6,
    STALLED = 7,
    PLAY = 8,
    PAUSE = 9,
    LOADEDMETADATA = 10,
    LOADEDDATA = 11,
    WAITING = 12,
    PLAYING = 13,
    CANPLAY = 14,
    CANPLAYTHROUGH = 15,
    SEEKING = 16,
    SEEKED = 17,
    TIMEUPDATE = 18,
    ENDED = 19,
    RATECHANGE = 20,
    DURATIONCHANGE = 21,
    VOLUMECHANGE = 22,
    FORMATCHANGE = 1000,
    PURGEQUEUEDEVENTS = 1001,
    TIMELINE_MARKER = 1002,
    BALANCECHANGE = 1003,
    DOWNLOADCOMPLETE = 1004,
    BUFFERINGSTARTED = 1005,
    BUFFERINGENDED = 1006,
    FRAMESTEPCOMPLETED = 1007,
    NOTIFYSTABLESTATE = 1008,
    FIRSTFRAMEREADY = 1009,
    TRACKSCHANGE = 1010,
    OPMINFO = 1011,
    RESOURCELOST = 1012,
    DELAYLOADEVENT_CHANGED = 1013,
    STREAMRENDERINGERROR = 1014,
    SUPPORTEDRATES_CHANGED = 1015,
    AUDIOENDPOINTCHANGE = 1016,
};
pub const MF_MEDIA_ENGINE_EVENT_LOADSTART = MF_MEDIA_ENGINE_EVENT.LOADSTART;
pub const MF_MEDIA_ENGINE_EVENT_PROGRESS = MF_MEDIA_ENGINE_EVENT.PROGRESS;
pub const MF_MEDIA_ENGINE_EVENT_SUSPEND = MF_MEDIA_ENGINE_EVENT.SUSPEND;
pub const MF_MEDIA_ENGINE_EVENT_ABORT = MF_MEDIA_ENGINE_EVENT.ABORT;
pub const MF_MEDIA_ENGINE_EVENT_ERROR = MF_MEDIA_ENGINE_EVENT.ERROR;
pub const MF_MEDIA_ENGINE_EVENT_EMPTIED = MF_MEDIA_ENGINE_EVENT.EMPTIED;
pub const MF_MEDIA_ENGINE_EVENT_STALLED = MF_MEDIA_ENGINE_EVENT.STALLED;
pub const MF_MEDIA_ENGINE_EVENT_PLAY = MF_MEDIA_ENGINE_EVENT.PLAY;
pub const MF_MEDIA_ENGINE_EVENT_PAUSE = MF_MEDIA_ENGINE_EVENT.PAUSE;
pub const MF_MEDIA_ENGINE_EVENT_LOADEDMETADATA = MF_MEDIA_ENGINE_EVENT.LOADEDMETADATA;
pub const MF_MEDIA_ENGINE_EVENT_LOADEDDATA = MF_MEDIA_ENGINE_EVENT.LOADEDDATA;
pub const MF_MEDIA_ENGINE_EVENT_WAITING = MF_MEDIA_ENGINE_EVENT.WAITING;
pub const MF_MEDIA_ENGINE_EVENT_PLAYING = MF_MEDIA_ENGINE_EVENT.PLAYING;
pub const MF_MEDIA_ENGINE_EVENT_CANPLAY = MF_MEDIA_ENGINE_EVENT.CANPLAY;
pub const MF_MEDIA_ENGINE_EVENT_CANPLAYTHROUGH = MF_MEDIA_ENGINE_EVENT.CANPLAYTHROUGH;
pub const MF_MEDIA_ENGINE_EVENT_SEEKING = MF_MEDIA_ENGINE_EVENT.SEEKING;
pub const MF_MEDIA_ENGINE_EVENT_SEEKED = MF_MEDIA_ENGINE_EVENT.SEEKED;
pub const MF_MEDIA_ENGINE_EVENT_TIMEUPDATE = MF_MEDIA_ENGINE_EVENT.TIMEUPDATE;
pub const MF_MEDIA_ENGINE_EVENT_ENDED = MF_MEDIA_ENGINE_EVENT.ENDED;
pub const MF_MEDIA_ENGINE_EVENT_RATECHANGE = MF_MEDIA_ENGINE_EVENT.RATECHANGE;
pub const MF_MEDIA_ENGINE_EVENT_DURATIONCHANGE = MF_MEDIA_ENGINE_EVENT.DURATIONCHANGE;
pub const MF_MEDIA_ENGINE_EVENT_VOLUMECHANGE = MF_MEDIA_ENGINE_EVENT.VOLUMECHANGE;
pub const MF_MEDIA_ENGINE_EVENT_FORMATCHANGE = MF_MEDIA_ENGINE_EVENT.FORMATCHANGE;
pub const MF_MEDIA_ENGINE_EVENT_PURGEQUEUEDEVENTS = MF_MEDIA_ENGINE_EVENT.PURGEQUEUEDEVENTS;
pub const MF_MEDIA_ENGINE_EVENT_TIMELINE_MARKER = MF_MEDIA_ENGINE_EVENT.TIMELINE_MARKER;
pub const MF_MEDIA_ENGINE_EVENT_BALANCECHANGE = MF_MEDIA_ENGINE_EVENT.BALANCECHANGE;
pub const MF_MEDIA_ENGINE_EVENT_DOWNLOADCOMPLETE = MF_MEDIA_ENGINE_EVENT.DOWNLOADCOMPLETE;
pub const MF_MEDIA_ENGINE_EVENT_BUFFERINGSTARTED = MF_MEDIA_ENGINE_EVENT.BUFFERINGSTARTED;
pub const MF_MEDIA_ENGINE_EVENT_BUFFERINGENDED = MF_MEDIA_ENGINE_EVENT.BUFFERINGENDED;
pub const MF_MEDIA_ENGINE_EVENT_FRAMESTEPCOMPLETED = MF_MEDIA_ENGINE_EVENT.FRAMESTEPCOMPLETED;
pub const MF_MEDIA_ENGINE_EVENT_NOTIFYSTABLESTATE = MF_MEDIA_ENGINE_EVENT.NOTIFYSTABLESTATE;
pub const MF_MEDIA_ENGINE_EVENT_FIRSTFRAMEREADY = MF_MEDIA_ENGINE_EVENT.FIRSTFRAMEREADY;
pub const MF_MEDIA_ENGINE_EVENT_TRACKSCHANGE = MF_MEDIA_ENGINE_EVENT.TRACKSCHANGE;
pub const MF_MEDIA_ENGINE_EVENT_OPMINFO = MF_MEDIA_ENGINE_EVENT.OPMINFO;
pub const MF_MEDIA_ENGINE_EVENT_RESOURCELOST = MF_MEDIA_ENGINE_EVENT.RESOURCELOST;
pub const MF_MEDIA_ENGINE_EVENT_DELAYLOADEVENT_CHANGED = MF_MEDIA_ENGINE_EVENT.DELAYLOADEVENT_CHANGED;
pub const MF_MEDIA_ENGINE_EVENT_STREAMRENDERINGERROR = MF_MEDIA_ENGINE_EVENT.STREAMRENDERINGERROR;
pub const MF_MEDIA_ENGINE_EVENT_SUPPORTEDRATES_CHANGED = MF_MEDIA_ENGINE_EVENT.SUPPORTEDRATES_CHANGED;
pub const MF_MEDIA_ENGINE_EVENT_AUDIOENDPOINTCHANGE = MF_MEDIA_ENGINE_EVENT.AUDIOENDPOINTCHANGE;

const IID_IMFMediaEngineNotify_Value = @import("../zig.zig").Guid.initString("FEE7C112-E776-42B5-9BBF-0048524E2BD5");
pub const IID_IMFMediaEngineNotify = &IID_IMFMediaEngineNotify_Value;
pub const IMFMediaEngineNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EventNotify: fn(
            self: *const IMFMediaEngineNotify,
            event: u32,
            param1: ?*c_void,
            param2: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineNotify_EventNotify(self: *const T, event: u32, param1: ?*c_void, param2: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineNotify.VTable, self.vtable).EventNotify(@ptrCast(*const IMFMediaEngineNotify, self), event, param1, param2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineSrcElements_Value = @import("../zig.zig").Guid.initString("7A5E5354-B114-4C72-B991-3131D75032EA");
pub const IID_IMFMediaEngineSrcElements = &IID_IMFMediaEngineSrcElements_Value;
pub const IMFMediaEngineSrcElements = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: fn(
            self: *const IMFMediaEngineSrcElements,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetURL: fn(
            self: *const IMFMediaEngineSrcElements,
            index: u32,
            pURL: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const IMFMediaEngineSrcElements,
            index: u32,
            pType: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMedia: fn(
            self: *const IMFMediaEngineSrcElements,
            index: u32,
            pMedia: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddElement: fn(
            self: *const IMFMediaEngineSrcElements,
            pURL: BSTR,
            pType: BSTR,
            pMedia: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllElements: fn(
            self: *const IMFMediaEngineSrcElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSrcElements_GetLength(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFMediaEngineSrcElements.VTable, self.vtable).GetLength(@ptrCast(*const IMFMediaEngineSrcElements, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSrcElements_GetURL(self: *const T, index: u32, pURL: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSrcElements.VTable, self.vtable).GetURL(@ptrCast(*const IMFMediaEngineSrcElements, self), index, pURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSrcElements_GetType(self: *const T, index: u32, pType: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSrcElements.VTable, self.vtable).GetType(@ptrCast(*const IMFMediaEngineSrcElements, self), index, pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSrcElements_GetMedia(self: *const T, index: u32, pMedia: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSrcElements.VTable, self.vtable).GetMedia(@ptrCast(*const IMFMediaEngineSrcElements, self), index, pMedia);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSrcElements_AddElement(self: *const T, pURL: BSTR, pType: BSTR, pMedia: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSrcElements.VTable, self.vtable).AddElement(@ptrCast(*const IMFMediaEngineSrcElements, self), pURL, pType, pMedia);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSrcElements_RemoveAllElements(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSrcElements.VTable, self.vtable).RemoveAllElements(@ptrCast(*const IMFMediaEngineSrcElements, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_NETWORK = extern enum(i32) {
    EMPTY = 0,
    IDLE = 1,
    LOADING = 2,
    NO_SOURCE = 3,
};
pub const MF_MEDIA_ENGINE_NETWORK_EMPTY = MF_MEDIA_ENGINE_NETWORK.EMPTY;
pub const MF_MEDIA_ENGINE_NETWORK_IDLE = MF_MEDIA_ENGINE_NETWORK.IDLE;
pub const MF_MEDIA_ENGINE_NETWORK_LOADING = MF_MEDIA_ENGINE_NETWORK.LOADING;
pub const MF_MEDIA_ENGINE_NETWORK_NO_SOURCE = MF_MEDIA_ENGINE_NETWORK.NO_SOURCE;

pub const MF_MEDIA_ENGINE_READY = extern enum(i32) {
    HAVE_NOTHING = 0,
    HAVE_METADATA = 1,
    HAVE_CURRENT_DATA = 2,
    HAVE_FUTURE_DATA = 3,
    HAVE_ENOUGH_DATA = 4,
};
pub const MF_MEDIA_ENGINE_READY_HAVE_NOTHING = MF_MEDIA_ENGINE_READY.HAVE_NOTHING;
pub const MF_MEDIA_ENGINE_READY_HAVE_METADATA = MF_MEDIA_ENGINE_READY.HAVE_METADATA;
pub const MF_MEDIA_ENGINE_READY_HAVE_CURRENT_DATA = MF_MEDIA_ENGINE_READY.HAVE_CURRENT_DATA;
pub const MF_MEDIA_ENGINE_READY_HAVE_FUTURE_DATA = MF_MEDIA_ENGINE_READY.HAVE_FUTURE_DATA;
pub const MF_MEDIA_ENGINE_READY_HAVE_ENOUGH_DATA = MF_MEDIA_ENGINE_READY.HAVE_ENOUGH_DATA;

pub const MF_MEDIA_ENGINE_CANPLAY = extern enum(i32) {
    NOT_SUPPORTED = 0,
    MAYBE = 1,
    PROBABLY = 2,
};
pub const MF_MEDIA_ENGINE_CANPLAY_NOT_SUPPORTED = MF_MEDIA_ENGINE_CANPLAY.NOT_SUPPORTED;
pub const MF_MEDIA_ENGINE_CANPLAY_MAYBE = MF_MEDIA_ENGINE_CANPLAY.MAYBE;
pub const MF_MEDIA_ENGINE_CANPLAY_PROBABLY = MF_MEDIA_ENGINE_CANPLAY.PROBABLY;

pub const MF_MEDIA_ENGINE_PRELOAD = extern enum(i32) {
    MISSING = 0,
    EMPTY = 1,
    NONE = 2,
    METADATA = 3,
    AUTOMATIC = 4,
};
pub const MF_MEDIA_ENGINE_PRELOAD_MISSING = MF_MEDIA_ENGINE_PRELOAD.MISSING;
pub const MF_MEDIA_ENGINE_PRELOAD_EMPTY = MF_MEDIA_ENGINE_PRELOAD.EMPTY;
pub const MF_MEDIA_ENGINE_PRELOAD_NONE = MF_MEDIA_ENGINE_PRELOAD.NONE;
pub const MF_MEDIA_ENGINE_PRELOAD_METADATA = MF_MEDIA_ENGINE_PRELOAD.METADATA;
pub const MF_MEDIA_ENGINE_PRELOAD_AUTOMATIC = MF_MEDIA_ENGINE_PRELOAD.AUTOMATIC;

const IID_IMFMediaEngine_Value = @import("../zig.zig").Guid.initString("98A1B0BB-03EB-4935-AE7C-93C1FA0E1C93");
pub const IID_IMFMediaEngine = &IID_IMFMediaEngine_Value;
pub const IMFMediaEngine = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetError: fn(
            self: *const IMFMediaEngine,
            ppError: **IMFMediaError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetErrorCode: fn(
            self: *const IMFMediaEngine,
            @"error": MF_MEDIA_ENGINE_ERR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourceElements: fn(
            self: *const IMFMediaEngine,
            pSrcElements: *IMFMediaEngineSrcElements,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSource: fn(
            self: *const IMFMediaEngine,
            pUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSource: fn(
            self: *const IMFMediaEngine,
            ppUrl: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNetworkState: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) u16,
        GetPreload: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) MF_MEDIA_ENGINE_PRELOAD,
        SetPreload: fn(
            self: *const IMFMediaEngine,
            Preload: MF_MEDIA_ENGINE_PRELOAD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffered: fn(
            self: *const IMFMediaEngine,
            ppBuffered: **IMFMediaTimeRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanPlayType: fn(
            self: *const IMFMediaEngine,
            type: BSTR,
            pAnswer: *MF_MEDIA_ENGINE_CANPLAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReadyState: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) u16,
        IsSeeking: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetCurrentTime: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        SetCurrentTime: fn(
            self: *const IMFMediaEngine,
            seekTime: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartTime: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        GetDuration: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        IsPaused: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetDefaultPlaybackRate: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        SetDefaultPlaybackRate: fn(
            self: *const IMFMediaEngine,
            Rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPlaybackRate: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        SetPlaybackRate: fn(
            self: *const IMFMediaEngine,
            Rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPlayed: fn(
            self: *const IMFMediaEngine,
            ppPlayed: **IMFMediaTimeRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSeekable: fn(
            self: *const IMFMediaEngine,
            ppSeekable: **IMFMediaTimeRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEnded: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetAutoPlay: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        SetAutoPlay: fn(
            self: *const IMFMediaEngine,
            AutoPlay: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLoop: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        SetLoop: fn(
            self: *const IMFMediaEngine,
            Loop: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Play: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMuted: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        SetMuted: fn(
            self: *const IMFMediaEngine,
            Muted: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolume: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        SetVolume: fn(
            self: *const IMFMediaEngine,
            Volume: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasVideo: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        HasAudio: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetNativeVideoSize: fn(
            self: *const IMFMediaEngine,
            cx: ?*u32,
            cy: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoAspectRatio: fn(
            self: *const IMFMediaEngine,
            cx: ?*u32,
            cy: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransferVideoFrame: fn(
            self: *const IMFMediaEngine,
            pDstSurf: *IUnknown,
            pSrc: ?*const MFVideoNormalizedRect,
            pDst: *const RECT,
            pBorderClr: ?*const MFARGB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnVideoStreamTick: fn(
            self: *const IMFMediaEngine,
            pPts: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetError(self: *const T, ppError: **IMFMediaError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetError(@ptrCast(*const IMFMediaEngine, self), ppError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetErrorCode(self: *const T, @"error": MF_MEDIA_ENGINE_ERR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetErrorCode(@ptrCast(*const IMFMediaEngine, self), @"error");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetSourceElements(self: *const T, pSrcElements: *IMFMediaEngineSrcElements) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetSourceElements(@ptrCast(*const IMFMediaEngine, self), pSrcElements);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetSource(self: *const T, pUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetSource(@ptrCast(*const IMFMediaEngine, self), pUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetCurrentSource(self: *const T, ppUrl: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetCurrentSource(@ptrCast(*const IMFMediaEngine, self), ppUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetNetworkState(self: *const T) callconv(.Inline) u16 {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetNetworkState(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetPreload(self: *const T) callconv(.Inline) MF_MEDIA_ENGINE_PRELOAD {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetPreload(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetPreload(self: *const T, Preload: MF_MEDIA_ENGINE_PRELOAD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetPreload(@ptrCast(*const IMFMediaEngine, self), Preload);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetBuffered(self: *const T, ppBuffered: **IMFMediaTimeRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetBuffered(@ptrCast(*const IMFMediaEngine, self), ppBuffered);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_Load(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).Load(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_CanPlayType(self: *const T, type: BSTR, pAnswer: *MF_MEDIA_ENGINE_CANPLAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).CanPlayType(@ptrCast(*const IMFMediaEngine, self), type, pAnswer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetReadyState(self: *const T) callconv(.Inline) u16 {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetReadyState(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_IsSeeking(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).IsSeeking(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetCurrentTime(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetCurrentTime(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetCurrentTime(self: *const T, seekTime: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetCurrentTime(@ptrCast(*const IMFMediaEngine, self), seekTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetStartTime(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetStartTime(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetDuration(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetDuration(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_IsPaused(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).IsPaused(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetDefaultPlaybackRate(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetDefaultPlaybackRate(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetDefaultPlaybackRate(self: *const T, Rate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetDefaultPlaybackRate(@ptrCast(*const IMFMediaEngine, self), Rate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetPlaybackRate(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetPlaybackRate(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetPlaybackRate(self: *const T, Rate: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetPlaybackRate(@ptrCast(*const IMFMediaEngine, self), Rate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetPlayed(self: *const T, ppPlayed: **IMFMediaTimeRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetPlayed(@ptrCast(*const IMFMediaEngine, self), ppPlayed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetSeekable(self: *const T, ppSeekable: **IMFMediaTimeRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetSeekable(@ptrCast(*const IMFMediaEngine, self), ppSeekable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_IsEnded(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).IsEnded(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetAutoPlay(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetAutoPlay(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetAutoPlay(self: *const T, AutoPlay: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetAutoPlay(@ptrCast(*const IMFMediaEngine, self), AutoPlay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetLoop(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetLoop(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetLoop(self: *const T, Loop: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetLoop(@ptrCast(*const IMFMediaEngine, self), Loop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_Play(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).Play(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).Pause(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetMuted(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetMuted(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetMuted(self: *const T, Muted: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetMuted(@ptrCast(*const IMFMediaEngine, self), Muted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetVolume(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetVolume(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_SetVolume(self: *const T, Volume: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).SetVolume(@ptrCast(*const IMFMediaEngine, self), Volume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_HasVideo(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).HasVideo(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_HasAudio(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).HasAudio(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetNativeVideoSize(self: *const T, cx: ?*u32, cy: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetNativeVideoSize(@ptrCast(*const IMFMediaEngine, self), cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_GetVideoAspectRatio(self: *const T, cx: ?*u32, cy: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).GetVideoAspectRatio(@ptrCast(*const IMFMediaEngine, self), cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).Shutdown(@ptrCast(*const IMFMediaEngine, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_TransferVideoFrame(self: *const T, pDstSurf: *IUnknown, pSrc: ?*const MFVideoNormalizedRect, pDst: *const RECT, pBorderClr: ?*const MFARGB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).TransferVideoFrame(@ptrCast(*const IMFMediaEngine, self), pDstSurf, pSrc, pDst, pBorderClr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngine_OnVideoStreamTick(self: *const T, pPts: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngine.VTable, self.vtable).OnVideoStreamTick(@ptrCast(*const IMFMediaEngine, self), pPts);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE = extern enum(i32) {
    NONE = 0,
    SIDE_BY_SIDE = 1,
    TOP_BOTTOM = 2,
};
pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE_NONE = MF_MEDIA_ENGINE_S3D_PACKING_MODE.NONE;
pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE_SIDE_BY_SIDE = MF_MEDIA_ENGINE_S3D_PACKING_MODE.SIDE_BY_SIDE;
pub const MF_MEDIA_ENGINE_S3D_PACKING_MODE_TOP_BOTTOM = MF_MEDIA_ENGINE_S3D_PACKING_MODE.TOP_BOTTOM;

pub const MF_MEDIA_ENGINE_STATISTIC = extern enum(i32) {
    FRAMES_RENDERED = 0,
    FRAMES_DROPPED = 1,
    BYTES_DOWNLOADED = 2,
    BUFFER_PROGRESS = 3,
    FRAMES_PER_SECOND = 4,
    PLAYBACK_JITTER = 5,
    FRAMES_CORRUPTED = 6,
    TOTAL_FRAME_DELAY = 7,
};
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_RENDERED = MF_MEDIA_ENGINE_STATISTIC.FRAMES_RENDERED;
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_DROPPED = MF_MEDIA_ENGINE_STATISTIC.FRAMES_DROPPED;
pub const MF_MEDIA_ENGINE_STATISTIC_BYTES_DOWNLOADED = MF_MEDIA_ENGINE_STATISTIC.BYTES_DOWNLOADED;
pub const MF_MEDIA_ENGINE_STATISTIC_BUFFER_PROGRESS = MF_MEDIA_ENGINE_STATISTIC.BUFFER_PROGRESS;
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_PER_SECOND = MF_MEDIA_ENGINE_STATISTIC.FRAMES_PER_SECOND;
pub const MF_MEDIA_ENGINE_STATISTIC_PLAYBACK_JITTER = MF_MEDIA_ENGINE_STATISTIC.PLAYBACK_JITTER;
pub const MF_MEDIA_ENGINE_STATISTIC_FRAMES_CORRUPTED = MF_MEDIA_ENGINE_STATISTIC.FRAMES_CORRUPTED;
pub const MF_MEDIA_ENGINE_STATISTIC_TOTAL_FRAME_DELAY = MF_MEDIA_ENGINE_STATISTIC.TOTAL_FRAME_DELAY;

pub const MF_MEDIA_ENGINE_SEEK_MODE = extern enum(i32) {
    NORMAL = 0,
    APPROXIMATE = 1,
};
pub const MF_MEDIA_ENGINE_SEEK_MODE_NORMAL = MF_MEDIA_ENGINE_SEEK_MODE.NORMAL;
pub const MF_MEDIA_ENGINE_SEEK_MODE_APPROXIMATE = MF_MEDIA_ENGINE_SEEK_MODE.APPROXIMATE;

const IID_IMFMediaEngineEx_Value = @import("../zig.zig").Guid.initString("83015EAD-B1E6-40D0-A98A-37145FFE1AD1");
pub const IID_IMFMediaEngineEx = &IID_IMFMediaEngineEx_Value;
pub const IMFMediaEngineEx = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEngine.VTable,
        SetSourceFromByteStream: fn(
            self: *const IMFMediaEngineEx,
            pByteStream: *IMFByteStream,
            pURL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatistics: fn(
            self: *const IMFMediaEngineEx,
            StatisticID: MF_MEDIA_ENGINE_STATISTIC,
            pStatistic: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateVideoStream: fn(
            self: *const IMFMediaEngineEx,
            pSrc: ?*const MFVideoNormalizedRect,
            pDst: ?*const RECT,
            pBorderClr: ?*const MFARGB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBalance: fn(
            self: *const IMFMediaEngineEx,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        SetBalance: fn(
            self: *const IMFMediaEngineEx,
            balance: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPlaybackRateSupported: fn(
            self: *const IMFMediaEngineEx,
            rate: f64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        FrameStep: fn(
            self: *const IMFMediaEngineEx,
            Forward: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResourceCharacteristics: fn(
            self: *const IMFMediaEngineEx,
            pCharacteristics: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPresentationAttribute: fn(
            self: *const IMFMediaEngineEx,
            guidMFAttribute: *const Guid,
            pvValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfStreams: fn(
            self: *const IMFMediaEngineEx,
            pdwStreamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamAttribute: fn(
            self: *const IMFMediaEngineEx,
            dwStreamIndex: u32,
            guidMFAttribute: *const Guid,
            pvValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamSelection: fn(
            self: *const IMFMediaEngineEx,
            dwStreamIndex: u32,
            pEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamSelection: fn(
            self: *const IMFMediaEngineEx,
            dwStreamIndex: u32,
            Enabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyStreamSelections: fn(
            self: *const IMFMediaEngineEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsProtected: fn(
            self: *const IMFMediaEngineEx,
            pProtected: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertVideoEffect: fn(
            self: *const IMFMediaEngineEx,
            pEffect: *IUnknown,
            fOptional: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertAudioEffect: fn(
            self: *const IMFMediaEngineEx,
            pEffect: *IUnknown,
            fOptional: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllEffects: fn(
            self: *const IMFMediaEngineEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTimelineMarkerTimer: fn(
            self: *const IMFMediaEngineEx,
            timeToFire: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimelineMarkerTimer: fn(
            self: *const IMFMediaEngineEx,
            pTimeToFire: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelTimelineMarkerTimer: fn(
            self: *const IMFMediaEngineEx,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsStereo3D: fn(
            self: *const IMFMediaEngineEx,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetStereo3DFramePackingMode: fn(
            self: *const IMFMediaEngineEx,
            packMode: *MF_MEDIA_ENGINE_S3D_PACKING_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStereo3DFramePackingMode: fn(
            self: *const IMFMediaEngineEx,
            packMode: MF_MEDIA_ENGINE_S3D_PACKING_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStereo3DRenderMode: fn(
            self: *const IMFMediaEngineEx,
            outputType: *MF3DVideoOutputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStereo3DRenderMode: fn(
            self: *const IMFMediaEngineEx,
            outputType: MF3DVideoOutputType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableWindowlessSwapchainMode: fn(
            self: *const IMFMediaEngineEx,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoSwapchainHandle: fn(
            self: *const IMFMediaEngineEx,
            phSwapchain: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableHorizontalMirrorMode: fn(
            self: *const IMFMediaEngineEx,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioStreamCategory: fn(
            self: *const IMFMediaEngineEx,
            pCategory: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAudioStreamCategory: fn(
            self: *const IMFMediaEngineEx,
            category: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioEndpointRole: fn(
            self: *const IMFMediaEngineEx,
            pRole: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAudioEndpointRole: fn(
            self: *const IMFMediaEngineEx,
            role: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRealTimeMode: fn(
            self: *const IMFMediaEngineEx,
            pfEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRealTimeMode: fn(
            self: *const IMFMediaEngineEx,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentTimeEx: fn(
            self: *const IMFMediaEngineEx,
            seekTime: f64,
            seekMode: MF_MEDIA_ENGINE_SEEK_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableTimeUpdateTimer: fn(
            self: *const IMFMediaEngineEx,
            fEnableTimer: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaEngine.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetSourceFromByteStream(self: *const T, pByteStream: *IMFByteStream, pURL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetSourceFromByteStream(@ptrCast(*const IMFMediaEngineEx, self), pByteStream, pURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetStatistics(self: *const T, StatisticID: MF_MEDIA_ENGINE_STATISTIC, pStatistic: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetStatistics(@ptrCast(*const IMFMediaEngineEx, self), StatisticID, pStatistic);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_UpdateVideoStream(self: *const T, pSrc: ?*const MFVideoNormalizedRect, pDst: ?*const RECT, pBorderClr: ?*const MFARGB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).UpdateVideoStream(@ptrCast(*const IMFMediaEngineEx, self), pSrc, pDst, pBorderClr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetBalance(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetBalance(@ptrCast(*const IMFMediaEngineEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetBalance(self: *const T, balance: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetBalance(@ptrCast(*const IMFMediaEngineEx, self), balance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_IsPlaybackRateSupported(self: *const T, rate: f64) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).IsPlaybackRateSupported(@ptrCast(*const IMFMediaEngineEx, self), rate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_FrameStep(self: *const T, Forward: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).FrameStep(@ptrCast(*const IMFMediaEngineEx, self), Forward);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetResourceCharacteristics(self: *const T, pCharacteristics: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetResourceCharacteristics(@ptrCast(*const IMFMediaEngineEx, self), pCharacteristics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetPresentationAttribute(self: *const T, guidMFAttribute: *const Guid, pvValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetPresentationAttribute(@ptrCast(*const IMFMediaEngineEx, self), guidMFAttribute, pvValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetNumberOfStreams(self: *const T, pdwStreamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetNumberOfStreams(@ptrCast(*const IMFMediaEngineEx, self), pdwStreamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetStreamAttribute(self: *const T, dwStreamIndex: u32, guidMFAttribute: *const Guid, pvValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetStreamAttribute(@ptrCast(*const IMFMediaEngineEx, self), dwStreamIndex, guidMFAttribute, pvValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetStreamSelection(self: *const T, dwStreamIndex: u32, pEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetStreamSelection(@ptrCast(*const IMFMediaEngineEx, self), dwStreamIndex, pEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetStreamSelection(self: *const T, dwStreamIndex: u32, Enabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetStreamSelection(@ptrCast(*const IMFMediaEngineEx, self), dwStreamIndex, Enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_ApplyStreamSelections(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).ApplyStreamSelections(@ptrCast(*const IMFMediaEngineEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_IsProtected(self: *const T, pProtected: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).IsProtected(@ptrCast(*const IMFMediaEngineEx, self), pProtected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_InsertVideoEffect(self: *const T, pEffect: *IUnknown, fOptional: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).InsertVideoEffect(@ptrCast(*const IMFMediaEngineEx, self), pEffect, fOptional);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_InsertAudioEffect(self: *const T, pEffect: *IUnknown, fOptional: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).InsertAudioEffect(@ptrCast(*const IMFMediaEngineEx, self), pEffect, fOptional);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_RemoveAllEffects(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).RemoveAllEffects(@ptrCast(*const IMFMediaEngineEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetTimelineMarkerTimer(self: *const T, timeToFire: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetTimelineMarkerTimer(@ptrCast(*const IMFMediaEngineEx, self), timeToFire);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetTimelineMarkerTimer(self: *const T, pTimeToFire: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetTimelineMarkerTimer(@ptrCast(*const IMFMediaEngineEx, self), pTimeToFire);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_CancelTimelineMarkerTimer(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).CancelTimelineMarkerTimer(@ptrCast(*const IMFMediaEngineEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_IsStereo3D(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).IsStereo3D(@ptrCast(*const IMFMediaEngineEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetStereo3DFramePackingMode(self: *const T, packMode: *MF_MEDIA_ENGINE_S3D_PACKING_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetStereo3DFramePackingMode(@ptrCast(*const IMFMediaEngineEx, self), packMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetStereo3DFramePackingMode(self: *const T, packMode: MF_MEDIA_ENGINE_S3D_PACKING_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetStereo3DFramePackingMode(@ptrCast(*const IMFMediaEngineEx, self), packMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetStereo3DRenderMode(self: *const T, outputType: *MF3DVideoOutputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetStereo3DRenderMode(@ptrCast(*const IMFMediaEngineEx, self), outputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetStereo3DRenderMode(self: *const T, outputType: MF3DVideoOutputType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetStereo3DRenderMode(@ptrCast(*const IMFMediaEngineEx, self), outputType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_EnableWindowlessSwapchainMode(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).EnableWindowlessSwapchainMode(@ptrCast(*const IMFMediaEngineEx, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetVideoSwapchainHandle(self: *const T, phSwapchain: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetVideoSwapchainHandle(@ptrCast(*const IMFMediaEngineEx, self), phSwapchain);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_EnableHorizontalMirrorMode(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).EnableHorizontalMirrorMode(@ptrCast(*const IMFMediaEngineEx, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetAudioStreamCategory(self: *const T, pCategory: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetAudioStreamCategory(@ptrCast(*const IMFMediaEngineEx, self), pCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetAudioStreamCategory(self: *const T, category: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetAudioStreamCategory(@ptrCast(*const IMFMediaEngineEx, self), category);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetAudioEndpointRole(self: *const T, pRole: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetAudioEndpointRole(@ptrCast(*const IMFMediaEngineEx, self), pRole);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetAudioEndpointRole(self: *const T, role: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetAudioEndpointRole(@ptrCast(*const IMFMediaEngineEx, self), role);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_GetRealTimeMode(self: *const T, pfEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).GetRealTimeMode(@ptrCast(*const IMFMediaEngineEx, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetRealTimeMode(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetRealTimeMode(@ptrCast(*const IMFMediaEngineEx, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_SetCurrentTimeEx(self: *const T, seekTime: f64, seekMode: MF_MEDIA_ENGINE_SEEK_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).SetCurrentTimeEx(@ptrCast(*const IMFMediaEngineEx, self), seekTime, seekMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEx_EnableTimeUpdateTimer(self: *const T, fEnableTimer: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEx.VTable, self.vtable).EnableTimeUpdateTimer(@ptrCast(*const IMFMediaEngineEx, self), fEnableTimer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineAudioEndpointId_Value = @import("../zig.zig").Guid.initString("7A3BAC98-0E76-49FB-8C20-8A86FD98EAF2");
pub const IID_IMFMediaEngineAudioEndpointId = &IID_IMFMediaEngineAudioEndpointId_Value;
pub const IMFMediaEngineAudioEndpointId = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAudioEndpointId: fn(
            self: *const IMFMediaEngineAudioEndpointId,
            pszEndpointId: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAudioEndpointId: fn(
            self: *const IMFMediaEngineAudioEndpointId,
            ppszEndpointId: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineAudioEndpointId_SetAudioEndpointId(self: *const T, pszEndpointId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineAudioEndpointId.VTable, self.vtable).SetAudioEndpointId(@ptrCast(*const IMFMediaEngineAudioEndpointId, self), pszEndpointId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineAudioEndpointId_GetAudioEndpointId(self: *const T, ppszEndpointId: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineAudioEndpointId.VTable, self.vtable).GetAudioEndpointId(@ptrCast(*const IMFMediaEngineAudioEndpointId, self), ppszEndpointId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_EXTENSION_TYPE = extern enum(i32) {
    MEDIASOURCE = 0,
    BYTESTREAM = 1,
};
pub const MF_MEDIA_ENGINE_EXTENSION_TYPE_MEDIASOURCE = MF_MEDIA_ENGINE_EXTENSION_TYPE.MEDIASOURCE;
pub const MF_MEDIA_ENGINE_EXTENSION_TYPE_BYTESTREAM = MF_MEDIA_ENGINE_EXTENSION_TYPE.BYTESTREAM;

const IID_IMFMediaEngineExtension_Value = @import("../zig.zig").Guid.initString("2F69D622-20B5-41E9-AFDF-89CED1DDA04E");
pub const IID_IMFMediaEngineExtension = &IID_IMFMediaEngineExtension_Value;
pub const IMFMediaEngineExtension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanPlayType: fn(
            self: *const IMFMediaEngineExtension,
            AudioOnly: BOOL,
            MimeType: BSTR,
            pAnswer: *MF_MEDIA_ENGINE_CANPLAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginCreateObject: fn(
            self: *const IMFMediaEngineExtension,
            bstrURL: BSTR,
            pByteStream: ?*IMFByteStream,
            type: MF_OBJECT_TYPE,
            ppIUnknownCancelCookie: **IUnknown,
            pCallback: *IMFAsyncCallback,
            punkState: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CancelObjectCreation: fn(
            self: *const IMFMediaEngineExtension,
            pIUnknownCancelCookie: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndCreateObject: fn(
            self: *const IMFMediaEngineExtension,
            pResult: *IMFAsyncResult,
            ppObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineExtension_CanPlayType(self: *const T, AudioOnly: BOOL, MimeType: BSTR, pAnswer: *MF_MEDIA_ENGINE_CANPLAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineExtension.VTable, self.vtable).CanPlayType(@ptrCast(*const IMFMediaEngineExtension, self), AudioOnly, MimeType, pAnswer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineExtension_BeginCreateObject(self: *const T, bstrURL: BSTR, pByteStream: ?*IMFByteStream, type: MF_OBJECT_TYPE, ppIUnknownCancelCookie: **IUnknown, pCallback: *IMFAsyncCallback, punkState: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineExtension.VTable, self.vtable).BeginCreateObject(@ptrCast(*const IMFMediaEngineExtension, self), bstrURL, pByteStream, type, ppIUnknownCancelCookie, pCallback, punkState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineExtension_CancelObjectCreation(self: *const T, pIUnknownCancelCookie: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineExtension.VTable, self.vtable).CancelObjectCreation(@ptrCast(*const IMFMediaEngineExtension, self), pIUnknownCancelCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineExtension_EndCreateObject(self: *const T, pResult: *IMFAsyncResult, ppObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineExtension.VTable, self.vtable).EndCreateObject(@ptrCast(*const IMFMediaEngineExtension, self), pResult, ppObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS = extern enum(i32) {
    MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED = 1,
    MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION = 2,
    MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION = 4,
};
pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED = MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS.MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_PROTECTED;
pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION = MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS.MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_SURFACE_PROTECTION;
pub const MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION = MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAGS.MF_MEDIA_ENGINE_FRAME_PROTECTION_FLAG_REQUIRES_ANTI_SCREEN_SCRAPE_PROTECTION;

const IID_IMFMediaEngineProtectedContent_Value = @import("../zig.zig").Guid.initString("9F8021E8-9C8C-487E-BB5C-79AA4779938C");
pub const IID_IMFMediaEngineProtectedContent = &IID_IMFMediaEngineProtectedContent_Value;
pub const IMFMediaEngineProtectedContent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShareResources: fn(
            self: *const IMFMediaEngineProtectedContent,
            pUnkDeviceContext: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRequiredProtections: fn(
            self: *const IMFMediaEngineProtectedContent,
            pFrameProtectionFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOPMWindow: fn(
            self: *const IMFMediaEngineProtectedContent,
            hwnd: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransferVideoFrame: fn(
            self: *const IMFMediaEngineProtectedContent,
            pDstSurf: *IUnknown,
            pSrc: ?*const MFVideoNormalizedRect,
            pDst: *const RECT,
            pBorderClr: ?*const MFARGB,
            pFrameProtectionFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetContentProtectionManager: fn(
            self: *const IMFMediaEngineProtectedContent,
            pCPM: ?*IMFContentProtectionManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationCertificate: fn(
            self: *const IMFMediaEngineProtectedContent,
            pbBlob: [*:0]const u8,
            cbBlob: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineProtectedContent_ShareResources(self: *const T, pUnkDeviceContext: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineProtectedContent.VTable, self.vtable).ShareResources(@ptrCast(*const IMFMediaEngineProtectedContent, self), pUnkDeviceContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineProtectedContent_GetRequiredProtections(self: *const T, pFrameProtectionFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineProtectedContent.VTable, self.vtable).GetRequiredProtections(@ptrCast(*const IMFMediaEngineProtectedContent, self), pFrameProtectionFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineProtectedContent_SetOPMWindow(self: *const T, hwnd: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineProtectedContent.VTable, self.vtable).SetOPMWindow(@ptrCast(*const IMFMediaEngineProtectedContent, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineProtectedContent_TransferVideoFrame(self: *const T, pDstSurf: *IUnknown, pSrc: ?*const MFVideoNormalizedRect, pDst: *const RECT, pBorderClr: ?*const MFARGB, pFrameProtectionFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineProtectedContent.VTable, self.vtable).TransferVideoFrame(@ptrCast(*const IMFMediaEngineProtectedContent, self), pDstSurf, pSrc, pDst, pBorderClr, pFrameProtectionFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineProtectedContent_SetContentProtectionManager(self: *const T, pCPM: ?*IMFContentProtectionManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineProtectedContent.VTable, self.vtable).SetContentProtectionManager(@ptrCast(*const IMFMediaEngineProtectedContent, self), pCPM);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineProtectedContent_SetApplicationCertificate(self: *const T, pbBlob: [*:0]const u8, cbBlob: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineProtectedContent.VTable, self.vtable).SetApplicationCertificate(@ptrCast(*const IMFMediaEngineProtectedContent, self), pbBlob, cbBlob);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAudioSourceProvider_Value = @import("../zig.zig").Guid.initString("EBBAF249-AFC2-4582-91C6-B60DF2E84954");
pub const IID_IAudioSourceProvider = &IID_IAudioSourceProvider_Value;
pub const IAudioSourceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ProvideInput: fn(
            self: *const IAudioSourceProvider,
            dwSampleCount: u32,
            pdwChannelCount: *u32,
            pInterleavedAudioData: ?*f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAudioSourceProvider_ProvideInput(self: *const T, dwSampleCount: u32, pdwChannelCount: *u32, pInterleavedAudioData: ?*f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAudioSourceProvider.VTable, self.vtable).ProvideInput(@ptrCast(*const IAudioSourceProvider, self), dwSampleCount, pdwChannelCount, pInterleavedAudioData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineWebSupport_Value = @import("../zig.zig").Guid.initString("BA2743A1-07E0-48EF-84B6-9A2ED023CA6C");
pub const IID_IMFMediaEngineWebSupport = &IID_IMFMediaEngineWebSupport_Value;
pub const IMFMediaEngineWebSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShouldDelayTheLoadEvent: fn(
            self: *const IMFMediaEngineWebSupport,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        ConnectWebAudio: fn(
            self: *const IMFMediaEngineWebSupport,
            dwSampleRate: u32,
            ppSourceProvider: **IAudioSourceProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectWebAudio: fn(
            self: *const IMFMediaEngineWebSupport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineWebSupport_ShouldDelayTheLoadEvent(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaEngineWebSupport.VTable, self.vtable).ShouldDelayTheLoadEvent(@ptrCast(*const IMFMediaEngineWebSupport, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineWebSupport_ConnectWebAudio(self: *const T, dwSampleRate: u32, ppSourceProvider: **IAudioSourceProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineWebSupport.VTable, self.vtable).ConnectWebAudio(@ptrCast(*const IMFMediaEngineWebSupport, self), dwSampleRate, ppSourceProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineWebSupport_DisconnectWebAudio(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineWebSupport.VTable, self.vtable).DisconnectWebAudio(@ptrCast(*const IMFMediaEngineWebSupport, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MSE_VP9_SUPPORT_TYPE = extern enum(i32) {
    MF_MSE_VP9_SUPPORT_DEFAULT = 0,
    MF_MSE_VP9_SUPPORT_ON = 1,
    MF_MSE_VP9_SUPPORT_OFF = 2,
};
pub const MF_MSE_VP9_SUPPORT_DEFAULT = MF_MSE_VP9_SUPPORT_TYPE.MF_MSE_VP9_SUPPORT_DEFAULT;
pub const MF_MSE_VP9_SUPPORT_ON = MF_MSE_VP9_SUPPORT_TYPE.MF_MSE_VP9_SUPPORT_ON;
pub const MF_MSE_VP9_SUPPORT_OFF = MF_MSE_VP9_SUPPORT_TYPE.MF_MSE_VP9_SUPPORT_OFF;

pub const MF_MSE_OPUS_SUPPORT_TYPE = extern enum(i32) {
    MF_MSE_OPUS_SUPPORT_ON = 0,
    MF_MSE_OPUS_SUPPORT_OFF = 1,
};
pub const MF_MSE_OPUS_SUPPORT_ON = MF_MSE_OPUS_SUPPORT_TYPE.MF_MSE_OPUS_SUPPORT_ON;
pub const MF_MSE_OPUS_SUPPORT_OFF = MF_MSE_OPUS_SUPPORT_TYPE.MF_MSE_OPUS_SUPPORT_OFF;

const IID_IMFMediaSourceExtensionNotify_Value = @import("../zig.zig").Guid.initString("A7901327-05DD-4469-A7B7-0E01979E361D");
pub const IID_IMFMediaSourceExtensionNotify = &IID_IMFMediaSourceExtensionNotify_Value;
pub const IMFMediaSourceExtensionNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSourceOpen: fn(
            self: *const IMFMediaSourceExtensionNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnSourceEnded: fn(
            self: *const IMFMediaSourceExtensionNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnSourceClose: fn(
            self: *const IMFMediaSourceExtensionNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtensionNotify_OnSourceOpen(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaSourceExtensionNotify.VTable, self.vtable).OnSourceOpen(@ptrCast(*const IMFMediaSourceExtensionNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtensionNotify_OnSourceEnded(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaSourceExtensionNotify.VTable, self.vtable).OnSourceEnded(@ptrCast(*const IMFMediaSourceExtensionNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtensionNotify_OnSourceClose(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaSourceExtensionNotify.VTable, self.vtable).OnSourceClose(@ptrCast(*const IMFMediaSourceExtensionNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFBufferListNotify_Value = @import("../zig.zig").Guid.initString("24CD47F7-81D8-4785-ADB2-AF697A963CD2");
pub const IID_IMFBufferListNotify = &IID_IMFBufferListNotify_Value;
pub const IMFBufferListNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnAddSourceBuffer: fn(
            self: *const IMFBufferListNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnRemoveSourceBuffer: fn(
            self: *const IMFBufferListNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFBufferListNotify_OnAddSourceBuffer(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFBufferListNotify.VTable, self.vtable).OnAddSourceBuffer(@ptrCast(*const IMFBufferListNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFBufferListNotify_OnRemoveSourceBuffer(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFBufferListNotify.VTable, self.vtable).OnRemoveSourceBuffer(@ptrCast(*const IMFBufferListNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSourceBufferNotify_Value = @import("../zig.zig").Guid.initString("87E47623-2CEB-45D6-9B88-D8520C4DCBBC");
pub const IID_IMFSourceBufferNotify = &IID_IMFSourceBufferNotify_Value;
pub const IMFSourceBufferNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnUpdateStart: fn(
            self: *const IMFSourceBufferNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnAbort: fn(
            self: *const IMFSourceBufferNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnError: fn(
            self: *const IMFSourceBufferNotify,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnUpdate: fn(
            self: *const IMFSourceBufferNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnUpdateEnd: fn(
            self: *const IMFSourceBufferNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBufferNotify_OnUpdateStart(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFSourceBufferNotify.VTable, self.vtable).OnUpdateStart(@ptrCast(*const IMFSourceBufferNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBufferNotify_OnAbort(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFSourceBufferNotify.VTable, self.vtable).OnAbort(@ptrCast(*const IMFSourceBufferNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBufferNotify_OnError(self: *const T, hr: HRESULT) callconv(.Inline) void {
            return @ptrCast(*const IMFSourceBufferNotify.VTable, self.vtable).OnError(@ptrCast(*const IMFSourceBufferNotify, self), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBufferNotify_OnUpdate(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFSourceBufferNotify.VTable, self.vtable).OnUpdate(@ptrCast(*const IMFSourceBufferNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBufferNotify_OnUpdateEnd(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFSourceBufferNotify.VTable, self.vtable).OnUpdateEnd(@ptrCast(*const IMFSourceBufferNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSourceBuffer_Value = @import("../zig.zig").Guid.initString("E2CD3A4B-AF25-4D3D-9110-DA0E6F8EE877");
pub const IID_IMFSourceBuffer = &IID_IMFSourceBuffer_Value;
pub const IMFSourceBuffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUpdating: fn(
            self: *const IMFSourceBuffer,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetBuffered: fn(
            self: *const IMFSourceBuffer,
            ppBuffered: **IMFMediaTimeRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTimeStampOffset: fn(
            self: *const IMFSourceBuffer,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        SetTimeStampOffset: fn(
            self: *const IMFSourceBuffer,
            offset: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppendWindowStart: fn(
            self: *const IMFSourceBuffer,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        SetAppendWindowStart: fn(
            self: *const IMFSourceBuffer,
            time: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAppendWindowEnd: fn(
            self: *const IMFSourceBuffer,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        SetAppendWindowEnd: fn(
            self: *const IMFSourceBuffer,
            time: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: fn(
            self: *const IMFSourceBuffer,
            pData: [*:0]const u8,
            len: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendByteStream: fn(
            self: *const IMFSourceBuffer,
            pStream: *IMFByteStream,
            pMaxLen: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const IMFSourceBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMFSourceBuffer,
            start: f64,
            end: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_GetUpdating(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).GetUpdating(@ptrCast(*const IMFSourceBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_GetBuffered(self: *const T, ppBuffered: **IMFMediaTimeRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).GetBuffered(@ptrCast(*const IMFSourceBuffer, self), ppBuffered);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_GetTimeStampOffset(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).GetTimeStampOffset(@ptrCast(*const IMFSourceBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_SetTimeStampOffset(self: *const T, offset: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).SetTimeStampOffset(@ptrCast(*const IMFSourceBuffer, self), offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_GetAppendWindowStart(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).GetAppendWindowStart(@ptrCast(*const IMFSourceBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_SetAppendWindowStart(self: *const T, time: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).SetAppendWindowStart(@ptrCast(*const IMFSourceBuffer, self), time);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_GetAppendWindowEnd(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).GetAppendWindowEnd(@ptrCast(*const IMFSourceBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_SetAppendWindowEnd(self: *const T, time: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).SetAppendWindowEnd(@ptrCast(*const IMFSourceBuffer, self), time);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_Append(self: *const T, pData: [*:0]const u8, len: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).Append(@ptrCast(*const IMFSourceBuffer, self), pData, len);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_AppendByteStream(self: *const T, pStream: *IMFByteStream, pMaxLen: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).AppendByteStream(@ptrCast(*const IMFSourceBuffer, self), pStream, pMaxLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).Abort(@ptrCast(*const IMFSourceBuffer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBuffer_Remove(self: *const T, start: f64, end: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceBuffer.VTable, self.vtable).Remove(@ptrCast(*const IMFSourceBuffer, self), start, end);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MSE_APPEND_MODE = extern enum(i32) {
    SEGMENTS = 0,
    SEQUENCE = 1,
};
pub const MF_MSE_APPEND_MODE_SEGMENTS = MF_MSE_APPEND_MODE.SEGMENTS;
pub const MF_MSE_APPEND_MODE_SEQUENCE = MF_MSE_APPEND_MODE.SEQUENCE;

const IID_IMFSourceBufferAppendMode_Value = @import("../zig.zig").Guid.initString("19666FB4-BABE-4C55-BC03-0A074DA37E2A");
pub const IID_IMFSourceBufferAppendMode = &IID_IMFSourceBufferAppendMode_Value;
pub const IMFSourceBufferAppendMode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAppendMode: fn(
            self: *const IMFSourceBufferAppendMode,
        ) callconv(@import("std").os.windows.WINAPI) MF_MSE_APPEND_MODE,
        SetAppendMode: fn(
            self: *const IMFSourceBufferAppendMode,
            mode: MF_MSE_APPEND_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBufferAppendMode_GetAppendMode(self: *const T) callconv(.Inline) MF_MSE_APPEND_MODE {
            return @ptrCast(*const IMFSourceBufferAppendMode.VTable, self.vtable).GetAppendMode(@ptrCast(*const IMFSourceBufferAppendMode, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBufferAppendMode_SetAppendMode(self: *const T, mode: MF_MSE_APPEND_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceBufferAppendMode.VTable, self.vtable).SetAppendMode(@ptrCast(*const IMFSourceBufferAppendMode, self), mode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSourceBufferList_Value = @import("../zig.zig").Guid.initString("249981F8-8325-41F3-B80C-3B9E3AAD0CBE");
pub const IID_IMFSourceBufferList = &IID_IMFSourceBufferList_Value;
pub const IMFSourceBufferList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: fn(
            self: *const IMFSourceBufferList,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetSourceBuffer: fn(
            self: *const IMFSourceBufferList,
            index: u32,
        ) callconv(@import("std").os.windows.WINAPI) *IMFSourceBuffer,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBufferList_GetLength(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFSourceBufferList.VTable, self.vtable).GetLength(@ptrCast(*const IMFSourceBufferList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceBufferList_GetSourceBuffer(self: *const T, index: u32) callconv(.Inline) *IMFSourceBuffer {
            return @ptrCast(*const IMFSourceBufferList.VTable, self.vtable).GetSourceBuffer(@ptrCast(*const IMFSourceBufferList, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MSE_READY = extern enum(i32) {
    CLOSED = 1,
    OPEN = 2,
    ENDED = 3,
};
pub const MF_MSE_READY_CLOSED = MF_MSE_READY.CLOSED;
pub const MF_MSE_READY_OPEN = MF_MSE_READY.OPEN;
pub const MF_MSE_READY_ENDED = MF_MSE_READY.ENDED;

pub const MF_MSE_ERROR = extern enum(i32) {
    NOERROR = 0,
    NETWORK = 1,
    DECODE = 2,
    UNKNOWN_ERROR = 3,
};
pub const MF_MSE_ERROR_NOERROR = MF_MSE_ERROR.NOERROR;
pub const MF_MSE_ERROR_NETWORK = MF_MSE_ERROR.NETWORK;
pub const MF_MSE_ERROR_DECODE = MF_MSE_ERROR.DECODE;
pub const MF_MSE_ERROR_UNKNOWN_ERROR = MF_MSE_ERROR.UNKNOWN_ERROR;

const IID_IMFMediaSourceExtension_Value = @import("../zig.zig").Guid.initString("E467B94E-A713-4562-A802-816A42E9008A");
pub const IID_IMFMediaSourceExtension = &IID_IMFMediaSourceExtension_Value;
pub const IMFMediaSourceExtension = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceBuffers: fn(
            self: *const IMFMediaSourceExtension,
        ) callconv(@import("std").os.windows.WINAPI) *IMFSourceBufferList,
        GetActiveSourceBuffers: fn(
            self: *const IMFMediaSourceExtension,
        ) callconv(@import("std").os.windows.WINAPI) *IMFSourceBufferList,
        GetReadyState: fn(
            self: *const IMFMediaSourceExtension,
        ) callconv(@import("std").os.windows.WINAPI) MF_MSE_READY,
        GetDuration: fn(
            self: *const IMFMediaSourceExtension,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        SetDuration: fn(
            self: *const IMFMediaSourceExtension,
            duration: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSourceBuffer: fn(
            self: *const IMFMediaSourceExtension,
            type: BSTR,
            pNotify: *IMFSourceBufferNotify,
            ppSourceBuffer: **IMFSourceBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSourceBuffer: fn(
            self: *const IMFMediaSourceExtension,
            pSourceBuffer: *IMFSourceBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEndOfStream: fn(
            self: *const IMFMediaSourceExtension,
            @"error": MF_MSE_ERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsTypeSupported: fn(
            self: *const IMFMediaSourceExtension,
            type: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetSourceBuffer: fn(
            self: *const IMFMediaSourceExtension,
            dwStreamIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) *IMFSourceBuffer,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_GetSourceBuffers(self: *const T) callconv(.Inline) *IMFSourceBufferList {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).GetSourceBuffers(@ptrCast(*const IMFMediaSourceExtension, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_GetActiveSourceBuffers(self: *const T) callconv(.Inline) *IMFSourceBufferList {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).GetActiveSourceBuffers(@ptrCast(*const IMFMediaSourceExtension, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_GetReadyState(self: *const T) callconv(.Inline) MF_MSE_READY {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).GetReadyState(@ptrCast(*const IMFMediaSourceExtension, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_GetDuration(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).GetDuration(@ptrCast(*const IMFMediaSourceExtension, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_SetDuration(self: *const T, duration: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).SetDuration(@ptrCast(*const IMFMediaSourceExtension, self), duration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_AddSourceBuffer(self: *const T, type: BSTR, pNotify: *IMFSourceBufferNotify, ppSourceBuffer: **IMFSourceBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).AddSourceBuffer(@ptrCast(*const IMFMediaSourceExtension, self), type, pNotify, ppSourceBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_RemoveSourceBuffer(self: *const T, pSourceBuffer: *IMFSourceBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).RemoveSourceBuffer(@ptrCast(*const IMFMediaSourceExtension, self), pSourceBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_SetEndOfStream(self: *const T, @"error": MF_MSE_ERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).SetEndOfStream(@ptrCast(*const IMFMediaSourceExtension, self), @"error");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_IsTypeSupported(self: *const T, type: BSTR) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).IsTypeSupported(@ptrCast(*const IMFMediaSourceExtension, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtension_GetSourceBuffer(self: *const T, dwStreamIndex: u32) callconv(.Inline) *IMFSourceBuffer {
            return @ptrCast(*const IMFMediaSourceExtension.VTable, self.vtable).GetSourceBuffer(@ptrCast(*const IMFMediaSourceExtension, self), dwStreamIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaSourceExtensionLiveSeekableRange_Value = @import("../zig.zig").Guid.initString("5D1ABFD6-450A-4D92-9EFC-D6B6CBC1F4DA");
pub const IID_IMFMediaSourceExtensionLiveSeekableRange = &IID_IMFMediaSourceExtensionLiveSeekableRange_Value;
pub const IMFMediaSourceExtensionLiveSeekableRange = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLiveSeekableRange: fn(
            self: *const IMFMediaSourceExtensionLiveSeekableRange,
            start: f64,
            end: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearLiveSeekableRange: fn(
            self: *const IMFMediaSourceExtensionLiveSeekableRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtensionLiveSeekableRange_SetLiveSeekableRange(self: *const T, start: f64, end: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceExtensionLiveSeekableRange.VTable, self.vtable).SetLiveSeekableRange(@ptrCast(*const IMFMediaSourceExtensionLiveSeekableRange, self), start, end);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSourceExtensionLiveSeekableRange_ClearLiveSeekableRange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSourceExtensionLiveSeekableRange.VTable, self.vtable).ClearLiveSeekableRange(@ptrCast(*const IMFMediaSourceExtensionLiveSeekableRange, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineEME_Value = @import("../zig.zig").Guid.initString("50DC93E4-BA4F-4275-AE66-83E836E57469");
pub const IID_IMFMediaEngineEME = &IID_IMFMediaEngineEME_Value;
pub const IMFMediaEngineEME = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_Keys: fn(
            self: *const IMFMediaEngineEME,
            keys: ?*?*IMFMediaKeys,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaKeys: fn(
            self: *const IMFMediaEngineEME,
            keys: ?*IMFMediaKeys,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEME_get_Keys(self: *const T, keys: ?*?*IMFMediaKeys) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEME.VTable, self.vtable).get_Keys(@ptrCast(*const IMFMediaEngineEME, self), keys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEME_SetMediaKeys(self: *const T, keys: ?*IMFMediaKeys) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineEME.VTable, self.vtable).SetMediaKeys(@ptrCast(*const IMFMediaEngineEME, self), keys);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineSrcElementsEx_Value = @import("../zig.zig").Guid.initString("654A6BB3-E1A3-424A-9908-53A43A0DFDA0");
pub const IID_IMFMediaEngineSrcElementsEx = &IID_IMFMediaEngineSrcElementsEx_Value;
pub const IMFMediaEngineSrcElementsEx = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEngineSrcElements.VTable,
        AddElementEx: fn(
            self: *const IMFMediaEngineSrcElementsEx,
            pURL: BSTR,
            pType: BSTR,
            pMedia: BSTR,
            keySystem: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeySystem: fn(
            self: *const IMFMediaEngineSrcElementsEx,
            index: u32,
            pType: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaEngineSrcElements.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSrcElementsEx_AddElementEx(self: *const T, pURL: BSTR, pType: BSTR, pMedia: BSTR, keySystem: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSrcElementsEx.VTable, self.vtable).AddElementEx(@ptrCast(*const IMFMediaEngineSrcElementsEx, self), pURL, pType, pMedia, keySystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSrcElementsEx_GetKeySystem(self: *const T, index: u32, pType: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSrcElementsEx.VTable, self.vtable).GetKeySystem(@ptrCast(*const IMFMediaEngineSrcElementsEx, self), index, pType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineNeedKeyNotify_Value = @import("../zig.zig").Guid.initString("46A30204-A696-4B18-8804-246B8F031BB1");
pub const IID_IMFMediaEngineNeedKeyNotify = &IID_IMFMediaEngineNeedKeyNotify_Value;
pub const IMFMediaEngineNeedKeyNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NeedKey: fn(
            self: *const IMFMediaEngineNeedKeyNotify,
            initData: ?[*:0]const u8,
            cb: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineNeedKeyNotify_NeedKey(self: *const T, initData: ?[*:0]const u8, cb: u32) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaEngineNeedKeyNotify.VTable, self.vtable).NeedKey(@ptrCast(*const IMFMediaEngineNeedKeyNotify, self), initData, cb);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaKeys_Value = @import("../zig.zig").Guid.initString("5CB31C05-61FF-418F-AFDA-CAAF41421A38");
pub const IID_IMFMediaKeys = &IID_IMFMediaKeys_Value;
pub const IMFMediaKeys = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSession: fn(
            self: *const IMFMediaKeys,
            mimeType: BSTR,
            initData: ?[*:0]const u8,
            cb: u32,
            customData: ?[*:0]const u8,
            cbCustomData: u32,
            notify: *IMFMediaKeySessionNotify,
            ppSession: **IMFMediaKeySession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_KeySystem: fn(
            self: *const IMFMediaKeys,
            keySystem: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFMediaKeys,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSuspendNotify: fn(
            self: *const IMFMediaKeys,
            notify: **IMFCdmSuspendNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeys_CreateSession(self: *const T, mimeType: BSTR, initData: ?[*:0]const u8, cb: u32, customData: ?[*:0]const u8, cbCustomData: u32, notify: *IMFMediaKeySessionNotify, ppSession: **IMFMediaKeySession) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeys.VTable, self.vtable).CreateSession(@ptrCast(*const IMFMediaKeys, self), mimeType, initData, cb, customData, cbCustomData, notify, ppSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeys_get_KeySystem(self: *const T, keySystem: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeys.VTable, self.vtable).get_KeySystem(@ptrCast(*const IMFMediaKeys, self), keySystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeys_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeys.VTable, self.vtable).Shutdown(@ptrCast(*const IMFMediaKeys, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeys_GetSuspendNotify(self: *const T, notify: **IMFCdmSuspendNotify) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeys.VTable, self.vtable).GetSuspendNotify(@ptrCast(*const IMFMediaKeys, self), notify);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_KEYERR = extern enum(i32) {
    MF_MEDIAENGINE_KEYERR_UNKNOWN = 1,
    MF_MEDIAENGINE_KEYERR_CLIENT = 2,
    MF_MEDIAENGINE_KEYERR_SERVICE = 3,
    MF_MEDIAENGINE_KEYERR_OUTPUT = 4,
    MF_MEDIAENGINE_KEYERR_HARDWARECHANGE = 5,
    MF_MEDIAENGINE_KEYERR_DOMAIN = 6,
};
pub const MF_MEDIAENGINE_KEYERR_UNKNOWN = MF_MEDIA_ENGINE_KEYERR.MF_MEDIAENGINE_KEYERR_UNKNOWN;
pub const MF_MEDIAENGINE_KEYERR_CLIENT = MF_MEDIA_ENGINE_KEYERR.MF_MEDIAENGINE_KEYERR_CLIENT;
pub const MF_MEDIAENGINE_KEYERR_SERVICE = MF_MEDIA_ENGINE_KEYERR.MF_MEDIAENGINE_KEYERR_SERVICE;
pub const MF_MEDIAENGINE_KEYERR_OUTPUT = MF_MEDIA_ENGINE_KEYERR.MF_MEDIAENGINE_KEYERR_OUTPUT;
pub const MF_MEDIAENGINE_KEYERR_HARDWARECHANGE = MF_MEDIA_ENGINE_KEYERR.MF_MEDIAENGINE_KEYERR_HARDWARECHANGE;
pub const MF_MEDIAENGINE_KEYERR_DOMAIN = MF_MEDIA_ENGINE_KEYERR.MF_MEDIAENGINE_KEYERR_DOMAIN;

const IID_IMFMediaKeySession_Value = @import("../zig.zig").Guid.initString("24FA67D5-D1D0-4DC5-995C-C0EFDC191FB5");
pub const IID_IMFMediaKeySession = &IID_IMFMediaKeySession_Value;
pub const IMFMediaKeySession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetError: fn(
            self: *const IMFMediaKeySession,
            code: *u16,
            systemCode: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_KeySystem: fn(
            self: *const IMFMediaKeySession,
            keySystem: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_SessionId: fn(
            self: *const IMFMediaKeySession,
            sessionId: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const IMFMediaKeySession,
            key: [*:0]const u8,
            cb: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IMFMediaKeySession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession_GetError(self: *const T, code: *u16, systemCode: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession.VTable, self.vtable).GetError(@ptrCast(*const IMFMediaKeySession, self), code, systemCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession_get_KeySystem(self: *const T, keySystem: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession.VTable, self.vtable).get_KeySystem(@ptrCast(*const IMFMediaKeySession, self), keySystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession_get_SessionId(self: *const T, sessionId: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession.VTable, self.vtable).get_SessionId(@ptrCast(*const IMFMediaKeySession, self), sessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession_Update(self: *const T, key: [*:0]const u8, cb: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession.VTable, self.vtable).Update(@ptrCast(*const IMFMediaKeySession, self), key, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession.VTable, self.vtable).Close(@ptrCast(*const IMFMediaKeySession, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaKeySessionNotify_Value = @import("../zig.zig").Guid.initString("6A0083F9-8947-4C1D-9CE0-CDEE22B23135");
pub const IID_IMFMediaKeySessionNotify = &IID_IMFMediaKeySessionNotify_Value;
pub const IMFMediaKeySessionNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        KeyMessage: fn(
            self: *const IMFMediaKeySessionNotify,
            destinationURL: BSTR,
            message: [*:0]const u8,
            cb: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        KeyAdded: fn(
            self: *const IMFMediaKeySessionNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
        KeyError: fn(
            self: *const IMFMediaKeySessionNotify,
            code: u16,
            systemCode: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySessionNotify_KeyMessage(self: *const T, destinationURL: BSTR, message: [*:0]const u8, cb: u32) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaKeySessionNotify.VTable, self.vtable).KeyMessage(@ptrCast(*const IMFMediaKeySessionNotify, self), destinationURL, message, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySessionNotify_KeyAdded(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaKeySessionNotify.VTable, self.vtable).KeyAdded(@ptrCast(*const IMFMediaKeySessionNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySessionNotify_KeyError(self: *const T, code: u16, systemCode: u32) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaKeySessionNotify.VTable, self.vtable).KeyError(@ptrCast(*const IMFMediaKeySessionNotify, self), code, systemCode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFCdmSuspendNotify_Value = @import("../zig.zig").Guid.initString("7A5645D2-43BD-47FD-87B7-DCD24CC7D692");
pub const IID_IMFCdmSuspendNotify = &IID_IMFCdmSuspendNotify_Value;
pub const IMFCdmSuspendNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin: fn(
            self: *const IMFCdmSuspendNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        End: fn(
            self: *const IMFCdmSuspendNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCdmSuspendNotify_Begin(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCdmSuspendNotify.VTable, self.vtable).Begin(@ptrCast(*const IMFCdmSuspendNotify, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFCdmSuspendNotify_End(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFCdmSuspendNotify.VTable, self.vtable).End(@ptrCast(*const IMFCdmSuspendNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_HDCP_STATUS = extern enum(i32) {
    ON = 0,
    OFF = 1,
    ON_WITH_TYPE_ENFORCEMENT = 2,
};
pub const MF_HDCP_STATUS_ON = MF_HDCP_STATUS.ON;
pub const MF_HDCP_STATUS_OFF = MF_HDCP_STATUS.OFF;
pub const MF_HDCP_STATUS_ON_WITH_TYPE_ENFORCEMENT = MF_HDCP_STATUS.ON_WITH_TYPE_ENFORCEMENT;

const IID_IMFHDCPStatus_Value = @import("../zig.zig").Guid.initString("DE400F54-5BF1-40CF-8964-0BEA136B1E3D");
pub const IID_IMFHDCPStatus = &IID_IMFHDCPStatus_Value;
pub const IMFHDCPStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Query: fn(
            self: *const IMFHDCPStatus,
            pStatus: *MF_HDCP_STATUS,
            pfStatus: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set: fn(
            self: *const IMFHDCPStatus,
            status: MF_HDCP_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHDCPStatus_Query(self: *const T, pStatus: *MF_HDCP_STATUS, pfStatus: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHDCPStatus.VTable, self.vtable).Query(@ptrCast(*const IMFHDCPStatus, self), pStatus, pfStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFHDCPStatus_Set(self: *const T, status: MF_HDCP_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFHDCPStatus.VTable, self.vtable).Set(@ptrCast(*const IMFHDCPStatus, self), status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_OPM_STATUS = extern enum(i32) {
    MF_MEDIA_ENGINE_OPM_NOT_REQUESTED = 0,
    MF_MEDIA_ENGINE_OPM_ESTABLISHED = 1,
    MF_MEDIA_ENGINE_OPM_FAILED_VM = 2,
    MF_MEDIA_ENGINE_OPM_FAILED_BDA = 3,
    MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER = 4,
    MF_MEDIA_ENGINE_OPM_FAILED = 5,
};
pub const MF_MEDIA_ENGINE_OPM_NOT_REQUESTED = MF_MEDIA_ENGINE_OPM_STATUS.MF_MEDIA_ENGINE_OPM_NOT_REQUESTED;
pub const MF_MEDIA_ENGINE_OPM_ESTABLISHED = MF_MEDIA_ENGINE_OPM_STATUS.MF_MEDIA_ENGINE_OPM_ESTABLISHED;
pub const MF_MEDIA_ENGINE_OPM_FAILED_VM = MF_MEDIA_ENGINE_OPM_STATUS.MF_MEDIA_ENGINE_OPM_FAILED_VM;
pub const MF_MEDIA_ENGINE_OPM_FAILED_BDA = MF_MEDIA_ENGINE_OPM_STATUS.MF_MEDIA_ENGINE_OPM_FAILED_BDA;
pub const MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER = MF_MEDIA_ENGINE_OPM_STATUS.MF_MEDIA_ENGINE_OPM_FAILED_UNSIGNED_DRIVER;
pub const MF_MEDIA_ENGINE_OPM_FAILED = MF_MEDIA_ENGINE_OPM_STATUS.MF_MEDIA_ENGINE_OPM_FAILED;

const IID_IMFMediaEngineOPMInfo_Value = @import("../zig.zig").Guid.initString("765763E6-6C01-4B01-BB0F-B829F60ED28C");
pub const IID_IMFMediaEngineOPMInfo = &IID_IMFMediaEngineOPMInfo_Value;
pub const IMFMediaEngineOPMInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOPMInfo: fn(
            self: *const IMFMediaEngineOPMInfo,
            pStatus: *MF_MEDIA_ENGINE_OPM_STATUS,
            pConstricted: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineOPMInfo_GetOPMInfo(self: *const T, pStatus: *MF_MEDIA_ENGINE_OPM_STATUS, pConstricted: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineOPMInfo.VTable, self.vtable).GetOPMInfo(@ptrCast(*const IMFMediaEngineOPMInfo, self), pStatus, pConstricted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_CREATEFLAGS = extern enum(i32) {
    MF_MEDIA_ENGINE_AUDIOONLY = 1,
    MF_MEDIA_ENGINE_WAITFORSTABLE_STATE = 2,
    MF_MEDIA_ENGINE_FORCEMUTE = 4,
    MF_MEDIA_ENGINE_REAL_TIME_MODE = 8,
    MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS = 16,
    MASK = 31,
};
pub const MF_MEDIA_ENGINE_AUDIOONLY = MF_MEDIA_ENGINE_CREATEFLAGS.MF_MEDIA_ENGINE_AUDIOONLY;
pub const MF_MEDIA_ENGINE_WAITFORSTABLE_STATE = MF_MEDIA_ENGINE_CREATEFLAGS.MF_MEDIA_ENGINE_WAITFORSTABLE_STATE;
pub const MF_MEDIA_ENGINE_FORCEMUTE = MF_MEDIA_ENGINE_CREATEFLAGS.MF_MEDIA_ENGINE_FORCEMUTE;
pub const MF_MEDIA_ENGINE_REAL_TIME_MODE = MF_MEDIA_ENGINE_CREATEFLAGS.MF_MEDIA_ENGINE_REAL_TIME_MODE;
pub const MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS = MF_MEDIA_ENGINE_CREATEFLAGS.MF_MEDIA_ENGINE_DISABLE_LOCAL_PLUGINS;
pub const MF_MEDIA_ENGINE_CREATEFLAGS_MASK = MF_MEDIA_ENGINE_CREATEFLAGS.MASK;

pub const MF_MEDIA_ENGINE_PROTECTION_FLAGS = extern enum(i32) {
    MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT = 1,
    MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT = 2,
    MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP = 4,
};
pub const MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT = MF_MEDIA_ENGINE_PROTECTION_FLAGS.MF_MEDIA_ENGINE_ENABLE_PROTECTED_CONTENT;
pub const MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT = MF_MEDIA_ENGINE_PROTECTION_FLAGS.MF_MEDIA_ENGINE_USE_PMP_FOR_ALL_CONTENT;
pub const MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP = MF_MEDIA_ENGINE_PROTECTION_FLAGS.MF_MEDIA_ENGINE_USE_UNPROTECTED_PMP;

const IID_IMFMediaEngineClassFactory_Value = @import("../zig.zig").Guid.initString("4D645ACE-26AA-4688-9BE1-DF3516990B93");
pub const IID_IMFMediaEngineClassFactory = &IID_IMFMediaEngineClassFactory_Value;
pub const IMFMediaEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: fn(
            self: *const IMFMediaEngineClassFactory,
            dwFlags: u32,
            pAttr: *IMFAttributes,
            ppPlayer: **IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTimeRange: fn(
            self: *const IMFMediaEngineClassFactory,
            ppTimeRange: **IMFMediaTimeRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateError: fn(
            self: *const IMFMediaEngineClassFactory,
            ppError: **IMFMediaError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineClassFactory_CreateInstance(self: *const T, dwFlags: u32, pAttr: *IMFAttributes, ppPlayer: **IMFMediaEngine) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineClassFactory.VTable, self.vtable).CreateInstance(@ptrCast(*const IMFMediaEngineClassFactory, self), dwFlags, pAttr, ppPlayer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineClassFactory_CreateTimeRange(self: *const T, ppTimeRange: **IMFMediaTimeRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineClassFactory.VTable, self.vtable).CreateTimeRange(@ptrCast(*const IMFMediaEngineClassFactory, self), ppTimeRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineClassFactory_CreateError(self: *const T, ppError: **IMFMediaError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineClassFactory.VTable, self.vtable).CreateError(@ptrCast(*const IMFMediaEngineClassFactory, self), ppError);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineClassFactoryEx_Value = @import("../zig.zig").Guid.initString("C56156C6-EA5B-48A5-9DF8-FBE035D0929E");
pub const IID_IMFMediaEngineClassFactoryEx = &IID_IMFMediaEngineClassFactoryEx_Value;
pub const IMFMediaEngineClassFactoryEx = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEngineClassFactory.VTable,
        CreateMediaSourceExtension: fn(
            self: *const IMFMediaEngineClassFactoryEx,
            dwFlags: u32,
            pAttr: *IMFAttributes,
            ppMSE: **IMFMediaSourceExtension,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMediaKeys: fn(
            self: *const IMFMediaEngineClassFactoryEx,
            keySystem: BSTR,
            cdmStorePath: BSTR,
            ppKeys: **IMFMediaKeys,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsTypeSupported: fn(
            self: *const IMFMediaEngineClassFactoryEx,
            type: BSTR,
            keySystem: BSTR,
            isSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaEngineClassFactory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineClassFactoryEx_CreateMediaSourceExtension(self: *const T, dwFlags: u32, pAttr: *IMFAttributes, ppMSE: **IMFMediaSourceExtension) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineClassFactoryEx.VTable, self.vtable).CreateMediaSourceExtension(@ptrCast(*const IMFMediaEngineClassFactoryEx, self), dwFlags, pAttr, ppMSE);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineClassFactoryEx_CreateMediaKeys(self: *const T, keySystem: BSTR, cdmStorePath: BSTR, ppKeys: **IMFMediaKeys) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineClassFactoryEx.VTable, self.vtable).CreateMediaKeys(@ptrCast(*const IMFMediaEngineClassFactoryEx, self), keySystem, cdmStorePath, ppKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineClassFactoryEx_IsTypeSupported(self: *const T, type: BSTR, keySystem: BSTR, isSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineClassFactoryEx.VTable, self.vtable).IsTypeSupported(@ptrCast(*const IMFMediaEngineClassFactoryEx, self), type, keySystem, isSupported);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineClassFactory2_Value = @import("../zig.zig").Guid.initString("09083CEF-867F-4BF6-8776-DEE3A7B42FCA");
pub const IID_IMFMediaEngineClassFactory2 = &IID_IMFMediaEngineClassFactory2_Value;
pub const IMFMediaEngineClassFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMediaKeys2: fn(
            self: *const IMFMediaEngineClassFactory2,
            keySystem: BSTR,
            defaultCdmStorePath: BSTR,
            inprivateCdmStorePath: BSTR,
            ppKeys: **IMFMediaKeys,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineClassFactory2_CreateMediaKeys2(self: *const T, keySystem: BSTR, defaultCdmStorePath: BSTR, inprivateCdmStorePath: BSTR, ppKeys: **IMFMediaKeys) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineClassFactory2.VTable, self.vtable).CreateMediaKeys2(@ptrCast(*const IMFMediaEngineClassFactory2, self), keySystem, defaultCdmStorePath, inprivateCdmStorePath, ppKeys);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFExtendedDRMTypeSupport_Value = @import("../zig.zig").Guid.initString("332EC562-3758-468D-A784-E38F23552128");
pub const IID_IMFExtendedDRMTypeSupport = &IID_IMFExtendedDRMTypeSupport_Value;
pub const IMFExtendedDRMTypeSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsTypeSupportedEx: fn(
            self: *const IMFExtendedDRMTypeSupport,
            type: BSTR,
            keySystem: BSTR,
            pAnswer: *MF_MEDIA_ENGINE_CANPLAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFExtendedDRMTypeSupport_IsTypeSupportedEx(self: *const T, type: BSTR, keySystem: BSTR, pAnswer: *MF_MEDIA_ENGINE_CANPLAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFExtendedDRMTypeSupport.VTable, self.vtable).IsTypeSupportedEx(@ptrCast(*const IMFExtendedDRMTypeSupport, self), type, keySystem, pAnswer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineSupportsSourceTransfer_Value = @import("../zig.zig").Guid.initString("A724B056-1B2E-4642-A6F3-DB9420C52908");
pub const IID_IMFMediaEngineSupportsSourceTransfer = &IID_IMFMediaEngineSupportsSourceTransfer_Value;
pub const IMFMediaEngineSupportsSourceTransfer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShouldTransferSource: fn(
            self: *const IMFMediaEngineSupportsSourceTransfer,
            pfShouldTransfer: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachMediaSource: fn(
            self: *const IMFMediaEngineSupportsSourceTransfer,
            ppByteStream: **IMFByteStream,
            ppMediaSource: **IMFMediaSource,
            ppMSE: **IMFMediaSourceExtension,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachMediaSource: fn(
            self: *const IMFMediaEngineSupportsSourceTransfer,
            pByteStream: ?*IMFByteStream,
            pMediaSource: *IMFMediaSource,
            pMSE: ?*IMFMediaSourceExtension,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSupportsSourceTransfer_ShouldTransferSource(self: *const T, pfShouldTransfer: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSupportsSourceTransfer.VTable, self.vtable).ShouldTransferSource(@ptrCast(*const IMFMediaEngineSupportsSourceTransfer, self), pfShouldTransfer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSupportsSourceTransfer_DetachMediaSource(self: *const T, ppByteStream: **IMFByteStream, ppMediaSource: **IMFMediaSource, ppMSE: **IMFMediaSourceExtension) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSupportsSourceTransfer.VTable, self.vtable).DetachMediaSource(@ptrCast(*const IMFMediaEngineSupportsSourceTransfer, self), ppByteStream, ppMediaSource, ppMSE);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineSupportsSourceTransfer_AttachMediaSource(self: *const T, pByteStream: ?*IMFByteStream, pMediaSource: *IMFMediaSource, pMSE: ?*IMFMediaSourceExtension) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineSupportsSourceTransfer.VTable, self.vtable).AttachMediaSource(@ptrCast(*const IMFMediaEngineSupportsSourceTransfer, self), pByteStream, pMediaSource, pMSE);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineTransferSource_Value = @import("../zig.zig").Guid.initString("24230452-FE54-40CC-94F3-FCC394C340D6");
pub const IID_IMFMediaEngineTransferSource = &IID_IMFMediaEngineTransferSource_Value;
pub const IMFMediaEngineTransferSource = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TransferSourceToMediaEngine: fn(
            self: *const IMFMediaEngineTransferSource,
            destination: *IMFMediaEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineTransferSource_TransferSourceToMediaEngine(self: *const T, destination: *IMFMediaEngine) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineTransferSource.VTable, self.vtable).TransferSourceToMediaEngine(@ptrCast(*const IMFMediaEngineTransferSource, self), destination);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_TIMED_TEXT_TRACK_KIND = extern enum(i32) {
    UNKNOWN = 0,
    SUBTITLES = 1,
    CAPTIONS = 2,
    METADATA = 3,
};
pub const MF_TIMED_TEXT_TRACK_KIND_UNKNOWN = MF_TIMED_TEXT_TRACK_KIND.UNKNOWN;
pub const MF_TIMED_TEXT_TRACK_KIND_SUBTITLES = MF_TIMED_TEXT_TRACK_KIND.SUBTITLES;
pub const MF_TIMED_TEXT_TRACK_KIND_CAPTIONS = MF_TIMED_TEXT_TRACK_KIND.CAPTIONS;
pub const MF_TIMED_TEXT_TRACK_KIND_METADATA = MF_TIMED_TEXT_TRACK_KIND.METADATA;

pub const MF_TIMED_TEXT_UNIT_TYPE = extern enum(i32) {
    PIXELS = 0,
    PERCENTAGE = 1,
};
pub const MF_TIMED_TEXT_UNIT_TYPE_PIXELS = MF_TIMED_TEXT_UNIT_TYPE.PIXELS;
pub const MF_TIMED_TEXT_UNIT_TYPE_PERCENTAGE = MF_TIMED_TEXT_UNIT_TYPE.PERCENTAGE;

pub const MF_TIMED_TEXT_FONT_STYLE = extern enum(i32) {
    NORMAL = 0,
    OBLIQUE = 1,
    ITALIC = 2,
};
pub const MF_TIMED_TEXT_FONT_STYLE_NORMAL = MF_TIMED_TEXT_FONT_STYLE.NORMAL;
pub const MF_TIMED_TEXT_FONT_STYLE_OBLIQUE = MF_TIMED_TEXT_FONT_STYLE.OBLIQUE;
pub const MF_TIMED_TEXT_FONT_STYLE_ITALIC = MF_TIMED_TEXT_FONT_STYLE.ITALIC;

pub const MF_TIMED_TEXT_ALIGNMENT = extern enum(i32) {
    START = 0,
    END = 1,
    CENTER = 2,
};
pub const MF_TIMED_TEXT_ALIGNMENT_START = MF_TIMED_TEXT_ALIGNMENT.START;
pub const MF_TIMED_TEXT_ALIGNMENT_END = MF_TIMED_TEXT_ALIGNMENT.END;
pub const MF_TIMED_TEXT_ALIGNMENT_CENTER = MF_TIMED_TEXT_ALIGNMENT.CENTER;

pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT = extern enum(i32) {
    BEFORE = 0,
    AFTER = 1,
    CENTER = 2,
};
pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT_BEFORE = MF_TIMED_TEXT_DISPLAY_ALIGNMENT.BEFORE;
pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT_AFTER = MF_TIMED_TEXT_DISPLAY_ALIGNMENT.AFTER;
pub const MF_TIMED_TEXT_DISPLAY_ALIGNMENT_CENTER = MF_TIMED_TEXT_DISPLAY_ALIGNMENT.CENTER;

pub const MF_TIMED_TEXT_DECORATION = extern enum(i32) {
    NONE = 0,
    UNDERLINE = 1,
    LINE_THROUGH = 2,
    OVERLINE = 4,
};
pub const MF_TIMED_TEXT_DECORATION_NONE = MF_TIMED_TEXT_DECORATION.NONE;
pub const MF_TIMED_TEXT_DECORATION_UNDERLINE = MF_TIMED_TEXT_DECORATION.UNDERLINE;
pub const MF_TIMED_TEXT_DECORATION_LINE_THROUGH = MF_TIMED_TEXT_DECORATION.LINE_THROUGH;
pub const MF_TIMED_TEXT_DECORATION_OVERLINE = MF_TIMED_TEXT_DECORATION.OVERLINE;

pub const MF_TIMED_TEXT_WRITING_MODE = extern enum(i32) {
    LRTB = 0,
    RLTB = 1,
    TBRL = 2,
    TBLR = 3,
    LR = 4,
    RL = 5,
    TB = 6,
};
pub const MF_TIMED_TEXT_WRITING_MODE_LRTB = MF_TIMED_TEXT_WRITING_MODE.LRTB;
pub const MF_TIMED_TEXT_WRITING_MODE_RLTB = MF_TIMED_TEXT_WRITING_MODE.RLTB;
pub const MF_TIMED_TEXT_WRITING_MODE_TBRL = MF_TIMED_TEXT_WRITING_MODE.TBRL;
pub const MF_TIMED_TEXT_WRITING_MODE_TBLR = MF_TIMED_TEXT_WRITING_MODE.TBLR;
pub const MF_TIMED_TEXT_WRITING_MODE_LR = MF_TIMED_TEXT_WRITING_MODE.LR;
pub const MF_TIMED_TEXT_WRITING_MODE_RL = MF_TIMED_TEXT_WRITING_MODE.RL;
pub const MF_TIMED_TEXT_WRITING_MODE_TB = MF_TIMED_TEXT_WRITING_MODE.TB;

pub const MF_TIMED_TEXT_SCROLL_MODE = extern enum(i32) {
    POP_ON = 0,
    ROLL_UP = 1,
};
pub const MF_TIMED_TEXT_SCROLL_MODE_POP_ON = MF_TIMED_TEXT_SCROLL_MODE.POP_ON;
pub const MF_TIMED_TEXT_SCROLL_MODE_ROLL_UP = MF_TIMED_TEXT_SCROLL_MODE.ROLL_UP;

pub const MF_TIMED_TEXT_ERROR_CODE = extern enum(i32) {
    NOERROR = 0,
    FATAL = 1,
    DATA_FORMAT = 2,
    NETWORK = 3,
    INTERNAL = 4,
};
pub const MF_TIMED_TEXT_ERROR_CODE_NOERROR = MF_TIMED_TEXT_ERROR_CODE.NOERROR;
pub const MF_TIMED_TEXT_ERROR_CODE_FATAL = MF_TIMED_TEXT_ERROR_CODE.FATAL;
pub const MF_TIMED_TEXT_ERROR_CODE_DATA_FORMAT = MF_TIMED_TEXT_ERROR_CODE.DATA_FORMAT;
pub const MF_TIMED_TEXT_ERROR_CODE_NETWORK = MF_TIMED_TEXT_ERROR_CODE.NETWORK;
pub const MF_TIMED_TEXT_ERROR_CODE_INTERNAL = MF_TIMED_TEXT_ERROR_CODE.INTERNAL;

pub const MF_TIMED_TEXT_CUE_EVENT = extern enum(i32) {
    ACTIVE = 0,
    INACTIVE = 1,
    CLEAR = 2,
};
pub const MF_TIMED_TEXT_CUE_EVENT_ACTIVE = MF_TIMED_TEXT_CUE_EVENT.ACTIVE;
pub const MF_TIMED_TEXT_CUE_EVENT_INACTIVE = MF_TIMED_TEXT_CUE_EVENT.INACTIVE;
pub const MF_TIMED_TEXT_CUE_EVENT_CLEAR = MF_TIMED_TEXT_CUE_EVENT.CLEAR;

pub const MF_TIMED_TEXT_TRACK_READY_STATE = extern enum(i32) {
    NONE = 0,
    LOADING = 1,
    LOADED = 2,
    ERROR = 3,
};
pub const MF_TIMED_TEXT_TRACK_READY_STATE_NONE = MF_TIMED_TEXT_TRACK_READY_STATE.NONE;
pub const MF_TIMED_TEXT_TRACK_READY_STATE_LOADING = MF_TIMED_TEXT_TRACK_READY_STATE.LOADING;
pub const MF_TIMED_TEXT_TRACK_READY_STATE_LOADED = MF_TIMED_TEXT_TRACK_READY_STATE.LOADED;
pub const MF_TIMED_TEXT_TRACK_READY_STATE_ERROR = MF_TIMED_TEXT_TRACK_READY_STATE.ERROR;

const IID_IMFTimedText_Value = @import("../zig.zig").Guid.initString("1F2A94C9-A3DF-430D-9D0F-ACD85DDC29AF");
pub const IID_IMFTimedText = &IID_IMFTimedText_Value;
pub const IMFTimedText = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterNotifications: fn(
            self: *const IMFTimedText,
            notify: ?*IMFTimedTextNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectTrack: fn(
            self: *const IMFTimedText,
            trackId: u32,
            selected: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDataSource: fn(
            self: *const IMFTimedText,
            byteStream: *IMFByteStream,
            label: ?[*:0]const u16,
            language: ?[*:0]const u16,
            kind: MF_TIMED_TEXT_TRACK_KIND,
            isDefault: BOOL,
            trackId: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDataSourceFromUrl: fn(
            self: *const IMFTimedText,
            url: [*:0]const u16,
            label: ?[*:0]const u16,
            language: ?[*:0]const u16,
            kind: MF_TIMED_TEXT_TRACK_KIND,
            isDefault: BOOL,
            trackId: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTrack: fn(
            self: *const IMFTimedText,
            label: ?[*:0]const u16,
            language: ?[*:0]const u16,
            kind: MF_TIMED_TEXT_TRACK_KIND,
            track: **IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTrack: fn(
            self: *const IMFTimedText,
            track: *IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCueTimeOffset: fn(
            self: *const IMFTimedText,
            offset: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCueTimeOffset: fn(
            self: *const IMFTimedText,
            offset: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTracks: fn(
            self: *const IMFTimedText,
            tracks: **IMFTimedTextTrackList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveTracks: fn(
            self: *const IMFTimedText,
            activeTracks: **IMFTimedTextTrackList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextTracks: fn(
            self: *const IMFTimedText,
            textTracks: **IMFTimedTextTrackList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMetadataTracks: fn(
            self: *const IMFTimedText,
            metadataTracks: **IMFTimedTextTrackList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInBandEnabled: fn(
            self: *const IMFTimedText,
            enabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInBandEnabled: fn(
            self: *const IMFTimedText,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_RegisterNotifications(self: *const T, notify: ?*IMFTimedTextNotify) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).RegisterNotifications(@ptrCast(*const IMFTimedText, self), notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_SelectTrack(self: *const T, trackId: u32, selected: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).SelectTrack(@ptrCast(*const IMFTimedText, self), trackId, selected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_AddDataSource(self: *const T, byteStream: *IMFByteStream, label: ?[*:0]const u16, language: ?[*:0]const u16, kind: MF_TIMED_TEXT_TRACK_KIND, isDefault: BOOL, trackId: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).AddDataSource(@ptrCast(*const IMFTimedText, self), byteStream, label, language, kind, isDefault, trackId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_AddDataSourceFromUrl(self: *const T, url: [*:0]const u16, label: ?[*:0]const u16, language: ?[*:0]const u16, kind: MF_TIMED_TEXT_TRACK_KIND, isDefault: BOOL, trackId: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).AddDataSourceFromUrl(@ptrCast(*const IMFTimedText, self), url, label, language, kind, isDefault, trackId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_AddTrack(self: *const T, label: ?[*:0]const u16, language: ?[*:0]const u16, kind: MF_TIMED_TEXT_TRACK_KIND, track: **IMFTimedTextTrack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).AddTrack(@ptrCast(*const IMFTimedText, self), label, language, kind, track);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_RemoveTrack(self: *const T, track: *IMFTimedTextTrack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).RemoveTrack(@ptrCast(*const IMFTimedText, self), track);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_GetCueTimeOffset(self: *const T, offset: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).GetCueTimeOffset(@ptrCast(*const IMFTimedText, self), offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_SetCueTimeOffset(self: *const T, offset: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).SetCueTimeOffset(@ptrCast(*const IMFTimedText, self), offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_GetTracks(self: *const T, tracks: **IMFTimedTextTrackList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).GetTracks(@ptrCast(*const IMFTimedText, self), tracks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_GetActiveTracks(self: *const T, activeTracks: **IMFTimedTextTrackList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).GetActiveTracks(@ptrCast(*const IMFTimedText, self), activeTracks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_GetTextTracks(self: *const T, textTracks: **IMFTimedTextTrackList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).GetTextTracks(@ptrCast(*const IMFTimedText, self), textTracks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_GetMetadataTracks(self: *const T, metadataTracks: **IMFTimedTextTrackList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).GetMetadataTracks(@ptrCast(*const IMFTimedText, self), metadataTracks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_SetInBandEnabled(self: *const T, enabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).SetInBandEnabled(@ptrCast(*const IMFTimedText, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedText_IsInBandEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFTimedText.VTable, self.vtable).IsInBandEnabled(@ptrCast(*const IMFTimedText, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextNotify_Value = @import("../zig.zig").Guid.initString("DF6B87B6-CE12-45DB-ABA7-432FE054E57D");
pub const IID_IMFTimedTextNotify = &IID_IMFTimedTextNotify_Value;
pub const IMFTimedTextNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TrackAdded: fn(
            self: *const IMFTimedTextNotify,
            trackId: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TrackRemoved: fn(
            self: *const IMFTimedTextNotify,
            trackId: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TrackSelected: fn(
            self: *const IMFTimedTextNotify,
            trackId: u32,
            selected: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TrackReadyStateChanged: fn(
            self: *const IMFTimedTextNotify,
            trackId: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Error: fn(
            self: *const IMFTimedTextNotify,
            errorCode: MF_TIMED_TEXT_ERROR_CODE,
            extendedErrorCode: HRESULT,
            sourceTrackId: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Cue: fn(
            self: *const IMFTimedTextNotify,
            cueEvent: MF_TIMED_TEXT_CUE_EVENT,
            currentTime: f64,
            cue: ?*IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Reset: fn(
            self: *const IMFTimedTextNotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextNotify_TrackAdded(self: *const T, trackId: u32) callconv(.Inline) void {
            return @ptrCast(*const IMFTimedTextNotify.VTable, self.vtable).TrackAdded(@ptrCast(*const IMFTimedTextNotify, self), trackId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextNotify_TrackRemoved(self: *const T, trackId: u32) callconv(.Inline) void {
            return @ptrCast(*const IMFTimedTextNotify.VTable, self.vtable).TrackRemoved(@ptrCast(*const IMFTimedTextNotify, self), trackId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextNotify_TrackSelected(self: *const T, trackId: u32, selected: BOOL) callconv(.Inline) void {
            return @ptrCast(*const IMFTimedTextNotify.VTable, self.vtable).TrackSelected(@ptrCast(*const IMFTimedTextNotify, self), trackId, selected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextNotify_TrackReadyStateChanged(self: *const T, trackId: u32) callconv(.Inline) void {
            return @ptrCast(*const IMFTimedTextNotify.VTable, self.vtable).TrackReadyStateChanged(@ptrCast(*const IMFTimedTextNotify, self), trackId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextNotify_Error(self: *const T, errorCode: MF_TIMED_TEXT_ERROR_CODE, extendedErrorCode: HRESULT, sourceTrackId: u32) callconv(.Inline) void {
            return @ptrCast(*const IMFTimedTextNotify.VTable, self.vtable).Error(@ptrCast(*const IMFTimedTextNotify, self), errorCode, extendedErrorCode, sourceTrackId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextNotify_Cue(self: *const T, cueEvent: MF_TIMED_TEXT_CUE_EVENT, currentTime: f64, cue: ?*IMFTimedTextCue) callconv(.Inline) void {
            return @ptrCast(*const IMFTimedTextNotify.VTable, self.vtable).Cue(@ptrCast(*const IMFTimedTextNotify, self), cueEvent, currentTime, cue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextNotify_Reset(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFTimedTextNotify.VTable, self.vtable).Reset(@ptrCast(*const IMFTimedTextNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextTrack_Value = @import("../zig.zig").Guid.initString("8822C32D-654E-4233-BF21-D7F2E67D30D4");
pub const IID_IMFTimedTextTrack = &IID_IMFTimedTextTrack_Value;
pub const IMFTimedTextTrack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetLabel: fn(
            self: *const IMFTimedTextTrack,
            label: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLabel: fn(
            self: *const IMFTimedTextTrack,
            label: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguage: fn(
            self: *const IMFTimedTextTrack,
            language: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrackKind: fn(
            self: *const IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_TRACK_KIND,
        IsInBand: fn(
            self: *const IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetInBandMetadataTrackDispatchType: fn(
            self: *const IMFTimedTextTrack,
            dispatchType: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsActive: fn(
            self: *const IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetErrorCode: fn(
            self: *const IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_ERROR_CODE,
        GetExtendedErrorCode: fn(
            self: *const IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataFormat: fn(
            self: *const IMFTimedTextTrack,
            format: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReadyState: fn(
            self: *const IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_TRACK_READY_STATE,
        GetCueList: fn(
            self: *const IMFTimedTextTrack,
            cues: **IMFTimedTextCueList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetId(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetId(@ptrCast(*const IMFTimedTextTrack, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetLabel(self: *const T, label: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetLabel(@ptrCast(*const IMFTimedTextTrack, self), label);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_SetLabel(self: *const T, label: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).SetLabel(@ptrCast(*const IMFTimedTextTrack, self), label);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetLanguage(self: *const T, language: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetLanguage(@ptrCast(*const IMFTimedTextTrack, self), language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetTrackKind(self: *const T) callconv(.Inline) MF_TIMED_TEXT_TRACK_KIND {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetTrackKind(@ptrCast(*const IMFTimedTextTrack, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_IsInBand(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).IsInBand(@ptrCast(*const IMFTimedTextTrack, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetInBandMetadataTrackDispatchType(self: *const T, dispatchType: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetInBandMetadataTrackDispatchType(@ptrCast(*const IMFTimedTextTrack, self), dispatchType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_IsActive(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).IsActive(@ptrCast(*const IMFTimedTextTrack, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetErrorCode(self: *const T) callconv(.Inline) MF_TIMED_TEXT_ERROR_CODE {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetErrorCode(@ptrCast(*const IMFTimedTextTrack, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetExtendedErrorCode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetExtendedErrorCode(@ptrCast(*const IMFTimedTextTrack, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetDataFormat(self: *const T, format: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetDataFormat(@ptrCast(*const IMFTimedTextTrack, self), format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetReadyState(self: *const T) callconv(.Inline) MF_TIMED_TEXT_TRACK_READY_STATE {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetReadyState(@ptrCast(*const IMFTimedTextTrack, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrack_GetCueList(self: *const T, cues: **IMFTimedTextCueList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextTrack.VTable, self.vtable).GetCueList(@ptrCast(*const IMFTimedTextTrack, self), cues);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextTrackList_Value = @import("../zig.zig").Guid.initString("23FF334C-442C-445F-BCCC-EDC438AA11E2");
pub const IID_IMFTimedTextTrackList = &IID_IMFTimedTextTrackList_Value;
pub const IMFTimedTextTrackList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: fn(
            self: *const IMFTimedTextTrackList,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetTrack: fn(
            self: *const IMFTimedTextTrackList,
            index: u32,
            track: **IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrackById: fn(
            self: *const IMFTimedTextTrackList,
            trackId: u32,
            track: **IMFTimedTextTrack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrackList_GetLength(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFTimedTextTrackList.VTable, self.vtable).GetLength(@ptrCast(*const IMFTimedTextTrackList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrackList_GetTrack(self: *const T, index: u32, track: **IMFTimedTextTrack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextTrackList.VTable, self.vtable).GetTrack(@ptrCast(*const IMFTimedTextTrackList, self), index, track);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextTrackList_GetTrackById(self: *const T, trackId: u32, track: **IMFTimedTextTrack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextTrackList.VTable, self.vtable).GetTrackById(@ptrCast(*const IMFTimedTextTrackList, self), trackId, track);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextCue_Value = @import("../zig.zig").Guid.initString("1E560447-9A2B-43E1-A94C-B0AAABFBFBC9");
pub const IID_IMFTimedTextCue = &IID_IMFTimedTextCue_Value;
pub const IMFTimedTextCue = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetOriginalId: fn(
            self: *const IMFTimedTextCue,
            originalId: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCueKind: fn(
            self: *const IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) MF_TIMED_TEXT_TRACK_KIND,
        GetStartTime: fn(
            self: *const IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        GetDuration: fn(
            self: *const IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) f64,
        GetTrackId: fn(
            self: *const IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetData: fn(
            self: *const IMFTimedTextCue,
            data: ?*?*IMFTimedTextBinary,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRegion: fn(
            self: *const IMFTimedTextCue,
            region: ?*?*IMFTimedTextRegion,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: fn(
            self: *const IMFTimedTextCue,
            style: ?*?*IMFTimedTextStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineCount: fn(
            self: *const IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetLine: fn(
            self: *const IMFTimedTextCue,
            index: u32,
            line: **IMFTimedTextFormattedText,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetId(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetId(@ptrCast(*const IMFTimedTextCue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetOriginalId(self: *const T, originalId: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetOriginalId(@ptrCast(*const IMFTimedTextCue, self), originalId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetCueKind(self: *const T) callconv(.Inline) MF_TIMED_TEXT_TRACK_KIND {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetCueKind(@ptrCast(*const IMFTimedTextCue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetStartTime(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetStartTime(@ptrCast(*const IMFTimedTextCue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetDuration(self: *const T) callconv(.Inline) f64 {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetDuration(@ptrCast(*const IMFTimedTextCue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetTrackId(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetTrackId(@ptrCast(*const IMFTimedTextCue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetData(self: *const T, data: ?*?*IMFTimedTextBinary) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetData(@ptrCast(*const IMFTimedTextCue, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetRegion(self: *const T, region: ?*?*IMFTimedTextRegion) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetRegion(@ptrCast(*const IMFTimedTextCue, self), region);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetStyle(self: *const T, style: ?*?*IMFTimedTextStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetStyle(@ptrCast(*const IMFTimedTextCue, self), style);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetLineCount(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetLineCount(@ptrCast(*const IMFTimedTextCue, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCue_GetLine(self: *const T, index: u32, line: **IMFTimedTextFormattedText) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCue.VTable, self.vtable).GetLine(@ptrCast(*const IMFTimedTextCue, self), index, line);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextFormattedText_Value = @import("../zig.zig").Guid.initString("E13AF3C1-4D47-4354-B1F5-E83AE0ECAE60");
pub const IID_IMFTimedTextFormattedText = &IID_IMFTimedTextFormattedText_Value;
pub const IMFTimedTextFormattedText = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetText: fn(
            self: *const IMFTimedTextFormattedText,
            text: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubformattingCount: fn(
            self: *const IMFTimedTextFormattedText,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetSubformatting: fn(
            self: *const IMFTimedTextFormattedText,
            index: u32,
            firstChar: *u32,
            charLength: *u32,
            style: ?*?*IMFTimedTextStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextFormattedText_GetText(self: *const T, text: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextFormattedText.VTable, self.vtable).GetText(@ptrCast(*const IMFTimedTextFormattedText, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextFormattedText_GetSubformattingCount(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFTimedTextFormattedText.VTable, self.vtable).GetSubformattingCount(@ptrCast(*const IMFTimedTextFormattedText, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextFormattedText_GetSubformatting(self: *const T, index: u32, firstChar: *u32, charLength: *u32, style: ?*?*IMFTimedTextStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextFormattedText.VTable, self.vtable).GetSubformatting(@ptrCast(*const IMFTimedTextFormattedText, self), index, firstChar, charLength, style);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextStyle_Value = @import("../zig.zig").Guid.initString("09B2455D-B834-4F01-A347-9052E21C450E");
pub const IID_IMFTimedTextStyle = &IID_IMFTimedTextStyle_Value;
pub const IMFTimedTextStyle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IMFTimedTextStyle,
            name: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsExternal: fn(
            self: *const IMFTimedTextStyle,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetFontFamily: fn(
            self: *const IMFTimedTextStyle,
            fontFamily: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFontSize: fn(
            self: *const IMFTimedTextStyle,
            fontSize: *f64,
            unitType: *MF_TIMED_TEXT_UNIT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColor: fn(
            self: *const IMFTimedTextStyle,
            color: *MFARGB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: fn(
            self: *const IMFTimedTextStyle,
            bgColor: *MFARGB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShowBackgroundAlways: fn(
            self: *const IMFTimedTextStyle,
            showBackgroundAlways: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFontStyle: fn(
            self: *const IMFTimedTextStyle,
            fontStyle: *MF_TIMED_TEXT_FONT_STYLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBold: fn(
            self: *const IMFTimedTextStyle,
            bold: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRightToLeft: fn(
            self: *const IMFTimedTextStyle,
            rightToLeft: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextAlignment: fn(
            self: *const IMFTimedTextStyle,
            textAlign: *MF_TIMED_TEXT_ALIGNMENT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextDecoration: fn(
            self: *const IMFTimedTextStyle,
            textDecoration: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextOutline: fn(
            self: *const IMFTimedTextStyle,
            color: *MFARGB,
            thickness: *f64,
            blurRadius: *f64,
            unitType: *MF_TIMED_TEXT_UNIT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetName(self: *const T, name: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetName(@ptrCast(*const IMFTimedTextStyle, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_IsExternal(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).IsExternal(@ptrCast(*const IMFTimedTextStyle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetFontFamily(self: *const T, fontFamily: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetFontFamily(@ptrCast(*const IMFTimedTextStyle, self), fontFamily);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetFontSize(self: *const T, fontSize: *f64, unitType: *MF_TIMED_TEXT_UNIT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetFontSize(@ptrCast(*const IMFTimedTextStyle, self), fontSize, unitType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetColor(self: *const T, color: *MFARGB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetColor(@ptrCast(*const IMFTimedTextStyle, self), color);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetBackgroundColor(self: *const T, bgColor: *MFARGB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetBackgroundColor(@ptrCast(*const IMFTimedTextStyle, self), bgColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetShowBackgroundAlways(self: *const T, showBackgroundAlways: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetShowBackgroundAlways(@ptrCast(*const IMFTimedTextStyle, self), showBackgroundAlways);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetFontStyle(self: *const T, fontStyle: *MF_TIMED_TEXT_FONT_STYLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetFontStyle(@ptrCast(*const IMFTimedTextStyle, self), fontStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetBold(self: *const T, bold: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetBold(@ptrCast(*const IMFTimedTextStyle, self), bold);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetRightToLeft(self: *const T, rightToLeft: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetRightToLeft(@ptrCast(*const IMFTimedTextStyle, self), rightToLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetTextAlignment(self: *const T, textAlign: *MF_TIMED_TEXT_ALIGNMENT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetTextAlignment(@ptrCast(*const IMFTimedTextStyle, self), textAlign);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetTextDecoration(self: *const T, textDecoration: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetTextDecoration(@ptrCast(*const IMFTimedTextStyle, self), textDecoration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextStyle_GetTextOutline(self: *const T, color: *MFARGB, thickness: *f64, blurRadius: *f64, unitType: *MF_TIMED_TEXT_UNIT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextStyle.VTable, self.vtable).GetTextOutline(@ptrCast(*const IMFTimedTextStyle, self), color, thickness, blurRadius, unitType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextRegion_Value = @import("../zig.zig").Guid.initString("C8D22AFC-BC47-4BDF-9B04-787E49CE3F58");
pub const IID_IMFTimedTextRegion = &IID_IMFTimedTextRegion_Value;
pub const IMFTimedTextRegion = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IMFTimedTextRegion,
            name: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const IMFTimedTextRegion,
            pX: *f64,
            pY: *f64,
            unitType: *MF_TIMED_TEXT_UNIT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtent: fn(
            self: *const IMFTimedTextRegion,
            pWidth: *f64,
            pHeight: *f64,
            unitType: *MF_TIMED_TEXT_UNIT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: fn(
            self: *const IMFTimedTextRegion,
            bgColor: *MFARGB,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWritingMode: fn(
            self: *const IMFTimedTextRegion,
            writingMode: *MF_TIMED_TEXT_WRITING_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayAlignment: fn(
            self: *const IMFTimedTextRegion,
            displayAlign: *MF_TIMED_TEXT_DISPLAY_ALIGNMENT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineHeight: fn(
            self: *const IMFTimedTextRegion,
            pLineHeight: *f64,
            unitType: *MF_TIMED_TEXT_UNIT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipOverflow: fn(
            self: *const IMFTimedTextRegion,
            clipOverflow: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPadding: fn(
            self: *const IMFTimedTextRegion,
            before: *f64,
            start: *f64,
            after: *f64,
            end: *f64,
            unitType: *MF_TIMED_TEXT_UNIT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWrap: fn(
            self: *const IMFTimedTextRegion,
            wrap: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetZIndex: fn(
            self: *const IMFTimedTextRegion,
            zIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScrollMode: fn(
            self: *const IMFTimedTextRegion,
            scrollMode: *MF_TIMED_TEXT_SCROLL_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetName(self: *const T, name: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetName(@ptrCast(*const IMFTimedTextRegion, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetPosition(self: *const T, pX: *f64, pY: *f64, unitType: *MF_TIMED_TEXT_UNIT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetPosition(@ptrCast(*const IMFTimedTextRegion, self), pX, pY, unitType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetExtent(self: *const T, pWidth: *f64, pHeight: *f64, unitType: *MF_TIMED_TEXT_UNIT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetExtent(@ptrCast(*const IMFTimedTextRegion, self), pWidth, pHeight, unitType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetBackgroundColor(self: *const T, bgColor: *MFARGB) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetBackgroundColor(@ptrCast(*const IMFTimedTextRegion, self), bgColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetWritingMode(self: *const T, writingMode: *MF_TIMED_TEXT_WRITING_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetWritingMode(@ptrCast(*const IMFTimedTextRegion, self), writingMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetDisplayAlignment(self: *const T, displayAlign: *MF_TIMED_TEXT_DISPLAY_ALIGNMENT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetDisplayAlignment(@ptrCast(*const IMFTimedTextRegion, self), displayAlign);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetLineHeight(self: *const T, pLineHeight: *f64, unitType: *MF_TIMED_TEXT_UNIT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetLineHeight(@ptrCast(*const IMFTimedTextRegion, self), pLineHeight, unitType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetClipOverflow(self: *const T, clipOverflow: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetClipOverflow(@ptrCast(*const IMFTimedTextRegion, self), clipOverflow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetPadding(self: *const T, before: *f64, start: *f64, after: *f64, end: *f64, unitType: *MF_TIMED_TEXT_UNIT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetPadding(@ptrCast(*const IMFTimedTextRegion, self), before, start, after, end, unitType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetWrap(self: *const T, wrap: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetWrap(@ptrCast(*const IMFTimedTextRegion, self), wrap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetZIndex(self: *const T, zIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetZIndex(@ptrCast(*const IMFTimedTextRegion, self), zIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextRegion_GetScrollMode(self: *const T, scrollMode: *MF_TIMED_TEXT_SCROLL_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextRegion.VTable, self.vtable).GetScrollMode(@ptrCast(*const IMFTimedTextRegion, self), scrollMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextBinary_Value = @import("../zig.zig").Guid.initString("4AE3A412-0545-43C4-BF6F-6B97A5C6C432");
pub const IID_IMFTimedTextBinary = &IID_IMFTimedTextBinary_Value;
pub const IMFTimedTextBinary = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: fn(
            self: *const IMFTimedTextBinary,
            data: *const *const u8,
            length: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextBinary_GetData(self: *const T, data: *const *const u8, length: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextBinary.VTable, self.vtable).GetData(@ptrCast(*const IMFTimedTextBinary, self), data, length);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTimedTextCueList_Value = @import("../zig.zig").Guid.initString("AD128745-211B-40A0-9981-FE65F166D0FD");
pub const IID_IMFTimedTextCueList = &IID_IMFTimedTextCueList_Value;
pub const IMFTimedTextCueList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLength: fn(
            self: *const IMFTimedTextCueList,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetCueByIndex: fn(
            self: *const IMFTimedTextCueList,
            index: u32,
            cue: **IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCueById: fn(
            self: *const IMFTimedTextCueList,
            id: u32,
            cue: **IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCueByOriginalId: fn(
            self: *const IMFTimedTextCueList,
            originalId: [*:0]const u16,
            cue: **IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTextCue: fn(
            self: *const IMFTimedTextCueList,
            start: f64,
            duration: f64,
            text: [*:0]const u16,
            cue: ?*?*IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDataCue: fn(
            self: *const IMFTimedTextCueList,
            start: f64,
            duration: f64,
            data: [*:0]const u8,
            dataSize: u32,
            cue: ?*?*IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveCue: fn(
            self: *const IMFTimedTextCueList,
            cue: *IMFTimedTextCue,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCueList_GetLength(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IMFTimedTextCueList.VTable, self.vtable).GetLength(@ptrCast(*const IMFTimedTextCueList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCueList_GetCueByIndex(self: *const T, index: u32, cue: **IMFTimedTextCue) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCueList.VTable, self.vtable).GetCueByIndex(@ptrCast(*const IMFTimedTextCueList, self), index, cue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCueList_GetCueById(self: *const T, id: u32, cue: **IMFTimedTextCue) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCueList.VTable, self.vtable).GetCueById(@ptrCast(*const IMFTimedTextCueList, self), id, cue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCueList_GetCueByOriginalId(self: *const T, originalId: [*:0]const u16, cue: **IMFTimedTextCue) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCueList.VTable, self.vtable).GetCueByOriginalId(@ptrCast(*const IMFTimedTextCueList, self), originalId, cue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCueList_AddTextCue(self: *const T, start: f64, duration: f64, text: [*:0]const u16, cue: ?*?*IMFTimedTextCue) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCueList.VTable, self.vtable).AddTextCue(@ptrCast(*const IMFTimedTextCueList, self), start, duration, text, cue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCueList_AddDataCue(self: *const T, start: f64, duration: f64, data: [*:0]const u8, dataSize: u32, cue: ?*?*IMFTimedTextCue) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCueList.VTable, self.vtable).AddDataCue(@ptrCast(*const IMFTimedTextCueList, self), start, duration, data, dataSize, cue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTimedTextCueList_RemoveCue(self: *const T, cue: *IMFTimedTextCue) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTimedTextCueList.VTable, self.vtable).RemoveCue(@ptrCast(*const IMFTimedTextCueList, self), cue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED = extern enum(i32) {
    UNKNOWN = 0,
    AUDIO = 1,
    VIDEO = 2,
};
pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED_UNKNOWN = MF_MEDIA_ENGINE_STREAMTYPE_FAILED.UNKNOWN;
pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED_AUDIO = MF_MEDIA_ENGINE_STREAMTYPE_FAILED.AUDIO;
pub const MF_MEDIA_ENGINE_STREAMTYPE_FAILED_VIDEO = MF_MEDIA_ENGINE_STREAMTYPE_FAILED.VIDEO;

const IID_IMFMediaEngineEMENotify_Value = @import("../zig.zig").Guid.initString("9E184D15-CDB7-4F86-B49E-566689F4A601");
pub const IID_IMFMediaEngineEMENotify = &IID_IMFMediaEngineEMENotify_Value;
pub const IMFMediaEngineEMENotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Encrypted: fn(
            self: *const IMFMediaEngineEMENotify,
            pbInitData: ?[*:0]const u8,
            cb: u32,
            bstrInitDataType: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) void,
        WaitingForKey: fn(
            self: *const IMFMediaEngineEMENotify,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEMENotify_Encrypted(self: *const T, pbInitData: ?[*:0]const u8, cb: u32, bstrInitDataType: BSTR) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaEngineEMENotify.VTable, self.vtable).Encrypted(@ptrCast(*const IMFMediaEngineEMENotify, self), pbInitData, cb, bstrInitDataType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineEMENotify_WaitingForKey(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaEngineEMENotify.VTable, self.vtable).WaitingForKey(@ptrCast(*const IMFMediaEngineEMENotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_MEDIAKEYS_REQUIREMENT = extern enum(i32) {
    REQUIRED = 1,
    OPTIONAL = 2,
    NOT_ALLOWED = 3,
};
pub const MF_MEDIAKEYS_REQUIREMENT_REQUIRED = MF_MEDIAKEYS_REQUIREMENT.REQUIRED;
pub const MF_MEDIAKEYS_REQUIREMENT_OPTIONAL = MF_MEDIAKEYS_REQUIREMENT.OPTIONAL;
pub const MF_MEDIAKEYS_REQUIREMENT_NOT_ALLOWED = MF_MEDIAKEYS_REQUIREMENT.NOT_ALLOWED;

const IID_IMFMediaKeySessionNotify2_Value = @import("../zig.zig").Guid.initString("C3A9E92A-DA88-46B0-A110-6CF953026CB9");
pub const IID_IMFMediaKeySessionNotify2 = &IID_IMFMediaKeySessionNotify2_Value;
pub const IMFMediaKeySessionNotify2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaKeySessionNotify.VTable,
        KeyMessage2: fn(
            self: *const IMFMediaKeySessionNotify2,
            eMessageType: MF_MEDIAKEYSESSION_MESSAGETYPE,
            destinationURL: BSTR,
            pbMessage: [*:0]const u8,
            cbMessage: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        KeyStatusChange: fn(
            self: *const IMFMediaKeySessionNotify2,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaKeySessionNotify.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySessionNotify2_KeyMessage2(self: *const T, eMessageType: MF_MEDIAKEYSESSION_MESSAGETYPE, destinationURL: BSTR, pbMessage: [*:0]const u8, cbMessage: u32) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaKeySessionNotify2.VTable, self.vtable).KeyMessage2(@ptrCast(*const IMFMediaKeySessionNotify2, self), eMessageType, destinationURL, pbMessage, cbMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySessionNotify2_KeyStatusChange(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFMediaKeySessionNotify2.VTable, self.vtable).KeyStatusChange(@ptrCast(*const IMFMediaKeySessionNotify2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaKeySystemAccess_Value = @import("../zig.zig").Guid.initString("AEC63FDA-7A97-4944-B35C-6C6DF8085CC3");
pub const IID_IMFMediaKeySystemAccess = &IID_IMFMediaKeySystemAccess_Value;
pub const IMFMediaKeySystemAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMediaKeys: fn(
            self: *const IMFMediaKeySystemAccess,
            pCdmCustomConfig: ?*IPropertyStore,
            ppKeys: **IMFMediaKeys2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_SupportedConfiguration: fn(
            self: *const IMFMediaKeySystemAccess,
            ppSupportedConfiguration: **IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_KeySystem: fn(
            self: *const IMFMediaKeySystemAccess,
            pKeySystem: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySystemAccess_CreateMediaKeys(self: *const T, pCdmCustomConfig: ?*IPropertyStore, ppKeys: **IMFMediaKeys2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySystemAccess.VTable, self.vtable).CreateMediaKeys(@ptrCast(*const IMFMediaKeySystemAccess, self), pCdmCustomConfig, ppKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySystemAccess_get_SupportedConfiguration(self: *const T, ppSupportedConfiguration: **IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySystemAccess.VTable, self.vtable).get_SupportedConfiguration(@ptrCast(*const IMFMediaKeySystemAccess, self), ppSupportedConfiguration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySystemAccess_get_KeySystem(self: *const T, pKeySystem: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySystemAccess.VTable, self.vtable).get_KeySystem(@ptrCast(*const IMFMediaKeySystemAccess, self), pKeySystem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineClassFactory3_Value = @import("../zig.zig").Guid.initString("3787614F-65F7-4003-B673-EAD8293A0E60");
pub const IID_IMFMediaEngineClassFactory3 = &IID_IMFMediaEngineClassFactory3_Value;
pub const IMFMediaEngineClassFactory3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMediaKeySystemAccess: fn(
            self: *const IMFMediaEngineClassFactory3,
            keySystem: BSTR,
            ppSupportedConfigurationsArray: [*]*IPropertyStore,
            uSize: u32,
            ppKeyAccess: **IMFMediaKeySystemAccess,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineClassFactory3_CreateMediaKeySystemAccess(self: *const T, keySystem: BSTR, ppSupportedConfigurationsArray: [*]*IPropertyStore, uSize: u32, ppKeyAccess: **IMFMediaKeySystemAccess) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineClassFactory3.VTable, self.vtable).CreateMediaKeySystemAccess(@ptrCast(*const IMFMediaEngineClassFactory3, self), keySystem, ppSupportedConfigurationsArray, uSize, ppKeyAccess);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaKeys2_Value = @import("../zig.zig").Guid.initString("45892507-AD66-4DE2-83A2-ACBB13CD8D43");
pub const IID_IMFMediaKeys2 = &IID_IMFMediaKeys2_Value;
pub const IMFMediaKeys2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaKeys.VTable,
        CreateSession2: fn(
            self: *const IMFMediaKeys2,
            eSessionType: MF_MEDIAKEYSESSION_TYPE,
            pMFMediaKeySessionNotify2: *IMFMediaKeySessionNotify2,
            ppSession: **IMFMediaKeySession2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetServerCertificate: fn(
            self: *const IMFMediaKeys2,
            pbServerCertificate: ?[*:0]const u8,
            cb: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDOMException: fn(
            self: *const IMFMediaKeys2,
            systemCode: HRESULT,
            code: *HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaKeys.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeys2_CreateSession2(self: *const T, eSessionType: MF_MEDIAKEYSESSION_TYPE, pMFMediaKeySessionNotify2: *IMFMediaKeySessionNotify2, ppSession: **IMFMediaKeySession2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeys2.VTable, self.vtable).CreateSession2(@ptrCast(*const IMFMediaKeys2, self), eSessionType, pMFMediaKeySessionNotify2, ppSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeys2_SetServerCertificate(self: *const T, pbServerCertificate: ?[*:0]const u8, cb: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeys2.VTable, self.vtable).SetServerCertificate(@ptrCast(*const IMFMediaKeys2, self), pbServerCertificate, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeys2_GetDOMException(self: *const T, systemCode: HRESULT, code: *HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeys2.VTable, self.vtable).GetDOMException(@ptrCast(*const IMFMediaKeys2, self), systemCode, code);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaKeySession2_Value = @import("../zig.zig").Guid.initString("E9707E05-6D55-4636-B185-3DE21210BD75");
pub const IID_IMFMediaKeySession2 = &IID_IMFMediaKeySession2_Value;
pub const IMFMediaKeySession2 = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaKeySession.VTable,
        get_KeyStatuses: fn(
            self: *const IMFMediaKeySession2,
            pKeyStatusesArray: **MFMediaKeyStatus,
            puSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IMFMediaKeySession2,
            bstrSessionId: BSTR,
            pfLoaded: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateRequest: fn(
            self: *const IMFMediaKeySession2,
            initDataType: BSTR,
            pbInitData: [*:0]const u8,
            cb: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Expiration: fn(
            self: *const IMFMediaKeySession2,
            dblExpiration: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMFMediaKeySession2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFMediaKeySession2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaKeySession.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession2_get_KeyStatuses(self: *const T, pKeyStatusesArray: **MFMediaKeyStatus, puSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession2.VTable, self.vtable).get_KeyStatuses(@ptrCast(*const IMFMediaKeySession2, self), pKeyStatusesArray, puSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession2_Load(self: *const T, bstrSessionId: BSTR, pfLoaded: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession2.VTable, self.vtable).Load(@ptrCast(*const IMFMediaKeySession2, self), bstrSessionId, pfLoaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession2_GenerateRequest(self: *const T, initDataType: BSTR, pbInitData: [*:0]const u8, cb: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession2.VTable, self.vtable).GenerateRequest(@ptrCast(*const IMFMediaKeySession2, self), initDataType, pbInitData, cb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession2_get_Expiration(self: *const T, dblExpiration: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession2.VTable, self.vtable).get_Expiration(@ptrCast(*const IMFMediaKeySession2, self), dblExpiration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession2_Remove(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession2.VTable, self.vtable).Remove(@ptrCast(*const IMFMediaKeySession2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaKeySession2_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaKeySession2.VTable, self.vtable).Shutdown(@ptrCast(*const IMFMediaKeySession2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaEngineClassFactory4_Value = @import("../zig.zig").Guid.initString("FBE256C1-43CF-4A9B-8CB8-CE8632A34186");
pub const IID_IMFMediaEngineClassFactory4 = &IID_IMFMediaEngineClassFactory4_Value;
pub const IMFMediaEngineClassFactory4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContentDecryptionModuleFactory: fn(
            self: *const IMFMediaEngineClassFactory4,
            keySystem: [*:0]const u16,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaEngineClassFactory4_CreateContentDecryptionModuleFactory(self: *const T, keySystem: [*:0]const u16, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaEngineClassFactory4.VTable, self.vtable).CreateContentDecryptionModuleFactory(@ptrCast(*const IMFMediaEngineClassFactory4, self), keySystem, riid, ppvObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFDLNASinkInit_Value = @import("../zig.zig").Guid.initString("0C012799-1B61-4C10-BDA9-04445BE5F561");
pub const IID_IMFDLNASinkInit = &IID_IMFDLNASinkInit_Value;
pub const IMFDLNASinkInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IMFDLNASinkInit,
            pByteStream: *IMFByteStream,
            fPal: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDLNASinkInit_Initialize(self: *const T, pByteStream: *IMFByteStream, fPal: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDLNASinkInit.VTable, self.vtable).Initialize(@ptrCast(*const IMFDLNASinkInit, self), pByteStream, fPal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFMPEG2DLNASINKSTATS = extern struct {
    cBytesWritten: u64,
    fPAL: BOOL,
    fccVideo: u32,
    dwVideoWidth: u32,
    dwVideoHeight: u32,
    cVideoFramesReceived: u64,
    cVideoFramesEncoded: u64,
    cVideoFramesSkipped: u64,
    cBlackVideoFramesEncoded: u64,
    cVideoFramesDuplicated: u64,
    cAudioSamplesPerSec: u32,
    cAudioChannels: u32,
    cAudioBytesReceived: u64,
    cAudioFramesEncoded: u64,
};

const IID_IMFReadWriteClassFactory_Value = @import("../zig.zig").Guid.initString("E7FE2E12-661C-40DA-92F9-4F002AB67627");
pub const IID_IMFReadWriteClassFactory = &IID_IMFReadWriteClassFactory_Value;
pub const IMFReadWriteClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstanceFromURL: fn(
            self: *const IMFReadWriteClassFactory,
            clsid: *const Guid,
            pwszURL: [*:0]const u16,
            pAttributes: ?*IMFAttributes,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstanceFromObject: fn(
            self: *const IMFReadWriteClassFactory,
            clsid: *const Guid,
            punkObject: *IUnknown,
            pAttributes: ?*IMFAttributes,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFReadWriteClassFactory_CreateInstanceFromURL(self: *const T, clsid: *const Guid, pwszURL: [*:0]const u16, pAttributes: ?*IMFAttributes, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFReadWriteClassFactory.VTable, self.vtable).CreateInstanceFromURL(@ptrCast(*const IMFReadWriteClassFactory, self), clsid, pwszURL, pAttributes, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFReadWriteClassFactory_CreateInstanceFromObject(self: *const T, clsid: *const Guid, punkObject: *IUnknown, pAttributes: ?*IMFAttributes, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFReadWriteClassFactory.VTable, self.vtable).CreateInstanceFromObject(@ptrCast(*const IMFReadWriteClassFactory, self), clsid, punkObject, pAttributes, riid, ppvObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_SOURCE_READER_FLAG = extern enum(i32) {
    MF_SOURCE_READERF_ERROR = 1,
    MF_SOURCE_READERF_ENDOFSTREAM = 2,
    MF_SOURCE_READERF_NEWSTREAM = 4,
    MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED = 16,
    MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED = 32,
    MF_SOURCE_READERF_STREAMTICK = 256,
    MF_SOURCE_READERF_ALLEFFECTSREMOVED = 512,
};
pub const MF_SOURCE_READERF_ERROR = MF_SOURCE_READER_FLAG.MF_SOURCE_READERF_ERROR;
pub const MF_SOURCE_READERF_ENDOFSTREAM = MF_SOURCE_READER_FLAG.MF_SOURCE_READERF_ENDOFSTREAM;
pub const MF_SOURCE_READERF_NEWSTREAM = MF_SOURCE_READER_FLAG.MF_SOURCE_READERF_NEWSTREAM;
pub const MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED = MF_SOURCE_READER_FLAG.MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED;
pub const MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED = MF_SOURCE_READER_FLAG.MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED;
pub const MF_SOURCE_READERF_STREAMTICK = MF_SOURCE_READER_FLAG.MF_SOURCE_READERF_STREAMTICK;
pub const MF_SOURCE_READERF_ALLEFFECTSREMOVED = MF_SOURCE_READER_FLAG.MF_SOURCE_READERF_ALLEFFECTSREMOVED;

pub const MF_SOURCE_READER_CONTROL_FLAG = extern enum(i32) {
    MF_SOURCE_READER_CONTROLF_DRAIN = 1,
};
pub const MF_SOURCE_READER_CONTROLF_DRAIN = MF_SOURCE_READER_CONTROL_FLAG.MF_SOURCE_READER_CONTROLF_DRAIN;

pub const __MIDL___MIDL_itf_mfreadwrite_0000_0001_0001 = extern enum(i32) {
    MF_SOURCE_READER_INVALID_STREAM_INDEX = -1,
    MF_SOURCE_READER_ALL_STREAMS = -2,
    MF_SOURCE_READER_ANY_STREAM = -2,
    MF_SOURCE_READER_FIRST_AUDIO_STREAM = -3,
    MF_SOURCE_READER_FIRST_VIDEO_STREAM = -4,
    MF_SOURCE_READER_MEDIASOURCE = -1,
};
pub const MF_SOURCE_READER_INVALID_STREAM_INDEX = __MIDL___MIDL_itf_mfreadwrite_0000_0001_0001.MF_SOURCE_READER_INVALID_STREAM_INDEX;
pub const MF_SOURCE_READER_ALL_STREAMS = __MIDL___MIDL_itf_mfreadwrite_0000_0001_0001.MF_SOURCE_READER_ALL_STREAMS;
pub const MF_SOURCE_READER_ANY_STREAM = __MIDL___MIDL_itf_mfreadwrite_0000_0001_0001.MF_SOURCE_READER_ANY_STREAM;
pub const MF_SOURCE_READER_FIRST_AUDIO_STREAM = __MIDL___MIDL_itf_mfreadwrite_0000_0001_0001.MF_SOURCE_READER_FIRST_AUDIO_STREAM;
pub const MF_SOURCE_READER_FIRST_VIDEO_STREAM = __MIDL___MIDL_itf_mfreadwrite_0000_0001_0001.MF_SOURCE_READER_FIRST_VIDEO_STREAM;
pub const MF_SOURCE_READER_MEDIASOURCE = __MIDL___MIDL_itf_mfreadwrite_0000_0001_0001.MF_SOURCE_READER_MEDIASOURCE;

pub const __MIDL___MIDL_itf_mfreadwrite_0000_0001_0002 = extern enum(i32) {
    MF_SOURCE_READER_CURRENT_TYPE_INDEX = -1,
};
pub const MF_SOURCE_READER_CURRENT_TYPE_INDEX = __MIDL___MIDL_itf_mfreadwrite_0000_0001_0002.MF_SOURCE_READER_CURRENT_TYPE_INDEX;

const IID_IMFSourceReader_Value = @import("../zig.zig").Guid.initString("70AE66F2-C809-4E4F-8915-BDCB406B7993");
pub const IID_IMFSourceReader = &IID_IMFSourceReader_Value;
pub const IMFSourceReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStreamSelection: fn(
            self: *const IMFSourceReader,
            dwStreamIndex: u32,
            pfSelected: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamSelection: fn(
            self: *const IMFSourceReader,
            dwStreamIndex: u32,
            fSelected: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNativeMediaType: fn(
            self: *const IMFSourceReader,
            dwStreamIndex: u32,
            dwMediaTypeIndex: u32,
            ppMediaType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentMediaType: fn(
            self: *const IMFSourceReader,
            dwStreamIndex: u32,
            ppMediaType: **IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentMediaType: fn(
            self: *const IMFSourceReader,
            dwStreamIndex: u32,
            pdwReserved: *u32,
            pMediaType: *IMFMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentPosition: fn(
            self: *const IMFSourceReader,
            guidTimeFormat: *const Guid,
            varPosition: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadSample: fn(
            self: *const IMFSourceReader,
            dwStreamIndex: u32,
            dwControlFlags: u32,
            pdwActualStreamIndex: ?*u32,
            pdwStreamFlags: ?*u32,
            pllTimestamp: ?*i64,
            ppSample: ?*?*IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IMFSourceReader,
            dwStreamIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceForStream: fn(
            self: *const IMFSourceReader,
            dwStreamIndex: u32,
            guidService: *const Guid,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPresentationAttribute: fn(
            self: *const IMFSourceReader,
            dwStreamIndex: u32,
            guidAttribute: *const Guid,
            pvarAttribute: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_GetStreamSelection(self: *const T, dwStreamIndex: u32, pfSelected: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).GetStreamSelection(@ptrCast(*const IMFSourceReader, self), dwStreamIndex, pfSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_SetStreamSelection(self: *const T, dwStreamIndex: u32, fSelected: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).SetStreamSelection(@ptrCast(*const IMFSourceReader, self), dwStreamIndex, fSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_GetNativeMediaType(self: *const T, dwStreamIndex: u32, dwMediaTypeIndex: u32, ppMediaType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).GetNativeMediaType(@ptrCast(*const IMFSourceReader, self), dwStreamIndex, dwMediaTypeIndex, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_GetCurrentMediaType(self: *const T, dwStreamIndex: u32, ppMediaType: **IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).GetCurrentMediaType(@ptrCast(*const IMFSourceReader, self), dwStreamIndex, ppMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_SetCurrentMediaType(self: *const T, dwStreamIndex: u32, pdwReserved: *u32, pMediaType: *IMFMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).SetCurrentMediaType(@ptrCast(*const IMFSourceReader, self), dwStreamIndex, pdwReserved, pMediaType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_SetCurrentPosition(self: *const T, guidTimeFormat: *const Guid, varPosition: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).SetCurrentPosition(@ptrCast(*const IMFSourceReader, self), guidTimeFormat, varPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_ReadSample(self: *const T, dwStreamIndex: u32, dwControlFlags: u32, pdwActualStreamIndex: ?*u32, pdwStreamFlags: ?*u32, pllTimestamp: ?*i64, ppSample: ?*?*IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).ReadSample(@ptrCast(*const IMFSourceReader, self), dwStreamIndex, dwControlFlags, pdwActualStreamIndex, pdwStreamFlags, pllTimestamp, ppSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_Flush(self: *const T, dwStreamIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).Flush(@ptrCast(*const IMFSourceReader, self), dwStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_GetServiceForStream(self: *const T, dwStreamIndex: u32, guidService: *const Guid, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).GetServiceForStream(@ptrCast(*const IMFSourceReader, self), dwStreamIndex, guidService, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReader_GetPresentationAttribute(self: *const T, dwStreamIndex: u32, guidAttribute: *const Guid, pvarAttribute: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReader.VTable, self.vtable).GetPresentationAttribute(@ptrCast(*const IMFSourceReader, self), dwStreamIndex, guidAttribute, pvarAttribute);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSourceReaderEx_Value = @import("../zig.zig").Guid.initString("7B981CF0-560E-4116-9875-B099895F23D7");
pub const IID_IMFSourceReaderEx = &IID_IMFSourceReaderEx_Value;
pub const IMFSourceReaderEx = extern struct {
    pub const VTable = extern struct {
        base: IMFSourceReader.VTable,
        SetNativeMediaType: fn(
            self: *const IMFSourceReaderEx,
            dwStreamIndex: u32,
            pMediaType: ?*IMFMediaType,
            pdwStreamFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTransformForStream: fn(
            self: *const IMFSourceReaderEx,
            dwStreamIndex: u32,
            pTransformOrActivate: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllTransformsForStream: fn(
            self: *const IMFSourceReaderEx,
            dwStreamIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransformForStream: fn(
            self: *const IMFSourceReaderEx,
            dwStreamIndex: u32,
            dwTransformIndex: u32,
            pGuidCategory: ?*Guid,
            ppTransform: **IMFTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFSourceReader.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReaderEx_SetNativeMediaType(self: *const T, dwStreamIndex: u32, pMediaType: ?*IMFMediaType, pdwStreamFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReaderEx.VTable, self.vtable).SetNativeMediaType(@ptrCast(*const IMFSourceReaderEx, self), dwStreamIndex, pMediaType, pdwStreamFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReaderEx_AddTransformForStream(self: *const T, dwStreamIndex: u32, pTransformOrActivate: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReaderEx.VTable, self.vtable).AddTransformForStream(@ptrCast(*const IMFSourceReaderEx, self), dwStreamIndex, pTransformOrActivate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReaderEx_RemoveAllTransformsForStream(self: *const T, dwStreamIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReaderEx.VTable, self.vtable).RemoveAllTransformsForStream(@ptrCast(*const IMFSourceReaderEx, self), dwStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReaderEx_GetTransformForStream(self: *const T, dwStreamIndex: u32, dwTransformIndex: u32, pGuidCategory: ?*Guid, ppTransform: **IMFTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReaderEx.VTable, self.vtable).GetTransformForStream(@ptrCast(*const IMFSourceReaderEx, self), dwStreamIndex, dwTransformIndex, pGuidCategory, ppTransform);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSourceReaderCallback_Value = @import("../zig.zig").Guid.initString("DEEC8D99-FA1D-4D82-84C2-2C8969944867");
pub const IID_IMFSourceReaderCallback = &IID_IMFSourceReaderCallback_Value;
pub const IMFSourceReaderCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnReadSample: fn(
            self: *const IMFSourceReaderCallback,
            hrStatus: HRESULT,
            dwStreamIndex: u32,
            dwStreamFlags: u32,
            llTimestamp: i64,
            pSample: ?*IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFlush: fn(
            self: *const IMFSourceReaderCallback,
            dwStreamIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEvent: fn(
            self: *const IMFSourceReaderCallback,
            dwStreamIndex: u32,
            pEvent: *IMFMediaEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReaderCallback_OnReadSample(self: *const T, hrStatus: HRESULT, dwStreamIndex: u32, dwStreamFlags: u32, llTimestamp: i64, pSample: ?*IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReaderCallback.VTable, self.vtable).OnReadSample(@ptrCast(*const IMFSourceReaderCallback, self), hrStatus, dwStreamIndex, dwStreamFlags, llTimestamp, pSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReaderCallback_OnFlush(self: *const T, dwStreamIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReaderCallback.VTable, self.vtable).OnFlush(@ptrCast(*const IMFSourceReaderCallback, self), dwStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReaderCallback_OnEvent(self: *const T, dwStreamIndex: u32, pEvent: *IMFMediaEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReaderCallback.VTable, self.vtable).OnEvent(@ptrCast(*const IMFSourceReaderCallback, self), dwStreamIndex, pEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSourceReaderCallback2_Value = @import("../zig.zig").Guid.initString("CF839FE6-8C2A-4DD2-B6EA-C22D6961AF05");
pub const IID_IMFSourceReaderCallback2 = &IID_IMFSourceReaderCallback2_Value;
pub const IMFSourceReaderCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IMFSourceReaderCallback.VTable,
        OnTransformChange: fn(
            self: *const IMFSourceReaderCallback2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStreamError: fn(
            self: *const IMFSourceReaderCallback2,
            dwStreamIndex: u32,
            hrStatus: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFSourceReaderCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReaderCallback2_OnTransformChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReaderCallback2.VTable, self.vtable).OnTransformChange(@ptrCast(*const IMFSourceReaderCallback2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSourceReaderCallback2_OnStreamError(self: *const T, dwStreamIndex: u32, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSourceReaderCallback2.VTable, self.vtable).OnStreamError(@ptrCast(*const IMFSourceReaderCallback2, self), dwStreamIndex, hrStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_mfreadwrite_0000_0005_0001 = extern enum(i32) {
    MF_SINK_WRITER_INVALID_STREAM_INDEX = -1,
    MF_SINK_WRITER_ALL_STREAMS = -2,
    MF_SINK_WRITER_MEDIASINK = -1,
};
pub const MF_SINK_WRITER_INVALID_STREAM_INDEX = __MIDL___MIDL_itf_mfreadwrite_0000_0005_0001.MF_SINK_WRITER_INVALID_STREAM_INDEX;
pub const MF_SINK_WRITER_ALL_STREAMS = __MIDL___MIDL_itf_mfreadwrite_0000_0005_0001.MF_SINK_WRITER_ALL_STREAMS;
pub const MF_SINK_WRITER_MEDIASINK = __MIDL___MIDL_itf_mfreadwrite_0000_0005_0001.MF_SINK_WRITER_MEDIASINK;

pub const MF_SINK_WRITER_STATISTICS = extern struct {
    cb: u32,
    llLastTimestampReceived: i64,
    llLastTimestampEncoded: i64,
    llLastTimestampProcessed: i64,
    llLastStreamTickReceived: i64,
    llLastSinkSampleRequest: i64,
    qwNumSamplesReceived: u64,
    qwNumSamplesEncoded: u64,
    qwNumSamplesProcessed: u64,
    qwNumStreamTicksReceived: u64,
    dwByteCountQueued: u32,
    qwByteCountProcessed: u64,
    dwNumOutstandingSinkSampleRequests: u32,
    dwAverageSampleRateReceived: u32,
    dwAverageSampleRateEncoded: u32,
    dwAverageSampleRateProcessed: u32,
};

const IID_IMFSinkWriter_Value = @import("../zig.zig").Guid.initString("3137F1CD-FE5E-4805-A5D8-FB477448CB3D");
pub const IID_IMFSinkWriter = &IID_IMFSinkWriter_Value;
pub const IMFSinkWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddStream: fn(
            self: *const IMFSinkWriter,
            pTargetMediaType: *IMFMediaType,
            pdwStreamIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputMediaType: fn(
            self: *const IMFSinkWriter,
            dwStreamIndex: u32,
            pInputMediaType: *IMFMediaType,
            pEncodingParameters: ?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginWriting: fn(
            self: *const IMFSinkWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSample: fn(
            self: *const IMFSinkWriter,
            dwStreamIndex: u32,
            pSample: *IMFSample,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SendStreamTick: fn(
            self: *const IMFSinkWriter,
            dwStreamIndex: u32,
            llTimestamp: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlaceMarker: fn(
            self: *const IMFSinkWriter,
            dwStreamIndex: u32,
            pvContext: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyEndOfSegment: fn(
            self: *const IMFSinkWriter,
            dwStreamIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IMFSinkWriter,
            dwStreamIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finalize: fn(
            self: *const IMFSinkWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetServiceForStream: fn(
            self: *const IMFSinkWriter,
            dwStreamIndex: u32,
            guidService: *const Guid,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatistics: fn(
            self: *const IMFSinkWriter,
            dwStreamIndex: u32,
            pStats: *MF_SINK_WRITER_STATISTICS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_AddStream(self: *const T, pTargetMediaType: *IMFMediaType, pdwStreamIndex: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).AddStream(@ptrCast(*const IMFSinkWriter, self), pTargetMediaType, pdwStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_SetInputMediaType(self: *const T, dwStreamIndex: u32, pInputMediaType: *IMFMediaType, pEncodingParameters: ?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).SetInputMediaType(@ptrCast(*const IMFSinkWriter, self), dwStreamIndex, pInputMediaType, pEncodingParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_BeginWriting(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).BeginWriting(@ptrCast(*const IMFSinkWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_WriteSample(self: *const T, dwStreamIndex: u32, pSample: *IMFSample) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).WriteSample(@ptrCast(*const IMFSinkWriter, self), dwStreamIndex, pSample);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_SendStreamTick(self: *const T, dwStreamIndex: u32, llTimestamp: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).SendStreamTick(@ptrCast(*const IMFSinkWriter, self), dwStreamIndex, llTimestamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_PlaceMarker(self: *const T, dwStreamIndex: u32, pvContext: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).PlaceMarker(@ptrCast(*const IMFSinkWriter, self), dwStreamIndex, pvContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_NotifyEndOfSegment(self: *const T, dwStreamIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).NotifyEndOfSegment(@ptrCast(*const IMFSinkWriter, self), dwStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_Flush(self: *const T, dwStreamIndex: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).Flush(@ptrCast(*const IMFSinkWriter, self), dwStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_Finalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).Finalize(@ptrCast(*const IMFSinkWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_GetServiceForStream(self: *const T, dwStreamIndex: u32, guidService: *const Guid, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).GetServiceForStream(@ptrCast(*const IMFSinkWriter, self), dwStreamIndex, guidService, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriter_GetStatistics(self: *const T, dwStreamIndex: u32, pStats: *MF_SINK_WRITER_STATISTICS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriter.VTable, self.vtable).GetStatistics(@ptrCast(*const IMFSinkWriter, self), dwStreamIndex, pStats);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSinkWriterEx_Value = @import("../zig.zig").Guid.initString("588D72AB-5BC1-496A-8714-B70617141B25");
pub const IID_IMFSinkWriterEx = &IID_IMFSinkWriterEx_Value;
pub const IMFSinkWriterEx = extern struct {
    pub const VTable = extern struct {
        base: IMFSinkWriter.VTable,
        GetTransformForStream: fn(
            self: *const IMFSinkWriterEx,
            dwStreamIndex: u32,
            dwTransformIndex: u32,
            pGuidCategory: ?*Guid,
            ppTransform: **IMFTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFSinkWriter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriterEx_GetTransformForStream(self: *const T, dwStreamIndex: u32, dwTransformIndex: u32, pGuidCategory: ?*Guid, ppTransform: **IMFTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriterEx.VTable, self.vtable).GetTransformForStream(@ptrCast(*const IMFSinkWriterEx, self), dwStreamIndex, dwTransformIndex, pGuidCategory, ppTransform);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSinkWriterEncoderConfig_Value = @import("../zig.zig").Guid.initString("17C3779E-3CDE-4EDE-8C60-3899F5F53AD6");
pub const IID_IMFSinkWriterEncoderConfig = &IID_IMFSinkWriterEncoderConfig_Value;
pub const IMFSinkWriterEncoderConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetTargetMediaType: fn(
            self: *const IMFSinkWriterEncoderConfig,
            dwStreamIndex: u32,
            pTargetMediaType: *IMFMediaType,
            pEncodingParameters: ?*IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PlaceEncodingParameters: fn(
            self: *const IMFSinkWriterEncoderConfig,
            dwStreamIndex: u32,
            pEncodingParameters: *IMFAttributes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriterEncoderConfig_SetTargetMediaType(self: *const T, dwStreamIndex: u32, pTargetMediaType: *IMFMediaType, pEncodingParameters: ?*IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriterEncoderConfig.VTable, self.vtable).SetTargetMediaType(@ptrCast(*const IMFSinkWriterEncoderConfig, self), dwStreamIndex, pTargetMediaType, pEncodingParameters);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriterEncoderConfig_PlaceEncodingParameters(self: *const T, dwStreamIndex: u32, pEncodingParameters: *IMFAttributes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriterEncoderConfig.VTable, self.vtable).PlaceEncodingParameters(@ptrCast(*const IMFSinkWriterEncoderConfig, self), dwStreamIndex, pEncodingParameters);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSinkWriterCallback_Value = @import("../zig.zig").Guid.initString("666F76DE-33D2-41B9-A458-29ED0A972C58");
pub const IID_IMFSinkWriterCallback = &IID_IMFSinkWriterCallback_Value;
pub const IMFSinkWriterCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnFinalize: fn(
            self: *const IMFSinkWriterCallback,
            hrStatus: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnMarker: fn(
            self: *const IMFSinkWriterCallback,
            dwStreamIndex: u32,
            pvContext: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriterCallback_OnFinalize(self: *const T, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriterCallback.VTable, self.vtable).OnFinalize(@ptrCast(*const IMFSinkWriterCallback, self), hrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriterCallback_OnMarker(self: *const T, dwStreamIndex: u32, pvContext: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriterCallback.VTable, self.vtable).OnMarker(@ptrCast(*const IMFSinkWriterCallback, self), dwStreamIndex, pvContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSinkWriterCallback2_Value = @import("../zig.zig").Guid.initString("2456BD58-C067-4513-84FE-8D0C88FFDC61");
pub const IID_IMFSinkWriterCallback2 = &IID_IMFSinkWriterCallback2_Value;
pub const IMFSinkWriterCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IMFSinkWriterCallback.VTable,
        OnTransformChange: fn(
            self: *const IMFSinkWriterCallback2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStreamError: fn(
            self: *const IMFSinkWriterCallback2,
            dwStreamIndex: u32,
            hrStatus: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFSinkWriterCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriterCallback2_OnTransformChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriterCallback2.VTable, self.vtable).OnTransformChange(@ptrCast(*const IMFSinkWriterCallback2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSinkWriterCallback2_OnStreamError(self: *const T, dwStreamIndex: u32, hrStatus: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSinkWriterCallback2.VTable, self.vtable).OnStreamError(@ptrCast(*const IMFSinkWriterCallback2, self), dwStreamIndex, hrStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoPositionMapper_Value = @import("../zig.zig").Guid.initString("1F6A9F17-E70B-4E24-8AE4-0B2C3BA7A4AE");
pub const IID_IMFVideoPositionMapper = &IID_IMFVideoPositionMapper_Value;
pub const IMFVideoPositionMapper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MapOutputCoordinateToInputStream: fn(
            self: *const IMFVideoPositionMapper,
            xOut: f32,
            yOut: f32,
            dwOutputStreamIndex: u32,
            dwInputStreamIndex: u32,
            pxIn: *f32,
            pyIn: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoPositionMapper_MapOutputCoordinateToInputStream(self: *const T, xOut: f32, yOut: f32, dwOutputStreamIndex: u32, dwInputStreamIndex: u32, pxIn: *f32, pyIn: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoPositionMapper.VTable, self.vtable).MapOutputCoordinateToInputStream(@ptrCast(*const IMFVideoPositionMapper, self), xOut, yOut, dwOutputStreamIndex, dwInputStreamIndex, pxIn, pyIn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoDeviceID_Value = @import("../zig.zig").Guid.initString("A38D9567-5A9C-4F3C-B293-8EB415B279BA");
pub const IID_IMFVideoDeviceID = &IID_IMFVideoDeviceID_Value;
pub const IMFVideoDeviceID = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeviceID: fn(
            self: *const IMFVideoDeviceID,
            pDeviceID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDeviceID_GetDeviceID(self: *const T, pDeviceID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDeviceID.VTable, self.vtable).GetDeviceID(@ptrCast(*const IMFVideoDeviceID, self), pDeviceID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoAspectRatioMode = extern enum(i32) {
    MFVideoARMode_None = 0,
    MFVideoARMode_PreservePicture = 1,
    MFVideoARMode_PreservePixel = 2,
    MFVideoARMode_NonLinearStretch = 4,
    MFVideoARMode_Mask = 7,
};
pub const MFVideoARMode_None = MFVideoAspectRatioMode.MFVideoARMode_None;
pub const MFVideoARMode_PreservePicture = MFVideoAspectRatioMode.MFVideoARMode_PreservePicture;
pub const MFVideoARMode_PreservePixel = MFVideoAspectRatioMode.MFVideoARMode_PreservePixel;
pub const MFVideoARMode_NonLinearStretch = MFVideoAspectRatioMode.MFVideoARMode_NonLinearStretch;
pub const MFVideoARMode_Mask = MFVideoAspectRatioMode.MFVideoARMode_Mask;

pub const MFVideoRenderPrefs = extern enum(i32) {
    DoNotRenderBorder = 1,
    DoNotClipToDevice = 2,
    AllowOutputThrottling = 4,
    ForceOutputThrottling = 8,
    ForceBatching = 16,
    AllowBatching = 32,
    ForceScaling = 64,
    AllowScaling = 128,
    DoNotRepaintOnStop = 256,
    Mask = 511,
};
pub const MFVideoRenderPrefs_DoNotRenderBorder = MFVideoRenderPrefs.DoNotRenderBorder;
pub const MFVideoRenderPrefs_DoNotClipToDevice = MFVideoRenderPrefs.DoNotClipToDevice;
pub const MFVideoRenderPrefs_AllowOutputThrottling = MFVideoRenderPrefs.AllowOutputThrottling;
pub const MFVideoRenderPrefs_ForceOutputThrottling = MFVideoRenderPrefs.ForceOutputThrottling;
pub const MFVideoRenderPrefs_ForceBatching = MFVideoRenderPrefs.ForceBatching;
pub const MFVideoRenderPrefs_AllowBatching = MFVideoRenderPrefs.AllowBatching;
pub const MFVideoRenderPrefs_ForceScaling = MFVideoRenderPrefs.ForceScaling;
pub const MFVideoRenderPrefs_AllowScaling = MFVideoRenderPrefs.AllowScaling;
pub const MFVideoRenderPrefs_DoNotRepaintOnStop = MFVideoRenderPrefs.DoNotRepaintOnStop;
pub const MFVideoRenderPrefs_Mask = MFVideoRenderPrefs.Mask;

const IID_IMFVideoDisplayControl_Value = @import("../zig.zig").Guid.initString("A490B1E4-AB84-4D31-A1B2-181E03B1077A");
pub const IID_IMFVideoDisplayControl = &IID_IMFVideoDisplayControl_Value;
pub const IMFVideoDisplayControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNativeVideoSize: fn(
            self: *const IMFVideoDisplayControl,
            pszVideo: *SIZE,
            pszARVideo: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdealVideoSize: fn(
            self: *const IMFVideoDisplayControl,
            pszMin: *SIZE,
            pszMax: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoPosition: fn(
            self: *const IMFVideoDisplayControl,
            pnrcSource: *const MFVideoNormalizedRect,
            prcDest: *const RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoPosition: fn(
            self: *const IMFVideoDisplayControl,
            pnrcSource: *MFVideoNormalizedRect,
            prcDest: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: fn(
            self: *const IMFVideoDisplayControl,
            dwAspectRatioMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatioMode: fn(
            self: *const IMFVideoDisplayControl,
            pdwAspectRatioMode: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoWindow: fn(
            self: *const IMFVideoDisplayControl,
            hwndVideo: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoWindow: fn(
            self: *const IMFVideoDisplayControl,
            phwndVideo: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RepaintVideo: fn(
            self: *const IMFVideoDisplayControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentImage: fn(
            self: *const IMFVideoDisplayControl,
            pBih: *BITMAPINFOHEADER,
            pDib: [*]*u8,
            pcbDib: *u32,
            pTimeStamp: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderColor: fn(
            self: *const IMFVideoDisplayControl,
            Clr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBorderColor: fn(
            self: *const IMFVideoDisplayControl,
            pClr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRenderingPrefs: fn(
            self: *const IMFVideoDisplayControl,
            dwRenderFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderingPrefs: fn(
            self: *const IMFVideoDisplayControl,
            pdwRenderFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFullscreen: fn(
            self: *const IMFVideoDisplayControl,
            fFullscreen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFullscreen: fn(
            self: *const IMFVideoDisplayControl,
            pfFullscreen: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_GetNativeVideoSize(self: *const T, pszVideo: *SIZE, pszARVideo: *SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).GetNativeVideoSize(@ptrCast(*const IMFVideoDisplayControl, self), pszVideo, pszARVideo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_GetIdealVideoSize(self: *const T, pszMin: *SIZE, pszMax: *SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).GetIdealVideoSize(@ptrCast(*const IMFVideoDisplayControl, self), pszMin, pszMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_SetVideoPosition(self: *const T, pnrcSource: *const MFVideoNormalizedRect, prcDest: *const RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).SetVideoPosition(@ptrCast(*const IMFVideoDisplayControl, self), pnrcSource, prcDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_GetVideoPosition(self: *const T, pnrcSource: *MFVideoNormalizedRect, prcDest: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).GetVideoPosition(@ptrCast(*const IMFVideoDisplayControl, self), pnrcSource, prcDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_SetAspectRatioMode(self: *const T, dwAspectRatioMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).SetAspectRatioMode(@ptrCast(*const IMFVideoDisplayControl, self), dwAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_GetAspectRatioMode(self: *const T, pdwAspectRatioMode: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).GetAspectRatioMode(@ptrCast(*const IMFVideoDisplayControl, self), pdwAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_SetVideoWindow(self: *const T, hwndVideo: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).SetVideoWindow(@ptrCast(*const IMFVideoDisplayControl, self), hwndVideo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_GetVideoWindow(self: *const T, phwndVideo: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).GetVideoWindow(@ptrCast(*const IMFVideoDisplayControl, self), phwndVideo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_RepaintVideo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).RepaintVideo(@ptrCast(*const IMFVideoDisplayControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_GetCurrentImage(self: *const T, pBih: *BITMAPINFOHEADER, pDib: [*]*u8, pcbDib: *u32, pTimeStamp: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).GetCurrentImage(@ptrCast(*const IMFVideoDisplayControl, self), pBih, pDib, pcbDib, pTimeStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_SetBorderColor(self: *const T, Clr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).SetBorderColor(@ptrCast(*const IMFVideoDisplayControl, self), Clr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_GetBorderColor(self: *const T, pClr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).GetBorderColor(@ptrCast(*const IMFVideoDisplayControl, self), pClr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_SetRenderingPrefs(self: *const T, dwRenderFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).SetRenderingPrefs(@ptrCast(*const IMFVideoDisplayControl, self), dwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_GetRenderingPrefs(self: *const T, pdwRenderFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).GetRenderingPrefs(@ptrCast(*const IMFVideoDisplayControl, self), pdwRenderFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_SetFullscreen(self: *const T, fFullscreen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).SetFullscreen(@ptrCast(*const IMFVideoDisplayControl, self), fFullscreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoDisplayControl_GetFullscreen(self: *const T, pfFullscreen: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoDisplayControl.VTable, self.vtable).GetFullscreen(@ptrCast(*const IMFVideoDisplayControl, self), pfFullscreen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFVP_MESSAGE_TYPE = extern enum(i32) {
    MFVP_MESSAGE_FLUSH = 0,
    MFVP_MESSAGE_INVALIDATEMEDIATYPE = 1,
    MFVP_MESSAGE_PROCESSINPUTNOTIFY = 2,
    MFVP_MESSAGE_BEGINSTREAMING = 3,
    MFVP_MESSAGE_ENDSTREAMING = 4,
    MFVP_MESSAGE_ENDOFSTREAM = 5,
    MFVP_MESSAGE_STEP = 6,
    MFVP_MESSAGE_CANCELSTEP = 7,
};
pub const MFVP_MESSAGE_FLUSH = MFVP_MESSAGE_TYPE.MFVP_MESSAGE_FLUSH;
pub const MFVP_MESSAGE_INVALIDATEMEDIATYPE = MFVP_MESSAGE_TYPE.MFVP_MESSAGE_INVALIDATEMEDIATYPE;
pub const MFVP_MESSAGE_PROCESSINPUTNOTIFY = MFVP_MESSAGE_TYPE.MFVP_MESSAGE_PROCESSINPUTNOTIFY;
pub const MFVP_MESSAGE_BEGINSTREAMING = MFVP_MESSAGE_TYPE.MFVP_MESSAGE_BEGINSTREAMING;
pub const MFVP_MESSAGE_ENDSTREAMING = MFVP_MESSAGE_TYPE.MFVP_MESSAGE_ENDSTREAMING;
pub const MFVP_MESSAGE_ENDOFSTREAM = MFVP_MESSAGE_TYPE.MFVP_MESSAGE_ENDOFSTREAM;
pub const MFVP_MESSAGE_STEP = MFVP_MESSAGE_TYPE.MFVP_MESSAGE_STEP;
pub const MFVP_MESSAGE_CANCELSTEP = MFVP_MESSAGE_TYPE.MFVP_MESSAGE_CANCELSTEP;

const IID_IMFVideoPresenter_Value = @import("../zig.zig").Guid.initString("29AFF080-182A-4A5D-AF3B-448F3A6346CB");
pub const IID_IMFVideoPresenter = &IID_IMFVideoPresenter_Value;
pub const IMFVideoPresenter = extern struct {
    pub const VTable = extern struct {
        base: IMFClockStateSink.VTable,
        ProcessMessage: fn(
            self: *const IMFVideoPresenter,
            eMessage: MFVP_MESSAGE_TYPE,
            ulParam: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentMediaType: fn(
            self: *const IMFVideoPresenter,
            ppMediaType: **IMFVideoMediaType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFClockStateSink.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoPresenter_ProcessMessage(self: *const T, eMessage: MFVP_MESSAGE_TYPE, ulParam: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoPresenter.VTable, self.vtable).ProcessMessage(@ptrCast(*const IMFVideoPresenter, self), eMessage, ulParam);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoPresenter_GetCurrentMediaType(self: *const T, ppMediaType: **IMFVideoMediaType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoPresenter.VTable, self.vtable).GetCurrentMediaType(@ptrCast(*const IMFVideoPresenter, self), ppMediaType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFDesiredSample_Value = @import("../zig.zig").Guid.initString("56C294D0-753E-4260-8D61-A3D8820B1D54");
pub const IID_IMFDesiredSample = &IID_IMFDesiredSample_Value;
pub const IMFDesiredSample = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDesiredSampleTimeAndDuration: fn(
            self: *const IMFDesiredSample,
            phnsSampleTime: *i64,
            phnsSampleDuration: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDesiredSampleTimeAndDuration: fn(
            self: *const IMFDesiredSample,
            hnsSampleTime: i64,
            hnsSampleDuration: i64,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Clear: fn(
            self: *const IMFDesiredSample,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDesiredSample_GetDesiredSampleTimeAndDuration(self: *const T, phnsSampleTime: *i64, phnsSampleDuration: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFDesiredSample.VTable, self.vtable).GetDesiredSampleTimeAndDuration(@ptrCast(*const IMFDesiredSample, self), phnsSampleTime, phnsSampleDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDesiredSample_SetDesiredSampleTimeAndDuration(self: *const T, hnsSampleTime: i64, hnsSampleDuration: i64) callconv(.Inline) void {
            return @ptrCast(*const IMFDesiredSample.VTable, self.vtable).SetDesiredSampleTimeAndDuration(@ptrCast(*const IMFDesiredSample, self), hnsSampleTime, hnsSampleDuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFDesiredSample_Clear(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IMFDesiredSample.VTable, self.vtable).Clear(@ptrCast(*const IMFDesiredSample, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoMixerControl_Value = @import("../zig.zig").Guid.initString("A5C6C53F-C202-4AA5-9695-175BA8C508A5");
pub const IID_IMFVideoMixerControl = &IID_IMFVideoMixerControl_Value;
pub const IMFVideoMixerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamZOrder: fn(
            self: *const IMFVideoMixerControl,
            dwStreamID: u32,
            dwZ: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamZOrder: fn(
            self: *const IMFVideoMixerControl,
            dwStreamID: u32,
            pdwZ: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamOutputRect: fn(
            self: *const IMFVideoMixerControl,
            dwStreamID: u32,
            pnrcOutput: *const MFVideoNormalizedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamOutputRect: fn(
            self: *const IMFVideoMixerControl,
            dwStreamID: u32,
            pnrcOutput: *MFVideoNormalizedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerControl_SetStreamZOrder(self: *const T, dwStreamID: u32, dwZ: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerControl.VTable, self.vtable).SetStreamZOrder(@ptrCast(*const IMFVideoMixerControl, self), dwStreamID, dwZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerControl_GetStreamZOrder(self: *const T, dwStreamID: u32, pdwZ: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerControl.VTable, self.vtable).GetStreamZOrder(@ptrCast(*const IMFVideoMixerControl, self), dwStreamID, pdwZ);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerControl_SetStreamOutputRect(self: *const T, dwStreamID: u32, pnrcOutput: *const MFVideoNormalizedRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerControl.VTable, self.vtable).SetStreamOutputRect(@ptrCast(*const IMFVideoMixerControl, self), dwStreamID, pnrcOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerControl_GetStreamOutputRect(self: *const T, dwStreamID: u32, pnrcOutput: *MFVideoNormalizedRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerControl.VTable, self.vtable).GetStreamOutputRect(@ptrCast(*const IMFVideoMixerControl, self), dwStreamID, pnrcOutput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoMixPrefs = extern enum(i32) {
    ForceHalfInterlace = 1,
    AllowDropToHalfInterlace = 2,
    AllowDropToBob = 4,
    ForceBob = 8,
    EnableRotation = 16,
    Mask = 31,
};
pub const MFVideoMixPrefs_ForceHalfInterlace = MFVideoMixPrefs.ForceHalfInterlace;
pub const MFVideoMixPrefs_AllowDropToHalfInterlace = MFVideoMixPrefs.AllowDropToHalfInterlace;
pub const MFVideoMixPrefs_AllowDropToBob = MFVideoMixPrefs.AllowDropToBob;
pub const MFVideoMixPrefs_ForceBob = MFVideoMixPrefs.ForceBob;
pub const MFVideoMixPrefs_EnableRotation = MFVideoMixPrefs.EnableRotation;
pub const MFVideoMixPrefs_Mask = MFVideoMixPrefs.Mask;

const IID_IMFVideoMixerControl2_Value = @import("../zig.zig").Guid.initString("8459616D-966E-4930-B658-54FA7E5A16D3");
pub const IID_IMFVideoMixerControl2 = &IID_IMFVideoMixerControl2_Value;
pub const IMFVideoMixerControl2 = extern struct {
    pub const VTable = extern struct {
        base: IMFVideoMixerControl.VTable,
        SetMixingPrefs: fn(
            self: *const IMFVideoMixerControl2,
            dwMixFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMixingPrefs: fn(
            self: *const IMFVideoMixerControl2,
            pdwMixFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFVideoMixerControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerControl2_SetMixingPrefs(self: *const T, dwMixFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerControl2.VTable, self.vtable).SetMixingPrefs(@ptrCast(*const IMFVideoMixerControl2, self), dwMixFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerControl2_GetMixingPrefs(self: *const T, pdwMixFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerControl2.VTable, self.vtable).GetMixingPrefs(@ptrCast(*const IMFVideoMixerControl2, self), pdwMixFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoRenderer_Value = @import("../zig.zig").Guid.initString("DFDFD197-A9CA-43D8-B341-6AF3503792CD");
pub const IID_IMFVideoRenderer = &IID_IMFVideoRenderer_Value;
pub const IMFVideoRenderer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeRenderer: fn(
            self: *const IMFVideoRenderer,
            pVideoMixer: ?*IMFTransform,
            pVideoPresenter: ?*IMFVideoPresenter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoRenderer_InitializeRenderer(self: *const T, pVideoMixer: ?*IMFTransform, pVideoPresenter: ?*IMFVideoPresenter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoRenderer.VTable, self.vtable).InitializeRenderer(@ptrCast(*const IMFVideoRenderer, self), pVideoMixer, pVideoPresenter);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEVRFilterConfig_Value = @import("../zig.zig").Guid.initString("83E91E85-82C1-4EA7-801D-85DC50B75086");
pub const IID_IEVRFilterConfig = &IID_IEVRFilterConfig_Value;
pub const IEVRFilterConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetNumberOfStreams: fn(
            self: *const IEVRFilterConfig,
            dwMaxStreams: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfStreams: fn(
            self: *const IEVRFilterConfig,
            pdwMaxStreams: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRFilterConfig_SetNumberOfStreams(self: *const T, dwMaxStreams: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRFilterConfig.VTable, self.vtable).SetNumberOfStreams(@ptrCast(*const IEVRFilterConfig, self), dwMaxStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRFilterConfig_GetNumberOfStreams(self: *const T, pdwMaxStreams: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRFilterConfig.VTable, self.vtable).GetNumberOfStreams(@ptrCast(*const IEVRFilterConfig, self), pdwMaxStreams);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const EVRFilterConfigPrefs = extern enum(i32) {
    EnableQoS = 1,
    Mask = 1,
};
pub const EVRFilterConfigPrefs_EnableQoS = EVRFilterConfigPrefs.EnableQoS;
pub const EVRFilterConfigPrefs_Mask = EVRFilterConfigPrefs.Mask;

const IID_IEVRFilterConfigEx_Value = @import("../zig.zig").Guid.initString("AEA36028-796D-454F-BEEE-B48071E24304");
pub const IID_IEVRFilterConfigEx = &IID_IEVRFilterConfigEx_Value;
pub const IEVRFilterConfigEx = extern struct {
    pub const VTable = extern struct {
        base: IEVRFilterConfig.VTable,
        SetConfigPrefs: fn(
            self: *const IEVRFilterConfigEx,
            dwConfigFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfigPrefs: fn(
            self: *const IEVRFilterConfigEx,
            pdwConfigFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEVRFilterConfig.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRFilterConfigEx_SetConfigPrefs(self: *const T, dwConfigFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRFilterConfigEx.VTable, self.vtable).SetConfigPrefs(@ptrCast(*const IEVRFilterConfigEx, self), dwConfigFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRFilterConfigEx_GetConfigPrefs(self: *const T, pdwConfigFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRFilterConfigEx.VTable, self.vtable).GetConfigPrefs(@ptrCast(*const IEVRFilterConfigEx, self), pdwConfigFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MF_SERVICE_LOOKUP_TYPE = extern enum(i32) {
    MF_SERVICE_LOOKUP_UPSTREAM = 0,
    MF_SERVICE_LOOKUP_UPSTREAM_DIRECT = 1,
    MF_SERVICE_LOOKUP_DOWNSTREAM = 2,
    MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT = 3,
    MF_SERVICE_LOOKUP_ALL = 4,
    MF_SERVICE_LOOKUP_GLOBAL = 5,
};
pub const MF_SERVICE_LOOKUP_UPSTREAM = MF_SERVICE_LOOKUP_TYPE.MF_SERVICE_LOOKUP_UPSTREAM;
pub const MF_SERVICE_LOOKUP_UPSTREAM_DIRECT = MF_SERVICE_LOOKUP_TYPE.MF_SERVICE_LOOKUP_UPSTREAM_DIRECT;
pub const MF_SERVICE_LOOKUP_DOWNSTREAM = MF_SERVICE_LOOKUP_TYPE.MF_SERVICE_LOOKUP_DOWNSTREAM;
pub const MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT = MF_SERVICE_LOOKUP_TYPE.MF_SERVICE_LOOKUP_DOWNSTREAM_DIRECT;
pub const MF_SERVICE_LOOKUP_ALL = MF_SERVICE_LOOKUP_TYPE.MF_SERVICE_LOOKUP_ALL;
pub const MF_SERVICE_LOOKUP_GLOBAL = MF_SERVICE_LOOKUP_TYPE.MF_SERVICE_LOOKUP_GLOBAL;

const IID_IMFTopologyServiceLookup_Value = @import("../zig.zig").Guid.initString("FA993889-4383-415A-A930-DD472A8CF6F7");
pub const IID_IMFTopologyServiceLookup = &IID_IMFTopologyServiceLookup_Value;
pub const IMFTopologyServiceLookup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LookupService: fn(
            self: *const IMFTopologyServiceLookup,
            Type: MF_SERVICE_LOOKUP_TYPE,
            dwIndex: u32,
            guidService: *const Guid,
            riid: *const Guid,
            ppvObjects: [*]*c_void,
            pnObjects: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyServiceLookup_LookupService(self: *const T, Type: MF_SERVICE_LOOKUP_TYPE, dwIndex: u32, guidService: *const Guid, riid: *const Guid, ppvObjects: [*]*c_void, pnObjects: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyServiceLookup.VTable, self.vtable).LookupService(@ptrCast(*const IMFTopologyServiceLookup, self), Type, dwIndex, guidService, riid, ppvObjects, pnObjects);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFTopologyServiceLookupClient_Value = @import("../zig.zig").Guid.initString("FA99388A-4383-415A-A930-DD472A8CF6F7");
pub const IID_IMFTopologyServiceLookupClient = &IID_IMFTopologyServiceLookupClient_Value;
pub const IMFTopologyServiceLookupClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitServicePointers: fn(
            self: *const IMFTopologyServiceLookupClient,
            pLookup: *IMFTopologyServiceLookup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseServicePointers: fn(
            self: *const IMFTopologyServiceLookupClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyServiceLookupClient_InitServicePointers(self: *const T, pLookup: *IMFTopologyServiceLookup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyServiceLookupClient.VTable, self.vtable).InitServicePointers(@ptrCast(*const IMFTopologyServiceLookupClient, self), pLookup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFTopologyServiceLookupClient_ReleaseServicePointers(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFTopologyServiceLookupClient.VTable, self.vtable).ReleaseServicePointers(@ptrCast(*const IMFTopologyServiceLookupClient, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEVRTrustedVideoPlugin_Value = @import("../zig.zig").Guid.initString("83A4CE40-7710-494B-A893-A472049AF630");
pub const IID_IEVRTrustedVideoPlugin = &IID_IEVRTrustedVideoPlugin_Value;
pub const IEVRTrustedVideoPlugin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsInTrustedVideoMode: fn(
            self: *const IEVRTrustedVideoPlugin,
            pYes: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanConstrict: fn(
            self: *const IEVRTrustedVideoPlugin,
            pYes: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConstriction: fn(
            self: *const IEVRTrustedVideoPlugin,
            dwKPix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisableImageExport: fn(
            self: *const IEVRTrustedVideoPlugin,
            bDisable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRTrustedVideoPlugin_IsInTrustedVideoMode(self: *const T, pYes: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRTrustedVideoPlugin.VTable, self.vtable).IsInTrustedVideoMode(@ptrCast(*const IEVRTrustedVideoPlugin, self), pYes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRTrustedVideoPlugin_CanConstrict(self: *const T, pYes: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRTrustedVideoPlugin.VTable, self.vtable).CanConstrict(@ptrCast(*const IEVRTrustedVideoPlugin, self), pYes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRTrustedVideoPlugin_SetConstriction(self: *const T, dwKPix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRTrustedVideoPlugin.VTable, self.vtable).SetConstriction(@ptrCast(*const IEVRTrustedVideoPlugin, self), dwKPix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRTrustedVideoPlugin_DisableImageExport(self: *const T, bDisable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRTrustedVideoPlugin.VTable, self.vtable).DisableImageExport(@ptrCast(*const IEVRTrustedVideoPlugin, self), bDisable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFP_CREATION_OPTIONS = extern enum(i32) {
    MFP_OPTION_NONE = 0,
    MFP_OPTION_FREE_THREADED_CALLBACK = 1,
    MFP_OPTION_NO_MMCSS = 2,
    MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION = 4,
};
pub const MFP_OPTION_NONE = MFP_CREATION_OPTIONS.MFP_OPTION_NONE;
pub const MFP_OPTION_FREE_THREADED_CALLBACK = MFP_CREATION_OPTIONS.MFP_OPTION_FREE_THREADED_CALLBACK;
pub const MFP_OPTION_NO_MMCSS = MFP_CREATION_OPTIONS.MFP_OPTION_NO_MMCSS;
pub const MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION = MFP_CREATION_OPTIONS.MFP_OPTION_NO_REMOTE_DESKTOP_OPTIMIZATION;

pub const MFP_MEDIAPLAYER_STATE = extern enum(i32) {
    EMPTY = 0,
    STOPPED = 1,
    PLAYING = 2,
    PAUSED = 3,
    SHUTDOWN = 4,
};
pub const MFP_MEDIAPLAYER_STATE_EMPTY = MFP_MEDIAPLAYER_STATE.EMPTY;
pub const MFP_MEDIAPLAYER_STATE_STOPPED = MFP_MEDIAPLAYER_STATE.STOPPED;
pub const MFP_MEDIAPLAYER_STATE_PLAYING = MFP_MEDIAPLAYER_STATE.PLAYING;
pub const MFP_MEDIAPLAYER_STATE_PAUSED = MFP_MEDIAPLAYER_STATE.PAUSED;
pub const MFP_MEDIAPLAYER_STATE_SHUTDOWN = MFP_MEDIAPLAYER_STATE.SHUTDOWN;

pub const _MFP_MEDIAITEM_CHARACTERISTICS = extern enum(i32) {
    MFP_MEDIAITEM_IS_LIVE = 1,
    MFP_MEDIAITEM_CAN_SEEK = 2,
    MFP_MEDIAITEM_CAN_PAUSE = 4,
    MFP_MEDIAITEM_HAS_SLOW_SEEK = 8,
};
pub const MFP_MEDIAITEM_IS_LIVE = _MFP_MEDIAITEM_CHARACTERISTICS.MFP_MEDIAITEM_IS_LIVE;
pub const MFP_MEDIAITEM_CAN_SEEK = _MFP_MEDIAITEM_CHARACTERISTICS.MFP_MEDIAITEM_CAN_SEEK;
pub const MFP_MEDIAITEM_CAN_PAUSE = _MFP_MEDIAITEM_CHARACTERISTICS.MFP_MEDIAITEM_CAN_PAUSE;
pub const MFP_MEDIAITEM_HAS_SLOW_SEEK = _MFP_MEDIAITEM_CHARACTERISTICS.MFP_MEDIAITEM_HAS_SLOW_SEEK;

pub const _MFP_CREDENTIAL_FLAGS = extern enum(i32) {
    MFP_CREDENTIAL_PROMPT = 1,
    MFP_CREDENTIAL_SAVE = 2,
    MFP_CREDENTIAL_DO_NOT_CACHE = 4,
    MFP_CREDENTIAL_CLEAR_TEXT = 8,
    MFP_CREDENTIAL_PROXY = 16,
    MFP_CREDENTIAL_LOGGED_ON_USER = 32,
};
pub const MFP_CREDENTIAL_PROMPT = _MFP_CREDENTIAL_FLAGS.MFP_CREDENTIAL_PROMPT;
pub const MFP_CREDENTIAL_SAVE = _MFP_CREDENTIAL_FLAGS.MFP_CREDENTIAL_SAVE;
pub const MFP_CREDENTIAL_DO_NOT_CACHE = _MFP_CREDENTIAL_FLAGS.MFP_CREDENTIAL_DO_NOT_CACHE;
pub const MFP_CREDENTIAL_CLEAR_TEXT = _MFP_CREDENTIAL_FLAGS.MFP_CREDENTIAL_CLEAR_TEXT;
pub const MFP_CREDENTIAL_PROXY = _MFP_CREDENTIAL_FLAGS.MFP_CREDENTIAL_PROXY;
pub const MFP_CREDENTIAL_LOGGED_ON_USER = _MFP_CREDENTIAL_FLAGS.MFP_CREDENTIAL_LOGGED_ON_USER;

const IID_IMFPMediaPlayer_Value = @import("../zig.zig").Guid.initString("A714590A-58AF-430A-85BF-44F5EC838D85");
pub const IID_IMFPMediaPlayer = &IID_IMFPMediaPlayer_Value;
pub const IMFPMediaPlayer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Play: fn(
            self: *const IMFPMediaPlayer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IMFPMediaPlayer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IMFPMediaPlayer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FrameStep: fn(
            self: *const IMFPMediaPlayer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPosition: fn(
            self: *const IMFPMediaPlayer,
            guidPositionType: *const Guid,
            pvPositionValue: *const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const IMFPMediaPlayer,
            guidPositionType: *const Guid,
            pvPositionValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuration: fn(
            self: *const IMFPMediaPlayer,
            guidPositionType: *const Guid,
            pvDurationValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRate: fn(
            self: *const IMFPMediaPlayer,
            flRate: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRate: fn(
            self: *const IMFPMediaPlayer,
            pflRate: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedRates: fn(
            self: *const IMFPMediaPlayer,
            fForwardDirection: BOOL,
            pflSlowestRate: *f32,
            pflFastestRate: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IMFPMediaPlayer,
            peState: *MFP_MEDIAPLAYER_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMediaItemFromURL: fn(
            self: *const IMFPMediaPlayer,
            pwszURL: [*:0]const u16,
            fSync: BOOL,
            dwUserData: ?*c_void,
            ppMediaItem: ?*?*IMFPMediaItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMediaItemFromObject: fn(
            self: *const IMFPMediaPlayer,
            pIUnknownObj: *IUnknown,
            fSync: BOOL,
            dwUserData: ?*c_void,
            ppMediaItem: ?*?*IMFPMediaItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMediaItem: fn(
            self: *const IMFPMediaPlayer,
            pIMFPMediaItem: *IMFPMediaItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearMediaItem: fn(
            self: *const IMFPMediaPlayer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaItem: fn(
            self: *const IMFPMediaPlayer,
            ppIMFPMediaItem: **IMFPMediaItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolume: fn(
            self: *const IMFPMediaPlayer,
            pflVolume: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVolume: fn(
            self: *const IMFPMediaPlayer,
            flVolume: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBalance: fn(
            self: *const IMFPMediaPlayer,
            pflBalance: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBalance: fn(
            self: *const IMFPMediaPlayer,
            flBalance: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMute: fn(
            self: *const IMFPMediaPlayer,
            pfMute: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMute: fn(
            self: *const IMFPMediaPlayer,
            fMute: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNativeVideoSize: fn(
            self: *const IMFPMediaPlayer,
            pszVideo: ?*SIZE,
            pszARVideo: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdealVideoSize: fn(
            self: *const IMFPMediaPlayer,
            pszMin: ?*SIZE,
            pszMax: ?*SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoSourceRect: fn(
            self: *const IMFPMediaPlayer,
            pnrcSource: *const MFVideoNormalizedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoSourceRect: fn(
            self: *const IMFPMediaPlayer,
            pnrcSource: *MFVideoNormalizedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAspectRatioMode: fn(
            self: *const IMFPMediaPlayer,
            dwAspectRatioMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAspectRatioMode: fn(
            self: *const IMFPMediaPlayer,
            pdwAspectRatioMode: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoWindow: fn(
            self: *const IMFPMediaPlayer,
            phwndVideo: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateVideo: fn(
            self: *const IMFPMediaPlayer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBorderColor: fn(
            self: *const IMFPMediaPlayer,
            Clr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBorderColor: fn(
            self: *const IMFPMediaPlayer,
            pClr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertEffect: fn(
            self: *const IMFPMediaPlayer,
            pEffect: *IUnknown,
            fOptional: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEffect: fn(
            self: *const IMFPMediaPlayer,
            pEffect: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAllEffects: fn(
            self: *const IMFPMediaPlayer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFPMediaPlayer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_Play(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).Play(@ptrCast(*const IMFPMediaPlayer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_Pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).Pause(@ptrCast(*const IMFPMediaPlayer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).Stop(@ptrCast(*const IMFPMediaPlayer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_FrameStep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).FrameStep(@ptrCast(*const IMFPMediaPlayer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_SetPosition(self: *const T, guidPositionType: *const Guid, pvPositionValue: *const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).SetPosition(@ptrCast(*const IMFPMediaPlayer, self), guidPositionType, pvPositionValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetPosition(self: *const T, guidPositionType: *const Guid, pvPositionValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetPosition(@ptrCast(*const IMFPMediaPlayer, self), guidPositionType, pvPositionValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetDuration(self: *const T, guidPositionType: *const Guid, pvDurationValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetDuration(@ptrCast(*const IMFPMediaPlayer, self), guidPositionType, pvDurationValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_SetRate(self: *const T, flRate: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).SetRate(@ptrCast(*const IMFPMediaPlayer, self), flRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetRate(self: *const T, pflRate: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetRate(@ptrCast(*const IMFPMediaPlayer, self), pflRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetSupportedRates(self: *const T, fForwardDirection: BOOL, pflSlowestRate: *f32, pflFastestRate: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetSupportedRates(@ptrCast(*const IMFPMediaPlayer, self), fForwardDirection, pflSlowestRate, pflFastestRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetState(self: *const T, peState: *MFP_MEDIAPLAYER_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetState(@ptrCast(*const IMFPMediaPlayer, self), peState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_CreateMediaItemFromURL(self: *const T, pwszURL: [*:0]const u16, fSync: BOOL, dwUserData: ?*c_void, ppMediaItem: ?*?*IMFPMediaItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).CreateMediaItemFromURL(@ptrCast(*const IMFPMediaPlayer, self), pwszURL, fSync, dwUserData, ppMediaItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_CreateMediaItemFromObject(self: *const T, pIUnknownObj: *IUnknown, fSync: BOOL, dwUserData: ?*c_void, ppMediaItem: ?*?*IMFPMediaItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).CreateMediaItemFromObject(@ptrCast(*const IMFPMediaPlayer, self), pIUnknownObj, fSync, dwUserData, ppMediaItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_SetMediaItem(self: *const T, pIMFPMediaItem: *IMFPMediaItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).SetMediaItem(@ptrCast(*const IMFPMediaPlayer, self), pIMFPMediaItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_ClearMediaItem(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).ClearMediaItem(@ptrCast(*const IMFPMediaPlayer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetMediaItem(self: *const T, ppIMFPMediaItem: **IMFPMediaItem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetMediaItem(@ptrCast(*const IMFPMediaPlayer, self), ppIMFPMediaItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetVolume(self: *const T, pflVolume: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetVolume(@ptrCast(*const IMFPMediaPlayer, self), pflVolume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_SetVolume(self: *const T, flVolume: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).SetVolume(@ptrCast(*const IMFPMediaPlayer, self), flVolume);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetBalance(self: *const T, pflBalance: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetBalance(@ptrCast(*const IMFPMediaPlayer, self), pflBalance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_SetBalance(self: *const T, flBalance: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).SetBalance(@ptrCast(*const IMFPMediaPlayer, self), flBalance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetMute(self: *const T, pfMute: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetMute(@ptrCast(*const IMFPMediaPlayer, self), pfMute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_SetMute(self: *const T, fMute: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).SetMute(@ptrCast(*const IMFPMediaPlayer, self), fMute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetNativeVideoSize(self: *const T, pszVideo: ?*SIZE, pszARVideo: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetNativeVideoSize(@ptrCast(*const IMFPMediaPlayer, self), pszVideo, pszARVideo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetIdealVideoSize(self: *const T, pszMin: ?*SIZE, pszMax: ?*SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetIdealVideoSize(@ptrCast(*const IMFPMediaPlayer, self), pszMin, pszMax);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_SetVideoSourceRect(self: *const T, pnrcSource: *const MFVideoNormalizedRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).SetVideoSourceRect(@ptrCast(*const IMFPMediaPlayer, self), pnrcSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetVideoSourceRect(self: *const T, pnrcSource: *MFVideoNormalizedRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetVideoSourceRect(@ptrCast(*const IMFPMediaPlayer, self), pnrcSource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_SetAspectRatioMode(self: *const T, dwAspectRatioMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).SetAspectRatioMode(@ptrCast(*const IMFPMediaPlayer, self), dwAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetAspectRatioMode(self: *const T, pdwAspectRatioMode: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetAspectRatioMode(@ptrCast(*const IMFPMediaPlayer, self), pdwAspectRatioMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetVideoWindow(self: *const T, phwndVideo: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetVideoWindow(@ptrCast(*const IMFPMediaPlayer, self), phwndVideo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_UpdateVideo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).UpdateVideo(@ptrCast(*const IMFPMediaPlayer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_SetBorderColor(self: *const T, Clr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).SetBorderColor(@ptrCast(*const IMFPMediaPlayer, self), Clr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_GetBorderColor(self: *const T, pClr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).GetBorderColor(@ptrCast(*const IMFPMediaPlayer, self), pClr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_InsertEffect(self: *const T, pEffect: *IUnknown, fOptional: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).InsertEffect(@ptrCast(*const IMFPMediaPlayer, self), pEffect, fOptional);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_RemoveEffect(self: *const T, pEffect: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).RemoveEffect(@ptrCast(*const IMFPMediaPlayer, self), pEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_RemoveAllEffects(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).RemoveAllEffects(@ptrCast(*const IMFPMediaPlayer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayer_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaPlayer.VTable, self.vtable).Shutdown(@ptrCast(*const IMFPMediaPlayer, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFPMediaItem_Value = @import("../zig.zig").Guid.initString("90EB3E6B-ECBF-45CC-B1DA-C6FE3EA70D57");
pub const IID_IMFPMediaItem = &IID_IMFPMediaItem_Value;
pub const IMFPMediaItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMediaPlayer: fn(
            self: *const IMFPMediaItem,
            ppMediaPlayer: **IMFPMediaPlayer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: fn(
            self: *const IMFPMediaItem,
            ppwszURL: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const IMFPMediaItem,
            ppIUnknown: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUserData: fn(
            self: *const IMFPMediaItem,
            pdwUserData: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUserData: fn(
            self: *const IMFPMediaItem,
            dwUserData: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartStopPosition: fn(
            self: *const IMFPMediaItem,
            pguidStartPositionType: ?*Guid,
            pvStartValue: ?*PROPVARIANT,
            pguidStopPositionType: ?*Guid,
            pvStopValue: ?*PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStartStopPosition: fn(
            self: *const IMFPMediaItem,
            pguidStartPositionType: ?*const Guid,
            pvStartValue: ?*const PROPVARIANT,
            pguidStopPositionType: ?*const Guid,
            pvStopValue: ?*const PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasVideo: fn(
            self: *const IMFPMediaItem,
            pfHasVideo: ?*BOOL,
            pfSelected: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasAudio: fn(
            self: *const IMFPMediaItem,
            pfHasAudio: ?*BOOL,
            pfSelected: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsProtected: fn(
            self: *const IMFPMediaItem,
            pfProtected: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuration: fn(
            self: *const IMFPMediaItem,
            guidPositionType: *const Guid,
            pvDurationValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfStreams: fn(
            self: *const IMFPMediaItem,
            pdwStreamCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamSelection: fn(
            self: *const IMFPMediaItem,
            dwStreamIndex: u32,
            pfEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamSelection: fn(
            self: *const IMFPMediaItem,
            dwStreamIndex: u32,
            fEnabled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamAttribute: fn(
            self: *const IMFPMediaItem,
            dwStreamIndex: u32,
            guidMFAttribute: *const Guid,
            pvValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPresentationAttribute: fn(
            self: *const IMFPMediaItem,
            guidMFAttribute: *const Guid,
            pvValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharacteristics: fn(
            self: *const IMFPMediaItem,
            pCharacteristics: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStreamSink: fn(
            self: *const IMFPMediaItem,
            dwStreamIndex: u32,
            pMediaSink: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMetadata: fn(
            self: *const IMFPMediaItem,
            ppMetadataStore: **IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetMediaPlayer(self: *const T, ppMediaPlayer: **IMFPMediaPlayer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetMediaPlayer(@ptrCast(*const IMFPMediaItem, self), ppMediaPlayer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetURL(self: *const T, ppwszURL: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetURL(@ptrCast(*const IMFPMediaItem, self), ppwszURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetObject(self: *const T, ppIUnknown: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetObject(@ptrCast(*const IMFPMediaItem, self), ppIUnknown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetUserData(self: *const T, pdwUserData: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetUserData(@ptrCast(*const IMFPMediaItem, self), pdwUserData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_SetUserData(self: *const T, dwUserData: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).SetUserData(@ptrCast(*const IMFPMediaItem, self), dwUserData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetStartStopPosition(self: *const T, pguidStartPositionType: ?*Guid, pvStartValue: ?*PROPVARIANT, pguidStopPositionType: ?*Guid, pvStopValue: ?*PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetStartStopPosition(@ptrCast(*const IMFPMediaItem, self), pguidStartPositionType, pvStartValue, pguidStopPositionType, pvStopValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_SetStartStopPosition(self: *const T, pguidStartPositionType: ?*const Guid, pvStartValue: ?*const PROPVARIANT, pguidStopPositionType: ?*const Guid, pvStopValue: ?*const PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).SetStartStopPosition(@ptrCast(*const IMFPMediaItem, self), pguidStartPositionType, pvStartValue, pguidStopPositionType, pvStopValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_HasVideo(self: *const T, pfHasVideo: ?*BOOL, pfSelected: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).HasVideo(@ptrCast(*const IMFPMediaItem, self), pfHasVideo, pfSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_HasAudio(self: *const T, pfHasAudio: ?*BOOL, pfSelected: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).HasAudio(@ptrCast(*const IMFPMediaItem, self), pfHasAudio, pfSelected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_IsProtected(self: *const T, pfProtected: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).IsProtected(@ptrCast(*const IMFPMediaItem, self), pfProtected);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetDuration(self: *const T, guidPositionType: *const Guid, pvDurationValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetDuration(@ptrCast(*const IMFPMediaItem, self), guidPositionType, pvDurationValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetNumberOfStreams(self: *const T, pdwStreamCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetNumberOfStreams(@ptrCast(*const IMFPMediaItem, self), pdwStreamCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetStreamSelection(self: *const T, dwStreamIndex: u32, pfEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetStreamSelection(@ptrCast(*const IMFPMediaItem, self), dwStreamIndex, pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_SetStreamSelection(self: *const T, dwStreamIndex: u32, fEnabled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).SetStreamSelection(@ptrCast(*const IMFPMediaItem, self), dwStreamIndex, fEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetStreamAttribute(self: *const T, dwStreamIndex: u32, guidMFAttribute: *const Guid, pvValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetStreamAttribute(@ptrCast(*const IMFPMediaItem, self), dwStreamIndex, guidMFAttribute, pvValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetPresentationAttribute(self: *const T, guidMFAttribute: *const Guid, pvValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetPresentationAttribute(@ptrCast(*const IMFPMediaItem, self), guidMFAttribute, pvValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetCharacteristics(self: *const T, pCharacteristics: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetCharacteristics(@ptrCast(*const IMFPMediaItem, self), pCharacteristics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_SetStreamSink(self: *const T, dwStreamIndex: u32, pMediaSink: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).SetStreamSink(@ptrCast(*const IMFPMediaItem, self), dwStreamIndex, pMediaSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaItem_GetMetadata(self: *const T, ppMetadataStore: **IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFPMediaItem.VTable, self.vtable).GetMetadata(@ptrCast(*const IMFPMediaItem, self), ppMetadataStore);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFP_EVENT_TYPE = extern enum(i32) {
    PLAY = 0,
    PAUSE = 1,
    STOP = 2,
    POSITION_SET = 3,
    RATE_SET = 4,
    MEDIAITEM_CREATED = 5,
    MEDIAITEM_SET = 6,
    FRAME_STEP = 7,
    MEDIAITEM_CLEARED = 8,
    MF = 9,
    ERROR = 10,
    PLAYBACK_ENDED = 11,
    ACQUIRE_USER_CREDENTIAL = 12,
};
pub const MFP_EVENT_TYPE_PLAY = MFP_EVENT_TYPE.PLAY;
pub const MFP_EVENT_TYPE_PAUSE = MFP_EVENT_TYPE.PAUSE;
pub const MFP_EVENT_TYPE_STOP = MFP_EVENT_TYPE.STOP;
pub const MFP_EVENT_TYPE_POSITION_SET = MFP_EVENT_TYPE.POSITION_SET;
pub const MFP_EVENT_TYPE_RATE_SET = MFP_EVENT_TYPE.RATE_SET;
pub const MFP_EVENT_TYPE_MEDIAITEM_CREATED = MFP_EVENT_TYPE.MEDIAITEM_CREATED;
pub const MFP_EVENT_TYPE_MEDIAITEM_SET = MFP_EVENT_TYPE.MEDIAITEM_SET;
pub const MFP_EVENT_TYPE_FRAME_STEP = MFP_EVENT_TYPE.FRAME_STEP;
pub const MFP_EVENT_TYPE_MEDIAITEM_CLEARED = MFP_EVENT_TYPE.MEDIAITEM_CLEARED;
pub const MFP_EVENT_TYPE_MF = MFP_EVENT_TYPE.MF;
pub const MFP_EVENT_TYPE_ERROR = MFP_EVENT_TYPE.ERROR;
pub const MFP_EVENT_TYPE_PLAYBACK_ENDED = MFP_EVENT_TYPE.PLAYBACK_ENDED;
pub const MFP_EVENT_TYPE_ACQUIRE_USER_CREDENTIAL = MFP_EVENT_TYPE.ACQUIRE_USER_CREDENTIAL;

pub const MFP_EVENT_HEADER = extern struct {
    eEventType: MFP_EVENT_TYPE,
    hrEvent: HRESULT,
    pMediaPlayer: *IMFPMediaPlayer,
    eState: MFP_MEDIAPLAYER_STATE,
    pPropertyStore: *IPropertyStore,
};

pub const MFP_PLAY_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
};

pub const MFP_PAUSE_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
};

pub const MFP_STOP_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
};

pub const MFP_POSITION_SET_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
};

pub const MFP_RATE_SET_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
    flRate: f32,
};

pub const MFP_MEDIAITEM_CREATED_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
    dwUserData: ?*c_void,
};

pub const MFP_MEDIAITEM_SET_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
};

pub const MFP_FRAME_STEP_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
};

pub const MFP_MEDIAITEM_CLEARED_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
};

pub const MFP_MF_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    MFEventType: u32,
    pMFMediaEvent: *IMFMediaEvent,
    pMediaItem: *IMFPMediaItem,
};

pub const MFP_ERROR_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
};

pub const MFP_PLAYBACK_ENDED_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    pMediaItem: *IMFPMediaItem,
};

pub const MFP_ACQUIRE_USER_CREDENTIAL_EVENT = extern struct {
    header: MFP_EVENT_HEADER,
    dwUserData: ?*c_void,
    fProceedWithAuthentication: BOOL,
    hrAuthenticationStatus: HRESULT,
    pwszURL: [*:0]const u16,
    pwszSite: [*:0]const u16,
    pwszRealm: [*:0]const u16,
    pwszPackage: [*:0]const u16,
    nRetries: i32,
    flags: u32,
    pCredential: *IMFNetCredential,
};

const IID_IMFPMediaPlayerCallback_Value = @import("../zig.zig").Guid.initString("766C8FFB-5FDB-4FEA-A28D-B912996F51BD");
pub const IID_IMFPMediaPlayerCallback = &IID_IMFPMediaPlayerCallback_Value;
pub const IMFPMediaPlayerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnMediaPlayerEvent: fn(
            self: *const IMFPMediaPlayerCallback,
            pEventHeader: *MFP_EVENT_HEADER,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFPMediaPlayerCallback_OnMediaPlayerEvent(self: *const T, pEventHeader: *MFP_EVENT_HEADER) callconv(.Inline) void {
            return @ptrCast(*const IMFPMediaPlayerCallback.VTable, self.vtable).OnMediaPlayerEvent(@ptrCast(*const IMFPMediaPlayerCallback, self), pEventHeader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEVICE_INFO = extern struct {
    pFriendlyDeviceName: BSTR,
    pUniqueDeviceName: BSTR,
    pManufacturerName: BSTR,
    pModelName: BSTR,
    pIconURL: BSTR,
};

pub const MF_SHARING_ENGINE_EVENT = extern enum(i32) {
    DISCONNECT = 2000,
    LOCALRENDERINGSTARTED = 2001,
    LOCALRENDERINGENDED = 2002,
    STOPPED = 2003,
    ERROR = 2501,
};
pub const MF_SHARING_ENGINE_EVENT_DISCONNECT = MF_SHARING_ENGINE_EVENT.DISCONNECT;
pub const MF_SHARING_ENGINE_EVENT_LOCALRENDERINGSTARTED = MF_SHARING_ENGINE_EVENT.LOCALRENDERINGSTARTED;
pub const MF_SHARING_ENGINE_EVENT_LOCALRENDERINGENDED = MF_SHARING_ENGINE_EVENT.LOCALRENDERINGENDED;
pub const MF_SHARING_ENGINE_EVENT_STOPPED = MF_SHARING_ENGINE_EVENT.STOPPED;
pub const MF_SHARING_ENGINE_EVENT_ERROR = MF_SHARING_ENGINE_EVENT.ERROR;

pub const MF_MEDIA_SHARING_ENGINE_EVENT = extern enum(i32) {
    DISCONNECT = 2000,
};
pub const MF_MEDIA_SHARING_ENGINE_EVENT_DISCONNECT = MF_MEDIA_SHARING_ENGINE_EVENT.DISCONNECT;

const IID_IMFSharingEngineClassFactory_Value = @import("../zig.zig").Guid.initString("2BA61F92-8305-413B-9733-FAF15F259384");
pub const IID_IMFSharingEngineClassFactory = &IID_IMFSharingEngineClassFactory_Value;
pub const IMFSharingEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: fn(
            self: *const IMFSharingEngineClassFactory,
            dwFlags: u32,
            pAttr: ?*IMFAttributes,
            ppEngine: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSharingEngineClassFactory_CreateInstance(self: *const T, dwFlags: u32, pAttr: ?*IMFAttributes, ppEngine: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSharingEngineClassFactory.VTable, self.vtable).CreateInstance(@ptrCast(*const IMFSharingEngineClassFactory, self), dwFlags, pAttr, ppEngine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaSharingEngine_Value = @import("../zig.zig").Guid.initString("8D3CE1BF-2367-40E0-9EEE-40D377CC1B46");
pub const IID_IMFMediaSharingEngine = &IID_IMFMediaSharingEngine_Value;
pub const IMFMediaSharingEngine = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaEngine.VTable,
        GetDevice: fn(
            self: *const IMFMediaSharingEngine,
            pDevice: *DEVICE_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaEngine.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSharingEngine_GetDevice(self: *const T, pDevice: *DEVICE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSharingEngine.VTable, self.vtable).GetDevice(@ptrCast(*const IMFMediaSharingEngine, self), pDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFMediaSharingEngineClassFactory_Value = @import("../zig.zig").Guid.initString("524D2BC4-B2B1-4FE5-8FAC-FA4E4512B4E0");
pub const IID_IMFMediaSharingEngineClassFactory = &IID_IMFMediaSharingEngineClassFactory_Value;
pub const IMFMediaSharingEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: fn(
            self: *const IMFMediaSharingEngineClassFactory,
            dwFlags: u32,
            pAttr: *IMFAttributes,
            ppEngine: **IMFMediaSharingEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFMediaSharingEngineClassFactory_CreateInstance(self: *const T, dwFlags: u32, pAttr: *IMFAttributes, ppEngine: **IMFMediaSharingEngine) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFMediaSharingEngineClassFactory.VTable, self.vtable).CreateInstance(@ptrCast(*const IMFMediaSharingEngineClassFactory, self), dwFlags, pAttr, ppEngine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFImageSharingEngine_Value = @import("../zig.zig").Guid.initString("CFA0AE8E-7E1C-44D2-AE68-FC4C148A6354");
pub const IID_IMFImageSharingEngine = &IID_IMFImageSharingEngine_Value;
pub const IMFImageSharingEngine = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSource: fn(
            self: *const IMFImageSharingEngine,
            pStream: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDevice: fn(
            self: *const IMFImageSharingEngine,
            pDevice: *DEVICE_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IMFImageSharingEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFImageSharingEngine_SetSource(self: *const T, pStream: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFImageSharingEngine.VTable, self.vtable).SetSource(@ptrCast(*const IMFImageSharingEngine, self), pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFImageSharingEngine_GetDevice(self: *const T, pDevice: *DEVICE_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFImageSharingEngine.VTable, self.vtable).GetDevice(@ptrCast(*const IMFImageSharingEngine, self), pDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFImageSharingEngine_Shutdown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFImageSharingEngine.VTable, self.vtable).Shutdown(@ptrCast(*const IMFImageSharingEngine, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFImageSharingEngineClassFactory_Value = @import("../zig.zig").Guid.initString("1FC55727-A7FB-4FC8-83AE-8AF024990AF1");
pub const IID_IMFImageSharingEngineClassFactory = &IID_IMFImageSharingEngineClassFactory_Value;
pub const IMFImageSharingEngineClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstanceFromUDN: fn(
            self: *const IMFImageSharingEngineClassFactory,
            pUniqueDeviceName: BSTR,
            ppEngine: **IMFImageSharingEngine,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFImageSharingEngineClassFactory_CreateInstanceFromUDN(self: *const T, pUniqueDeviceName: BSTR, ppEngine: **IMFImageSharingEngine) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFImageSharingEngineClassFactory.VTable, self.vtable).CreateInstanceFromUDN(@ptrCast(*const IMFImageSharingEngineClassFactory, self), pUniqueDeviceName, ppEngine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PLAYTO_SOURCE_CREATEFLAGS = extern enum(i32) {
    PLAYTO_SOURCE_NONE = 0,
    PLAYTO_SOURCE_IMAGE = 1,
    PLAYTO_SOURCE_AUDIO = 2,
    PLAYTO_SOURCE_VIDEO = 4,
    PLAYTO_SOURCE_PROTECTED = 8,
};
pub const PLAYTO_SOURCE_NONE = PLAYTO_SOURCE_CREATEFLAGS.PLAYTO_SOURCE_NONE;
pub const PLAYTO_SOURCE_IMAGE = PLAYTO_SOURCE_CREATEFLAGS.PLAYTO_SOURCE_IMAGE;
pub const PLAYTO_SOURCE_AUDIO = PLAYTO_SOURCE_CREATEFLAGS.PLAYTO_SOURCE_AUDIO;
pub const PLAYTO_SOURCE_VIDEO = PLAYTO_SOURCE_CREATEFLAGS.PLAYTO_SOURCE_VIDEO;
pub const PLAYTO_SOURCE_PROTECTED = PLAYTO_SOURCE_CREATEFLAGS.PLAYTO_SOURCE_PROTECTED;

const IID_IPlayToControl_Value = @import("../zig.zig").Guid.initString("607574EB-F4B6-45C1-B08C-CB715122901D");
pub const IID_IPlayToControl = &IID_IPlayToControl_Value;
pub const IPlayToControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Connect: fn(
            self: *const IPlayToControl,
            pFactory: *IMFSharingEngineClassFactory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disconnect: fn(
            self: *const IPlayToControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPlayToControl_Connect(self: *const T, pFactory: *IMFSharingEngineClassFactory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPlayToControl.VTable, self.vtable).Connect(@ptrCast(*const IPlayToControl, self), pFactory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPlayToControl_Disconnect(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPlayToControl.VTable, self.vtable).Disconnect(@ptrCast(*const IPlayToControl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPlayToControlWithCapabilities_Value = @import("../zig.zig").Guid.initString("AA9DD80F-C50A-4220-91C1-332287F82A34");
pub const IID_IPlayToControlWithCapabilities = &IID_IPlayToControlWithCapabilities_Value;
pub const IPlayToControlWithCapabilities = extern struct {
    pub const VTable = extern struct {
        base: IPlayToControl.VTable,
        GetCapabilities: fn(
            self: *const IPlayToControlWithCapabilities,
            pCapabilities: *PLAYTO_SOURCE_CREATEFLAGS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPlayToControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPlayToControlWithCapabilities_GetCapabilities(self: *const T, pCapabilities: *PLAYTO_SOURCE_CREATEFLAGS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPlayToControlWithCapabilities.VTable, self.vtable).GetCapabilities(@ptrCast(*const IPlayToControlWithCapabilities, self), pCapabilities);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPlayToSourceClassFactory_Value = @import("../zig.zig").Guid.initString("842B32A3-9B9B-4D1C-B3F3-49193248A554");
pub const IID_IPlayToSourceClassFactory = &IID_IPlayToSourceClassFactory_Value;
pub const IPlayToSourceClassFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateInstance: fn(
            self: *const IPlayToSourceClassFactory,
            dwFlags: u32,
            pControl: *IPlayToControl,
            ppSource: **IInspectable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPlayToSourceClassFactory_CreateInstance(self: *const T, dwFlags: u32, pControl: *IPlayToControl, ppSource: **IInspectable) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPlayToSourceClassFactory.VTable, self.vtable).CreateInstance(@ptrCast(*const IPlayToSourceClassFactory, self), dwFlags, pControl, ppSource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEVRVideoStreamControl_Value = @import("../zig.zig").Guid.initString("D0CFE38B-93E7-4772-8957-0400C49A4485");
pub const IID_IEVRVideoStreamControl = &IID_IEVRVideoStreamControl_Value;
pub const IEVRVideoStreamControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetStreamActiveState: fn(
            self: *const IEVRVideoStreamControl,
            fActive: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStreamActiveState: fn(
            self: *const IEVRVideoStreamControl,
            lpfActive: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRVideoStreamControl_SetStreamActiveState(self: *const T, fActive: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRVideoStreamControl.VTable, self.vtable).SetStreamActiveState(@ptrCast(*const IEVRVideoStreamControl, self), fActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEVRVideoStreamControl_GetStreamActiveState(self: *const T, lpfActive: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEVRVideoStreamControl.VTable, self.vtable).GetStreamActiveState(@ptrCast(*const IEVRVideoStreamControl, self), lpfActive);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFVideoProcessor_Value = @import("../zig.zig").Guid.initString("6AB0000C-FECE-4D1F-A2AC-A9573530656E");
pub const IID_IMFVideoProcessor = &IID_IMFVideoProcessor_Value;
pub const IMFVideoProcessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAvailableVideoProcessorModes: fn(
            self: *const IMFVideoProcessor,
            lpdwNumProcessingModes: *u32,
            ppVideoProcessingModes: ?[*]?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorCaps: fn(
            self: *const IMFVideoProcessor,
            lpVideoProcessorMode: *Guid,
            lpVideoProcessorCaps: *DXVA2_VideoProcessorCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorMode: fn(
            self: *const IMFVideoProcessor,
            lpMode: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetVideoProcessorMode: fn(
            self: *const IMFVideoProcessor,
            lpMode: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcAmpRange: fn(
            self: *const IMFVideoProcessor,
            dwProperty: u32,
            pPropRange: *DXVA2_ValueRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcAmpValues: fn(
            self: *const IMFVideoProcessor,
            dwFlags: u32,
            Values: *DXVA2_ProcAmpValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcAmpValues: fn(
            self: *const IMFVideoProcessor,
            dwFlags: u32,
            pValues: *DXVA2_ProcAmpValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilteringRange: fn(
            self: *const IMFVideoProcessor,
            dwProperty: u32,
            pPropRange: *DXVA2_ValueRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilteringValue: fn(
            self: *const IMFVideoProcessor,
            dwProperty: u32,
            pValue: *DXVA2_Fixed32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFilteringValue: fn(
            self: *const IMFVideoProcessor,
            dwProperty: u32,
            pValue: *DXVA2_Fixed32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackgroundColor: fn(
            self: *const IMFVideoProcessor,
            lpClrBkg: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackgroundColor: fn(
            self: *const IMFVideoProcessor,
            ClrBkg: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_GetAvailableVideoProcessorModes(self: *const T, lpdwNumProcessingModes: *u32, ppVideoProcessingModes: ?[*]?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).GetAvailableVideoProcessorModes(@ptrCast(*const IMFVideoProcessor, self), lpdwNumProcessingModes, ppVideoProcessingModes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_GetVideoProcessorCaps(self: *const T, lpVideoProcessorMode: *Guid, lpVideoProcessorCaps: *DXVA2_VideoProcessorCaps) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).GetVideoProcessorCaps(@ptrCast(*const IMFVideoProcessor, self), lpVideoProcessorMode, lpVideoProcessorCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_GetVideoProcessorMode(self: *const T, lpMode: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).GetVideoProcessorMode(@ptrCast(*const IMFVideoProcessor, self), lpMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_SetVideoProcessorMode(self: *const T, lpMode: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).SetVideoProcessorMode(@ptrCast(*const IMFVideoProcessor, self), lpMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_GetProcAmpRange(self: *const T, dwProperty: u32, pPropRange: *DXVA2_ValueRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).GetProcAmpRange(@ptrCast(*const IMFVideoProcessor, self), dwProperty, pPropRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_GetProcAmpValues(self: *const T, dwFlags: u32, Values: *DXVA2_ProcAmpValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).GetProcAmpValues(@ptrCast(*const IMFVideoProcessor, self), dwFlags, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_SetProcAmpValues(self: *const T, dwFlags: u32, pValues: *DXVA2_ProcAmpValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).SetProcAmpValues(@ptrCast(*const IMFVideoProcessor, self), dwFlags, pValues);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_GetFilteringRange(self: *const T, dwProperty: u32, pPropRange: *DXVA2_ValueRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).GetFilteringRange(@ptrCast(*const IMFVideoProcessor, self), dwProperty, pPropRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_GetFilteringValue(self: *const T, dwProperty: u32, pValue: *DXVA2_Fixed32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).GetFilteringValue(@ptrCast(*const IMFVideoProcessor, self), dwProperty, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_SetFilteringValue(self: *const T, dwProperty: u32, pValue: *DXVA2_Fixed32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).SetFilteringValue(@ptrCast(*const IMFVideoProcessor, self), dwProperty, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_GetBackgroundColor(self: *const T, lpClrBkg: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).GetBackgroundColor(@ptrCast(*const IMFVideoProcessor, self), lpClrBkg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoProcessor_SetBackgroundColor(self: *const T, ClrBkg: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoProcessor.VTable, self.vtable).SetBackgroundColor(@ptrCast(*const IMFVideoProcessor, self), ClrBkg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MFVideoAlphaBitmapParams = extern struct {
    dwFlags: u32,
    clrSrcKey: u32,
    rcSrc: RECT,
    nrcDest: MFVideoNormalizedRect,
    fAlpha: f32,
    dwFilterMode: u32,
};

pub const MFVideoAlphaBitmap = extern struct {
    GetBitmapFromDC: BOOL,
    bitmap: MFVideoAlphaBitmap._bitmap_e__Union,
    params: MFVideoAlphaBitmapParams,
    const _bitmap_e__Union = u32; // TODO: generate this nested type!
};

pub const MFVideoAlphaBitmapFlags = extern enum(i32) {
    MFVideoAlphaBitmap_EntireDDS = 1,
    MFVideoAlphaBitmap_SrcColorKey = 2,
    MFVideoAlphaBitmap_SrcRect = 4,
    MFVideoAlphaBitmap_DestRect = 8,
    MFVideoAlphaBitmap_FilterMode = 16,
    MFVideoAlphaBitmap_Alpha = 32,
    MFVideoAlphaBitmap_BitMask = 63,
};
pub const MFVideoAlphaBitmap_EntireDDS = MFVideoAlphaBitmapFlags.MFVideoAlphaBitmap_EntireDDS;
pub const MFVideoAlphaBitmap_SrcColorKey = MFVideoAlphaBitmapFlags.MFVideoAlphaBitmap_SrcColorKey;
pub const MFVideoAlphaBitmap_SrcRect = MFVideoAlphaBitmapFlags.MFVideoAlphaBitmap_SrcRect;
pub const MFVideoAlphaBitmap_DestRect = MFVideoAlphaBitmapFlags.MFVideoAlphaBitmap_DestRect;
pub const MFVideoAlphaBitmap_FilterMode = MFVideoAlphaBitmapFlags.MFVideoAlphaBitmap_FilterMode;
pub const MFVideoAlphaBitmap_Alpha = MFVideoAlphaBitmapFlags.MFVideoAlphaBitmap_Alpha;
pub const MFVideoAlphaBitmap_BitMask = MFVideoAlphaBitmapFlags.MFVideoAlphaBitmap_BitMask;

const IID_IMFVideoMixerBitmap_Value = @import("../zig.zig").Guid.initString("814C7B20-0FDB-4EEC-AF8F-F957C8F69EDC");
pub const IID_IMFVideoMixerBitmap = &IID_IMFVideoMixerBitmap_Value;
pub const IMFVideoMixerBitmap = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAlphaBitmap: fn(
            self: *const IMFVideoMixerBitmap,
            pBmpParms: *const MFVideoAlphaBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearAlphaBitmap: fn(
            self: *const IMFVideoMixerBitmap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateAlphaBitmapParameters: fn(
            self: *const IMFVideoMixerBitmap,
            pBmpParms: *const MFVideoAlphaBitmapParams,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlphaBitmapParameters: fn(
            self: *const IMFVideoMixerBitmap,
            pBmpParms: *MFVideoAlphaBitmapParams,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerBitmap_SetAlphaBitmap(self: *const T, pBmpParms: *const MFVideoAlphaBitmap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerBitmap.VTable, self.vtable).SetAlphaBitmap(@ptrCast(*const IMFVideoMixerBitmap, self), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerBitmap_ClearAlphaBitmap(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerBitmap.VTable, self.vtable).ClearAlphaBitmap(@ptrCast(*const IMFVideoMixerBitmap, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerBitmap_UpdateAlphaBitmapParameters(self: *const T, pBmpParms: *const MFVideoAlphaBitmapParams) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerBitmap.VTable, self.vtable).UpdateAlphaBitmapParameters(@ptrCast(*const IMFVideoMixerBitmap, self), pBmpParms);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFVideoMixerBitmap_GetAlphaBitmapParameters(self: *const T, pBmpParms: *MFVideoAlphaBitmapParams) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFVideoMixerBitmap.VTable, self.vtable).GetAlphaBitmapParameters(@ptrCast(*const IMFVideoMixerBitmap, self), pBmpParms);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAdvancedMediaCaptureInitializationSettings_Value = @import("../zig.zig").Guid.initString("3DE21209-8BA6-4F2A-A577-2819B56FF14D");
pub const IID_IAdvancedMediaCaptureInitializationSettings = &IID_IAdvancedMediaCaptureInitializationSettings_Value;
pub const IAdvancedMediaCaptureInitializationSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDirectxDeviceManager: fn(
            self: *const IAdvancedMediaCaptureInitializationSettings,
            value: *IMFDXGIDeviceManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdvancedMediaCaptureInitializationSettings_SetDirectxDeviceManager(self: *const T, value: *IMFDXGIDeviceManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAdvancedMediaCaptureInitializationSettings.VTable, self.vtable).SetDirectxDeviceManager(@ptrCast(*const IAdvancedMediaCaptureInitializationSettings, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAdvancedMediaCaptureSettings_Value = @import("../zig.zig").Guid.initString("24E0485F-A33E-4AA1-B564-6019B1D14F65");
pub const IID_IAdvancedMediaCaptureSettings = &IID_IAdvancedMediaCaptureSettings_Value;
pub const IAdvancedMediaCaptureSettings = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDirectxDeviceManager: fn(
            self: *const IAdvancedMediaCaptureSettings,
            value: **IMFDXGIDeviceManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdvancedMediaCaptureSettings_GetDirectxDeviceManager(self: *const T, value: **IMFDXGIDeviceManager) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAdvancedMediaCaptureSettings.VTable, self.vtable).GetDirectxDeviceManager(@ptrCast(*const IAdvancedMediaCaptureSettings, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IAdvancedMediaCapture_Value = @import("../zig.zig").Guid.initString("D0751585-D216-4344-B5BF-463B68F977BB");
pub const IID_IAdvancedMediaCapture = &IID_IAdvancedMediaCapture_Value;
pub const IAdvancedMediaCapture = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAdvancedMediaCaptureSettings: fn(
            self: *const IAdvancedMediaCapture,
            value: **IAdvancedMediaCaptureSettings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAdvancedMediaCapture_GetAdvancedMediaCaptureSettings(self: *const T, value: **IAdvancedMediaCaptureSettings) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAdvancedMediaCapture.VTable, self.vtable).GetAdvancedMediaCaptureSettings(@ptrCast(*const IAdvancedMediaCapture, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSpatialAudioObjectBuffer_Value = @import("../zig.zig").Guid.initString("D396EC8C-605E-4249-978D-72AD1C312872");
pub const IID_IMFSpatialAudioObjectBuffer = &IID_IMFSpatialAudioObjectBuffer_Value;
pub const IMFSpatialAudioObjectBuffer = extern struct {
    pub const VTable = extern struct {
        base: IMFMediaBuffer.VTable,
        SetID: fn(
            self: *const IMFSpatialAudioObjectBuffer,
            u32ID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetID: fn(
            self: *const IMFSpatialAudioObjectBuffer,
            pu32ID: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetType: fn(
            self: *const IMFSpatialAudioObjectBuffer,
            type: AudioObjectType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const IMFSpatialAudioObjectBuffer,
            pType: *AudioObjectType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMetadataItems: fn(
            self: *const IMFSpatialAudioObjectBuffer,
            ppMetadataItems: **ISpatialAudioMetadataItems,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFMediaBuffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSpatialAudioObjectBuffer_SetID(self: *const T, u32ID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSpatialAudioObjectBuffer.VTable, self.vtable).SetID(@ptrCast(*const IMFSpatialAudioObjectBuffer, self), u32ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSpatialAudioObjectBuffer_GetID(self: *const T, pu32ID: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSpatialAudioObjectBuffer.VTable, self.vtable).GetID(@ptrCast(*const IMFSpatialAudioObjectBuffer, self), pu32ID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSpatialAudioObjectBuffer_SetType(self: *const T, type: AudioObjectType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSpatialAudioObjectBuffer.VTable, self.vtable).SetType(@ptrCast(*const IMFSpatialAudioObjectBuffer, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSpatialAudioObjectBuffer_GetType(self: *const T, pType: *AudioObjectType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSpatialAudioObjectBuffer.VTable, self.vtable).GetType(@ptrCast(*const IMFSpatialAudioObjectBuffer, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSpatialAudioObjectBuffer_GetMetadataItems(self: *const T, ppMetadataItems: **ISpatialAudioMetadataItems) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSpatialAudioObjectBuffer.VTable, self.vtable).GetMetadataItems(@ptrCast(*const IMFSpatialAudioObjectBuffer, self), ppMetadataItems);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFSpatialAudioSample_Value = @import("../zig.zig").Guid.initString("ABF28A9B-3393-4290-BA79-5FFC46D986B2");
pub const IID_IMFSpatialAudioSample = &IID_IMFSpatialAudioSample_Value;
pub const IMFSpatialAudioSample = extern struct {
    pub const VTable = extern struct {
        base: IMFSample.VTable,
        GetObjectCount: fn(
            self: *const IMFSpatialAudioSample,
            pdwObjectCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSpatialAudioObject: fn(
            self: *const IMFSpatialAudioSample,
            pAudioObjBuffer: *IMFSpatialAudioObjectBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpatialAudioObjectByIndex: fn(
            self: *const IMFSpatialAudioSample,
            dwIndex: u32,
            ppAudioObjBuffer: **IMFSpatialAudioObjectBuffer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMFSample.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSpatialAudioSample_GetObjectCount(self: *const T, pdwObjectCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSpatialAudioSample.VTable, self.vtable).GetObjectCount(@ptrCast(*const IMFSpatialAudioSample, self), pdwObjectCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSpatialAudioSample_AddSpatialAudioObject(self: *const T, pAudioObjBuffer: *IMFSpatialAudioObjectBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSpatialAudioSample.VTable, self.vtable).AddSpatialAudioObject(@ptrCast(*const IMFSpatialAudioSample, self), pAudioObjBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFSpatialAudioSample_GetSpatialAudioObjectByIndex(self: *const T, dwIndex: u32, ppAudioObjBuffer: **IMFSpatialAudioObjectBuffer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFSpatialAudioSample.VTable, self.vtable).GetSpatialAudioObjectByIndex(@ptrCast(*const IMFSpatialAudioSample, self), dwIndex, ppAudioObjBuffer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFContentDecryptionModuleSession_Value = @import("../zig.zig").Guid.initString("4E233EFD-1DD2-49E8-B577-D63EEE4C0D33");
pub const IID_IMFContentDecryptionModuleSession = &IID_IMFContentDecryptionModuleSession_Value;
pub const IMFContentDecryptionModuleSession = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSessionId: fn(
            self: *const IMFContentDecryptionModuleSession,
            sessionId: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpiration: fn(
            self: *const IMFContentDecryptionModuleSession,
            expiration: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyStatuses: fn(
            self: *const IMFContentDecryptionModuleSession,
            keyStatuses: [*]*MFMediaKeyStatus,
            numKeyStatuses: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Load: fn(
            self: *const IMFContentDecryptionModuleSession,
            sessionId: [*:0]const u16,
            loaded: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GenerateRequest: fn(
            self: *const IMFContentDecryptionModuleSession,
            initDataType: [*:0]const u16,
            initData: [*:0]const u8,
            initDataSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const IMFContentDecryptionModuleSession,
            response: [*:0]const u8,
            responseSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IMFContentDecryptionModuleSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMFContentDecryptionModuleSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSession_GetSessionId(self: *const T, sessionId: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSession.VTable, self.vtable).GetSessionId(@ptrCast(*const IMFContentDecryptionModuleSession, self), sessionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSession_GetExpiration(self: *const T, expiration: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSession.VTable, self.vtable).GetExpiration(@ptrCast(*const IMFContentDecryptionModuleSession, self), expiration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSession_GetKeyStatuses(self: *const T, keyStatuses: [*]*MFMediaKeyStatus, numKeyStatuses: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSession.VTable, self.vtable).GetKeyStatuses(@ptrCast(*const IMFContentDecryptionModuleSession, self), keyStatuses, numKeyStatuses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSession_Load(self: *const T, sessionId: [*:0]const u16, loaded: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSession.VTable, self.vtable).Load(@ptrCast(*const IMFContentDecryptionModuleSession, self), sessionId, loaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSession_GenerateRequest(self: *const T, initDataType: [*:0]const u16, initData: [*:0]const u8, initDataSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSession.VTable, self.vtable).GenerateRequest(@ptrCast(*const IMFContentDecryptionModuleSession, self), initDataType, initData, initDataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSession_Update(self: *const T, response: [*:0]const u8, responseSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSession.VTable, self.vtable).Update(@ptrCast(*const IMFContentDecryptionModuleSession, self), response, responseSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSession_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSession.VTable, self.vtable).Close(@ptrCast(*const IMFContentDecryptionModuleSession, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSession_Remove(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSession.VTable, self.vtable).Remove(@ptrCast(*const IMFContentDecryptionModuleSession, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFContentDecryptionModuleSessionCallbacks_Value = @import("../zig.zig").Guid.initString("3F96EE40-AD81-4096-8470-59A4B770F89A");
pub const IID_IMFContentDecryptionModuleSessionCallbacks = &IID_IMFContentDecryptionModuleSessionCallbacks_Value;
pub const IMFContentDecryptionModuleSessionCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        KeyMessage: fn(
            self: *const IMFContentDecryptionModuleSessionCallbacks,
            messageType: MF_MEDIAKEYSESSION_MESSAGETYPE,
            message: [*:0]const u8,
            messageSize: u32,
            destinationURL: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        KeyStatusChanged: fn(
            self: *const IMFContentDecryptionModuleSessionCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSessionCallbacks_KeyMessage(self: *const T, messageType: MF_MEDIAKEYSESSION_MESSAGETYPE, message: [*:0]const u8, messageSize: u32, destinationURL: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSessionCallbacks.VTable, self.vtable).KeyMessage(@ptrCast(*const IMFContentDecryptionModuleSessionCallbacks, self), messageType, message, messageSize, destinationURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleSessionCallbacks_KeyStatusChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleSessionCallbacks.VTable, self.vtable).KeyStatusChanged(@ptrCast(*const IMFContentDecryptionModuleSessionCallbacks, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFContentDecryptionModule_Value = @import("../zig.zig").Guid.initString("87BE986C-10BE-4943-BF48-4B54CE1983A2");
pub const IID_IMFContentDecryptionModule = &IID_IMFContentDecryptionModule_Value;
pub const IMFContentDecryptionModule = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetContentEnabler: fn(
            self: *const IMFContentDecryptionModule,
            contentEnabler: *IMFContentEnabler,
            result: *IMFAsyncResult,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSuspendNotify: fn(
            self: *const IMFContentDecryptionModule,
            notify: **IMFCdmSuspendNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPMPHostApp: fn(
            self: *const IMFContentDecryptionModule,
            pmpHostApp: *IMFPMPHostApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSession: fn(
            self: *const IMFContentDecryptionModule,
            sessionType: MF_MEDIAKEYSESSION_TYPE,
            callbacks: *IMFContentDecryptionModuleSessionCallbacks,
            session: **IMFContentDecryptionModuleSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetServerCertificate: fn(
            self: *const IMFContentDecryptionModule,
            certificate: [*:0]const u8,
            certificateSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTrustedInput: fn(
            self: *const IMFContentDecryptionModule,
            contentInitData: [*:0]const u8,
            contentInitDataSize: u32,
            trustedInput: **IMFTrustedInput,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtectionSystemIds: fn(
            self: *const IMFContentDecryptionModule,
            systemIds: [*]*Guid,
            count: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModule_SetContentEnabler(self: *const T, contentEnabler: *IMFContentEnabler, result: *IMFAsyncResult) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModule.VTable, self.vtable).SetContentEnabler(@ptrCast(*const IMFContentDecryptionModule, self), contentEnabler, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModule_GetSuspendNotify(self: *const T, notify: **IMFCdmSuspendNotify) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModule.VTable, self.vtable).GetSuspendNotify(@ptrCast(*const IMFContentDecryptionModule, self), notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModule_SetPMPHostApp(self: *const T, pmpHostApp: *IMFPMPHostApp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModule.VTable, self.vtable).SetPMPHostApp(@ptrCast(*const IMFContentDecryptionModule, self), pmpHostApp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModule_CreateSession(self: *const T, sessionType: MF_MEDIAKEYSESSION_TYPE, callbacks: *IMFContentDecryptionModuleSessionCallbacks, session: **IMFContentDecryptionModuleSession) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModule.VTable, self.vtable).CreateSession(@ptrCast(*const IMFContentDecryptionModule, self), sessionType, callbacks, session);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModule_SetServerCertificate(self: *const T, certificate: [*:0]const u8, certificateSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModule.VTable, self.vtable).SetServerCertificate(@ptrCast(*const IMFContentDecryptionModule, self), certificate, certificateSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModule_CreateTrustedInput(self: *const T, contentInitData: [*:0]const u8, contentInitDataSize: u32, trustedInput: **IMFTrustedInput) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModule.VTable, self.vtable).CreateTrustedInput(@ptrCast(*const IMFContentDecryptionModule, self), contentInitData, contentInitDataSize, trustedInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModule_GetProtectionSystemIds(self: *const T, systemIds: [*]*Guid, count: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModule.VTable, self.vtable).GetProtectionSystemIds(@ptrCast(*const IMFContentDecryptionModule, self), systemIds, count);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFContentDecryptionModuleAccess_Value = @import("../zig.zig").Guid.initString("A853D1F4-E2A0-4303-9EDC-F1A68EE43136");
pub const IID_IMFContentDecryptionModuleAccess = &IID_IMFContentDecryptionModuleAccess_Value;
pub const IMFContentDecryptionModuleAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContentDecryptionModule: fn(
            self: *const IMFContentDecryptionModuleAccess,
            contentDecryptionModuleProperties: *IPropertyStore,
            contentDecryptionModule: **IMFContentDecryptionModule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfiguration: fn(
            self: *const IMFContentDecryptionModuleAccess,
            configuration: **IPropertyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeySystem: fn(
            self: *const IMFContentDecryptionModuleAccess,
            keySystem: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleAccess_CreateContentDecryptionModule(self: *const T, contentDecryptionModuleProperties: *IPropertyStore, contentDecryptionModule: **IMFContentDecryptionModule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleAccess.VTable, self.vtable).CreateContentDecryptionModule(@ptrCast(*const IMFContentDecryptionModuleAccess, self), contentDecryptionModuleProperties, contentDecryptionModule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleAccess_GetConfiguration(self: *const T, configuration: **IPropertyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleAccess.VTable, self.vtable).GetConfiguration(@ptrCast(*const IMFContentDecryptionModuleAccess, self), configuration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleAccess_GetKeySystem(self: *const T, keySystem: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleAccess.VTable, self.vtable).GetKeySystem(@ptrCast(*const IMFContentDecryptionModuleAccess, self), keySystem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMFContentDecryptionModuleFactory_Value = @import("../zig.zig").Guid.initString("7D5ABF16-4CBB-4E08-B977-9BA59049943E");
pub const IID_IMFContentDecryptionModuleFactory = &IID_IMFContentDecryptionModuleFactory_Value;
pub const IMFContentDecryptionModuleFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsTypeSupported: fn(
            self: *const IMFContentDecryptionModuleFactory,
            keySystem: [*:0]const u16,
            contentType: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        CreateContentDecryptionModuleAccess: fn(
            self: *const IMFContentDecryptionModuleFactory,
            keySystem: [*:0]const u16,
            configurations: [*]*IPropertyStore,
            numConfigurations: u32,
            contentDecryptionModuleAccess: **IMFContentDecryptionModuleAccess,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleFactory_IsTypeSupported(self: *const T, keySystem: [*:0]const u16, contentType: [*:0]const u16) callconv(.Inline) BOOL {
            return @ptrCast(*const IMFContentDecryptionModuleFactory.VTable, self.vtable).IsTypeSupported(@ptrCast(*const IMFContentDecryptionModuleFactory, self), keySystem, contentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMFContentDecryptionModuleFactory_CreateContentDecryptionModuleAccess(self: *const T, keySystem: [*:0]const u16, configurations: [*]*IPropertyStore, numConfigurations: u32, contentDecryptionModuleAccess: **IMFContentDecryptionModuleAccess) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMFContentDecryptionModuleFactory.VTable, self.vtable).CreateContentDecryptionModuleAccess(@ptrCast(*const IMFContentDecryptionModuleFactory, self), keySystem, configurations, numConfigurations, contentDecryptionModuleAccess);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_VIDEO_DECODER_DESC = extern struct {
    Guid: Guid,
    SampleWidth: u32,
    SampleHeight: u32,
    OutputFormat: DXGI_FORMAT,
};

pub const D3D11_VIDEO_DECODER_CONFIG = extern struct {
    guidConfigBitstreamEncryption: Guid,
    guidConfigMBcontrolEncryption: Guid,
    guidConfigResidDiffEncryption: Guid,
    ConfigBitstreamRaw: u32,
    ConfigMBcontrolRasterOrder: u32,
    ConfigResidDiffHost: u32,
    ConfigSpatialResid8: u32,
    ConfigResid8Subtraction: u32,
    ConfigSpatialHost8or9Clipping: u32,
    ConfigSpatialResidInterleaved: u32,
    ConfigIntraResidUnsigned: u32,
    ConfigResidDiffAccelerator: u32,
    ConfigHostInverseScan: u32,
    ConfigSpecificIDCT: u32,
    Config4GroupedCoefs: u32,
    ConfigMinRenderTargetBuffCount: u16,
    ConfigDecoderSpecific: u16,
};

pub const D3D11_VIDEO_DECODER_BUFFER_TYPE = extern enum(i32) {
    D3D11_VIDEO_DECODER_BUFFER_PICTURE_PARAMETERS = 0,
    D3D11_VIDEO_DECODER_BUFFER_MACROBLOCK_CONTROL = 1,
    D3D11_VIDEO_DECODER_BUFFER_RESIDUAL_DIFFERENCE = 2,
    D3D11_VIDEO_DECODER_BUFFER_DEBLOCKING_CONTROL = 3,
    D3D11_VIDEO_DECODER_BUFFER_INVERSE_QUANTIZATION_MATRIX = 4,
    D3D11_VIDEO_DECODER_BUFFER_SLICE_CONTROL = 5,
    D3D11_VIDEO_DECODER_BUFFER_BITSTREAM = 6,
    D3D11_VIDEO_DECODER_BUFFER_MOTION_VECTOR = 7,
    D3D11_VIDEO_DECODER_BUFFER_FILM_GRAIN = 8,
};
pub const D3D11_VIDEO_DECODER_BUFFER_PICTURE_PARAMETERS = D3D11_VIDEO_DECODER_BUFFER_TYPE.D3D11_VIDEO_DECODER_BUFFER_PICTURE_PARAMETERS;
pub const D3D11_VIDEO_DECODER_BUFFER_MACROBLOCK_CONTROL = D3D11_VIDEO_DECODER_BUFFER_TYPE.D3D11_VIDEO_DECODER_BUFFER_MACROBLOCK_CONTROL;
pub const D3D11_VIDEO_DECODER_BUFFER_RESIDUAL_DIFFERENCE = D3D11_VIDEO_DECODER_BUFFER_TYPE.D3D11_VIDEO_DECODER_BUFFER_RESIDUAL_DIFFERENCE;
pub const D3D11_VIDEO_DECODER_BUFFER_DEBLOCKING_CONTROL = D3D11_VIDEO_DECODER_BUFFER_TYPE.D3D11_VIDEO_DECODER_BUFFER_DEBLOCKING_CONTROL;
pub const D3D11_VIDEO_DECODER_BUFFER_INVERSE_QUANTIZATION_MATRIX = D3D11_VIDEO_DECODER_BUFFER_TYPE.D3D11_VIDEO_DECODER_BUFFER_INVERSE_QUANTIZATION_MATRIX;
pub const D3D11_VIDEO_DECODER_BUFFER_SLICE_CONTROL = D3D11_VIDEO_DECODER_BUFFER_TYPE.D3D11_VIDEO_DECODER_BUFFER_SLICE_CONTROL;
pub const D3D11_VIDEO_DECODER_BUFFER_BITSTREAM = D3D11_VIDEO_DECODER_BUFFER_TYPE.D3D11_VIDEO_DECODER_BUFFER_BITSTREAM;
pub const D3D11_VIDEO_DECODER_BUFFER_MOTION_VECTOR = D3D11_VIDEO_DECODER_BUFFER_TYPE.D3D11_VIDEO_DECODER_BUFFER_MOTION_VECTOR;
pub const D3D11_VIDEO_DECODER_BUFFER_FILM_GRAIN = D3D11_VIDEO_DECODER_BUFFER_TYPE.D3D11_VIDEO_DECODER_BUFFER_FILM_GRAIN;

pub const D3D11_AES_CTR_IV = extern struct {
    IV: u64,
    Count: u64,
};

pub const D3D11_ENCRYPTED_BLOCK_INFO = extern struct {
    NumEncryptedBytesAtBeginning: u32,
    NumBytesInSkipPattern: u32,
    NumBytesInEncryptPattern: u32,
};

pub const D3D11_VIDEO_DECODER_BUFFER_DESC = extern struct {
    BufferType: D3D11_VIDEO_DECODER_BUFFER_TYPE,
    BufferIndex: u32,
    DataOffset: u32,
    DataSize: u32,
    FirstMBaddress: u32,
    NumMBsInBuffer: u32,
    Width: u32,
    Height: u32,
    Stride: u32,
    ReservedBits: u32,
    pIV: *c_void,
    IVSize: u32,
    PartialEncryption: BOOL,
    EncryptedBlockInfo: D3D11_ENCRYPTED_BLOCK_INFO,
};

pub const D3D11_VIDEO_DECODER_EXTENSION = extern struct {
    Function: u32,
    pPrivateInputData: *c_void,
    PrivateInputDataSize: u32,
    pPrivateOutputData: *c_void,
    PrivateOutputDataSize: u32,
    ResourceCount: u32,
    ppResourceList: **ID3D11Resource,
};

const IID_ID3D11VideoDecoder_Value = @import("../zig.zig").Guid.initString("3C9C5B51-995D-48D1-9B8D-FA5CAEDED65C");
pub const IID_ID3D11VideoDecoder = &IID_ID3D11VideoDecoder_Value;
pub const ID3D11VideoDecoder = extern struct {
    pub const VTable = extern struct {
        base: ID3D11DeviceChild.VTable,
        GetCreationParameters: fn(
            self: *const ID3D11VideoDecoder,
            pVideoDesc: *D3D11_VIDEO_DECODER_DESC,
            pConfig: *D3D11_VIDEO_DECODER_CONFIG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDriverHandle: fn(
            self: *const ID3D11VideoDecoder,
            pDriverHandle: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDecoder_GetCreationParameters(self: *const T, pVideoDesc: *D3D11_VIDEO_DECODER_DESC, pConfig: *D3D11_VIDEO_DECODER_CONFIG) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDecoder.VTable, self.vtable).GetCreationParameters(@ptrCast(*const ID3D11VideoDecoder, self), pVideoDesc, pConfig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDecoder_GetDriverHandle(self: *const T, pDriverHandle: *HANDLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDecoder.VTable, self.vtable).GetDriverHandle(@ptrCast(*const ID3D11VideoDecoder, self), pDriverHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT = extern enum(i32) {
    INPUT = 1,
    OUTPUT = 2,
};
pub const D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT_INPUT = D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT.INPUT;
pub const D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT_OUTPUT = D3D11_VIDEO_PROCESSOR_FORMAT_SUPPORT.OUTPUT;

pub const D3D11_VIDEO_PROCESSOR_DEVICE_CAPS = extern enum(i32) {
    LINEAR_SPACE = 1,
    xvYCC = 2,
    RGB_RANGE_CONVERSION = 4,
    YCbCr_MATRIX_CONVERSION = 8,
    NOMINAL_RANGE = 16,
};
pub const D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_LINEAR_SPACE = D3D11_VIDEO_PROCESSOR_DEVICE_CAPS.LINEAR_SPACE;
pub const D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_xvYCC = D3D11_VIDEO_PROCESSOR_DEVICE_CAPS.xvYCC;
pub const D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_RGB_RANGE_CONVERSION = D3D11_VIDEO_PROCESSOR_DEVICE_CAPS.RGB_RANGE_CONVERSION;
pub const D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_YCbCr_MATRIX_CONVERSION = D3D11_VIDEO_PROCESSOR_DEVICE_CAPS.YCbCr_MATRIX_CONVERSION;
pub const D3D11_VIDEO_PROCESSOR_DEVICE_CAPS_NOMINAL_RANGE = D3D11_VIDEO_PROCESSOR_DEVICE_CAPS.NOMINAL_RANGE;

pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS = extern enum(i32) {
    ALPHA_FILL = 1,
    CONSTRICTION = 2,
    LUMA_KEY = 4,
    ALPHA_PALETTE = 8,
    LEGACY = 16,
    STEREO = 32,
    ROTATION = 64,
    ALPHA_STREAM = 128,
    PIXEL_ASPECT_RATIO = 256,
    MIRROR = 512,
    SHADER_USAGE = 1024,
    METADATA_HDR10 = 2048,
};
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_FILL = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.ALPHA_FILL;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_CONSTRICTION = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.CONSTRICTION;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_LUMA_KEY = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.LUMA_KEY;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_PALETTE = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.ALPHA_PALETTE;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_LEGACY = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.LEGACY;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_STEREO = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.STEREO;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ROTATION = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.ROTATION;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_ALPHA_STREAM = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.ALPHA_STREAM;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_PIXEL_ASPECT_RATIO = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.PIXEL_ASPECT_RATIO;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_MIRROR = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.MIRROR;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_SHADER_USAGE = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.SHADER_USAGE;
pub const D3D11_VIDEO_PROCESSOR_FEATURE_CAPS_METADATA_HDR10 = D3D11_VIDEO_PROCESSOR_FEATURE_CAPS.METADATA_HDR10;

pub const D3D11_VIDEO_PROCESSOR_FILTER_CAPS = extern enum(i32) {
    BRIGHTNESS = 1,
    CONTRAST = 2,
    HUE = 4,
    SATURATION = 8,
    NOISE_REDUCTION = 16,
    EDGE_ENHANCEMENT = 32,
    ANAMORPHIC_SCALING = 64,
    STEREO_ADJUSTMENT = 128,
};
pub const D3D11_VIDEO_PROCESSOR_FILTER_CAPS_BRIGHTNESS = D3D11_VIDEO_PROCESSOR_FILTER_CAPS.BRIGHTNESS;
pub const D3D11_VIDEO_PROCESSOR_FILTER_CAPS_CONTRAST = D3D11_VIDEO_PROCESSOR_FILTER_CAPS.CONTRAST;
pub const D3D11_VIDEO_PROCESSOR_FILTER_CAPS_HUE = D3D11_VIDEO_PROCESSOR_FILTER_CAPS.HUE;
pub const D3D11_VIDEO_PROCESSOR_FILTER_CAPS_SATURATION = D3D11_VIDEO_PROCESSOR_FILTER_CAPS.SATURATION;
pub const D3D11_VIDEO_PROCESSOR_FILTER_CAPS_NOISE_REDUCTION = D3D11_VIDEO_PROCESSOR_FILTER_CAPS.NOISE_REDUCTION;
pub const D3D11_VIDEO_PROCESSOR_FILTER_CAPS_EDGE_ENHANCEMENT = D3D11_VIDEO_PROCESSOR_FILTER_CAPS.EDGE_ENHANCEMENT;
pub const D3D11_VIDEO_PROCESSOR_FILTER_CAPS_ANAMORPHIC_SCALING = D3D11_VIDEO_PROCESSOR_FILTER_CAPS.ANAMORPHIC_SCALING;
pub const D3D11_VIDEO_PROCESSOR_FILTER_CAPS_STEREO_ADJUSTMENT = D3D11_VIDEO_PROCESSOR_FILTER_CAPS.STEREO_ADJUSTMENT;

pub const D3D11_VIDEO_PROCESSOR_FORMAT_CAPS = extern enum(i32) {
    RGB_INTERLACED = 1,
    RGB_PROCAMP = 2,
    RGB_LUMA_KEY = 4,
    PALETTE_INTERLACED = 8,
};
pub const D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_INTERLACED = D3D11_VIDEO_PROCESSOR_FORMAT_CAPS.RGB_INTERLACED;
pub const D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_PROCAMP = D3D11_VIDEO_PROCESSOR_FORMAT_CAPS.RGB_PROCAMP;
pub const D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_RGB_LUMA_KEY = D3D11_VIDEO_PROCESSOR_FORMAT_CAPS.RGB_LUMA_KEY;
pub const D3D11_VIDEO_PROCESSOR_FORMAT_CAPS_PALETTE_INTERLACED = D3D11_VIDEO_PROCESSOR_FORMAT_CAPS.PALETTE_INTERLACED;

pub const D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS = extern enum(i32) {
    DENOISE = 1,
    DERINGING = 2,
    EDGE_ENHANCEMENT = 4,
    COLOR_CORRECTION = 8,
    FLESH_TONE_MAPPING = 16,
    IMAGE_STABILIZATION = 32,
    SUPER_RESOLUTION = 64,
    ANAMORPHIC_SCALING = 128,
};
pub const D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_DENOISE = D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS.DENOISE;
pub const D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_DERINGING = D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS.DERINGING;
pub const D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_EDGE_ENHANCEMENT = D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS.EDGE_ENHANCEMENT;
pub const D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_COLOR_CORRECTION = D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS.COLOR_CORRECTION;
pub const D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_FLESH_TONE_MAPPING = D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS.FLESH_TONE_MAPPING;
pub const D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_IMAGE_STABILIZATION = D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS.IMAGE_STABILIZATION;
pub const D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_SUPER_RESOLUTION = D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS.SUPER_RESOLUTION;
pub const D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS_ANAMORPHIC_SCALING = D3D11_VIDEO_PROCESSOR_AUTO_STREAM_CAPS.ANAMORPHIC_SCALING;

pub const D3D11_VIDEO_PROCESSOR_STEREO_CAPS = extern enum(i32) {
    MONO_OFFSET = 1,
    ROW_INTERLEAVED = 2,
    COLUMN_INTERLEAVED = 4,
    CHECKERBOARD = 8,
    FLIP_MODE = 16,
};
pub const D3D11_VIDEO_PROCESSOR_STEREO_CAPS_MONO_OFFSET = D3D11_VIDEO_PROCESSOR_STEREO_CAPS.MONO_OFFSET;
pub const D3D11_VIDEO_PROCESSOR_STEREO_CAPS_ROW_INTERLEAVED = D3D11_VIDEO_PROCESSOR_STEREO_CAPS.ROW_INTERLEAVED;
pub const D3D11_VIDEO_PROCESSOR_STEREO_CAPS_COLUMN_INTERLEAVED = D3D11_VIDEO_PROCESSOR_STEREO_CAPS.COLUMN_INTERLEAVED;
pub const D3D11_VIDEO_PROCESSOR_STEREO_CAPS_CHECKERBOARD = D3D11_VIDEO_PROCESSOR_STEREO_CAPS.CHECKERBOARD;
pub const D3D11_VIDEO_PROCESSOR_STEREO_CAPS_FLIP_MODE = D3D11_VIDEO_PROCESSOR_STEREO_CAPS.FLIP_MODE;

pub const D3D11_VIDEO_PROCESSOR_CAPS = extern struct {
    DeviceCaps: u32,
    FeatureCaps: u32,
    FilterCaps: u32,
    InputFormatCaps: u32,
    AutoStreamCaps: u32,
    StereoCaps: u32,
    RateConversionCapsCount: u32,
    MaxInputStreams: u32,
    MaxStreamStates: u32,
};

pub const D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS = extern enum(i32) {
    DEINTERLACE_BLEND = 1,
    DEINTERLACE_BOB = 2,
    DEINTERLACE_ADAPTIVE = 4,
    DEINTERLACE_MOTION_COMPENSATION = 8,
    INVERSE_TELECINE = 16,
    FRAME_RATE_CONVERSION = 32,
};
pub const D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_BLEND = D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS.DEINTERLACE_BLEND;
pub const D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_BOB = D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS.DEINTERLACE_BOB;
pub const D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_ADAPTIVE = D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS.DEINTERLACE_ADAPTIVE;
pub const D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_DEINTERLACE_MOTION_COMPENSATION = D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS.DEINTERLACE_MOTION_COMPENSATION;
pub const D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_INVERSE_TELECINE = D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS.INVERSE_TELECINE;
pub const D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS_FRAME_RATE_CONVERSION = D3D11_VIDEO_PROCESSOR_PROCESSOR_CAPS.FRAME_RATE_CONVERSION;

pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS = extern enum(i32) {
    _32 = 1,
    _22 = 2,
    _2224 = 4,
    _2332 = 8,
    _32322 = 16,
    _55 = 32,
    _64 = 64,
    _87 = 128,
    _222222222223 = 256,
    OTHER = -2147483648,
};
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_32 = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS._32;
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_22 = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS._22;
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_2224 = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS._2224;
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_2332 = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS._2332;
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_32322 = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS._32322;
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_55 = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS._55;
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_64 = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS._64;
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_87 = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS._87;
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_222222222223 = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS._222222222223;
pub const D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS_OTHER = D3D11_VIDEO_PROCESSOR_ITELECINE_CAPS.OTHER;

pub const D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS = extern struct {
    PastFrames: u32,
    FutureFrames: u32,
    ProcessorCaps: u32,
    ITelecineCaps: u32,
    CustomRateCount: u32,
};

pub const D3D11_CONTENT_PROTECTION_CAPS = extern enum(i32) {
    SOFTWARE = 1,
    HARDWARE = 2,
    PROTECTION_ALWAYS_ON = 4,
    PARTIAL_DECRYPTION = 8,
    CONTENT_KEY = 16,
    FRESHEN_SESSION_KEY = 32,
    ENCRYPTED_READ_BACK = 64,
    ENCRYPTED_READ_BACK_KEY = 128,
    SEQUENTIAL_CTR_IV = 256,
    ENCRYPT_SLICEDATA_ONLY = 512,
    DECRYPTION_BLT = 1024,
    HARDWARE_PROTECT_UNCOMPRESSED = 2048,
    HARDWARE_PROTECTED_MEMORY_PAGEABLE = 4096,
    HARDWARE_TEARDOWN = 8192,
    HARDWARE_DRM_COMMUNICATION = 16384,
    HARDWARE_DRM_COMMUNICATION_MULTI_THREADED = 32768,
};
pub const D3D11_CONTENT_PROTECTION_CAPS_SOFTWARE = D3D11_CONTENT_PROTECTION_CAPS.SOFTWARE;
pub const D3D11_CONTENT_PROTECTION_CAPS_HARDWARE = D3D11_CONTENT_PROTECTION_CAPS.HARDWARE;
pub const D3D11_CONTENT_PROTECTION_CAPS_PROTECTION_ALWAYS_ON = D3D11_CONTENT_PROTECTION_CAPS.PROTECTION_ALWAYS_ON;
pub const D3D11_CONTENT_PROTECTION_CAPS_PARTIAL_DECRYPTION = D3D11_CONTENT_PROTECTION_CAPS.PARTIAL_DECRYPTION;
pub const D3D11_CONTENT_PROTECTION_CAPS_CONTENT_KEY = D3D11_CONTENT_PROTECTION_CAPS.CONTENT_KEY;
pub const D3D11_CONTENT_PROTECTION_CAPS_FRESHEN_SESSION_KEY = D3D11_CONTENT_PROTECTION_CAPS.FRESHEN_SESSION_KEY;
pub const D3D11_CONTENT_PROTECTION_CAPS_ENCRYPTED_READ_BACK = D3D11_CONTENT_PROTECTION_CAPS.ENCRYPTED_READ_BACK;
pub const D3D11_CONTENT_PROTECTION_CAPS_ENCRYPTED_READ_BACK_KEY = D3D11_CONTENT_PROTECTION_CAPS.ENCRYPTED_READ_BACK_KEY;
pub const D3D11_CONTENT_PROTECTION_CAPS_SEQUENTIAL_CTR_IV = D3D11_CONTENT_PROTECTION_CAPS.SEQUENTIAL_CTR_IV;
pub const D3D11_CONTENT_PROTECTION_CAPS_ENCRYPT_SLICEDATA_ONLY = D3D11_CONTENT_PROTECTION_CAPS.ENCRYPT_SLICEDATA_ONLY;
pub const D3D11_CONTENT_PROTECTION_CAPS_DECRYPTION_BLT = D3D11_CONTENT_PROTECTION_CAPS.DECRYPTION_BLT;
pub const D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_PROTECT_UNCOMPRESSED = D3D11_CONTENT_PROTECTION_CAPS.HARDWARE_PROTECT_UNCOMPRESSED;
pub const D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_PROTECTED_MEMORY_PAGEABLE = D3D11_CONTENT_PROTECTION_CAPS.HARDWARE_PROTECTED_MEMORY_PAGEABLE;
pub const D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_TEARDOWN = D3D11_CONTENT_PROTECTION_CAPS.HARDWARE_TEARDOWN;
pub const D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_DRM_COMMUNICATION = D3D11_CONTENT_PROTECTION_CAPS.HARDWARE_DRM_COMMUNICATION;
pub const D3D11_CONTENT_PROTECTION_CAPS_HARDWARE_DRM_COMMUNICATION_MULTI_THREADED = D3D11_CONTENT_PROTECTION_CAPS.HARDWARE_DRM_COMMUNICATION_MULTI_THREADED;

pub const D3D11_VIDEO_CONTENT_PROTECTION_CAPS = extern struct {
    Caps: u32,
    KeyExchangeTypeCount: u32,
    BlockAlignmentSize: u32,
    ProtectedMemorySize: u64,
};

pub const D3D11_VIDEO_PROCESSOR_CUSTOM_RATE = extern struct {
    CustomRate: DXGI_RATIONAL,
    OutputFrames: u32,
    InputInterlaced: BOOL,
    InputFramesOrFields: u32,
};

pub const D3D11_VIDEO_PROCESSOR_FILTER = extern enum(i32) {
    BRIGHTNESS = 0,
    CONTRAST = 1,
    HUE = 2,
    SATURATION = 3,
    NOISE_REDUCTION = 4,
    EDGE_ENHANCEMENT = 5,
    ANAMORPHIC_SCALING = 6,
    STEREO_ADJUSTMENT = 7,
};
pub const D3D11_VIDEO_PROCESSOR_FILTER_BRIGHTNESS = D3D11_VIDEO_PROCESSOR_FILTER.BRIGHTNESS;
pub const D3D11_VIDEO_PROCESSOR_FILTER_CONTRAST = D3D11_VIDEO_PROCESSOR_FILTER.CONTRAST;
pub const D3D11_VIDEO_PROCESSOR_FILTER_HUE = D3D11_VIDEO_PROCESSOR_FILTER.HUE;
pub const D3D11_VIDEO_PROCESSOR_FILTER_SATURATION = D3D11_VIDEO_PROCESSOR_FILTER.SATURATION;
pub const D3D11_VIDEO_PROCESSOR_FILTER_NOISE_REDUCTION = D3D11_VIDEO_PROCESSOR_FILTER.NOISE_REDUCTION;
pub const D3D11_VIDEO_PROCESSOR_FILTER_EDGE_ENHANCEMENT = D3D11_VIDEO_PROCESSOR_FILTER.EDGE_ENHANCEMENT;
pub const D3D11_VIDEO_PROCESSOR_FILTER_ANAMORPHIC_SCALING = D3D11_VIDEO_PROCESSOR_FILTER.ANAMORPHIC_SCALING;
pub const D3D11_VIDEO_PROCESSOR_FILTER_STEREO_ADJUSTMENT = D3D11_VIDEO_PROCESSOR_FILTER.STEREO_ADJUSTMENT;

pub const D3D11_VIDEO_PROCESSOR_FILTER_RANGE = extern struct {
    Minimum: i32,
    Maximum: i32,
    Default: i32,
    Multiplier: f32,
};

pub const D3D11_VIDEO_FRAME_FORMAT = extern enum(i32) {
    PROGRESSIVE = 0,
    INTERLACED_TOP_FIELD_FIRST = 1,
    INTERLACED_BOTTOM_FIELD_FIRST = 2,
};
pub const D3D11_VIDEO_FRAME_FORMAT_PROGRESSIVE = D3D11_VIDEO_FRAME_FORMAT.PROGRESSIVE;
pub const D3D11_VIDEO_FRAME_FORMAT_INTERLACED_TOP_FIELD_FIRST = D3D11_VIDEO_FRAME_FORMAT.INTERLACED_TOP_FIELD_FIRST;
pub const D3D11_VIDEO_FRAME_FORMAT_INTERLACED_BOTTOM_FIELD_FIRST = D3D11_VIDEO_FRAME_FORMAT.INTERLACED_BOTTOM_FIELD_FIRST;

pub const D3D11_VIDEO_USAGE = extern enum(i32) {
    PLAYBACK_NORMAL = 0,
    OPTIMAL_SPEED = 1,
    OPTIMAL_QUALITY = 2,
};
pub const D3D11_VIDEO_USAGE_PLAYBACK_NORMAL = D3D11_VIDEO_USAGE.PLAYBACK_NORMAL;
pub const D3D11_VIDEO_USAGE_OPTIMAL_SPEED = D3D11_VIDEO_USAGE.OPTIMAL_SPEED;
pub const D3D11_VIDEO_USAGE_OPTIMAL_QUALITY = D3D11_VIDEO_USAGE.OPTIMAL_QUALITY;

pub const D3D11_VIDEO_PROCESSOR_CONTENT_DESC = extern struct {
    InputFrameFormat: D3D11_VIDEO_FRAME_FORMAT,
    InputFrameRate: DXGI_RATIONAL,
    InputWidth: u32,
    InputHeight: u32,
    OutputFrameRate: DXGI_RATIONAL,
    OutputWidth: u32,
    OutputHeight: u32,
    Usage: D3D11_VIDEO_USAGE,
};

const IID_ID3D11VideoProcessorEnumerator_Value = @import("../zig.zig").Guid.initString("31627037-53AB-4200-9061-05FAA9AB45F9");
pub const IID_ID3D11VideoProcessorEnumerator = &IID_ID3D11VideoProcessorEnumerator_Value;
pub const ID3D11VideoProcessorEnumerator = extern struct {
    pub const VTable = extern struct {
        base: ID3D11DeviceChild.VTable,
        GetVideoProcessorContentDesc: fn(
            self: *const ID3D11VideoProcessorEnumerator,
            pContentDesc: *D3D11_VIDEO_PROCESSOR_CONTENT_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckVideoProcessorFormat: fn(
            self: *const ID3D11VideoProcessorEnumerator,
            Format: DXGI_FORMAT,
            pFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorCaps: fn(
            self: *const ID3D11VideoProcessorEnumerator,
            pCaps: *D3D11_VIDEO_PROCESSOR_CAPS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorRateConversionCaps: fn(
            self: *const ID3D11VideoProcessorEnumerator,
            TypeIndex: u32,
            pCaps: *D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorCustomRate: fn(
            self: *const ID3D11VideoProcessorEnumerator,
            TypeIndex: u32,
            CustomRateIndex: u32,
            pRate: *D3D11_VIDEO_PROCESSOR_CUSTOM_RATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoProcessorFilterRange: fn(
            self: *const ID3D11VideoProcessorEnumerator,
            Filter: D3D11_VIDEO_PROCESSOR_FILTER,
            pRange: *D3D11_VIDEO_PROCESSOR_FILTER_RANGE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessorEnumerator_GetVideoProcessorContentDesc(self: *const T, pContentDesc: *D3D11_VIDEO_PROCESSOR_CONTENT_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoProcessorEnumerator.VTable, self.vtable).GetVideoProcessorContentDesc(@ptrCast(*const ID3D11VideoProcessorEnumerator, self), pContentDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessorEnumerator_CheckVideoProcessorFormat(self: *const T, Format: DXGI_FORMAT, pFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoProcessorEnumerator.VTable, self.vtable).CheckVideoProcessorFormat(@ptrCast(*const ID3D11VideoProcessorEnumerator, self), Format, pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessorEnumerator_GetVideoProcessorCaps(self: *const T, pCaps: *D3D11_VIDEO_PROCESSOR_CAPS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoProcessorEnumerator.VTable, self.vtable).GetVideoProcessorCaps(@ptrCast(*const ID3D11VideoProcessorEnumerator, self), pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessorEnumerator_GetVideoProcessorRateConversionCaps(self: *const T, TypeIndex: u32, pCaps: *D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoProcessorEnumerator.VTable, self.vtable).GetVideoProcessorRateConversionCaps(@ptrCast(*const ID3D11VideoProcessorEnumerator, self), TypeIndex, pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessorEnumerator_GetVideoProcessorCustomRate(self: *const T, TypeIndex: u32, CustomRateIndex: u32, pRate: *D3D11_VIDEO_PROCESSOR_CUSTOM_RATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoProcessorEnumerator.VTable, self.vtable).GetVideoProcessorCustomRate(@ptrCast(*const ID3D11VideoProcessorEnumerator, self), TypeIndex, CustomRateIndex, pRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessorEnumerator_GetVideoProcessorFilterRange(self: *const T, Filter: D3D11_VIDEO_PROCESSOR_FILTER, pRange: *D3D11_VIDEO_PROCESSOR_FILTER_RANGE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoProcessorEnumerator.VTable, self.vtable).GetVideoProcessorFilterRange(@ptrCast(*const ID3D11VideoProcessorEnumerator, self), Filter, pRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_VIDEO_COLOR_RGBA = extern struct {
    R: f32,
    G: f32,
    B: f32,
    A: f32,
};

pub const D3D11_VIDEO_COLOR_YCbCrA = extern struct {
    Y: f32,
    Cb: f32,
    Cr: f32,
    A: f32,
};

pub const D3D11_VIDEO_COLOR = extern struct {
    Anonymous: D3D11_VIDEO_COLOR._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE = extern enum(i32) {
    UNDEFINED = 0,
    _16_235 = 1,
    _0_255 = 2,
};
pub const D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_UNDEFINED = D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE.UNDEFINED;
pub const D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_16_235 = D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE._16_235;
pub const D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE_0_255 = D3D11_VIDEO_PROCESSOR_NOMINAL_RANGE._0_255;

pub const D3D11_VIDEO_PROCESSOR_COLOR_SPACE = extern struct {
    _bitfield: u32,
};

pub const D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE = extern enum(i32) {
    OPAQUE = 0,
    BACKGROUND = 1,
    DESTINATION = 2,
    SOURCE_STREAM = 3,
};
pub const D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_OPAQUE = D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE.OPAQUE;
pub const D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_BACKGROUND = D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE.BACKGROUND;
pub const D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_DESTINATION = D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE.DESTINATION;
pub const D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE_SOURCE_STREAM = D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE.SOURCE_STREAM;

pub const D3D11_VIDEO_PROCESSOR_OUTPUT_RATE = extern enum(i32) {
    NORMAL = 0,
    HALF = 1,
    CUSTOM = 2,
};
pub const D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_NORMAL = D3D11_VIDEO_PROCESSOR_OUTPUT_RATE.NORMAL;
pub const D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_HALF = D3D11_VIDEO_PROCESSOR_OUTPUT_RATE.HALF;
pub const D3D11_VIDEO_PROCESSOR_OUTPUT_RATE_CUSTOM = D3D11_VIDEO_PROCESSOR_OUTPUT_RATE.CUSTOM;

pub const D3D11_VIDEO_PROCESSOR_STEREO_FORMAT = extern enum(i32) {
    MONO = 0,
    HORIZONTAL = 1,
    VERTICAL = 2,
    SEPARATE = 3,
    MONO_OFFSET = 4,
    ROW_INTERLEAVED = 5,
    COLUMN_INTERLEAVED = 6,
    CHECKERBOARD = 7,
};
pub const D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO = D3D11_VIDEO_PROCESSOR_STEREO_FORMAT.MONO;
pub const D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_HORIZONTAL = D3D11_VIDEO_PROCESSOR_STEREO_FORMAT.HORIZONTAL;
pub const D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_VERTICAL = D3D11_VIDEO_PROCESSOR_STEREO_FORMAT.VERTICAL;
pub const D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_SEPARATE = D3D11_VIDEO_PROCESSOR_STEREO_FORMAT.SEPARATE;
pub const D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_MONO_OFFSET = D3D11_VIDEO_PROCESSOR_STEREO_FORMAT.MONO_OFFSET;
pub const D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_ROW_INTERLEAVED = D3D11_VIDEO_PROCESSOR_STEREO_FORMAT.ROW_INTERLEAVED;
pub const D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_COLUMN_INTERLEAVED = D3D11_VIDEO_PROCESSOR_STEREO_FORMAT.COLUMN_INTERLEAVED;
pub const D3D11_VIDEO_PROCESSOR_STEREO_FORMAT_CHECKERBOARD = D3D11_VIDEO_PROCESSOR_STEREO_FORMAT.CHECKERBOARD;

pub const D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE = extern enum(i32) {
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_NONE = 0,
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME0 = 1,
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME1 = 2,
};
pub const D3D11_VIDEO_PROCESSOR_STEREO_FLIP_NONE = D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE.D3D11_VIDEO_PROCESSOR_STEREO_FLIP_NONE;
pub const D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME0 = D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE.D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME0;
pub const D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME1 = D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE.D3D11_VIDEO_PROCESSOR_STEREO_FLIP_FRAME1;

pub const D3D11_VIDEO_PROCESSOR_ROTATION = extern enum(i32) {
    IDENTITY = 0,
    _90 = 1,
    _180 = 2,
    _270 = 3,
};
pub const D3D11_VIDEO_PROCESSOR_ROTATION_IDENTITY = D3D11_VIDEO_PROCESSOR_ROTATION.IDENTITY;
pub const D3D11_VIDEO_PROCESSOR_ROTATION_90 = D3D11_VIDEO_PROCESSOR_ROTATION._90;
pub const D3D11_VIDEO_PROCESSOR_ROTATION_180 = D3D11_VIDEO_PROCESSOR_ROTATION._180;
pub const D3D11_VIDEO_PROCESSOR_ROTATION_270 = D3D11_VIDEO_PROCESSOR_ROTATION._270;

pub const D3D11_VIDEO_PROCESSOR_STREAM = extern struct {
    Enable: BOOL,
    OutputIndex: u32,
    InputFrameOrField: u32,
    PastFrames: u32,
    FutureFrames: u32,
    ppPastSurfaces: **ID3D11VideoProcessorInputView,
    pInputSurface: *ID3D11VideoProcessorInputView,
    ppFutureSurfaces: **ID3D11VideoProcessorInputView,
    ppPastSurfacesRight: **ID3D11VideoProcessorInputView,
    pInputSurfaceRight: *ID3D11VideoProcessorInputView,
    ppFutureSurfacesRight: **ID3D11VideoProcessorInputView,
};

const IID_ID3D11VideoProcessor_Value = @import("../zig.zig").Guid.initString("1D7B0652-185F-41C6-85CE-0C5BE3D4AE6C");
pub const IID_ID3D11VideoProcessor = &IID_ID3D11VideoProcessor_Value;
pub const ID3D11VideoProcessor = extern struct {
    pub const VTable = extern struct {
        base: ID3D11DeviceChild.VTable,
        GetContentDesc: fn(
            self: *const ID3D11VideoProcessor,
            pDesc: *D3D11_VIDEO_PROCESSOR_CONTENT_DESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetRateConversionCaps: fn(
            self: *const ID3D11VideoProcessor,
            pCaps: *D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessor_GetContentDesc(self: *const T, pDesc: *D3D11_VIDEO_PROCESSOR_CONTENT_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoProcessor.VTable, self.vtable).GetContentDesc(@ptrCast(*const ID3D11VideoProcessor, self), pDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessor_GetRateConversionCaps(self: *const T, pCaps: *D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoProcessor.VTable, self.vtable).GetRateConversionCaps(@ptrCast(*const ID3D11VideoProcessor, self), pCaps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_OMAC = extern struct {
    Omac: [16]u8,
};

pub const D3D11_AUTHENTICATED_CHANNEL_TYPE = extern enum(i32) {
    D3D11_AUTHENTICATED_CHANNEL_D3D11 = 1,
    D3D11_AUTHENTICATED_CHANNEL_DRIVER_SOFTWARE = 2,
    D3D11_AUTHENTICATED_CHANNEL_DRIVER_HARDWARE = 3,
};
pub const D3D11_AUTHENTICATED_CHANNEL_D3D11 = D3D11_AUTHENTICATED_CHANNEL_TYPE.D3D11_AUTHENTICATED_CHANNEL_D3D11;
pub const D3D11_AUTHENTICATED_CHANNEL_DRIVER_SOFTWARE = D3D11_AUTHENTICATED_CHANNEL_TYPE.D3D11_AUTHENTICATED_CHANNEL_DRIVER_SOFTWARE;
pub const D3D11_AUTHENTICATED_CHANNEL_DRIVER_HARDWARE = D3D11_AUTHENTICATED_CHANNEL_TYPE.D3D11_AUTHENTICATED_CHANNEL_DRIVER_HARDWARE;

const IID_ID3D11AuthenticatedChannel_Value = @import("../zig.zig").Guid.initString("3015A308-DCBD-47AA-A747-192486D14D4A");
pub const IID_ID3D11AuthenticatedChannel = &IID_ID3D11AuthenticatedChannel_Value;
pub const ID3D11AuthenticatedChannel = extern struct {
    pub const VTable = extern struct {
        base: ID3D11DeviceChild.VTable,
        GetCertificateSize: fn(
            self: *const ID3D11AuthenticatedChannel,
            pCertificateSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificate: fn(
            self: *const ID3D11AuthenticatedChannel,
            CertificateSize: u32,
            pCertificate: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChannelHandle: fn(
            self: *const ID3D11AuthenticatedChannel,
            pChannelHandle: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11AuthenticatedChannel_GetCertificateSize(self: *const T, pCertificateSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11AuthenticatedChannel.VTable, self.vtable).GetCertificateSize(@ptrCast(*const ID3D11AuthenticatedChannel, self), pCertificateSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11AuthenticatedChannel_GetCertificate(self: *const T, CertificateSize: u32, pCertificate: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11AuthenticatedChannel.VTable, self.vtable).GetCertificate(@ptrCast(*const ID3D11AuthenticatedChannel, self), CertificateSize, pCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11AuthenticatedChannel_GetChannelHandle(self: *const T, pChannelHandle: *HANDLE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11AuthenticatedChannel.VTable, self.vtable).GetChannelHandle(@ptrCast(*const ID3D11AuthenticatedChannel, self), pChannelHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_AUTHENTICATED_QUERY_INPUT = extern struct {
    QueryType: Guid,
    hChannel: HANDLE,
    SequenceNumber: u32,
};

pub const D3D11_AUTHENTICATED_QUERY_OUTPUT = extern struct {
    omac: D3D11_OMAC,
    QueryType: Guid,
    hChannel: HANDLE,
    SequenceNumber: u32,
    ReturnCode: HRESULT,
};

pub const D3D11_AUTHENTICATED_QUERY_PROTECTION_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    ProtectionFlags: D3D11_AUTHENTICATED_PROTECTION_FLAGS,
};

pub const D3D11_AUTHENTICATED_QUERY_CHANNEL_TYPE_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    ChannelType: D3D11_AUTHENTICATED_CHANNEL_TYPE,
};

pub const D3D11_AUTHENTICATED_QUERY_DEVICE_HANDLE_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    DeviceHandle: HANDLE,
};

pub const D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_INPUT = extern struct {
    Input: D3D11_AUTHENTICATED_QUERY_INPUT,
    DecoderHandle: HANDLE,
};

pub const D3D11_AUTHENTICATED_QUERY_CRYPTO_SESSION_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    DecoderHandle: HANDLE,
    CryptoSessionHandle: HANDLE,
    DeviceHandle: HANDLE,
};

pub const D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_COUNT_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    RestrictedSharedResourceProcessCount: u32,
};

pub const D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_INPUT = extern struct {
    Input: D3D11_AUTHENTICATED_QUERY_INPUT,
    ProcessIndex: u32,
};

pub const D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE = extern enum(i32) {
    D3D11_PROCESSIDTYPE_UNKNOWN = 0,
    D3D11_PROCESSIDTYPE_DWM = 1,
    D3D11_PROCESSIDTYPE_HANDLE = 2,
};
pub const D3D11_PROCESSIDTYPE_UNKNOWN = D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE.D3D11_PROCESSIDTYPE_UNKNOWN;
pub const D3D11_PROCESSIDTYPE_DWM = D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE.D3D11_PROCESSIDTYPE_DWM;
pub const D3D11_PROCESSIDTYPE_HANDLE = D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE.D3D11_PROCESSIDTYPE_HANDLE;

pub const D3D11_AUTHENTICATED_QUERY_RESTRICTED_SHARED_RESOURCE_PROCESS_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    ProcessIndex: u32,
    ProcessIdentifier: D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE,
    ProcessHandle: HANDLE,
};

pub const D3D11_AUTHENTICATED_QUERY_UNRESTRICTED_PROTECTED_SHARED_RESOURCE_COUNT_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    UnrestrictedProtectedSharedResourceCount: u32,
};

pub const D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_INPUT = extern struct {
    Input: D3D11_AUTHENTICATED_QUERY_INPUT,
    DeviceHandle: HANDLE,
    CryptoSessionHandle: HANDLE,
};

pub const D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_COUNT_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    DeviceHandle: HANDLE,
    CryptoSessionHandle: HANDLE,
    OutputIDCount: u32,
};

pub const D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_INPUT = extern struct {
    Input: D3D11_AUTHENTICATED_QUERY_INPUT,
    DeviceHandle: HANDLE,
    CryptoSessionHandle: HANDLE,
    OutputIDIndex: u32,
};

pub const D3D11_AUTHENTICATED_QUERY_OUTPUT_ID_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    DeviceHandle: HANDLE,
    CryptoSessionHandle: HANDLE,
    OutputIDIndex: u32,
    OutputID: u64,
};

pub const D3D11_BUS_TYPE = extern enum(i32) {
    OTHER = 0,
    PCI = 1,
    PCIX = 2,
    PCIEXPRESS = 3,
    AGP = 4,
    D3D11_BUS_IMPL_MODIFIER_INSIDE_OF_CHIPSET = 65536,
    D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP = 131072,
    D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = 196608,
    D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR = 262144,
    D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = 327680,
    D3D11_BUS_IMPL_MODIFIER_NON_STANDARD = -2147483648,
};
pub const D3D11_BUS_TYPE_OTHER = D3D11_BUS_TYPE.OTHER;
pub const D3D11_BUS_TYPE_PCI = D3D11_BUS_TYPE.PCI;
pub const D3D11_BUS_TYPE_PCIX = D3D11_BUS_TYPE.PCIX;
pub const D3D11_BUS_TYPE_PCIEXPRESS = D3D11_BUS_TYPE.PCIEXPRESS;
pub const D3D11_BUS_TYPE_AGP = D3D11_BUS_TYPE.AGP;
pub const D3D11_BUS_IMPL_MODIFIER_INSIDE_OF_CHIPSET = D3D11_BUS_TYPE.D3D11_BUS_IMPL_MODIFIER_INSIDE_OF_CHIPSET;
pub const D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP = D3D11_BUS_TYPE.D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_CHIP;
pub const D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET = D3D11_BUS_TYPE.D3D11_BUS_IMPL_MODIFIER_TRACKS_ON_MOTHER_BOARD_TO_SOCKET;
pub const D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR = D3D11_BUS_TYPE.D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR;
pub const D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE = D3D11_BUS_TYPE.D3D11_BUS_IMPL_MODIFIER_DAUGHTER_BOARD_CONNECTOR_INSIDE_OF_NUAE;
pub const D3D11_BUS_IMPL_MODIFIER_NON_STANDARD = D3D11_BUS_TYPE.D3D11_BUS_IMPL_MODIFIER_NON_STANDARD;

pub const D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    BusType: D3D11_BUS_TYPE,
    AccessibleInContiguousBlocks: BOOL,
    AccessibleInNonContiguousBlocks: BOOL,
};

pub const D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_COUNT_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    EncryptionGuidCount: u32,
};

pub const D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_INPUT = extern struct {
    Input: D3D11_AUTHENTICATED_QUERY_INPUT,
    EncryptionGuidIndex: u32,
};

pub const D3D11_AUTHENTICATED_QUERY_ACCESSIBILITY_ENCRYPTION_GUID_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    EncryptionGuidIndex: u32,
    EncryptionGuid: Guid,
};

pub const D3D11_AUTHENTICATED_QUERY_CURRENT_ACCESSIBILITY_ENCRYPTION_OUTPUT = extern struct {
    Output: D3D11_AUTHENTICATED_QUERY_OUTPUT,
    EncryptionGuid: Guid,
};

pub const D3D11_AUTHENTICATED_CONFIGURE_INPUT = extern struct {
    omac: D3D11_OMAC,
    ConfigureType: Guid,
    hChannel: HANDLE,
    SequenceNumber: u32,
};

pub const D3D11_AUTHENTICATED_CONFIGURE_OUTPUT = extern struct {
    omac: D3D11_OMAC,
    ConfigureType: Guid,
    hChannel: HANDLE,
    SequenceNumber: u32,
    ReturnCode: HRESULT,
};

pub const D3D11_AUTHENTICATED_CONFIGURE_INITIALIZE_INPUT = extern struct {
    Parameters: D3D11_AUTHENTICATED_CONFIGURE_INPUT,
    StartSequenceQuery: u32,
    StartSequenceConfigure: u32,
};

pub const D3D11_AUTHENTICATED_CONFIGURE_PROTECTION_INPUT = extern struct {
    Parameters: D3D11_AUTHENTICATED_CONFIGURE_INPUT,
    Protections: D3D11_AUTHENTICATED_PROTECTION_FLAGS,
};

pub const D3D11_AUTHENTICATED_CONFIGURE_CRYPTO_SESSION_INPUT = extern struct {
    Parameters: D3D11_AUTHENTICATED_CONFIGURE_INPUT,
    DecoderHandle: HANDLE,
    CryptoSessionHandle: HANDLE,
    DeviceHandle: HANDLE,
};

pub const D3D11_AUTHENTICATED_CONFIGURE_SHARED_RESOURCE_INPUT = extern struct {
    Parameters: D3D11_AUTHENTICATED_CONFIGURE_INPUT,
    ProcessType: D3D11_AUTHENTICATED_PROCESS_IDENTIFIER_TYPE,
    ProcessHandle: HANDLE,
    AllowAccess: BOOL,
};

pub const D3D11_AUTHENTICATED_CONFIGURE_ACCESSIBLE_ENCRYPTION_INPUT = extern struct {
    Parameters: D3D11_AUTHENTICATED_CONFIGURE_INPUT,
    EncryptionGuid: Guid,
};

const IID_ID3D11CryptoSession_Value = @import("../zig.zig").Guid.initString("9B32F9AD-BDCC-40A6-A39D-D5C865845720");
pub const IID_ID3D11CryptoSession = &IID_ID3D11CryptoSession_Value;
pub const ID3D11CryptoSession = extern struct {
    pub const VTable = extern struct {
        base: ID3D11DeviceChild.VTable,
        GetCryptoType: fn(
            self: *const ID3D11CryptoSession,
            pCryptoType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetDecoderProfile: fn(
            self: *const ID3D11CryptoSession,
            pDecoderProfile: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetCertificateSize: fn(
            self: *const ID3D11CryptoSession,
            pCertificateSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCertificate: fn(
            self: *const ID3D11CryptoSession,
            CertificateSize: u32,
            pCertificate: [*:0]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCryptoSessionHandle: fn(
            self: *const ID3D11CryptoSession,
            pCryptoSessionHandle: *HANDLE,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11CryptoSession_GetCryptoType(self: *const T, pCryptoType: *Guid) callconv(.Inline) void {
            return @ptrCast(*const ID3D11CryptoSession.VTable, self.vtable).GetCryptoType(@ptrCast(*const ID3D11CryptoSession, self), pCryptoType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11CryptoSession_GetDecoderProfile(self: *const T, pDecoderProfile: *Guid) callconv(.Inline) void {
            return @ptrCast(*const ID3D11CryptoSession.VTable, self.vtable).GetDecoderProfile(@ptrCast(*const ID3D11CryptoSession, self), pDecoderProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11CryptoSession_GetCertificateSize(self: *const T, pCertificateSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11CryptoSession.VTable, self.vtable).GetCertificateSize(@ptrCast(*const ID3D11CryptoSession, self), pCertificateSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11CryptoSession_GetCertificate(self: *const T, CertificateSize: u32, pCertificate: [*:0]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11CryptoSession.VTable, self.vtable).GetCertificate(@ptrCast(*const ID3D11CryptoSession, self), CertificateSize, pCertificate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11CryptoSession_GetCryptoSessionHandle(self: *const T, pCryptoSessionHandle: *HANDLE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11CryptoSession.VTable, self.vtable).GetCryptoSessionHandle(@ptrCast(*const ID3D11CryptoSession, self), pCryptoSessionHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_VDOV_DIMENSION = extern enum(i32) {
    UNKNOWN = 0,
    TEXTURE2D = 1,
};
pub const D3D11_VDOV_DIMENSION_UNKNOWN = D3D11_VDOV_DIMENSION.UNKNOWN;
pub const D3D11_VDOV_DIMENSION_TEXTURE2D = D3D11_VDOV_DIMENSION.TEXTURE2D;

pub const D3D11_TEX2D_VDOV = extern struct {
    ArraySlice: u32,
};

pub const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC = extern struct {
    DecodeProfile: Guid,
    ViewDimension: D3D11_VDOV_DIMENSION,
    Anonymous: D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

const IID_ID3D11VideoDecoderOutputView_Value = @import("../zig.zig").Guid.initString("C2931AEA-2A85-4F20-860F-FBA1FD256E18");
pub const IID_ID3D11VideoDecoderOutputView = &IID_ID3D11VideoDecoderOutputView_Value;
pub const ID3D11VideoDecoderOutputView = extern struct {
    pub const VTable = extern struct {
        base: ID3D11View.VTable,
        GetDesc: fn(
            self: *const ID3D11VideoDecoderOutputView,
            pDesc: *D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11View.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDecoderOutputView_GetDesc(self: *const T, pDesc: *D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoDecoderOutputView.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D11VideoDecoderOutputView, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_VPIV_DIMENSION = extern enum(i32) {
    UNKNOWN = 0,
    TEXTURE2D = 1,
};
pub const D3D11_VPIV_DIMENSION_UNKNOWN = D3D11_VPIV_DIMENSION.UNKNOWN;
pub const D3D11_VPIV_DIMENSION_TEXTURE2D = D3D11_VPIV_DIMENSION.TEXTURE2D;

pub const D3D11_TEX2D_VPIV = extern struct {
    MipSlice: u32,
    ArraySlice: u32,
};

pub const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC = extern struct {
    FourCC: u32,
    ViewDimension: D3D11_VPIV_DIMENSION,
    Anonymous: D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

const IID_ID3D11VideoProcessorInputView_Value = @import("../zig.zig").Guid.initString("11EC5A5F-51DC-4945-AB34-6E8C21300EA5");
pub const IID_ID3D11VideoProcessorInputView = &IID_ID3D11VideoProcessorInputView_Value;
pub const ID3D11VideoProcessorInputView = extern struct {
    pub const VTable = extern struct {
        base: ID3D11View.VTable,
        GetDesc: fn(
            self: *const ID3D11VideoProcessorInputView,
            pDesc: *D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11View.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessorInputView_GetDesc(self: *const T, pDesc: *D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoProcessorInputView.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D11VideoProcessorInputView, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_VPOV_DIMENSION = extern enum(i32) {
    UNKNOWN = 0,
    TEXTURE2D = 1,
    TEXTURE2DARRAY = 2,
};
pub const D3D11_VPOV_DIMENSION_UNKNOWN = D3D11_VPOV_DIMENSION.UNKNOWN;
pub const D3D11_VPOV_DIMENSION_TEXTURE2D = D3D11_VPOV_DIMENSION.TEXTURE2D;
pub const D3D11_VPOV_DIMENSION_TEXTURE2DARRAY = D3D11_VPOV_DIMENSION.TEXTURE2DARRAY;

pub const D3D11_TEX2D_VPOV = extern struct {
    MipSlice: u32,
};

pub const D3D11_TEX2D_ARRAY_VPOV = extern struct {
    MipSlice: u32,
    FirstArraySlice: u32,
    ArraySize: u32,
};

pub const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC = extern struct {
    ViewDimension: D3D11_VPOV_DIMENSION,
    Anonymous: D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

const IID_ID3D11VideoProcessorOutputView_Value = @import("../zig.zig").Guid.initString("A048285E-25A9-4527-BD93-D68B68C44254");
pub const IID_ID3D11VideoProcessorOutputView = &IID_ID3D11VideoProcessorOutputView_Value;
pub const ID3D11VideoProcessorOutputView = extern struct {
    pub const VTable = extern struct {
        base: ID3D11View.VTable,
        GetDesc: fn(
            self: *const ID3D11VideoProcessorOutputView,
            pDesc: *D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11View.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessorOutputView_GetDesc(self: *const T, pDesc: *D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoProcessorOutputView.VTable, self.vtable).GetDesc(@ptrCast(*const ID3D11VideoProcessorOutputView, self), pDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D11VideoContext_Value = @import("../zig.zig").Guid.initString("61F21C45-3C0E-4A74-9CEA-67100D9AD5E4");
pub const IID_ID3D11VideoContext = &IID_ID3D11VideoContext_Value;
pub const ID3D11VideoContext = extern struct {
    pub const VTable = extern struct {
        base: ID3D11DeviceChild.VTable,
        GetDecoderBuffer: fn(
            self: *const ID3D11VideoContext,
            pDecoder: *ID3D11VideoDecoder,
            Type: D3D11_VIDEO_DECODER_BUFFER_TYPE,
            pBufferSize: *u32,
            ppBuffer: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseDecoderBuffer: fn(
            self: *const ID3D11VideoContext,
            pDecoder: *ID3D11VideoDecoder,
            Type: D3D11_VIDEO_DECODER_BUFFER_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecoderBeginFrame: fn(
            self: *const ID3D11VideoContext,
            pDecoder: *ID3D11VideoDecoder,
            pView: *ID3D11VideoDecoderOutputView,
            ContentKeySize: u32,
            pContentKey: ?[*]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecoderEndFrame: fn(
            self: *const ID3D11VideoContext,
            pDecoder: *ID3D11VideoDecoder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SubmitDecoderBuffers: fn(
            self: *const ID3D11VideoContext,
            pDecoder: *ID3D11VideoDecoder,
            NumBuffers: u32,
            pBufferDesc: [*]const D3D11_VIDEO_DECODER_BUFFER_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecoderExtension: fn(
            self: *const ID3D11VideoContext,
            pDecoder: *ID3D11VideoDecoder,
            pExtensionData: *const D3D11_VIDEO_DECODER_EXTENSION,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        VideoProcessorSetOutputTargetRect: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            Enable: BOOL,
            pRect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetOutputBackgroundColor: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            YCbCr: BOOL,
            pColor: *const D3D11_VIDEO_COLOR,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetOutputColorSpace: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            pColorSpace: *const D3D11_VIDEO_PROCESSOR_COLOR_SPACE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetOutputAlphaFillMode: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            AlphaFillMode: D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE,
            StreamIndex: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetOutputConstriction: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            Enable: BOOL,
            Size: SIZE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetOutputStereoMode: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            Enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetOutputExtension: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            pExtensionGuid: *const Guid,
            DataSize: u32,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        VideoProcessorGetOutputTargetRect: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            Enabled: *BOOL,
            pRect: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetOutputBackgroundColor: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            pYCbCr: *BOOL,
            pColor: *D3D11_VIDEO_COLOR,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetOutputColorSpace: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            pColorSpace: *D3D11_VIDEO_PROCESSOR_COLOR_SPACE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetOutputAlphaFillMode: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            pAlphaFillMode: *D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE,
            pStreamIndex: *u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetOutputConstriction: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            pEnabled: *BOOL,
            pSize: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetOutputStereoMode: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            pEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetOutputExtension: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            pExtensionGuid: *const Guid,
            DataSize: u32,
            pData: [*]u8,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        VideoProcessorSetStreamFrameFormat: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            FrameFormat: D3D11_VIDEO_FRAME_FORMAT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamColorSpace: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pColorSpace: *const D3D11_VIDEO_PROCESSOR_COLOR_SPACE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamOutputRate: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            OutputRate: D3D11_VIDEO_PROCESSOR_OUTPUT_RATE,
            RepeatFrame: BOOL,
            pCustomRate: ?*const DXGI_RATIONAL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamSourceRect: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Enable: BOOL,
            pRect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamDestRect: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Enable: BOOL,
            pRect: ?*const RECT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamAlpha: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Enable: BOOL,
            Alpha: f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamPalette: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Count: u32,
            pEntries: ?[*]const u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamPixelAspectRatio: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Enable: BOOL,
            pSourceAspectRatio: ?*const DXGI_RATIONAL,
            pDestinationAspectRatio: ?*const DXGI_RATIONAL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamLumaKey: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Enable: BOOL,
            Lower: f32,
            Upper: f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamStereoFormat: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Enable: BOOL,
            Format: D3D11_VIDEO_PROCESSOR_STEREO_FORMAT,
            LeftViewFrame0: BOOL,
            BaseViewFrame0: BOOL,
            FlipMode: D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE,
            MonoOffset: i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamAutoProcessingMode: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Enable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamFilter: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Filter: D3D11_VIDEO_PROCESSOR_FILTER,
            Enable: BOOL,
            Level: i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamExtension: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pExtensionGuid: *const Guid,
            DataSize: u32,
            pData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        VideoProcessorGetStreamFrameFormat: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pFrameFormat: *D3D11_VIDEO_FRAME_FORMAT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamColorSpace: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pColorSpace: *D3D11_VIDEO_PROCESSOR_COLOR_SPACE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamOutputRate: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pOutputRate: *D3D11_VIDEO_PROCESSOR_OUTPUT_RATE,
            pRepeatFrame: *BOOL,
            pCustomRate: *DXGI_RATIONAL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamSourceRect: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pEnabled: *BOOL,
            pRect: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamDestRect: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pEnabled: *BOOL,
            pRect: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamAlpha: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pEnabled: *BOOL,
            pAlpha: *f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamPalette: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Count: u32,
            pEntries: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamPixelAspectRatio: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pEnabled: *BOOL,
            pSourceAspectRatio: *DXGI_RATIONAL,
            pDestinationAspectRatio: *DXGI_RATIONAL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamLumaKey: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pEnabled: *BOOL,
            pLower: *f32,
            pUpper: *f32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamStereoFormat: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pEnable: *BOOL,
            pFormat: *D3D11_VIDEO_PROCESSOR_STEREO_FORMAT,
            pLeftViewFrame0: *BOOL,
            pBaseViewFrame0: *BOOL,
            pFlipMode: *D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE,
            MonoOffset: *i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamAutoProcessingMode: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamFilter: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Filter: D3D11_VIDEO_PROCESSOR_FILTER,
            pEnabled: *BOOL,
            pLevel: *i32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamExtension: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pExtensionGuid: *const Guid,
            DataSize: u32,
            pData: [*]u8,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        VideoProcessorBlt: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            pView: *ID3D11VideoProcessorOutputView,
            OutputFrame: u32,
            StreamCount: u32,
            pStreams: [*]const D3D11_VIDEO_PROCESSOR_STREAM,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NegotiateCryptoSessionKeyExchange: fn(
            self: *const ID3D11VideoContext,
            pCryptoSession: *ID3D11CryptoSession,
            DataSize: u32,
            pData: [*]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncryptionBlt: fn(
            self: *const ID3D11VideoContext,
            pCryptoSession: *ID3D11CryptoSession,
            pSrcSurface: *ID3D11Texture2D,
            pDstSurface: *ID3D11Texture2D,
            IVSize: u32,
            pIV: ?[*]u8,
        ) callconv(@import("std").os.windows.WINAPI) void,
        DecryptionBlt: fn(
            self: *const ID3D11VideoContext,
            pCryptoSession: *ID3D11CryptoSession,
            pSrcSurface: *ID3D11Texture2D,
            pDstSurface: *ID3D11Texture2D,
            pEncryptedBlockInfo: ?*D3D11_ENCRYPTED_BLOCK_INFO,
            ContentKeySize: u32,
            pContentKey: ?[*]const u8,
            IVSize: u32,
            pIV: ?[*]u8,
        ) callconv(@import("std").os.windows.WINAPI) void,
        StartSessionKeyRefresh: fn(
            self: *const ID3D11VideoContext,
            pCryptoSession: *ID3D11CryptoSession,
            RandomNumberSize: u32,
            pRandomNumber: [*]u8,
        ) callconv(@import("std").os.windows.WINAPI) void,
        FinishSessionKeyRefresh: fn(
            self: *const ID3D11VideoContext,
            pCryptoSession: *ID3D11CryptoSession,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetEncryptionBltKey: fn(
            self: *const ID3D11VideoContext,
            pCryptoSession: *ID3D11CryptoSession,
            KeySize: u32,
            pReadbackKey: [*]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NegotiateAuthenticatedChannelKeyExchange: fn(
            self: *const ID3D11VideoContext,
            pChannel: *ID3D11AuthenticatedChannel,
            DataSize: u32,
            pData: [*]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAuthenticatedChannel: fn(
            self: *const ID3D11VideoContext,
            pChannel: *ID3D11AuthenticatedChannel,
            InputSize: u32,
            pInput: [*]const u8,
            OutputSize: u32,
            pOutput: [*]u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConfigureAuthenticatedChannel: fn(
            self: *const ID3D11VideoContext,
            pChannel: *ID3D11AuthenticatedChannel,
            InputSize: u32,
            pInput: [*]const u8,
            pOutput: *D3D11_AUTHENTICATED_CONFIGURE_OUTPUT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VideoProcessorSetStreamRotation: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Enable: BOOL,
            Rotation: D3D11_VIDEO_PROCESSOR_ROTATION,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamRotation: fn(
            self: *const ID3D11VideoContext,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pEnable: *BOOL,
            pRotation: *D3D11_VIDEO_PROCESSOR_ROTATION,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11DeviceChild.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_GetDecoderBuffer(self: *const T, pDecoder: *ID3D11VideoDecoder, Type: D3D11_VIDEO_DECODER_BUFFER_TYPE, pBufferSize: *u32, ppBuffer: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).GetDecoderBuffer(@ptrCast(*const ID3D11VideoContext, self), pDecoder, Type, pBufferSize, ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_ReleaseDecoderBuffer(self: *const T, pDecoder: *ID3D11VideoDecoder, Type: D3D11_VIDEO_DECODER_BUFFER_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).ReleaseDecoderBuffer(@ptrCast(*const ID3D11VideoContext, self), pDecoder, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_DecoderBeginFrame(self: *const T, pDecoder: *ID3D11VideoDecoder, pView: *ID3D11VideoDecoderOutputView, ContentKeySize: u32, pContentKey: ?[*]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).DecoderBeginFrame(@ptrCast(*const ID3D11VideoContext, self), pDecoder, pView, ContentKeySize, pContentKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_DecoderEndFrame(self: *const T, pDecoder: *ID3D11VideoDecoder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).DecoderEndFrame(@ptrCast(*const ID3D11VideoContext, self), pDecoder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_SubmitDecoderBuffers(self: *const T, pDecoder: *ID3D11VideoDecoder, NumBuffers: u32, pBufferDesc: [*]const D3D11_VIDEO_DECODER_BUFFER_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).SubmitDecoderBuffers(@ptrCast(*const ID3D11VideoContext, self), pDecoder, NumBuffers, pBufferDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_DecoderExtension(self: *const T, pDecoder: *ID3D11VideoDecoder, pExtensionData: *const D3D11_VIDEO_DECODER_EXTENSION) callconv(.Inline) i32 {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).DecoderExtension(@ptrCast(*const ID3D11VideoContext, self), pDecoder, pExtensionData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetOutputTargetRect(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, Enable: BOOL, pRect: ?*const RECT) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetOutputTargetRect(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, Enable, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetOutputBackgroundColor(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, YCbCr: BOOL, pColor: *const D3D11_VIDEO_COLOR) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetOutputBackgroundColor(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, YCbCr, pColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetOutputColorSpace(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pColorSpace: *const D3D11_VIDEO_PROCESSOR_COLOR_SPACE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetOutputColorSpace(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, pColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetOutputAlphaFillMode(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, AlphaFillMode: D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE, StreamIndex: u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetOutputAlphaFillMode(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, AlphaFillMode, StreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetOutputConstriction(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, Enable: BOOL, Size: SIZE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetOutputConstriction(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, Enable, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetOutputStereoMode(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, Enable: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetOutputStereoMode(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, Enable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetOutputExtension(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pExtensionGuid: *const Guid, DataSize: u32, pData: *c_void) callconv(.Inline) i32 {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetOutputExtension(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, pExtensionGuid, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetOutputTargetRect(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, Enabled: *BOOL, pRect: *RECT) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetOutputTargetRect(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, Enabled, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetOutputBackgroundColor(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pYCbCr: *BOOL, pColor: *D3D11_VIDEO_COLOR) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetOutputBackgroundColor(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, pYCbCr, pColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetOutputColorSpace(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pColorSpace: *D3D11_VIDEO_PROCESSOR_COLOR_SPACE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetOutputColorSpace(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, pColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetOutputAlphaFillMode(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pAlphaFillMode: *D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE, pStreamIndex: *u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetOutputAlphaFillMode(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, pAlphaFillMode, pStreamIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetOutputConstriction(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pEnabled: *BOOL, pSize: *SIZE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetOutputConstriction(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, pEnabled, pSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetOutputStereoMode(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pEnabled: *BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetOutputStereoMode(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, pEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetOutputExtension(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pExtensionGuid: *const Guid, DataSize: u32, pData: [*]u8) callconv(.Inline) i32 {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetOutputExtension(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, pExtensionGuid, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamFrameFormat(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, FrameFormat: D3D11_VIDEO_FRAME_FORMAT) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamFrameFormat(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, FrameFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamColorSpace(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pColorSpace: *const D3D11_VIDEO_PROCESSOR_COLOR_SPACE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamColorSpace(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamOutputRate(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, OutputRate: D3D11_VIDEO_PROCESSOR_OUTPUT_RATE, RepeatFrame: BOOL, pCustomRate: ?*const DXGI_RATIONAL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamOutputRate(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, OutputRate, RepeatFrame, pCustomRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamSourceRect(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Enable: BOOL, pRect: ?*const RECT) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamSourceRect(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Enable, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamDestRect(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Enable: BOOL, pRect: ?*const RECT) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamDestRect(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Enable, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamAlpha(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Enable: BOOL, Alpha: f32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamAlpha(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Enable, Alpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamPalette(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Count: u32, pEntries: ?[*]const u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamPalette(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Count, pEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamPixelAspectRatio(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Enable: BOOL, pSourceAspectRatio: ?*const DXGI_RATIONAL, pDestinationAspectRatio: ?*const DXGI_RATIONAL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamPixelAspectRatio(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Enable, pSourceAspectRatio, pDestinationAspectRatio);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamLumaKey(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Enable: BOOL, Lower: f32, Upper: f32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamLumaKey(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Enable, Lower, Upper);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamStereoFormat(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Enable: BOOL, Format: D3D11_VIDEO_PROCESSOR_STEREO_FORMAT, LeftViewFrame0: BOOL, BaseViewFrame0: BOOL, FlipMode: D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE, MonoOffset: i32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamStereoFormat(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Enable, Format, LeftViewFrame0, BaseViewFrame0, FlipMode, MonoOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamAutoProcessingMode(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Enable: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamAutoProcessingMode(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Enable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamFilter(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Filter: D3D11_VIDEO_PROCESSOR_FILTER, Enable: BOOL, Level: i32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamFilter(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Filter, Enable, Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamExtension(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pExtensionGuid: *const Guid, DataSize: u32, pData: *c_void) callconv(.Inline) i32 {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamExtension(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pExtensionGuid, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamFrameFormat(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pFrameFormat: *D3D11_VIDEO_FRAME_FORMAT) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamFrameFormat(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pFrameFormat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamColorSpace(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pColorSpace: *D3D11_VIDEO_PROCESSOR_COLOR_SPACE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamColorSpace(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamOutputRate(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pOutputRate: *D3D11_VIDEO_PROCESSOR_OUTPUT_RATE, pRepeatFrame: *BOOL, pCustomRate: *DXGI_RATIONAL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamOutputRate(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pOutputRate, pRepeatFrame, pCustomRate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamSourceRect(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pEnabled: *BOOL, pRect: *RECT) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamSourceRect(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pEnabled, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamDestRect(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pEnabled: *BOOL, pRect: *RECT) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamDestRect(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pEnabled, pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamAlpha(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pEnabled: *BOOL, pAlpha: *f32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamAlpha(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pEnabled, pAlpha);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamPalette(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Count: u32, pEntries: [*]u32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamPalette(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Count, pEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamPixelAspectRatio(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pEnabled: *BOOL, pSourceAspectRatio: *DXGI_RATIONAL, pDestinationAspectRatio: *DXGI_RATIONAL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamPixelAspectRatio(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pEnabled, pSourceAspectRatio, pDestinationAspectRatio);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamLumaKey(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pEnabled: *BOOL, pLower: *f32, pUpper: *f32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamLumaKey(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pEnabled, pLower, pUpper);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamStereoFormat(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pEnable: *BOOL, pFormat: *D3D11_VIDEO_PROCESSOR_STEREO_FORMAT, pLeftViewFrame0: *BOOL, pBaseViewFrame0: *BOOL, pFlipMode: *D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE, MonoOffset: *i32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamStereoFormat(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pEnable, pFormat, pLeftViewFrame0, pBaseViewFrame0, pFlipMode, MonoOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamAutoProcessingMode(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pEnabled: *BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamAutoProcessingMode(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamFilter(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Filter: D3D11_VIDEO_PROCESSOR_FILTER, pEnabled: *BOOL, pLevel: *i32) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamFilter(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Filter, pEnabled, pLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamExtension(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pExtensionGuid: *const Guid, DataSize: u32, pData: [*]u8) callconv(.Inline) i32 {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamExtension(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pExtensionGuid, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorBlt(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pView: *ID3D11VideoProcessorOutputView, OutputFrame: u32, StreamCount: u32, pStreams: [*]const D3D11_VIDEO_PROCESSOR_STREAM) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorBlt(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, pView, OutputFrame, StreamCount, pStreams);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_NegotiateCryptoSessionKeyExchange(self: *const T, pCryptoSession: *ID3D11CryptoSession, DataSize: u32, pData: [*]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).NegotiateCryptoSessionKeyExchange(@ptrCast(*const ID3D11VideoContext, self), pCryptoSession, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_EncryptionBlt(self: *const T, pCryptoSession: *ID3D11CryptoSession, pSrcSurface: *ID3D11Texture2D, pDstSurface: *ID3D11Texture2D, IVSize: u32, pIV: ?[*]u8) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).EncryptionBlt(@ptrCast(*const ID3D11VideoContext, self), pCryptoSession, pSrcSurface, pDstSurface, IVSize, pIV);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_DecryptionBlt(self: *const T, pCryptoSession: *ID3D11CryptoSession, pSrcSurface: *ID3D11Texture2D, pDstSurface: *ID3D11Texture2D, pEncryptedBlockInfo: ?*D3D11_ENCRYPTED_BLOCK_INFO, ContentKeySize: u32, pContentKey: ?[*]const u8, IVSize: u32, pIV: ?[*]u8) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).DecryptionBlt(@ptrCast(*const ID3D11VideoContext, self), pCryptoSession, pSrcSurface, pDstSurface, pEncryptedBlockInfo, ContentKeySize, pContentKey, IVSize, pIV);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_StartSessionKeyRefresh(self: *const T, pCryptoSession: *ID3D11CryptoSession, RandomNumberSize: u32, pRandomNumber: [*]u8) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).StartSessionKeyRefresh(@ptrCast(*const ID3D11VideoContext, self), pCryptoSession, RandomNumberSize, pRandomNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_FinishSessionKeyRefresh(self: *const T, pCryptoSession: *ID3D11CryptoSession) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).FinishSessionKeyRefresh(@ptrCast(*const ID3D11VideoContext, self), pCryptoSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_GetEncryptionBltKey(self: *const T, pCryptoSession: *ID3D11CryptoSession, KeySize: u32, pReadbackKey: [*]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).GetEncryptionBltKey(@ptrCast(*const ID3D11VideoContext, self), pCryptoSession, KeySize, pReadbackKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_NegotiateAuthenticatedChannelKeyExchange(self: *const T, pChannel: *ID3D11AuthenticatedChannel, DataSize: u32, pData: [*]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).NegotiateAuthenticatedChannelKeyExchange(@ptrCast(*const ID3D11VideoContext, self), pChannel, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_QueryAuthenticatedChannel(self: *const T, pChannel: *ID3D11AuthenticatedChannel, InputSize: u32, pInput: [*]const u8, OutputSize: u32, pOutput: [*]u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).QueryAuthenticatedChannel(@ptrCast(*const ID3D11VideoContext, self), pChannel, InputSize, pInput, OutputSize, pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_ConfigureAuthenticatedChannel(self: *const T, pChannel: *ID3D11AuthenticatedChannel, InputSize: u32, pInput: [*]const u8, pOutput: *D3D11_AUTHENTICATED_CONFIGURE_OUTPUT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).ConfigureAuthenticatedChannel(@ptrCast(*const ID3D11VideoContext, self), pChannel, InputSize, pInput, pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorSetStreamRotation(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Enable: BOOL, Rotation: D3D11_VIDEO_PROCESSOR_ROTATION) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorSetStreamRotation(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, Enable, Rotation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext_VideoProcessorGetStreamRotation(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pEnable: *BOOL, pRotation: *D3D11_VIDEO_PROCESSOR_ROTATION) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext.VTable, self.vtable).VideoProcessorGetStreamRotation(@ptrCast(*const ID3D11VideoContext, self), pVideoProcessor, StreamIndex, pEnable, pRotation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D11VideoDevice_Value = @import("../zig.zig").Guid.initString("10EC4D5B-975A-4689-B9E4-D0AAC30FE333");
pub const IID_ID3D11VideoDevice = &IID_ID3D11VideoDevice_Value;
pub const ID3D11VideoDevice = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateVideoDecoder: fn(
            self: *const ID3D11VideoDevice,
            pVideoDesc: *const D3D11_VIDEO_DECODER_DESC,
            pConfig: *const D3D11_VIDEO_DECODER_CONFIG,
            ppDecoder: **ID3D11VideoDecoder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoProcessor: fn(
            self: *const ID3D11VideoDevice,
            pEnum: *ID3D11VideoProcessorEnumerator,
            RateConversionIndex: u32,
            ppVideoProcessor: **ID3D11VideoProcessor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAuthenticatedChannel: fn(
            self: *const ID3D11VideoDevice,
            ChannelType: D3D11_AUTHENTICATED_CHANNEL_TYPE,
            ppAuthenticatedChannel: **ID3D11AuthenticatedChannel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateCryptoSession: fn(
            self: *const ID3D11VideoDevice,
            pCryptoType: *const Guid,
            pDecoderProfile: ?*const Guid,
            pKeyExchangeType: *const Guid,
            ppCryptoSession: **ID3D11CryptoSession,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoDecoderOutputView: fn(
            self: *const ID3D11VideoDevice,
            pResource: *ID3D11Resource,
            pDesc: *const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC,
            ppVDOVView: ?*?*ID3D11VideoDecoderOutputView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoProcessorInputView: fn(
            self: *const ID3D11VideoDevice,
            pResource: *ID3D11Resource,
            pEnum: *ID3D11VideoProcessorEnumerator,
            pDesc: *const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC,
            ppVPIView: ?*?*ID3D11VideoProcessorInputView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoProcessorOutputView: fn(
            self: *const ID3D11VideoDevice,
            pResource: *ID3D11Resource,
            pEnum: *ID3D11VideoProcessorEnumerator,
            pDesc: *const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC,
            ppVPOView: ?*?*ID3D11VideoProcessorOutputView,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateVideoProcessorEnumerator: fn(
            self: *const ID3D11VideoDevice,
            pDesc: *const D3D11_VIDEO_PROCESSOR_CONTENT_DESC,
            ppEnum: **ID3D11VideoProcessorEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoDecoderProfileCount: fn(
            self: *const ID3D11VideoDevice,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetVideoDecoderProfile: fn(
            self: *const ID3D11VideoDevice,
            Index: u32,
            pDecoderProfile: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckVideoDecoderFormat: fn(
            self: *const ID3D11VideoDevice,
            pDecoderProfile: *const Guid,
            Format: DXGI_FORMAT,
            pSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoDecoderConfigCount: fn(
            self: *const ID3D11VideoDevice,
            pDesc: *const D3D11_VIDEO_DECODER_DESC,
            pCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoDecoderConfig: fn(
            self: *const ID3D11VideoDevice,
            pDesc: *const D3D11_VIDEO_DECODER_DESC,
            Index: u32,
            pConfig: *D3D11_VIDEO_DECODER_CONFIG,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContentProtectionCaps: fn(
            self: *const ID3D11VideoDevice,
            pCryptoType: ?*const Guid,
            pDecoderProfile: ?*const Guid,
            pCaps: *D3D11_VIDEO_CONTENT_PROTECTION_CAPS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckCryptoKeyExchange: fn(
            self: *const ID3D11VideoDevice,
            pCryptoType: *const Guid,
            pDecoderProfile: ?*const Guid,
            Index: u32,
            pKeyExchangeType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPrivateData: fn(
            self: *const ID3D11VideoDevice,
            guid: *const Guid,
            DataSize: u32,
            pData: ?[*]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPrivateDataInterface: fn(
            self: *const ID3D11VideoDevice,
            guid: *const Guid,
            pData: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CreateVideoDecoder(self: *const T, pVideoDesc: *const D3D11_VIDEO_DECODER_DESC, pConfig: *const D3D11_VIDEO_DECODER_CONFIG, ppDecoder: **ID3D11VideoDecoder) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CreateVideoDecoder(@ptrCast(*const ID3D11VideoDevice, self), pVideoDesc, pConfig, ppDecoder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CreateVideoProcessor(self: *const T, pEnum: *ID3D11VideoProcessorEnumerator, RateConversionIndex: u32, ppVideoProcessor: **ID3D11VideoProcessor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CreateVideoProcessor(@ptrCast(*const ID3D11VideoDevice, self), pEnum, RateConversionIndex, ppVideoProcessor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CreateAuthenticatedChannel(self: *const T, ChannelType: D3D11_AUTHENTICATED_CHANNEL_TYPE, ppAuthenticatedChannel: **ID3D11AuthenticatedChannel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CreateAuthenticatedChannel(@ptrCast(*const ID3D11VideoDevice, self), ChannelType, ppAuthenticatedChannel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CreateCryptoSession(self: *const T, pCryptoType: *const Guid, pDecoderProfile: ?*const Guid, pKeyExchangeType: *const Guid, ppCryptoSession: **ID3D11CryptoSession) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CreateCryptoSession(@ptrCast(*const ID3D11VideoDevice, self), pCryptoType, pDecoderProfile, pKeyExchangeType, ppCryptoSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CreateVideoDecoderOutputView(self: *const T, pResource: *ID3D11Resource, pDesc: *const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC, ppVDOVView: ?*?*ID3D11VideoDecoderOutputView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CreateVideoDecoderOutputView(@ptrCast(*const ID3D11VideoDevice, self), pResource, pDesc, ppVDOVView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CreateVideoProcessorInputView(self: *const T, pResource: *ID3D11Resource, pEnum: *ID3D11VideoProcessorEnumerator, pDesc: *const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC, ppVPIView: ?*?*ID3D11VideoProcessorInputView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CreateVideoProcessorInputView(@ptrCast(*const ID3D11VideoDevice, self), pResource, pEnum, pDesc, ppVPIView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CreateVideoProcessorOutputView(self: *const T, pResource: *ID3D11Resource, pEnum: *ID3D11VideoProcessorEnumerator, pDesc: *const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC, ppVPOView: ?*?*ID3D11VideoProcessorOutputView) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CreateVideoProcessorOutputView(@ptrCast(*const ID3D11VideoDevice, self), pResource, pEnum, pDesc, ppVPOView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CreateVideoProcessorEnumerator(self: *const T, pDesc: *const D3D11_VIDEO_PROCESSOR_CONTENT_DESC, ppEnum: **ID3D11VideoProcessorEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CreateVideoProcessorEnumerator(@ptrCast(*const ID3D11VideoDevice, self), pDesc, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_GetVideoDecoderProfileCount(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).GetVideoDecoderProfileCount(@ptrCast(*const ID3D11VideoDevice, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_GetVideoDecoderProfile(self: *const T, Index: u32, pDecoderProfile: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).GetVideoDecoderProfile(@ptrCast(*const ID3D11VideoDevice, self), Index, pDecoderProfile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CheckVideoDecoderFormat(self: *const T, pDecoderProfile: *const Guid, Format: DXGI_FORMAT, pSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CheckVideoDecoderFormat(@ptrCast(*const ID3D11VideoDevice, self), pDecoderProfile, Format, pSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_GetVideoDecoderConfigCount(self: *const T, pDesc: *const D3D11_VIDEO_DECODER_DESC, pCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).GetVideoDecoderConfigCount(@ptrCast(*const ID3D11VideoDevice, self), pDesc, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_GetVideoDecoderConfig(self: *const T, pDesc: *const D3D11_VIDEO_DECODER_DESC, Index: u32, pConfig: *D3D11_VIDEO_DECODER_CONFIG) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).GetVideoDecoderConfig(@ptrCast(*const ID3D11VideoDevice, self), pDesc, Index, pConfig);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_GetContentProtectionCaps(self: *const T, pCryptoType: ?*const Guid, pDecoderProfile: ?*const Guid, pCaps: *D3D11_VIDEO_CONTENT_PROTECTION_CAPS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).GetContentProtectionCaps(@ptrCast(*const ID3D11VideoDevice, self), pCryptoType, pDecoderProfile, pCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_CheckCryptoKeyExchange(self: *const T, pCryptoType: *const Guid, pDecoderProfile: ?*const Guid, Index: u32, pKeyExchangeType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).CheckCryptoKeyExchange(@ptrCast(*const ID3D11VideoDevice, self), pCryptoType, pDecoderProfile, Index, pKeyExchangeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_SetPrivateData(self: *const T, guid: *const Guid, DataSize: u32, pData: ?[*]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).SetPrivateData(@ptrCast(*const ID3D11VideoDevice, self), guid, DataSize, pData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice_SetPrivateDataInterface(self: *const T, guid: *const Guid, pData: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice.VTable, self.vtable).SetPrivateDataInterface(@ptrCast(*const ID3D11VideoDevice, self), guid, pData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_VIDEO_DECODER_SUB_SAMPLE_MAPPING_BLOCK = extern struct {
    ClearSize: u32,
    EncryptedSize: u32,
};

pub const D3D11_VIDEO_DECODER_BUFFER_DESC1 = extern struct {
    BufferType: D3D11_VIDEO_DECODER_BUFFER_TYPE,
    DataOffset: u32,
    DataSize: u32,
    pIV: *c_void,
    IVSize: u32,
    pSubSampleMappingBlock: *D3D11_VIDEO_DECODER_SUB_SAMPLE_MAPPING_BLOCK,
    SubSampleMappingCount: u32,
};

pub const D3D11_VIDEO_DECODER_BEGIN_FRAME_CRYPTO_SESSION = extern struct {
    pCryptoSession: *ID3D11CryptoSession,
    BlobSize: u32,
    pBlob: *c_void,
    pKeyInfoId: *Guid,
    PrivateDataSize: u32,
    pPrivateData: *c_void,
};

pub const D3D11_VIDEO_DECODER_CAPS = extern enum(i32) {
    DOWNSAMPLE = 1,
    NON_REAL_TIME = 2,
    DOWNSAMPLE_DYNAMIC = 4,
    DOWNSAMPLE_REQUIRED = 8,
    UNSUPPORTED = 16,
};
pub const D3D11_VIDEO_DECODER_CAPS_DOWNSAMPLE = D3D11_VIDEO_DECODER_CAPS.DOWNSAMPLE;
pub const D3D11_VIDEO_DECODER_CAPS_NON_REAL_TIME = D3D11_VIDEO_DECODER_CAPS.NON_REAL_TIME;
pub const D3D11_VIDEO_DECODER_CAPS_DOWNSAMPLE_DYNAMIC = D3D11_VIDEO_DECODER_CAPS.DOWNSAMPLE_DYNAMIC;
pub const D3D11_VIDEO_DECODER_CAPS_DOWNSAMPLE_REQUIRED = D3D11_VIDEO_DECODER_CAPS.DOWNSAMPLE_REQUIRED;
pub const D3D11_VIDEO_DECODER_CAPS_UNSUPPORTED = D3D11_VIDEO_DECODER_CAPS.UNSUPPORTED;

pub const D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINTS = extern enum(i32) {
    D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_ROTATION = 1,
    D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_RESIZE = 2,
    D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_COLOR_SPACE_CONVERSION = 4,
    D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_TRIPLE_BUFFER_OUTPUT = 8,
};
pub const D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_ROTATION = D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINTS.D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_ROTATION;
pub const D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_RESIZE = D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINTS.D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_RESIZE;
pub const D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_COLOR_SPACE_CONVERSION = D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINTS.D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_MULTIPLANE_OVERLAY_COLOR_SPACE_CONVERSION;
pub const D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_TRIPLE_BUFFER_OUTPUT = D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINTS.D3D11_VIDEO_PROCESSOR_BEHAVIOR_HINT_TRIPLE_BUFFER_OUTPUT;

pub const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT = extern struct {
    Enable: BOOL,
    Width: u32,
    Height: u32,
    Format: DXGI_FORMAT,
};

pub const D3D11_CRYPTO_SESSION_STATUS = extern enum(i32) {
    OK = 0,
    KEY_LOST = 1,
    KEY_AND_CONTENT_LOST = 2,
};
pub const D3D11_CRYPTO_SESSION_STATUS_OK = D3D11_CRYPTO_SESSION_STATUS.OK;
pub const D3D11_CRYPTO_SESSION_STATUS_KEY_LOST = D3D11_CRYPTO_SESSION_STATUS.KEY_LOST;
pub const D3D11_CRYPTO_SESSION_STATUS_KEY_AND_CONTENT_LOST = D3D11_CRYPTO_SESSION_STATUS.KEY_AND_CONTENT_LOST;

pub const D3D11_KEY_EXCHANGE_HW_PROTECTION_INPUT_DATA = extern struct {
    PrivateDataSize: u32,
    HWProtectionDataSize: u32,
    pbInput: [4]u8,
};

pub const D3D11_KEY_EXCHANGE_HW_PROTECTION_OUTPUT_DATA = extern struct {
    PrivateDataSize: u32,
    MaxHWProtectionDataSize: u32,
    HWProtectionDataSize: u32,
    TransportTime: u64,
    ExecutionTime: u64,
    pbOutput: [4]u8,
};

pub const D3D11_KEY_EXCHANGE_HW_PROTECTION_DATA = extern struct {
    HWProtectionFunctionID: u32,
    pInputData: *D3D11_KEY_EXCHANGE_HW_PROTECTION_INPUT_DATA,
    pOutputData: *D3D11_KEY_EXCHANGE_HW_PROTECTION_OUTPUT_DATA,
    Status: HRESULT,
};

pub const D3D11_VIDEO_SAMPLE_DESC = extern struct {
    Width: u32,
    Height: u32,
    Format: DXGI_FORMAT,
    ColorSpace: DXGI_COLOR_SPACE_TYPE,
};

const IID_ID3D11VideoContext1_Value = @import("../zig.zig").Guid.initString("A7F026DA-A5F8-4487-A564-15E34357651E");
pub const IID_ID3D11VideoContext1 = &IID_ID3D11VideoContext1_Value;
pub const ID3D11VideoContext1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D11VideoContext.VTable,
        SubmitDecoderBuffers1: fn(
            self: *const ID3D11VideoContext1,
            pDecoder: *ID3D11VideoDecoder,
            NumBuffers: u32,
            pBufferDesc: [*]const D3D11_VIDEO_DECODER_BUFFER_DESC1,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataForNewHardwareKey: fn(
            self: *const ID3D11VideoContext1,
            pCryptoSession: *ID3D11CryptoSession,
            PrivateInputSize: u32,
            pPrivatInputData: [*]const u8,
            pPrivateOutputData: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckCryptoSessionStatus: fn(
            self: *const ID3D11VideoContext1,
            pCryptoSession: *ID3D11CryptoSession,
            pStatus: *D3D11_CRYPTO_SESSION_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecoderEnableDownsampling: fn(
            self: *const ID3D11VideoContext1,
            pDecoder: *ID3D11VideoDecoder,
            InputColorSpace: DXGI_COLOR_SPACE_TYPE,
            pOutputDesc: *const D3D11_VIDEO_SAMPLE_DESC,
            ReferenceFrameCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecoderUpdateDownsampling: fn(
            self: *const ID3D11VideoContext1,
            pDecoder: *ID3D11VideoDecoder,
            pOutputDesc: *const D3D11_VIDEO_SAMPLE_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VideoProcessorSetOutputColorSpace1: fn(
            self: *const ID3D11VideoContext1,
            pVideoProcessor: *ID3D11VideoProcessor,
            ColorSpace: DXGI_COLOR_SPACE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetOutputShaderUsage: fn(
            self: *const ID3D11VideoContext1,
            pVideoProcessor: *ID3D11VideoProcessor,
            ShaderUsage: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetOutputColorSpace1: fn(
            self: *const ID3D11VideoContext1,
            pVideoProcessor: *ID3D11VideoProcessor,
            pColorSpace: *DXGI_COLOR_SPACE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetOutputShaderUsage: fn(
            self: *const ID3D11VideoContext1,
            pVideoProcessor: *ID3D11VideoProcessor,
            pShaderUsage: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamColorSpace1: fn(
            self: *const ID3D11VideoContext1,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            ColorSpace: DXGI_COLOR_SPACE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamMirror: fn(
            self: *const ID3D11VideoContext1,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Enable: BOOL,
            FlipHorizontal: BOOL,
            FlipVertical: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamColorSpace1: fn(
            self: *const ID3D11VideoContext1,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pColorSpace: *DXGI_COLOR_SPACE_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamMirror: fn(
            self: *const ID3D11VideoContext1,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pEnable: *BOOL,
            pFlipHorizontal: *BOOL,
            pFlipVertical: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetBehaviorHints: fn(
            self: *const ID3D11VideoContext1,
            pVideoProcessor: *ID3D11VideoProcessor,
            OutputWidth: u32,
            OutputHeight: u32,
            OutputFormat: DXGI_FORMAT,
            StreamCount: u32,
            pStreams: [*]const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT,
            pBehaviorHints: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11VideoContext.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_SubmitDecoderBuffers1(self: *const T, pDecoder: *ID3D11VideoDecoder, NumBuffers: u32, pBufferDesc: [*]const D3D11_VIDEO_DECODER_BUFFER_DESC1) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).SubmitDecoderBuffers1(@ptrCast(*const ID3D11VideoContext1, self), pDecoder, NumBuffers, pBufferDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_GetDataForNewHardwareKey(self: *const T, pCryptoSession: *ID3D11CryptoSession, PrivateInputSize: u32, pPrivatInputData: [*]const u8, pPrivateOutputData: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).GetDataForNewHardwareKey(@ptrCast(*const ID3D11VideoContext1, self), pCryptoSession, PrivateInputSize, pPrivatInputData, pPrivateOutputData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_CheckCryptoSessionStatus(self: *const T, pCryptoSession: *ID3D11CryptoSession, pStatus: *D3D11_CRYPTO_SESSION_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).CheckCryptoSessionStatus(@ptrCast(*const ID3D11VideoContext1, self), pCryptoSession, pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_DecoderEnableDownsampling(self: *const T, pDecoder: *ID3D11VideoDecoder, InputColorSpace: DXGI_COLOR_SPACE_TYPE, pOutputDesc: *const D3D11_VIDEO_SAMPLE_DESC, ReferenceFrameCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).DecoderEnableDownsampling(@ptrCast(*const ID3D11VideoContext1, self), pDecoder, InputColorSpace, pOutputDesc, ReferenceFrameCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_DecoderUpdateDownsampling(self: *const T, pDecoder: *ID3D11VideoDecoder, pOutputDesc: *const D3D11_VIDEO_SAMPLE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).DecoderUpdateDownsampling(@ptrCast(*const ID3D11VideoContext1, self), pDecoder, pOutputDesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_VideoProcessorSetOutputColorSpace1(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, ColorSpace: DXGI_COLOR_SPACE_TYPE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).VideoProcessorSetOutputColorSpace1(@ptrCast(*const ID3D11VideoContext1, self), pVideoProcessor, ColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_VideoProcessorSetOutputShaderUsage(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, ShaderUsage: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).VideoProcessorSetOutputShaderUsage(@ptrCast(*const ID3D11VideoContext1, self), pVideoProcessor, ShaderUsage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_VideoProcessorGetOutputColorSpace1(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pColorSpace: *DXGI_COLOR_SPACE_TYPE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).VideoProcessorGetOutputColorSpace1(@ptrCast(*const ID3D11VideoContext1, self), pVideoProcessor, pColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_VideoProcessorGetOutputShaderUsage(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pShaderUsage: *BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).VideoProcessorGetOutputShaderUsage(@ptrCast(*const ID3D11VideoContext1, self), pVideoProcessor, pShaderUsage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_VideoProcessorSetStreamColorSpace1(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, ColorSpace: DXGI_COLOR_SPACE_TYPE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).VideoProcessorSetStreamColorSpace1(@ptrCast(*const ID3D11VideoContext1, self), pVideoProcessor, StreamIndex, ColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_VideoProcessorSetStreamMirror(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Enable: BOOL, FlipHorizontal: BOOL, FlipVertical: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).VideoProcessorSetStreamMirror(@ptrCast(*const ID3D11VideoContext1, self), pVideoProcessor, StreamIndex, Enable, FlipHorizontal, FlipVertical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_VideoProcessorGetStreamColorSpace1(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pColorSpace: *DXGI_COLOR_SPACE_TYPE) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).VideoProcessorGetStreamColorSpace1(@ptrCast(*const ID3D11VideoContext1, self), pVideoProcessor, StreamIndex, pColorSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_VideoProcessorGetStreamMirror(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pEnable: *BOOL, pFlipHorizontal: *BOOL, pFlipVertical: *BOOL) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).VideoProcessorGetStreamMirror(@ptrCast(*const ID3D11VideoContext1, self), pVideoProcessor, StreamIndex, pEnable, pFlipHorizontal, pFlipVertical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext1_VideoProcessorGetBehaviorHints(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, OutputWidth: u32, OutputHeight: u32, OutputFormat: DXGI_FORMAT, StreamCount: u32, pStreams: [*]const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT, pBehaviorHints: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoContext1.VTable, self.vtable).VideoProcessorGetBehaviorHints(@ptrCast(*const ID3D11VideoContext1, self), pVideoProcessor, OutputWidth, OutputHeight, OutputFormat, StreamCount, pStreams, pBehaviorHints);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D11VideoDevice1_Value = @import("../zig.zig").Guid.initString("29DA1D51-1321-4454-804B-F5FC9F861F0F");
pub const IID_ID3D11VideoDevice1 = &IID_ID3D11VideoDevice1_Value;
pub const ID3D11VideoDevice1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D11VideoDevice.VTable,
        GetCryptoSessionPrivateDataSize: fn(
            self: *const ID3D11VideoDevice1,
            pCryptoType: *const Guid,
            pDecoderProfile: ?*const Guid,
            pKeyExchangeType: *const Guid,
            pPrivateInputSize: *u32,
            pPrivateOutputSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVideoDecoderCaps: fn(
            self: *const ID3D11VideoDevice1,
            pDecoderProfile: *const Guid,
            SampleWidth: u32,
            SampleHeight: u32,
            pFrameRate: *const DXGI_RATIONAL,
            BitRate: u32,
            pCryptoType: ?*const Guid,
            pDecoderCaps: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckVideoDecoderDownsampling: fn(
            self: *const ID3D11VideoDevice1,
            pInputDesc: *const D3D11_VIDEO_DECODER_DESC,
            InputColorSpace: DXGI_COLOR_SPACE_TYPE,
            pInputConfig: *const D3D11_VIDEO_DECODER_CONFIG,
            pFrameRate: *const DXGI_RATIONAL,
            pOutputDesc: *const D3D11_VIDEO_SAMPLE_DESC,
            pSupported: *BOOL,
            pRealTimeHint: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RecommendVideoDecoderDownsampleParameters: fn(
            self: *const ID3D11VideoDevice1,
            pInputDesc: *const D3D11_VIDEO_DECODER_DESC,
            InputColorSpace: DXGI_COLOR_SPACE_TYPE,
            pInputConfig: *const D3D11_VIDEO_DECODER_CONFIG,
            pFrameRate: *const DXGI_RATIONAL,
            pRecommendedOutputDesc: *D3D11_VIDEO_SAMPLE_DESC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11VideoDevice.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice1_GetCryptoSessionPrivateDataSize(self: *const T, pCryptoType: *const Guid, pDecoderProfile: ?*const Guid, pKeyExchangeType: *const Guid, pPrivateInputSize: *u32, pPrivateOutputSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice1.VTable, self.vtable).GetCryptoSessionPrivateDataSize(@ptrCast(*const ID3D11VideoDevice1, self), pCryptoType, pDecoderProfile, pKeyExchangeType, pPrivateInputSize, pPrivateOutputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice1_GetVideoDecoderCaps(self: *const T, pDecoderProfile: *const Guid, SampleWidth: u32, SampleHeight: u32, pFrameRate: *const DXGI_RATIONAL, BitRate: u32, pCryptoType: ?*const Guid, pDecoderCaps: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice1.VTable, self.vtable).GetVideoDecoderCaps(@ptrCast(*const ID3D11VideoDevice1, self), pDecoderProfile, SampleWidth, SampleHeight, pFrameRate, BitRate, pCryptoType, pDecoderCaps);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice1_CheckVideoDecoderDownsampling(self: *const T, pInputDesc: *const D3D11_VIDEO_DECODER_DESC, InputColorSpace: DXGI_COLOR_SPACE_TYPE, pInputConfig: *const D3D11_VIDEO_DECODER_CONFIG, pFrameRate: *const DXGI_RATIONAL, pOutputDesc: *const D3D11_VIDEO_SAMPLE_DESC, pSupported: *BOOL, pRealTimeHint: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice1.VTable, self.vtable).CheckVideoDecoderDownsampling(@ptrCast(*const ID3D11VideoDevice1, self), pInputDesc, InputColorSpace, pInputConfig, pFrameRate, pOutputDesc, pSupported, pRealTimeHint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoDevice1_RecommendVideoDecoderDownsampleParameters(self: *const T, pInputDesc: *const D3D11_VIDEO_DECODER_DESC, InputColorSpace: DXGI_COLOR_SPACE_TYPE, pInputConfig: *const D3D11_VIDEO_DECODER_CONFIG, pFrameRate: *const DXGI_RATIONAL, pRecommendedOutputDesc: *D3D11_VIDEO_SAMPLE_DESC) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoDevice1.VTable, self.vtable).RecommendVideoDecoderDownsampleParameters(@ptrCast(*const ID3D11VideoDevice1, self), pInputDesc, InputColorSpace, pInputConfig, pFrameRate, pRecommendedOutputDesc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D11VideoProcessorEnumerator1_Value = @import("../zig.zig").Guid.initString("465217F2-5568-43CF-B5B9-F61D54531CA1");
pub const IID_ID3D11VideoProcessorEnumerator1 = &IID_ID3D11VideoProcessorEnumerator1_Value;
pub const ID3D11VideoProcessorEnumerator1 = extern struct {
    pub const VTable = extern struct {
        base: ID3D11VideoProcessorEnumerator.VTable,
        CheckVideoProcessorFormatConversion: fn(
            self: *const ID3D11VideoProcessorEnumerator1,
            InputFormat: DXGI_FORMAT,
            InputColorSpace: DXGI_COLOR_SPACE_TYPE,
            OutputFormat: DXGI_FORMAT,
            OutputColorSpace: DXGI_COLOR_SPACE_TYPE,
            pSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11VideoProcessorEnumerator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoProcessorEnumerator1_CheckVideoProcessorFormatConversion(self: *const T, InputFormat: DXGI_FORMAT, InputColorSpace: DXGI_COLOR_SPACE_TYPE, OutputFormat: DXGI_FORMAT, OutputColorSpace: DXGI_COLOR_SPACE_TYPE, pSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ID3D11VideoProcessorEnumerator1.VTable, self.vtable).CheckVideoProcessorFormatConversion(@ptrCast(*const ID3D11VideoProcessorEnumerator1, self), InputFormat, InputColorSpace, OutputFormat, OutputColorSpace, pSupported);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ID3D11VideoContext2_Value = @import("../zig.zig").Guid.initString("C4E7374C-6243-4D1B-AE87-52B4F740E261");
pub const IID_ID3D11VideoContext2 = &IID_ID3D11VideoContext2_Value;
pub const ID3D11VideoContext2 = extern struct {
    pub const VTable = extern struct {
        base: ID3D11VideoContext1.VTable,
        VideoProcessorSetOutputHDRMetaData: fn(
            self: *const ID3D11VideoContext2,
            pVideoProcessor: *ID3D11VideoProcessor,
            Type: DXGI_HDR_METADATA_TYPE,
            Size: u32,
            pHDRMetaData: ?[*]const u8,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetOutputHDRMetaData: fn(
            self: *const ID3D11VideoContext2,
            pVideoProcessor: *ID3D11VideoProcessor,
            pType: *DXGI_HDR_METADATA_TYPE,
            Size: u32,
            pMetaData: ?[*]u8,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorSetStreamHDRMetaData: fn(
            self: *const ID3D11VideoContext2,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            Type: DXGI_HDR_METADATA_TYPE,
            Size: u32,
            pHDRMetaData: ?[*]const u8,
        ) callconv(@import("std").os.windows.WINAPI) void,
        VideoProcessorGetStreamHDRMetaData: fn(
            self: *const ID3D11VideoContext2,
            pVideoProcessor: *ID3D11VideoProcessor,
            StreamIndex: u32,
            pType: *DXGI_HDR_METADATA_TYPE,
            Size: u32,
            pMetaData: ?[*]u8,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ID3D11VideoContext1.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext2_VideoProcessorSetOutputHDRMetaData(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, Type: DXGI_HDR_METADATA_TYPE, Size: u32, pHDRMetaData: ?[*]const u8) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext2.VTable, self.vtable).VideoProcessorSetOutputHDRMetaData(@ptrCast(*const ID3D11VideoContext2, self), pVideoProcessor, Type, Size, pHDRMetaData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext2_VideoProcessorGetOutputHDRMetaData(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, pType: *DXGI_HDR_METADATA_TYPE, Size: u32, pMetaData: ?[*]u8) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext2.VTable, self.vtable).VideoProcessorGetOutputHDRMetaData(@ptrCast(*const ID3D11VideoContext2, self), pVideoProcessor, pType, Size, pMetaData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext2_VideoProcessorSetStreamHDRMetaData(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, Type: DXGI_HDR_METADATA_TYPE, Size: u32, pHDRMetaData: ?[*]const u8) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext2.VTable, self.vtable).VideoProcessorSetStreamHDRMetaData(@ptrCast(*const ID3D11VideoContext2, self), pVideoProcessor, StreamIndex, Type, Size, pHDRMetaData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ID3D11VideoContext2_VideoProcessorGetStreamHDRMetaData(self: *const T, pVideoProcessor: *ID3D11VideoProcessor, StreamIndex: u32, pType: *DXGI_HDR_METADATA_TYPE, Size: u32, pMetaData: ?[*]u8) callconv(.Inline) void {
            return @ptrCast(*const ID3D11VideoContext2.VTable, self.vtable).VideoProcessorGetStreamHDRMetaData(@ptrCast(*const ID3D11VideoContext2, self), pVideoProcessor, StreamIndex, pType, Size, pMetaData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const D3D11_FEATURE_VIDEO = extern enum(i32) {
    DECODER_HISTOGRAM = 0,
};
pub const D3D11_FEATURE_VIDEO_DECODER_HISTOGRAM = D3D11_FEATURE_VIDEO.DECODER_HISTOGRAM;


//--------------------------------------------------------------------------------
// Section: Functions (235)
//--------------------------------------------------------------------------------
pub extern "dxva2" fn DXVAHD_CreateDevice(
    pD3DDevice: *IDirect3DDevice9Ex,
    pContentDesc: *const DXVAHD_CONTENT_DESC,
    Usage: DXVAHD_DEVICE_USAGE,
    pPlugin: ?PDXVAHDSW_Plugin,
    ppDevice: **IDXVAHD_Device,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dxva2" fn DXVA2CreateDirect3DDeviceManager9(
    pResetToken: *u32,
    ppDeviceManager: **IDirect3DDeviceManager9,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dxva2" fn DXVA2CreateVideoService(
    pDD: *IDirect3DDevice9,
    riid: *const Guid,
    ppService: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dxva2" fn OPMGetVideoOutputsFromHMONITOR(
    hMonitor: HMONITOR,
    vos: OPM_VIDEO_OUTPUT_SEMANTICS,
    pulNumVideoOutputs: *u32,
    pppOPMVideoOutputArray: ***IOPMVideoOutput,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dxva2" fn OPMGetVideoOutputForTarget(
    pAdapterLuid: *LUID,
    VidPnTarget: u32,
    vos: OPM_VIDEO_OUTPUT_SEMANTICS,
    ppOPMVideoOutput: **IOPMVideoOutput,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dxva2" fn OPMGetVideoOutputsFromIDirect3DDevice9Object(
    pDirect3DDevice9: *IDirect3DDevice9,
    vos: OPM_VIDEO_OUTPUT_SEMANTICS,
    pulNumVideoOutputs: *u32,
    pppOPMVideoOutputArray: ***IOPMVideoOutput,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFSerializeAttributesToStream(
    pAttr: *IMFAttributes,
    dwOptions: u32,
    pStm: *IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFDeserializeAttributesFromStream(
    pAttr: *IMFAttributes,
    dwOptions: u32,
    pStm: *IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateTransformActivate(
    ppActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateMediaSession(
    pConfiguration: *IMFAttributes,
    ppMediaSession: **IMFMediaSession,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreatePMPMediaSession(
    dwCreationFlags: u32,
    pConfiguration: *IMFAttributes,
    ppMediaSession: **IMFMediaSession,
    ppEnablerActivate: ?*?*IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateSourceResolver(
    ppISourceResolver: **IMFSourceResolver,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn CreatePropertyStore(
    ppStore: **IPropertyStore,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetSupportedSchemes(
    pPropVarSchemeArray: *PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetSupportedMimeTypes(
    pPropVarMimeTypeArray: *PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateTopology(
    ppTopo: **IMFTopology,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateTopologyNode(
    NodeType: MF_TOPOLOGY_TYPE,
    ppNode: **IMFTopologyNode,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFGetTopoNodeCurrentType(
    pNode: *IMFTopologyNode,
    dwStreamIndex: u32,
    fOutput: BOOL,
    ppType: **IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFGetService(
    punkObject: *IUnknown,
    guidService: *const Guid,
    riid: *const Guid,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetSystemTime(
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "MF" fn MFCreatePresentationClock(
    ppPresentationClock: **IMFPresentationClock,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateSystemTimeSource(
    ppSystemTimeSource: **IMFPresentationTimeSource,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreatePresentationDescriptor(
    cStreamDescriptors: u32,
    apStreamDescriptors: ?[*]?*IMFStreamDescriptor,
    ppPresentationDescriptor: **IMFPresentationDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFRequireProtectedEnvironment(
    pPresentationDescriptor: *IMFPresentationDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFSerializePresentationDescriptor(
    pPD: *IMFPresentationDescriptor,
    pcbData: *u32,
    ppbData: [*]*u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFDeserializePresentationDescriptor(
    cbData: u32,
    pbData: [*:0]u8,
    ppPD: **IMFPresentationDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateStreamDescriptor(
    dwStreamIdentifier: u32,
    cMediaTypes: u32,
    apMediaTypes: [*]*IMFMediaType,
    ppDescriptor: **IMFStreamDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateSimpleTypeHandler(
    ppHandler: **IMFMediaTypeHandler,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFShutdownObject(
    pUnk: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateAudioRenderer(
    pAudioAttributes: *IMFAttributes,
    ppSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateAudioRendererActivate(
    ppActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateVideoRendererActivate(
    hwndVideo: HWND,
    ppActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateMPEG4MediaSink(
    pIByteStream: *IMFByteStream,
    pVideoMediaType: ?*IMFMediaType,
    pAudioMediaType: ?*IMFMediaType,
    ppIMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreate3GPMediaSink(
    pIByteStream: *IMFByteStream,
    pVideoMediaType: ?*IMFMediaType,
    pAudioMediaType: ?*IMFMediaType,
    ppIMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateMP3MediaSink(
    pTargetByteStream: *IMFByteStream,
    ppMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateAC3MediaSink(
    pTargetByteStream: *IMFByteStream,
    pAudioMediaType: *IMFMediaType,
    ppMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateADTSMediaSink(
    pTargetByteStream: *IMFByteStream,
    pAudioMediaType: *IMFMediaType,
    ppMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateMuxSink(
    guidOutputSubType: Guid,
    pOutputAttributes: ?*IMFAttributes,
    pOutputByteStream: ?*IMFByteStream,
    ppMuxSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateFMPEG4MediaSink(
    pIByteStream: *IMFByteStream,
    pVideoMediaType: ?*IMFMediaType,
    pAudioMediaType: ?*IMFMediaType,
    ppIMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mfsrcsnk" fn MFCreateAVIMediaSink(
    pIByteStream: *IMFByteStream,
    pVideoMediaType: *IMFMediaType,
    pAudioMediaType: ?*IMFMediaType,
    ppIMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "mfsrcsnk" fn MFCreateWAVEMediaSink(
    pTargetByteStream: *IMFByteStream,
    pAudioMediaType: *IMFMediaType,
    ppMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateTopoLoader(
    ppObj: **IMFTopoLoader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateSampleGrabberSinkActivate(
    pIMFMediaType: *IMFMediaType,
    pIMFSampleGrabberSinkCallback: *IMFSampleGrabberSinkCallback,
    ppIActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateStandardQualityManager(
    ppQualityManager: **IMFQualityManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateSequencerSource(
    pReserved: *IUnknown,
    ppSequencerSource: **IMFSequencerSource,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateSequencerSegmentOffset(
    dwId: u32,
    hnsOffset: i64,
    pvarSegmentOffset: *PROPVARIANT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateAggregateSource(
    pSourceCollection: *IMFCollection,
    ppAggSource: **IMFMediaSource,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateCredentialCache(
    ppCache: **IMFNetCredentialCache,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateProxyLocator(
    pszProtocol: [*:0]const u16,
    pProxyConfig: *IPropertyStore,
    ppProxyLocator: **IMFNetProxyLocator,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateNetSchemePlugin(
    riid: *const Guid,
    ppvHandler: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreatePMPServer(
    dwCreationFlags: u32,
    ppPMPServer: **IMFPMPServer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateRemoteDesktopPlugin(
    ppPlugin: **IMFRemoteDesktopPlugin,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn CreateNamedPropertyStore(
    ppStore: **INamedPropertyStore,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateSampleCopierMFT(
    ppCopierMFT: **IMFTransform,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateTranscodeProfile(
    ppTranscodeProfile: **IMFTranscodeProfile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateTranscodeTopology(
    pSrc: *IMFMediaSource,
    pwszOutputFilePath: [*:0]const u16,
    pProfile: *IMFTranscodeProfile,
    ppTranscodeTopo: **IMFTopology,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateTranscodeTopologyFromByteStream(
    pSrc: *IMFMediaSource,
    pOutputStream: *IMFByteStream,
    pProfile: *IMFTranscodeProfile,
    ppTranscodeTopo: **IMFTopology,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFTranscodeGetAudioOutputAvailableTypes(
    guidSubType: *const Guid,
    dwMFTFlags: u32,
    pCodecConfig: ?*IMFAttributes,
    ppAvailableTypes: **IMFCollection,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateTranscodeSinkActivate(
    ppActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateTrackedSample(
    ppMFSample: **IMFTrackedSample,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMFByteStreamOnStream(
    pStream: *IStream,
    ppByteStream: **IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateStreamOnMFByteStream(
    pByteStream: *IMFByteStream,
    ppStream: **IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMFByteStreamOnStreamEx(
    punkStream: *IUnknown,
    ppByteStream: **IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateStreamOnMFByteStreamEx(
    pByteStream: *IMFByteStream,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMediaTypeFromProperties(
    punkStream: *IUnknown,
    ppMediaType: **IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreatePropertiesFromMediaType(
    pMediaType: *IMFMediaType,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFEnumDeviceSources(
    pAttributes: *IMFAttributes,
    pppSourceActivate: ***IMFActivate,
    pcSourceActivate: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateDeviceSource(
    pAttributes: *IMFAttributes,
    ppSource: **IMFMediaSource,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateDeviceSourceActivate(
    pAttributes: *IMFAttributes,
    ppActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateProtectedEnvironmentAccess(
    ppAccess: **IMFProtectedEnvironmentAccess,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFLoadSignedLibrary(
    pszName: [*:0]const u16,
    ppLib: **IMFSignedLibrary,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFGetSystemId(
    ppId: **IMFSystemId,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFGetLocalId(
    verifier: [*:0]const u8,
    size: u32,
    id: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateContentProtectionDevice(
    ProtectionSystemId: *const Guid,
    ContentProtectionDevice: **IMFContentProtectionDevice,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFIsContentProtectionDeviceSupported(
    ProtectionSystemId: *const Guid,
    isSupported: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateContentDecryptorContext(
    guidMediaProtectionSystemId: *const Guid,
    pD3DManager: ?*IMFDXGIDeviceManager,
    pContentProtectionDevice: *IMFContentProtectionDevice,
    ppContentDecryptorContext: **IMFContentDecryptorContext,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFSENSORGROUP" fn MFCreateSensorGroup(
    SensorGroupSymbolicLink: [*:0]const u16,
    ppSensorGroup: **IMFSensorGroup,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFSENSORGROUP" fn MFCreateSensorStream(
    StreamId: u32,
    pAttributes: ?*IMFAttributes,
    pMediaTypeCollection: *IMFCollection,
    ppStream: **IMFSensorStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFSENSORGROUP" fn MFCreateSensorProfile(
    ProfileType: *const Guid,
    ProfileIndex: u32,
    Constraints: ?[*:0]const u16,
    ppProfile: **IMFSensorProfile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFSENSORGROUP" fn MFCreateSensorProfileCollection(
    ppSensorProfile: **IMFSensorProfileCollection,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFSENSORGROUP" fn MFCreateSensorActivityMonitor(
    pCallback: *IMFSensorActivitiesReportCallback,
    ppActivityMonitor: **IMFSensorActivityMonitor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFCORE" fn MFCreateExtendedCameraIntrinsics(
    ppExtendedCameraIntrinsics: **IMFExtendedCameraIntrinsics,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFCORE" fn MFCreateExtendedCameraIntrinsicModel(
    distortionModelType: MFCameraIntrinsic_DistortionModelType,
    ppExtendedCameraIntrinsicModel: **IMFExtendedCameraIntrinsicModel,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFSENSORGROUP" fn MFCreateRelativePanelWatcher(
    videoDeviceId: [*:0]const u16,
    displayMonitorDeviceId: [*:0]const u16,
    ppRelativePanelWatcher: **IMFRelativePanelWatcher,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFContentInfo(
    ppIContentInfo: **IMFASFContentInfo,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFIndexer(
    ppIIndexer: **IMFASFIndexer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFIndexerByteStream(
    pIContentByteStream: *IMFByteStream,
    cbIndexStartOffset: u64,
    pIIndexByteStream: **IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFSplitter(
    ppISplitter: **IMFASFSplitter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFProfile(
    ppIProfile: **IMFASFProfile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFProfileFromPresentationDescriptor(
    pIPD: *IMFPresentationDescriptor,
    ppIProfile: **IMFASFProfile,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreatePresentationDescriptorFromASFProfile(
    pIProfile: *IMFASFProfile,
    ppIPD: **IMFPresentationDescriptor,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFMultiplexer(
    ppIMultiplexer: **IMFASFMultiplexer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFStreamSelector(
    pIASFProfile: *IMFASFProfile,
    ppSelector: **IMFASFStreamSelector,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFMediaSink(
    pIByteStream: *IMFByteStream,
    ppIMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFMediaSinkActivate(
    pwszFileName: [*:0]const u16,
    pContentInfo: *IMFASFContentInfo,
    ppIActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateWMVEncoderActivate(
    pMediaType: *IMFMediaType,
    pEncodingConfigurationProperties: *IPropertyStore,
    ppActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateWMAEncoderActivate(
    pMediaType: *IMFMediaType,
    pEncodingConfigurationProperties: *IPropertyStore,
    ppActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFStreamingMediaSink(
    pIByteStream: *IMFByteStream,
    ppIMediaSink: **IMFMediaSink,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateASFStreamingMediaSinkActivate(
    pByteStreamActivate: *IMFActivate,
    pContentInfo: *IMFASFContentInfo,
    ppIActivate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFStartup(
    Version: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFShutdown(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFLockPlatform(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFUnlockPlatform(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFPutWorkItem(
    dwQueue: u32,
    pCallback: *IMFAsyncCallback,
    pState: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFPutWorkItem2(
    dwQueue: u32,
    Priority: i32,
    pCallback: *IMFAsyncCallback,
    pState: ?*IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFPutWorkItemEx(
    dwQueue: u32,
    pResult: *IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFPutWorkItemEx2(
    dwQueue: u32,
    Priority: i32,
    pResult: *IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFPutWaitingWorkItem(
    hEvent: HANDLE,
    Priority: i32,
    pResult: *IMFAsyncResult,
    pKey: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFAllocateSerialWorkQueue(
    dwWorkQueue: u32,
    pdwWorkQueue: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFScheduleWorkItemEx(
    pResult: *IMFAsyncResult,
    Timeout: i64,
    pKey: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFScheduleWorkItem(
    pCallback: *IMFAsyncCallback,
    pState: *IUnknown,
    Timeout: i64,
    pKey: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCancelWorkItem(
    Key: u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetTimerPeriodicity(
    Periodicity: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFAddPeriodicCallback(
    Callback: MFPERIODICCALLBACK,
    pContext: *IUnknown,
    pdwKey: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFRemovePeriodicCallback(
    dwKey: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFAllocateWorkQueueEx(
    WorkQueueType: MFASYNC_WORKQUEUE_TYPE,
    pdwWorkQueue: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFAllocateWorkQueue(
    pdwWorkQueue: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFLockWorkQueue(
    dwWorkQueue: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFUnlockWorkQueue(
    dwWorkQueue: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFBeginRegisterWorkQueueWithMMCSS(
    dwWorkQueueId: u32,
    wszClass: [*:0]const u16,
    dwTaskId: u32,
    pDoneCallback: *IMFAsyncCallback,
    pDoneState: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFBeginRegisterWorkQueueWithMMCSSEx(
    dwWorkQueueId: u32,
    wszClass: [*:0]const u16,
    dwTaskId: u32,
    lPriority: i32,
    pDoneCallback: *IMFAsyncCallback,
    pDoneState: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFEndRegisterWorkQueueWithMMCSS(
    pResult: *IMFAsyncResult,
    pdwTaskId: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFBeginUnregisterWorkQueueWithMMCSS(
    dwWorkQueueId: u32,
    pDoneCallback: *IMFAsyncCallback,
    pDoneState: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFEndUnregisterWorkQueueWithMMCSS(
    pResult: *IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetWorkQueueMMCSSClass(
    dwWorkQueueId: u32,
    pwszClass: ?[*:0]u16,
    pcchClass: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetWorkQueueMMCSSTaskId(
    dwWorkQueueId: u32,
    pdwTaskId: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFRegisterPlatformWithMMCSS(
    wszClass: [*:0]const u16,
    pdwTaskId: *u32,
    lPriority: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFUnregisterPlatformFromMMCSS(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFLockSharedWorkQueue(
    wszClass: [*:0]const u16,
    BasePriority: i32,
    pdwTaskId: *u32,
    pID: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetWorkQueueMMCSSPriority(
    dwWorkQueueId: u32,
    lPriority: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateAsyncResult(
    punkObject: *IUnknown,
    pCallback: *IMFAsyncCallback,
    punkState: *IUnknown,
    ppAsyncResult: **IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInvokeCallback(
    pAsyncResult: *IMFAsyncResult,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateFile(
    AccessMode: MF_FILE_ACCESSMODE,
    OpenMode: MF_FILE_OPENMODE,
    fFlags: MF_FILE_FLAGS,
    pwszFileURL: [*:0]const u16,
    ppIByteStream: **IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateTempFile(
    AccessMode: MF_FILE_ACCESSMODE,
    OpenMode: MF_FILE_OPENMODE,
    fFlags: MF_FILE_FLAGS,
    ppIByteStream: **IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFBeginCreateFile(
    AccessMode: MF_FILE_ACCESSMODE,
    OpenMode: MF_FILE_OPENMODE,
    fFlags: MF_FILE_FLAGS,
    pwszFilePath: [*:0]const u16,
    pCallback: *IMFAsyncCallback,
    pState: *IUnknown,
    ppCancelCookie: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFEndCreateFile(
    pResult: *IMFAsyncResult,
    ppFile: **IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCancelCreateFile(
    pCancelCookie: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMemoryBuffer(
    cbMaxLength: u32,
    ppBuffer: **IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMediaBufferWrapper(
    pBuffer: *IMFMediaBuffer,
    cbOffset: u32,
    dwLength: u32,
    ppBuffer: **IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateLegacyMediaBufferOnMFMediaBuffer(
    pSample: ?*IMFSample,
    pMFMediaBuffer: *IMFMediaBuffer,
    cbOffset: u32,
    ppMediaBuffer: **IMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFMapDX9FormatToDXGIFormat(
    dx9: u32,
) callconv(@import("std").os.windows.WINAPI) DXGI_FORMAT;

pub extern "MFPlat" fn MFMapDXGIFormatToDX9Format(
    dx11: DXGI_FORMAT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MFPlat" fn MFLockDXGIDeviceManager(
    pResetToken: ?*u32,
    ppManager: **IMFDXGIDeviceManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFUnlockDXGIDeviceManager(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateDXSurfaceBuffer(
    riid: *const Guid,
    punkSurface: *IUnknown,
    fBottomUpWhenLinear: BOOL,
    ppBuffer: **IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateWICBitmapBuffer(
    riid: *const Guid,
    punkSurface: *IUnknown,
    ppBuffer: **IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateDXGISurfaceBuffer(
    riid: *const Guid,
    punkSurface: *IUnknown,
    uSubresourceIndex: u32,
    fBottomUpWhenLinear: BOOL,
    ppBuffer: **IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateVideoSampleAllocatorEx(
    riid: *const Guid,
    ppSampleAllocator: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateDXGIDeviceManager(
    resetToken: *u32,
    ppDeviceManager: **IMFDXGIDeviceManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateAlignedMemoryBuffer(
    cbMaxLength: u32,
    cbAligment: u32,
    ppBuffer: **IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMediaEvent(
    met: u32,
    guidExtendedType: *const Guid,
    hrStatus: HRESULT,
    pvValue: ?*const PROPVARIANT,
    ppEvent: **IMFMediaEvent,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateEventQueue(
    ppMediaEventQueue: **IMFMediaEventQueue,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateSample(
    ppIMFSample: **IMFSample,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateAttributes(
    ppMFAttributes: **IMFAttributes,
    cInitialSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitAttributesFromBlob(
    pAttributes: *IMFAttributes,
    pBuf: [*:0]const u8,
    cbBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetAttributesAsBlobSize(
    pAttributes: *IMFAttributes,
    pcbBufSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetAttributesAsBlob(
    pAttributes: *IMFAttributes,
    pBuf: [*:0]u8,
    cbBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTRegister(
    clsidMFT: Guid,
    guidCategory: Guid,
    pszName: PWSTR,
    Flags: u32,
    cInputTypes: u32,
    pInputTypes: ?[*]MFT_REGISTER_TYPE_INFO,
    cOutputTypes: u32,
    pOutputTypes: ?[*]MFT_REGISTER_TYPE_INFO,
    pAttributes: ?*IMFAttributes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTUnregister(
    clsidMFT: Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTRegisterLocal(
    pClassFactory: *IClassFactory,
    guidCategory: *const Guid,
    pszName: [*:0]const u16,
    Flags: u32,
    cInputTypes: u32,
    pInputTypes: ?[*]const MFT_REGISTER_TYPE_INFO,
    cOutputTypes: u32,
    pOutputTypes: ?[*]const MFT_REGISTER_TYPE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTUnregisterLocal(
    pClassFactory: ?*IClassFactory,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTRegisterLocalByCLSID(
    clisdMFT: *const Guid,
    guidCategory: *const Guid,
    pszName: [*:0]const u16,
    Flags: u32,
    cInputTypes: u32,
    pInputTypes: ?[*]const MFT_REGISTER_TYPE_INFO,
    cOutputTypes: u32,
    pOutputTypes: ?[*]const MFT_REGISTER_TYPE_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTUnregisterLocalByCLSID(
    clsidMFT: Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTEnum(
    guidCategory: Guid,
    Flags: u32,
    pInputType: ?*MFT_REGISTER_TYPE_INFO,
    pOutputType: ?*MFT_REGISTER_TYPE_INFO,
    pAttributes: ?*IMFAttributes,
    ppclsidMFT: **Guid,
    pcMFTs: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTEnumEx(
    guidCategory: Guid,
    Flags: u32,
    pInputType: ?*const MFT_REGISTER_TYPE_INFO,
    pOutputType: ?*const MFT_REGISTER_TYPE_INFO,
    pppMFTActivate: ***IMFActivate,
    pnumMFTActivate: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTEnum2(
    guidCategory: Guid,
    Flags: u32,
    pInputType: ?*const MFT_REGISTER_TYPE_INFO,
    pOutputType: ?*const MFT_REGISTER_TYPE_INFO,
    pAttributes: ?*IMFAttributes,
    pppMFTActivate: ***IMFActivate,
    pnumMFTActivate: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFTGetInfo(
    clsidMFT: Guid,
    pszName: ?*?PWSTR,
    ppInputTypes: ?*?*MFT_REGISTER_TYPE_INFO,
    pcInputTypes: ?*u32,
    ppOutputTypes: ?*?*MFT_REGISTER_TYPE_INFO,
    pcOutputTypes: ?*u32,
    ppAttributes: ?*?*IMFAttributes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetPluginControl(
    ppPluginControl: **IMFPluginControl,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetMFTMerit(
    pMFT: *IUnknown,
    cbVerifier: u32,
    verifier: [*:0]const u8,
    merit: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFRegisterLocalSchemeHandler(
    szScheme: [*:0]const u16,
    pActivate: *IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFRegisterLocalByteStreamHandler(
    szFileExtension: [*:0]const u16,
    szMimeType: [*:0]const u16,
    pActivate: *IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMFByteStreamWrapper(
    pStream: *IMFByteStream,
    ppStreamWrapper: **IMFByteStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMediaExtensionActivate(
    szActivatableClassId: [*:0]const u16,
    pConfiguration: ?*IUnknown,
    riid: *const Guid,
    ppvObject: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMuxStreamAttributes(
    pAttributesToMux: *IMFCollection,
    ppMuxAttribs: **IMFAttributes,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMuxStreamMediaType(
    pMediaTypesToMux: *IMFCollection,
    ppMuxMediaType: **IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMuxStreamSample(
    pSamplesToMux: *IMFCollection,
    ppMuxSample: **IMFSample,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFValidateMediaTypeSize(
    FormatType: Guid,
    pBlock: ?[*:0]u8,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMediaType(
    ppMFType: **IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMFVideoFormatFromMFMediaType(
    pMFType: *IMFMediaType,
    ppMFVF: **MFVIDEOFORMAT,
    pcbSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateWaveFormatExFromMFMediaType(
    pMFType: *IMFMediaType,
    ppWF: **WAVEFORMATEX,
    pcbSize: ?*u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitMediaTypeFromVideoInfoHeader(
    pMFType: *IMFMediaType,
    pVIH: [*]const VIDEOINFOHEADER,
    cbBufSize: u32,
    pSubtype: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitMediaTypeFromVideoInfoHeader2(
    pMFType: *IMFMediaType,
    pVIH2: [*]const VIDEOINFOHEADER2,
    cbBufSize: u32,
    pSubtype: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitMediaTypeFromMPEG1VideoInfo(
    pMFType: *IMFMediaType,
    pMP1VI: [*]const MPEG1VIDEOINFO,
    cbBufSize: u32,
    pSubtype: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitMediaTypeFromMPEG2VideoInfo(
    pMFType: *IMFMediaType,
    pMP2VI: [*]const MPEG2VIDEOINFO,
    cbBufSize: u32,
    pSubtype: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCalculateBitmapImageSize(
    pBMIH: [*]const BITMAPINFOHEADER,
    cbBufSize: u32,
    pcbImageSize: *u32,
    pbKnown: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCalculateImageSize(
    guidSubtype: *const Guid,
    unWidth: u32,
    unHeight: u32,
    pcbImageSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFFrameRateToAverageTimePerFrame(
    unNumerator: u32,
    unDenominator: u32,
    punAverageTimePerFrame: *u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFAverageTimePerFrameToFrameRate(
    unAverageTimePerFrame: u64,
    punNumerator: *u32,
    punDenominator: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitMediaTypeFromMFVideoFormat(
    pMFType: *IMFMediaType,
    pMFVF: [*]const MFVIDEOFORMAT,
    cbBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitMediaTypeFromWaveFormatEx(
    pMFType: *IMFMediaType,
    pWaveFormat: [*]const WAVEFORMATEX,
    cbBufSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitMediaTypeFromAMMediaType(
    pMFType: *IMFMediaType,
    pAMType: *const AM_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitAMMediaTypeFromMFMediaType(
    pMFType: *IMFMediaType,
    guidFormatBlockType: Guid,
    pAMType: *AM_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateAMMediaTypeFromMFMediaType(
    pMFType: *IMFMediaType,
    guidFormatBlockType: Guid,
    ppAMType: **AM_MEDIA_TYPE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCompareFullToPartialMediaType(
    pMFTypeFull: *IMFMediaType,
    pMFTypePartial: *IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MFPlat" fn MFWrapMediaType(
    pOrig: *IMFMediaType,
    MajorType: *const Guid,
    SubType: *const Guid,
    ppWrap: **IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFUnwrapMediaType(
    pWrap: *IMFMediaType,
    ppOrig: **IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateVideoMediaType(
    pVideoFormat: *const MFVIDEOFORMAT,
    ppIVideoMediaType: **IMFVideoMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateVideoMediaTypeFromSubtype(
    pAMSubtype: *const Guid,
    ppIVideoMediaType: **IMFVideoMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "EVR" fn MFIsFormatYUV(
    Format: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MFPlat" fn MFCreateVideoMediaTypeFromBitMapInfoHeader(
    pbmihBitMapInfoHeader: *const BITMAPINFOHEADER,
    dwPixelAspectRatioX: u32,
    dwPixelAspectRatioY: u32,
    InterlaceMode: MFVideoInterlaceMode,
    VideoFlags: u64,
    qwFramesPerSecondNumerator: u64,
    qwFramesPerSecondDenominator: u64,
    dwMaxBitRate: u32,
    ppIVideoMediaType: **IMFVideoMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetStrideForBitmapInfoHeader(
    format: u32,
    dwWidth: u32,
    pStride: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetPlaneSize(
    format: u32,
    dwWidth: u32,
    dwHeight: u32,
    pdwPlaneSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateVideoMediaTypeFromBitMapInfoHeaderEx(
    pbmihBitMapInfoHeader: [*]const BITMAPINFOHEADER,
    cbBitMapInfoHeader: u32,
    dwPixelAspectRatioX: u32,
    dwPixelAspectRatioY: u32,
    InterlaceMode: MFVideoInterlaceMode,
    VideoFlags: u64,
    dwFramesPerSecondNumerator: u32,
    dwFramesPerSecondDenominator: u32,
    dwMaxBitRate: u32,
    ppIVideoMediaType: **IMFVideoMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMediaTypeFromRepresentation(
    guidRepresentation: Guid,
    pvRepresentation: *c_void,
    ppIMediaType: **IMFMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateAudioMediaType(
    pAudioFormat: *const WAVEFORMATEX,
    ppIAudioMediaType: **IMFAudioMediaType,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFGetUncompressedVideoFormat(
    pVideoFormat: *const MFVIDEOFORMAT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "MFPlat" fn MFInitVideoFormat(
    pVideoFormat: *MFVIDEOFORMAT,
    type: MFStandardVideoFormat,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFInitVideoFormat_RGB(
    pVideoFormat: *MFVIDEOFORMAT,
    dwWidth: u32,
    dwHeight: u32,
    D3Dfmt: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFConvertColorInfoToDXVA(
    pdwToDXVA: *u32,
    pFromFormat: *const MFVIDEOFORMAT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFConvertColorInfoFromDXVA(
    pToFormat: *MFVIDEOFORMAT,
    dwFromDXVA: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCopyImage(
    pDest: *u8,
    lDestStride: i32,
    pSrc: *const u8,
    lSrcStride: i32,
    dwWidthInBytes: u32,
    dwLines: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFConvertFromFP16Array(
    pDest: [*]f32,
    pSrc: [*:0]const u16,
    dwCount: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFConvertToFP16Array(
    pDest: [*:0]u16,
    pSrc: [*]const f32,
    dwCount: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreate2DMediaBuffer(
    dwWidth: u32,
    dwHeight: u32,
    dwFourCC: u32,
    fBottomUp: BOOL,
    ppBuffer: **IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateMediaBufferFromMediaType(
    pMediaType: *IMFMediaType,
    llDuration: i64,
    dwMinLength: u32,
    dwMinAlignment: u32,
    ppBuffer: **IMFMediaBuffer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCreateCollection(
    ppIMFCollection: **IMFCollection,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFHeapAlloc(
    nSize: ?*c_void,
    dwFlags: u32,
    pszFile: ?*i8,
    line: i32,
    eat: EAllocationType,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "MFPlat" fn MFHeapFree(
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "MFPlat" fn MFllMulDiv(
    a: i64,
    b: i64,
    c: i64,
    d: i64,
) callconv(@import("std").os.windows.WINAPI) i64;

pub extern "MFPlat" fn MFGetContentProtectionSystemCLSID(
    guidProtectionSystemID: *const Guid,
    pclsid: *Guid,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFCombineSamples(
    pSample: *IMFSample,
    pSampleToAdd: *IMFSample,
    dwMaxMergedDurationInMS: u32,
    pMerged: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlat" fn MFSplitSample(
    pSample: *IMFSample,
    pOutputSamples: [*]*IMFSample,
    dwOutputSampleMaxCount: u32,
    pdwOutputSampleCount: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFReadWrite" fn MFCreateSourceReaderFromURL(
    pwszURL: [*:0]const u16,
    pAttributes: ?*IMFAttributes,
    ppSourceReader: **IMFSourceReader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFReadWrite" fn MFCreateSourceReaderFromByteStream(
    pByteStream: *IMFByteStream,
    pAttributes: ?*IMFAttributes,
    ppSourceReader: **IMFSourceReader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFReadWrite" fn MFCreateSourceReaderFromMediaSource(
    pMediaSource: *IMFMediaSource,
    pAttributes: ?*IMFAttributes,
    ppSourceReader: **IMFSourceReader,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFReadWrite" fn MFCreateSinkWriterFromURL(
    pwszOutputURL: ?[*:0]const u16,
    pByteStream: ?*IMFByteStream,
    pAttributes: ?*IMFAttributes,
    ppSinkWriter: **IMFSinkWriter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFReadWrite" fn MFCreateSinkWriterFromMediaSink(
    pMediaSink: *IMFMediaSink,
    pAttributes: ?*IMFAttributes,
    ppSinkWriter: **IMFSinkWriter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "EVR" fn MFCreateVideoPresenter(
    pOwner: ?*IUnknown,
    riidDevice: *const Guid,
    riid: *const Guid,
    ppVideoPresenter: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "EVR" fn MFCreateVideoMixer(
    pOwner: ?*IUnknown,
    riidDevice: *const Guid,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "EVR" fn MFCreateVideoMixerAndPresenter(
    pMixerOwner: ?*IUnknown,
    pPresenterOwner: ?*IUnknown,
    riidMixer: *const Guid,
    ppvVideoMixer: **c_void,
    riidPresenter: *const Guid,
    ppvVideoPresenter: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateVideoRenderer(
    riidRenderer: *const Guid,
    ppVideoRenderer: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "EVR" fn MFCreateVideoSampleFromSurface(
    pUnkSurface: *IUnknown,
    ppSample: **IMFSample,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "EVR" fn MFCreateVideoSampleAllocator(
    riid: *const Guid,
    ppSampleAllocator: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MFPlay" fn MFPCreateMediaPlayer(
    pwszURL: ?[*:0]const u16,
    fStartPlayback: BOOL,
    creationOptions: MFP_CREATION_OPTIONS,
    pCallback: ?*IMFPMediaPlayerCallback,
    hWnd: HWND,
    ppMediaPlayer: ?*?*IMFPMediaPlayer,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "MF" fn MFCreateEncryptedMediaExtensionsStoreActivate(
    pmpHost: *IMFPMPHostApp,
    objectStream: *IStream,
    classId: [*:0]const u16,
    activate: **IMFActivate,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (67)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const D3DDISPLAYROTATION = @import("direct3d9.zig").D3DDISPLAYROTATION;
const ID3D12CommandList = @import("direct3d12.zig").ID3D12CommandList;
const FILETIME = @import("windows_programming.zig").FILETIME;
const ID3D11Texture2D = @import("direct3d11.zig").ID3D11Texture2D;
const DXGI_COLOR_SPACE_TYPE = @import("dxgi.zig").DXGI_COLOR_SPACE_TYPE;
const D3DPOOL = @import("direct3d9.zig").D3DPOOL;
const DXGI_HDR_METADATA_TYPE = @import("dxgi.zig").DXGI_HDR_METADATA_TYPE;
const D3D12_PREDICATION_OP = @import("direct3d12.zig").D3D12_PREDICATION_OP;
const ID3D12Resource = @import("direct3d12.zig").ID3D12Resource;
const IInspectable = @import("win_rt.zig").IInspectable;
const D3DAUTHENTICATEDCHANNELTYPE = @import("direct3d9.zig").D3DAUTHENTICATEDCHANNELTYPE;
const ID3D11View = @import("direct3d11.zig").ID3D11View;
const AM_MEDIA_TYPE = @import("direct_show.zig").AM_MEDIA_TYPE;
const IMFDeviceTransform = @import("streaming_media.zig").IMFDeviceTransform;
const ISpatialAudioMetadataItems = @import("core_audio.zig").ISpatialAudioMetadataItems;
const INamedPropertyStore = @import("shell.zig").INamedPropertyStore;
const IPropertyStore = @import("audio.zig").IPropertyStore;
const IDirect3DSurface9 = @import("direct3d9.zig").IDirect3DSurface9;
const D3DENCRYPTED_BLOCK_INFO = @import("direct3d9.zig").D3DENCRYPTED_BLOCK_INFO;
const IStream = @import("structured_storage.zig").IStream;
const D3D12_QUERY_TYPE = @import("direct3d12.zig").D3D12_QUERY_TYPE;
const PWSTR = @import("system_services.zig").PWSTR;
const D3DDEVTYPE = @import("direct3d9.zig").D3DDEVTYPE;
const HMONITOR = @import("gdi.zig").HMONITOR;
const PROPVARIANT = @import("structured_storage.zig").PROPVARIANT;
const BSTR = @import("automation.zig").BSTR;
const RECT = @import("display_devices.zig").RECT;
const PSTR = @import("system_services.zig").PSTR;
const ID3D12QueryHeap = @import("direct3d12.zig").ID3D12QueryHeap;
const ID3D12ProtectedResourceSession = @import("direct3d12.zig").ID3D12ProtectedResourceSession;
const DXGI_FORMAT = @import("dxgi.zig").DXGI_FORMAT;
const D3D12_COMMAND_LIST_SUPPORT_FLAGS = @import("direct3d12.zig").D3D12_COMMAND_LIST_SUPPORT_FLAGS;
const AudioObjectType = @import("core_audio.zig").AudioObjectType;
const HANDLE = @import("system_services.zig").HANDLE;
const ID3D11DeviceChild = @import("direct3d11.zig").ID3D11DeviceChild;
const IDirect3DDevice9 = @import("direct3d9.zig").IDirect3DDevice9;
const ID3D12Pageable = @import("direct3d12.zig").ID3D12Pageable;
const D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT = @import("direct3d9.zig").D3DAUTHENTICATEDCHANNEL_CONFIGURE_OUTPUT;
const HRESULT = @import("com.zig").HRESULT;
const DMO_MEDIA_TYPE = @import("direct_show.zig").DMO_MEDIA_TYPE;
const VIDEOINFOHEADER2 = @import("direct_show.zig").VIDEOINFOHEADER2;
const BITMAPINFOHEADER = @import("direct_show.zig").BITMAPINFOHEADER;
const BOOL = @import("system_services.zig").BOOL;
const D3D11_AUTHENTICATED_PROTECTION_FLAGS = @import("direct3d11.zig").D3D11_AUTHENTICATED_PROTECTION_FLAGS;
const LUID = @import("kernel.zig").LUID;
const VIDEOINFOHEADER = @import("direct_show.zig").VIDEOINFOHEADER;
const DXGI_RATIONAL = @import("dxgi.zig").DXGI_RATIONAL;
const D3DDISPLAYMODEEX = @import("direct3d9.zig").D3DDISPLAYMODEEX;
const IDirect3DDevice9Ex = @import("direct3d9.zig").IDirect3DDevice9Ex;
const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER = @import("direct3d12.zig").D3D12_WRITEBUFFERIMMEDIATE_PARAMETER;
const IUnknown = @import("com.zig").IUnknown;
const ID3D12CommandAllocator = @import("direct3d12.zig").ID3D12CommandAllocator;
const D3D12_RESOURCE_BARRIER = @import("direct3d12.zig").D3D12_RESOURCE_BARRIER;
const D3D12_WRITEBUFFERIMMEDIATE_MODE = @import("direct3d12.zig").D3D12_WRITEBUFFERIMMEDIATE_MODE;
const HWND = @import("windows_and_messaging.zig").HWND;
const ID3D11Resource = @import("direct3d11.zig").ID3D11Resource;
const IClassFactory = @import("com.zig").IClassFactory;
const VARIANT = @import("automation.zig").VARIANT;
const MPEG2VIDEOINFO = @import("direct_show.zig").MPEG2VIDEOINFO;
const IMediaBuffer = @import("direct_show.zig").IMediaBuffer;
const D3DFORMAT = @import("direct3d9.zig").D3DFORMAT;
const D3D12_DISCARD_REGION = @import("direct3d12.zig").D3D12_DISCARD_REGION;
const SIZE = @import("display_devices.zig").SIZE;
const WAVEFORMATEX = @import("multimedia.zig").WAVEFORMATEX;
const POINT = @import("display_devices.zig").POINT;
const MPEG1VIDEOINFO = @import("direct_show.zig").MPEG1VIDEOINFO;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = PDXVAHDSW_CreateDevice;
    _ = PDXVAHDSW_ProposeVideoPrivateFormat;
    _ = PDXVAHDSW_GetVideoProcessorDeviceCaps;
    _ = PDXVAHDSW_GetVideoProcessorOutputFormats;
    _ = PDXVAHDSW_GetVideoProcessorInputFormats;
    _ = PDXVAHDSW_GetVideoProcessorCaps;
    _ = PDXVAHDSW_GetVideoProcessorCustomRates;
    _ = PDXVAHDSW_GetVideoProcessorFilterRange;
    _ = PDXVAHDSW_DestroyDevice;
    _ = PDXVAHDSW_CreateVideoProcessor;
    _ = PDXVAHDSW_SetVideoProcessBltState;
    _ = PDXVAHDSW_GetVideoProcessBltStatePrivate;
    _ = PDXVAHDSW_SetVideoProcessStreamState;
    _ = PDXVAHDSW_GetVideoProcessStreamStatePrivate;
    _ = PDXVAHDSW_VideoProcessBltHD;
    _ = PDXVAHDSW_DestroyVideoProcessor;
    _ = PDXVAHDSW_Plugin;
    _ = PDXVAHD_CreateDevice;
    _ = MFPERIODICCALLBACK;

    const constant_export_count = 579;
    const type_export_count = 1004;
    const enum_value_export_count = 1757;
    const com_iface_id_export_count = 354;
    const com_class_id_export_count = 95;
    const func_export_count = 235;
    const unicode_alias_count = 0;
    const import_count = 67;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
