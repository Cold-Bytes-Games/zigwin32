//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (338)
//--------------------------------------------------------------------------------
pub const MAX_ADAPTER_DESCRIPTION_LENGTH = @as(u32, 128);
pub const MAX_ADAPTER_NAME_LENGTH = @as(u32, 256);
pub const MAX_ADAPTER_ADDRESS_LENGTH = @as(u32, 8);
pub const DEFAULT_MINIMUM_ENTITIES = @as(u32, 32);
pub const MAX_HOSTNAME_LEN = @as(u32, 128);
pub const MAX_DOMAIN_NAME_LEN = @as(u32, 128);
pub const MAX_SCOPE_ID_LEN = @as(u32, 256);
pub const MAX_DHCPV6_DUID_LENGTH = @as(u32, 130);
pub const MAX_DNS_SUFFIX_STRING_LENGTH = @as(u32, 256);
pub const BROADCAST_NODETYPE = @as(u32, 1);
pub const PEER_TO_PEER_NODETYPE = @as(u32, 2);
pub const MIXED_NODETYPE = @as(u32, 4);
pub const HYBRID_NODETYPE = @as(u32, 8);
pub const IP_ADAPTER_ADDRESS_DNS_ELIGIBLE = @as(u32, 1);
pub const IP_ADAPTER_ADDRESS_TRANSIENT = @as(u32, 2);
pub const IP_ADAPTER_DDNS_ENABLED = @as(u32, 1);
pub const IP_ADAPTER_REGISTER_ADAPTER_SUFFIX = @as(u32, 2);
pub const IP_ADAPTER_DHCP_ENABLED = @as(u32, 4);
pub const IP_ADAPTER_RECEIVE_ONLY = @as(u32, 8);
pub const IP_ADAPTER_NO_MULTICAST = @as(u32, 16);
pub const IP_ADAPTER_IPV6_OTHER_STATEFUL_CONFIG = @as(u32, 32);
pub const IP_ADAPTER_NETBIOS_OVER_TCPIP_ENABLED = @as(u32, 64);
pub const IP_ADAPTER_IPV4_ENABLED = @as(u32, 128);
pub const IP_ADAPTER_IPV6_ENABLED = @as(u32, 256);
pub const IP_ADAPTER_IPV6_MANAGE_ADDRESS_CONFIG = @as(u32, 512);
pub const GAA_FLAG_SKIP_DNS_INFO = @as(u32, 2048);
pub const ANY_SIZE = @as(u32, 1);
pub const TCPIP_OWNING_MODULE_SIZE = @as(u32, 16);
pub const MIB_IPADDR_PRIMARY = @as(u32, 1);
pub const MIB_IPADDR_DYNAMIC = @as(u32, 4);
pub const MIB_IPADDR_DISCONNECTED = @as(u32, 8);
pub const MIB_IPADDR_DELETED = @as(u32, 64);
pub const MIB_IPADDR_TRANSIENT = @as(u32, 128);
pub const MIB_IPADDR_DNS_ELIGIBLE = @as(u32, 256);
pub const MIB_IPROUTE_TYPE_OTHER = @as(u32, 1);
pub const MIB_IPROUTE_TYPE_INVALID = @as(u32, 2);
pub const MIB_IPROUTE_TYPE_DIRECT = @as(u32, 3);
pub const MIB_IPROUTE_TYPE_INDIRECT = @as(u32, 4);
pub const MAXLEN_PHYSADDR = @as(u32, 8);
pub const MAXLEN_IFDESCR = @as(u32, 256);
pub const MAX_INTERFACE_NAME_LEN = @as(u32, 256);
pub const IPRTRMGR_PID = @as(u32, 10000);
pub const IF_NUMBER = @as(u32, 0);
pub const MAX_SCOPE_NAME_LEN = @as(u32, 255);
pub const MAX_MIB_OFFSET = @as(u32, 8);
pub const NET_IF_OPER_STATUS_DOWN_NOT_AUTHENTICATED = @as(u32, 1);
pub const NET_IF_OPER_STATUS_DOWN_NOT_MEDIA_CONNECTED = @as(u32, 2);
pub const NET_IF_OPER_STATUS_DORMANT_PAUSED = @as(u32, 4);
pub const NET_IF_OPER_STATUS_DORMANT_LOW_POWER = @as(u32, 8);
pub const NET_IF_OID_IF_ALIAS = @as(u32, 1);
pub const NET_IF_OID_COMPARTMENT_ID = @as(u32, 2);
pub const NET_IF_OID_NETWORK_GUID = @as(u32, 3);
pub const NET_IF_OID_IF_ENTRY = @as(u32, 4);
pub const NET_SITEID_UNSPECIFIED = @as(u32, 0);
pub const NET_SITEID_MAXUSER = @as(u32, 134217727);
pub const NET_SITEID_MAXSYSTEM = @as(u32, 268435455);
pub const NET_IFLUID_UNSPECIFIED = @as(u32, 0);
pub const NIIF_HARDWARE_INTERFACE = @as(u32, 1);
pub const NIIF_FILTER_INTERFACE = @as(u32, 2);
pub const NIIF_NDIS_RESERVED1 = @as(u32, 4);
pub const NIIF_NDIS_RESERVED2 = @as(u32, 8);
pub const NIIF_NDIS_RESERVED3 = @as(u32, 16);
pub const NIIF_NDIS_WDM_INTERFACE = @as(u32, 32);
pub const NIIF_NDIS_ENDPOINT_INTERFACE = @as(u32, 64);
pub const NIIF_NDIS_ISCSI_INTERFACE = @as(u32, 128);
pub const NIIF_NDIS_RESERVED4 = @as(u32, 256);
pub const IF_MAX_STRING_SIZE = @as(u32, 256);
pub const IF_MAX_PHYS_ADDRESS_LENGTH = @as(u32, 32);
pub const MIN_IF_TYPE = @as(u32, 1);
pub const IF_TYPE_OTHER = @as(u32, 1);
pub const IF_TYPE_REGULAR_1822 = @as(u32, 2);
pub const IF_TYPE_HDH_1822 = @as(u32, 3);
pub const IF_TYPE_DDN_X25 = @as(u32, 4);
pub const IF_TYPE_RFC877_X25 = @as(u32, 5);
pub const IF_TYPE_ETHERNET_CSMACD = @as(u32, 6);
pub const IF_TYPE_IS088023_CSMACD = @as(u32, 7);
pub const IF_TYPE_ISO88024_TOKENBUS = @as(u32, 8);
pub const IF_TYPE_ISO88025_TOKENRING = @as(u32, 9);
pub const IF_TYPE_ISO88026_MAN = @as(u32, 10);
pub const IF_TYPE_STARLAN = @as(u32, 11);
pub const IF_TYPE_PROTEON_10MBIT = @as(u32, 12);
pub const IF_TYPE_PROTEON_80MBIT = @as(u32, 13);
pub const IF_TYPE_HYPERCHANNEL = @as(u32, 14);
pub const IF_TYPE_FDDI = @as(u32, 15);
pub const IF_TYPE_LAP_B = @as(u32, 16);
pub const IF_TYPE_SDLC = @as(u32, 17);
pub const IF_TYPE_DS1 = @as(u32, 18);
pub const IF_TYPE_E1 = @as(u32, 19);
pub const IF_TYPE_BASIC_ISDN = @as(u32, 20);
pub const IF_TYPE_PRIMARY_ISDN = @as(u32, 21);
pub const IF_TYPE_PROP_POINT2POINT_SERIAL = @as(u32, 22);
pub const IF_TYPE_PPP = @as(u32, 23);
pub const IF_TYPE_SOFTWARE_LOOPBACK = @as(u32, 24);
pub const IF_TYPE_EON = @as(u32, 25);
pub const IF_TYPE_ETHERNET_3MBIT = @as(u32, 26);
pub const IF_TYPE_NSIP = @as(u32, 27);
pub const IF_TYPE_SLIP = @as(u32, 28);
pub const IF_TYPE_ULTRA = @as(u32, 29);
pub const IF_TYPE_DS3 = @as(u32, 30);
pub const IF_TYPE_SIP = @as(u32, 31);
pub const IF_TYPE_FRAMERELAY = @as(u32, 32);
pub const IF_TYPE_RS232 = @as(u32, 33);
pub const IF_TYPE_PARA = @as(u32, 34);
pub const IF_TYPE_ARCNET = @as(u32, 35);
pub const IF_TYPE_ARCNET_PLUS = @as(u32, 36);
pub const IF_TYPE_ATM = @as(u32, 37);
pub const IF_TYPE_MIO_X25 = @as(u32, 38);
pub const IF_TYPE_SONET = @as(u32, 39);
pub const IF_TYPE_X25_PLE = @as(u32, 40);
pub const IF_TYPE_ISO88022_LLC = @as(u32, 41);
pub const IF_TYPE_LOCALTALK = @as(u32, 42);
pub const IF_TYPE_SMDS_DXI = @as(u32, 43);
pub const IF_TYPE_FRAMERELAY_SERVICE = @as(u32, 44);
pub const IF_TYPE_V35 = @as(u32, 45);
pub const IF_TYPE_HSSI = @as(u32, 46);
pub const IF_TYPE_HIPPI = @as(u32, 47);
pub const IF_TYPE_MODEM = @as(u32, 48);
pub const IF_TYPE_AAL5 = @as(u32, 49);
pub const IF_TYPE_SONET_PATH = @as(u32, 50);
pub const IF_TYPE_SONET_VT = @as(u32, 51);
pub const IF_TYPE_SMDS_ICIP = @as(u32, 52);
pub const IF_TYPE_PROP_VIRTUAL = @as(u32, 53);
pub const IF_TYPE_PROP_MULTIPLEXOR = @as(u32, 54);
pub const IF_TYPE_IEEE80212 = @as(u32, 55);
pub const IF_TYPE_FIBRECHANNEL = @as(u32, 56);
pub const IF_TYPE_HIPPIINTERFACE = @as(u32, 57);
pub const IF_TYPE_FRAMERELAY_INTERCONNECT = @as(u32, 58);
pub const IF_TYPE_AFLANE_8023 = @as(u32, 59);
pub const IF_TYPE_AFLANE_8025 = @as(u32, 60);
pub const IF_TYPE_CCTEMUL = @as(u32, 61);
pub const IF_TYPE_FASTETHER = @as(u32, 62);
pub const IF_TYPE_ISDN = @as(u32, 63);
pub const IF_TYPE_V11 = @as(u32, 64);
pub const IF_TYPE_V36 = @as(u32, 65);
pub const IF_TYPE_G703_64K = @as(u32, 66);
pub const IF_TYPE_G703_2MB = @as(u32, 67);
pub const IF_TYPE_QLLC = @as(u32, 68);
pub const IF_TYPE_FASTETHER_FX = @as(u32, 69);
pub const IF_TYPE_CHANNEL = @as(u32, 70);
pub const IF_TYPE_IEEE80211 = @as(u32, 71);
pub const IF_TYPE_IBM370PARCHAN = @as(u32, 72);
pub const IF_TYPE_ESCON = @as(u32, 73);
pub const IF_TYPE_DLSW = @as(u32, 74);
pub const IF_TYPE_ISDN_S = @as(u32, 75);
pub const IF_TYPE_ISDN_U = @as(u32, 76);
pub const IF_TYPE_LAP_D = @as(u32, 77);
pub const IF_TYPE_IPSWITCH = @as(u32, 78);
pub const IF_TYPE_RSRB = @as(u32, 79);
pub const IF_TYPE_ATM_LOGICAL = @as(u32, 80);
pub const IF_TYPE_DS0 = @as(u32, 81);
pub const IF_TYPE_DS0_BUNDLE = @as(u32, 82);
pub const IF_TYPE_BSC = @as(u32, 83);
pub const IF_TYPE_ASYNC = @as(u32, 84);
pub const IF_TYPE_CNR = @as(u32, 85);
pub const IF_TYPE_ISO88025R_DTR = @as(u32, 86);
pub const IF_TYPE_EPLRS = @as(u32, 87);
pub const IF_TYPE_ARAP = @as(u32, 88);
pub const IF_TYPE_PROP_CNLS = @as(u32, 89);
pub const IF_TYPE_HOSTPAD = @as(u32, 90);
pub const IF_TYPE_TERMPAD = @as(u32, 91);
pub const IF_TYPE_FRAMERELAY_MPI = @as(u32, 92);
pub const IF_TYPE_X213 = @as(u32, 93);
pub const IF_TYPE_ADSL = @as(u32, 94);
pub const IF_TYPE_RADSL = @as(u32, 95);
pub const IF_TYPE_SDSL = @as(u32, 96);
pub const IF_TYPE_VDSL = @as(u32, 97);
pub const IF_TYPE_ISO88025_CRFPRINT = @as(u32, 98);
pub const IF_TYPE_MYRINET = @as(u32, 99);
pub const IF_TYPE_VOICE_EM = @as(u32, 100);
pub const IF_TYPE_VOICE_FXO = @as(u32, 101);
pub const IF_TYPE_VOICE_FXS = @as(u32, 102);
pub const IF_TYPE_VOICE_ENCAP = @as(u32, 103);
pub const IF_TYPE_VOICE_OVERIP = @as(u32, 104);
pub const IF_TYPE_ATM_DXI = @as(u32, 105);
pub const IF_TYPE_ATM_FUNI = @as(u32, 106);
pub const IF_TYPE_ATM_IMA = @as(u32, 107);
pub const IF_TYPE_PPPMULTILINKBUNDLE = @as(u32, 108);
pub const IF_TYPE_IPOVER_CDLC = @as(u32, 109);
pub const IF_TYPE_IPOVER_CLAW = @as(u32, 110);
pub const IF_TYPE_STACKTOSTACK = @as(u32, 111);
pub const IF_TYPE_VIRTUALIPADDRESS = @as(u32, 112);
pub const IF_TYPE_MPC = @as(u32, 113);
pub const IF_TYPE_IPOVER_ATM = @as(u32, 114);
pub const IF_TYPE_ISO88025_FIBER = @as(u32, 115);
pub const IF_TYPE_TDLC = @as(u32, 116);
pub const IF_TYPE_GIGABITETHERNET = @as(u32, 117);
pub const IF_TYPE_HDLC = @as(u32, 118);
pub const IF_TYPE_LAP_F = @as(u32, 119);
pub const IF_TYPE_V37 = @as(u32, 120);
pub const IF_TYPE_X25_MLP = @as(u32, 121);
pub const IF_TYPE_X25_HUNTGROUP = @as(u32, 122);
pub const IF_TYPE_TRANSPHDLC = @as(u32, 123);
pub const IF_TYPE_INTERLEAVE = @as(u32, 124);
pub const IF_TYPE_FAST = @as(u32, 125);
pub const IF_TYPE_IP = @as(u32, 126);
pub const IF_TYPE_DOCSCABLE_MACLAYER = @as(u32, 127);
pub const IF_TYPE_DOCSCABLE_DOWNSTREAM = @as(u32, 128);
pub const IF_TYPE_DOCSCABLE_UPSTREAM = @as(u32, 129);
pub const IF_TYPE_A12MPPSWITCH = @as(u32, 130);
pub const IF_TYPE_TUNNEL = @as(u32, 131);
pub const IF_TYPE_COFFEE = @as(u32, 132);
pub const IF_TYPE_CES = @as(u32, 133);
pub const IF_TYPE_ATM_SUBINTERFACE = @as(u32, 134);
pub const IF_TYPE_L2_VLAN = @as(u32, 135);
pub const IF_TYPE_L3_IPVLAN = @as(u32, 136);
pub const IF_TYPE_L3_IPXVLAN = @as(u32, 137);
pub const IF_TYPE_DIGITALPOWERLINE = @as(u32, 138);
pub const IF_TYPE_MEDIAMAILOVERIP = @as(u32, 139);
pub const IF_TYPE_DTM = @as(u32, 140);
pub const IF_TYPE_DCN = @as(u32, 141);
pub const IF_TYPE_IPFORWARD = @as(u32, 142);
pub const IF_TYPE_MSDSL = @as(u32, 143);
pub const IF_TYPE_IEEE1394 = @as(u32, 144);
pub const IF_TYPE_IF_GSN = @as(u32, 145);
pub const IF_TYPE_DVBRCC_MACLAYER = @as(u32, 146);
pub const IF_TYPE_DVBRCC_DOWNSTREAM = @as(u32, 147);
pub const IF_TYPE_DVBRCC_UPSTREAM = @as(u32, 148);
pub const IF_TYPE_ATM_VIRTUAL = @as(u32, 149);
pub const IF_TYPE_MPLS_TUNNEL = @as(u32, 150);
pub const IF_TYPE_SRP = @as(u32, 151);
pub const IF_TYPE_VOICEOVERATM = @as(u32, 152);
pub const IF_TYPE_VOICEOVERFRAMERELAY = @as(u32, 153);
pub const IF_TYPE_IDSL = @as(u32, 154);
pub const IF_TYPE_COMPOSITELINK = @as(u32, 155);
pub const IF_TYPE_SS7_SIGLINK = @as(u32, 156);
pub const IF_TYPE_PROP_WIRELESS_P2P = @as(u32, 157);
pub const IF_TYPE_FR_FORWARD = @as(u32, 158);
pub const IF_TYPE_RFC1483 = @as(u32, 159);
pub const IF_TYPE_USB = @as(u32, 160);
pub const IF_TYPE_IEEE8023AD_LAG = @as(u32, 161);
pub const IF_TYPE_BGP_POLICY_ACCOUNTING = @as(u32, 162);
pub const IF_TYPE_FRF16_MFR_BUNDLE = @as(u32, 163);
pub const IF_TYPE_H323_GATEKEEPER = @as(u32, 164);
pub const IF_TYPE_H323_PROXY = @as(u32, 165);
pub const IF_TYPE_MPLS = @as(u32, 166);
pub const IF_TYPE_MF_SIGLINK = @as(u32, 167);
pub const IF_TYPE_HDSL2 = @as(u32, 168);
pub const IF_TYPE_SHDSL = @as(u32, 169);
pub const IF_TYPE_DS1_FDL = @as(u32, 170);
pub const IF_TYPE_POS = @as(u32, 171);
pub const IF_TYPE_DVB_ASI_IN = @as(u32, 172);
pub const IF_TYPE_DVB_ASI_OUT = @as(u32, 173);
pub const IF_TYPE_PLC = @as(u32, 174);
pub const IF_TYPE_NFAS = @as(u32, 175);
pub const IF_TYPE_TR008 = @as(u32, 176);
pub const IF_TYPE_GR303_RDT = @as(u32, 177);
pub const IF_TYPE_GR303_IDT = @as(u32, 178);
pub const IF_TYPE_ISUP = @as(u32, 179);
pub const IF_TYPE_PROP_DOCS_WIRELESS_MACLAYER = @as(u32, 180);
pub const IF_TYPE_PROP_DOCS_WIRELESS_DOWNSTREAM = @as(u32, 181);
pub const IF_TYPE_PROP_DOCS_WIRELESS_UPSTREAM = @as(u32, 182);
pub const IF_TYPE_HIPERLAN2 = @as(u32, 183);
pub const IF_TYPE_PROP_BWA_P2MP = @as(u32, 184);
pub const IF_TYPE_SONET_OVERHEAD_CHANNEL = @as(u32, 185);
pub const IF_TYPE_DIGITAL_WRAPPER_OVERHEAD_CHANNEL = @as(u32, 186);
pub const IF_TYPE_AAL2 = @as(u32, 187);
pub const IF_TYPE_RADIO_MAC = @as(u32, 188);
pub const IF_TYPE_ATM_RADIO = @as(u32, 189);
pub const IF_TYPE_IMT = @as(u32, 190);
pub const IF_TYPE_MVL = @as(u32, 191);
pub const IF_TYPE_REACH_DSL = @as(u32, 192);
pub const IF_TYPE_FR_DLCI_ENDPT = @as(u32, 193);
pub const IF_TYPE_ATM_VCI_ENDPT = @as(u32, 194);
pub const IF_TYPE_OPTICAL_CHANNEL = @as(u32, 195);
pub const IF_TYPE_OPTICAL_TRANSPORT = @as(u32, 196);
pub const IF_TYPE_IEEE80216_WMAN = @as(u32, 237);
pub const IF_TYPE_WWANPP = @as(u32, 243);
pub const IF_TYPE_WWANPP2 = @as(u32, 244);
pub const IF_TYPE_IEEE802154 = @as(u32, 259);
pub const IF_TYPE_XBOX_WIRELESS = @as(u32, 281);
pub const MAX_IF_TYPE = @as(u32, 281);
pub const IF_CHECK_NONE = @as(u32, 0);
pub const IF_CHECK_MCAST = @as(u32, 1);
pub const IF_CHECK_SEND = @as(u32, 2);
pub const IF_CONNECTION_DEDICATED = @as(u32, 1);
pub const IF_CONNECTION_PASSIVE = @as(u32, 2);
pub const IF_CONNECTION_DEMAND = @as(u32, 3);
pub const IF_ADMIN_STATUS_UP = @as(u32, 1);
pub const IF_ADMIN_STATUS_DOWN = @as(u32, 2);
pub const IF_ADMIN_STATUS_TESTING = @as(u32, 3);
pub const MIB_IF_TYPE_OTHER = @as(u32, 1);
pub const MIB_IF_TYPE_ETHERNET = @as(u32, 6);
pub const MIB_IF_TYPE_TOKENRING = @as(u32, 9);
pub const MIB_IF_TYPE_FDDI = @as(u32, 15);
pub const MIB_IF_TYPE_PPP = @as(u32, 23);
pub const MIB_IF_TYPE_LOOPBACK = @as(u32, 24);
pub const MIB_IF_TYPE_SLIP = @as(u32, 28);
pub const MIB_IF_ADMIN_STATUS_UP = @as(u32, 1);
pub const MIB_IF_ADMIN_STATUS_DOWN = @as(u32, 2);
pub const MIB_IF_ADMIN_STATUS_TESTING = @as(u32, 3);
pub const INTERFACE_TIMESTAMP_CAPABILITIES_VERSION_1 = @as(u32, 1);
pub const INTERFACE_HARDWARE_CROSSTIMESTAMP_VERSION_1 = @as(u32, 1);
pub const NET_STRING_IPV4_ADDRESS = @as(u32, 1);
pub const NET_STRING_IPV4_SERVICE = @as(u32, 2);
pub const NET_STRING_IPV4_NETWORK = @as(u32, 4);
pub const NET_STRING_IPV6_ADDRESS = @as(u32, 8);
pub const NET_STRING_IPV6_ADDRESS_NO_SCOPE = @as(u32, 16);
pub const NET_STRING_IPV6_SERVICE = @as(u32, 32);
pub const NET_STRING_IPV6_SERVICE_NO_SCOPE = @as(u32, 64);
pub const NET_STRING_IPV6_NETWORK = @as(u32, 128);
pub const NET_STRING_NAMED_ADDRESS = @as(u32, 256);
pub const NET_STRING_NAMED_SERVICE = @as(u32, 512);
pub const MIB_INVALID_TEREDO_PORT_NUMBER = @as(u32, 0);
pub const DNS_SETTINGS_VERSION1 = @as(u32, 1);
pub const DNS_INTERFACE_SETTINGS_VERSION1 = @as(u32, 1);
pub const DNS_INTERFACE_SETTINGS_VERSION2 = @as(u32, 2);
pub const DNS_SETTING_IPV6 = @as(u32, 1);
pub const DNS_SETTING_NAMESERVER = @as(u32, 2);
pub const DNS_SETTING_SEARCHLIST = @as(u32, 4);
pub const DNS_SETTING_REGISTRATION_ENABLED = @as(u32, 8);
pub const DNS_SETTING_REGISTER_ADAPTER_NAME = @as(u32, 16);
pub const DNS_SETTING_DOMAIN = @as(u32, 32);
pub const DNS_SETTING_HOSTNAME = @as(u32, 64);
pub const DNS_SETTINGS_ENABLE_LLMNR = @as(u32, 128);
pub const DNS_SETTINGS_QUERY_ADAPTER_NAME = @as(u32, 256);
pub const DNS_SETTING_PROFILE_NAMESERVER = @as(u32, 512);
pub const DNS_SETTING_DISABLE_UNCONSTRAINED_QUERIES = @as(u32, 1024);
pub const DNS_SETTING_SUPPLEMENTAL_SEARCH_LIST = @as(u32, 2048);
pub const IP_EXPORT_INCLUDED = @as(u32, 1);
pub const MAX_ADAPTER_NAME = @as(u32, 128);
pub const IP_STATUS_BASE = @as(u32, 11000);
pub const IP_SUCCESS = @as(u32, 0);
pub const IP_OPT_EOL = @as(u32, 0);
pub const IP_OPT_NOP = @as(u32, 1);
pub const IP_OPT_SECURITY = @as(u32, 130);
pub const IP_OPT_LSRR = @as(u32, 131);
pub const IP_OPT_SSRR = @as(u32, 137);
pub const IP_OPT_RR = @as(u32, 7);
pub const IP_OPT_TS = @as(u32, 68);
pub const IP_OPT_SID = @as(u32, 136);
pub const IP_OPT_ROUTER_ALERT = @as(u32, 148);
pub const MAX_OPT_SIZE = @as(u32, 40);
pub const IOCTL_IP_RTCHANGE_NOTIFY_REQUEST = @as(u32, 101);
pub const IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST = @as(u32, 102);
pub const IOCTL_ARP_SEND_REQUEST = @as(u32, 103);
pub const IOCTL_IP_INTERFACE_INFO = @as(u32, 104);
pub const IOCTL_IP_GET_BEST_INTERFACE = @as(u32, 105);
pub const IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS = @as(u32, 106);

//--------------------------------------------------------------------------------
// Section: Types (102)
//--------------------------------------------------------------------------------
// TODO: this type has a FreeFunc 'IcmpCloseHandle', what can Zig do with this information?
pub const IcmpHandle = ?*c_void;

pub const HIFTIMESTAMPCHANGE = ?*c_void;

pub const NET_ADDRESS_INFO = extern struct {
    comment: [*]const u8 = "TODO: why is this struct empty?"
};

pub const SCOPE_LEVEL = extern enum(i32) {
    Interface = 1,
    Link = 2,
    Subnet = 3,
    Admin = 4,
    Site = 5,
    Organization = 8,
    Global = 14,
    Count = 16,
};
pub const ScopeLevelInterface = SCOPE_LEVEL.Interface;
pub const ScopeLevelLink = SCOPE_LEVEL.Link;
pub const ScopeLevelSubnet = SCOPE_LEVEL.Subnet;
pub const ScopeLevelAdmin = SCOPE_LEVEL.Admin;
pub const ScopeLevelSite = SCOPE_LEVEL.Site;
pub const ScopeLevelOrganization = SCOPE_LEVEL.Organization;
pub const ScopeLevelGlobal = SCOPE_LEVEL.Global;
pub const ScopeLevelCount = SCOPE_LEVEL.Count;

pub const SOCKADDR_INET = u32; // TODO: implement StructOrUnion types?

pub const SOCKADDR_IN6_PAIR = extern struct {
    SourceAddress: *SOCKADDR_IN6_LH,
    DestinationAddress: *SOCKADDR_IN6_LH,
};

pub const NL_PREFIX_ORIGIN = extern enum(i32) {
    Other = 0,
    Manual = 1,
    WellKnown = 2,
    Dhcp = 3,
    RouterAdvertisement = 4,
    Unchanged = 16,
};
pub const IpPrefixOriginOther = NL_PREFIX_ORIGIN.Other;
pub const IpPrefixOriginManual = NL_PREFIX_ORIGIN.Manual;
pub const IpPrefixOriginWellKnown = NL_PREFIX_ORIGIN.WellKnown;
pub const IpPrefixOriginDhcp = NL_PREFIX_ORIGIN.Dhcp;
pub const IpPrefixOriginRouterAdvertisement = NL_PREFIX_ORIGIN.RouterAdvertisement;
pub const IpPrefixOriginUnchanged = NL_PREFIX_ORIGIN.Unchanged;

pub const NL_SUFFIX_ORIGIN = extern enum(i32) {
    NlsoOther = 0,
    NlsoManual = 1,
    NlsoWellKnown = 2,
    NlsoDhcp = 3,
    NlsoLinkLayerAddress = 4,
    NlsoRandom = 5,
    IpSuffixOriginOther = 0,
    IpSuffixOriginManual = 1,
    IpSuffixOriginWellKnown = 2,
    IpSuffixOriginDhcp = 3,
    IpSuffixOriginLinkLayerAddress = 4,
    IpSuffixOriginRandom = 5,
    IpSuffixOriginUnchanged = 16,
};
pub const NlsoOther = NL_SUFFIX_ORIGIN.NlsoOther;
pub const NlsoManual = NL_SUFFIX_ORIGIN.NlsoManual;
pub const NlsoWellKnown = NL_SUFFIX_ORIGIN.NlsoWellKnown;
pub const NlsoDhcp = NL_SUFFIX_ORIGIN.NlsoDhcp;
pub const NlsoLinkLayerAddress = NL_SUFFIX_ORIGIN.NlsoLinkLayerAddress;
pub const NlsoRandom = NL_SUFFIX_ORIGIN.NlsoRandom;
pub const IpSuffixOriginOther = NL_SUFFIX_ORIGIN.IpSuffixOriginOther;
pub const IpSuffixOriginManual = NL_SUFFIX_ORIGIN.IpSuffixOriginManual;
pub const IpSuffixOriginWellKnown = NL_SUFFIX_ORIGIN.IpSuffixOriginWellKnown;
pub const IpSuffixOriginDhcp = NL_SUFFIX_ORIGIN.IpSuffixOriginDhcp;
pub const IpSuffixOriginLinkLayerAddress = NL_SUFFIX_ORIGIN.IpSuffixOriginLinkLayerAddress;
pub const IpSuffixOriginRandom = NL_SUFFIX_ORIGIN.IpSuffixOriginRandom;
pub const IpSuffixOriginUnchanged = NL_SUFFIX_ORIGIN.IpSuffixOriginUnchanged;

pub const NL_DAD_STATE = extern enum(i32) {
    NldsInvalid = 0,
    NldsTentative = 1,
    NldsDuplicate = 2,
    NldsDeprecated = 3,
    NldsPreferred = 4,
    IpDadStateInvalid = 0,
    IpDadStateTentative = 1,
    IpDadStateDuplicate = 2,
    IpDadStateDeprecated = 3,
    IpDadStatePreferred = 4,
};
pub const NldsInvalid = NL_DAD_STATE.NldsInvalid;
pub const NldsTentative = NL_DAD_STATE.NldsTentative;
pub const NldsDuplicate = NL_DAD_STATE.NldsDuplicate;
pub const NldsDeprecated = NL_DAD_STATE.NldsDeprecated;
pub const NldsPreferred = NL_DAD_STATE.NldsPreferred;
pub const IpDadStateInvalid = NL_DAD_STATE.IpDadStateInvalid;
pub const IpDadStateTentative = NL_DAD_STATE.IpDadStateTentative;
pub const IpDadStateDuplicate = NL_DAD_STATE.IpDadStateDuplicate;
pub const IpDadStateDeprecated = NL_DAD_STATE.IpDadStateDeprecated;
pub const IpDadStatePreferred = NL_DAD_STATE.IpDadStatePreferred;

pub const NL_NETWORK_CONNECTIVITY_LEVEL_HINT = extern enum(i32) {
    Unknown = 0,
    None = 1,
    LocalAccess = 2,
    InternetAccess = 3,
    ConstrainedInternetAccess = 4,
    Hidden = 5,
};
pub const NetworkConnectivityLevelHintUnknown = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.Unknown;
pub const NetworkConnectivityLevelHintNone = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.None;
pub const NetworkConnectivityLevelHintLocalAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.LocalAccess;
pub const NetworkConnectivityLevelHintInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.InternetAccess;
pub const NetworkConnectivityLevelHintConstrainedInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.ConstrainedInternetAccess;
pub const NetworkConnectivityLevelHintHidden = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.Hidden;

pub const NL_NETWORK_CONNECTIVITY_COST_HINT = extern enum(i32) {
    Unknown = 0,
    Unrestricted = 1,
    Fixed = 2,
    Variable = 3,
};
pub const NetworkConnectivityCostHintUnknown = NL_NETWORK_CONNECTIVITY_COST_HINT.Unknown;
pub const NetworkConnectivityCostHintUnrestricted = NL_NETWORK_CONNECTIVITY_COST_HINT.Unrestricted;
pub const NetworkConnectivityCostHintFixed = NL_NETWORK_CONNECTIVITY_COST_HINT.Fixed;
pub const NetworkConnectivityCostHintVariable = NL_NETWORK_CONNECTIVITY_COST_HINT.Variable;

pub const NL_NETWORK_CONNECTIVITY_HINT = extern struct {
    ConnectivityLevel: NL_NETWORK_CONNECTIVITY_LEVEL_HINT,
    ConnectivityCost: NL_NETWORK_CONNECTIVITY_COST_HINT,
    ApproachingDataLimit: u8,
    OverDataLimit: u8,
    Roaming: u8,
};

pub const NL_BANDWIDTH_INFORMATION = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: u8,
};

pub const Get_Family = extern enum(u32) {
    INET = 2,
    INET6 = 23,
    UNSPEC = 0,
};
pub const AF_INET = Get_Family.INET;
pub const AF_INET6 = Get_Family.INET6;
pub const AF_UNSPEC = Get_Family.UNSPEC;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const GetAdaptersAddresses_Flags = extern enum(u32) {
    SKIP_UNICAST = 1,
    SKIP_ANYCAST = 2,
    SKIP_MULTICAST = 4,
    SKIP_DNS_SERVER = 8,
    INCLUDE_PREFIX = 16,
    SKIP_FRIENDLY_NAME = 32,
    INCLUDE_WINS_INFO = 64,
    INCLUDE_GATEWAYS = 128,
    INCLUDE_ALL_INTERFACES = 256,
    INCLUDE_ALL_COMPARTMENTS = 512,
    INCLUDE_TUNNEL_BINDINGORDER = 1024,
    _,
};
pub const GAA_FLAG_SKIP_UNICAST = GetAdaptersAddresses_Flags.SKIP_UNICAST;
pub const GAA_FLAG_SKIP_ANYCAST = GetAdaptersAddresses_Flags.SKIP_ANYCAST;
pub const GAA_FLAG_SKIP_MULTICAST = GetAdaptersAddresses_Flags.SKIP_MULTICAST;
pub const GAA_FLAG_SKIP_DNS_SERVER = GetAdaptersAddresses_Flags.SKIP_DNS_SERVER;
pub const GAA_FLAG_INCLUDE_PREFIX = GetAdaptersAddresses_Flags.INCLUDE_PREFIX;
pub const GAA_FLAG_SKIP_FRIENDLY_NAME = GetAdaptersAddresses_Flags.SKIP_FRIENDLY_NAME;
pub const GAA_FLAG_INCLUDE_WINS_INFO = GetAdaptersAddresses_Flags.INCLUDE_WINS_INFO;
pub const GAA_FLAG_INCLUDE_GATEWAYS = GetAdaptersAddresses_Flags.INCLUDE_GATEWAYS;
pub const GAA_FLAG_INCLUDE_ALL_INTERFACES = GetAdaptersAddresses_Flags.INCLUDE_ALL_INTERFACES;
pub const GAA_FLAG_INCLUDE_ALL_COMPARTMENTS = GetAdaptersAddresses_Flags.INCLUDE_ALL_COMPARTMENTS;
pub const GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER = GetAdaptersAddresses_Flags.INCLUDE_TUNNEL_BINDINGORDER;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const IP_FLAG = extern enum(u32) {
    REVERSE = 1,
    DF = 2,
    _,
};
pub const IP_FLAG_REVERSE = IP_FLAG.REVERSE;
pub const IP_FLAG_DF = IP_FLAG.DF;

pub const ip_option_information = extern struct {
    Ttl: u8,
    Tos: u8,
    Flags: u8,
    OptionsSize: u8,
    OptionsData: *u8,
};

pub const icmp_echo_reply = extern struct {
    Address: u32,
    Status: u32,
    RoundTripTime: u32,
    DataSize: u16,
    Reserved: u16,
    Data: *c_void,
    Options: ip_option_information,
};

pub const IPV6_ADDRESS_EX = extern struct {
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: [8]u16,
    sin6_scope_id: u32,
};

pub const icmpv6_echo_reply_lh = extern struct {
    Address: IPV6_ADDRESS_EX,
    Status: u32,
    RoundTripTime: u32,
};

pub const arp_send_reply = extern struct {
    DestAddress: u32,
    SrcAddress: u32,
};

pub const tcp_reserve_port_range = extern struct {
    UpperRange: u16,
    LowerRange: u16,
};

pub const IP_ADAPTER_INDEX_MAP = extern struct {
    Index: u32,
    Name: [128]u16,
};

pub const IP_INTERFACE_INFO = extern struct {
    NumAdapters: i32,
    Adapter: [1]IP_ADAPTER_INDEX_MAP,
};

pub const IP_UNIDIRECTIONAL_ADAPTER_ADDRESS = extern struct {
    NumAdapters: u32,
    Address: [1]u32,
};

pub const IP_ADAPTER_ORDER_MAP = extern struct {
    NumAdapters: u32,
    AdapterOrder: [1]u32,
};

pub const IP_MCAST_COUNTER_INFO = extern struct {
    InMcastOctets: u64,
    OutMcastOctets: u64,
    InMcastPkts: u64,
    OutMcastPkts: u64,
};

pub const IF_ACCESS_TYPE = extern enum(i32) {
    LOOPBACK = 1,
    BROADCAST = 2,
    POINT_TO_POINT = 3,
    POINTTOPOINT = 3,
    POINT_TO_MULTI_POINT = 4,
    POINTTOMULTIPOINT = 4,
};
pub const IF_ACCESS_LOOPBACK = IF_ACCESS_TYPE.LOOPBACK;
pub const IF_ACCESS_BROADCAST = IF_ACCESS_TYPE.BROADCAST;
pub const IF_ACCESS_POINT_TO_POINT = IF_ACCESS_TYPE.POINT_TO_POINT;
pub const IF_ACCESS_POINTTOPOINT = IF_ACCESS_TYPE.POINTTOPOINT;
pub const IF_ACCESS_POINT_TO_MULTI_POINT = IF_ACCESS_TYPE.POINT_TO_MULTI_POINT;
pub const IF_ACCESS_POINTTOMULTIPOINT = IF_ACCESS_TYPE.POINTTOMULTIPOINT;

pub const INTERNAL_IF_OPER_STATUS = extern enum(i32) {
    NON_OPERATIONAL = 0,
    UNREACHABLE = 1,
    DISCONNECTED = 2,
    CONNECTING = 3,
    CONNECTED = 4,
    OPERATIONAL = 5,
};
pub const IF_OPER_STATUS_NON_OPERATIONAL = INTERNAL_IF_OPER_STATUS.NON_OPERATIONAL;
pub const IF_OPER_STATUS_UNREACHABLE = INTERNAL_IF_OPER_STATUS.UNREACHABLE;
pub const IF_OPER_STATUS_DISCONNECTED = INTERNAL_IF_OPER_STATUS.DISCONNECTED;
pub const IF_OPER_STATUS_CONNECTING = INTERNAL_IF_OPER_STATUS.CONNECTING;
pub const IF_OPER_STATUS_CONNECTED = INTERNAL_IF_OPER_STATUS.CONNECTED;
pub const IF_OPER_STATUS_OPERATIONAL = INTERNAL_IF_OPER_STATUS.OPERATIONAL;

pub const NET_IF_RCV_ADDRESS_TYPE = extern enum(i32) {
    OTHER = 1,
    VOLATILE = 2,
    NON_VOLATILE = 3,
};
pub const NET_IF_RCV_ADDRESS_TYPE_OTHER = NET_IF_RCV_ADDRESS_TYPE.OTHER;
pub const NET_IF_RCV_ADDRESS_TYPE_VOLATILE = NET_IF_RCV_ADDRESS_TYPE.VOLATILE;
pub const NET_IF_RCV_ADDRESS_TYPE_NON_VOLATILE = NET_IF_RCV_ADDRESS_TYPE.NON_VOLATILE;

pub const NET_IF_RCV_ADDRESS_LH = extern struct {
    ifRcvAddressType: NET_IF_RCV_ADDRESS_TYPE,
    ifRcvAddressLength: u16,
    ifRcvAddressOffset: u16,
};

pub const NET_IF_ALIAS_LH = extern struct {
    ifAliasLength: u16,
    ifAliasOffset: u16,
};

pub const NET_LUID_LH = u32; // TODO: implement StructOrUnion types?

pub const IF_PHYSICAL_ADDRESS_LH = extern struct {
    Length: u16,
    Address: [32]u8,
};

pub const IF_ADMINISTRATIVE_STATE = extern enum(i32) {
    DISABLED = 0,
    ENABLED = 1,
    DEMANDDIAL = 2,
};
pub const IF_ADMINISTRATIVE_DISABLED = IF_ADMINISTRATIVE_STATE.DISABLED;
pub const IF_ADMINISTRATIVE_ENABLED = IF_ADMINISTRATIVE_STATE.ENABLED;
pub const IF_ADMINISTRATIVE_DEMANDDIAL = IF_ADMINISTRATIVE_STATE.DEMANDDIAL;

pub const IF_OPER_STATUS = extern enum(i32) {
    Up = 1,
    Down = 2,
    Testing = 3,
    Unknown = 4,
    Dormant = 5,
    NotPresent = 6,
    LowerLayerDown = 7,
};
pub const IfOperStatusUp = IF_OPER_STATUS.Up;
pub const IfOperStatusDown = IF_OPER_STATUS.Down;
pub const IfOperStatusTesting = IF_OPER_STATUS.Testing;
pub const IfOperStatusUnknown = IF_OPER_STATUS.Unknown;
pub const IfOperStatusDormant = IF_OPER_STATUS.Dormant;
pub const IfOperStatusNotPresent = IF_OPER_STATUS.NotPresent;
pub const IfOperStatusLowerLayerDown = IF_OPER_STATUS.LowerLayerDown;

pub const MIB_IF_ENTRY_LEVEL = extern enum(i32) {
    l = 0,
    WithoutStatistics = 2,
};
pub const MibIfEntryNormal = MIB_IF_ENTRY_LEVEL.l;
pub const MibIfEntryNormalWithoutStatistics = MIB_IF_ENTRY_LEVEL.WithoutStatistics;

pub const PIPINTERFACE_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Row: *MIB_IPINTERFACE_ROW,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PUNICAST_IPADDRESS_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK = fn(
    CallerContext: *c_void,
    AddressTable: *MIB_UNICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const IP_ADDRESS_PREFIX = extern struct {
    Prefix: SOCKADDR_INET,
    PrefixLength: u8,
};

pub const PIPFORWARD_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Row: ?*MIB_IPFORWARD_ROW2,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PTEREDO_PORT_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Port: u16,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const DNS_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Hostname: PWSTR,
    Domain: PWSTR,
    SearchList: PWSTR,
};

pub const DNS_INTERFACE_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Domain: PWSTR,
    NameServer: PWSTR,
    SearchList: PWSTR,
    RegistrationEnabled: u32,
    RegisterAdapterName: u32,
    EnableLLMNR: u32,
    QueryAdapterName: u32,
    ProfileNameServer: PWSTR,
};

pub const DNS_INTERFACE_SETTINGS_EX = extern struct {
    SettingsV1: DNS_INTERFACE_SETTINGS,
    DisableUnconstrainedQueries: u32,
    SupplementalSearchList: PWSTR,
};

pub const PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    ConnectivityHint: NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIB_IPFORWARD_TYPE = extern enum(i32) {
    OTHER = 1,
    INVALID = 2,
    DIRECT = 3,
    INDIRECT = 4,
};
// TODO: enum 'MIB_IPFORWARD_TYPE' has known issues with its value aliases

pub const MIB_IPNET_TYPE = extern enum(i32) {
    OTHER = 1,
    INVALID = 2,
    DYNAMIC = 3,
    STATIC = 4,
};
pub const MIB_IPNET_TYPE_OTHER = MIB_IPNET_TYPE.OTHER;
pub const MIB_IPNET_TYPE_INVALID = MIB_IPNET_TYPE.INVALID;
pub const MIB_IPNET_TYPE_DYNAMIC = MIB_IPNET_TYPE.DYNAMIC;
pub const MIB_IPNET_TYPE_STATIC = MIB_IPNET_TYPE.STATIC;

pub const MIB_IPSTATS_FORWARDING = extern enum(i32) {
    FORWARDING = 1,
    NOT_FORWARDING = 2,
};
pub const MIB_IP_FORWARDING = MIB_IPSTATS_FORWARDING.FORWARDING;
pub const MIB_IP_NOT_FORWARDING = MIB_IPSTATS_FORWARDING.NOT_FORWARDING;

pub const MIB_TCP_STATE = extern enum(i32) {
    CLOSED = 1,
    LISTEN = 2,
    SYN_SENT = 3,
    SYN_RCVD = 4,
    ESTAB = 5,
    FIN_WAIT1 = 6,
    FIN_WAIT2 = 7,
    CLOSE_WAIT = 8,
    CLOSING = 9,
    LAST_ACK = 10,
    TIME_WAIT = 11,
    DELETE_TCB = 12,
    RESERVED = 100,
};
pub const MIB_TCP_STATE_CLOSED = MIB_TCP_STATE.CLOSED;
pub const MIB_TCP_STATE_LISTEN = MIB_TCP_STATE.LISTEN;
pub const MIB_TCP_STATE_SYN_SENT = MIB_TCP_STATE.SYN_SENT;
pub const MIB_TCP_STATE_SYN_RCVD = MIB_TCP_STATE.SYN_RCVD;
pub const MIB_TCP_STATE_ESTAB = MIB_TCP_STATE.ESTAB;
pub const MIB_TCP_STATE_FIN_WAIT1 = MIB_TCP_STATE.FIN_WAIT1;
pub const MIB_TCP_STATE_FIN_WAIT2 = MIB_TCP_STATE.FIN_WAIT2;
pub const MIB_TCP_STATE_CLOSE_WAIT = MIB_TCP_STATE.CLOSE_WAIT;
pub const MIB_TCP_STATE_CLOSING = MIB_TCP_STATE.CLOSING;
pub const MIB_TCP_STATE_LAST_ACK = MIB_TCP_STATE.LAST_ACK;
pub const MIB_TCP_STATE_TIME_WAIT = MIB_TCP_STATE.TIME_WAIT;
pub const MIB_TCP_STATE_DELETE_TCB = MIB_TCP_STATE.DELETE_TCB;
pub const MIB_TCP_STATE_RESERVED = MIB_TCP_STATE.RESERVED;

pub const TCP_RTO_ALGORITHM = extern enum(i32) {
    TcpRtoAlgorithmOther = 1,
    TcpRtoAlgorithmConstant = 2,
    TcpRtoAlgorithmRsre = 3,
    TcpRtoAlgorithmVanj = 4,
    MIB_TCP_RTO_OTHER = 1,
    MIB_TCP_RTO_CONSTANT = 2,
    MIB_TCP_RTO_RSRE = 3,
    MIB_TCP_RTO_VANJ = 4,
};
pub const TcpRtoAlgorithmOther = TCP_RTO_ALGORITHM.TcpRtoAlgorithmOther;
pub const TcpRtoAlgorithmConstant = TCP_RTO_ALGORITHM.TcpRtoAlgorithmConstant;
pub const TcpRtoAlgorithmRsre = TCP_RTO_ALGORITHM.TcpRtoAlgorithmRsre;
pub const TcpRtoAlgorithmVanj = TCP_RTO_ALGORITHM.TcpRtoAlgorithmVanj;
pub const MIB_TCP_RTO_OTHER = TCP_RTO_ALGORITHM.MIB_TCP_RTO_OTHER;
pub const MIB_TCP_RTO_CONSTANT = TCP_RTO_ALGORITHM.MIB_TCP_RTO_CONSTANT;
pub const MIB_TCP_RTO_RSRE = TCP_RTO_ALGORITHM.MIB_TCP_RTO_RSRE;
pub const MIB_TCP_RTO_VANJ = TCP_RTO_ALGORITHM.MIB_TCP_RTO_VANJ;

pub const TCP_TABLE_CLASS = extern enum(i32) {
    BASIC_LISTENER = 0,
    BASIC_CONNECTIONS = 1,
    BASIC_ALL = 2,
    OWNER_PID_LISTENER = 3,
    OWNER_PID_CONNECTIONS = 4,
    OWNER_PID_ALL = 5,
    OWNER_MODULE_LISTENER = 6,
    OWNER_MODULE_CONNECTIONS = 7,
    OWNER_MODULE_ALL = 8,
};
pub const TCP_TABLE_BASIC_LISTENER = TCP_TABLE_CLASS.BASIC_LISTENER;
pub const TCP_TABLE_BASIC_CONNECTIONS = TCP_TABLE_CLASS.BASIC_CONNECTIONS;
pub const TCP_TABLE_BASIC_ALL = TCP_TABLE_CLASS.BASIC_ALL;
pub const TCP_TABLE_OWNER_PID_LISTENER = TCP_TABLE_CLASS.OWNER_PID_LISTENER;
pub const TCP_TABLE_OWNER_PID_CONNECTIONS = TCP_TABLE_CLASS.OWNER_PID_CONNECTIONS;
pub const TCP_TABLE_OWNER_PID_ALL = TCP_TABLE_CLASS.OWNER_PID_ALL;
pub const TCP_TABLE_OWNER_MODULE_LISTENER = TCP_TABLE_CLASS.OWNER_MODULE_LISTENER;
pub const TCP_TABLE_OWNER_MODULE_CONNECTIONS = TCP_TABLE_CLASS.OWNER_MODULE_CONNECTIONS;
pub const TCP_TABLE_OWNER_MODULE_ALL = TCP_TABLE_CLASS.OWNER_MODULE_ALL;

pub const UDP_TABLE_CLASS = extern enum(i32) {
    BASIC = 0,
    OWNER_PID = 1,
    OWNER_MODULE = 2,
};
pub const UDP_TABLE_BASIC = UDP_TABLE_CLASS.BASIC;
pub const UDP_TABLE_OWNER_PID = UDP_TABLE_CLASS.OWNER_PID;
pub const UDP_TABLE_OWNER_MODULE = UDP_TABLE_CLASS.OWNER_MODULE;

pub const TCPIP_OWNER_MODULE_INFO_CLASS = extern enum(i32) {
    C = 0,
};
pub const TCPIP_OWNER_MODULE_INFO_BASIC = TCPIP_OWNER_MODULE_INFO_CLASS.C;

pub const TCPIP_OWNER_MODULE_BASIC_INFO = extern struct {
    pModuleName: [*]u16,
    pModulePath: [*]u16,
};

pub const MIB_IPDESTROW = extern struct {
    ForwardRow: MIB_IPFORWARDROW,
    dwForwardPreference: u32,
    dwForwardViewSet: u32,
};

pub const MIB_IPDESTTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPDESTROW,
};

pub const MIB_ROUTESTATE = extern struct {
    bRoutesSetToStack: BOOL,
};

pub const IP_ADDRESS_STRING = extern struct {
    String: [16]i8,
};

pub const IP_ADDR_STRING = extern struct {
    Next: *IP_ADDR_STRING,
    IpAddress: IP_ADDRESS_STRING,
    IpMask: IP_ADDRESS_STRING,
    Context: u32,
};

pub const IP_ADAPTER_INFO = extern struct {
    Next: *IP_ADAPTER_INFO,
    ComboIndex: u32,
    AdapterName: [260]i8,
    Description: [132]i8,
    AddressLength: u32,
    Address: [8]u8,
    Index: u32,
    Type: u32,
    DhcpEnabled: u32,
    CurrentIpAddress: *IP_ADDR_STRING,
    IpAddressList: IP_ADDR_STRING,
    GatewayList: IP_ADDR_STRING,
    DhcpServer: IP_ADDR_STRING,
    HaveWins: BOOL,
    PrimaryWinsServer: IP_ADDR_STRING,
    SecondaryWinsServer: IP_ADDR_STRING,
    LeaseObtained: i64,
    LeaseExpires: i64,
};

pub const IP_ADAPTER_UNICAST_ADDRESS_LH = extern struct {
    Anonymous: IP_ADAPTER_UNICAST_ADDRESS_LH._Anonymous_e__Union,
    Next: *IP_ADAPTER_UNICAST_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
    OnLinkPrefixLength: u8,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_UNICAST_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_UNICAST_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_UNICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_ANYCAST_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_ANYCAST_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_ANYCAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_MULTICAST_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_MULTICAST_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_MULTICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_DNS_SERVER_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_DNS_SERVER_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_WINS_SERVER_ADDRESS_LH = extern struct {
    Anonymous: IP_ADAPTER_WINS_SERVER_ADDRESS_LH._Anonymous_e__Union,
    Next: *IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_GATEWAY_ADDRESS_LH = extern struct {
    Anonymous: IP_ADAPTER_GATEWAY_ADDRESS_LH._Anonymous_e__Union,
    Next: *IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_PREFIX_XP = extern struct {
    Anonymous: IP_ADAPTER_PREFIX_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_PREFIX_XP,
    Address: SOCKET_ADDRESS,
    PrefixLength: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_DNS_SUFFIX = extern struct {
    Next: *IP_ADAPTER_DNS_SUFFIX,
    String: [256]u16,
};

pub const IP_ADAPTER_ADDRESSES_LH = extern struct {
    Anonymous1: IP_ADAPTER_ADDRESSES_LH._Anonymous1_e__Union,
    Next: *IP_ADAPTER_ADDRESSES_LH,
    AdapterName: [*]u8,
    FirstUnicastAddress: *IP_ADAPTER_UNICAST_ADDRESS_LH,
    FirstAnycastAddress: *IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: *IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: *IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: [*]u16,
    Description: [*]u16,
    FriendlyName: [*]u16,
    PhysicalAddress: [8]u8,
    PhysicalAddressLength: u32,
    Anonymous2: IP_ADAPTER_ADDRESSES_LH._Anonymous2_e__Union,
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: [16]u32,
    FirstPrefix: *IP_ADAPTER_PREFIX_XP,
    TransmitLinkSpeed: u64,
    ReceiveLinkSpeed: u64,
    FirstWinsServerAddress: *IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    FirstGatewayAddress: *IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Ipv4Metric: u32,
    Ipv6Metric: u32,
    Luid: NET_LUID_LH,
    Dhcpv4Server: SOCKET_ADDRESS,
    CompartmentId: u32,
    NetworkGuid: Guid,
    ConnectionType: NET_IF_CONNECTION_TYPE,
    TunnelType: TUNNEL_TYPE,
    Dhcpv6Server: SOCKET_ADDRESS,
    Dhcpv6ClientDuid: [130]u8,
    Dhcpv6ClientDuidLength: u32,
    Dhcpv6Iaid: u32,
    FirstDnsSuffix: *IP_ADAPTER_DNS_SUFFIX,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_ADDRESSES_XP = extern struct {
    Anonymous: IP_ADAPTER_ADDRESSES_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_ADDRESSES_XP,
    AdapterName: [*]u8,
    FirstUnicastAddress: *IP_ADAPTER_UNICAST_ADDRESS_XP,
    FirstAnycastAddress: *IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: *IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: *IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: [*]u16,
    Description: [*]u16,
    FriendlyName: [*]u16,
    PhysicalAddress: [8]u8,
    PhysicalAddressLength: u32,
    Flags: u32,
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: [16]u32,
    FirstPrefix: *IP_ADAPTER_PREFIX_XP,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_PER_ADAPTER_INFO_W2KSP1 = extern struct {
    AutoconfigEnabled: u32,
    AutoconfigActive: u32,
    CurrentDnsServer: *IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
};

pub const FIXED_INFO_W2KSP1 = extern struct {
    HostName: [132]i8,
    DomainName: [132]i8,
    CurrentDnsServer: *IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
    NodeType: u32,
    ScopeId: [260]i8,
    EnableRouting: u32,
    EnableProxy: u32,
    EnableDns: u32,
};

pub const ip_interface_name_info_w2ksp1 = extern struct {
    Index: u32,
    MediaType: u32,
    ConnectionType: u8,
    AccessType: u8,
    DeviceGuid: Guid,
    InterfaceGuid: Guid,
};

pub const TCP_ESTATS_TYPE = extern enum(i32) {
    SynOpts = 0,
    Data = 1,
    SndCong = 2,
    Path = 3,
    SendBuff = 4,
    Rec = 5,
    ObsRec = 6,
    Bandwidth = 7,
    FineRtt = 8,
    Maximum = 9,
};
pub const TcpConnectionEstatsSynOpts = TCP_ESTATS_TYPE.SynOpts;
pub const TcpConnectionEstatsData = TCP_ESTATS_TYPE.Data;
pub const TcpConnectionEstatsSndCong = TCP_ESTATS_TYPE.SndCong;
pub const TcpConnectionEstatsPath = TCP_ESTATS_TYPE.Path;
pub const TcpConnectionEstatsSendBuff = TCP_ESTATS_TYPE.SendBuff;
pub const TcpConnectionEstatsRec = TCP_ESTATS_TYPE.Rec;
pub const TcpConnectionEstatsObsRec = TCP_ESTATS_TYPE.ObsRec;
pub const TcpConnectionEstatsBandwidth = TCP_ESTATS_TYPE.Bandwidth;
pub const TcpConnectionEstatsFineRtt = TCP_ESTATS_TYPE.FineRtt;
pub const TcpConnectionEstatsMaximum = TCP_ESTATS_TYPE.Maximum;

pub const TCP_BOOLEAN_OPTIONAL = extern enum(i32) {
    Disabled = 0,
    Enabled = 1,
    Unchanged = -1,
};
pub const TcpBoolOptDisabled = TCP_BOOLEAN_OPTIONAL.Disabled;
pub const TcpBoolOptEnabled = TCP_BOOLEAN_OPTIONAL.Enabled;
pub const TcpBoolOptUnchanged = TCP_BOOLEAN_OPTIONAL.Unchanged;

pub const TCP_ESTATS_SYN_OPTS_ROS_v0 = extern struct {
    ActiveOpen: u8,
    MssRcvd: u32,
    MssSent: u32,
};

pub const TCP_SOFT_ERROR = extern enum(i32) {
    None = 0,
    BelowDataWindow = 1,
    AboveDataWindow = 2,
    BelowAckWindow = 3,
    AboveAckWindow = 4,
    BelowTsWindow = 5,
    AboveTsWindow = 6,
    DataChecksumError = 7,
    DataLengthError = 8,
    MaxSoftError = 9,
};
pub const TcpErrorNone = TCP_SOFT_ERROR.None;
pub const TcpErrorBelowDataWindow = TCP_SOFT_ERROR.BelowDataWindow;
pub const TcpErrorAboveDataWindow = TCP_SOFT_ERROR.AboveDataWindow;
pub const TcpErrorBelowAckWindow = TCP_SOFT_ERROR.BelowAckWindow;
pub const TcpErrorAboveAckWindow = TCP_SOFT_ERROR.AboveAckWindow;
pub const TcpErrorBelowTsWindow = TCP_SOFT_ERROR.BelowTsWindow;
pub const TcpErrorAboveTsWindow = TCP_SOFT_ERROR.AboveTsWindow;
pub const TcpErrorDataChecksumError = TCP_SOFT_ERROR.DataChecksumError;
pub const TcpErrorDataLengthError = TCP_SOFT_ERROR.DataLengthError;
pub const TcpErrorMaxSoftError = TCP_SOFT_ERROR.MaxSoftError;

pub const TCP_ESTATS_DATA_ROD_v0 = extern struct {
    DataBytesOut: u64,
    DataSegsOut: u64,
    DataBytesIn: u64,
    DataSegsIn: u64,
    SegsOut: u64,
    SegsIn: u64,
    SoftErrors: u32,
    SoftErrorReason: u32,
    SndUna: u32,
    SndNxt: u32,
    SndMax: u32,
    ThruBytesAcked: u64,
    RcvNxt: u32,
    ThruBytesReceived: u64,
};

pub const TCP_ESTATS_DATA_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_SND_CONG_ROD_v0 = extern struct {
    SndLimTransRwin: u32,
    SndLimTimeRwin: u32,
    SndLimBytesRwin: ?*c_void,
    SndLimTransCwnd: u32,
    SndLimTimeCwnd: u32,
    SndLimBytesCwnd: ?*c_void,
    SndLimTransSnd: u32,
    SndLimTimeSnd: u32,
    SndLimBytesSnd: ?*c_void,
    SlowStart: u32,
    CongAvoid: u32,
    OtherReductions: u32,
    CurCwnd: u32,
    MaxSsCwnd: u32,
    MaxCaCwnd: u32,
    CurSsthresh: u32,
    MaxSsthresh: u32,
    MinSsthresh: u32,
};

pub const TCP_ESTATS_SND_CONG_ROS_v0 = extern struct {
    LimCwnd: u32,
};

pub const TCP_ESTATS_SND_CONG_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_PATH_ROD_v0 = extern struct {
    FastRetran: u32,
    Timeouts: u32,
    SubsequentTimeouts: u32,
    CurTimeoutCount: u32,
    AbruptTimeouts: u32,
    PktsRetrans: u32,
    BytesRetrans: u32,
    DupAcksIn: u32,
    SacksRcvd: u32,
    SackBlocksRcvd: u32,
    CongSignals: u32,
    PreCongSumCwnd: u32,
    PreCongSumRtt: u32,
    PostCongSumRtt: u32,
    PostCongCountRtt: u32,
    EcnSignals: u32,
    EceRcvd: u32,
    SendStall: u32,
    QuenchRcvd: u32,
    RetranThresh: u32,
    SndDupAckEpisodes: u32,
    SumBytesReordered: u32,
    NonRecovDa: u32,
    NonRecovDaEpisodes: u32,
    AckAfterFr: u32,
    DsackDups: u32,
    SampleRtt: u32,
    SmoothedRtt: u32,
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
    CountRtt: u32,
    CurRto: u32,
    MaxRto: u32,
    MinRto: u32,
    CurMss: u32,
    MaxMss: u32,
    MinMss: u32,
    SpuriousRtoDetections: u32,
};

pub const TCP_ESTATS_PATH_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_SEND_BUFF_ROD_v0 = extern struct {
    CurRetxQueue: ?*c_void,
    MaxRetxQueue: ?*c_void,
    CurAppWQueue: ?*c_void,
    MaxAppWQueue: ?*c_void,
};

pub const TCP_ESTATS_SEND_BUFF_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_REC_ROD_v0 = extern struct {
    CurRwinSent: u32,
    MaxRwinSent: u32,
    MinRwinSent: u32,
    LimRwin: u32,
    DupAckEpisodes: u32,
    DupAcksOut: u32,
    CeRcvd: u32,
    EcnSent: u32,
    EcnNoncesRcvd: u32,
    CurReasmQueue: u32,
    MaxReasmQueue: u32,
    CurAppRQueue: ?*c_void,
    MaxAppRQueue: ?*c_void,
    WinScaleSent: u8,
};

pub const TCP_ESTATS_REC_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_OBS_REC_ROD_v0 = extern struct {
    CurRwinRcvd: u32,
    MaxRwinRcvd: u32,
    MinRwinRcvd: u32,
    WinScaleRcvd: u8,
};

pub const TCP_ESTATS_OBS_REC_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_BANDWIDTH_RW_v0 = extern struct {
    EnableCollectionOutbound: TCP_BOOLEAN_OPTIONAL,
    EnableCollectionInbound: TCP_BOOLEAN_OPTIONAL,
};

pub const TCP_ESTATS_BANDWIDTH_ROD_v0 = extern struct {
    OutboundBandwidth: u64,
    InboundBandwidth: u64,
    OutboundInstability: u64,
    InboundInstability: u64,
    OutboundBandwidthPeaked: u8,
    InboundBandwidthPeaked: u8,
};

pub const TCP_ESTATS_FINE_RTT_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_FINE_RTT_ROD_v0 = extern struct {
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
};

pub const INTERFACE_TIMESTAMP_CAPABILITY_FLAGS = extern struct {
    PtpV2OverUdpIPv4EventMsgReceiveHw: u8,
    PtpV2OverUdpIPv4AllMsgReceiveHw: u8,
    PtpV2OverUdpIPv4EventMsgTransmitHw: u8,
    PtpV2OverUdpIPv4AllMsgTransmitHw: u8,
    PtpV2OverUdpIPv6EventMsgReceiveHw: u8,
    PtpV2OverUdpIPv6AllMsgReceiveHw: u8,
    PtpV2OverUdpIPv6EventMsgTransmitHw: u8,
    PtpV2OverUdpIPv6AllMsgTransmitHw: u8,
    AllReceiveHw: u8,
    AllTransmitHw: u8,
    TaggedTransmitHw: u8,
    AllReceiveSw: u8,
    AllTransmitSw: u8,
    TaggedTransmitSw: u8,
};

pub const INTERFACE_TIMESTAMP_CAPABILITIES = extern struct {
    Version: u32,
    HardwareClockFrequencyHz: u64,
    CrossTimestamp: u8,
    Reserved1: u64,
    Reserved2: u64,
    TimestampFlags: INTERFACE_TIMESTAMP_CAPABILITY_FLAGS,
};

pub const INTERFACE_HARDWARE_CROSSTIMESTAMP = extern struct {
    Version: u32,
    Flags: u32,
    SystemTimestamp1: u64,
    HardwareClockTimestamp: u64,
    SystemTimestamp2: u64,
};

pub const PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NET_ADDRESS_FORMAT = extern enum(i32) {
    FORMAT_UNSPECIFIED = 0,
    DNS_NAME = 1,
    IPV4 = 2,
    IPV6 = 3,
};
pub const NET_ADDRESS_FORMAT_UNSPECIFIED = NET_ADDRESS_FORMAT.FORMAT_UNSPECIFIED;
pub const NET_ADDRESS_DNS_NAME = NET_ADDRESS_FORMAT.DNS_NAME;
pub const NET_ADDRESS_IPV4 = NET_ADDRESS_FORMAT.IPV4;
pub const NET_ADDRESS_IPV6 = NET_ADDRESS_FORMAT.IPV6;


//--------------------------------------------------------------------------------
// Section: Functions (190)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4AddressToStringA(
    Addr: *const in_addr,
    S: *[16]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4AddressToStringW(
    Addr: *const in_addr,
    S: *[16]u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4AddressToStringExW(
    Address: *const in_addr,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4StringToAddressA(
    S: [*:0]const u8,
    Strict: u8,
    Terminator: *PSTR,
    Addr: *in_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4StringToAddressW(
    S: [*:0]const u16,
    Strict: u8,
    Terminator: *PWSTR,
    Addr: *in_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv4StringToAddressExW(
    AddressString: [*:0]const u16,
    Strict: u8,
    Address: *in_addr,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6AddressToStringA(
    Addr: *const in6_addr,
    S: *[46]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6AddressToStringW(
    Addr: *const in6_addr,
    S: *[46]u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6AddressToStringExW(
    Address: *const in6_addr,
    ScopeId: u32,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6StringToAddressA(
    S: [*:0]const u8,
    Terminator: *PSTR,
    Addr: *in6_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6StringToAddressW(
    S: [*:0]const u16,
    Terminator: *PWSTR,
    Addr: *in6_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ntdll" fn RtlIpv6StringToAddressExW(
    AddressString: [*:0]const u16,
    Address: *in6_addr,
    ScopeId: *u32,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetAddressToStringA(
    Addr: *const DL_EUI48,
    S: *[18]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetAddressToStringW(
    Addr: *const DL_EUI48,
    S: *[18]u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetStringToAddressA(
    S: [*:0]const u8,
    Terminator: *PSTR,
    Addr: *DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ntdll" fn RtlEthernetStringToAddressW(
    S: [*:0]const u16,
    Terminator: *PWSTR,
    Addr: *DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIfEntry2(
    Row: *MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.15063'
pub extern "IPHLPAPI" fn GetIfEntry2Ex(
    Level: MIB_IF_ENTRY_LEVEL,
    Row: *MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIfTable2(
    Table: **MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIfTable2Ex(
    Level: MIB_IF_TABLE_LEVEL,
    Table: **MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIfStackTable(
    Table: **MIB_IFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetInvertedIfStackTable(
    Table: **MIB_INVERTEDIFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIpInterfaceEntry(
    Row: *MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIpInterfaceTable(
    Family: u16,
    Table: **MIB_IPINTERFACE_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn InitializeIpInterfaceEntry(
    Row: *MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn NotifyIpInterfaceChange(
    Family: u16,
    Callback: PIPINTERFACE_CHANGE_CALLBACK,
    CallerContext: ?*c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn SetIpInterfaceEntry(
    Row: *MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows8.0'
pub extern "IPHLPAPI" fn GetIpNetworkConnectionBandwidthEstimates(
    InterfaceIndex: u32,
    AddressFamily: u16,
    BandwidthEstimates: *MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn CreateUnicastIpAddressEntry(
    Row: *const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn DeleteUnicastIpAddressEntry(
    Row: *const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetUnicastIpAddressEntry(
    Row: *MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetUnicastIpAddressTable(
    Family: u16,
    Table: **MIB_UNICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn InitializeUnicastIpAddressEntry(
    Row: *MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn NotifyUnicastIpAddressChange(
    Family: u16,
    Callback: PUNICAST_IPADDRESS_CHANGE_CALLBACK,
    CallerContext: ?*c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn NotifyStableUnicastIpAddressTable(
    Family: u16,
    Table: **MIB_UNICASTIPADDRESS_TABLE,
    CallerCallback: PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK,
    CallerContext: *c_void,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn SetUnicastIpAddressEntry(
    Row: *const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn CreateAnycastIpAddressEntry(
    Row: *const MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn DeleteAnycastIpAddressEntry(
    Row: *const MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetAnycastIpAddressEntry(
    Row: *MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetAnycastIpAddressTable(
    Family: u16,
    Table: **MIB_ANYCASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetMulticastIpAddressEntry(
    Row: *MIB_MULTICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetMulticastIpAddressTable(
    Family: u16,
    Table: **MIB_MULTICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn CreateIpForwardEntry2(
    Row: *const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn DeleteIpForwardEntry2(
    Row: *const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetBestRoute2(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceIndex: u32,
    SourceAddress: ?*const SOCKADDR_INET,
    DestinationAddress: *const SOCKADDR_INET,
    AddressSortOptions: u32,
    BestRoute: *MIB_IPFORWARD_ROW2,
    BestSourceAddress: *SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIpForwardEntry2(
    Row: *MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIpForwardTable2(
    Family: u16,
    Table: **MIB_IPFORWARD_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn InitializeIpForwardEntry(
    Row: *MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn NotifyRouteChange2(
    AddressFamily: u16,
    Callback: PIPFORWARD_CHANGE_CALLBACK,
    CallerContext: *c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn SetIpForwardEntry2(
    Route: *const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn FlushIpPathTable(
    Family: u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIpPathEntry(
    Row: *MIB_IPPATH_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIpPathTable(
    Family: u16,
    Table: **MIB_IPPATH_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn CreateIpNetEntry2(
    Row: *const MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn DeleteIpNetEntry2(
    Row: *const MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn FlushIpNetTable2(
    Family: u16,
    InterfaceIndex: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIpNetEntry2(
    Row: *MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetIpNetTable2(
    Family: u16,
    Table: **MIB_IPNET_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ResolveIpNetEntry2(
    Row: *MIB_IPNET_ROW2,
    SourceAddress: ?*const SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn SetIpNetEntry2(
    Row: *MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn NotifyTeredoPortChange(
    Callback: PTEREDO_PORT_CHANGE_CALLBACK,
    CallerContext: *c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetTeredoPort(
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn CancelMibChangeNotify2(
    NotificationHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn FreeMibTable(
    Memory: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn CreateSortedAddressPairs(
    SourceAddressList: ?*const SOCKADDR_IN6_LH,
    SourceAddressCount: u32,
    DestinationAddressList: *const SOCKADDR_IN6_LH,
    DestinationAddressCount: u32,
    AddressSortOptions: u32,
    SortedAddressPairList: **SOCKADDR_IN6_PAIR,
    SortedAddressPairCount: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertCompartmentGuidToId(
    CompartmentGuid: *const Guid,
    CompartmentId: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertCompartmentIdToGuid(
    CompartmentId: u32,
    CompartmentGuid: *Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceNameToLuidA(
    InterfaceName: *const i8,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceNameToLuidW(
    InterfaceName: [*:0]const u16,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToNameA(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceName: [*:0]u8,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToNameW(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceName: [*:0]u16,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToIndex(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceIndexToLuid(
    InterfaceIndex: u32,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToAlias(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceAlias: [*:0]u16,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceAliasToLuid(
    InterfaceAlias: [*:0]const u16,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceLuidToGuid(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceGuid: *Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertInterfaceGuidToLuid(
    InterfaceGuid: *const Guid,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn if_nametoindex(
    InterfaceName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn if_indextoname(
    InterfaceIndex: u32,
    InterfaceName: *[256]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "IPHLPAPI" fn GetCurrentThreadCompartmentScope(
    CompartmentScope: *u32,
    CompartmentId: *u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn SetCurrentThreadCompartmentScope(
    CompartmentScope: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetJobCompartmentId(
    JobHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetJobCompartmentId(
    JobHandle: HANDLE,
    CompartmentId: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "IPHLPAPI" fn GetDefaultCompartmentId(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertLengthToIpv4Mask(
    MaskLength: u32,
    Mask: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn ConvertIpv4MaskToLength(
    Mask: u32,
    MaskLength: *u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetDnsSettings(
    Settings: *DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FreeDnsSettings(
    Settings: *DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn SetDnsSettings(
    Settings: *const DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetInterfaceDnsSettings(
    Interface: Guid,
    Settings: *DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FreeInterfaceDnsSettings(
    Settings: *DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn SetInterfaceDnsSettings(
    Interface: Guid,
    Settings: *const DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "IPHLPAPI" fn GetNetworkConnectivityHint(
    ConnectivityHint: *NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "IPHLPAPI" fn GetNetworkConnectivityHintForInterface(
    InterfaceIndex: u32,
    ConnectivityHint: *NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "IPHLPAPI" fn NotifyNetworkConnectivityHintChange(
    Callback: PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK,
    CallerContext: ?*c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn IcmpCreateFile(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn Icmp6CreateFile(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn IcmpCloseHandle(
    IcmpHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn IcmpSendEcho(
    IcmpHandle: HANDLE,
    DestinationAddress: u32,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn IcmpSendEcho2(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: ?FARPROC,
    ApcContext: ?*c_void,
    DestinationAddress: u32,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn IcmpSendEcho2Ex(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: ?FARPROC,
    ApcContext: ?*c_void,
    SourceAddress: u32,
    DestinationAddress: u32,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn Icmp6SendEcho2(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: ?FARPROC,
    ApcContext: ?*c_void,
    SourceAddress: *SOCKADDR_IN6_LH,
    DestinationAddress: *SOCKADDR_IN6_LH,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn IcmpParseReplies(
    ReplyBuffer: [*]u8,
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn Icmp6ParseReplies(
    ReplyBuffer: [*]u8,
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetNumberOfInterfaces(
    pdwNumIf: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetIfEntry(
    pIfRow: *MIB_IFROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetIfTable(
    pIfTable: ?[*]MIB_IFTABLE,
    pdwSize: *u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetIpAddrTable(
    pIpAddrTable: ?[*]MIB_IPADDRTABLE,
    pdwSize: *u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetIpNetTable(
    IpNetTable: ?[*]MIB_IPNETTABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetIpForwardTable(
    pIpForwardTable: ?[*]MIB_IPFORWARDTABLE,
    pdwSize: *u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetTcpTable(
    TcpTable: ?[*]MIB_TCPTABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetExtendedTcpTable(
    pTcpTable: ?[*]u8,
    pdwSize: *u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: TCP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetOwnerModuleFromTcpEntry(
    pTcpEntry: *MIB_TCPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetUdpTable(
    UdpTable: ?[*]MIB_UDPTABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetExtendedUdpTable(
    pUdpTable: ?[*]u8,
    pdwSize: *u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: UDP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetOwnerModuleFromUdpEntry(
    pUdpEntry: *MIB_UDPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetTcpTable2(
    TcpTable: ?[*]MIB_TCPTABLE2,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetTcp6Table(
    TcpTable: [*]MIB_TCP6TABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetTcp6Table2(
    TcpTable: [*]MIB_TCP6TABLE2,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetPerTcpConnectionEStats(
    Row: *MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?[*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Ros: ?[*:0]u8,
    RosVersion: u32,
    RosSize: u32,
    Rod: ?[*:0]u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn SetPerTcpConnectionEStats(
    Row: *MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: [*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetPerTcp6ConnectionEStats(
    Row: *MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?[*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Ros: ?[*:0]u8,
    RosVersion: u32,
    RosSize: u32,
    Rod: ?[*:0]u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn SetPerTcp6ConnectionEStats(
    Row: *MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: [*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetOwnerModuleFromTcp6Entry(
    pTcpEntry: *MIB_TCP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetUdp6Table(
    Udp6Table: ?[*]MIB_UDP6TABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn GetOwnerModuleFromUdp6Entry(
    pUdpEntry: *MIB_UDP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromPidAndInfo(
    ulPid: u32,
    pInfo: *u64,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetIpStatistics(
    Statistics: *MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetIcmpStatistics(
    Statistics: *MIB_ICMP,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetTcpStatistics(
    Statistics: *MIB_TCPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetUdpStatistics(
    Stats: *MIB_UDPSTATS,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn SetIpStatisticsEx(
    Statistics: *MIB_IPSTATS_LH,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn GetIpStatisticsEx(
    Statistics: *MIB_IPSTATS_LH,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn GetIcmpStatisticsEx(
    Statistics: *MIB_ICMP_EX_XPSP1,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn GetTcpStatisticsEx(
    Statistics: *MIB_TCPSTATS_LH,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn GetUdpStatisticsEx(
    Statistics: *MIB_UDPSTATS,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "IPHLPAPI" fn GetTcpStatisticsEx2(
    Statistics: *MIB_TCPSTATS2,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows10.0.16299'
pub extern "IPHLPAPI" fn GetUdpStatisticsEx2(
    Statistics: *MIB_UDPSTATS2,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn SetIfEntry(
    pIfRow: *MIB_IFROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn CreateIpForwardEntry(
    pRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn SetIpForwardEntry(
    pRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn DeleteIpForwardEntry(
    pRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn SetIpStatistics(
    pIpStats: *MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn SetIpTTL(
    nTTL: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn CreateIpNetEntry(
    pArpEntry: *MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn SetIpNetEntry(
    pArpEntry: *MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn DeleteIpNetEntry(
    pArpEntry: *MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn FlushIpNetTable(
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn CreateProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn DeleteProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn SetTcpEntry(
    pTcpRow: *MIB_TCPROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetInterfaceInfo(
    pIfTable: ?[*]IP_INTERFACE_INFO,
    dwOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUniDirectionalAdapterInfo(
    pIPIfInfo: ?[*]IP_UNIDIRECTIONAL_ADAPTER_ADDRESS,
    dwOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn NhpAllocateAndGetInterfaceInfoFromStack(
    ppTable: **ip_interface_name_info_w2ksp1,
    pdwCount: *u32,
    bOrder: BOOL,
    hHeap: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetBestInterface(
    dwDestAddr: u32,
    pdwBestIfIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn GetBestInterfaceEx(
    pDestAddr: *SOCKADDR,
    pdwBestIfIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetBestRoute(
    dwDestAddr: u32,
    dwSourceAddr: u32,
    pBestRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn NotifyAddrChange(
    Handle: *HANDLE,
    overlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn NotifyRouteChange(
    Handle: *HANDLE,
    overlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn CancelIPChangeNotify(
    notifyOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetAdapterIndex(
    AdapterName: PWSTR,
    IfIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn AddIPAddress(
    Address: u32,
    IpMask: u32,
    IfIndex: u32,
    NTEContext: *u32,
    NTEInstance: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn DeleteIPAddress(
    NTEContext: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetNetworkParams(
    pFixedInfo: ?[*]FIXED_INFO_W2KSP1,
    pOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetAdaptersInfo(
    AdapterInfo: ?[*]IP_ADAPTER_INFO,
    SizePointer: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn GetAdapterOrderMap(
) callconv(@import("std").os.windows.WINAPI) *IP_ADAPTER_ORDER_MAP;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn GetAdaptersAddresses(
    Family: Get_Family,
    Flags: GetAdaptersAddresses_Flags,
    Reserved: *c_void,
    AdapterAddresses: ?[*]IP_ADAPTER_ADDRESSES_LH,
    SizePointer: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetPerAdapterInfo(
    IfIndex: u32,
    pPerAdapterInfo: ?[*]IP_PER_ADAPTER_INFO_W2KSP1,
    pOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetInterfaceCurrentTimestampCapabilities(
    InterfaceLuid: *const NET_LUID_LH,
    TimestampCapabilites: *INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetInterfaceHardwareTimestampCapabilities(
    InterfaceLuid: *const NET_LUID_LH,
    TimestampCapabilites: *INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CaptureInterfaceHardwareCrossTimestamp(
    InterfaceLuid: *const NET_LUID_LH,
    CrossTimestamp: *INTERFACE_HARDWARE_CROSSTIMESTAMP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn NotifyIfTimestampConfigChange(
    CallerContext: ?*c_void,
    Callback: PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK,
    NotificationHandle: *HIFTIMESTAMPCHANGE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CancelIfTimestampConfigChange(
    NotificationHandle: HIFTIMESTAMPCHANGE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn IpReleaseAddress(
    AdapterInfo: *IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn IpRenewAddress(
    AdapterInfo: *IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn SendARP(
    DestIP: u32,
    SrcIP: u32,
    pMacAddr: [*]u8,
    PhyAddrLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetRTTAndHopCount(
    DestIpAddress: u32,
    HopCount: *u32,
    MaxHops: u32,
    RTT: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn GetFriendlyIfIndex(
    IfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn EnableRouter(
    pHandle: *HANDLE,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.0'
pub extern "IPHLPAPI" fn UnenableRouter(
    pOverlapped: *OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn DisableMediaSense(
    pHandle: *HANDLE,
    pOverLapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn RestoreMediaSense(
    pOverlapped: *OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn GetIpErrorString(
    ErrorCode: u32,
    Buffer: ?PWSTR,
    Size: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "IPHLPAPI" fn ResolveNeighbor(
    NetworkAddress: *SOCKADDR,
    PhysicalAddress: [*]u8,
    PhysicalAddressLength: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn CreatePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn CreatePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn DeletePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn DeletePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn LookupPersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "IPHLPAPI" fn LookupPersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (8)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const RtlIpv4AddressToString = RtlIpv4AddressToStringA;
        pub const RtlIpv4StringToAddress = RtlIpv4StringToAddressA;
        pub const RtlIpv6AddressToString = RtlIpv6AddressToStringA;
        pub const RtlIpv6StringToAddress = RtlIpv6StringToAddressA;
        pub const RtlEthernetAddressToString = RtlEthernetAddressToStringA;
        pub const RtlEthernetStringToAddress = RtlEthernetStringToAddressA;
        pub const ConvertInterfaceNameToLuid = ConvertInterfaceNameToLuidA;
        pub const ConvertInterfaceLuidToName = ConvertInterfaceLuidToNameA;
    },
    .wide => struct {
        pub const RtlIpv4AddressToString = RtlIpv4AddressToStringW;
        pub const RtlIpv4StringToAddress = RtlIpv4StringToAddressW;
        pub const RtlIpv6AddressToString = RtlIpv6AddressToStringW;
        pub const RtlIpv6StringToAddress = RtlIpv6StringToAddressW;
        pub const RtlEthernetAddressToString = RtlEthernetAddressToStringW;
        pub const RtlEthernetStringToAddress = RtlEthernetStringToAddressW;
        pub const ConvertInterfaceNameToLuid = ConvertInterfaceNameToLuidW;
        pub const ConvertInterfaceLuidToName = ConvertInterfaceLuidToNameW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const RtlIpv4AddressToString = *opaque{};
        pub const RtlIpv4StringToAddress = *opaque{};
        pub const RtlIpv6AddressToString = *opaque{};
        pub const RtlIpv6StringToAddress = *opaque{};
        pub const RtlEthernetAddressToString = *opaque{};
        pub const RtlEthernetStringToAddress = *opaque{};
        pub const ConvertInterfaceNameToLuid = *opaque{};
        pub const ConvertInterfaceLuidToName = *opaque{};
    } else struct {
        pub const RtlIpv4AddressToString = @compileError("'RtlIpv4AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4StringToAddress = @compileError("'RtlIpv4StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6AddressToString = @compileError("'RtlIpv6AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6StringToAddress = @compileError("'RtlIpv6StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetAddressToString = @compileError("'RtlEthernetAddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetStringToAddress = @compileError("'RtlEthernetStringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const ConvertInterfaceNameToLuid = @compileError("'ConvertInterfaceNameToLuid' requires that UNICODE be set to true or false in the root module");
        pub const ConvertInterfaceLuidToName = @compileError("'ConvertInterfaceLuidToName' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (63)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const MIB_IFSTACK_TABLE = @import("mib.zig").MIB_IFSTACK_TABLE;
const MIB_TCPROW_OWNER_MODULE = @import("mib.zig").MIB_TCPROW_OWNER_MODULE;
const MIB_ANYCASTIPADDRESS_TABLE = @import("mib.zig").MIB_ANYCASTIPADDRESS_TABLE;
const MIB_IPINTERFACE_TABLE = @import("mib.zig").MIB_IPINTERFACE_TABLE;
const MIB_UNICASTIPADDRESS_TABLE = @import("mib.zig").MIB_UNICASTIPADDRESS_TABLE;
const MIB_IPPATH_TABLE = @import("mib.zig").MIB_IPPATH_TABLE;
const MIB_IF_ROW2 = @import("mib.zig").MIB_IF_ROW2;
const in_addr = @import("win_sock.zig").in_addr;
const MIB_UDPSTATS = @import("mib.zig").MIB_UDPSTATS;
const SOCKADDR = @import("win_sock.zig").SOCKADDR;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;
const in6_addr = @import("win_sock.zig").in6_addr;
const MIB_IPADDRTABLE = @import("mib.zig").MIB_IPADDRTABLE;
const MIB_TCPSTATS_LH = @import("mib.zig").MIB_TCPSTATS_LH;
const MIB_ICMP = @import("mib.zig").MIB_ICMP;
const MIB_MULTICASTIPADDRESS_ROW = @import("mib.zig").MIB_MULTICASTIPADDRESS_ROW;
const MIB_TCP6TABLE = @import("mib.zig").MIB_TCP6TABLE;
const PWSTR = @import("system_services.zig").PWSTR;
const MIB_TCP6ROW_OWNER_MODULE = @import("mib.zig").MIB_TCP6ROW_OWNER_MODULE;
const MIB_IPFORWARDTABLE = @import("mib.zig").MIB_IPFORWARDTABLE;
const MIB_IPNET_TABLE2 = @import("mib.zig").MIB_IPNET_TABLE2;
const MIB_NOTIFICATION_TYPE = @import("mib.zig").MIB_NOTIFICATION_TYPE;
const PSTR = @import("system_services.zig").PSTR;
const MIB_IF_TABLE2 = @import("mib.zig").MIB_IF_TABLE2;
const NET_IF_CONNECTION_TYPE = @import("network_drivers.zig").NET_IF_CONNECTION_TYPE;
const MIB_IPNETROW_LH = @import("mib.zig").MIB_IPNETROW_LH;
const MIB_IPFORWARDROW = @import("mib.zig").MIB_IPFORWARDROW;
const HANDLE = @import("system_services.zig").HANDLE;
const TUNNEL_TYPE = @import("network_drivers.zig").TUNNEL_TYPE;
const MIB_UDPSTATS2 = @import("mib.zig").MIB_UDPSTATS2;
const MIB_IPINTERFACE_ROW = @import("mib.zig").MIB_IPINTERFACE_ROW;
const MIB_IPFORWARD_TABLE2 = @import("mib.zig").MIB_IPFORWARD_TABLE2;
const MIB_IF_TABLE_LEVEL = @import("network_drivers.zig").MIB_IF_TABLE_LEVEL;
const MIB_IPPATH_ROW = @import("mib.zig").MIB_IPPATH_ROW;
const MIB_ICMP_EX_XPSP1 = @import("mib.zig").MIB_ICMP_EX_XPSP1;
const MIB_TCP6ROW = @import("mib.zig").MIB_TCP6ROW;
const MIB_INVERTEDIFSTACK_TABLE = @import("mib.zig").MIB_INVERTEDIFSTACK_TABLE;
const MIB_TCPROW_LH = @import("mib.zig").MIB_TCPROW_LH;
const BOOL = @import("system_services.zig").BOOL;
const MIB_ANYCASTIPADDRESS_ROW = @import("mib.zig").MIB_ANYCASTIPADDRESS_ROW;
const MIB_TCPTABLE2 = @import("mib.zig").MIB_TCPTABLE2;
const FARPROC = @import("system_services.zig").FARPROC;
const MIB_TCPSTATS2 = @import("mib.zig").MIB_TCPSTATS2;
const MIB_IPFORWARD_ROW2 = @import("mib.zig").MIB_IPFORWARD_ROW2;
const MIB_UNICASTIPADDRESS_ROW = @import("mib.zig").MIB_UNICASTIPADDRESS_ROW;
const DL_EUI48 = @import("windows_filtering.zig").DL_EUI48;
const MIB_UDPROW_OWNER_MODULE = @import("mib.zig").MIB_UDPROW_OWNER_MODULE;
const MIB_TCP6TABLE2 = @import("mib.zig").MIB_TCP6TABLE2;
const MIB_IPSTATS_LH = @import("mib.zig").MIB_IPSTATS_LH;
const MIB_IFTABLE = @import("mib.zig").MIB_IFTABLE;
const MIB_MULTICASTIPADDRESS_TABLE = @import("mib.zig").MIB_MULTICASTIPADDRESS_TABLE;
const MIB_UDPTABLE = @import("mib.zig").MIB_UDPTABLE;
const MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES = @import("mib.zig").MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES;
const MIB_UDP6ROW_OWNER_MODULE = @import("mib.zig").MIB_UDP6ROW_OWNER_MODULE;
const MIB_TCPTABLE = @import("mib.zig").MIB_TCPTABLE;
const MIB_IPNETTABLE = @import("mib.zig").MIB_IPNETTABLE;
const MIB_IPNET_ROW2 = @import("mib.zig").MIB_IPNET_ROW2;
const SOCKADDR_IN6_LH = @import("network_drivers.zig").SOCKADDR_IN6_LH;
const MIB_IFROW = @import("mib.zig").MIB_IFROW;
const MIB_UDP6TABLE = @import("mib.zig").MIB_UDP6TABLE;
const SOCKET_ADDRESS = @import("win_sock.zig").SOCKET_ADDRESS;
const NTSTATUS = @import("system_services.zig").NTSTATUS;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = PIPINTERFACE_CHANGE_CALLBACK;
    _ = PUNICAST_IPADDRESS_CHANGE_CALLBACK;
    _ = PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK;
    _ = PIPFORWARD_CHANGE_CALLBACK;
    _ = PTEREDO_PORT_CHANGE_CALLBACK;
    _ = PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK;
    _ = PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK;

    const constant_export_count = 338;
    const type_export_count = 102;
    const enum_value_export_count = 157;
    const com_iface_id_export_count = 0;
    const com_class_id_export_count = 0;
    const func_export_count = 190;
    const unicode_alias_count = 8;
    const import_count = 63;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
