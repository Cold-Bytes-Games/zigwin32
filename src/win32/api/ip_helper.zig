//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (336)
//--------------------------------------------------------------------------------
pub const MAX_ADAPTER_DESCRIPTION_LENGTH : u32 = 128;
pub const MAX_ADAPTER_NAME_LENGTH : u32 = 256;
pub const MAX_ADAPTER_ADDRESS_LENGTH : u32 = 8;
pub const DEFAULT_MINIMUM_ENTITIES : u32 = 32;
pub const MAX_HOSTNAME_LEN : u32 = 128;
pub const MAX_DOMAIN_NAME_LEN : u32 = 128;
pub const MAX_SCOPE_ID_LEN : u32 = 256;
pub const MAX_DHCPV6_DUID_LENGTH : u32 = 130;
pub const MAX_DNS_SUFFIX_STRING_LENGTH : u32 = 256;
pub const BROADCAST_NODETYPE : u32 = 1;
pub const PEER_TO_PEER_NODETYPE : u32 = 2;
pub const MIXED_NODETYPE : u32 = 4;
pub const HYBRID_NODETYPE : u32 = 8;
pub const IP_ADAPTER_ADDRESS_DNS_ELIGIBLE : u32 = 1;
pub const IP_ADAPTER_ADDRESS_TRANSIENT : u32 = 2;
pub const IP_ADAPTER_DDNS_ENABLED : u32 = 1;
pub const IP_ADAPTER_REGISTER_ADAPTER_SUFFIX : u32 = 2;
pub const IP_ADAPTER_DHCP_ENABLED : u32 = 4;
pub const IP_ADAPTER_RECEIVE_ONLY : u32 = 8;
pub const IP_ADAPTER_NO_MULTICAST : u32 = 16;
pub const IP_ADAPTER_IPV6_OTHER_STATEFUL_CONFIG : u32 = 32;
pub const IP_ADAPTER_NETBIOS_OVER_TCPIP_ENABLED : u32 = 64;
pub const IP_ADAPTER_IPV4_ENABLED : u32 = 128;
pub const IP_ADAPTER_IPV6_ENABLED : u32 = 256;
pub const IP_ADAPTER_IPV6_MANAGE_ADDRESS_CONFIG : u32 = 512;
pub const GAA_FLAG_SKIP_DNS_INFO : u32 = 2048;
pub const ANY_SIZE : u32 = 1;
pub const TCPIP_OWNING_MODULE_SIZE : u32 = 16;
pub const MIB_IPADDR_PRIMARY : u32 = 1;
pub const MIB_IPADDR_DYNAMIC : u32 = 4;
pub const MIB_IPADDR_DISCONNECTED : u32 = 8;
pub const MIB_IPADDR_DELETED : u32 = 64;
pub const MIB_IPADDR_TRANSIENT : u32 = 128;
pub const MIB_IPADDR_DNS_ELIGIBLE : u32 = 256;
pub const MIB_IPROUTE_TYPE_OTHER : u32 = 1;
pub const MIB_IPROUTE_TYPE_INVALID : u32 = 2;
pub const MIB_IPROUTE_TYPE_DIRECT : u32 = 3;
pub const MIB_IPROUTE_TYPE_INDIRECT : u32 = 4;
pub const MAXLEN_PHYSADDR : u32 = 8;
pub const MAXLEN_IFDESCR : u32 = 256;
pub const MAX_INTERFACE_NAME_LEN : u32 = 256;
pub const IPRTRMGR_PID : u32 = 10000;
pub const IF_NUMBER : u32 = 0;
pub const MAX_SCOPE_NAME_LEN : u32 = 255;
pub const MAX_MIB_OFFSET : u32 = 8;
pub const NET_IF_OPER_STATUS_DOWN_NOT_AUTHENTICATED : u32 = 1;
pub const NET_IF_OPER_STATUS_DOWN_NOT_MEDIA_CONNECTED : u32 = 2;
pub const NET_IF_OPER_STATUS_DORMANT_PAUSED : u32 = 4;
pub const NET_IF_OPER_STATUS_DORMANT_LOW_POWER : u32 = 8;
pub const NET_IF_OID_IF_ALIAS : u32 = 1;
pub const NET_IF_OID_COMPARTMENT_ID : u32 = 2;
pub const NET_IF_OID_NETWORK_GUID : u32 = 3;
pub const NET_IF_OID_IF_ENTRY : u32 = 4;
pub const NET_SITEID_UNSPECIFIED : u32 = 0;
pub const NET_SITEID_MAXUSER : u32 = 134217727;
pub const NET_SITEID_MAXSYSTEM : u32 = 268435455;
pub const NET_IFLUID_UNSPECIFIED : u32 = 0;
pub const NIIF_HARDWARE_INTERFACE : u32 = 1;
pub const NIIF_FILTER_INTERFACE : u32 = 2;
pub const NIIF_NDIS_RESERVED1 : u32 = 4;
pub const NIIF_NDIS_RESERVED2 : u32 = 8;
pub const NIIF_NDIS_RESERVED3 : u32 = 16;
pub const NIIF_NDIS_WDM_INTERFACE : u32 = 32;
pub const NIIF_NDIS_ENDPOINT_INTERFACE : u32 = 64;
pub const NIIF_NDIS_ISCSI_INTERFACE : u32 = 128;
pub const NIIF_NDIS_RESERVED4 : u32 = 256;
pub const IF_MAX_STRING_SIZE : u32 = 256;
pub const IF_MAX_PHYS_ADDRESS_LENGTH : u32 = 32;
pub const MIN_IF_TYPE : u32 = 1;
pub const IF_TYPE_OTHER : u32 = 1;
pub const IF_TYPE_REGULAR_1822 : u32 = 2;
pub const IF_TYPE_HDH_1822 : u32 = 3;
pub const IF_TYPE_DDN_X25 : u32 = 4;
pub const IF_TYPE_RFC877_X25 : u32 = 5;
pub const IF_TYPE_ETHERNET_CSMACD : u32 = 6;
pub const IF_TYPE_IS088023_CSMACD : u32 = 7;
pub const IF_TYPE_ISO88024_TOKENBUS : u32 = 8;
pub const IF_TYPE_ISO88025_TOKENRING : u32 = 9;
pub const IF_TYPE_ISO88026_MAN : u32 = 10;
pub const IF_TYPE_STARLAN : u32 = 11;
pub const IF_TYPE_PROTEON_10MBIT : u32 = 12;
pub const IF_TYPE_PROTEON_80MBIT : u32 = 13;
pub const IF_TYPE_HYPERCHANNEL : u32 = 14;
pub const IF_TYPE_FDDI : u32 = 15;
pub const IF_TYPE_LAP_B : u32 = 16;
pub const IF_TYPE_SDLC : u32 = 17;
pub const IF_TYPE_DS1 : u32 = 18;
pub const IF_TYPE_E1 : u32 = 19;
pub const IF_TYPE_BASIC_ISDN : u32 = 20;
pub const IF_TYPE_PRIMARY_ISDN : u32 = 21;
pub const IF_TYPE_PROP_POINT2POINT_SERIAL : u32 = 22;
pub const IF_TYPE_PPP : u32 = 23;
pub const IF_TYPE_SOFTWARE_LOOPBACK : u32 = 24;
pub const IF_TYPE_EON : u32 = 25;
pub const IF_TYPE_ETHERNET_3MBIT : u32 = 26;
pub const IF_TYPE_NSIP : u32 = 27;
pub const IF_TYPE_SLIP : u32 = 28;
pub const IF_TYPE_ULTRA : u32 = 29;
pub const IF_TYPE_DS3 : u32 = 30;
pub const IF_TYPE_SIP : u32 = 31;
pub const IF_TYPE_FRAMERELAY : u32 = 32;
pub const IF_TYPE_RS232 : u32 = 33;
pub const IF_TYPE_PARA : u32 = 34;
pub const IF_TYPE_ARCNET : u32 = 35;
pub const IF_TYPE_ARCNET_PLUS : u32 = 36;
pub const IF_TYPE_ATM : u32 = 37;
pub const IF_TYPE_MIO_X25 : u32 = 38;
pub const IF_TYPE_SONET : u32 = 39;
pub const IF_TYPE_X25_PLE : u32 = 40;
pub const IF_TYPE_ISO88022_LLC : u32 = 41;
pub const IF_TYPE_LOCALTALK : u32 = 42;
pub const IF_TYPE_SMDS_DXI : u32 = 43;
pub const IF_TYPE_FRAMERELAY_SERVICE : u32 = 44;
pub const IF_TYPE_V35 : u32 = 45;
pub const IF_TYPE_HSSI : u32 = 46;
pub const IF_TYPE_HIPPI : u32 = 47;
pub const IF_TYPE_MODEM : u32 = 48;
pub const IF_TYPE_AAL5 : u32 = 49;
pub const IF_TYPE_SONET_PATH : u32 = 50;
pub const IF_TYPE_SONET_VT : u32 = 51;
pub const IF_TYPE_SMDS_ICIP : u32 = 52;
pub const IF_TYPE_PROP_VIRTUAL : u32 = 53;
pub const IF_TYPE_PROP_MULTIPLEXOR : u32 = 54;
pub const IF_TYPE_IEEE80212 : u32 = 55;
pub const IF_TYPE_FIBRECHANNEL : u32 = 56;
pub const IF_TYPE_HIPPIINTERFACE : u32 = 57;
pub const IF_TYPE_FRAMERELAY_INTERCONNECT : u32 = 58;
pub const IF_TYPE_AFLANE_8023 : u32 = 59;
pub const IF_TYPE_AFLANE_8025 : u32 = 60;
pub const IF_TYPE_CCTEMUL : u32 = 61;
pub const IF_TYPE_FASTETHER : u32 = 62;
pub const IF_TYPE_ISDN : u32 = 63;
pub const IF_TYPE_V11 : u32 = 64;
pub const IF_TYPE_V36 : u32 = 65;
pub const IF_TYPE_G703_64K : u32 = 66;
pub const IF_TYPE_G703_2MB : u32 = 67;
pub const IF_TYPE_QLLC : u32 = 68;
pub const IF_TYPE_FASTETHER_FX : u32 = 69;
pub const IF_TYPE_CHANNEL : u32 = 70;
pub const IF_TYPE_IEEE80211 : u32 = 71;
pub const IF_TYPE_IBM370PARCHAN : u32 = 72;
pub const IF_TYPE_ESCON : u32 = 73;
pub const IF_TYPE_DLSW : u32 = 74;
pub const IF_TYPE_ISDN_S : u32 = 75;
pub const IF_TYPE_ISDN_U : u32 = 76;
pub const IF_TYPE_LAP_D : u32 = 77;
pub const IF_TYPE_IPSWITCH : u32 = 78;
pub const IF_TYPE_RSRB : u32 = 79;
pub const IF_TYPE_ATM_LOGICAL : u32 = 80;
pub const IF_TYPE_DS0 : u32 = 81;
pub const IF_TYPE_DS0_BUNDLE : u32 = 82;
pub const IF_TYPE_BSC : u32 = 83;
pub const IF_TYPE_ASYNC : u32 = 84;
pub const IF_TYPE_CNR : u32 = 85;
pub const IF_TYPE_ISO88025R_DTR : u32 = 86;
pub const IF_TYPE_EPLRS : u32 = 87;
pub const IF_TYPE_ARAP : u32 = 88;
pub const IF_TYPE_PROP_CNLS : u32 = 89;
pub const IF_TYPE_HOSTPAD : u32 = 90;
pub const IF_TYPE_TERMPAD : u32 = 91;
pub const IF_TYPE_FRAMERELAY_MPI : u32 = 92;
pub const IF_TYPE_X213 : u32 = 93;
pub const IF_TYPE_ADSL : u32 = 94;
pub const IF_TYPE_RADSL : u32 = 95;
pub const IF_TYPE_SDSL : u32 = 96;
pub const IF_TYPE_VDSL : u32 = 97;
pub const IF_TYPE_ISO88025_CRFPRINT : u32 = 98;
pub const IF_TYPE_MYRINET : u32 = 99;
pub const IF_TYPE_VOICE_EM : u32 = 100;
pub const IF_TYPE_VOICE_FXO : u32 = 101;
pub const IF_TYPE_VOICE_FXS : u32 = 102;
pub const IF_TYPE_VOICE_ENCAP : u32 = 103;
pub const IF_TYPE_VOICE_OVERIP : u32 = 104;
pub const IF_TYPE_ATM_DXI : u32 = 105;
pub const IF_TYPE_ATM_FUNI : u32 = 106;
pub const IF_TYPE_ATM_IMA : u32 = 107;
pub const IF_TYPE_PPPMULTILINKBUNDLE : u32 = 108;
pub const IF_TYPE_IPOVER_CDLC : u32 = 109;
pub const IF_TYPE_IPOVER_CLAW : u32 = 110;
pub const IF_TYPE_STACKTOSTACK : u32 = 111;
pub const IF_TYPE_VIRTUALIPADDRESS : u32 = 112;
pub const IF_TYPE_MPC : u32 = 113;
pub const IF_TYPE_IPOVER_ATM : u32 = 114;
pub const IF_TYPE_ISO88025_FIBER : u32 = 115;
pub const IF_TYPE_TDLC : u32 = 116;
pub const IF_TYPE_GIGABITETHERNET : u32 = 117;
pub const IF_TYPE_HDLC : u32 = 118;
pub const IF_TYPE_LAP_F : u32 = 119;
pub const IF_TYPE_V37 : u32 = 120;
pub const IF_TYPE_X25_MLP : u32 = 121;
pub const IF_TYPE_X25_HUNTGROUP : u32 = 122;
pub const IF_TYPE_TRANSPHDLC : u32 = 123;
pub const IF_TYPE_INTERLEAVE : u32 = 124;
pub const IF_TYPE_FAST : u32 = 125;
pub const IF_TYPE_IP : u32 = 126;
pub const IF_TYPE_DOCSCABLE_MACLAYER : u32 = 127;
pub const IF_TYPE_DOCSCABLE_DOWNSTREAM : u32 = 128;
pub const IF_TYPE_DOCSCABLE_UPSTREAM : u32 = 129;
pub const IF_TYPE_A12MPPSWITCH : u32 = 130;
pub const IF_TYPE_TUNNEL : u32 = 131;
pub const IF_TYPE_COFFEE : u32 = 132;
pub const IF_TYPE_CES : u32 = 133;
pub const IF_TYPE_ATM_SUBINTERFACE : u32 = 134;
pub const IF_TYPE_L2_VLAN : u32 = 135;
pub const IF_TYPE_L3_IPVLAN : u32 = 136;
pub const IF_TYPE_L3_IPXVLAN : u32 = 137;
pub const IF_TYPE_DIGITALPOWERLINE : u32 = 138;
pub const IF_TYPE_MEDIAMAILOVERIP : u32 = 139;
pub const IF_TYPE_DTM : u32 = 140;
pub const IF_TYPE_DCN : u32 = 141;
pub const IF_TYPE_IPFORWARD : u32 = 142;
pub const IF_TYPE_MSDSL : u32 = 143;
pub const IF_TYPE_IEEE1394 : u32 = 144;
pub const IF_TYPE_IF_GSN : u32 = 145;
pub const IF_TYPE_DVBRCC_MACLAYER : u32 = 146;
pub const IF_TYPE_DVBRCC_DOWNSTREAM : u32 = 147;
pub const IF_TYPE_DVBRCC_UPSTREAM : u32 = 148;
pub const IF_TYPE_ATM_VIRTUAL : u32 = 149;
pub const IF_TYPE_MPLS_TUNNEL : u32 = 150;
pub const IF_TYPE_SRP : u32 = 151;
pub const IF_TYPE_VOICEOVERATM : u32 = 152;
pub const IF_TYPE_VOICEOVERFRAMERELAY : u32 = 153;
pub const IF_TYPE_IDSL : u32 = 154;
pub const IF_TYPE_COMPOSITELINK : u32 = 155;
pub const IF_TYPE_SS7_SIGLINK : u32 = 156;
pub const IF_TYPE_PROP_WIRELESS_P2P : u32 = 157;
pub const IF_TYPE_FR_FORWARD : u32 = 158;
pub const IF_TYPE_RFC1483 : u32 = 159;
pub const IF_TYPE_USB : u32 = 160;
pub const IF_TYPE_IEEE8023AD_LAG : u32 = 161;
pub const IF_TYPE_BGP_POLICY_ACCOUNTING : u32 = 162;
pub const IF_TYPE_FRF16_MFR_BUNDLE : u32 = 163;
pub const IF_TYPE_H323_GATEKEEPER : u32 = 164;
pub const IF_TYPE_H323_PROXY : u32 = 165;
pub const IF_TYPE_MPLS : u32 = 166;
pub const IF_TYPE_MF_SIGLINK : u32 = 167;
pub const IF_TYPE_HDSL2 : u32 = 168;
pub const IF_TYPE_SHDSL : u32 = 169;
pub const IF_TYPE_DS1_FDL : u32 = 170;
pub const IF_TYPE_POS : u32 = 171;
pub const IF_TYPE_DVB_ASI_IN : u32 = 172;
pub const IF_TYPE_DVB_ASI_OUT : u32 = 173;
pub const IF_TYPE_PLC : u32 = 174;
pub const IF_TYPE_NFAS : u32 = 175;
pub const IF_TYPE_TR008 : u32 = 176;
pub const IF_TYPE_GR303_RDT : u32 = 177;
pub const IF_TYPE_GR303_IDT : u32 = 178;
pub const IF_TYPE_ISUP : u32 = 179;
pub const IF_TYPE_PROP_DOCS_WIRELESS_MACLAYER : u32 = 180;
pub const IF_TYPE_PROP_DOCS_WIRELESS_DOWNSTREAM : u32 = 181;
pub const IF_TYPE_PROP_DOCS_WIRELESS_UPSTREAM : u32 = 182;
pub const IF_TYPE_HIPERLAN2 : u32 = 183;
pub const IF_TYPE_PROP_BWA_P2MP : u32 = 184;
pub const IF_TYPE_SONET_OVERHEAD_CHANNEL : u32 = 185;
pub const IF_TYPE_DIGITAL_WRAPPER_OVERHEAD_CHANNEL : u32 = 186;
pub const IF_TYPE_AAL2 : u32 = 187;
pub const IF_TYPE_RADIO_MAC : u32 = 188;
pub const IF_TYPE_ATM_RADIO : u32 = 189;
pub const IF_TYPE_IMT : u32 = 190;
pub const IF_TYPE_MVL : u32 = 191;
pub const IF_TYPE_REACH_DSL : u32 = 192;
pub const IF_TYPE_FR_DLCI_ENDPT : u32 = 193;
pub const IF_TYPE_ATM_VCI_ENDPT : u32 = 194;
pub const IF_TYPE_OPTICAL_CHANNEL : u32 = 195;
pub const IF_TYPE_OPTICAL_TRANSPORT : u32 = 196;
pub const IF_TYPE_IEEE80216_WMAN : u32 = 237;
pub const IF_TYPE_WWANPP : u32 = 243;
pub const IF_TYPE_WWANPP2 : u32 = 244;
pub const IF_TYPE_IEEE802154 : u32 = 259;
pub const IF_TYPE_XBOX_WIRELESS : u32 = 281;
pub const MAX_IF_TYPE : u32 = 281;
pub const IF_CHECK_NONE : u32 = 0;
pub const IF_CHECK_MCAST : u32 = 1;
pub const IF_CHECK_SEND : u32 = 2;
pub const IF_CONNECTION_DEDICATED : u32 = 1;
pub const IF_CONNECTION_PASSIVE : u32 = 2;
pub const IF_CONNECTION_DEMAND : u32 = 3;
pub const IF_ADMIN_STATUS_UP : u32 = 1;
pub const IF_ADMIN_STATUS_DOWN : u32 = 2;
pub const IF_ADMIN_STATUS_TESTING : u32 = 3;
pub const MIB_IF_TYPE_OTHER : u32 = 1;
pub const MIB_IF_TYPE_ETHERNET : u32 = 6;
pub const MIB_IF_TYPE_TOKENRING : u32 = 9;
pub const MIB_IF_TYPE_FDDI : u32 = 15;
pub const MIB_IF_TYPE_PPP : u32 = 23;
pub const MIB_IF_TYPE_LOOPBACK : u32 = 24;
pub const MIB_IF_TYPE_SLIP : u32 = 28;
pub const MIB_IF_ADMIN_STATUS_TESTING : u32 = 3;
pub const INTERFACE_TIMESTAMP_CAPABILITIES_VERSION_1 : u32 = 1;
pub const INTERFACE_HARDWARE_CROSSTIMESTAMP_VERSION_1 : u32 = 1;
pub const NET_STRING_IPV4_ADDRESS : u32 = 1;
pub const NET_STRING_IPV4_SERVICE : u32 = 2;
pub const NET_STRING_IPV4_NETWORK : u32 = 4;
pub const NET_STRING_IPV6_ADDRESS : u32 = 8;
pub const NET_STRING_IPV6_ADDRESS_NO_SCOPE : u32 = 16;
pub const NET_STRING_IPV6_SERVICE : u32 = 32;
pub const NET_STRING_IPV6_SERVICE_NO_SCOPE : u32 = 64;
pub const NET_STRING_IPV6_NETWORK : u32 = 128;
pub const NET_STRING_NAMED_ADDRESS : u32 = 256;
pub const NET_STRING_NAMED_SERVICE : u32 = 512;
pub const MIB_INVALID_TEREDO_PORT_NUMBER : u32 = 0;
pub const DNS_SETTINGS_VERSION1 : u32 = 1;
pub const DNS_INTERFACE_SETTINGS_VERSION1 : u32 = 1;
pub const DNS_INTERFACE_SETTINGS_VERSION2 : u32 = 2;
pub const DNS_SETTING_IPV6 : u32 = 1;
pub const DNS_SETTING_NAMESERVER : u32 = 2;
pub const DNS_SETTING_SEARCHLIST : u32 = 4;
pub const DNS_SETTING_REGISTRATION_ENABLED : u32 = 8;
pub const DNS_SETTING_REGISTER_ADAPTER_NAME : u32 = 16;
pub const DNS_SETTING_DOMAIN : u32 = 32;
pub const DNS_SETTING_HOSTNAME : u32 = 64;
pub const DNS_SETTINGS_ENABLE_LLMNR : u32 = 128;
pub const DNS_SETTINGS_QUERY_ADAPTER_NAME : u32 = 256;
pub const DNS_SETTING_PROFILE_NAMESERVER : u32 = 512;
pub const DNS_SETTING_DISABLE_UNCONSTRAINED_QUERIES : u32 = 1024;
pub const DNS_SETTING_SUPPLEMENTAL_SEARCH_LIST : u32 = 2048;
pub const IP_EXPORT_INCLUDED : u32 = 1;
pub const MAX_ADAPTER_NAME : u32 = 128;
pub const IP_STATUS_BASE : u32 = 11000;
pub const IP_SUCCESS : u32 = 0;
pub const IP_OPT_EOL : u32 = 0;
pub const IP_OPT_NOP : u32 = 1;
pub const IP_OPT_SECURITY : u32 = 130;
pub const IP_OPT_LSRR : u32 = 131;
pub const IP_OPT_SSRR : u32 = 137;
pub const IP_OPT_RR : u32 = 7;
pub const IP_OPT_TS : u32 = 68;
pub const IP_OPT_SID : u32 = 136;
pub const IP_OPT_ROUTER_ALERT : u32 = 148;
pub const MAX_OPT_SIZE : u32 = 40;
pub const IOCTL_IP_RTCHANGE_NOTIFY_REQUEST : u32 = 101;
pub const IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST : u32 = 102;
pub const IOCTL_ARP_SEND_REQUEST : u32 = 103;
pub const IOCTL_IP_INTERFACE_INFO : u32 = 104;
pub const IOCTL_IP_GET_BEST_INTERFACE : u32 = 105;
pub const IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS : u32 = 106;

//--------------------------------------------------------------------------------
// Section: Types (104)
//--------------------------------------------------------------------------------
pub const HIFTIMESTAMPCHANGE = ?*c_void;

// TODO: this type has a FreeFunc 'IcmpCloseHandle', what can Zig do with this information?
pub const IcmpHandle = ?*c_void;

pub const SCOPE_LEVEL = extern enum(i32) {
    Interface = 1,
    Link = 2,
    Subnet = 3,
    Admin = 4,
    Site = 5,
    Organization = 8,
    Global = 14,
    Count = 16,
};
pub const ScopeLevelInterface = SCOPE_LEVEL.Interface;
pub const ScopeLevelLink = SCOPE_LEVEL.Link;
pub const ScopeLevelSubnet = SCOPE_LEVEL.Subnet;
pub const ScopeLevelAdmin = SCOPE_LEVEL.Admin;
pub const ScopeLevelSite = SCOPE_LEVEL.Site;
pub const ScopeLevelOrganization = SCOPE_LEVEL.Organization;
pub const ScopeLevelGlobal = SCOPE_LEVEL.Global;
pub const ScopeLevelCount = SCOPE_LEVEL.Count;

pub const SOCKADDR_INET = u32; // TODO: implement StructOrUnion types?

pub const SOCKADDR_IN6_PAIR = extern struct {
    SourceAddress: *SOCKADDR_IN6_LH,
    DestinationAddress: *SOCKADDR_IN6_LH,
};

pub const NL_PREFIX_ORIGIN = extern enum(i32) {
    Other = 0,
    Manual = 1,
    WellKnown = 2,
    Dhcp = 3,
    RouterAdvertisement = 4,
    Unchanged = 16,
};
pub const IpPrefixOriginOther = NL_PREFIX_ORIGIN.Other;
pub const IpPrefixOriginManual = NL_PREFIX_ORIGIN.Manual;
pub const IpPrefixOriginWellKnown = NL_PREFIX_ORIGIN.WellKnown;
pub const IpPrefixOriginDhcp = NL_PREFIX_ORIGIN.Dhcp;
pub const IpPrefixOriginRouterAdvertisement = NL_PREFIX_ORIGIN.RouterAdvertisement;
pub const IpPrefixOriginUnchanged = NL_PREFIX_ORIGIN.Unchanged;

pub const NL_SUFFIX_ORIGIN = extern enum(i32) {
    NlsoOther = 0,
    NlsoManual = 1,
    NlsoWellKnown = 2,
    NlsoDhcp = 3,
    NlsoLinkLayerAddress = 4,
    NlsoRandom = 5,
    IpSuffixOriginOther = 0,
    IpSuffixOriginManual = 1,
    IpSuffixOriginWellKnown = 2,
    IpSuffixOriginDhcp = 3,
    IpSuffixOriginLinkLayerAddress = 4,
    IpSuffixOriginRandom = 5,
    IpSuffixOriginUnchanged = 16,
};
pub const NlsoOther = NL_SUFFIX_ORIGIN.NlsoOther;
pub const NlsoManual = NL_SUFFIX_ORIGIN.NlsoManual;
pub const NlsoWellKnown = NL_SUFFIX_ORIGIN.NlsoWellKnown;
pub const NlsoDhcp = NL_SUFFIX_ORIGIN.NlsoDhcp;
pub const NlsoLinkLayerAddress = NL_SUFFIX_ORIGIN.NlsoLinkLayerAddress;
pub const NlsoRandom = NL_SUFFIX_ORIGIN.NlsoRandom;
pub const IpSuffixOriginOther = NL_SUFFIX_ORIGIN.IpSuffixOriginOther;
pub const IpSuffixOriginManual = NL_SUFFIX_ORIGIN.IpSuffixOriginManual;
pub const IpSuffixOriginWellKnown = NL_SUFFIX_ORIGIN.IpSuffixOriginWellKnown;
pub const IpSuffixOriginDhcp = NL_SUFFIX_ORIGIN.IpSuffixOriginDhcp;
pub const IpSuffixOriginLinkLayerAddress = NL_SUFFIX_ORIGIN.IpSuffixOriginLinkLayerAddress;
pub const IpSuffixOriginRandom = NL_SUFFIX_ORIGIN.IpSuffixOriginRandom;
pub const IpSuffixOriginUnchanged = NL_SUFFIX_ORIGIN.IpSuffixOriginUnchanged;

pub const NL_DAD_STATE = extern enum(i32) {
    NldsInvalid = 0,
    NldsTentative = 1,
    NldsDuplicate = 2,
    NldsDeprecated = 3,
    NldsPreferred = 4,
    IpDadStateInvalid = 0,
    IpDadStateTentative = 1,
    IpDadStateDuplicate = 2,
    IpDadStateDeprecated = 3,
    IpDadStatePreferred = 4,
};
pub const NldsInvalid = NL_DAD_STATE.NldsInvalid;
pub const NldsTentative = NL_DAD_STATE.NldsTentative;
pub const NldsDuplicate = NL_DAD_STATE.NldsDuplicate;
pub const NldsDeprecated = NL_DAD_STATE.NldsDeprecated;
pub const NldsPreferred = NL_DAD_STATE.NldsPreferred;
pub const IpDadStateInvalid = NL_DAD_STATE.IpDadStateInvalid;
pub const IpDadStateTentative = NL_DAD_STATE.IpDadStateTentative;
pub const IpDadStateDuplicate = NL_DAD_STATE.IpDadStateDuplicate;
pub const IpDadStateDeprecated = NL_DAD_STATE.IpDadStateDeprecated;
pub const IpDadStatePreferred = NL_DAD_STATE.IpDadStatePreferred;

pub const NL_NETWORK_CONNECTIVITY_LEVEL_HINT = extern enum(i32) {
    Unknown = 0,
    None = 1,
    LocalAccess = 2,
    InternetAccess = 3,
    ConstrainedInternetAccess = 4,
    Hidden = 5,
};
pub const NetworkConnectivityLevelHintUnknown = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.Unknown;
pub const NetworkConnectivityLevelHintNone = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.None;
pub const NetworkConnectivityLevelHintLocalAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.LocalAccess;
pub const NetworkConnectivityLevelHintInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.InternetAccess;
pub const NetworkConnectivityLevelHintConstrainedInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.ConstrainedInternetAccess;
pub const NetworkConnectivityLevelHintHidden = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.Hidden;

pub const NL_NETWORK_CONNECTIVITY_COST_HINT = extern enum(i32) {
    Unknown = 0,
    Unrestricted = 1,
    Fixed = 2,
    Variable = 3,
};
pub const NetworkConnectivityCostHintUnknown = NL_NETWORK_CONNECTIVITY_COST_HINT.Unknown;
pub const NetworkConnectivityCostHintUnrestricted = NL_NETWORK_CONNECTIVITY_COST_HINT.Unrestricted;
pub const NetworkConnectivityCostHintFixed = NL_NETWORK_CONNECTIVITY_COST_HINT.Fixed;
pub const NetworkConnectivityCostHintVariable = NL_NETWORK_CONNECTIVITY_COST_HINT.Variable;

pub const NL_NETWORK_CONNECTIVITY_HINT = extern struct {
    ConnectivityLevel: NL_NETWORK_CONNECTIVITY_LEVEL_HINT,
    ConnectivityCost: NL_NETWORK_CONNECTIVITY_COST_HINT,
    ApproachingDataLimit: u8,
    OverDataLimit: u8,
    Roaming: u8,
};

pub const NL_BANDWIDTH_INFORMATION = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: u8,
};

pub const NET_ADDRESS_INFO = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const Get_Family = extern enum(u32) {
    INET = 2,
    INET6 = 23,
    UNSPEC = 0,
};
pub const AF_INET = Get_Family.INET;
pub const AF_INET6 = Get_Family.INET6;
pub const AF_UNSPEC = Get_Family.UNSPEC;

pub const SetIfEntry_pIfRowFlags = extern enum(u32) {
    UP = 1,
    DOWN = 2,
};
pub const MIB_IF_ADMIN_STATUS_UP = SetIfEntry_pIfRowFlags.UP;
pub const MIB_IF_ADMIN_STATUS_DOWN = SetIfEntry_pIfRowFlags.DOWN;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const GetAdaptersAddresses_Flags = extern enum(u32) {
    SKIP_UNICAST = 1,
    SKIP_ANYCAST = 2,
    SKIP_MULTICAST = 4,
    SKIP_DNS_SERVER = 8,
    INCLUDE_PREFIX = 16,
    SKIP_FRIENDLY_NAME = 32,
    INCLUDE_WINS_INFO = 64,
    INCLUDE_GATEWAYS = 128,
    INCLUDE_ALL_INTERFACES = 256,
    INCLUDE_ALL_COMPARTMENTS = 512,
    INCLUDE_TUNNEL_BINDINGORDER = 1024,
    _,
};
pub const GAA_FLAG_SKIP_UNICAST = GetAdaptersAddresses_Flags.SKIP_UNICAST;
pub const GAA_FLAG_SKIP_ANYCAST = GetAdaptersAddresses_Flags.SKIP_ANYCAST;
pub const GAA_FLAG_SKIP_MULTICAST = GetAdaptersAddresses_Flags.SKIP_MULTICAST;
pub const GAA_FLAG_SKIP_DNS_SERVER = GetAdaptersAddresses_Flags.SKIP_DNS_SERVER;
pub const GAA_FLAG_INCLUDE_PREFIX = GetAdaptersAddresses_Flags.INCLUDE_PREFIX;
pub const GAA_FLAG_SKIP_FRIENDLY_NAME = GetAdaptersAddresses_Flags.SKIP_FRIENDLY_NAME;
pub const GAA_FLAG_INCLUDE_WINS_INFO = GetAdaptersAddresses_Flags.INCLUDE_WINS_INFO;
pub const GAA_FLAG_INCLUDE_GATEWAYS = GetAdaptersAddresses_Flags.INCLUDE_GATEWAYS;
pub const GAA_FLAG_INCLUDE_ALL_INTERFACES = GetAdaptersAddresses_Flags.INCLUDE_ALL_INTERFACES;
pub const GAA_FLAG_INCLUDE_ALL_COMPARTMENTS = GetAdaptersAddresses_Flags.INCLUDE_ALL_COMPARTMENTS;
pub const GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER = GetAdaptersAddresses_Flags.INCLUDE_TUNNEL_BINDINGORDER;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const IP_FLAG = extern enum(u32) {
    REVERSE = 1,
    DF = 2,
    _,
};
pub const IP_FLAG_REVERSE = IP_FLAG.REVERSE;
pub const IP_FLAG_DF = IP_FLAG.DF;

pub const ip_option_information = extern struct {
    Ttl: u8,
    Tos: u8,
    Flags: u8,
    OptionsSize: u8,
    OptionsData: *u8,
};

pub const icmp_echo_reply = extern struct {
    Address: u32,
    Status: u32,
    RoundTripTime: u32,
    DataSize: u16,
    Reserved: u16,
    Data: *c_void,
    Options: ip_option_information,
};

pub const IPV6_ADDRESS_EX = extern struct {
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: [8]u16,
    sin6_scope_id: u32,
};

pub const icmpv6_echo_reply_lh = extern struct {
    Address: IPV6_ADDRESS_EX,
    Status: u32,
    RoundTripTime: u32,
};

pub const arp_send_reply = extern struct {
    DestAddress: u32,
    SrcAddress: u32,
};

pub const tcp_reserve_port_range = extern struct {
    UpperRange: u16,
    LowerRange: u16,
};

pub const IP_ADAPTER_INDEX_MAP = extern struct {
    Index: u32,
    Name: [128]u16,
};

pub const IP_INTERFACE_INFO = extern struct {
    NumAdapters: i32,
    Adapter: [1]IP_ADAPTER_INDEX_MAP,
};

pub const IP_UNIDIRECTIONAL_ADAPTER_ADDRESS = extern struct {
    NumAdapters: u32,
    Address: [1]u32,
};

pub const IP_ADAPTER_ORDER_MAP = extern struct {
    NumAdapters: u32,
    AdapterOrder: [1]u32,
};

pub const IP_MCAST_COUNTER_INFO = extern struct {
    InMcastOctets: u64,
    OutMcastOctets: u64,
    InMcastPkts: u64,
    OutMcastPkts: u64,
};

pub const IF_ACCESS_TYPE = extern enum(i32) {
    LOOPBACK = 1,
    BROADCAST = 2,
    POINT_TO_POINT = 3,
    POINTTOPOINT = 3,
    POINT_TO_MULTI_POINT = 4,
    POINTTOMULTIPOINT = 4,
};
pub const IF_ACCESS_LOOPBACK = IF_ACCESS_TYPE.LOOPBACK;
pub const IF_ACCESS_BROADCAST = IF_ACCESS_TYPE.BROADCAST;
pub const IF_ACCESS_POINT_TO_POINT = IF_ACCESS_TYPE.POINT_TO_POINT;
pub const IF_ACCESS_POINTTOPOINT = IF_ACCESS_TYPE.POINTTOPOINT;
pub const IF_ACCESS_POINT_TO_MULTI_POINT = IF_ACCESS_TYPE.POINT_TO_MULTI_POINT;
pub const IF_ACCESS_POINTTOMULTIPOINT = IF_ACCESS_TYPE.POINTTOMULTIPOINT;

pub const INTERNAL_IF_OPER_STATUS = extern enum(i32) {
    NON_OPERATIONAL = 0,
    UNREACHABLE = 1,
    DISCONNECTED = 2,
    CONNECTING = 3,
    CONNECTED = 4,
    OPERATIONAL = 5,
};
pub const IF_OPER_STATUS_NON_OPERATIONAL = INTERNAL_IF_OPER_STATUS.NON_OPERATIONAL;
pub const IF_OPER_STATUS_UNREACHABLE = INTERNAL_IF_OPER_STATUS.UNREACHABLE;
pub const IF_OPER_STATUS_DISCONNECTED = INTERNAL_IF_OPER_STATUS.DISCONNECTED;
pub const IF_OPER_STATUS_CONNECTING = INTERNAL_IF_OPER_STATUS.CONNECTING;
pub const IF_OPER_STATUS_CONNECTED = INTERNAL_IF_OPER_STATUS.CONNECTED;
pub const IF_OPER_STATUS_OPERATIONAL = INTERNAL_IF_OPER_STATUS.OPERATIONAL;

pub const NET_IF_RCV_ADDRESS_TYPE = extern enum(i32) {
    OTHER = 1,
    VOLATILE = 2,
    NON_VOLATILE = 3,
};
pub const NET_IF_RCV_ADDRESS_TYPE_OTHER = NET_IF_RCV_ADDRESS_TYPE.OTHER;
pub const NET_IF_RCV_ADDRESS_TYPE_VOLATILE = NET_IF_RCV_ADDRESS_TYPE.VOLATILE;
pub const NET_IF_RCV_ADDRESS_TYPE_NON_VOLATILE = NET_IF_RCV_ADDRESS_TYPE.NON_VOLATILE;

pub const NET_IF_RCV_ADDRESS_LH = extern struct {
    ifRcvAddressType: NET_IF_RCV_ADDRESS_TYPE,
    ifRcvAddressLength: u16,
    ifRcvAddressOffset: u16,
};

pub const NET_IF_ALIAS_LH = extern struct {
    ifAliasLength: u16,
    ifAliasOffset: u16,
};

pub const NET_LUID_LH = u32; // TODO: implement StructOrUnion types?

pub const IF_PHYSICAL_ADDRESS_LH = extern struct {
    Length: u16,
    Address: [32]u8,
};

pub const IF_ADMINISTRATIVE_STATE = extern enum(i32) {
    DISABLED = 0,
    ENABLED = 1,
    DEMANDDIAL = 2,
};
pub const IF_ADMINISTRATIVE_DISABLED = IF_ADMINISTRATIVE_STATE.DISABLED;
pub const IF_ADMINISTRATIVE_ENABLED = IF_ADMINISTRATIVE_STATE.ENABLED;
pub const IF_ADMINISTRATIVE_DEMANDDIAL = IF_ADMINISTRATIVE_STATE.DEMANDDIAL;

pub const IF_OPER_STATUS = extern enum(i32) {
    Up = 1,
    Down = 2,
    Testing = 3,
    Unknown = 4,
    Dormant = 5,
    NotPresent = 6,
    LowerLayerDown = 7,
};
pub const IfOperStatusUp = IF_OPER_STATUS.Up;
pub const IfOperStatusDown = IF_OPER_STATUS.Down;
pub const IfOperStatusTesting = IF_OPER_STATUS.Testing;
pub const IfOperStatusUnknown = IF_OPER_STATUS.Unknown;
pub const IfOperStatusDormant = IF_OPER_STATUS.Dormant;
pub const IfOperStatusNotPresent = IF_OPER_STATUS.NotPresent;
pub const IfOperStatusLowerLayerDown = IF_OPER_STATUS.LowerLayerDown;

pub const MIB_IF_ENTRY_LEVEL = extern enum(i32) {
    l = 0,
    WithoutStatistics = 2,
};
pub const MibIfEntryNormal = MIB_IF_ENTRY_LEVEL.l;
pub const MibIfEntryNormalWithoutStatistics = MIB_IF_ENTRY_LEVEL.WithoutStatistics;

pub const PIPINTERFACE_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Row: *MIB_IPINTERFACE_ROW,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PUNICAST_IPADDRESS_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK = fn(
    CallerContext: *c_void,
    AddressTable: *MIB_UNICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const IP_ADDRESS_PREFIX = extern struct {
    Prefix: SOCKADDR_INET,
    PrefixLength: u8,
};

pub const PIPFORWARD_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Row: ?*MIB_IPFORWARD_ROW2,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PTEREDO_PORT_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Port: u16,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const DNS_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Hostname: PWSTR,
    Domain: PWSTR,
    SearchList: PWSTR,
};

pub const DNS_INTERFACE_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Domain: PWSTR,
    NameServer: PWSTR,
    SearchList: PWSTR,
    RegistrationEnabled: u32,
    RegisterAdapterName: u32,
    EnableLLMNR: u32,
    QueryAdapterName: u32,
    ProfileNameServer: PWSTR,
};

pub const DNS_INTERFACE_SETTINGS_EX = extern struct {
    SettingsV1: DNS_INTERFACE_SETTINGS,
    DisableUnconstrainedQueries: u32,
    SupplementalSearchList: PWSTR,
};

pub const PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    ConnectivityHint: NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIB_IPFORWARD_TYPE = extern enum(i32) {
    OTHER = 1,
    INVALID = 2,
    DIRECT = 3,
    INDIRECT = 4,
};
// TODO: enum 'MIB_IPFORWARD_TYPE' has known issues with its value aliases

pub const MIB_IPNET_TYPE = extern enum(i32) {
    OTHER = 1,
    INVALID = 2,
    DYNAMIC = 3,
    STATIC = 4,
};
pub const MIB_IPNET_TYPE_OTHER = MIB_IPNET_TYPE.OTHER;
pub const MIB_IPNET_TYPE_INVALID = MIB_IPNET_TYPE.INVALID;
pub const MIB_IPNET_TYPE_DYNAMIC = MIB_IPNET_TYPE.DYNAMIC;
pub const MIB_IPNET_TYPE_STATIC = MIB_IPNET_TYPE.STATIC;

pub const MIB_IPSTATS_FORWARDING = extern enum(i32) {
    FORWARDING = 1,
    NOT_FORWARDING = 2,
};
pub const MIB_IP_FORWARDING = MIB_IPSTATS_FORWARDING.FORWARDING;
pub const MIB_IP_NOT_FORWARDING = MIB_IPSTATS_FORWARDING.NOT_FORWARDING;

pub const MIB_TCP_STATE = extern enum(i32) {
    CLOSED = 1,
    LISTEN = 2,
    SYN_SENT = 3,
    SYN_RCVD = 4,
    ESTAB = 5,
    FIN_WAIT1 = 6,
    FIN_WAIT2 = 7,
    CLOSE_WAIT = 8,
    CLOSING = 9,
    LAST_ACK = 10,
    TIME_WAIT = 11,
    DELETE_TCB = 12,
    RESERVED = 100,
};
pub const MIB_TCP_STATE_CLOSED = MIB_TCP_STATE.CLOSED;
pub const MIB_TCP_STATE_LISTEN = MIB_TCP_STATE.LISTEN;
pub const MIB_TCP_STATE_SYN_SENT = MIB_TCP_STATE.SYN_SENT;
pub const MIB_TCP_STATE_SYN_RCVD = MIB_TCP_STATE.SYN_RCVD;
pub const MIB_TCP_STATE_ESTAB = MIB_TCP_STATE.ESTAB;
pub const MIB_TCP_STATE_FIN_WAIT1 = MIB_TCP_STATE.FIN_WAIT1;
pub const MIB_TCP_STATE_FIN_WAIT2 = MIB_TCP_STATE.FIN_WAIT2;
pub const MIB_TCP_STATE_CLOSE_WAIT = MIB_TCP_STATE.CLOSE_WAIT;
pub const MIB_TCP_STATE_CLOSING = MIB_TCP_STATE.CLOSING;
pub const MIB_TCP_STATE_LAST_ACK = MIB_TCP_STATE.LAST_ACK;
pub const MIB_TCP_STATE_TIME_WAIT = MIB_TCP_STATE.TIME_WAIT;
pub const MIB_TCP_STATE_DELETE_TCB = MIB_TCP_STATE.DELETE_TCB;
pub const MIB_TCP_STATE_RESERVED = MIB_TCP_STATE.RESERVED;

pub const TCP_RTO_ALGORITHM = extern enum(i32) {
    TcpRtoAlgorithmOther = 1,
    TcpRtoAlgorithmConstant = 2,
    TcpRtoAlgorithmRsre = 3,
    TcpRtoAlgorithmVanj = 4,
    MIB_TCP_RTO_OTHER = 1,
    MIB_TCP_RTO_CONSTANT = 2,
    MIB_TCP_RTO_RSRE = 3,
    MIB_TCP_RTO_VANJ = 4,
};
pub const TcpRtoAlgorithmOther = TCP_RTO_ALGORITHM.TcpRtoAlgorithmOther;
pub const TcpRtoAlgorithmConstant = TCP_RTO_ALGORITHM.TcpRtoAlgorithmConstant;
pub const TcpRtoAlgorithmRsre = TCP_RTO_ALGORITHM.TcpRtoAlgorithmRsre;
pub const TcpRtoAlgorithmVanj = TCP_RTO_ALGORITHM.TcpRtoAlgorithmVanj;
pub const MIB_TCP_RTO_OTHER = TCP_RTO_ALGORITHM.MIB_TCP_RTO_OTHER;
pub const MIB_TCP_RTO_CONSTANT = TCP_RTO_ALGORITHM.MIB_TCP_RTO_CONSTANT;
pub const MIB_TCP_RTO_RSRE = TCP_RTO_ALGORITHM.MIB_TCP_RTO_RSRE;
pub const MIB_TCP_RTO_VANJ = TCP_RTO_ALGORITHM.MIB_TCP_RTO_VANJ;

pub const TCP_TABLE_CLASS = extern enum(i32) {
    BASIC_LISTENER = 0,
    BASIC_CONNECTIONS = 1,
    BASIC_ALL = 2,
    OWNER_PID_LISTENER = 3,
    OWNER_PID_CONNECTIONS = 4,
    OWNER_PID_ALL = 5,
    OWNER_MODULE_LISTENER = 6,
    OWNER_MODULE_CONNECTIONS = 7,
    OWNER_MODULE_ALL = 8,
};
pub const TCP_TABLE_BASIC_LISTENER = TCP_TABLE_CLASS.BASIC_LISTENER;
pub const TCP_TABLE_BASIC_CONNECTIONS = TCP_TABLE_CLASS.BASIC_CONNECTIONS;
pub const TCP_TABLE_BASIC_ALL = TCP_TABLE_CLASS.BASIC_ALL;
pub const TCP_TABLE_OWNER_PID_LISTENER = TCP_TABLE_CLASS.OWNER_PID_LISTENER;
pub const TCP_TABLE_OWNER_PID_CONNECTIONS = TCP_TABLE_CLASS.OWNER_PID_CONNECTIONS;
pub const TCP_TABLE_OWNER_PID_ALL = TCP_TABLE_CLASS.OWNER_PID_ALL;
pub const TCP_TABLE_OWNER_MODULE_LISTENER = TCP_TABLE_CLASS.OWNER_MODULE_LISTENER;
pub const TCP_TABLE_OWNER_MODULE_CONNECTIONS = TCP_TABLE_CLASS.OWNER_MODULE_CONNECTIONS;
pub const TCP_TABLE_OWNER_MODULE_ALL = TCP_TABLE_CLASS.OWNER_MODULE_ALL;

pub const UDP_TABLE_CLASS = extern enum(i32) {
    BASIC = 0,
    OWNER_PID = 1,
    OWNER_MODULE = 2,
};
pub const UDP_TABLE_BASIC = UDP_TABLE_CLASS.BASIC;
pub const UDP_TABLE_OWNER_PID = UDP_TABLE_CLASS.OWNER_PID;
pub const UDP_TABLE_OWNER_MODULE = UDP_TABLE_CLASS.OWNER_MODULE;

pub const TCPIP_OWNER_MODULE_INFO_CLASS = extern enum(i32) {
    C = 0,
};
pub const TCPIP_OWNER_MODULE_INFO_BASIC = TCPIP_OWNER_MODULE_INFO_CLASS.C;

pub const TCPIP_OWNER_MODULE_BASIC_INFO = extern struct {
    pModuleName: [*]u16,
    pModulePath: [*]u16,
};

pub const MIB_IPDESTROW = extern struct {
    ForwardRow: MIB_IPFORWARDROW,
    dwForwardPreference: u32,
    dwForwardViewSet: u32,
};

pub const MIB_IPDESTTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPDESTROW,
};

pub const MIB_ROUTESTATE = extern struct {
    bRoutesSetToStack: BOOL,
};

pub const IP_ADDRESS_STRING = extern struct {
    String: [16]i8,
};

pub const IP_ADDR_STRING = extern struct {
    Next: *IP_ADDR_STRING,
    IpAddress: IP_ADDRESS_STRING,
    IpMask: IP_ADDRESS_STRING,
    Context: u32,
};

pub const IP_ADAPTER_INFO = extern struct {
    Next: *IP_ADAPTER_INFO,
    ComboIndex: u32,
    AdapterName: [260]i8,
    Description: [132]i8,
    AddressLength: u32,
    Address: [8]u8,
    Index: u32,
    Type: u32,
    DhcpEnabled: u32,
    CurrentIpAddress: *IP_ADDR_STRING,
    IpAddressList: IP_ADDR_STRING,
    GatewayList: IP_ADDR_STRING,
    DhcpServer: IP_ADDR_STRING,
    HaveWins: BOOL,
    PrimaryWinsServer: IP_ADDR_STRING,
    SecondaryWinsServer: IP_ADDR_STRING,
    LeaseObtained: i64,
    LeaseExpires: i64,
};

pub const IP_ADAPTER_UNICAST_ADDRESS_LH = extern struct {
    Anonymous: IP_ADAPTER_UNICAST_ADDRESS_LH._Anonymous_e__Union,
    Next: *IP_ADAPTER_UNICAST_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
    OnLinkPrefixLength: u8,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_UNICAST_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_UNICAST_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_UNICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_ANYCAST_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_ANYCAST_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_ANYCAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_MULTICAST_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_MULTICAST_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_MULTICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_DNS_SERVER_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_DNS_SERVER_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_WINS_SERVER_ADDRESS_LH = extern struct {
    Anonymous: IP_ADAPTER_WINS_SERVER_ADDRESS_LH._Anonymous_e__Union,
    Next: *IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_GATEWAY_ADDRESS_LH = extern struct {
    Anonymous: IP_ADAPTER_GATEWAY_ADDRESS_LH._Anonymous_e__Union,
    Next: *IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_PREFIX_XP = extern struct {
    Anonymous: IP_ADAPTER_PREFIX_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_PREFIX_XP,
    Address: SOCKET_ADDRESS,
    PrefixLength: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_DNS_SUFFIX = extern struct {
    Next: *IP_ADAPTER_DNS_SUFFIX,
    String: [256]u16,
};

pub const IP_ADAPTER_ADDRESSES_LH = extern struct {
    Anonymous1: IP_ADAPTER_ADDRESSES_LH._Anonymous1_e__Union,
    Next: *IP_ADAPTER_ADDRESSES_LH,
    AdapterName: [*]u8,
    FirstUnicastAddress: *IP_ADAPTER_UNICAST_ADDRESS_LH,
    FirstAnycastAddress: *IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: *IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: *IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: [*]u16,
    Description: [*]u16,
    FriendlyName: [*]u16,
    PhysicalAddress: [8]u8,
    PhysicalAddressLength: u32,
    Anonymous2: IP_ADAPTER_ADDRESSES_LH._Anonymous2_e__Union,
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: [16]u32,
    FirstPrefix: *IP_ADAPTER_PREFIX_XP,
    TransmitLinkSpeed: u64,
    ReceiveLinkSpeed: u64,
    FirstWinsServerAddress: *IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    FirstGatewayAddress: *IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Ipv4Metric: u32,
    Ipv6Metric: u32,
    Luid: NET_LUID_LH,
    Dhcpv4Server: SOCKET_ADDRESS,
    CompartmentId: u32,
    NetworkGuid: Guid,
    ConnectionType: NET_IF_CONNECTION_TYPE,
    TunnelType: TUNNEL_TYPE,
    Dhcpv6Server: SOCKET_ADDRESS,
    Dhcpv6ClientDuid: [130]u8,
    Dhcpv6ClientDuidLength: u32,
    Dhcpv6Iaid: u32,
    FirstDnsSuffix: *IP_ADAPTER_DNS_SUFFIX,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_ADDRESSES_XP = extern struct {
    Anonymous: IP_ADAPTER_ADDRESSES_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_ADDRESSES_XP,
    AdapterName: [*]u8,
    FirstUnicastAddress: *IP_ADAPTER_UNICAST_ADDRESS_XP,
    FirstAnycastAddress: *IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: *IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: *IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: [*]u16,
    Description: [*]u16,
    FriendlyName: [*]u16,
    PhysicalAddress: [8]u8,
    PhysicalAddressLength: u32,
    Flags: u32,
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: [16]u32,
    FirstPrefix: *IP_ADAPTER_PREFIX_XP,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_PER_ADAPTER_INFO_W2KSP1 = extern struct {
    AutoconfigEnabled: u32,
    AutoconfigActive: u32,
    CurrentDnsServer: *IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
};

pub const FIXED_INFO_W2KSP1 = extern struct {
    HostName: [132]i8,
    DomainName: [132]i8,
    CurrentDnsServer: *IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
    NodeType: u32,
    ScopeId: [260]i8,
    EnableRouting: u32,
    EnableProxy: u32,
    EnableDns: u32,
};

pub const ip_interface_name_info_w2ksp1 = extern struct {
    Index: u32,
    MediaType: u32,
    ConnectionType: u8,
    AccessType: u8,
    DeviceGuid: Guid,
    InterfaceGuid: Guid,
};

pub const TCP_ESTATS_TYPE = extern enum(i32) {
    SynOpts = 0,
    Data = 1,
    SndCong = 2,
    Path = 3,
    SendBuff = 4,
    Rec = 5,
    ObsRec = 6,
    Bandwidth = 7,
    FineRtt = 8,
    Maximum = 9,
};
pub const TcpConnectionEstatsSynOpts = TCP_ESTATS_TYPE.SynOpts;
pub const TcpConnectionEstatsData = TCP_ESTATS_TYPE.Data;
pub const TcpConnectionEstatsSndCong = TCP_ESTATS_TYPE.SndCong;
pub const TcpConnectionEstatsPath = TCP_ESTATS_TYPE.Path;
pub const TcpConnectionEstatsSendBuff = TCP_ESTATS_TYPE.SendBuff;
pub const TcpConnectionEstatsRec = TCP_ESTATS_TYPE.Rec;
pub const TcpConnectionEstatsObsRec = TCP_ESTATS_TYPE.ObsRec;
pub const TcpConnectionEstatsBandwidth = TCP_ESTATS_TYPE.Bandwidth;
pub const TcpConnectionEstatsFineRtt = TCP_ESTATS_TYPE.FineRtt;
pub const TcpConnectionEstatsMaximum = TCP_ESTATS_TYPE.Maximum;

pub const TCP_BOOLEAN_OPTIONAL = extern enum(i32) {
    Disabled = 0,
    Enabled = 1,
    Unchanged = -1,
};
pub const TcpBoolOptDisabled = TCP_BOOLEAN_OPTIONAL.Disabled;
pub const TcpBoolOptEnabled = TCP_BOOLEAN_OPTIONAL.Enabled;
pub const TcpBoolOptUnchanged = TCP_BOOLEAN_OPTIONAL.Unchanged;

pub const TCP_ESTATS_SYN_OPTS_ROS_v0 = extern struct {
    ActiveOpen: u8,
    MssRcvd: u32,
    MssSent: u32,
};

pub const TCP_SOFT_ERROR = extern enum(i32) {
    None = 0,
    BelowDataWindow = 1,
    AboveDataWindow = 2,
    BelowAckWindow = 3,
    AboveAckWindow = 4,
    BelowTsWindow = 5,
    AboveTsWindow = 6,
    DataChecksumError = 7,
    DataLengthError = 8,
    MaxSoftError = 9,
};
pub const TcpErrorNone = TCP_SOFT_ERROR.None;
pub const TcpErrorBelowDataWindow = TCP_SOFT_ERROR.BelowDataWindow;
pub const TcpErrorAboveDataWindow = TCP_SOFT_ERROR.AboveDataWindow;
pub const TcpErrorBelowAckWindow = TCP_SOFT_ERROR.BelowAckWindow;
pub const TcpErrorAboveAckWindow = TCP_SOFT_ERROR.AboveAckWindow;
pub const TcpErrorBelowTsWindow = TCP_SOFT_ERROR.BelowTsWindow;
pub const TcpErrorAboveTsWindow = TCP_SOFT_ERROR.AboveTsWindow;
pub const TcpErrorDataChecksumError = TCP_SOFT_ERROR.DataChecksumError;
pub const TcpErrorDataLengthError = TCP_SOFT_ERROR.DataLengthError;
pub const TcpErrorMaxSoftError = TCP_SOFT_ERROR.MaxSoftError;

pub const TCP_ESTATS_DATA_ROD_v0 = extern struct {
    DataBytesOut: u64,
    DataSegsOut: u64,
    DataBytesIn: u64,
    DataSegsIn: u64,
    SegsOut: u64,
    SegsIn: u64,
    SoftErrors: u32,
    SoftErrorReason: u32,
    SndUna: u32,
    SndNxt: u32,
    SndMax: u32,
    ThruBytesAcked: u64,
    RcvNxt: u32,
    ThruBytesReceived: u64,
};

pub const TCP_ESTATS_DATA_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_SND_CONG_ROD_v0 = extern struct {
    SndLimTransRwin: u32,
    SndLimTimeRwin: u32,
    SndLimBytesRwin: ?*c_void,
    SndLimTransCwnd: u32,
    SndLimTimeCwnd: u32,
    SndLimBytesCwnd: ?*c_void,
    SndLimTransSnd: u32,
    SndLimTimeSnd: u32,
    SndLimBytesSnd: ?*c_void,
    SlowStart: u32,
    CongAvoid: u32,
    OtherReductions: u32,
    CurCwnd: u32,
    MaxSsCwnd: u32,
    MaxCaCwnd: u32,
    CurSsthresh: u32,
    MaxSsthresh: u32,
    MinSsthresh: u32,
};

pub const TCP_ESTATS_SND_CONG_ROS_v0 = extern struct {
    LimCwnd: u32,
};

pub const TCP_ESTATS_SND_CONG_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_PATH_ROD_v0 = extern struct {
    FastRetran: u32,
    Timeouts: u32,
    SubsequentTimeouts: u32,
    CurTimeoutCount: u32,
    AbruptTimeouts: u32,
    PktsRetrans: u32,
    BytesRetrans: u32,
    DupAcksIn: u32,
    SacksRcvd: u32,
    SackBlocksRcvd: u32,
    CongSignals: u32,
    PreCongSumCwnd: u32,
    PreCongSumRtt: u32,
    PostCongSumRtt: u32,
    PostCongCountRtt: u32,
    EcnSignals: u32,
    EceRcvd: u32,
    SendStall: u32,
    QuenchRcvd: u32,
    RetranThresh: u32,
    SndDupAckEpisodes: u32,
    SumBytesReordered: u32,
    NonRecovDa: u32,
    NonRecovDaEpisodes: u32,
    AckAfterFr: u32,
    DsackDups: u32,
    SampleRtt: u32,
    SmoothedRtt: u32,
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
    CountRtt: u32,
    CurRto: u32,
    MaxRto: u32,
    MinRto: u32,
    CurMss: u32,
    MaxMss: u32,
    MinMss: u32,
    SpuriousRtoDetections: u32,
};

pub const TCP_ESTATS_PATH_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_SEND_BUFF_ROD_v0 = extern struct {
    CurRetxQueue: ?*c_void,
    MaxRetxQueue: ?*c_void,
    CurAppWQueue: ?*c_void,
    MaxAppWQueue: ?*c_void,
};

pub const TCP_ESTATS_SEND_BUFF_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_REC_ROD_v0 = extern struct {
    CurRwinSent: u32,
    MaxRwinSent: u32,
    MinRwinSent: u32,
    LimRwin: u32,
    DupAckEpisodes: u32,
    DupAcksOut: u32,
    CeRcvd: u32,
    EcnSent: u32,
    EcnNoncesRcvd: u32,
    CurReasmQueue: u32,
    MaxReasmQueue: u32,
    CurAppRQueue: ?*c_void,
    MaxAppRQueue: ?*c_void,
    WinScaleSent: u8,
};

pub const TCP_ESTATS_REC_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_OBS_REC_ROD_v0 = extern struct {
    CurRwinRcvd: u32,
    MaxRwinRcvd: u32,
    MinRwinRcvd: u32,
    WinScaleRcvd: u8,
};

pub const TCP_ESTATS_OBS_REC_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_BANDWIDTH_RW_v0 = extern struct {
    EnableCollectionOutbound: TCP_BOOLEAN_OPTIONAL,
    EnableCollectionInbound: TCP_BOOLEAN_OPTIONAL,
};

pub const TCP_ESTATS_BANDWIDTH_ROD_v0 = extern struct {
    OutboundBandwidth: u64,
    InboundBandwidth: u64,
    OutboundInstability: u64,
    InboundInstability: u64,
    OutboundBandwidthPeaked: u8,
    InboundBandwidthPeaked: u8,
};

pub const TCP_ESTATS_FINE_RTT_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_FINE_RTT_ROD_v0 = extern struct {
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
};

pub const INTERFACE_TIMESTAMP_CAPABILITY_FLAGS = extern struct {
    PtpV2OverUdpIPv4EventMsgReceiveHw: u8,
    PtpV2OverUdpIPv4AllMsgReceiveHw: u8,
    PtpV2OverUdpIPv4EventMsgTransmitHw: u8,
    PtpV2OverUdpIPv4AllMsgTransmitHw: u8,
    PtpV2OverUdpIPv6EventMsgReceiveHw: u8,
    PtpV2OverUdpIPv6AllMsgReceiveHw: u8,
    PtpV2OverUdpIPv6EventMsgTransmitHw: u8,
    PtpV2OverUdpIPv6AllMsgTransmitHw: u8,
    AllReceiveHw: u8,
    AllTransmitHw: u8,
    TaggedTransmitHw: u8,
    AllReceiveSw: u8,
    AllTransmitSw: u8,
    TaggedTransmitSw: u8,
};

pub const INTERFACE_TIMESTAMP_CAPABILITIES = extern struct {
    Version: u32,
    HardwareClockFrequencyHz: u64,
    CrossTimestamp: u8,
    Reserved1: u64,
    Reserved2: u64,
    TimestampFlags: INTERFACE_TIMESTAMP_CAPABILITY_FLAGS,
};

pub const INTERFACE_HARDWARE_CROSSTIMESTAMP = extern struct {
    Version: u32,
    Flags: u32,
    SystemTimestamp1: u64,
    HardwareClockTimestamp: u64,
    SystemTimestamp2: u64,
};

pub const INTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const NET_ADDRESS_FORMAT = extern enum(i32) {
    FORMAT_UNSPECIFIED = 0,
    DNS_NAME = 1,
    IPV4 = 2,
    IPV6 = 3,
};
pub const NET_ADDRESS_FORMAT_UNSPECIFIED = NET_ADDRESS_FORMAT.FORMAT_UNSPECIFIED;
pub const NET_ADDRESS_DNS_NAME = NET_ADDRESS_FORMAT.DNS_NAME;
pub const NET_ADDRESS_IPV4 = NET_ADDRESS_FORMAT.IPV4;
pub const NET_ADDRESS_IPV6 = NET_ADDRESS_FORMAT.IPV6;


//--------------------------------------------------------------------------------
// Section: Functions (190)
//--------------------------------------------------------------------------------
pub extern "ntdll" fn RtlIpv4AddressToStringA(
    Addr: *const in_addr,
    S: *[16]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "ntdll" fn RtlIpv4AddressToStringW(
    Addr: *const in_addr,
    S: *[16]u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

pub extern "ntdll" fn RtlIpv4AddressToStringExW(
    Address: *const in_addr,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressA(
    S: [*:0]const u8,
    Strict: u8,
    Terminator: *PSTR,
    Addr: *in_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressW(
    S: [*:0]const u16,
    Strict: u8,
    Terminator: *PWSTR,
    Addr: *in_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressExW(
    AddressString: [*:0]const u16,
    Strict: u8,
    Address: *in_addr,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6AddressToStringA(
    Addr: *const in6_addr,
    S: *[46]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "ntdll" fn RtlIpv6AddressToStringW(
    Addr: *const in6_addr,
    S: *[46]u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

pub extern "ntdll" fn RtlIpv6AddressToStringExW(
    Address: *const in6_addr,
    ScopeId: u32,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressA(
    S: [*:0]const u8,
    Terminator: *PSTR,
    Addr: *in6_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressW(
    S: [*:0]const u16,
    Terminator: *PWSTR,
    Addr: *in6_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressExW(
    AddressString: [*:0]const u16,
    Address: *in6_addr,
    ScopeId: *u32,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlEthernetAddressToStringA(
    Addr: *const DL_EUI48,
    S: *[18]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "ntdll" fn RtlEthernetAddressToStringW(
    Addr: *const DL_EUI48,
    S: *[18]u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

pub extern "ntdll" fn RtlEthernetStringToAddressA(
    S: [*:0]const u8,
    Terminator: *PSTR,
    Addr: *DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlEthernetStringToAddressW(
    S: [*:0]const u16,
    Terminator: *PWSTR,
    Addr: *DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "IPHLPAPI" fn GetIfEntry2(
    Row: *MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIfEntry2Ex(
    Level: MIB_IF_ENTRY_LEVEL,
    Row: *MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIfTable2(
    Table: **MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIfTable2Ex(
    Level: MIB_IF_TABLE_LEVEL,
    Table: **MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIfStackTable(
    Table: **MIB_IFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetInvertedIfStackTable(
    Table: **MIB_INVERTEDIFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpInterfaceEntry(
    Row: *MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpInterfaceTable(
    Family: u16,
    Table: **MIB_IPINTERFACE_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn InitializeIpInterfaceEntry(
    Row: *MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn NotifyIpInterfaceChange(
    Family: u16,
    Callback: PIPINTERFACE_CHANGE_CALLBACK,
    CallerContext: ?*c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn SetIpInterfaceEntry(
    Row: *MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpNetworkConnectionBandwidthEstimates(
    InterfaceIndex: u32,
    AddressFamily: u16,
    BandwidthEstimates: *MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CreateUnicastIpAddressEntry(
    Row: *const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn DeleteUnicastIpAddressEntry(
    Row: *const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetUnicastIpAddressEntry(
    Row: *MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetUnicastIpAddressTable(
    Family: u16,
    Table: **MIB_UNICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn InitializeUnicastIpAddressEntry(
    Row: *MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn NotifyUnicastIpAddressChange(
    Family: u16,
    Callback: PUNICAST_IPADDRESS_CHANGE_CALLBACK,
    CallerContext: ?*c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn NotifyStableUnicastIpAddressTable(
    Family: u16,
    Table: **MIB_UNICASTIPADDRESS_TABLE,
    CallerCallback: PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK,
    CallerContext: *c_void,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn SetUnicastIpAddressEntry(
    Row: *const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CreateAnycastIpAddressEntry(
    Row: *const MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn DeleteAnycastIpAddressEntry(
    Row: *const MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetAnycastIpAddressEntry(
    Row: *MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetAnycastIpAddressTable(
    Family: u16,
    Table: **MIB_ANYCASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetMulticastIpAddressEntry(
    Row: *MIB_MULTICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetMulticastIpAddressTable(
    Family: u16,
    Table: **MIB_MULTICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CreateIpForwardEntry2(
    Row: *const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn DeleteIpForwardEntry2(
    Row: *const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetBestRoute2(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceIndex: u32,
    SourceAddress: ?*const SOCKADDR_INET,
    DestinationAddress: *const SOCKADDR_INET,
    AddressSortOptions: u32,
    BestRoute: *MIB_IPFORWARD_ROW2,
    BestSourceAddress: *SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpForwardEntry2(
    Row: *MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpForwardTable2(
    Family: u16,
    Table: **MIB_IPFORWARD_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn InitializeIpForwardEntry(
    Row: *MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn NotifyRouteChange2(
    AddressFamily: u16,
    Callback: PIPFORWARD_CHANGE_CALLBACK,
    CallerContext: *c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn SetIpForwardEntry2(
    Route: *const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FlushIpPathTable(
    Family: u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpPathEntry(
    Row: *MIB_IPPATH_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpPathTable(
    Family: u16,
    Table: **MIB_IPPATH_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CreateIpNetEntry2(
    Row: *const MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn DeleteIpNetEntry2(
    Row: *const MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FlushIpNetTable2(
    Family: u16,
    InterfaceIndex: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpNetEntry2(
    Row: *MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpNetTable2(
    Family: u16,
    Table: **MIB_IPNET_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ResolveIpNetEntry2(
    Row: *MIB_IPNET_ROW2,
    SourceAddress: ?*const SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn SetIpNetEntry2(
    Row: *MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn NotifyTeredoPortChange(
    Callback: PTEREDO_PORT_CHANGE_CALLBACK,
    CallerContext: *c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetTeredoPort(
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CancelMibChangeNotify2(
    NotificationHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FreeMibTable(
    Memory: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn CreateSortedAddressPairs(
    SourceAddressList: ?*const SOCKADDR_IN6_LH,
    SourceAddressCount: u32,
    DestinationAddressList: *const SOCKADDR_IN6_LH,
    DestinationAddressCount: u32,
    AddressSortOptions: u32,
    SortedAddressPairList: **SOCKADDR_IN6_PAIR,
    SortedAddressPairCount: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertCompartmentGuidToId(
    CompartmentGuid: *const Guid,
    CompartmentId: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertCompartmentIdToGuid(
    CompartmentId: u32,
    CompartmentGuid: *Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceNameToLuidA(
    InterfaceName: *const i8,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceNameToLuidW(
    InterfaceName: [*:0]const u16,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToNameA(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceName: [*:0]u8,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToNameW(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceName: [*:0]u16,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToIndex(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceIndexToLuid(
    InterfaceIndex: u32,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToAlias(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceAlias: [*:0]u16,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceAliasToLuid(
    InterfaceAlias: [*:0]const u16,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToGuid(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceGuid: *Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceGuidToLuid(
    InterfaceGuid: *const Guid,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn if_nametoindex(
    InterfaceName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn if_indextoname(
    InterfaceIndex: u32,
    InterfaceName: *[256]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "IPHLPAPI" fn GetCurrentThreadCompartmentScope(
    CompartmentScope: *u32,
    CompartmentId: *u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn SetCurrentThreadCompartmentScope(
    CompartmentScope: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetJobCompartmentId(
    JobHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetJobCompartmentId(
    JobHandle: HANDLE,
    CompartmentId: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetDefaultCompartmentId(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn ConvertLengthToIpv4Mask(
    MaskLength: u32,
    Mask: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertIpv4MaskToLength(
    Mask: u32,
    MaskLength: *u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetDnsSettings(
    Settings: *DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FreeDnsSettings(
    Settings: *DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn SetDnsSettings(
    Settings: *const DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetInterfaceDnsSettings(
    Interface: Guid,
    Settings: *DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FreeInterfaceDnsSettings(
    Settings: *DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn SetInterfaceDnsSettings(
    Interface: Guid,
    Settings: *const DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetNetworkConnectivityHint(
    ConnectivityHint: *NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetNetworkConnectivityHintForInterface(
    InterfaceIndex: u32,
    ConnectivityHint: *NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn NotifyNetworkConnectivityHintChange(
    Callback: PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK,
    CallerContext: ?*c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn IcmpCreateFile(
) callconv(@import("std").os.windows.WINAPI) IcmpHandle;

pub extern "IPHLPAPI" fn Icmp6CreateFile(
) callconv(@import("std").os.windows.WINAPI) IcmpHandle;

pub extern "IPHLPAPI" fn IcmpCloseHandle(
    IcmpHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IPHLPAPI" fn IcmpSendEcho(
    IcmpHandle: HANDLE,
    DestinationAddress: u32,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn IcmpSendEcho2(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: ?FARPROC,
    ApcContext: ?*c_void,
    DestinationAddress: u32,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn IcmpSendEcho2Ex(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: ?FARPROC,
    ApcContext: ?*c_void,
    SourceAddress: u32,
    DestinationAddress: u32,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn Icmp6SendEcho2(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: ?FARPROC,
    ApcContext: ?*c_void,
    SourceAddress: *SOCKADDR_IN6_LH,
    DestinationAddress: *SOCKADDR_IN6_LH,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn IcmpParseReplies(
    ReplyBuffer: [*]u8,
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn Icmp6ParseReplies(
    ReplyBuffer: [*]u8,
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetNumberOfInterfaces(
    pdwNumIf: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIfEntry(
    pIfRow: *MIB_IFROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIfTable(
    pIfTable: ?[*]MIB_IFTABLE,
    pdwSize: *u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpAddrTable(
    pIpAddrTable: ?[*]MIB_IPADDRTABLE,
    pdwSize: *u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpNetTable(
    IpNetTable: ?[*]MIB_IPNETTABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpForwardTable(
    pIpForwardTable: ?[*]MIB_IPFORWARDTABLE,
    pdwSize: *u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpTable(
    TcpTable: ?[*]MIB_TCPTABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetExtendedTcpTable(
    pTcpTable: ?[*]u8,
    pdwSize: *u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: TCP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromTcpEntry(
    pTcpEntry: *MIB_TCPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdpTable(
    UdpTable: ?[*]MIB_UDPTABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetExtendedUdpTable(
    pUdpTable: ?[*]u8,
    pdwSize: *u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: UDP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromUdpEntry(
    pUdpEntry: *MIB_UDPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpTable2(
    TcpTable: ?[*]MIB_TCPTABLE2,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcp6Table(
    TcpTable: [*]MIB_TCP6TABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcp6Table2(
    TcpTable: [*]MIB_TCP6TABLE2,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetPerTcpConnectionEStats(
    Row: *MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?[*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Ros: ?[*:0]u8,
    RosVersion: u32,
    RosSize: u32,
    Rod: ?[*:0]u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetPerTcpConnectionEStats(
    Row: *MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: [*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetPerTcp6ConnectionEStats(
    Row: *MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?[*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Ros: ?[*:0]u8,
    RosVersion: u32,
    RosSize: u32,
    Rod: ?[*:0]u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetPerTcp6ConnectionEStats(
    Row: *MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: [*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromTcp6Entry(
    pTcpEntry: *MIB_TCP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdp6Table(
    Udp6Table: ?[*]MIB_UDP6TABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromUdp6Entry(
    pUdpEntry: *MIB_UDP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromPidAndInfo(
    ulPid: u32,
    pInfo: *u64,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpStatistics(
    Statistics: *MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIcmpStatistics(
    Statistics: *MIB_ICMP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpStatistics(
    Statistics: *MIB_TCPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdpStatistics(
    Stats: *MIB_UDPSTATS,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpStatisticsEx(
    Statistics: *MIB_IPSTATS_LH,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpStatisticsEx(
    Statistics: *MIB_IPSTATS_LH,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIcmpStatisticsEx(
    Statistics: *MIB_ICMP_EX_XPSP1,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpStatisticsEx(
    Statistics: *MIB_TCPSTATS_LH,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdpStatisticsEx(
    Statistics: *MIB_UDPSTATS,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpStatisticsEx2(
    Statistics: *MIB_TCPSTATS2,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdpStatisticsEx2(
    Statistics: *MIB_UDPSTATS2,
    Family: Get_Family,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIfEntry(
    pIfRow: SetIfEntry_pIfRowFlags,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreateIpForwardEntry(
    pRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpForwardEntry(
    pRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeleteIpForwardEntry(
    pRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpStatistics(
    pIpStats: *MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpTTL(
    nTTL: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreateIpNetEntry(
    pArpEntry: *MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpNetEntry(
    pArpEntry: *MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeleteIpNetEntry(
    pArpEntry: *MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn FlushIpNetTable(
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreateProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeleteProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetTcpEntry(
    pTcpRow: *MIB_TCPROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetInterfaceInfo(
    pIfTable: ?[*]IP_INTERFACE_INFO,
    dwOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUniDirectionalAdapterInfo(
    pIPIfInfo: ?[*]IP_UNIDIRECTIONAL_ADAPTER_ADDRESS,
    dwOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn NhpAllocateAndGetInterfaceInfoFromStack(
    ppTable: **ip_interface_name_info_w2ksp1,
    pdwCount: *u32,
    bOrder: BOOL,
    hHeap: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetBestInterface(
    dwDestAddr: u32,
    pdwBestIfIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetBestInterfaceEx(
    pDestAddr: *SOCKADDR,
    pdwBestIfIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetBestRoute(
    dwDestAddr: u32,
    dwSourceAddr: u32,
    pBestRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn NotifyAddrChange(
    Handle: *HANDLE,
    overlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn NotifyRouteChange(
    Handle: *HANDLE,
    overlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CancelIPChangeNotify(
    notifyOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IPHLPAPI" fn GetAdapterIndex(
    AdapterName: PWSTR,
    IfIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn AddIPAddress(
    Address: u32,
    IpMask: u32,
    IfIndex: u32,
    NTEContext: *u32,
    NTEInstance: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeleteIPAddress(
    NTEContext: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetNetworkParams(
    pFixedInfo: ?[*]FIXED_INFO_W2KSP1,
    pOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetAdaptersInfo(
    AdapterInfo: ?[*]IP_ADAPTER_INFO,
    SizePointer: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetAdapterOrderMap(
) callconv(@import("std").os.windows.WINAPI) *IP_ADAPTER_ORDER_MAP;

pub extern "IPHLPAPI" fn GetAdaptersAddresses(
    Family: Get_Family,
    Flags: GetAdaptersAddresses_Flags,
    Reserved: *c_void,
    AdapterAddresses: ?[*]IP_ADAPTER_ADDRESSES_LH,
    SizePointer: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetPerAdapterInfo(
    IfIndex: u32,
    pPerAdapterInfo: ?[*]IP_PER_ADAPTER_INFO_W2KSP1,
    pOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetInterfaceCurrentTimestampCapabilities(
    InterfaceLuid: *const NET_LUID_LH,
    TimestampCapabilites: *INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetInterfaceHardwareTimestampCapabilities(
    InterfaceLuid: *const NET_LUID_LH,
    TimestampCapabilites: *INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CaptureInterfaceHardwareCrossTimestamp(
    InterfaceLuid: *const NET_LUID_LH,
    CrossTimestamp: *INTERFACE_HARDWARE_CROSSTIMESTAMP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn NotifyIfTimestampConfigChange(
    CallerContext: ?*c_void,
    Callback: PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK,
    NotificationHandle: *HIFTIMESTAMPCHANGE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CancelIfTimestampConfigChange(
    NotificationHandle: HIFTIMESTAMPCHANGE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn IpReleaseAddress(
    AdapterInfo: *IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn IpRenewAddress(
    AdapterInfo: *IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SendARP(
    DestIP: u32,
    SrcIP: u32,
    pMacAddr: [*]u8,
    PhyAddrLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetRTTAndHopCount(
    DestIpAddress: u32,
    HopCount: *u32,
    MaxHops: u32,
    RTT: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IPHLPAPI" fn GetFriendlyIfIndex(
    IfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn EnableRouter(
    pHandle: *HANDLE,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn UnenableRouter(
    pOverlapped: *OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DisableMediaSense(
    pHandle: *HANDLE,
    pOverLapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn RestoreMediaSense(
    pOverlapped: *OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpErrorString(
    ErrorCode: u32,
    Buffer: ?PWSTR,
    Size: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn ResolveNeighbor(
    NetworkAddress: *SOCKADDR,
    PhysicalAddress: [*]u8,
    PhysicalAddressLength: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreatePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreatePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeletePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeletePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn LookupPersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn LookupPersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (8)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const RtlIpv4AddressToString = RtlIpv4AddressToStringA;
        pub const RtlIpv4StringToAddress = RtlIpv4StringToAddressA;
        pub const RtlIpv6AddressToString = RtlIpv6AddressToStringA;
        pub const RtlIpv6StringToAddress = RtlIpv6StringToAddressA;
        pub const RtlEthernetAddressToString = RtlEthernetAddressToStringA;
        pub const RtlEthernetStringToAddress = RtlEthernetStringToAddressA;
        pub const ConvertInterfaceNameToLuid = ConvertInterfaceNameToLuidA;
        pub const ConvertInterfaceLuidToName = ConvertInterfaceLuidToNameA;
    },
    .wide => struct {
        pub const RtlIpv4AddressToString = RtlIpv4AddressToStringW;
        pub const RtlIpv4StringToAddress = RtlIpv4StringToAddressW;
        pub const RtlIpv6AddressToString = RtlIpv6AddressToStringW;
        pub const RtlIpv6StringToAddress = RtlIpv6StringToAddressW;
        pub const RtlEthernetAddressToString = RtlEthernetAddressToStringW;
        pub const RtlEthernetStringToAddress = RtlEthernetStringToAddressW;
        pub const ConvertInterfaceNameToLuid = ConvertInterfaceNameToLuidW;
        pub const ConvertInterfaceLuidToName = ConvertInterfaceLuidToNameW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const RtlIpv4AddressToString = *opaque{};
        pub const RtlIpv4StringToAddress = *opaque{};
        pub const RtlIpv6AddressToString = *opaque{};
        pub const RtlIpv6StringToAddress = *opaque{};
        pub const RtlEthernetAddressToString = *opaque{};
        pub const RtlEthernetStringToAddress = *opaque{};
        pub const ConvertInterfaceNameToLuid = *opaque{};
        pub const ConvertInterfaceLuidToName = *opaque{};
    } else struct {
        pub const RtlIpv4AddressToString = @compileError("'RtlIpv4AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4StringToAddress = @compileError("'RtlIpv4StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6AddressToString = @compileError("'RtlIpv6AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6StringToAddress = @compileError("'RtlIpv6StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetAddressToString = @compileError("'RtlEthernetAddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetStringToAddress = @compileError("'RtlEthernetStringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const ConvertInterfaceNameToLuid = @compileError("'ConvertInterfaceNameToLuid' requires that UNICODE be set to true or false in the root module");
        pub const ConvertInterfaceLuidToName = @compileError("'ConvertInterfaceLuidToName' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (63)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const MIB_IFSTACK_TABLE = @import("mib.zig").MIB_IFSTACK_TABLE;
const MIB_TCPROW_OWNER_MODULE = @import("mib.zig").MIB_TCPROW_OWNER_MODULE;
const MIB_ANYCASTIPADDRESS_TABLE = @import("mib.zig").MIB_ANYCASTIPADDRESS_TABLE;
const MIB_IPINTERFACE_TABLE = @import("mib.zig").MIB_IPINTERFACE_TABLE;
const MIB_UNICASTIPADDRESS_TABLE = @import("mib.zig").MIB_UNICASTIPADDRESS_TABLE;
const MIB_IPPATH_TABLE = @import("mib.zig").MIB_IPPATH_TABLE;
const MIB_IF_ROW2 = @import("mib.zig").MIB_IF_ROW2;
const in_addr = @import("win_sock.zig").in_addr;
const MIB_UDPSTATS = @import("mib.zig").MIB_UDPSTATS;
const SOCKADDR = @import("win_sock.zig").SOCKADDR;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;
const in6_addr = @import("win_sock.zig").in6_addr;
const MIB_IPADDRTABLE = @import("mib.zig").MIB_IPADDRTABLE;
const MIB_TCPSTATS_LH = @import("mib.zig").MIB_TCPSTATS_LH;
const MIB_ICMP = @import("mib.zig").MIB_ICMP;
const MIB_MULTICASTIPADDRESS_ROW = @import("mib.zig").MIB_MULTICASTIPADDRESS_ROW;
const MIB_TCP6TABLE = @import("mib.zig").MIB_TCP6TABLE;
const PWSTR = @import("system_services.zig").PWSTR;
const MIB_TCP6ROW_OWNER_MODULE = @import("mib.zig").MIB_TCP6ROW_OWNER_MODULE;
const MIB_IPFORWARDTABLE = @import("mib.zig").MIB_IPFORWARDTABLE;
const MIB_IPNET_TABLE2 = @import("mib.zig").MIB_IPNET_TABLE2;
const MIB_NOTIFICATION_TYPE = @import("mib.zig").MIB_NOTIFICATION_TYPE;
const PSTR = @import("system_services.zig").PSTR;
const MIB_IF_TABLE2 = @import("mib.zig").MIB_IF_TABLE2;
const NET_IF_CONNECTION_TYPE = @import("network_drivers.zig").NET_IF_CONNECTION_TYPE;
const MIB_IPNETROW_LH = @import("mib.zig").MIB_IPNETROW_LH;
const MIB_IPFORWARDROW = @import("mib.zig").MIB_IPFORWARDROW;
const HANDLE = @import("system_services.zig").HANDLE;
const TUNNEL_TYPE = @import("network_drivers.zig").TUNNEL_TYPE;
const MIB_UDPSTATS2 = @import("mib.zig").MIB_UDPSTATS2;
const MIB_IPINTERFACE_ROW = @import("mib.zig").MIB_IPINTERFACE_ROW;
const MIB_IPFORWARD_TABLE2 = @import("mib.zig").MIB_IPFORWARD_TABLE2;
const MIB_IF_TABLE_LEVEL = @import("network_drivers.zig").MIB_IF_TABLE_LEVEL;
const MIB_IPPATH_ROW = @import("mib.zig").MIB_IPPATH_ROW;
const MIB_ICMP_EX_XPSP1 = @import("mib.zig").MIB_ICMP_EX_XPSP1;
const MIB_TCP6ROW = @import("mib.zig").MIB_TCP6ROW;
const MIB_INVERTEDIFSTACK_TABLE = @import("mib.zig").MIB_INVERTEDIFSTACK_TABLE;
const MIB_TCPROW_LH = @import("mib.zig").MIB_TCPROW_LH;
const BOOL = @import("system_services.zig").BOOL;
const MIB_ANYCASTIPADDRESS_ROW = @import("mib.zig").MIB_ANYCASTIPADDRESS_ROW;
const MIB_TCPTABLE2 = @import("mib.zig").MIB_TCPTABLE2;
const FARPROC = @import("system_services.zig").FARPROC;
const MIB_TCPSTATS2 = @import("mib.zig").MIB_TCPSTATS2;
const MIB_IPFORWARD_ROW2 = @import("mib.zig").MIB_IPFORWARD_ROW2;
const MIB_UNICASTIPADDRESS_ROW = @import("mib.zig").MIB_UNICASTIPADDRESS_ROW;
const DL_EUI48 = @import("windows_filtering.zig").DL_EUI48;
const MIB_UDPROW_OWNER_MODULE = @import("mib.zig").MIB_UDPROW_OWNER_MODULE;
const MIB_TCP6TABLE2 = @import("mib.zig").MIB_TCP6TABLE2;
const MIB_IPSTATS_LH = @import("mib.zig").MIB_IPSTATS_LH;
const MIB_IFTABLE = @import("mib.zig").MIB_IFTABLE;
const MIB_MULTICASTIPADDRESS_TABLE = @import("mib.zig").MIB_MULTICASTIPADDRESS_TABLE;
const MIB_UDPTABLE = @import("mib.zig").MIB_UDPTABLE;
const MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES = @import("mib.zig").MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES;
const MIB_UDP6ROW_OWNER_MODULE = @import("mib.zig").MIB_UDP6ROW_OWNER_MODULE;
const MIB_TCPTABLE = @import("mib.zig").MIB_TCPTABLE;
const MIB_IPNETTABLE = @import("mib.zig").MIB_IPNETTABLE;
const MIB_IPNET_ROW2 = @import("mib.zig").MIB_IPNET_ROW2;
const SOCKADDR_IN6_LH = @import("network_drivers.zig").SOCKADDR_IN6_LH;
const MIB_IFROW = @import("mib.zig").MIB_IFROW;
const MIB_UDP6TABLE = @import("mib.zig").MIB_UDP6TABLE;
const SOCKET_ADDRESS = @import("win_sock.zig").SOCKET_ADDRESS;
const NTSTATUS = @import("system_services.zig").NTSTATUS;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = PIPINTERFACE_CHANGE_CALLBACK;
    _ = PUNICAST_IPADDRESS_CHANGE_CALLBACK;
    _ = PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK;
    _ = PIPFORWARD_CHANGE_CALLBACK;
    _ = PTEREDO_PORT_CHANGE_CALLBACK;
    _ = PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK;
    _ = INTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK;
    _ = PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK;

    const constant_export_count = 336;
    const type_export_count = 104;
    const enum_value_export_count = 159;
    const com_iface_id_export_count = 0;
    const com_class_id_export_count = 0;
    const func_export_count = 190;
    const unicode_alias_count = 8;
    const import_count = 63;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
