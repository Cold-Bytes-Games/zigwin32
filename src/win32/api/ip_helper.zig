//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (100)
//--------------------------------------------------------------------------------
pub const ip_option_information = extern struct {
    Ttl: u8,
    Tos: u8,
    Flags: u8,
    OptionsSize: u8,
    OptionsData: *u8,
};

pub const icmp_echo_reply = extern struct {
    Address: u32,
    Status: u32,
    RoundTripTime: u32,
    DataSize: u16,
    Reserved: u16,
    Data: *c_void,
    Options: ip_option_information,
};

pub const IPV6_ADDRESS_EX = extern struct {
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: [8]u16,
    sin6_scope_id: u32,
};

pub const icmpv6_echo_reply_lh = extern struct {
    Address: IPV6_ADDRESS_EX,
    Status: u32,
    RoundTripTime: u32,
};

pub const arp_send_reply = extern struct {
    DestAddress: u32,
    SrcAddress: u32,
};

pub const tcp_reserve_port_range = extern struct {
    UpperRange: u16,
    LowerRange: u16,
};

pub const IP_ADAPTER_INDEX_MAP = extern struct {
    Index: u32,
    Name: [128]u16,
};

pub const IP_INTERFACE_INFO = extern struct {
    NumAdapters: i32,
    Adapter: [1]IP_ADAPTER_INDEX_MAP,
};

pub const IP_UNIDIRECTIONAL_ADAPTER_ADDRESS = extern struct {
    NumAdapters: u32,
    Address: [1]u32,
};

pub const IP_ADAPTER_ORDER_MAP = extern struct {
    NumAdapters: u32,
    AdapterOrder: [1]u32,
};

pub const IP_MCAST_COUNTER_INFO = extern struct {
    InMcastOctets: u64,
    OutMcastOctets: u64,
    InMcastPkts: u64,
    OutMcastPkts: u64,
};

pub const IF_ACCESS_TYPE = extern enum(i32) {
    IF_ACCESS_LOOPBACK = 1,
    IF_ACCESS_BROADCAST = 2,
    IF_ACCESS_POINT_TO_POINT = 3,
    IF_ACCESS_POINTTOPOINT = 3,
    IF_ACCESS_POINT_TO_MULTI_POINT = 4,
    IF_ACCESS_POINTTOMULTIPOINT = 4,
};
pub const IF_ACCESS_LOOPBACK = IF_ACCESS_TYPE.IF_ACCESS_LOOPBACK;
pub const IF_ACCESS_BROADCAST = IF_ACCESS_TYPE.IF_ACCESS_BROADCAST;
pub const IF_ACCESS_POINT_TO_POINT = IF_ACCESS_TYPE.IF_ACCESS_POINT_TO_POINT;
pub const IF_ACCESS_POINTTOPOINT = IF_ACCESS_TYPE.IF_ACCESS_POINTTOPOINT;
pub const IF_ACCESS_POINT_TO_MULTI_POINT = IF_ACCESS_TYPE.IF_ACCESS_POINT_TO_MULTI_POINT;
pub const IF_ACCESS_POINTTOMULTIPOINT = IF_ACCESS_TYPE.IF_ACCESS_POINTTOMULTIPOINT;

pub const INTERNAL_IF_OPER_STATUS = extern enum(i32) {
    IF_OPER_STATUS_NON_OPERATIONAL = 0,
    IF_OPER_STATUS_UNREACHABLE = 1,
    IF_OPER_STATUS_DISCONNECTED = 2,
    IF_OPER_STATUS_CONNECTING = 3,
    IF_OPER_STATUS_CONNECTED = 4,
    IF_OPER_STATUS_OPERATIONAL = 5,
};
pub const IF_OPER_STATUS_NON_OPERATIONAL = INTERNAL_IF_OPER_STATUS.IF_OPER_STATUS_NON_OPERATIONAL;
pub const IF_OPER_STATUS_UNREACHABLE = INTERNAL_IF_OPER_STATUS.IF_OPER_STATUS_UNREACHABLE;
pub const IF_OPER_STATUS_DISCONNECTED = INTERNAL_IF_OPER_STATUS.IF_OPER_STATUS_DISCONNECTED;
pub const IF_OPER_STATUS_CONNECTING = INTERNAL_IF_OPER_STATUS.IF_OPER_STATUS_CONNECTING;
pub const IF_OPER_STATUS_CONNECTED = INTERNAL_IF_OPER_STATUS.IF_OPER_STATUS_CONNECTED;
pub const IF_OPER_STATUS_OPERATIONAL = INTERNAL_IF_OPER_STATUS.IF_OPER_STATUS_OPERATIONAL;

pub const NET_IF_RCV_ADDRESS_TYPE = extern enum(i32) {
    OTHER = 1,
    VOLATILE = 2,
    NON_VOLATILE = 3,
};
pub const NET_IF_RCV_ADDRESS_TYPE_OTHER = NET_IF_RCV_ADDRESS_TYPE.OTHER;
pub const NET_IF_RCV_ADDRESS_TYPE_VOLATILE = NET_IF_RCV_ADDRESS_TYPE.VOLATILE;
pub const NET_IF_RCV_ADDRESS_TYPE_NON_VOLATILE = NET_IF_RCV_ADDRESS_TYPE.NON_VOLATILE;

pub const NET_IF_RCV_ADDRESS_LH = extern struct {
    ifRcvAddressType: NET_IF_RCV_ADDRESS_TYPE,
    ifRcvAddressLength: u16,
    ifRcvAddressOffset: u16,
};

pub const NET_IF_ALIAS_LH = extern struct {
    ifAliasLength: u16,
    ifAliasOffset: u16,
};

pub const NET_LUID_LH = u32; // TODO: implement StructOrUnion types?

pub const IF_PHYSICAL_ADDRESS_LH = extern struct {
    Length: u16,
    Address: [32]u8,
};

pub const IF_ADMINISTRATIVE_STATE = extern enum(i32) {
    IF_ADMINISTRATIVE_DISABLED = 0,
    IF_ADMINISTRATIVE_ENABLED = 1,
    IF_ADMINISTRATIVE_DEMANDDIAL = 2,
};
pub const IF_ADMINISTRATIVE_DISABLED = IF_ADMINISTRATIVE_STATE.IF_ADMINISTRATIVE_DISABLED;
pub const IF_ADMINISTRATIVE_ENABLED = IF_ADMINISTRATIVE_STATE.IF_ADMINISTRATIVE_ENABLED;
pub const IF_ADMINISTRATIVE_DEMANDDIAL = IF_ADMINISTRATIVE_STATE.IF_ADMINISTRATIVE_DEMANDDIAL;

pub const IF_OPER_STATUS = extern enum(i32) {
    IfOperStatusUp = 1,
    IfOperStatusDown = 2,
    IfOperStatusTesting = 3,
    IfOperStatusUnknown = 4,
    IfOperStatusDormant = 5,
    IfOperStatusNotPresent = 6,
    IfOperStatusLowerLayerDown = 7,
};
pub const IfOperStatusUp = IF_OPER_STATUS.IfOperStatusUp;
pub const IfOperStatusDown = IF_OPER_STATUS.IfOperStatusDown;
pub const IfOperStatusTesting = IF_OPER_STATUS.IfOperStatusTesting;
pub const IfOperStatusUnknown = IF_OPER_STATUS.IfOperStatusUnknown;
pub const IfOperStatusDormant = IF_OPER_STATUS.IfOperStatusDormant;
pub const IfOperStatusNotPresent = IF_OPER_STATUS.IfOperStatusNotPresent;
pub const IfOperStatusLowerLayerDown = IF_OPER_STATUS.IfOperStatusLowerLayerDown;

pub const MIB_IF_ENTRY_LEVEL = extern enum(i32) {
    MibIfEntryNormal = 0,
    MibIfEntryNormalWithoutStatistics = 2,
};
pub const MibIfEntryNormal = MIB_IF_ENTRY_LEVEL.MibIfEntryNormal;
pub const MibIfEntryNormalWithoutStatistics = MIB_IF_ENTRY_LEVEL.MibIfEntryNormalWithoutStatistics;

pub const PIPINTERFACE_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Row: *MIB_IPINTERFACE_ROW,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PUNICAST_IPADDRESS_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Row: ?*MIB_UNICASTIPADDRESS_ROW,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK = fn(
    CallerContext: *c_void,
    AddressTable: *MIB_UNICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const IP_ADDRESS_PREFIX = extern struct {
    Prefix: SOCKADDR_INET,
    PrefixLength: u8,
};

pub const PIPFORWARD_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Row: ?*MIB_IPFORWARD_ROW2,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PTEREDO_PORT_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    Port: u16,
    NotificationType: MIB_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const DNS_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Hostname: PWSTR,
    Domain: PWSTR,
    SearchList: PWSTR,
};

pub const DNS_INTERFACE_SETTINGS = extern struct {
    Version: u32,
    Flags: u64,
    Domain: PWSTR,
    NameServer: PWSTR,
    SearchList: PWSTR,
    RegistrationEnabled: u32,
    RegisterAdapterName: u32,
    EnableLLMNR: u32,
    QueryAdapterName: u32,
    ProfileNameServer: PWSTR,
};

pub const DNS_INTERFACE_SETTINGS_EX = extern struct {
    SettingsV1: DNS_INTERFACE_SETTINGS,
    DisableUnconstrainedQueries: u32,
    SupplementalSearchList: PWSTR,
};

pub const PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
    ConnectivityHint: NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) void;

pub const MIB_IPFORWARD_TYPE = extern enum(i32) {
    MIB_IPROUTE_TYPE_OTHER = 1,
    MIB_IPROUTE_TYPE_INVALID = 2,
    MIB_IPROUTE_TYPE_DIRECT = 3,
    MIB_IPROUTE_TYPE_INDIRECT = 4,
};
pub const MIB_IPROUTE_TYPE_OTHER = MIB_IPFORWARD_TYPE.MIB_IPROUTE_TYPE_OTHER;
pub const MIB_IPROUTE_TYPE_INVALID = MIB_IPFORWARD_TYPE.MIB_IPROUTE_TYPE_INVALID;
pub const MIB_IPROUTE_TYPE_DIRECT = MIB_IPFORWARD_TYPE.MIB_IPROUTE_TYPE_DIRECT;
pub const MIB_IPROUTE_TYPE_INDIRECT = MIB_IPFORWARD_TYPE.MIB_IPROUTE_TYPE_INDIRECT;

pub const MIB_IPNET_TYPE = extern enum(i32) {
    OTHER = 1,
    INVALID = 2,
    DYNAMIC = 3,
    STATIC = 4,
};
pub const MIB_IPNET_TYPE_OTHER = MIB_IPNET_TYPE.OTHER;
pub const MIB_IPNET_TYPE_INVALID = MIB_IPNET_TYPE.INVALID;
pub const MIB_IPNET_TYPE_DYNAMIC = MIB_IPNET_TYPE.DYNAMIC;
pub const MIB_IPNET_TYPE_STATIC = MIB_IPNET_TYPE.STATIC;

pub const MIB_IPSTATS_FORWARDING = extern enum(i32) {
    MIB_IP_FORWARDING = 1,
    MIB_IP_NOT_FORWARDING = 2,
};
pub const MIB_IP_FORWARDING = MIB_IPSTATS_FORWARDING.MIB_IP_FORWARDING;
pub const MIB_IP_NOT_FORWARDING = MIB_IPSTATS_FORWARDING.MIB_IP_NOT_FORWARDING;

pub const MIB_TCP_STATE = extern enum(i32) {
    CLOSED = 1,
    LISTEN = 2,
    SYN_SENT = 3,
    SYN_RCVD = 4,
    ESTAB = 5,
    FIN_WAIT1 = 6,
    FIN_WAIT2 = 7,
    CLOSE_WAIT = 8,
    CLOSING = 9,
    LAST_ACK = 10,
    TIME_WAIT = 11,
    DELETE_TCB = 12,
    RESERVED = 100,
};
pub const MIB_TCP_STATE_CLOSED = MIB_TCP_STATE.CLOSED;
pub const MIB_TCP_STATE_LISTEN = MIB_TCP_STATE.LISTEN;
pub const MIB_TCP_STATE_SYN_SENT = MIB_TCP_STATE.SYN_SENT;
pub const MIB_TCP_STATE_SYN_RCVD = MIB_TCP_STATE.SYN_RCVD;
pub const MIB_TCP_STATE_ESTAB = MIB_TCP_STATE.ESTAB;
pub const MIB_TCP_STATE_FIN_WAIT1 = MIB_TCP_STATE.FIN_WAIT1;
pub const MIB_TCP_STATE_FIN_WAIT2 = MIB_TCP_STATE.FIN_WAIT2;
pub const MIB_TCP_STATE_CLOSE_WAIT = MIB_TCP_STATE.CLOSE_WAIT;
pub const MIB_TCP_STATE_CLOSING = MIB_TCP_STATE.CLOSING;
pub const MIB_TCP_STATE_LAST_ACK = MIB_TCP_STATE.LAST_ACK;
pub const MIB_TCP_STATE_TIME_WAIT = MIB_TCP_STATE.TIME_WAIT;
pub const MIB_TCP_STATE_DELETE_TCB = MIB_TCP_STATE.DELETE_TCB;
pub const MIB_TCP_STATE_RESERVED = MIB_TCP_STATE.RESERVED;

pub const TCP_RTO_ALGORITHM = extern enum(i32) {
    TcpRtoAlgorithmOther = 1,
    TcpRtoAlgorithmConstant = 2,
    TcpRtoAlgorithmRsre = 3,
    TcpRtoAlgorithmVanj = 4,
    MIB_TCP_RTO_OTHER = 1,
    MIB_TCP_RTO_CONSTANT = 2,
    MIB_TCP_RTO_RSRE = 3,
    MIB_TCP_RTO_VANJ = 4,
};
pub const TcpRtoAlgorithmOther = TCP_RTO_ALGORITHM.TcpRtoAlgorithmOther;
pub const TcpRtoAlgorithmConstant = TCP_RTO_ALGORITHM.TcpRtoAlgorithmConstant;
pub const TcpRtoAlgorithmRsre = TCP_RTO_ALGORITHM.TcpRtoAlgorithmRsre;
pub const TcpRtoAlgorithmVanj = TCP_RTO_ALGORITHM.TcpRtoAlgorithmVanj;
pub const MIB_TCP_RTO_OTHER = TCP_RTO_ALGORITHM.MIB_TCP_RTO_OTHER;
pub const MIB_TCP_RTO_CONSTANT = TCP_RTO_ALGORITHM.MIB_TCP_RTO_CONSTANT;
pub const MIB_TCP_RTO_RSRE = TCP_RTO_ALGORITHM.MIB_TCP_RTO_RSRE;
pub const MIB_TCP_RTO_VANJ = TCP_RTO_ALGORITHM.MIB_TCP_RTO_VANJ;

pub const TCP_TABLE_CLASS = extern enum(i32) {
    TCP_TABLE_BASIC_LISTENER = 0,
    TCP_TABLE_BASIC_CONNECTIONS = 1,
    TCP_TABLE_BASIC_ALL = 2,
    TCP_TABLE_OWNER_PID_LISTENER = 3,
    TCP_TABLE_OWNER_PID_CONNECTIONS = 4,
    TCP_TABLE_OWNER_PID_ALL = 5,
    TCP_TABLE_OWNER_MODULE_LISTENER = 6,
    TCP_TABLE_OWNER_MODULE_CONNECTIONS = 7,
    TCP_TABLE_OWNER_MODULE_ALL = 8,
};
pub const TCP_TABLE_BASIC_LISTENER = TCP_TABLE_CLASS.TCP_TABLE_BASIC_LISTENER;
pub const TCP_TABLE_BASIC_CONNECTIONS = TCP_TABLE_CLASS.TCP_TABLE_BASIC_CONNECTIONS;
pub const TCP_TABLE_BASIC_ALL = TCP_TABLE_CLASS.TCP_TABLE_BASIC_ALL;
pub const TCP_TABLE_OWNER_PID_LISTENER = TCP_TABLE_CLASS.TCP_TABLE_OWNER_PID_LISTENER;
pub const TCP_TABLE_OWNER_PID_CONNECTIONS = TCP_TABLE_CLASS.TCP_TABLE_OWNER_PID_CONNECTIONS;
pub const TCP_TABLE_OWNER_PID_ALL = TCP_TABLE_CLASS.TCP_TABLE_OWNER_PID_ALL;
pub const TCP_TABLE_OWNER_MODULE_LISTENER = TCP_TABLE_CLASS.TCP_TABLE_OWNER_MODULE_LISTENER;
pub const TCP_TABLE_OWNER_MODULE_CONNECTIONS = TCP_TABLE_CLASS.TCP_TABLE_OWNER_MODULE_CONNECTIONS;
pub const TCP_TABLE_OWNER_MODULE_ALL = TCP_TABLE_CLASS.TCP_TABLE_OWNER_MODULE_ALL;

pub const UDP_TABLE_CLASS = extern enum(i32) {
    UDP_TABLE_BASIC = 0,
    UDP_TABLE_OWNER_PID = 1,
    UDP_TABLE_OWNER_MODULE = 2,
};
pub const UDP_TABLE_BASIC = UDP_TABLE_CLASS.UDP_TABLE_BASIC;
pub const UDP_TABLE_OWNER_PID = UDP_TABLE_CLASS.UDP_TABLE_OWNER_PID;
pub const UDP_TABLE_OWNER_MODULE = UDP_TABLE_CLASS.UDP_TABLE_OWNER_MODULE;

pub const TCPIP_OWNER_MODULE_INFO_CLASS = extern enum(i32) {
    TCPIP_OWNER_MODULE_INFO_BASIC = 0,
};
pub const TCPIP_OWNER_MODULE_INFO_BASIC = TCPIP_OWNER_MODULE_INFO_CLASS.TCPIP_OWNER_MODULE_INFO_BASIC;

pub const TCPIP_OWNER_MODULE_BASIC_INFO = extern struct {
    pModuleName: [*]u16,
    pModulePath: [*]u16,
};

pub const MIB_IPDESTROW = extern struct {
    ForwardRow: MIB_IPFORWARDROW,
    dwForwardPreference: u32,
    dwForwardViewSet: u32,
};

pub const MIB_IPDESTTABLE = extern struct {
    dwNumEntries: u32,
    table: [1]MIB_IPDESTROW,
};

pub const MIB_ROUTESTATE = extern struct {
    bRoutesSetToStack: BOOL,
};

pub const IP_ADDRESS_STRING = extern struct {
    String: [16]i8,
};

pub const IP_ADDR_STRING = extern struct {
    Next: *IP_ADDR_STRING,
    IpAddress: IP_ADDRESS_STRING,
    IpMask: IP_ADDRESS_STRING,
    Context: u32,
};

pub const IP_ADAPTER_INFO = extern struct {
    Next: *IP_ADAPTER_INFO,
    ComboIndex: u32,
    AdapterName: [260]i8,
    Description: [132]i8,
    AddressLength: u32,
    Address: [8]u8,
    Index: u32,
    Type: u32,
    DhcpEnabled: u32,
    CurrentIpAddress: *IP_ADDR_STRING,
    IpAddressList: IP_ADDR_STRING,
    GatewayList: IP_ADDR_STRING,
    DhcpServer: IP_ADDR_STRING,
    HaveWins: BOOL,
    PrimaryWinsServer: IP_ADDR_STRING,
    SecondaryWinsServer: IP_ADDR_STRING,
    LeaseObtained: i64,
    LeaseExpires: i64,
};

pub const IP_ADAPTER_UNICAST_ADDRESS_LH = extern struct {
    Anonymous: IP_ADAPTER_UNICAST_ADDRESS_LH._Anonymous_e__Union,
    Next: *IP_ADAPTER_UNICAST_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
    OnLinkPrefixLength: u8,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_UNICAST_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_UNICAST_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_UNICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    PrefixOrigin: NL_PREFIX_ORIGIN,
    SuffixOrigin: NL_SUFFIX_ORIGIN,
    DadState: NL_DAD_STATE,
    ValidLifetime: u32,
    PreferredLifetime: u32,
    LeaseLifetime: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_ANYCAST_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_ANYCAST_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_ANYCAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_MULTICAST_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_MULTICAST_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_MULTICAST_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_DNS_SERVER_ADDRESS_XP = extern struct {
    Anonymous: IP_ADAPTER_DNS_SERVER_ADDRESS_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_WINS_SERVER_ADDRESS_LH = extern struct {
    Anonymous: IP_ADAPTER_WINS_SERVER_ADDRESS_LH._Anonymous_e__Union,
    Next: *IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_GATEWAY_ADDRESS_LH = extern struct {
    Anonymous: IP_ADAPTER_GATEWAY_ADDRESS_LH._Anonymous_e__Union,
    Next: *IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Address: SOCKET_ADDRESS,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_PREFIX_XP = extern struct {
    Anonymous: IP_ADAPTER_PREFIX_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_PREFIX_XP,
    Address: SOCKET_ADDRESS,
    PrefixLength: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_DNS_SUFFIX = extern struct {
    Next: *IP_ADAPTER_DNS_SUFFIX,
    String: [256]u16,
};

pub const IP_ADAPTER_ADDRESSES_LH = extern struct {
    Anonymous1: IP_ADAPTER_ADDRESSES_LH._Anonymous1_e__Union,
    Next: *IP_ADAPTER_ADDRESSES_LH,
    AdapterName: [*]u8,
    FirstUnicastAddress: *IP_ADAPTER_UNICAST_ADDRESS_LH,
    FirstAnycastAddress: *IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: *IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: *IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: [*]u16,
    Description: [*]u16,
    FriendlyName: [*]u16,
    PhysicalAddress: [8]u8,
    PhysicalAddressLength: u32,
    Anonymous2: IP_ADAPTER_ADDRESSES_LH._Anonymous2_e__Union,
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: [16]u32,
    FirstPrefix: *IP_ADAPTER_PREFIX_XP,
    TransmitLinkSpeed: u64,
    ReceiveLinkSpeed: u64,
    FirstWinsServerAddress: *IP_ADAPTER_WINS_SERVER_ADDRESS_LH,
    FirstGatewayAddress: *IP_ADAPTER_GATEWAY_ADDRESS_LH,
    Ipv4Metric: u32,
    Ipv6Metric: u32,
    Luid: NET_LUID_LH,
    Dhcpv4Server: SOCKET_ADDRESS,
    CompartmentId: u32,
    NetworkGuid: Guid,
    ConnectionType: NET_IF_CONNECTION_TYPE,
    TunnelType: TUNNEL_TYPE,
    Dhcpv6Server: SOCKET_ADDRESS,
    Dhcpv6ClientDuid: [130]u8,
    Dhcpv6ClientDuidLength: u32,
    Dhcpv6Iaid: u32,
    FirstDnsSuffix: *IP_ADAPTER_DNS_SUFFIX,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_ADAPTER_ADDRESSES_XP = extern struct {
    Anonymous: IP_ADAPTER_ADDRESSES_XP._Anonymous_e__Union,
    Next: *IP_ADAPTER_ADDRESSES_XP,
    AdapterName: [*]u8,
    FirstUnicastAddress: *IP_ADAPTER_UNICAST_ADDRESS_XP,
    FirstAnycastAddress: *IP_ADAPTER_ANYCAST_ADDRESS_XP,
    FirstMulticastAddress: *IP_ADAPTER_MULTICAST_ADDRESS_XP,
    FirstDnsServerAddress: *IP_ADAPTER_DNS_SERVER_ADDRESS_XP,
    DnsSuffix: [*]u16,
    Description: [*]u16,
    FriendlyName: [*]u16,
    PhysicalAddress: [8]u8,
    PhysicalAddressLength: u32,
    Flags: u32,
    Mtu: u32,
    IfType: u32,
    OperStatus: IF_OPER_STATUS,
    Ipv6IfIndex: u32,
    ZoneIndices: [16]u32,
    FirstPrefix: *IP_ADAPTER_PREFIX_XP,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IP_PER_ADAPTER_INFO_W2KSP1 = extern struct {
    AutoconfigEnabled: u32,
    AutoconfigActive: u32,
    CurrentDnsServer: *IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
};

pub const FIXED_INFO_W2KSP1 = extern struct {
    HostName: [132]i8,
    DomainName: [132]i8,
    CurrentDnsServer: *IP_ADDR_STRING,
    DnsServerList: IP_ADDR_STRING,
    NodeType: u32,
    ScopeId: [260]i8,
    EnableRouting: u32,
    EnableProxy: u32,
    EnableDns: u32,
};

pub const ip_interface_name_info_w2ksp1 = extern struct {
    Index: u32,
    MediaType: u32,
    ConnectionType: u8,
    AccessType: u8,
    DeviceGuid: Guid,
    InterfaceGuid: Guid,
};

pub const TCP_ESTATS_TYPE = extern enum(i32) {
    TcpConnectionEstatsSynOpts = 0,
    TcpConnectionEstatsData = 1,
    TcpConnectionEstatsSndCong = 2,
    TcpConnectionEstatsPath = 3,
    TcpConnectionEstatsSendBuff = 4,
    TcpConnectionEstatsRec = 5,
    TcpConnectionEstatsObsRec = 6,
    TcpConnectionEstatsBandwidth = 7,
    TcpConnectionEstatsFineRtt = 8,
    TcpConnectionEstatsMaximum = 9,
};
pub const TcpConnectionEstatsSynOpts = TCP_ESTATS_TYPE.TcpConnectionEstatsSynOpts;
pub const TcpConnectionEstatsData = TCP_ESTATS_TYPE.TcpConnectionEstatsData;
pub const TcpConnectionEstatsSndCong = TCP_ESTATS_TYPE.TcpConnectionEstatsSndCong;
pub const TcpConnectionEstatsPath = TCP_ESTATS_TYPE.TcpConnectionEstatsPath;
pub const TcpConnectionEstatsSendBuff = TCP_ESTATS_TYPE.TcpConnectionEstatsSendBuff;
pub const TcpConnectionEstatsRec = TCP_ESTATS_TYPE.TcpConnectionEstatsRec;
pub const TcpConnectionEstatsObsRec = TCP_ESTATS_TYPE.TcpConnectionEstatsObsRec;
pub const TcpConnectionEstatsBandwidth = TCP_ESTATS_TYPE.TcpConnectionEstatsBandwidth;
pub const TcpConnectionEstatsFineRtt = TCP_ESTATS_TYPE.TcpConnectionEstatsFineRtt;
pub const TcpConnectionEstatsMaximum = TCP_ESTATS_TYPE.TcpConnectionEstatsMaximum;

pub const TCP_BOOLEAN_OPTIONAL = extern enum(i32) {
    TcpBoolOptDisabled = 0,
    TcpBoolOptEnabled = 1,
    TcpBoolOptUnchanged = -1,
};
pub const TcpBoolOptDisabled = TCP_BOOLEAN_OPTIONAL.TcpBoolOptDisabled;
pub const TcpBoolOptEnabled = TCP_BOOLEAN_OPTIONAL.TcpBoolOptEnabled;
pub const TcpBoolOptUnchanged = TCP_BOOLEAN_OPTIONAL.TcpBoolOptUnchanged;

pub const TCP_ESTATS_SYN_OPTS_ROS_v0 = extern struct {
    ActiveOpen: u8,
    MssRcvd: u32,
    MssSent: u32,
};

pub const TCP_SOFT_ERROR = extern enum(i32) {
    TcpErrorNone = 0,
    TcpErrorBelowDataWindow = 1,
    TcpErrorAboveDataWindow = 2,
    TcpErrorBelowAckWindow = 3,
    TcpErrorAboveAckWindow = 4,
    TcpErrorBelowTsWindow = 5,
    TcpErrorAboveTsWindow = 6,
    TcpErrorDataChecksumError = 7,
    TcpErrorDataLengthError = 8,
    TcpErrorMaxSoftError = 9,
};
pub const TcpErrorNone = TCP_SOFT_ERROR.TcpErrorNone;
pub const TcpErrorBelowDataWindow = TCP_SOFT_ERROR.TcpErrorBelowDataWindow;
pub const TcpErrorAboveDataWindow = TCP_SOFT_ERROR.TcpErrorAboveDataWindow;
pub const TcpErrorBelowAckWindow = TCP_SOFT_ERROR.TcpErrorBelowAckWindow;
pub const TcpErrorAboveAckWindow = TCP_SOFT_ERROR.TcpErrorAboveAckWindow;
pub const TcpErrorBelowTsWindow = TCP_SOFT_ERROR.TcpErrorBelowTsWindow;
pub const TcpErrorAboveTsWindow = TCP_SOFT_ERROR.TcpErrorAboveTsWindow;
pub const TcpErrorDataChecksumError = TCP_SOFT_ERROR.TcpErrorDataChecksumError;
pub const TcpErrorDataLengthError = TCP_SOFT_ERROR.TcpErrorDataLengthError;
pub const TcpErrorMaxSoftError = TCP_SOFT_ERROR.TcpErrorMaxSoftError;

pub const TCP_ESTATS_DATA_ROD_v0 = extern struct {
    DataBytesOut: u64,
    DataSegsOut: u64,
    DataBytesIn: u64,
    DataSegsIn: u64,
    SegsOut: u64,
    SegsIn: u64,
    SoftErrors: u32,
    SoftErrorReason: u32,
    SndUna: u32,
    SndNxt: u32,
    SndMax: u32,
    ThruBytesAcked: u64,
    RcvNxt: u32,
    ThruBytesReceived: u64,
};

pub const TCP_ESTATS_DATA_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_SND_CONG_ROD_v0 = extern struct {
    SndLimTransRwin: u32,
    SndLimTimeRwin: u32,
    SndLimBytesRwin: ?*c_void,
    SndLimTransCwnd: u32,
    SndLimTimeCwnd: u32,
    SndLimBytesCwnd: ?*c_void,
    SndLimTransSnd: u32,
    SndLimTimeSnd: u32,
    SndLimBytesSnd: ?*c_void,
    SlowStart: u32,
    CongAvoid: u32,
    OtherReductions: u32,
    CurCwnd: u32,
    MaxSsCwnd: u32,
    MaxCaCwnd: u32,
    CurSsthresh: u32,
    MaxSsthresh: u32,
    MinSsthresh: u32,
};

pub const TCP_ESTATS_SND_CONG_ROS_v0 = extern struct {
    LimCwnd: u32,
};

pub const TCP_ESTATS_SND_CONG_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_PATH_ROD_v0 = extern struct {
    FastRetran: u32,
    Timeouts: u32,
    SubsequentTimeouts: u32,
    CurTimeoutCount: u32,
    AbruptTimeouts: u32,
    PktsRetrans: u32,
    BytesRetrans: u32,
    DupAcksIn: u32,
    SacksRcvd: u32,
    SackBlocksRcvd: u32,
    CongSignals: u32,
    PreCongSumCwnd: u32,
    PreCongSumRtt: u32,
    PostCongSumRtt: u32,
    PostCongCountRtt: u32,
    EcnSignals: u32,
    EceRcvd: u32,
    SendStall: u32,
    QuenchRcvd: u32,
    RetranThresh: u32,
    SndDupAckEpisodes: u32,
    SumBytesReordered: u32,
    NonRecovDa: u32,
    NonRecovDaEpisodes: u32,
    AckAfterFr: u32,
    DsackDups: u32,
    SampleRtt: u32,
    SmoothedRtt: u32,
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
    CountRtt: u32,
    CurRto: u32,
    MaxRto: u32,
    MinRto: u32,
    CurMss: u32,
    MaxMss: u32,
    MinMss: u32,
    SpuriousRtoDetections: u32,
};

pub const TCP_ESTATS_PATH_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_SEND_BUFF_ROD_v0 = extern struct {
    CurRetxQueue: ?*c_void,
    MaxRetxQueue: ?*c_void,
    CurAppWQueue: ?*c_void,
    MaxAppWQueue: ?*c_void,
};

pub const TCP_ESTATS_SEND_BUFF_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_REC_ROD_v0 = extern struct {
    CurRwinSent: u32,
    MaxRwinSent: u32,
    MinRwinSent: u32,
    LimRwin: u32,
    DupAckEpisodes: u32,
    DupAcksOut: u32,
    CeRcvd: u32,
    EcnSent: u32,
    EcnNoncesRcvd: u32,
    CurReasmQueue: u32,
    MaxReasmQueue: u32,
    CurAppRQueue: ?*c_void,
    MaxAppRQueue: ?*c_void,
    WinScaleSent: u8,
};

pub const TCP_ESTATS_REC_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_OBS_REC_ROD_v0 = extern struct {
    CurRwinRcvd: u32,
    MaxRwinRcvd: u32,
    MinRwinRcvd: u32,
    WinScaleRcvd: u8,
};

pub const TCP_ESTATS_OBS_REC_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_BANDWIDTH_RW_v0 = extern struct {
    EnableCollectionOutbound: TCP_BOOLEAN_OPTIONAL,
    EnableCollectionInbound: TCP_BOOLEAN_OPTIONAL,
};

pub const TCP_ESTATS_BANDWIDTH_ROD_v0 = extern struct {
    OutboundBandwidth: u64,
    InboundBandwidth: u64,
    OutboundInstability: u64,
    InboundInstability: u64,
    OutboundBandwidthPeaked: u8,
    InboundBandwidthPeaked: u8,
};

pub const TCP_ESTATS_FINE_RTT_RW_v0 = extern struct {
    EnableCollection: u8,
};

pub const TCP_ESTATS_FINE_RTT_ROD_v0 = extern struct {
    RttVar: u32,
    MaxRtt: u32,
    MinRtt: u32,
    SumRtt: u32,
};

pub const INTERFACE_TIMESTAMP_CAPABILITY_FLAGS = extern struct {
    PtpV2OverUdpIPv4EventMsgReceiveHw: u8,
    PtpV2OverUdpIPv4AllMsgReceiveHw: u8,
    PtpV2OverUdpIPv4EventMsgTransmitHw: u8,
    PtpV2OverUdpIPv4AllMsgTransmitHw: u8,
    PtpV2OverUdpIPv6EventMsgReceiveHw: u8,
    PtpV2OverUdpIPv6AllMsgReceiveHw: u8,
    PtpV2OverUdpIPv6EventMsgTransmitHw: u8,
    PtpV2OverUdpIPv6AllMsgTransmitHw: u8,
    AllReceiveHw: u8,
    AllTransmitHw: u8,
    TaggedTransmitHw: u8,
    AllReceiveSw: u8,
    AllTransmitSw: u8,
    TaggedTransmitSw: u8,
};

pub const INTERFACE_TIMESTAMP_CAPABILITIES = extern struct {
    Version: u32,
    HardwareClockFrequencyHz: u64,
    CrossTimestamp: u8,
    Reserved1: u64,
    Reserved2: u64,
    TimestampFlags: INTERFACE_TIMESTAMP_CAPABILITY_FLAGS,
};

pub const INTERFACE_HARDWARE_CROSSTIMESTAMP = extern struct {
    Version: u32,
    Flags: u32,
    SystemTimestamp1: u64,
    HardwareClockTimestamp: u64,
    SystemTimestamp2: u64,
};

pub const HIFTIMESTAMPCHANGE__ = extern struct {
    unused: i32,
};

pub const INTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK = fn(
    CallerContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const NET_ADDRESS_FORMAT = extern enum(i32) {
    UNSPECIFIED = 0,
    NET_ADDRESS_DNS_NAME = 1,
    NET_ADDRESS_IPV4 = 2,
    NET_ADDRESS_IPV6 = 3,
};
pub const NET_ADDRESS_FORMAT_UNSPECIFIED = NET_ADDRESS_FORMAT.UNSPECIFIED;
pub const NET_ADDRESS_DNS_NAME = NET_ADDRESS_FORMAT.NET_ADDRESS_DNS_NAME;
pub const NET_ADDRESS_IPV4 = NET_ADDRESS_FORMAT.NET_ADDRESS_IPV4;
pub const NET_ADDRESS_IPV6 = NET_ADDRESS_FORMAT.NET_ADDRESS_IPV6;

// TODO: this type has a FreeFunc 'IcmpCloseHandle', what can Zig do with this information?
pub const IcmpHandle = ?*c_void;

pub const SCOPE_LEVEL = extern enum(i32) {
    ScopeLevelInterface = 1,
    ScopeLevelLink = 2,
    ScopeLevelSubnet = 3,
    ScopeLevelAdmin = 4,
    ScopeLevelSite = 5,
    ScopeLevelOrganization = 8,
    ScopeLevelGlobal = 14,
    ScopeLevelCount = 16,
};
pub const ScopeLevelInterface = SCOPE_LEVEL.ScopeLevelInterface;
pub const ScopeLevelLink = SCOPE_LEVEL.ScopeLevelLink;
pub const ScopeLevelSubnet = SCOPE_LEVEL.ScopeLevelSubnet;
pub const ScopeLevelAdmin = SCOPE_LEVEL.ScopeLevelAdmin;
pub const ScopeLevelSite = SCOPE_LEVEL.ScopeLevelSite;
pub const ScopeLevelOrganization = SCOPE_LEVEL.ScopeLevelOrganization;
pub const ScopeLevelGlobal = SCOPE_LEVEL.ScopeLevelGlobal;
pub const ScopeLevelCount = SCOPE_LEVEL.ScopeLevelCount;

pub const SOCKADDR_INET = u32; // TODO: implement StructOrUnion types?

pub const SOCKADDR_IN6_PAIR = extern struct {
    SourceAddress: *SOCKADDR_IN6_LH,
    DestinationAddress: *SOCKADDR_IN6_LH,
};

pub const NL_PREFIX_ORIGIN = extern enum(i32) {
    IpPrefixOriginOther = 0,
    IpPrefixOriginManual = 1,
    IpPrefixOriginWellKnown = 2,
    IpPrefixOriginDhcp = 3,
    IpPrefixOriginRouterAdvertisement = 4,
    IpPrefixOriginUnchanged = 16,
};
pub const IpPrefixOriginOther = NL_PREFIX_ORIGIN.IpPrefixOriginOther;
pub const IpPrefixOriginManual = NL_PREFIX_ORIGIN.IpPrefixOriginManual;
pub const IpPrefixOriginWellKnown = NL_PREFIX_ORIGIN.IpPrefixOriginWellKnown;
pub const IpPrefixOriginDhcp = NL_PREFIX_ORIGIN.IpPrefixOriginDhcp;
pub const IpPrefixOriginRouterAdvertisement = NL_PREFIX_ORIGIN.IpPrefixOriginRouterAdvertisement;
pub const IpPrefixOriginUnchanged = NL_PREFIX_ORIGIN.IpPrefixOriginUnchanged;

pub const NL_SUFFIX_ORIGIN = extern enum(i32) {
    NlsoOther = 0,
    NlsoManual = 1,
    NlsoWellKnown = 2,
    NlsoDhcp = 3,
    NlsoLinkLayerAddress = 4,
    NlsoRandom = 5,
    IpSuffixOriginOther = 0,
    IpSuffixOriginManual = 1,
    IpSuffixOriginWellKnown = 2,
    IpSuffixOriginDhcp = 3,
    IpSuffixOriginLinkLayerAddress = 4,
    IpSuffixOriginRandom = 5,
    IpSuffixOriginUnchanged = 16,
};
pub const NlsoOther = NL_SUFFIX_ORIGIN.NlsoOther;
pub const NlsoManual = NL_SUFFIX_ORIGIN.NlsoManual;
pub const NlsoWellKnown = NL_SUFFIX_ORIGIN.NlsoWellKnown;
pub const NlsoDhcp = NL_SUFFIX_ORIGIN.NlsoDhcp;
pub const NlsoLinkLayerAddress = NL_SUFFIX_ORIGIN.NlsoLinkLayerAddress;
pub const NlsoRandom = NL_SUFFIX_ORIGIN.NlsoRandom;
pub const IpSuffixOriginOther = NL_SUFFIX_ORIGIN.IpSuffixOriginOther;
pub const IpSuffixOriginManual = NL_SUFFIX_ORIGIN.IpSuffixOriginManual;
pub const IpSuffixOriginWellKnown = NL_SUFFIX_ORIGIN.IpSuffixOriginWellKnown;
pub const IpSuffixOriginDhcp = NL_SUFFIX_ORIGIN.IpSuffixOriginDhcp;
pub const IpSuffixOriginLinkLayerAddress = NL_SUFFIX_ORIGIN.IpSuffixOriginLinkLayerAddress;
pub const IpSuffixOriginRandom = NL_SUFFIX_ORIGIN.IpSuffixOriginRandom;
pub const IpSuffixOriginUnchanged = NL_SUFFIX_ORIGIN.IpSuffixOriginUnchanged;

pub const NL_DAD_STATE = extern enum(i32) {
    NldsInvalid = 0,
    NldsTentative = 1,
    NldsDuplicate = 2,
    NldsDeprecated = 3,
    NldsPreferred = 4,
    IpDadStateInvalid = 0,
    IpDadStateTentative = 1,
    IpDadStateDuplicate = 2,
    IpDadStateDeprecated = 3,
    IpDadStatePreferred = 4,
};
pub const NldsInvalid = NL_DAD_STATE.NldsInvalid;
pub const NldsTentative = NL_DAD_STATE.NldsTentative;
pub const NldsDuplicate = NL_DAD_STATE.NldsDuplicate;
pub const NldsDeprecated = NL_DAD_STATE.NldsDeprecated;
pub const NldsPreferred = NL_DAD_STATE.NldsPreferred;
pub const IpDadStateInvalid = NL_DAD_STATE.IpDadStateInvalid;
pub const IpDadStateTentative = NL_DAD_STATE.IpDadStateTentative;
pub const IpDadStateDuplicate = NL_DAD_STATE.IpDadStateDuplicate;
pub const IpDadStateDeprecated = NL_DAD_STATE.IpDadStateDeprecated;
pub const IpDadStatePreferred = NL_DAD_STATE.IpDadStatePreferred;

pub const NL_NETWORK_CONNECTIVITY_LEVEL_HINT = extern enum(i32) {
    NetworkConnectivityLevelHintUnknown = 0,
    NetworkConnectivityLevelHintNone = 1,
    NetworkConnectivityLevelHintLocalAccess = 2,
    NetworkConnectivityLevelHintInternetAccess = 3,
    NetworkConnectivityLevelHintConstrainedInternetAccess = 4,
    NetworkConnectivityLevelHintHidden = 5,
};
pub const NetworkConnectivityLevelHintUnknown = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.NetworkConnectivityLevelHintUnknown;
pub const NetworkConnectivityLevelHintNone = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.NetworkConnectivityLevelHintNone;
pub const NetworkConnectivityLevelHintLocalAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.NetworkConnectivityLevelHintLocalAccess;
pub const NetworkConnectivityLevelHintInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.NetworkConnectivityLevelHintInternetAccess;
pub const NetworkConnectivityLevelHintConstrainedInternetAccess = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.NetworkConnectivityLevelHintConstrainedInternetAccess;
pub const NetworkConnectivityLevelHintHidden = NL_NETWORK_CONNECTIVITY_LEVEL_HINT.NetworkConnectivityLevelHintHidden;

pub const NL_NETWORK_CONNECTIVITY_COST_HINT = extern enum(i32) {
    NetworkConnectivityCostHintUnknown = 0,
    NetworkConnectivityCostHintUnrestricted = 1,
    NetworkConnectivityCostHintFixed = 2,
    NetworkConnectivityCostHintVariable = 3,
};
pub const NetworkConnectivityCostHintUnknown = NL_NETWORK_CONNECTIVITY_COST_HINT.NetworkConnectivityCostHintUnknown;
pub const NetworkConnectivityCostHintUnrestricted = NL_NETWORK_CONNECTIVITY_COST_HINT.NetworkConnectivityCostHintUnrestricted;
pub const NetworkConnectivityCostHintFixed = NL_NETWORK_CONNECTIVITY_COST_HINT.NetworkConnectivityCostHintFixed;
pub const NetworkConnectivityCostHintVariable = NL_NETWORK_CONNECTIVITY_COST_HINT.NetworkConnectivityCostHintVariable;

pub const NL_NETWORK_CONNECTIVITY_HINT = extern struct {
    ConnectivityLevel: NL_NETWORK_CONNECTIVITY_LEVEL_HINT,
    ConnectivityCost: NL_NETWORK_CONNECTIVITY_COST_HINT,
    ApproachingDataLimit: u8,
    OverDataLimit: u8,
    Roaming: u8,
};

pub const NL_BANDWIDTH_INFORMATION = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: u8,
};

pub const NET_ADDRESS_INFO = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };


//--------------------------------------------------------------------------------
// Section: Functions (190)
//--------------------------------------------------------------------------------
pub extern "IPHLPAPI" fn GetIfEntry2(
    Row: *MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIfEntry2Ex(
    Level: MIB_IF_ENTRY_LEVEL,
    Row: *MIB_IF_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIfTable2(
    Table: **MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIfTable2Ex(
    Level: MIB_IF_TABLE_LEVEL,
    Table: **MIB_IF_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIfStackTable(
    Table: **MIB_IFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetInvertedIfStackTable(
    Table: **MIB_INVERTEDIFSTACK_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpInterfaceEntry(
    Row: *MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpInterfaceTable(
    Family: u16,
    Table: **MIB_IPINTERFACE_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn InitializeIpInterfaceEntry(
    Row: *MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn NotifyIpInterfaceChange(
    Family: u16,
    Callback: PIPINTERFACE_CHANGE_CALLBACK,
    CallerContext: ?*c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn SetIpInterfaceEntry(
    Row: *MIB_IPINTERFACE_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpNetworkConnectionBandwidthEstimates(
    InterfaceIndex: u32,
    AddressFamily: u16,
    BandwidthEstimates: *MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CreateUnicastIpAddressEntry(
    Row: *const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn DeleteUnicastIpAddressEntry(
    Row: *const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetUnicastIpAddressEntry(
    Row: *MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetUnicastIpAddressTable(
    Family: u16,
    Table: **MIB_UNICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn InitializeUnicastIpAddressEntry(
    Row: *MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn NotifyUnicastIpAddressChange(
    Family: u16,
    Callback: PUNICAST_IPADDRESS_CHANGE_CALLBACK,
    CallerContext: ?*c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn NotifyStableUnicastIpAddressTable(
    Family: u16,
    Table: **MIB_UNICASTIPADDRESS_TABLE,
    CallerCallback: PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK,
    CallerContext: *c_void,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn SetUnicastIpAddressEntry(
    Row: *const MIB_UNICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CreateAnycastIpAddressEntry(
    Row: *const MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn DeleteAnycastIpAddressEntry(
    Row: *const MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetAnycastIpAddressEntry(
    Row: *MIB_ANYCASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetAnycastIpAddressTable(
    Family: u16,
    Table: **MIB_ANYCASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetMulticastIpAddressEntry(
    Row: *MIB_MULTICASTIPADDRESS_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetMulticastIpAddressTable(
    Family: u16,
    Table: **MIB_MULTICASTIPADDRESS_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CreateIpForwardEntry2(
    Row: *const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn DeleteIpForwardEntry2(
    Row: *const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetBestRoute2(
    InterfaceLuid: ?*NET_LUID_LH,
    InterfaceIndex: u32,
    SourceAddress: ?*const SOCKADDR_INET,
    DestinationAddress: *const SOCKADDR_INET,
    AddressSortOptions: u32,
    BestRoute: *MIB_IPFORWARD_ROW2,
    BestSourceAddress: *SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpForwardEntry2(
    Row: *MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpForwardTable2(
    Family: u16,
    Table: **MIB_IPFORWARD_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn InitializeIpForwardEntry(
    Row: *MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn NotifyRouteChange2(
    AddressFamily: u16,
    Callback: PIPFORWARD_CHANGE_CALLBACK,
    CallerContext: *c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn SetIpForwardEntry2(
    Route: *const MIB_IPFORWARD_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FlushIpPathTable(
    Family: u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpPathEntry(
    Row: *MIB_IPPATH_ROW,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpPathTable(
    Family: u16,
    Table: **MIB_IPPATH_TABLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CreateIpNetEntry2(
    Row: *const MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn DeleteIpNetEntry2(
    Row: *const MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FlushIpNetTable2(
    Family: u16,
    InterfaceIndex: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpNetEntry2(
    Row: *MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetIpNetTable2(
    Family: u16,
    Table: **MIB_IPNET_TABLE2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ResolveIpNetEntry2(
    Row: *MIB_IPNET_ROW2,
    SourceAddress: ?*const SOCKADDR_INET,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn SetIpNetEntry2(
    Row: *MIB_IPNET_ROW2,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn NotifyTeredoPortChange(
    Callback: PTEREDO_PORT_CHANGE_CALLBACK,
    CallerContext: *c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetTeredoPort(
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn CancelMibChangeNotify2(
    NotificationHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FreeMibTable(
    Memory: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn CreateSortedAddressPairs(
    SourceAddressList: ?*const SOCKADDR_IN6_LH,
    SourceAddressCount: u32,
    DestinationAddressList: *const SOCKADDR_IN6_LH,
    DestinationAddressCount: u32,
    AddressSortOptions: u32,
    SortedAddressPairList: **SOCKADDR_IN6_PAIR,
    SortedAddressPairCount: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertCompartmentGuidToId(
    CompartmentGuid: *const Guid,
    CompartmentId: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertCompartmentIdToGuid(
    CompartmentId: u32,
    CompartmentGuid: *Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceNameToLuidA(
    InterfaceName: *const i8,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceNameToLuidW(
    InterfaceName: [*:0]const u16,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToNameA(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceName: [*:0]u8,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToNameW(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceName: [*:0]u16,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToIndex(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceIndexToLuid(
    InterfaceIndex: u32,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToAlias(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceAlias: [*:0]u16,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceAliasToLuid(
    InterfaceAlias: [*:0]const u16,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceLuidToGuid(
    InterfaceLuid: *const NET_LUID_LH,
    InterfaceGuid: *Guid,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertInterfaceGuidToLuid(
    InterfaceGuid: *const Guid,
    InterfaceLuid: *NET_LUID_LH,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn if_nametoindex(
    InterfaceName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn if_indextoname(
    InterfaceIndex: u32,
    InterfaceName: *[256]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "IPHLPAPI" fn GetCurrentThreadCompartmentScope(
    CompartmentScope: *u32,
    CompartmentId: *u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn SetCurrentThreadCompartmentScope(
    CompartmentScope: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetJobCompartmentId(
    JobHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetJobCompartmentId(
    JobHandle: HANDLE,
    CompartmentId: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetDefaultCompartmentId(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn ConvertLengthToIpv4Mask(
    MaskLength: u32,
    Mask: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn ConvertIpv4MaskToLength(
    Mask: u32,
    MaskLength: *u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetDnsSettings(
    Settings: *DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FreeDnsSettings(
    Settings: *DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn SetDnsSettings(
    Settings: *const DNS_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetInterfaceDnsSettings(
    Interface: Guid,
    Settings: *DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn FreeInterfaceDnsSettings(
    Settings: *DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn SetInterfaceDnsSettings(
    Interface: Guid,
    Settings: *const DNS_INTERFACE_SETTINGS,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetNetworkConnectivityHint(
    ConnectivityHint: *NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn GetNetworkConnectivityHintForInterface(
    InterfaceIndex: u32,
    ConnectivityHint: *NL_NETWORK_CONNECTIVITY_HINT,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn NotifyNetworkConnectivityHintChange(
    Callback: PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK,
    CallerContext: ?*c_void,
    InitialNotification: u8,
    NotificationHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "IPHLPAPI" fn IcmpCreateFile(
) callconv(@import("std").os.windows.WINAPI) IcmpHandle;

pub extern "IPHLPAPI" fn Icmp6CreateFile(
) callconv(@import("std").os.windows.WINAPI) IcmpHandle;

pub extern "IPHLPAPI" fn IcmpCloseHandle(
    IcmpHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IPHLPAPI" fn IcmpSendEcho(
    IcmpHandle: HANDLE,
    DestinationAddress: u32,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn IcmpSendEcho2(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: ?FARPROC,
    ApcContext: ?*c_void,
    DestinationAddress: u32,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn IcmpSendEcho2Ex(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: ?FARPROC,
    ApcContext: ?*c_void,
    SourceAddress: u32,
    DestinationAddress: u32,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn Icmp6SendEcho2(
    IcmpHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: ?FARPROC,
    ApcContext: ?*c_void,
    SourceAddress: *SOCKADDR_IN6_LH,
    DestinationAddress: *SOCKADDR_IN6_LH,
    RequestData: [*]u8,
    RequestSize: u16,
    RequestOptions: ?*ip_option_information,
    ReplyBuffer: [*]u8,
    ReplySize: u32,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn IcmpParseReplies(
    ReplyBuffer: [*]u8,
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn Icmp6ParseReplies(
    ReplyBuffer: [*]u8,
    ReplySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetNumberOfInterfaces(
    pdwNumIf: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIfEntry(
    pIfRow: *MIB_IFROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIfTable(
    pIfTable: ?[*]MIB_IFTABLE,
    pdwSize: *u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpAddrTable(
    pIpAddrTable: ?[*]MIB_IPADDRTABLE,
    pdwSize: *u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpNetTable(
    IpNetTable: ?[*]MIB_IPNETTABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpForwardTable(
    pIpForwardTable: ?[*]MIB_IPFORWARDTABLE,
    pdwSize: *u32,
    bOrder: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpTable(
    TcpTable: ?[*]MIB_TCPTABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetExtendedTcpTable(
    pTcpTable: ?[*]u8,
    pdwSize: *u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: TCP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromTcpEntry(
    pTcpEntry: *MIB_TCPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdpTable(
    UdpTable: ?[*]MIB_UDPTABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetExtendedUdpTable(
    pUdpTable: ?[*]u8,
    pdwSize: *u32,
    bOrder: BOOL,
    ulAf: u32,
    TableClass: UDP_TABLE_CLASS,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromUdpEntry(
    pUdpEntry: *MIB_UDPROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpTable2(
    TcpTable: ?[*]MIB_TCPTABLE2,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcp6Table(
    TcpTable: [*]MIB_TCP6TABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcp6Table2(
    TcpTable: [*]MIB_TCP6TABLE2,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetPerTcpConnectionEStats(
    Row: *MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?[*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Ros: ?[*:0]u8,
    RosVersion: u32,
    RosSize: u32,
    Rod: ?[*:0]u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetPerTcpConnectionEStats(
    Row: *MIB_TCPROW_LH,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: [*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetPerTcp6ConnectionEStats(
    Row: *MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: ?[*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Ros: ?[*:0]u8,
    RosVersion: u32,
    RosSize: u32,
    Rod: ?[*:0]u8,
    RodVersion: u32,
    RodSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetPerTcp6ConnectionEStats(
    Row: *MIB_TCP6ROW,
    EstatsType: TCP_ESTATS_TYPE,
    Rw: [*:0]u8,
    RwVersion: u32,
    RwSize: u32,
    Offset: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromTcp6Entry(
    pTcpEntry: *MIB_TCP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdp6Table(
    Udp6Table: ?[*]MIB_UDP6TABLE,
    SizePointer: *u32,
    Order: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromUdp6Entry(
    pUdpEntry: *MIB_UDP6ROW_OWNER_MODULE,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetOwnerModuleFromPidAndInfo(
    ulPid: u32,
    pInfo: *u64,
    Class: TCPIP_OWNER_MODULE_INFO_CLASS,
    pBuffer: [*]u8,
    pdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpStatistics(
    Statistics: *MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIcmpStatistics(
    Statistics: *MIB_ICMP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpStatistics(
    Statistics: *MIB_TCPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdpStatistics(
    Stats: *MIB_UDPSTATS,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpStatisticsEx(
    Statistics: *MIB_IPSTATS_LH,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpStatisticsEx(
    Statistics: *MIB_IPSTATS_LH,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIcmpStatisticsEx(
    Statistics: *MIB_ICMP_EX_XPSP1,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpStatisticsEx(
    Statistics: *MIB_TCPSTATS_LH,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdpStatisticsEx(
    Statistics: *MIB_UDPSTATS,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetTcpStatisticsEx2(
    Statistics: *MIB_TCPSTATS2,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUdpStatisticsEx2(
    Statistics: *MIB_UDPSTATS2,
    Family: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIfEntry(
    pIfRow: *MIB_IFROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreateIpForwardEntry(
    pRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpForwardEntry(
    pRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeleteIpForwardEntry(
    pRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpStatistics(
    pIpStats: *MIB_IPSTATS_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpTTL(
    nTTL: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreateIpNetEntry(
    pArpEntry: *MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetIpNetEntry(
    pArpEntry: *MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeleteIpNetEntry(
    pArpEntry: *MIB_IPNETROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn FlushIpNetTable(
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreateProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeleteProxyArpEntry(
    dwAddress: u32,
    dwMask: u32,
    dwIfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SetTcpEntry(
    pTcpRow: *MIB_TCPROW_LH,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetInterfaceInfo(
    pIfTable: ?[*]IP_INTERFACE_INFO,
    dwOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetUniDirectionalAdapterInfo(
    pIPIfInfo: ?[*]IP_UNIDIRECTIONAL_ADAPTER_ADDRESS,
    dwOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn NhpAllocateAndGetInterfaceInfoFromStack(
    ppTable: **ip_interface_name_info_w2ksp1,
    pdwCount: *u32,
    bOrder: BOOL,
    hHeap: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetBestInterface(
    dwDestAddr: u32,
    pdwBestIfIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetBestInterfaceEx(
    pDestAddr: *SOCKADDR,
    pdwBestIfIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetBestRoute(
    dwDestAddr: u32,
    dwSourceAddr: u32,
    pBestRoute: *MIB_IPFORWARDROW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn NotifyAddrChange(
    Handle: *HANDLE,
    overlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn NotifyRouteChange(
    Handle: *HANDLE,
    overlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CancelIPChangeNotify(
    notifyOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IPHLPAPI" fn GetAdapterIndex(
    AdapterName: PWSTR,
    IfIndex: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn AddIPAddress(
    Address: u32,
    IpMask: u32,
    IfIndex: u32,
    NTEContext: *u32,
    NTEInstance: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeleteIPAddress(
    NTEContext: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetNetworkParams(
    pFixedInfo: ?[*]FIXED_INFO_W2KSP1,
    pOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetAdaptersInfo(
    AdapterInfo: ?[*]IP_ADAPTER_INFO,
    SizePointer: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetAdapterOrderMap(
) callconv(@import("std").os.windows.WINAPI) *IP_ADAPTER_ORDER_MAP;

pub extern "IPHLPAPI" fn GetAdaptersAddresses(
    Family: u32,
    Flags: u32,
    Reserved: *c_void,
    AdapterAddresses: ?[*]IP_ADAPTER_ADDRESSES_LH,
    SizePointer: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetPerAdapterInfo(
    IfIndex: u32,
    pPerAdapterInfo: ?[*]IP_PER_ADAPTER_INFO_W2KSP1,
    pOutBufLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetInterfaceCurrentTimestampCapabilities(
    InterfaceLuid: *const NET_LUID_LH,
    TimestampCapabilites: *INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetInterfaceHardwareTimestampCapabilities(
    InterfaceLuid: *const NET_LUID_LH,
    TimestampCapabilites: *INTERFACE_TIMESTAMP_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CaptureInterfaceHardwareCrossTimestamp(
    InterfaceLuid: *const NET_LUID_LH,
    CrossTimestamp: *INTERFACE_HARDWARE_CROSSTIMESTAMP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn NotifyIfTimestampConfigChange(
    CallerContext: ?*c_void,
    Callback: PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK,
    NotificationHandle: **HIFTIMESTAMPCHANGE__,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CancelIfTimestampConfigChange(
    NotificationHandle: *HIFTIMESTAMPCHANGE__,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "IPHLPAPI" fn IpReleaseAddress(
    AdapterInfo: *IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn IpRenewAddress(
    AdapterInfo: *IP_ADAPTER_INDEX_MAP,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn SendARP(
    DestIP: u32,
    SrcIP: u32,
    pMacAddr: [*]u8,
    PhyAddrLen: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetRTTAndHopCount(
    DestIpAddress: u32,
    HopCount: *u32,
    MaxHops: u32,
    RTT: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "IPHLPAPI" fn GetFriendlyIfIndex(
    IfIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn EnableRouter(
    pHandle: *HANDLE,
    pOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn UnenableRouter(
    pOverlapped: *OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DisableMediaSense(
    pHandle: *HANDLE,
    pOverLapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn RestoreMediaSense(
    pOverlapped: *OVERLAPPED,
    lpdwEnableCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn GetIpErrorString(
    ErrorCode: u32,
    Buffer: ?PWSTR,
    Size: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn ResolveNeighbor(
    NetworkAddress: *SOCKADDR,
    PhysicalAddress: [*]u8,
    PhysicalAddressLength: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreatePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn CreatePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeletePersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn DeletePersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn LookupPersistentTcpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn LookupPersistentUdpPortReservation(
    StartPort: u16,
    NumberOfPorts: u16,
    Token: *u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlIpv4AddressToStringA(
    Addr: *const in_addr,
    S: *[16]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "ntdll" fn RtlIpv4AddressToStringW(
    Addr: *const in_addr,
    S: *[16]u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

pub extern "ntdll" fn RtlIpv4AddressToStringExW(
    Address: *const in_addr,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressA(
    S: [*:0]const u8,
    Strict: u8,
    Terminator: *PSTR,
    Addr: *in_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressW(
    S: [*:0]const u16,
    Strict: u8,
    Terminator: *PWSTR,
    Addr: *in_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressExW(
    AddressString: [*:0]const u16,
    Strict: u8,
    Address: *in_addr,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6AddressToStringA(
    Addr: *const in6_addr,
    S: *[46]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "ntdll" fn RtlIpv6AddressToStringW(
    Addr: *const in6_addr,
    S: *[46]u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

pub extern "ntdll" fn RtlIpv6AddressToStringExW(
    Address: *const in6_addr,
    ScopeId: u32,
    Port: u16,
    AddressString: [*:0]u16,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressA(
    S: [*:0]const u8,
    Terminator: *PSTR,
    Addr: *in6_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressW(
    S: [*:0]const u16,
    Terminator: *PWSTR,
    Addr: *in6_addr,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressExW(
    AddressString: [*:0]const u16,
    Address: *in6_addr,
    ScopeId: *u32,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlEthernetAddressToStringA(
    Addr: *const DL_EUI48,
    S: *[18]u8,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "ntdll" fn RtlEthernetAddressToStringW(
    Addr: *const DL_EUI48,
    S: *[18]u16,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

pub extern "ntdll" fn RtlEthernetStringToAddressA(
    S: [*:0]const u8,
    Terminator: *PSTR,
    Addr: *DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlEthernetStringToAddressW(
    S: [*:0]const u16,
    Terminator: *PWSTR,
    Addr: *DL_EUI48,
) callconv(@import("std").os.windows.WINAPI) i32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (8)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const ConvertInterfaceNameToLuid = ConvertInterfaceNameToLuidA;
        pub const ConvertInterfaceLuidToName = ConvertInterfaceLuidToNameA;
        pub const RtlIpv4AddressToString = RtlIpv4AddressToStringA;
        pub const RtlIpv4StringToAddress = RtlIpv4StringToAddressA;
        pub const RtlIpv6AddressToString = RtlIpv6AddressToStringA;
        pub const RtlIpv6StringToAddress = RtlIpv6StringToAddressA;
        pub const RtlEthernetAddressToString = RtlEthernetAddressToStringA;
        pub const RtlEthernetStringToAddress = RtlEthernetStringToAddressA;
    },
    .wide => struct {
        pub const ConvertInterfaceNameToLuid = ConvertInterfaceNameToLuidW;
        pub const ConvertInterfaceLuidToName = ConvertInterfaceLuidToNameW;
        pub const RtlIpv4AddressToString = RtlIpv4AddressToStringW;
        pub const RtlIpv4StringToAddress = RtlIpv4StringToAddressW;
        pub const RtlIpv6AddressToString = RtlIpv6AddressToStringW;
        pub const RtlIpv6StringToAddress = RtlIpv6StringToAddressW;
        pub const RtlEthernetAddressToString = RtlEthernetAddressToStringW;
        pub const RtlEthernetStringToAddress = RtlEthernetStringToAddressW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const ConvertInterfaceNameToLuid = *opaque{};
        pub const ConvertInterfaceLuidToName = *opaque{};
        pub const RtlIpv4AddressToString = *opaque{};
        pub const RtlIpv4StringToAddress = *opaque{};
        pub const RtlIpv6AddressToString = *opaque{};
        pub const RtlIpv6StringToAddress = *opaque{};
        pub const RtlEthernetAddressToString = *opaque{};
        pub const RtlEthernetStringToAddress = *opaque{};
    } else struct {
        pub const ConvertInterfaceNameToLuid = @compileError("'ConvertInterfaceNameToLuid' requires that UNICODE be set to true or false in the root module");
        pub const ConvertInterfaceLuidToName = @compileError("'ConvertInterfaceLuidToName' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4AddressToString = @compileError("'RtlIpv4AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv4StringToAddress = @compileError("'RtlIpv4StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6AddressToString = @compileError("'RtlIpv6AddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlIpv6StringToAddress = @compileError("'RtlIpv6StringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetAddressToString = @compileError("'RtlEthernetAddressToString' requires that UNICODE be set to true or false in the root module");
        pub const RtlEthernetStringToAddress = @compileError("'RtlEthernetStringToAddress' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (63)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const MIB_IFSTACK_TABLE = @import("mib.zig").MIB_IFSTACK_TABLE;
const MIB_TCPROW_OWNER_MODULE = @import("mib.zig").MIB_TCPROW_OWNER_MODULE;
const MIB_ANYCASTIPADDRESS_TABLE = @import("mib.zig").MIB_ANYCASTIPADDRESS_TABLE;
const MIB_IPINTERFACE_TABLE = @import("mib.zig").MIB_IPINTERFACE_TABLE;
const MIB_UNICASTIPADDRESS_TABLE = @import("mib.zig").MIB_UNICASTIPADDRESS_TABLE;
const MIB_IPPATH_TABLE = @import("mib.zig").MIB_IPPATH_TABLE;
const MIB_IF_ROW2 = @import("mib.zig").MIB_IF_ROW2;
const MIB_UDPSTATS = @import("mib.zig").MIB_UDPSTATS;
const SOCKADDR = @import("win_sock.zig").SOCKADDR;
const in_addr = @import("win_sock.zig").in_addr;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;
const in6_addr = @import("win_sock.zig").in6_addr;
const MIB_IPADDRTABLE = @import("mib.zig").MIB_IPADDRTABLE;
const MIB_TCPSTATS_LH = @import("mib.zig").MIB_TCPSTATS_LH;
const MIB_ICMP = @import("mib.zig").MIB_ICMP;
const MIB_MULTICASTIPADDRESS_ROW = @import("mib.zig").MIB_MULTICASTIPADDRESS_ROW;
const MIB_TCP6TABLE = @import("mib.zig").MIB_TCP6TABLE;
const PWSTR = @import("system_services.zig").PWSTR;
const MIB_TCP6ROW_OWNER_MODULE = @import("mib.zig").MIB_TCP6ROW_OWNER_MODULE;
const MIB_IPFORWARDTABLE = @import("mib.zig").MIB_IPFORWARDTABLE;
const MIB_IPNET_TABLE2 = @import("mib.zig").MIB_IPNET_TABLE2;
const MIB_NOTIFICATION_TYPE = @import("mib.zig").MIB_NOTIFICATION_TYPE;
const PSTR = @import("system_services.zig").PSTR;
const MIB_IF_TABLE2 = @import("mib.zig").MIB_IF_TABLE2;
const NET_IF_CONNECTION_TYPE = @import("network_drivers.zig").NET_IF_CONNECTION_TYPE;
const MIB_IPNETROW_LH = @import("mib.zig").MIB_IPNETROW_LH;
const MIB_IPFORWARDROW = @import("mib.zig").MIB_IPFORWARDROW;
const HANDLE = @import("system_services.zig").HANDLE;
const TUNNEL_TYPE = @import("network_drivers.zig").TUNNEL_TYPE;
const MIB_UDPSTATS2 = @import("mib.zig").MIB_UDPSTATS2;
const MIB_IPINTERFACE_ROW = @import("mib.zig").MIB_IPINTERFACE_ROW;
const MIB_IPFORWARD_TABLE2 = @import("mib.zig").MIB_IPFORWARD_TABLE2;
const MIB_IF_TABLE_LEVEL = @import("network_drivers.zig").MIB_IF_TABLE_LEVEL;
const MIB_IPPATH_ROW = @import("mib.zig").MIB_IPPATH_ROW;
const MIB_ICMP_EX_XPSP1 = @import("mib.zig").MIB_ICMP_EX_XPSP1;
const MIB_TCP6ROW = @import("mib.zig").MIB_TCP6ROW;
const MIB_INVERTEDIFSTACK_TABLE = @import("mib.zig").MIB_INVERTEDIFSTACK_TABLE;
const MIB_TCPROW_LH = @import("mib.zig").MIB_TCPROW_LH;
const BOOL = @import("system_services.zig").BOOL;
const MIB_ANYCASTIPADDRESS_ROW = @import("mib.zig").MIB_ANYCASTIPADDRESS_ROW;
const MIB_TCPTABLE2 = @import("mib.zig").MIB_TCPTABLE2;
const FARPROC = @import("system_services.zig").FARPROC;
const MIB_TCPSTATS2 = @import("mib.zig").MIB_TCPSTATS2;
const MIB_IPFORWARD_ROW2 = @import("mib.zig").MIB_IPFORWARD_ROW2;
const MIB_UNICASTIPADDRESS_ROW = @import("mib.zig").MIB_UNICASTIPADDRESS_ROW;
const DL_EUI48 = @import("windows_filtering.zig").DL_EUI48;
const MIB_UDPROW_OWNER_MODULE = @import("mib.zig").MIB_UDPROW_OWNER_MODULE;
const MIB_TCP6TABLE2 = @import("mib.zig").MIB_TCP6TABLE2;
const MIB_IPSTATS_LH = @import("mib.zig").MIB_IPSTATS_LH;
const MIB_IFTABLE = @import("mib.zig").MIB_IFTABLE;
const MIB_MULTICASTIPADDRESS_TABLE = @import("mib.zig").MIB_MULTICASTIPADDRESS_TABLE;
const MIB_UDPTABLE = @import("mib.zig").MIB_UDPTABLE;
const MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES = @import("mib.zig").MIB_IP_NETWORK_CONNECTION_BANDWIDTH_ESTIMATES;
const MIB_UDP6ROW_OWNER_MODULE = @import("mib.zig").MIB_UDP6ROW_OWNER_MODULE;
const MIB_TCPTABLE = @import("mib.zig").MIB_TCPTABLE;
const MIB_IPNETTABLE = @import("mib.zig").MIB_IPNETTABLE;
const MIB_IPNET_ROW2 = @import("mib.zig").MIB_IPNET_ROW2;
const SOCKADDR_IN6_LH = @import("network_drivers.zig").SOCKADDR_IN6_LH;
const MIB_IFROW = @import("mib.zig").MIB_IFROW;
const MIB_UDP6TABLE = @import("mib.zig").MIB_UDP6TABLE;
const SOCKET_ADDRESS = @import("win_sock.zig").SOCKET_ADDRESS;
const NTSTATUS = @import("system_services.zig").NTSTATUS;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = PIPINTERFACE_CHANGE_CALLBACK;
    _ = PUNICAST_IPADDRESS_CHANGE_CALLBACK;
    _ = PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK;
    _ = PIPFORWARD_CHANGE_CALLBACK;
    _ = PTEREDO_PORT_CHANGE_CALLBACK;
    _ = PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK;
    _ = INTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK;
    _ = PINTERFACE_TIMESTAMP_CONFIG_CHANGE_CALLBACK;

    const constant_export_count = 0;
    const type_export_count = 100;
    const enum_value_export_count = 145;
    const com_iface_id_export_count = 0;
    const com_class_id_export_count = 0;
    const func_export_count = 190;
    const unicode_alias_count = 8;
    const import_count = 63;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
