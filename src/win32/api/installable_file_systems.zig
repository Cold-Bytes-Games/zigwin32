//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (21)
//--------------------------------------------------------------------------------
// TODO: this type has a FreeFunc 'FilterFindClose', what can Zig do with this information?
pub const FilterFindHandle = ?*c_void;

// TODO: this type has a FreeFunc 'FilterInstanceFindClose', what can Zig do with this information?
pub const FilterInstanceFindHandle = ?*c_void;

// TODO: this type has a FreeFunc 'FilterVolumeFindClose', what can Zig do with this information?
pub const FilterVolumeFindHandle = ?*c_void;

// TODO: this type has a FreeFunc 'FilterVolumeInstanceFindClose', what can Zig do with this information?
pub const FilterVolumeInstanceFindHandle = ?*c_void;

// TODO: this type has a FreeFunc 'FilterClose', what can Zig do with this information?
pub const HFILTER = ?*c_void;

// TODO: this type has a FreeFunc 'FilterInstanceClose', what can Zig do with this information?
pub const HFILTER_INSTANCE = ?*c_void;

pub const FLT_FILESYSTEM_TYPE = extern enum(i32) {
    FLT_FSTYPE_UNKNOWN = 0,
    FLT_FSTYPE_RAW = 1,
    FLT_FSTYPE_NTFS = 2,
    FLT_FSTYPE_FAT = 3,
    FLT_FSTYPE_CDFS = 4,
    FLT_FSTYPE_UDFS = 5,
    FLT_FSTYPE_LANMAN = 6,
    FLT_FSTYPE_WEBDAV = 7,
    FLT_FSTYPE_RDPDR = 8,
    FLT_FSTYPE_NFS = 9,
    FLT_FSTYPE_MS_NETWARE = 10,
    FLT_FSTYPE_NETWARE = 11,
    FLT_FSTYPE_BSUDF = 12,
    FLT_FSTYPE_MUP = 13,
    FLT_FSTYPE_RSFX = 14,
    FLT_FSTYPE_ROXIO_UDF1 = 15,
    FLT_FSTYPE_ROXIO_UDF2 = 16,
    FLT_FSTYPE_ROXIO_UDF3 = 17,
    FLT_FSTYPE_TACIT = 18,
    FLT_FSTYPE_FS_REC = 19,
    FLT_FSTYPE_INCD = 20,
    FLT_FSTYPE_INCD_FAT = 21,
    FLT_FSTYPE_EXFAT = 22,
    FLT_FSTYPE_PSFS = 23,
    FLT_FSTYPE_GPFS = 24,
    FLT_FSTYPE_NPFS = 25,
    FLT_FSTYPE_MSFS = 26,
    FLT_FSTYPE_CSVFS = 27,
    FLT_FSTYPE_REFS = 28,
    FLT_FSTYPE_OPENAFS = 29,
    FLT_FSTYPE_CIMFS = 30,
};
pub const FLT_FSTYPE_UNKNOWN = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_UNKNOWN;
pub const FLT_FSTYPE_RAW = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_RAW;
pub const FLT_FSTYPE_NTFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_NTFS;
pub const FLT_FSTYPE_FAT = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_FAT;
pub const FLT_FSTYPE_CDFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_CDFS;
pub const FLT_FSTYPE_UDFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_UDFS;
pub const FLT_FSTYPE_LANMAN = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_LANMAN;
pub const FLT_FSTYPE_WEBDAV = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_WEBDAV;
pub const FLT_FSTYPE_RDPDR = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_RDPDR;
pub const FLT_FSTYPE_NFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_NFS;
pub const FLT_FSTYPE_MS_NETWARE = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_MS_NETWARE;
pub const FLT_FSTYPE_NETWARE = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_NETWARE;
pub const FLT_FSTYPE_BSUDF = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_BSUDF;
pub const FLT_FSTYPE_MUP = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_MUP;
pub const FLT_FSTYPE_RSFX = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_RSFX;
pub const FLT_FSTYPE_ROXIO_UDF1 = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_ROXIO_UDF1;
pub const FLT_FSTYPE_ROXIO_UDF2 = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_ROXIO_UDF2;
pub const FLT_FSTYPE_ROXIO_UDF3 = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_ROXIO_UDF3;
pub const FLT_FSTYPE_TACIT = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_TACIT;
pub const FLT_FSTYPE_FS_REC = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_FS_REC;
pub const FLT_FSTYPE_INCD = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_INCD;
pub const FLT_FSTYPE_INCD_FAT = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_INCD_FAT;
pub const FLT_FSTYPE_EXFAT = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_EXFAT;
pub const FLT_FSTYPE_PSFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_PSFS;
pub const FLT_FSTYPE_GPFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_GPFS;
pub const FLT_FSTYPE_NPFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_NPFS;
pub const FLT_FSTYPE_MSFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_MSFS;
pub const FLT_FSTYPE_CSVFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_CSVFS;
pub const FLT_FSTYPE_REFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_REFS;
pub const FLT_FSTYPE_OPENAFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_OPENAFS;
pub const FLT_FSTYPE_CIMFS = FLT_FILESYSTEM_TYPE.FLT_FSTYPE_CIMFS;

pub const FILTER_INFORMATION_CLASS = extern enum(i32) {
    FilterFullInformation = 0,
    FilterAggregateBasicInformation = 1,
    FilterAggregateStandardInformation = 2,
};
pub const FilterFullInformation = FILTER_INFORMATION_CLASS.FilterFullInformation;
pub const FilterAggregateBasicInformation = FILTER_INFORMATION_CLASS.FilterAggregateBasicInformation;
pub const FilterAggregateStandardInformation = FILTER_INFORMATION_CLASS.FilterAggregateStandardInformation;

pub const FILTER_FULL_INFORMATION = extern struct {
    NextEntryOffset: u32,
    FrameID: u32,
    NumberOfInstances: u32,
    FilterNameLength: u16,
    FilterNameBuffer: [1]u16,
};

pub const FILTER_AGGREGATE_BASIC_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Flags: u32,
    Type: FILTER_AGGREGATE_BASIC_INFORMATION._Type_e__Union,
    const _Type_e__Union = u32; // TODO: generate this nested type!
};

pub const FILTER_AGGREGATE_STANDARD_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Flags: u32,
    Type: FILTER_AGGREGATE_STANDARD_INFORMATION._Type_e__Union,
    const _Type_e__Union = u32; // TODO: generate this nested type!
};

pub const FILTER_VOLUME_INFORMATION_CLASS = extern enum(i32) {
    FilterVolumeBasicInformation = 0,
    FilterVolumeStandardInformation = 1,
};
pub const FilterVolumeBasicInformation = FILTER_VOLUME_INFORMATION_CLASS.FilterVolumeBasicInformation;
pub const FilterVolumeStandardInformation = FILTER_VOLUME_INFORMATION_CLASS.FilterVolumeStandardInformation;

pub const FILTER_VOLUME_BASIC_INFORMATION = extern struct {
    FilterVolumeNameLength: u16,
    FilterVolumeName: [1]u16,
};

pub const FILTER_VOLUME_STANDARD_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Flags: u32,
    FrameID: u32,
    FileSystemType: FLT_FILESYSTEM_TYPE,
    FilterVolumeNameLength: u16,
    FilterVolumeName: [1]u16,
};

pub const INSTANCE_INFORMATION_CLASS = extern enum(i32) {
    InstanceBasicInformation = 0,
    InstancePartialInformation = 1,
    InstanceFullInformation = 2,
    InstanceAggregateStandardInformation = 3,
};
pub const InstanceBasicInformation = INSTANCE_INFORMATION_CLASS.InstanceBasicInformation;
pub const InstancePartialInformation = INSTANCE_INFORMATION_CLASS.InstancePartialInformation;
pub const InstanceFullInformation = INSTANCE_INFORMATION_CLASS.InstanceFullInformation;
pub const InstanceAggregateStandardInformation = INSTANCE_INFORMATION_CLASS.InstanceAggregateStandardInformation;

pub const INSTANCE_BASIC_INFORMATION = extern struct {
    NextEntryOffset: u32,
    InstanceNameLength: u16,
    InstanceNameBufferOffset: u16,
};

pub const INSTANCE_PARTIAL_INFORMATION = extern struct {
    NextEntryOffset: u32,
    InstanceNameLength: u16,
    InstanceNameBufferOffset: u16,
    AltitudeLength: u16,
    AltitudeBufferOffset: u16,
};

pub const INSTANCE_FULL_INFORMATION = extern struct {
    NextEntryOffset: u32,
    InstanceNameLength: u16,
    InstanceNameBufferOffset: u16,
    AltitudeLength: u16,
    AltitudeBufferOffset: u16,
    VolumeNameLength: u16,
    VolumeNameBufferOffset: u16,
    FilterNameLength: u16,
    FilterNameBufferOffset: u16,
};

pub const INSTANCE_AGGREGATE_STANDARD_INFORMATION = extern struct {
    NextEntryOffset: u32,
    Flags: u32,
    Type: INSTANCE_AGGREGATE_STANDARD_INFORMATION._Type_e__Union,
    const _Type_e__Union = u32; // TODO: generate this nested type!
};

pub const FILTER_MESSAGE_HEADER = extern struct {
    ReplyLength: u32,
    MessageId: u64,
};

pub const FILTER_REPLY_HEADER = extern struct {
    Status: NTSTATUS,
    MessageId: u64,
};


//--------------------------------------------------------------------------------
// Section: Functions (29)
//--------------------------------------------------------------------------------
pub extern "KERNEL32" fn RtlCaptureStackBackTrace(
    FramesToSkip: u32,
    FramesToCapture: u32,
    BackTrace: [*]*c_void,
    BackTraceHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "FLTLIB" fn FilterLoad(
    lpFilterName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterUnload(
    lpFilterName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterCreate(
    lpFilterName: [*:0]const u16,
    hFilter: *HFILTER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterClose(
    hFilter: HFILTER,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterInstanceCreate(
    lpFilterName: [*:0]const u16,
    lpVolumeName: [*:0]const u16,
    lpInstanceName: ?[*:0]const u16,
    hInstance: *HFILTER_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterInstanceClose(
    hInstance: HFILTER_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterAttach(
    lpFilterName: [*:0]const u16,
    lpVolumeName: [*:0]const u16,
    lpInstanceName: ?[*:0]const u16,
    dwCreatedInstanceNameLength: u32,
    lpCreatedInstanceName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterAttachAtAltitude(
    lpFilterName: [*:0]const u16,
    lpVolumeName: [*:0]const u16,
    lpAltitude: [*:0]const u16,
    lpInstanceName: ?[*:0]const u16,
    dwCreatedInstanceNameLength: u32,
    lpCreatedInstanceName: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterDetach(
    lpFilterName: [*:0]const u16,
    lpVolumeName: [*:0]const u16,
    lpInstanceName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterFindFirst(
    dwInformationClass: FILTER_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
    lpFilterFind: *FilterFindHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterFindNext(
    hFilterFind: HANDLE,
    dwInformationClass: FILTER_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterFindClose(
    hFilterFind: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterVolumeFindFirst(
    dwInformationClass: FILTER_VOLUME_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
    lpVolumeFind: *FilterVolumeFindHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterVolumeFindNext(
    hVolumeFind: HANDLE,
    dwInformationClass: FILTER_VOLUME_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterVolumeFindClose(
    hVolumeFind: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterInstanceFindFirst(
    lpFilterName: [*:0]const u16,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
    lpFilterInstanceFind: *FilterInstanceFindHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterInstanceFindNext(
    hFilterInstanceFind: HANDLE,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterInstanceFindClose(
    hFilterInstanceFind: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterVolumeInstanceFindFirst(
    lpVolumeName: [*:0]const u16,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
    lpVolumeInstanceFind: *FilterVolumeInstanceFindHandle,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterVolumeInstanceFindNext(
    hVolumeInstanceFind: HANDLE,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterVolumeInstanceFindClose(
    hVolumeInstanceFind: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterGetInformation(
    hFilter: HFILTER,
    dwInformationClass: FILTER_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterInstanceGetInformation(
    hInstance: HFILTER_INSTANCE,
    dwInformationClass: INSTANCE_INFORMATION_CLASS,
    lpBuffer: [*]u8,
    dwBufferSize: u32,
    lpBytesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterConnectCommunicationPort(
    lpPortName: [*:0]const u16,
    dwOptions: u32,
    lpContext: ?[*]const u8,
    wSizeOfContext: u16,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
    hPort: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterSendMessage(
    hPort: HANDLE,
    lpInBuffer: [*]u8,
    dwInBufferSize: u32,
    lpOutBuffer: ?[*]u8,
    dwOutBufferSize: u32,
    lpBytesReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterGetMessage(
    hPort: HANDLE,
    lpMessageBuffer: [*]FILTER_MESSAGE_HEADER,
    dwMessageBufferSize: u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterReplyMessage(
    hPort: HANDLE,
    lpReplyBuffer: [*]FILTER_REPLY_HEADER,
    dwReplyBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "FLTLIB" fn FilterGetDosName(
    lpVolumeName: [*:0]const u16,
    lpDosName: [*:0]u16,
    dwDosNameBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (6)
//--------------------------------------------------------------------------------
const HRESULT = @import("com.zig").HRESULT;
const SECURITY_ATTRIBUTES = @import("system_services.zig").SECURITY_ATTRIBUTES;
const PWSTR = @import("system_services.zig").PWSTR;
const HANDLE = @import("system_services.zig").HANDLE;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;
const NTSTATUS = @import("system_services.zig").NTSTATUS;

test {
    const constant_export_count = 0;
    const type_export_count = 21;
    const enum_value_export_count = 40;
    const com_iface_id_export_count = 0;
    const com_class_id_export_count = 0;
    const func_export_count = 29;
    const unicode_alias_count = 0;
    const import_count = 6;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
