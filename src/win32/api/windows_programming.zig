//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (3)
//--------------------------------------------------------------------------------
pub const _IID_IXmlReader = @import("../zig.zig").Guid.initString("7279fc81-709d-4095-b63d-69fe4b0d9030");
pub const _IID_IXmlWriter = @import("../zig.zig").Guid.initString("7279fc88-709d-4095-b63d-69fe4b0d9030");
pub const _IID_IXmlResolver = @import("../zig.zig").Guid.initString("7279fc82-709d-4095-b63d-69fe4b0d9030");

//--------------------------------------------------------------------------------
// Section: Types (579)
//--------------------------------------------------------------------------------
// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PROCESS_CREATION_FLAGS = extern enum(u32) {
    DEBUG_PROCESS = 1,
    DEBUG_ONLY_THIS_PROCESS = 2,
    CREATE_SUSPENDED = 4,
    DETACHED_PROCESS = 8,
    CREATE_NEW_CONSOLE = 16,
    NORMAL_PRIORITY_CLASS = 32,
    IDLE_PRIORITY_CLASS = 64,
    HIGH_PRIORITY_CLASS = 128,
    REALTIME_PRIORITY_CLASS = 256,
    CREATE_NEW_PROCESS_GROUP = 512,
    CREATE_UNICODE_ENVIRONMENT = 1024,
    CREATE_SEPARATE_WOW_VDM = 2048,
    CREATE_SHARED_WOW_VDM = 4096,
    CREATE_FORCEDOS = 8192,
    BELOW_NORMAL_PRIORITY_CLASS = 16384,
    ABOVE_NORMAL_PRIORITY_CLASS = 32768,
    INHERIT_PARENT_AFFINITY = 65536,
    INHERIT_CALLER_PRIORITY = 131072,
    CREATE_PROTECTED_PROCESS = 262144,
    EXTENDED_STARTUPINFO_PRESENT = 524288,
    PROCESS_MODE_BACKGROUND_BEGIN = 1048576,
    PROCESS_MODE_BACKGROUND_END = 2097152,
    CREATE_SECURE_PROCESS = 4194304,
    CREATE_BREAKAWAY_FROM_JOB = 16777216,
    CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 33554432,
    CREATE_DEFAULT_ERROR_MODE = 67108864,
    CREATE_NO_WINDOW = 134217728,
    PROFILE_USER = 268435456,
    PROFILE_KERNEL = 536870912,
    PROFILE_SERVER = 1073741824,
    CREATE_IGNORE_SYSTEM_DEFAULT = 2147483648,
};
pub const DEBUG_PROCESS = PROCESS_CREATION_FLAGS.DEBUG_PROCESS;
pub const DEBUG_ONLY_THIS_PROCESS = PROCESS_CREATION_FLAGS.DEBUG_ONLY_THIS_PROCESS;
pub const CREATE_SUSPENDED = PROCESS_CREATION_FLAGS.CREATE_SUSPENDED;
pub const DETACHED_PROCESS = PROCESS_CREATION_FLAGS.DETACHED_PROCESS;
pub const CREATE_NEW_CONSOLE = PROCESS_CREATION_FLAGS.CREATE_NEW_CONSOLE;
pub const NORMAL_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.NORMAL_PRIORITY_CLASS;
pub const IDLE_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.IDLE_PRIORITY_CLASS;
pub const HIGH_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.HIGH_PRIORITY_CLASS;
pub const REALTIME_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.REALTIME_PRIORITY_CLASS;
pub const CREATE_NEW_PROCESS_GROUP = PROCESS_CREATION_FLAGS.CREATE_NEW_PROCESS_GROUP;
pub const CREATE_UNICODE_ENVIRONMENT = PROCESS_CREATION_FLAGS.CREATE_UNICODE_ENVIRONMENT;
pub const CREATE_SEPARATE_WOW_VDM = PROCESS_CREATION_FLAGS.CREATE_SEPARATE_WOW_VDM;
pub const CREATE_SHARED_WOW_VDM = PROCESS_CREATION_FLAGS.CREATE_SHARED_WOW_VDM;
pub const CREATE_FORCEDOS = PROCESS_CREATION_FLAGS.CREATE_FORCEDOS;
pub const BELOW_NORMAL_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.BELOW_NORMAL_PRIORITY_CLASS;
pub const ABOVE_NORMAL_PRIORITY_CLASS = PROCESS_CREATION_FLAGS.ABOVE_NORMAL_PRIORITY_CLASS;
pub const INHERIT_PARENT_AFFINITY = PROCESS_CREATION_FLAGS.INHERIT_PARENT_AFFINITY;
pub const INHERIT_CALLER_PRIORITY = PROCESS_CREATION_FLAGS.INHERIT_CALLER_PRIORITY;
pub const CREATE_PROTECTED_PROCESS = PROCESS_CREATION_FLAGS.CREATE_PROTECTED_PROCESS;
pub const EXTENDED_STARTUPINFO_PRESENT = PROCESS_CREATION_FLAGS.EXTENDED_STARTUPINFO_PRESENT;
pub const PROCESS_MODE_BACKGROUND_BEGIN = PROCESS_CREATION_FLAGS.PROCESS_MODE_BACKGROUND_BEGIN;
pub const PROCESS_MODE_BACKGROUND_END = PROCESS_CREATION_FLAGS.PROCESS_MODE_BACKGROUND_END;
pub const CREATE_SECURE_PROCESS = PROCESS_CREATION_FLAGS.CREATE_SECURE_PROCESS;
pub const CREATE_BREAKAWAY_FROM_JOB = PROCESS_CREATION_FLAGS.CREATE_BREAKAWAY_FROM_JOB;
pub const CREATE_PRESERVE_CODE_AUTHZ_LEVEL = PROCESS_CREATION_FLAGS.CREATE_PRESERVE_CODE_AUTHZ_LEVEL;
pub const CREATE_DEFAULT_ERROR_MODE = PROCESS_CREATION_FLAGS.CREATE_DEFAULT_ERROR_MODE;
pub const CREATE_NO_WINDOW = PROCESS_CREATION_FLAGS.CREATE_NO_WINDOW;
pub const PROFILE_USER = PROCESS_CREATION_FLAGS.PROFILE_USER;
pub const PROFILE_KERNEL = PROCESS_CREATION_FLAGS.PROFILE_KERNEL;
pub const PROFILE_SERVER = PROCESS_CREATION_FLAGS.PROFILE_SERVER;
pub const CREATE_IGNORE_SYSTEM_DEFAULT = PROCESS_CREATION_FLAGS.CREATE_IGNORE_SYSTEM_DEFAULT;

pub const HANDLE_FLAG_OPTIONS = extern enum(i32) {
    HANDLE_FLAG_INHERIT = 1,
    HANDLE_FLAG_PROTECT_FROM_CLOSE = 2,
};
pub const HANDLE_FLAG_INHERIT = HANDLE_FLAG_OPTIONS.HANDLE_FLAG_INHERIT;
pub const HANDLE_FLAG_PROTECT_FROM_CLOSE = HANDLE_FLAG_OPTIONS.HANDLE_FLAG_PROTECT_FROM_CLOSE;

pub const DUPLICATE_HANDLE_OPTIONS = extern enum(i32) {
    DUPLICATE_CLOSE_SOURCE = 1,
    DUPLICATE_SAME_ACCESS = 2,
};
pub const DUPLICATE_CLOSE_SOURCE = DUPLICATE_HANDLE_OPTIONS.DUPLICATE_CLOSE_SOURCE;
pub const DUPLICATE_SAME_ACCESS = DUPLICATE_HANDLE_OPTIONS.DUPLICATE_SAME_ACCESS;

pub const STD_HANDLE_TYPE = extern enum(u32) {
    STD_INPUT_HANDLE = 4294967286,
    STD_OUTPUT_HANDLE = 4294967285,
    STD_ERROR_HANDLE = 4294967284,
};
pub const STD_INPUT_HANDLE = STD_HANDLE_TYPE.STD_INPUT_HANDLE;
pub const STD_OUTPUT_HANDLE = STD_HANDLE_TYPE.STD_OUTPUT_HANDLE;
pub const STD_ERROR_HANDLE = STD_HANDLE_TYPE.STD_ERROR_HANDLE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const VER_FLAGS = extern enum(u32) {
    VER_MINORVERSION = 1,
    VER_MAJORVERSION = 2,
    VER_BUILDNUMBER = 4,
    VER_PLATFORMID = 8,
    VER_SERVICEPACKMINOR = 16,
    VER_SERVICEPACKMAJOR = 32,
    VER_SUITENAME = 64,
    VER_PRODUCT_TYPE = 128,
};
pub const VER_MINORVERSION = VER_FLAGS.VER_MINORVERSION;
pub const VER_MAJORVERSION = VER_FLAGS.VER_MAJORVERSION;
pub const VER_BUILDNUMBER = VER_FLAGS.VER_BUILDNUMBER;
pub const VER_PLATFORMID = VER_FLAGS.VER_PLATFORMID;
pub const VER_SERVICEPACKMINOR = VER_FLAGS.VER_SERVICEPACKMINOR;
pub const VER_SERVICEPACKMAJOR = VER_FLAGS.VER_SERVICEPACKMAJOR;
pub const VER_SUITENAME = VER_FLAGS.VER_SUITENAME;
pub const VER_PRODUCT_TYPE = VER_FLAGS.VER_PRODUCT_TYPE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const FORMAT_MESSAGE_OPTIONS = extern enum(i32) {
    FORMAT_MESSAGE_ALLOCATE_BUFFER = 256,
    FORMAT_MESSAGE_IGNORE_INSERTS = 512,
    FORMAT_MESSAGE_FROM_STRING = 1024,
    FORMAT_MESSAGE_FROM_HMODULE = 2048,
    FORMAT_MESSAGE_FROM_SYSTEM = 4096,
    FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192,
    FORMAT_MESSAGE_MAX_WIDTH_MASK = 255,
};
pub const FORMAT_MESSAGE_ALLOCATE_BUFFER = FORMAT_MESSAGE_OPTIONS.FORMAT_MESSAGE_ALLOCATE_BUFFER;
pub const FORMAT_MESSAGE_IGNORE_INSERTS = FORMAT_MESSAGE_OPTIONS.FORMAT_MESSAGE_IGNORE_INSERTS;
pub const FORMAT_MESSAGE_FROM_STRING = FORMAT_MESSAGE_OPTIONS.FORMAT_MESSAGE_FROM_STRING;
pub const FORMAT_MESSAGE_FROM_HMODULE = FORMAT_MESSAGE_OPTIONS.FORMAT_MESSAGE_FROM_HMODULE;
pub const FORMAT_MESSAGE_FROM_SYSTEM = FORMAT_MESSAGE_OPTIONS.FORMAT_MESSAGE_FROM_SYSTEM;
pub const FORMAT_MESSAGE_ARGUMENT_ARRAY = FORMAT_MESSAGE_OPTIONS.FORMAT_MESSAGE_ARGUMENT_ARRAY;
pub const FORMAT_MESSAGE_MAX_WIDTH_MASK = FORMAT_MESSAGE_OPTIONS.FORMAT_MESSAGE_MAX_WIDTH_MASK;

pub const STRING = extern struct {
    Length: u16,
    MaximumLength: u16,
    Buffer: [*]u8,
};

pub const EXTENDED_NAME_FORMAT = extern enum(i32) {
    NameUnknown = 0,
    NameFullyQualifiedDN = 1,
    NameSamCompatible = 2,
    NameDisplay = 3,
    NameUniqueId = 6,
    NameCanonical = 7,
    NameUserPrincipal = 8,
    NameCanonicalEx = 9,
    NameServicePrincipal = 10,
    NameDnsDomain = 12,
    NameGivenName = 13,
    NameSurname = 14,
};
pub const NameUnknown = EXTENDED_NAME_FORMAT.NameUnknown;
pub const NameFullyQualifiedDN = EXTENDED_NAME_FORMAT.NameFullyQualifiedDN;
pub const NameSamCompatible = EXTENDED_NAME_FORMAT.NameSamCompatible;
pub const NameDisplay = EXTENDED_NAME_FORMAT.NameDisplay;
pub const NameUniqueId = EXTENDED_NAME_FORMAT.NameUniqueId;
pub const NameCanonical = EXTENDED_NAME_FORMAT.NameCanonical;
pub const NameUserPrincipal = EXTENDED_NAME_FORMAT.NameUserPrincipal;
pub const NameCanonicalEx = EXTENDED_NAME_FORMAT.NameCanonicalEx;
pub const NameServicePrincipal = EXTENDED_NAME_FORMAT.NameServicePrincipal;
pub const NameDnsDomain = EXTENDED_NAME_FORMAT.NameDnsDomain;
pub const NameGivenName = EXTENDED_NAME_FORMAT.NameGivenName;
pub const NameSurname = EXTENDED_NAME_FORMAT.NameSurname;

pub const NETLOGON_INFO_1 = extern struct {
    netlog1_flags: u32,
    netlog1_pdc_connection_status: u32,
};

pub const NETLOGON_INFO_2 = extern struct {
    netlog2_flags: u32,
    netlog2_pdc_connection_status: u32,
    netlog2_trusted_dc_name: PWSTR,
    netlog2_tc_connection_status: u32,
};

pub const NETLOGON_INFO_3 = extern struct {
    netlog3_flags: u32,
    netlog3_logon_attempts: u32,
    netlog3_reserved1: u32,
    netlog3_reserved2: u32,
    netlog3_reserved3: u32,
    netlog3_reserved4: u32,
    netlog3_reserved5: u32,
};

pub const NETLOGON_INFO_4 = extern struct {
    netlog4_trusted_dc_name: PWSTR,
    netlog4_trusted_domain_name: PWSTR,
};

// TODO: this type has a FreeFunc 'RegCloseKey', what can Zig do with this information?
pub const HKEY = ?*c_void;

pub const FIRMWARE_TYPE = extern enum(i32) {
    FirmwareTypeUnknown = 0,
    FirmwareTypeBios = 1,
    FirmwareTypeUefi = 2,
    FirmwareTypeMax = 3,
};
pub const FirmwareTypeUnknown = FIRMWARE_TYPE.FirmwareTypeUnknown;
pub const FirmwareTypeBios = FIRMWARE_TYPE.FirmwareTypeBios;
pub const FirmwareTypeUefi = FIRMWARE_TYPE.FirmwareTypeUefi;
pub const FirmwareTypeMax = FIRMWARE_TYPE.FirmwareTypeMax;

pub const OSVERSIONINFOA = extern struct {
    dwOSVersionInfoSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformId: u32,
    szCSDVersion: [128]i8,
};

pub const OSVERSIONINFOW = extern struct {
    dwOSVersionInfoSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformId: u32,
    szCSDVersion: [128]u16,
};

pub const OSVERSIONINFOEXA = extern struct {
    dwOSVersionInfoSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformId: u32,
    szCSDVersion: [128]i8,
    wServicePackMajor: u16,
    wServicePackMinor: u16,
    wSuiteMask: u16,
    wProductType: u8,
    wReserved: u8,
};

pub const OSVERSIONINFOEXW = extern struct {
    dwOSVersionInfoSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    dwBuildNumber: u32,
    dwPlatformId: u32,
    szCSDVersion: [128]u16,
    wServicePackMajor: u16,
    wServicePackMinor: u16,
    wSuiteMask: u16,
    wProductType: u8,
    wReserved: u8,
};

pub const FILETIME = extern struct {
    dwLowDateTime: u32,
    dwHighDateTime: u32,
};

pub const SYSTEMTIME = extern struct {
    wYear: u16,
    wMonth: u16,
    wDayOfWeek: u16,
    wDay: u16,
    wHour: u16,
    wMinute: u16,
    wSecond: u16,
    wMilliseconds: u16,
};

pub const UpdateImpactLevel = extern enum(i32) {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
};
pub const UpdateImpactLevel_None = UpdateImpactLevel.None;
pub const UpdateImpactLevel_Low = UpdateImpactLevel.Low;
pub const UpdateImpactLevel_Medium = UpdateImpactLevel.Medium;
pub const UpdateImpactLevel_High = UpdateImpactLevel.High;

pub const UpdateAssessmentStatus = extern enum(i32) {
    Latest = 0,
    NotLatestSoftRestriction = 1,
    NotLatestHardRestriction = 2,
    NotLatestEndOfSupport = 3,
    NotLatestServicingTrain = 4,
    NotLatestDeferredFeature = 5,
    NotLatestDeferredQuality = 6,
    NotLatestPausedFeature = 7,
    NotLatestPausedQuality = 8,
    NotLatestManaged = 9,
    NotLatestUnknown = 10,
    NotLatestTargetedVersion = 11,
};
pub const UpdateAssessmentStatus_Latest = UpdateAssessmentStatus.Latest;
pub const UpdateAssessmentStatus_NotLatestSoftRestriction = UpdateAssessmentStatus.NotLatestSoftRestriction;
pub const UpdateAssessmentStatus_NotLatestHardRestriction = UpdateAssessmentStatus.NotLatestHardRestriction;
pub const UpdateAssessmentStatus_NotLatestEndOfSupport = UpdateAssessmentStatus.NotLatestEndOfSupport;
pub const UpdateAssessmentStatus_NotLatestServicingTrain = UpdateAssessmentStatus.NotLatestServicingTrain;
pub const UpdateAssessmentStatus_NotLatestDeferredFeature = UpdateAssessmentStatus.NotLatestDeferredFeature;
pub const UpdateAssessmentStatus_NotLatestDeferredQuality = UpdateAssessmentStatus.NotLatestDeferredQuality;
pub const UpdateAssessmentStatus_NotLatestPausedFeature = UpdateAssessmentStatus.NotLatestPausedFeature;
pub const UpdateAssessmentStatus_NotLatestPausedQuality = UpdateAssessmentStatus.NotLatestPausedQuality;
pub const UpdateAssessmentStatus_NotLatestManaged = UpdateAssessmentStatus.NotLatestManaged;
pub const UpdateAssessmentStatus_NotLatestUnknown = UpdateAssessmentStatus.NotLatestUnknown;
pub const UpdateAssessmentStatus_NotLatestTargetedVersion = UpdateAssessmentStatus.NotLatestTargetedVersion;

pub const UpdateAssessment = extern struct {
    status: UpdateAssessmentStatus,
    impact: UpdateImpactLevel,
    daysOutOfDate: u32,
};

pub const OSUpdateAssessment = extern struct {
    isEndOfSupport: BOOL,
    assessmentForCurrent: UpdateAssessment,
    assessmentForUpToDate: UpdateAssessment,
    securityStatus: UpdateAssessmentStatus,
    assessmentTime: FILETIME,
    releaseInfoTime: FILETIME,
    currentOSBuild: PWSTR,
    currentOSReleaseTime: FILETIME,
    upToDateOSBuild: PWSTR,
    upToDateOSReleaseTime: FILETIME,
};

pub const _PROC_THREAD_ATTRIBUTE_LIST = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const THREAD_INFORMATION_CLASS = extern enum(i32) {
    ThreadMemoryPriority = 0,
    ThreadAbsoluteCpuPriority = 1,
    ThreadDynamicCodePolicy = 2,
    ThreadPowerThrottling = 3,
    ThreadInformationClassMax = 4,
};
pub const ThreadMemoryPriority = THREAD_INFORMATION_CLASS.ThreadMemoryPriority;
pub const ThreadAbsoluteCpuPriority = THREAD_INFORMATION_CLASS.ThreadAbsoluteCpuPriority;
pub const ThreadDynamicCodePolicy = THREAD_INFORMATION_CLASS.ThreadDynamicCodePolicy;
pub const ThreadPowerThrottling = THREAD_INFORMATION_CLASS.ThreadPowerThrottling;
pub const ThreadInformationClassMax = THREAD_INFORMATION_CLASS.ThreadInformationClassMax;

pub const SYSTEM_INFO = extern struct {
    Anonymous: SYSTEM_INFO._Anonymous_e__Union,
    dwPageSize: u32,
    lpMinimumApplicationAddress: *c_void,
    lpMaximumApplicationAddress: *c_void,
    dwActiveProcessorMask: ?*c_void,
    dwNumberOfProcessors: u32,
    dwProcessorType: u32,
    dwAllocationGranularity: u32,
    wProcessorLevel: u16,
    wProcessorRevision: u16,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const COMPUTER_NAME_FORMAT = extern enum(i32) {
    ComputerNameNetBIOS = 0,
    ComputerNameDnsHostname = 1,
    ComputerNameDnsDomain = 2,
    ComputerNameDnsFullyQualified = 3,
    ComputerNamePhysicalNetBIOS = 4,
    ComputerNamePhysicalDnsHostname = 5,
    ComputerNamePhysicalDnsDomain = 6,
    ComputerNamePhysicalDnsFullyQualified = 7,
    ComputerNameMax = 8,
};
pub const ComputerNameNetBIOS = COMPUTER_NAME_FORMAT.ComputerNameNetBIOS;
pub const ComputerNameDnsHostname = COMPUTER_NAME_FORMAT.ComputerNameDnsHostname;
pub const ComputerNameDnsDomain = COMPUTER_NAME_FORMAT.ComputerNameDnsDomain;
pub const ComputerNameDnsFullyQualified = COMPUTER_NAME_FORMAT.ComputerNameDnsFullyQualified;
pub const ComputerNamePhysicalNetBIOS = COMPUTER_NAME_FORMAT.ComputerNamePhysicalNetBIOS;
pub const ComputerNamePhysicalDnsHostname = COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsHostname;
pub const ComputerNamePhysicalDnsDomain = COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsDomain;
pub const ComputerNamePhysicalDnsFullyQualified = COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsFullyQualified;
pub const ComputerNameMax = COMPUTER_NAME_FORMAT.ComputerNameMax;

pub const LPFIBER_START_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFIBER_CALLOUT_ROUTINE = fn(
    lpParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const JIT_DEBUG_INFO = extern struct {
    dwSize: u32,
    dwProcessorArchitecture: u32,
    dwThreadID: u32,
    dwReserved0: u32,
    lpExceptionAddress: u64,
    lpExceptionRecord: u64,
    lpContextRecord: u64,
};

pub const PUMS_SCHEDULER_ENTRY_POINT = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const DEP_SYSTEM_POLICY_TYPE = extern enum(i32) {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn = 1,
    DEPPolicyOptIn = 2,
    DEPPolicyOptOut = 3,
    DEPTotalPolicyCount = 4,
};
pub const DEPPolicyAlwaysOff = DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOff;
pub const DEPPolicyAlwaysOn = DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOn;
pub const DEPPolicyOptIn = DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptIn;
pub const DEPPolicyOptOut = DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptOut;
pub const DEPTotalPolicyCount = DEP_SYSTEM_POLICY_TYPE.DEPTotalPolicyCount;

pub const PROC_THREAD_ATTRIBUTE_NUM = extern enum(i32) {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeHandleList = 2,
    ProcThreadAttributeGroupAffinity = 3,
    ProcThreadAttributePreferredNode = 4,
    ProcThreadAttributeIdealProcessor = 5,
    ProcThreadAttributeUmsThread = 6,
    ProcThreadAttributeMitigationPolicy = 7,
    ProcThreadAttributeSecurityCapabilities = 9,
    ProcThreadAttributeProtectionLevel = 11,
    ProcThreadAttributeJobList = 13,
    ProcThreadAttributeChildProcessPolicy = 14,
    ProcThreadAttributeAllApplicationPackagesPolicy = 15,
    ProcThreadAttributeWin32kFilter = 16,
    ProcThreadAttributeSafeOpenPromptOriginClaim = 17,
    ProcThreadAttributeDesktopAppPolicy = 18,
    ProcThreadAttributePseudoConsole = 22,
};
pub const ProcThreadAttributeParentProcess = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeParentProcess;
pub const ProcThreadAttributeHandleList = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeHandleList;
pub const ProcThreadAttributeGroupAffinity = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeGroupAffinity;
pub const ProcThreadAttributePreferredNode = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePreferredNode;
pub const ProcThreadAttributeIdealProcessor = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeIdealProcessor;
pub const ProcThreadAttributeUmsThread = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeUmsThread;
pub const ProcThreadAttributeMitigationPolicy = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeMitigationPolicy;
pub const ProcThreadAttributeSecurityCapabilities = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSecurityCapabilities;
pub const ProcThreadAttributeProtectionLevel = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeProtectionLevel;
pub const ProcThreadAttributeJobList = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeJobList;
pub const ProcThreadAttributeChildProcessPolicy = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeChildProcessPolicy;
pub const ProcThreadAttributeAllApplicationPackagesPolicy = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeAllApplicationPackagesPolicy;
pub const ProcThreadAttributeWin32kFilter = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeWin32kFilter;
pub const ProcThreadAttributeSafeOpenPromptOriginClaim = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSafeOpenPromptOriginClaim;
pub const ProcThreadAttributeDesktopAppPolicy = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeDesktopAppPolicy;
pub const ProcThreadAttributePseudoConsole = PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePseudoConsole;

pub const PGET_SYSTEM_WOW64_DIRECTORY_A = fn(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PGET_SYSTEM_WOW64_DIRECTORY_W = fn(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const HW_PROFILE_INFOA = extern struct {
    dwDockInfo: u32,
    szHwProfileGuid: [39]i8,
    szHwProfileName: [80]i8,
};

pub const HW_PROFILE_INFOW = extern struct {
    dwDockInfo: u32,
    szHwProfileGuid: [39]u16,
    szHwProfileName: [80]u16,
};

pub const TIME_ZONE_INFORMATION = extern struct {
    Bias: i32,
    StandardName: [32]u16,
    StandardDate: SYSTEMTIME,
    StandardBias: i32,
    DaylightName: [32]u16,
    DaylightDate: SYSTEMTIME,
    DaylightBias: i32,
};

pub const DYNAMIC_TIME_ZONE_INFORMATION = extern struct {
    Bias: i32,
    StandardName: [32]u16,
    StandardDate: SYSTEMTIME,
    StandardBias: i32,
    DaylightName: [32]u16,
    DaylightDate: SYSTEMTIME,
    DaylightBias: i32,
    TimeZoneKeyName: [128]u16,
    DynamicDaylightTimeDisabled: u8,
};

pub const ACTCTX_SECTION_KEYED_DATA_2600 = extern struct {
    cbSize: u32,
    ulDataFormatVersion: u32,
    lpData: *c_void,
    ulLength: u32,
    lpSectionGlobalData: *c_void,
    ulSectionGlobalDataLength: u32,
    lpSectionBase: *c_void,
    ulSectionTotalLength: u32,
    hActCtx: HANDLE,
    ulAssemblyRosterIndex: u32,
};

pub const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = extern struct {
    lpInformation: *c_void,
    lpSectionBase: *c_void,
    ulSectionLength: u32,
    lpSectionGlobalDataBase: *c_void,
    ulSectionGlobalDataLength: u32,
};

pub const ACTIVATION_CONTEXT_BASIC_INFORMATION = extern struct {
    hActCtx: HANDLE,
    dwFlags: u32,
};

pub const PQUERYACTCTXW_FUNC = fn(
    dwFlags: u32,
    hActCtx: HANDLE,
    pvSubInstance: ?*c_void,
    ulInfoClass: u32,
    pvBuffer: ?[*]u8,
    cbBuffer: ?*c_void,
    pcbWrittenOrRequired: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const APPLICATION_RECOVERY_CALLBACK = fn(
    pvParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const FILE_CASE_SENSITIVE_INFO = extern struct {
    Flags: u32,
};

pub const FILE_DISPOSITION_INFO_EX = extern struct {
    Flags: u32,
};

pub const val_context = extern struct {
    valuelen: i32,
    value_context: *c_void,
    val_buff_ptr: *c_void,
};

pub const pvalueA = extern struct {
    pv_valuename: PSTR,
    pv_valuelen: i32,
    pv_value_context: *c_void,
    pv_type: u32,
};

pub const pvalueW = extern struct {
    pv_valuename: PWSTR,
    pv_valuelen: i32,
    pv_value_context: *c_void,
    pv_type: u32,
};

pub const QUERYHANDLER = fn(
    keycontext: *c_void,
    val_list: *val_context,
    num_vals: u32,
    outputbuffer: *c_void,
    total_outlen: *u32,
    input_blen: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PQUERYHANDLER = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const provider_info = extern struct {
    pi_R0_1val: PQUERYHANDLER,
    pi_R0_allvals: PQUERYHANDLER,
    pi_R3_1val: PQUERYHANDLER,
    pi_R3_allvals: PQUERYHANDLER,
    pi_flags: u32,
    pi_key_context: *c_void,
};

pub const VALENTA = extern struct {
    ve_valuename: PSTR,
    ve_valuelen: u32,
    ve_valueptr: ?*c_void,
    ve_type: u32,
};

pub const VALENTW = extern struct {
    ve_valuename: PWSTR,
    ve_valuelen: u32,
    ve_valueptr: ?*c_void,
    ve_type: u32,
};

const CLSID_DOMDocument_Value = @import("../zig.zig").Guid.initString("2933BF90-7B36-11D2-B20E-00C04F983E60");
pub const CLSID_DOMDocument = &CLSID_DOMDocument_Value;

const CLSID_DOMFreeThreadedDocument_Value = @import("../zig.zig").Guid.initString("2933BF91-7B36-11D2-B20E-00C04F983E60");
pub const CLSID_DOMFreeThreadedDocument = &CLSID_DOMFreeThreadedDocument_Value;

const CLSID_XMLHTTPRequest_Value = @import("../zig.zig").Guid.initString("ED8C108E-4349-11D2-91A4-00C04F7969E8");
pub const CLSID_XMLHTTPRequest = &CLSID_XMLHTTPRequest_Value;

const CLSID_XMLDSOControl_Value = @import("../zig.zig").Guid.initString("550DDA30-0541-11D2-9CA9-0060B0EC3D39");
pub const CLSID_XMLDSOControl = &CLSID_XMLDSOControl_Value;

const CLSID_XMLDocument_Value = @import("../zig.zig").Guid.initString("CFC399AF-D876-11D0-9C10-00C04FC99C8E");
pub const CLSID_XMLDocument = &CLSID_XMLDocument_Value;

pub const XML_ERROR = extern struct {
    _nLine: u32,
    _pchBuf: BSTR,
    _cchBuf: u32,
    _ich: u32,
    _pszFound: BSTR,
    _pszExpected: BSTR,
    _reserved1: u32,
    _reserved2: u32,
};

pub const DOMNodeType = extern enum(i32) {
    NODE_INVALID = 0,
    NODE_ELEMENT = 1,
    NODE_ATTRIBUTE = 2,
    NODE_TEXT = 3,
    NODE_CDATA_SECTION = 4,
    NODE_ENTITY_REFERENCE = 5,
    NODE_ENTITY = 6,
    NODE_PROCESSING_INSTRUCTION = 7,
    NODE_COMMENT = 8,
    NODE_DOCUMENT = 9,
    NODE_DOCUMENT_TYPE = 10,
    NODE_DOCUMENT_FRAGMENT = 11,
    NODE_NOTATION = 12,
};
pub const NODE_INVALID = DOMNodeType.NODE_INVALID;
pub const NODE_ELEMENT = DOMNodeType.NODE_ELEMENT;
pub const NODE_ATTRIBUTE = DOMNodeType.NODE_ATTRIBUTE;
pub const NODE_TEXT = DOMNodeType.NODE_TEXT;
pub const NODE_CDATA_SECTION = DOMNodeType.NODE_CDATA_SECTION;
pub const NODE_ENTITY_REFERENCE = DOMNodeType.NODE_ENTITY_REFERENCE;
pub const NODE_ENTITY = DOMNodeType.NODE_ENTITY;
pub const NODE_PROCESSING_INSTRUCTION = DOMNodeType.NODE_PROCESSING_INSTRUCTION;
pub const NODE_COMMENT = DOMNodeType.NODE_COMMENT;
pub const NODE_DOCUMENT = DOMNodeType.NODE_DOCUMENT;
pub const NODE_DOCUMENT_TYPE = DOMNodeType.NODE_DOCUMENT_TYPE;
pub const NODE_DOCUMENT_FRAGMENT = DOMNodeType.NODE_DOCUMENT_FRAGMENT;
pub const NODE_NOTATION = DOMNodeType.NODE_NOTATION;

pub const XMLEMEM_TYPE = extern enum(i32) {
    XMLELEMTYPE_ELEMENT = 0,
    XMLELEMTYPE_TEXT = 1,
    XMLELEMTYPE_COMMENT = 2,
    XMLELEMTYPE_DOCUMENT = 3,
    XMLELEMTYPE_DTD = 4,
    XMLELEMTYPE_PI = 5,
    XMLELEMTYPE_OTHER = 6,
};
pub const XMLELEMTYPE_ELEMENT = XMLEMEM_TYPE.XMLELEMTYPE_ELEMENT;
pub const XMLELEMTYPE_TEXT = XMLEMEM_TYPE.XMLELEMTYPE_TEXT;
pub const XMLELEMTYPE_COMMENT = XMLEMEM_TYPE.XMLELEMTYPE_COMMENT;
pub const XMLELEMTYPE_DOCUMENT = XMLEMEM_TYPE.XMLELEMTYPE_DOCUMENT;
pub const XMLELEMTYPE_DTD = XMLEMEM_TYPE.XMLELEMTYPE_DTD;
pub const XMLELEMTYPE_PI = XMLEMEM_TYPE.XMLELEMTYPE_PI;
pub const XMLELEMTYPE_OTHER = XMLEMEM_TYPE.XMLELEMTYPE_OTHER;

const IID_IXMLDOMImplementation_Value = @import("../zig.zig").Guid.initString("2933BF8F-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMImplementation = &IID_IXMLDOMImplementation_Value;
pub const IXMLDOMImplementation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        hasFeature: fn(
            self: *const IXMLDOMImplementation,
            feature: BSTR,
            version: BSTR,
            hasFeature: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMImplementation_hasFeature(self: *const T, feature: BSTR, version: BSTR, hasFeature: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMImplementation.VTable, self.vtable).hasFeature(@ptrCast(*const IXMLDOMImplementation, self), feature, version, hasFeature);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNode_Value = @import("../zig.zig").Guid.initString("2933BF80-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMNode = &IID_IXMLDOMNode_Value;
pub const IXMLDOMNode = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_nodeName: fn(
            self: *const IXMLDOMNode,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeValue: fn(
            self: *const IXMLDOMNode,
            value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_nodeValue: fn(
            self: *const IXMLDOMNode,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeType: fn(
            self: *const IXMLDOMNode,
            type: *DOMNodeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentNode: fn(
            self: *const IXMLDOMNode,
            parent: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_childNodes: fn(
            self: *const IXMLDOMNode,
            childList: **IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_firstChild: fn(
            self: *const IXMLDOMNode,
            firstChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lastChild: fn(
            self: *const IXMLDOMNode,
            lastChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_previousSibling: fn(
            self: *const IXMLDOMNode,
            previousSibling: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nextSibling: fn(
            self: *const IXMLDOMNode,
            nextSibling: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_attributes: fn(
            self: *const IXMLDOMNode,
            attributeMap: **IXMLDOMNamedNodeMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertBefore: fn(
            self: *const IXMLDOMNode,
            newChild: *IXMLDOMNode,
            refChild: VARIANT,
            outNewChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceChild: fn(
            self: *const IXMLDOMNode,
            newChild: *IXMLDOMNode,
            oldChild: *IXMLDOMNode,
            outOldChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IXMLDOMNode,
            childNode: *IXMLDOMNode,
            oldChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendChild: fn(
            self: *const IXMLDOMNode,
            newChild: *IXMLDOMNode,
            outNewChild: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasChildNodes: fn(
            self: *const IXMLDOMNode,
            hasChild: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ownerDocument: fn(
            self: *const IXMLDOMNode,
            XMLDOMDocument: **IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneNode: fn(
            self: *const IXMLDOMNode,
            deep: i16,
            cloneRoot: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeTypeString: fn(
            self: *const IXMLDOMNode,
            nodeType: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_text: fn(
            self: *const IXMLDOMNode,
            text: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_text: fn(
            self: *const IXMLDOMNode,
            text: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_specified: fn(
            self: *const IXMLDOMNode,
            isSpecified: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_definition: fn(
            self: *const IXMLDOMNode,
            definitionNode: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeTypedValue: fn(
            self: *const IXMLDOMNode,
            typedValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_nodeTypedValue: fn(
            self: *const IXMLDOMNode,
            typedValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dataType: fn(
            self: *const IXMLDOMNode,
            dataTypeName: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dataType: fn(
            self: *const IXMLDOMNode,
            dataTypeName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_xml: fn(
            self: *const IXMLDOMNode,
            xmlString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        transformNode: fn(
            self: *const IXMLDOMNode,
            stylesheet: *IXMLDOMNode,
            xmlString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectNodes: fn(
            self: *const IXMLDOMNode,
            queryString: BSTR,
            resultList: **IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectSingleNode: fn(
            self: *const IXMLDOMNode,
            queryString: BSTR,
            resultNode: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parsed: fn(
            self: *const IXMLDOMNode,
            isParsed: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_namespaceURI: fn(
            self: *const IXMLDOMNode,
            namespaceURI: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_prefix: fn(
            self: *const IXMLDOMNode,
            prefixString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseName: fn(
            self: *const IXMLDOMNode,
            nameString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        transformNodeToObject: fn(
            self: *const IXMLDOMNode,
            stylesheet: *IXMLDOMNode,
            outputObject: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeName(self: *const T, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeName(@ptrCast(*const IXMLDOMNode, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeValue(self: *const T, value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeValue(@ptrCast(*const IXMLDOMNode, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_nodeValue(self: *const T, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).put_nodeValue(@ptrCast(*const IXMLDOMNode, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeType(self: *const T, type: *DOMNodeType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeType(@ptrCast(*const IXMLDOMNode, self), type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_parentNode(self: *const T, parent: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_parentNode(@ptrCast(*const IXMLDOMNode, self), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_childNodes(self: *const T, childList: **IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_childNodes(@ptrCast(*const IXMLDOMNode, self), childList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_firstChild(self: *const T, firstChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_firstChild(@ptrCast(*const IXMLDOMNode, self), firstChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_lastChild(self: *const T, lastChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_lastChild(@ptrCast(*const IXMLDOMNode, self), lastChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_previousSibling(self: *const T, previousSibling: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_previousSibling(@ptrCast(*const IXMLDOMNode, self), previousSibling);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nextSibling(self: *const T, nextSibling: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nextSibling(@ptrCast(*const IXMLDOMNode, self), nextSibling);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_attributes(self: *const T, attributeMap: **IXMLDOMNamedNodeMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_attributes(@ptrCast(*const IXMLDOMNode, self), attributeMap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_insertBefore(self: *const T, newChild: *IXMLDOMNode, refChild: VARIANT, outNewChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).insertBefore(@ptrCast(*const IXMLDOMNode, self), newChild, refChild, outNewChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_replaceChild(self: *const T, newChild: *IXMLDOMNode, oldChild: *IXMLDOMNode, outOldChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).replaceChild(@ptrCast(*const IXMLDOMNode, self), newChild, oldChild, outOldChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_removeChild(self: *const T, childNode: *IXMLDOMNode, oldChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).removeChild(@ptrCast(*const IXMLDOMNode, self), childNode, oldChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_appendChild(self: *const T, newChild: *IXMLDOMNode, outNewChild: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).appendChild(@ptrCast(*const IXMLDOMNode, self), newChild, outNewChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_hasChildNodes(self: *const T, hasChild: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).hasChildNodes(@ptrCast(*const IXMLDOMNode, self), hasChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_ownerDocument(self: *const T, XMLDOMDocument: **IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_ownerDocument(@ptrCast(*const IXMLDOMNode, self), XMLDOMDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_cloneNode(self: *const T, deep: i16, cloneRoot: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).cloneNode(@ptrCast(*const IXMLDOMNode, self), deep, cloneRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeTypeString(self: *const T, nodeType: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeTypeString(@ptrCast(*const IXMLDOMNode, self), nodeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_text(self: *const T, text: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_text(@ptrCast(*const IXMLDOMNode, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_text(self: *const T, text: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).put_text(@ptrCast(*const IXMLDOMNode, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_specified(self: *const T, isSpecified: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_specified(@ptrCast(*const IXMLDOMNode, self), isSpecified);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_definition(self: *const T, definitionNode: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_definition(@ptrCast(*const IXMLDOMNode, self), definitionNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_nodeTypedValue(self: *const T, typedValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_nodeTypedValue(@ptrCast(*const IXMLDOMNode, self), typedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_nodeTypedValue(self: *const T, typedValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).put_nodeTypedValue(@ptrCast(*const IXMLDOMNode, self), typedValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_dataType(self: *const T, dataTypeName: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_dataType(@ptrCast(*const IXMLDOMNode, self), dataTypeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_put_dataType(self: *const T, dataTypeName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).put_dataType(@ptrCast(*const IXMLDOMNode, self), dataTypeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_xml(self: *const T, xmlString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_xml(@ptrCast(*const IXMLDOMNode, self), xmlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_transformNode(self: *const T, stylesheet: *IXMLDOMNode, xmlString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).transformNode(@ptrCast(*const IXMLDOMNode, self), stylesheet, xmlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_selectNodes(self: *const T, queryString: BSTR, resultList: **IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).selectNodes(@ptrCast(*const IXMLDOMNode, self), queryString, resultList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_selectSingleNode(self: *const T, queryString: BSTR, resultNode: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).selectSingleNode(@ptrCast(*const IXMLDOMNode, self), queryString, resultNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_parsed(self: *const T, isParsed: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_parsed(@ptrCast(*const IXMLDOMNode, self), isParsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_namespaceURI(self: *const T, namespaceURI: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_namespaceURI(@ptrCast(*const IXMLDOMNode, self), namespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_prefix(self: *const T, prefixString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_prefix(@ptrCast(*const IXMLDOMNode, self), prefixString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_get_baseName(self: *const T, nameString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).get_baseName(@ptrCast(*const IXMLDOMNode, self), nameString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNode_transformNodeToObject(self: *const T, stylesheet: *IXMLDOMNode, outputObject: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNode.VTable, self.vtable).transformNodeToObject(@ptrCast(*const IXMLDOMNode, self), stylesheet, outputObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocumentFragment_Value = @import("../zig.zig").Guid.initString("3EFAA413-272F-11D2-836F-0000F87A7782");
pub const IID_IXMLDOMDocumentFragment = &IID_IXMLDOMDocumentFragment_Value;
pub const IXMLDOMDocumentFragment = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocument_Value = @import("../zig.zig").Guid.initString("2933BF81-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMDocument = &IID_IXMLDOMDocument_Value;
pub const IXMLDOMDocument = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        get_doctype: fn(
            self: *const IXMLDOMDocument,
            documentType: **IXMLDOMDocumentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_implementation: fn(
            self: *const IXMLDOMDocument,
            impl: **IXMLDOMImplementation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_documentElement: fn(
            self: *const IXMLDOMDocument,
            DOMElement: **IXMLDOMElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_documentElement: fn(
            self: *const IXMLDOMDocument,
            DOMElement: *IXMLDOMElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IXMLDOMDocument,
            tagName: BSTR,
            element: **IXMLDOMElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createDocumentFragment: fn(
            self: *const IXMLDOMDocument,
            docFrag: **IXMLDOMDocumentFragment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextNode: fn(
            self: *const IXMLDOMDocument,
            data: BSTR,
            text: **IXMLDOMText,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createComment: fn(
            self: *const IXMLDOMDocument,
            data: BSTR,
            comment: **IXMLDOMComment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createCDATASection: fn(
            self: *const IXMLDOMDocument,
            data: BSTR,
            cdata: **IXMLDOMCDATASection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createProcessingInstruction: fn(
            self: *const IXMLDOMDocument,
            target: BSTR,
            data: BSTR,
            pi: **IXMLDOMProcessingInstruction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createAttribute: fn(
            self: *const IXMLDOMDocument,
            name: BSTR,
            attribute: **IXMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createEntityReference: fn(
            self: *const IXMLDOMDocument,
            name: BSTR,
            entityRef: **IXMLDOMEntityReference,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagName: fn(
            self: *const IXMLDOMDocument,
            tagName: BSTR,
            resultList: **IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createNode: fn(
            self: *const IXMLDOMDocument,
            Type: VARIANT,
            name: BSTR,
            namespaceURI: BSTR,
            node: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nodeFromID: fn(
            self: *const IXMLDOMDocument,
            idString: BSTR,
            node: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        load: fn(
            self: *const IXMLDOMDocument,
            xmlSource: VARIANT,
            isSuccessful: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IXMLDOMDocument,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parseError: fn(
            self: *const IXMLDOMDocument,
            errorObj: **IXMLDOMParseError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_url: fn(
            self: *const IXMLDOMDocument,
            urlString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_async: fn(
            self: *const IXMLDOMDocument,
            isAsync: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_async: fn(
            self: *const IXMLDOMDocument,
            isAsync: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        loadXML: fn(
            self: *const IXMLDOMDocument,
            bstrXML: BSTR,
            isSuccessful: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        save: fn(
            self: *const IXMLDOMDocument,
            destination: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_validateOnParse: fn(
            self: *const IXMLDOMDocument,
            isValidating: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_validateOnParse: fn(
            self: *const IXMLDOMDocument,
            isValidating: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_resolveExternals: fn(
            self: *const IXMLDOMDocument,
            isResolving: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_resolveExternals: fn(
            self: *const IXMLDOMDocument,
            isResolving: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_preserveWhiteSpace: fn(
            self: *const IXMLDOMDocument,
            isPreserving: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_preserveWhiteSpace: fn(
            self: *const IXMLDOMDocument,
            isPreserving: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IXMLDOMDocument,
            readystatechangeSink: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondataavailable: fn(
            self: *const IXMLDOMDocument,
            ondataavailableSink: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ontransformnode: fn(
            self: *const IXMLDOMDocument,
            ontransformnodeSink: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_doctype(self: *const T, documentType: **IXMLDOMDocumentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_doctype(@ptrCast(*const IXMLDOMDocument, self), documentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_implementation(self: *const T, impl: **IXMLDOMImplementation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_implementation(@ptrCast(*const IXMLDOMDocument, self), impl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_documentElement(self: *const T, DOMElement: **IXMLDOMElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_documentElement(@ptrCast(*const IXMLDOMDocument, self), DOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_putref_documentElement(self: *const T, DOMElement: *IXMLDOMElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).putref_documentElement(@ptrCast(*const IXMLDOMDocument, self), DOMElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createElement(self: *const T, tagName: BSTR, element: **IXMLDOMElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createElement(@ptrCast(*const IXMLDOMDocument, self), tagName, element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createDocumentFragment(self: *const T, docFrag: **IXMLDOMDocumentFragment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createDocumentFragment(@ptrCast(*const IXMLDOMDocument, self), docFrag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createTextNode(self: *const T, data: BSTR, text: **IXMLDOMText) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createTextNode(@ptrCast(*const IXMLDOMDocument, self), data, text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createComment(self: *const T, data: BSTR, comment: **IXMLDOMComment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createComment(@ptrCast(*const IXMLDOMDocument, self), data, comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createCDATASection(self: *const T, data: BSTR, cdata: **IXMLDOMCDATASection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createCDATASection(@ptrCast(*const IXMLDOMDocument, self), data, cdata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createProcessingInstruction(self: *const T, target: BSTR, data: BSTR, pi: **IXMLDOMProcessingInstruction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createProcessingInstruction(@ptrCast(*const IXMLDOMDocument, self), target, data, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createAttribute(self: *const T, name: BSTR, attribute: **IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createAttribute(@ptrCast(*const IXMLDOMDocument, self), name, attribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createEntityReference(self: *const T, name: BSTR, entityRef: **IXMLDOMEntityReference) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createEntityReference(@ptrCast(*const IXMLDOMDocument, self), name, entityRef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_getElementsByTagName(self: *const T, tagName: BSTR, resultList: **IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).getElementsByTagName(@ptrCast(*const IXMLDOMDocument, self), tagName, resultList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_createNode(self: *const T, Type: VARIANT, name: BSTR, namespaceURI: BSTR, node: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).createNode(@ptrCast(*const IXMLDOMDocument, self), Type, name, namespaceURI, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_nodeFromID(self: *const T, idString: BSTR, node: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).nodeFromID(@ptrCast(*const IXMLDOMDocument, self), idString, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_load(self: *const T, xmlSource: VARIANT, isSuccessful: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).load(@ptrCast(*const IXMLDOMDocument, self), xmlSource, isSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_readyState(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLDOMDocument, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_parseError(self: *const T, errorObj: **IXMLDOMParseError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_parseError(@ptrCast(*const IXMLDOMDocument, self), errorObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_url(self: *const T, urlString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_url(@ptrCast(*const IXMLDOMDocument, self), urlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_async(self: *const T, isAsync: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_async(@ptrCast(*const IXMLDOMDocument, self), isAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_async(self: *const T, isAsync: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_async(@ptrCast(*const IXMLDOMDocument, self), isAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).abort(@ptrCast(*const IXMLDOMDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_loadXML(self: *const T, bstrXML: BSTR, isSuccessful: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).loadXML(@ptrCast(*const IXMLDOMDocument, self), bstrXML, isSuccessful);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_save(self: *const T, destination: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).save(@ptrCast(*const IXMLDOMDocument, self), destination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_validateOnParse(self: *const T, isValidating: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_validateOnParse(@ptrCast(*const IXMLDOMDocument, self), isValidating);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_validateOnParse(self: *const T, isValidating: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_validateOnParse(@ptrCast(*const IXMLDOMDocument, self), isValidating);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_resolveExternals(self: *const T, isResolving: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_resolveExternals(@ptrCast(*const IXMLDOMDocument, self), isResolving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_resolveExternals(self: *const T, isResolving: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_resolveExternals(@ptrCast(*const IXMLDOMDocument, self), isResolving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_get_preserveWhiteSpace(self: *const T, isPreserving: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).get_preserveWhiteSpace(@ptrCast(*const IXMLDOMDocument, self), isPreserving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_preserveWhiteSpace(self: *const T, isPreserving: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_preserveWhiteSpace(@ptrCast(*const IXMLDOMDocument, self), isPreserving);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_onreadystatechange(self: *const T, readystatechangeSink: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IXMLDOMDocument, self), readystatechangeSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_ondataavailable(self: *const T, ondataavailableSink: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_ondataavailable(@ptrCast(*const IXMLDOMDocument, self), ondataavailableSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocument_put_ontransformnode(self: *const T, ontransformnodeSink: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocument.VTable, self.vtable).put_ontransformnode(@ptrCast(*const IXMLDOMDocument, self), ontransformnodeSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNodeList_Value = @import("../zig.zig").Guid.initString("2933BF82-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMNodeList = &IID_IXMLDOMNodeList_Value;
pub const IXMLDOMNodeList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_item: fn(
            self: *const IXMLDOMNodeList,
            index: i32,
            listItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IXMLDOMNodeList,
            listLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextNode: fn(
            self: *const IXMLDOMNodeList,
            nextItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IXMLDOMNodeList,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_get_item(self: *const T, index: i32, listItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).get_item(@ptrCast(*const IXMLDOMNodeList, self), index, listItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_get_length(self: *const T, listLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).get_length(@ptrCast(*const IXMLDOMNodeList, self), listLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_nextNode(self: *const T, nextItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).nextNode(@ptrCast(*const IXMLDOMNodeList, self), nextItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).reset(@ptrCast(*const IXMLDOMNodeList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNodeList_get__newEnum(self: *const T, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNodeList.VTable, self.vtable).get__newEnum(@ptrCast(*const IXMLDOMNodeList, self), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNamedNodeMap_Value = @import("../zig.zig").Guid.initString("2933BF83-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMNamedNodeMap = &IID_IXMLDOMNamedNodeMap_Value;
pub const IXMLDOMNamedNodeMap = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getNamedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            name: BSTR,
            namedItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            newItem: *IXMLDOMNode,
            nameItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            name: BSTR,
            namedItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_item: fn(
            self: *const IXMLDOMNamedNodeMap,
            index: i32,
            listItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IXMLDOMNamedNodeMap,
            listLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getQualifiedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            baseName: BSTR,
            namespaceURI: BSTR,
            qualifiedItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeQualifiedItem: fn(
            self: *const IXMLDOMNamedNodeMap,
            baseName: BSTR,
            namespaceURI: BSTR,
            qualifiedItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextNode: fn(
            self: *const IXMLDOMNamedNodeMap,
            nextItem: **IXMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IXMLDOMNamedNodeMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IXMLDOMNamedNodeMap,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_getNamedItem(self: *const T, name: BSTR, namedItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).getNamedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), name, namedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_setNamedItem(self: *const T, newItem: *IXMLDOMNode, nameItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).setNamedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), newItem, nameItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_removeNamedItem(self: *const T, name: BSTR, namedItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).removeNamedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), name, namedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_get_item(self: *const T, index: i32, listItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).get_item(@ptrCast(*const IXMLDOMNamedNodeMap, self), index, listItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_get_length(self: *const T, listLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).get_length(@ptrCast(*const IXMLDOMNamedNodeMap, self), listLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_getQualifiedItem(self: *const T, baseName: BSTR, namespaceURI: BSTR, qualifiedItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).getQualifiedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), baseName, namespaceURI, qualifiedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_removeQualifiedItem(self: *const T, baseName: BSTR, namespaceURI: BSTR, qualifiedItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).removeQualifiedItem(@ptrCast(*const IXMLDOMNamedNodeMap, self), baseName, namespaceURI, qualifiedItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_nextNode(self: *const T, nextItem: **IXMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).nextNode(@ptrCast(*const IXMLDOMNamedNodeMap, self), nextItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).reset(@ptrCast(*const IXMLDOMNamedNodeMap, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNamedNodeMap_get__newEnum(self: *const T, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNamedNodeMap.VTable, self.vtable).get__newEnum(@ptrCast(*const IXMLDOMNamedNodeMap, self), ppUnk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMCharacterData_Value = @import("../zig.zig").Guid.initString("2933BF84-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMCharacterData = &IID_IXMLDOMCharacterData_Value;
pub const IXMLDOMCharacterData = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        get_data: fn(
            self: *const IXMLDOMCharacterData,
            data: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_data: fn(
            self: *const IXMLDOMCharacterData,
            data: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IXMLDOMCharacterData,
            dataLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        substringData: fn(
            self: *const IXMLDOMCharacterData,
            offset: i32,
            count: i32,
            data: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendData: fn(
            self: *const IXMLDOMCharacterData,
            data: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IXMLDOMCharacterData,
            offset: i32,
            data: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IXMLDOMCharacterData,
            offset: i32,
            count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IXMLDOMCharacterData,
            offset: i32,
            count: i32,
            data: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_get_data(self: *const T, data: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).get_data(@ptrCast(*const IXMLDOMCharacterData, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_put_data(self: *const T, data: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).put_data(@ptrCast(*const IXMLDOMCharacterData, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_get_length(self: *const T, dataLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).get_length(@ptrCast(*const IXMLDOMCharacterData, self), dataLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_substringData(self: *const T, offset: i32, count: i32, data: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).substringData(@ptrCast(*const IXMLDOMCharacterData, self), offset, count, data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_appendData(self: *const T, data: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).appendData(@ptrCast(*const IXMLDOMCharacterData, self), data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_insertData(self: *const T, offset: i32, data: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).insertData(@ptrCast(*const IXMLDOMCharacterData, self), offset, data);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_deleteData(self: *const T, offset: i32, count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).deleteData(@ptrCast(*const IXMLDOMCharacterData, self), offset, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMCharacterData_replaceData(self: *const T, offset: i32, count: i32, data: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMCharacterData.VTable, self.vtable).replaceData(@ptrCast(*const IXMLDOMCharacterData, self), offset, count, data);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMAttribute_Value = @import("../zig.zig").Guid.initString("2933BF85-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMAttribute = &IID_IXMLDOMAttribute_Value;
pub const IXMLDOMAttribute = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        get_name: fn(
            self: *const IXMLDOMAttribute,
            attributeName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IXMLDOMAttribute,
            attributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IXMLDOMAttribute,
            attributeValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMAttribute_get_name(self: *const T, attributeName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMAttribute.VTable, self.vtable).get_name(@ptrCast(*const IXMLDOMAttribute, self), attributeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMAttribute_get_value(self: *const T, attributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMAttribute.VTable, self.vtable).get_value(@ptrCast(*const IXMLDOMAttribute, self), attributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMAttribute_put_value(self: *const T, attributeValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMAttribute.VTable, self.vtable).put_value(@ptrCast(*const IXMLDOMAttribute, self), attributeValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMElement_Value = @import("../zig.zig").Guid.initString("2933BF86-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMElement = &IID_IXMLDOMElement_Value;
pub const IXMLDOMElement = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        get_tagName: fn(
            self: *const IXMLDOMElement,
            tagName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IXMLDOMElement,
            name: BSTR,
            value: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IXMLDOMElement,
            name: BSTR,
            value: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IXMLDOMElement,
            name: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttributeNode: fn(
            self: *const IXMLDOMElement,
            name: BSTR,
            attributeNode: **IXMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNode: fn(
            self: *const IXMLDOMElement,
            DOMAttribute: *IXMLDOMAttribute,
            attributeNode: **IXMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNode: fn(
            self: *const IXMLDOMElement,
            DOMAttribute: *IXMLDOMAttribute,
            attributeNode: **IXMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagName: fn(
            self: *const IXMLDOMElement,
            tagName: BSTR,
            resultList: **IXMLDOMNodeList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IXMLDOMElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_get_tagName(self: *const T, tagName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).get_tagName(@ptrCast(*const IXMLDOMElement, self), tagName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_getAttribute(self: *const T, name: BSTR, value: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).getAttribute(@ptrCast(*const IXMLDOMElement, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_setAttribute(self: *const T, name: BSTR, value: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).setAttribute(@ptrCast(*const IXMLDOMElement, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_removeAttribute(self: *const T, name: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).removeAttribute(@ptrCast(*const IXMLDOMElement, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_getAttributeNode(self: *const T, name: BSTR, attributeNode: **IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).getAttributeNode(@ptrCast(*const IXMLDOMElement, self), name, attributeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_setAttributeNode(self: *const T, DOMAttribute: *IXMLDOMAttribute, attributeNode: **IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).setAttributeNode(@ptrCast(*const IXMLDOMElement, self), DOMAttribute, attributeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_removeAttributeNode(self: *const T, DOMAttribute: *IXMLDOMAttribute, attributeNode: **IXMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).removeAttributeNode(@ptrCast(*const IXMLDOMElement, self), DOMAttribute, attributeNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_getElementsByTagName(self: *const T, tagName: BSTR, resultList: **IXMLDOMNodeList) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).getElementsByTagName(@ptrCast(*const IXMLDOMElement, self), tagName, resultList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMElement_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMElement.VTable, self.vtable).normalize(@ptrCast(*const IXMLDOMElement, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMText_Value = @import("../zig.zig").Guid.initString("2933BF87-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMText = &IID_IXMLDOMText_Value;
pub const IXMLDOMText = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMCharacterData.VTable,
        splitText: fn(
            self: *const IXMLDOMText,
            offset: i32,
            rightHandTextNode: **IXMLDOMText,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMCharacterData.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMText_splitText(self: *const T, offset: i32, rightHandTextNode: **IXMLDOMText) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMText.VTable, self.vtable).splitText(@ptrCast(*const IXMLDOMText, self), offset, rightHandTextNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMComment_Value = @import("../zig.zig").Guid.initString("2933BF88-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMComment = &IID_IXMLDOMComment_Value;
pub const IXMLDOMComment = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMCharacterData.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMCharacterData.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMProcessingInstruction_Value = @import("../zig.zig").Guid.initString("2933BF89-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMProcessingInstruction = &IID_IXMLDOMProcessingInstruction_Value;
pub const IXMLDOMProcessingInstruction = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        get_target: fn(
            self: *const IXMLDOMProcessingInstruction,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_data: fn(
            self: *const IXMLDOMProcessingInstruction,
            value: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_data: fn(
            self: *const IXMLDOMProcessingInstruction,
            value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMProcessingInstruction_get_target(self: *const T, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMProcessingInstruction.VTable, self.vtable).get_target(@ptrCast(*const IXMLDOMProcessingInstruction, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMProcessingInstruction_get_data(self: *const T, value: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMProcessingInstruction.VTable, self.vtable).get_data(@ptrCast(*const IXMLDOMProcessingInstruction, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMProcessingInstruction_put_data(self: *const T, value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMProcessingInstruction.VTable, self.vtable).put_data(@ptrCast(*const IXMLDOMProcessingInstruction, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMCDATASection_Value = @import("../zig.zig").Guid.initString("2933BF8A-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMCDATASection = &IID_IXMLDOMCDATASection_Value;
pub const IXMLDOMCDATASection = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMText.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMText.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMDocumentType_Value = @import("../zig.zig").Guid.initString("2933BF8B-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMDocumentType = &IID_IXMLDOMDocumentType_Value;
pub const IXMLDOMDocumentType = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        get_name: fn(
            self: *const IXMLDOMDocumentType,
            rootName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_entities: fn(
            self: *const IXMLDOMDocumentType,
            entityMap: **IXMLDOMNamedNodeMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_notations: fn(
            self: *const IXMLDOMDocumentType,
            notationMap: **IXMLDOMNamedNodeMap,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocumentType_get_name(self: *const T, rootName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocumentType.VTable, self.vtable).get_name(@ptrCast(*const IXMLDOMDocumentType, self), rootName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocumentType_get_entities(self: *const T, entityMap: **IXMLDOMNamedNodeMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocumentType.VTable, self.vtable).get_entities(@ptrCast(*const IXMLDOMDocumentType, self), entityMap);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMDocumentType_get_notations(self: *const T, notationMap: **IXMLDOMNamedNodeMap) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMDocumentType.VTable, self.vtable).get_notations(@ptrCast(*const IXMLDOMDocumentType, self), notationMap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMNotation_Value = @import("../zig.zig").Guid.initString("2933BF8C-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMNotation = &IID_IXMLDOMNotation_Value;
pub const IXMLDOMNotation = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        get_publicId: fn(
            self: *const IXMLDOMNotation,
            publicID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_systemId: fn(
            self: *const IXMLDOMNotation,
            systemID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNotation_get_publicId(self: *const T, publicID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNotation.VTable, self.vtable).get_publicId(@ptrCast(*const IXMLDOMNotation, self), publicID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMNotation_get_systemId(self: *const T, systemID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMNotation.VTable, self.vtable).get_systemId(@ptrCast(*const IXMLDOMNotation, self), systemID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMEntity_Value = @import("../zig.zig").Guid.initString("2933BF8D-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMEntity = &IID_IXMLDOMEntity_Value;
pub const IXMLDOMEntity = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        get_publicId: fn(
            self: *const IXMLDOMEntity,
            publicID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_systemId: fn(
            self: *const IXMLDOMEntity,
            systemID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_notationName: fn(
            self: *const IXMLDOMEntity,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMEntity_get_publicId(self: *const T, publicID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMEntity.VTable, self.vtable).get_publicId(@ptrCast(*const IXMLDOMEntity, self), publicID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMEntity_get_systemId(self: *const T, systemID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMEntity.VTable, self.vtable).get_systemId(@ptrCast(*const IXMLDOMEntity, self), systemID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMEntity_get_notationName(self: *const T, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMEntity.VTable, self.vtable).get_notationName(@ptrCast(*const IXMLDOMEntity, self), name);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMEntityReference_Value = @import("../zig.zig").Guid.initString("2933BF8E-7B36-11D2-B20E-00C04F983E60");
pub const IID_IXMLDOMEntityReference = &IID_IXMLDOMEntityReference_Value;
pub const IXMLDOMEntityReference = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDOMParseError_Value = @import("../zig.zig").Guid.initString("3EFAA426-272F-11D2-836F-0000F87A7782");
pub const IID_IXMLDOMParseError = &IID_IXMLDOMParseError_Value;
pub const IXMLDOMParseError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_errorCode: fn(
            self: *const IXMLDOMParseError,
            errorCode: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_url: fn(
            self: *const IXMLDOMParseError,
            urlString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_reason: fn(
            self: *const IXMLDOMParseError,
            reasonString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_srcText: fn(
            self: *const IXMLDOMParseError,
            sourceString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_line: fn(
            self: *const IXMLDOMParseError,
            lineNumber: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_linepos: fn(
            self: *const IXMLDOMParseError,
            linePosition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_filepos: fn(
            self: *const IXMLDOMParseError,
            filePosition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_errorCode(self: *const T, errorCode: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_errorCode(@ptrCast(*const IXMLDOMParseError, self), errorCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_url(self: *const T, urlString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_url(@ptrCast(*const IXMLDOMParseError, self), urlString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_reason(self: *const T, reasonString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_reason(@ptrCast(*const IXMLDOMParseError, self), reasonString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_srcText(self: *const T, sourceString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_srcText(@ptrCast(*const IXMLDOMParseError, self), sourceString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_line(self: *const T, lineNumber: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_line(@ptrCast(*const IXMLDOMParseError, self), lineNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_linepos(self: *const T, linePosition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_linepos(@ptrCast(*const IXMLDOMParseError, self), linePosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDOMParseError_get_filepos(self: *const T, filePosition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDOMParseError.VTable, self.vtable).get_filepos(@ptrCast(*const IXMLDOMParseError, self), filePosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXTLRuntime_Value = @import("../zig.zig").Guid.initString("3EFAA425-272F-11D2-836F-0000F87A7782");
pub const IID_IXTLRuntime = &IID_IXTLRuntime_Value;
pub const IXTLRuntime = extern struct {
    pub const VTable = extern struct {
        base: IXMLDOMNode.VTable,
        uniqueID: fn(
            self: *const IXTLRuntime,
            pNode: *IXMLDOMNode,
            pID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        depth: fn(
            self: *const IXTLRuntime,
            pNode: *IXMLDOMNode,
            pDepth: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        childNumber: fn(
            self: *const IXTLRuntime,
            pNode: *IXMLDOMNode,
            pNumber: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ancestorChildNumber: fn(
            self: *const IXTLRuntime,
            bstrNodeName: BSTR,
            pNode: *IXMLDOMNode,
            pNumber: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        absoluteChildNumber: fn(
            self: *const IXTLRuntime,
            pNode: *IXMLDOMNode,
            pNumber: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        formatIndex: fn(
            self: *const IXTLRuntime,
            lIndex: i32,
            bstrFormat: BSTR,
            pbstrFormattedString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        formatNumber: fn(
            self: *const IXTLRuntime,
            dblNumber: f64,
            bstrFormat: BSTR,
            pbstrFormattedString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        formatDate: fn(
            self: *const IXTLRuntime,
            varDate: VARIANT,
            bstrFormat: BSTR,
            varDestLocale: VARIANT,
            pbstrFormattedString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        formatTime: fn(
            self: *const IXTLRuntime,
            varTime: VARIANT,
            bstrFormat: BSTR,
            varDestLocale: VARIANT,
            pbstrFormattedString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IXMLDOMNode.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_uniqueID(self: *const T, pNode: *IXMLDOMNode, pID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).uniqueID(@ptrCast(*const IXTLRuntime, self), pNode, pID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_depth(self: *const T, pNode: *IXMLDOMNode, pDepth: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).depth(@ptrCast(*const IXTLRuntime, self), pNode, pDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_childNumber(self: *const T, pNode: *IXMLDOMNode, pNumber: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).childNumber(@ptrCast(*const IXTLRuntime, self), pNode, pNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_ancestorChildNumber(self: *const T, bstrNodeName: BSTR, pNode: *IXMLDOMNode, pNumber: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).ancestorChildNumber(@ptrCast(*const IXTLRuntime, self), bstrNodeName, pNode, pNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_absoluteChildNumber(self: *const T, pNode: *IXMLDOMNode, pNumber: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).absoluteChildNumber(@ptrCast(*const IXTLRuntime, self), pNode, pNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatIndex(self: *const T, lIndex: i32, bstrFormat: BSTR, pbstrFormattedString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).formatIndex(@ptrCast(*const IXTLRuntime, self), lIndex, bstrFormat, pbstrFormattedString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatNumber(self: *const T, dblNumber: f64, bstrFormat: BSTR, pbstrFormattedString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).formatNumber(@ptrCast(*const IXTLRuntime, self), dblNumber, bstrFormat, pbstrFormattedString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatDate(self: *const T, varDate: VARIANT, bstrFormat: BSTR, varDestLocale: VARIANT, pbstrFormattedString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).formatDate(@ptrCast(*const IXTLRuntime, self), varDate, bstrFormat, varDestLocale, pbstrFormattedString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXTLRuntime_formatTime(self: *const T, varTime: VARIANT, bstrFormat: BSTR, varDestLocale: VARIANT, pbstrFormattedString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXTLRuntime.VTable, self.vtable).formatTime(@ptrCast(*const IXTLRuntime, self), varTime, bstrFormat, varDestLocale, pbstrFormattedString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_XMLDOMDocumentEvents_Value = @import("../zig.zig").Guid.initString("3EFAA427-272F-11D2-836F-0000F87A7782");
pub const IID_XMLDOMDocumentEvents = &IID_XMLDOMDocumentEvents_Value;
pub const XMLDOMDocumentEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLHttpRequest_Value = @import("../zig.zig").Guid.initString("ED8C108D-4349-11D2-91A4-00C04F7969E8");
pub const IID_IXMLHttpRequest = &IID_IXMLHttpRequest_Value;
pub const IXMLHttpRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        open: fn(
            self: *const IXMLHttpRequest,
            bstrMethod: BSTR,
            bstrUrl: BSTR,
            varAsync: VARIANT,
            bstrUser: VARIANT,
            bstrPassword: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setRequestHeader: fn(
            self: *const IXMLHttpRequest,
            bstrHeader: BSTR,
            bstrValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getResponseHeader: fn(
            self: *const IXMLHttpRequest,
            bstrHeader: BSTR,
            pbstrValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAllResponseHeaders: fn(
            self: *const IXMLHttpRequest,
            pbstrHeaders: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        send: fn(
            self: *const IXMLHttpRequest,
            varBody: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IXMLHttpRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IXMLHttpRequest,
            plStatus: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_statusText: fn(
            self: *const IXMLHttpRequest,
            pbstrStatus: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_responseXML: fn(
            self: *const IXMLHttpRequest,
            ppBody: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_responseText: fn(
            self: *const IXMLHttpRequest,
            pbstrBody: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_responseBody: fn(
            self: *const IXMLHttpRequest,
            pvarBody: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_responseStream: fn(
            self: *const IXMLHttpRequest,
            pvarBody: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IXMLHttpRequest,
            plState: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IXMLHttpRequest,
            pReadyStateSink: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_open(self: *const T, bstrMethod: BSTR, bstrUrl: BSTR, varAsync: VARIANT, bstrUser: VARIANT, bstrPassword: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).open(@ptrCast(*const IXMLHttpRequest, self), bstrMethod, bstrUrl, varAsync, bstrUser, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_setRequestHeader(self: *const T, bstrHeader: BSTR, bstrValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).setRequestHeader(@ptrCast(*const IXMLHttpRequest, self), bstrHeader, bstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_getResponseHeader(self: *const T, bstrHeader: BSTR, pbstrValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).getResponseHeader(@ptrCast(*const IXMLHttpRequest, self), bstrHeader, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_getAllResponseHeaders(self: *const T, pbstrHeaders: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).getAllResponseHeaders(@ptrCast(*const IXMLHttpRequest, self), pbstrHeaders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_send(self: *const T, varBody: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).send(@ptrCast(*const IXMLHttpRequest, self), varBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).abort(@ptrCast(*const IXMLHttpRequest, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_status(self: *const T, plStatus: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_status(@ptrCast(*const IXMLHttpRequest, self), plStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_statusText(self: *const T, pbstrStatus: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_statusText(@ptrCast(*const IXMLHttpRequest, self), pbstrStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseXML(self: *const T, ppBody: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_responseXML(@ptrCast(*const IXMLHttpRequest, self), ppBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseText(self: *const T, pbstrBody: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_responseText(@ptrCast(*const IXMLHttpRequest, self), pbstrBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseBody(self: *const T, pvarBody: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_responseBody(@ptrCast(*const IXMLHttpRequest, self), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_responseStream(self: *const T, pvarBody: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_responseStream(@ptrCast(*const IXMLHttpRequest, self), pvarBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_get_readyState(self: *const T, plState: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLHttpRequest, self), plState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLHttpRequest_put_onreadystatechange(self: *const T, pReadyStateSink: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLHttpRequest.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IXMLHttpRequest, self), pReadyStateSink);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDSOControl_Value = @import("../zig.zig").Guid.initString("310AFA62-0575-11D2-9CA9-0060B0EC3D39");
pub const IID_IXMLDSOControl = &IID_IXMLDSOControl_Value;
pub const IXMLDSOControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_XMLDocument: fn(
            self: *const IXMLDSOControl,
            ppDoc: **IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_XMLDocument: fn(
            self: *const IXMLDSOControl,
            ppDoc: *IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_JavaDSOCompatible: fn(
            self: *const IXMLDSOControl,
            fJavaDSOCompatible: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_JavaDSOCompatible: fn(
            self: *const IXMLDSOControl,
            fJavaDSOCompatible: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IXMLDSOControl,
            state: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_get_XMLDocument(self: *const T, ppDoc: **IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).get_XMLDocument(@ptrCast(*const IXMLDSOControl, self), ppDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_put_XMLDocument(self: *const T, ppDoc: *IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).put_XMLDocument(@ptrCast(*const IXMLDSOControl, self), ppDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_get_JavaDSOCompatible(self: *const T, fJavaDSOCompatible: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).get_JavaDSOCompatible(@ptrCast(*const IXMLDSOControl, self), fJavaDSOCompatible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_put_JavaDSOCompatible(self: *const T, fJavaDSOCompatible: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).put_JavaDSOCompatible(@ptrCast(*const IXMLDSOControl, self), fJavaDSOCompatible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDSOControl_get_readyState(self: *const T, state: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDSOControl.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLDSOControl, self), state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLElementCollection_Value = @import("../zig.zig").Guid.initString("65725580-9B5D-11D0-9BFE-00C04FC99C8E");
pub const IID_IXMLElementCollection = &IID_IXMLElementCollection_Value;
pub const IXMLElementCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_length: fn(
            self: *const IXMLElementCollection,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IXMLElementCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IXMLElementCollection,
            ppUnk: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IXMLElementCollection,
            var1: VARIANT,
            var2: VARIANT,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElementCollection.VTable, self.vtable).put_length(@ptrCast(*const IXMLElementCollection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElementCollection.VTable, self.vtable).get_length(@ptrCast(*const IXMLElementCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_get__newEnum(self: *const T, ppUnk: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElementCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IXMLElementCollection, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElementCollection_item(self: *const T, var1: VARIANT, var2: VARIANT, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElementCollection.VTable, self.vtable).item(@ptrCast(*const IXMLElementCollection, self), var1, var2, ppDisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDocument_Value = @import("../zig.zig").Guid.initString("F52E2B61-18A1-11D1-B105-00805F49916B");
pub const IID_IXMLDocument = &IID_IXMLDocument_Value;
pub const IXMLDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_root: fn(
            self: *const IXMLDocument,
            p: **IXMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileSize: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileModifiedDate: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileUpdatedDate: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_URL: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_URL: fn(
            self: *const IXMLDocument,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_mimeType: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IXMLDocument,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_charset: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_charset: fn(
            self: *const IXMLDocument,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_version: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_doctype: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dtdURL: fn(
            self: *const IXMLDocument,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IXMLDocument,
            vType: VARIANT,
            var1: VARIANT,
            ppElem: **IXMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_root(self: *const T, p: **IXMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_root(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_fileSize(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_fileSize(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_fileModifiedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_fileModifiedDate(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_fileUpdatedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_fileUpdatedDate(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_URL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_URL(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_put_URL(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).put_URL(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_mimeType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_mimeType(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_readyState(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLDocument, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_charset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_charset(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_put_charset(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).put_charset(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_version(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_version(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_doctype(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_doctype(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_get_dtdURL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).get_dtdURL(@ptrCast(*const IXMLDocument, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument_createElement(self: *const T, vType: VARIANT, var1: VARIANT, ppElem: **IXMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument.VTable, self.vtable).createElement(@ptrCast(*const IXMLDocument, self), vType, var1, ppElem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLDocument2_Value = @import("../zig.zig").Guid.initString("2B8DE2FE-8D2D-11D1-B2FC-00C04FD915A9");
pub const IID_IXMLDocument2 = &IID_IXMLDocument2_Value;
pub const IXMLDocument2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_root: fn(
            self: *const IXMLDocument2,
            p: **IXMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileSize: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileModifiedDate: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileUpdatedDate: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_URL: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_URL: fn(
            self: *const IXMLDocument2,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_mimeType: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IXMLDocument2,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_charset: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_charset: fn(
            self: *const IXMLDocument2,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_version: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_doctype: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dtdURL: fn(
            self: *const IXMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IXMLDocument2,
            vType: VARIANT,
            var1: VARIANT,
            ppElem: **IXMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_async: fn(
            self: *const IXMLDocument2,
            pf: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_async: fn(
            self: *const IXMLDocument2,
            f: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_root(self: *const T, p: **IXMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_root(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_fileSize(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_fileSize(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_fileModifiedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_fileModifiedDate(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_fileUpdatedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_fileUpdatedDate(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_URL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_URL(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_put_URL(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).put_URL(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_mimeType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_mimeType(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_readyState(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_readyState(@ptrCast(*const IXMLDocument2, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_charset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_charset(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_put_charset(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).put_charset(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_version(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_version(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_doctype(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_doctype(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_dtdURL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_dtdURL(@ptrCast(*const IXMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_createElement(self: *const T, vType: VARIANT, var1: VARIANT, ppElem: **IXMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).createElement(@ptrCast(*const IXMLDocument2, self), vType, var1, ppElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_get_async(self: *const T, pf: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).get_async(@ptrCast(*const IXMLDocument2, self), pf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLDocument2_put_async(self: *const T, f: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLDocument2.VTable, self.vtable).put_async(@ptrCast(*const IXMLDocument2, self), f);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLElement_Value = @import("../zig.zig").Guid.initString("3F7F31AC-E15F-11D0-9C25-00C04FC99C8E");
pub const IID_IXMLElement = &IID_IXMLElement_Value;
pub const IXMLElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_tagName: fn(
            self: *const IXMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_tagName: fn(
            self: *const IXMLElement,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parent: fn(
            self: *const IXMLElement,
            ppParent: **IXMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IXMLElement,
            strPropertyName: BSTR,
            PropertyValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IXMLElement,
            strPropertyName: BSTR,
            PropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IXMLElement,
            strPropertyName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_children: fn(
            self: *const IXMLElement,
            pp: **IXMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IXMLElement,
            plType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_text: fn(
            self: *const IXMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_text: fn(
            self: *const IXMLElement,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addChild: fn(
            self: *const IXMLElement,
            pChildElem: *IXMLElement,
            lIndex: i32,
            lReserved: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IXMLElement,
            pChildElem: *IXMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_tagName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_tagName(@ptrCast(*const IXMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_put_tagName(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).put_tagName(@ptrCast(*const IXMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_parent(self: *const T, ppParent: **IXMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_parent(@ptrCast(*const IXMLElement, self), ppParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_setAttribute(self: *const T, strPropertyName: BSTR, PropertyValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).setAttribute(@ptrCast(*const IXMLElement, self), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_getAttribute(self: *const T, strPropertyName: BSTR, PropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).getAttribute(@ptrCast(*const IXMLElement, self), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_removeAttribute(self: *const T, strPropertyName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).removeAttribute(@ptrCast(*const IXMLElement, self), strPropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_children(self: *const T, pp: **IXMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_children(@ptrCast(*const IXMLElement, self), pp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_type(self: *const T, plType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_type(@ptrCast(*const IXMLElement, self), plType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_get_text(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).get_text(@ptrCast(*const IXMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_put_text(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).put_text(@ptrCast(*const IXMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_addChild(self: *const T, pChildElem: *IXMLElement, lIndex: i32, lReserved: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).addChild(@ptrCast(*const IXMLElement, self), pChildElem, lIndex, lReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement_removeChild(self: *const T, pChildElem: *IXMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement.VTable, self.vtable).removeChild(@ptrCast(*const IXMLElement, self), pChildElem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLElement2_Value = @import("../zig.zig").Guid.initString("2B8DE2FF-8D2D-11D1-B2FC-00C04FD915A9");
pub const IID_IXMLElement2 = &IID_IXMLElement2_Value;
pub const IXMLElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_tagName: fn(
            self: *const IXMLElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_tagName: fn(
            self: *const IXMLElement2,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parent: fn(
            self: *const IXMLElement2,
            ppParent: **IXMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IXMLElement2,
            strPropertyName: BSTR,
            PropertyValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IXMLElement2,
            strPropertyName: BSTR,
            PropertyValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IXMLElement2,
            strPropertyName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_children: fn(
            self: *const IXMLElement2,
            pp: **IXMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IXMLElement2,
            plType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_text: fn(
            self: *const IXMLElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_text: fn(
            self: *const IXMLElement2,
            p: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addChild: fn(
            self: *const IXMLElement2,
            pChildElem: *IXMLElement2,
            lIndex: i32,
            lReserved: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IXMLElement2,
            pChildElem: *IXMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_attributes: fn(
            self: *const IXMLElement2,
            pp: **IXMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_tagName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_tagName(@ptrCast(*const IXMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_put_tagName(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).put_tagName(@ptrCast(*const IXMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_parent(self: *const T, ppParent: **IXMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_parent(@ptrCast(*const IXMLElement2, self), ppParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_setAttribute(self: *const T, strPropertyName: BSTR, PropertyValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).setAttribute(@ptrCast(*const IXMLElement2, self), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_getAttribute(self: *const T, strPropertyName: BSTR, PropertyValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).getAttribute(@ptrCast(*const IXMLElement2, self), strPropertyName, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_removeAttribute(self: *const T, strPropertyName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).removeAttribute(@ptrCast(*const IXMLElement2, self), strPropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_children(self: *const T, pp: **IXMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_children(@ptrCast(*const IXMLElement2, self), pp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_type(self: *const T, plType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_type(@ptrCast(*const IXMLElement2, self), plType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_text(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_text(@ptrCast(*const IXMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_put_text(self: *const T, p: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).put_text(@ptrCast(*const IXMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_addChild(self: *const T, pChildElem: *IXMLElement2, lIndex: i32, lReserved: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).addChild(@ptrCast(*const IXMLElement2, self), pChildElem, lIndex, lReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_removeChild(self: *const T, pChildElem: *IXMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).removeChild(@ptrCast(*const IXMLElement2, self), pChildElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLElement2_get_attributes(self: *const T, pp: **IXMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLElement2.VTable, self.vtable).get_attributes(@ptrCast(*const IXMLElement2, self), pp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLAttribute_Value = @import("../zig.zig").Guid.initString("D4D4A0FC-3B73-11D1-B2B4-00C04FB92596");
pub const IID_IXMLAttribute = &IID_IXMLAttribute_Value;
pub const IXMLAttribute = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_name: fn(
            self: *const IXMLAttribute,
            n: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IXMLAttribute,
            v: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLAttribute_get_name(self: *const T, n: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLAttribute.VTable, self.vtable).get_name(@ptrCast(*const IXMLAttribute, self), n);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLAttribute_get_value(self: *const T, v: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLAttribute.VTable, self.vtable).get_value(@ptrCast(*const IXMLAttribute, self), v);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLError_Value = @import("../zig.zig").Guid.initString("948C5AD3-C58D-11D0-9C0B-00C04FC99C8E");
pub const IID_IXMLError = &IID_IXMLError_Value;
pub const IXMLError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetErrorInfo: fn(
            self: *const IXMLError,
            pErrorReturn: *XML_ERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLError_GetErrorInfo(self: *const T, pErrorReturn: *XML_ERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLError.VTable, self.vtable).GetErrorInfo(@ptrCast(*const IXMLError, self), pErrorReturn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CLIENT_ID = extern struct {
    UniqueProcess: HANDLE,
    UniqueThread: HANDLE,
};

pub const LDR_DATA_TABLE_ENTRY = extern struct {
    Reserved1: [2]*c_void,
    InMemoryOrderLinks: LIST_ENTRY,
    Reserved2: [2]*c_void,
    DllBase: *c_void,
    Reserved3: [2]*c_void,
    FullDllName: UNICODE_STRING,
    Reserved4: [8]u8,
    Reserved5: [3]*c_void,
    Anonymous: LDR_DATA_TABLE_ENTRY._Anonymous_e__Union,
    TimeDateStamp: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PPS_POST_PROCESS_INIT_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const OBJECT_ATTRIBUTES = extern struct {
    Length: u32,
    RootDirectory: HANDLE,
    ObjectName: *UNICODE_STRING,
    Attributes: u32,
    SecurityDescriptor: *c_void,
    SecurityQualityOfService: *c_void,
};

pub const IO_STATUS_BLOCK = extern struct {
    Anonymous: IO_STATUS_BLOCK._Anonymous_e__Union,
    Information: ?*c_void,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PIO_APC_ROUTINE = fn(
    ApcContext: *c_void,
    IoStatusBlock: *IO_STATUS_BLOCK,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PROCESS_BASIC_INFORMATION = extern struct {
    Reserved1: *c_void,
    PebBaseAddress: *PEB,
    Reserved2: [2]*c_void,
    UniqueProcessId: ?*c_void,
    Reserved3: *c_void,
};

pub const SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION = extern struct {
    IdleTime: LARGE_INTEGER,
    KernelTime: LARGE_INTEGER,
    UserTime: LARGE_INTEGER,
    Reserved1: [2]LARGE_INTEGER,
    Reserved2: u32,
};

pub const SYSTEM_PROCESS_INFORMATION = extern struct {
    NextEntryOffset: u32,
    NumberOfThreads: u32,
    Reserved1: [48]u8,
    ImageName: UNICODE_STRING,
    BasePriority: i32,
    UniqueProcessId: HANDLE,
    Reserved2: *c_void,
    HandleCount: u32,
    SessionId: u32,
    Reserved3: *c_void,
    PeakVirtualSize: ?*c_void,
    VirtualSize: ?*c_void,
    Reserved4: u32,
    PeakWorkingSetSize: ?*c_void,
    WorkingSetSize: ?*c_void,
    Reserved5: *c_void,
    QuotaPagedPoolUsage: ?*c_void,
    Reserved6: *c_void,
    QuotaNonPagedPoolUsage: ?*c_void,
    PagefileUsage: ?*c_void,
    PeakPagefileUsage: ?*c_void,
    PrivatePageCount: ?*c_void,
    Reserved7: [6]LARGE_INTEGER,
};

pub const SYSTEM_THREAD_INFORMATION = extern struct {
    Reserved1: [3]LARGE_INTEGER,
    Reserved2: u32,
    StartAddress: *c_void,
    ClientId: CLIENT_ID,
    Priority: i32,
    BasePriority: i32,
    Reserved3: u32,
    ThreadState: u32,
    WaitReason: u32,
};

pub const SYSTEM_REGISTRY_QUOTA_INFORMATION = extern struct {
    RegistryQuotaAllowed: u32,
    RegistryQuotaUsed: u32,
    Reserved1: *c_void,
};

pub const SYSTEM_BASIC_INFORMATION = extern struct {
    Reserved1: [24]u8,
    Reserved2: [4]*c_void,
    NumberOfProcessors: i8,
};

pub const SYSTEM_TIMEOFDAY_INFORMATION = extern struct {
    Reserved1: [48]u8,
};

pub const SYSTEM_PERFORMANCE_INFORMATION = extern struct {
    Reserved1: [312]u8,
};

pub const SYSTEM_EXCEPTION_INFORMATION = extern struct {
    Reserved1: [16]u8,
};

pub const SYSTEM_LOOKASIDE_INFORMATION = extern struct {
    Reserved1: [32]u8,
};

pub const SYSTEM_INTERRUPT_INFORMATION = extern struct {
    Reserved1: [24]u8,
};

pub const SYSTEM_POLICY_INFORMATION = extern struct {
    Reserved1: [2]*c_void,
    Reserved2: [3]u32,
};

pub const FILE_INFORMATION_CLASS = extern enum(i32) {
    FileDirectoryInformation = 1,
};
pub const FileDirectoryInformation = FILE_INFORMATION_CLASS.FileDirectoryInformation;

pub const PROCESSINFOCLASS = extern enum(i32) {
    ProcessBasicInformation = 0,
    ProcessDebugPort = 7,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessBreakOnTermination = 29,
};
pub const ProcessBasicInformation = PROCESSINFOCLASS.ProcessBasicInformation;
pub const ProcessDebugPort = PROCESSINFOCLASS.ProcessDebugPort;
pub const ProcessWow64Information = PROCESSINFOCLASS.ProcessWow64Information;
pub const ProcessImageFileName = PROCESSINFOCLASS.ProcessImageFileName;
pub const ProcessBreakOnTermination = PROCESSINFOCLASS.ProcessBreakOnTermination;

pub const THREADINFOCLASS = extern enum(i32) {
    ThreadIsIoPending = 16,
};
pub const ThreadIsIoPending = THREADINFOCLASS.ThreadIsIoPending;

pub const SYSTEM_CODEINTEGRITY_INFORMATION = extern struct {
    Length: u32,
    CodeIntegrityOptions: u32,
};

pub const SYSTEM_INFORMATION_CLASS = extern enum(i32) {
    SystemBasicInformation = 0,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemProcessInformation = 5,
    SystemProcessorPerformanceInformation = 8,
    SystemInterruptInformation = 23,
    SystemExceptionInformation = 33,
    SystemRegistryQuotaInformation = 37,
    SystemLookasideInformation = 45,
    SystemCodeIntegrityInformation = 103,
    SystemPolicyInformation = 134,
};
pub const SystemBasicInformation = SYSTEM_INFORMATION_CLASS.SystemBasicInformation;
pub const SystemPerformanceInformation = SYSTEM_INFORMATION_CLASS.SystemPerformanceInformation;
pub const SystemTimeOfDayInformation = SYSTEM_INFORMATION_CLASS.SystemTimeOfDayInformation;
pub const SystemProcessInformation = SYSTEM_INFORMATION_CLASS.SystemProcessInformation;
pub const SystemProcessorPerformanceInformation = SYSTEM_INFORMATION_CLASS.SystemProcessorPerformanceInformation;
pub const SystemInterruptInformation = SYSTEM_INFORMATION_CLASS.SystemInterruptInformation;
pub const SystemExceptionInformation = SYSTEM_INFORMATION_CLASS.SystemExceptionInformation;
pub const SystemRegistryQuotaInformation = SYSTEM_INFORMATION_CLASS.SystemRegistryQuotaInformation;
pub const SystemLookasideInformation = SYSTEM_INFORMATION_CLASS.SystemLookasideInformation;
pub const SystemCodeIntegrityInformation = SYSTEM_INFORMATION_CLASS.SystemCodeIntegrityInformation;
pub const SystemPolicyInformation = SYSTEM_INFORMATION_CLASS.SystemPolicyInformation;

pub const OBJECT_INFORMATION_CLASS = extern enum(i32) {
    ObjectBasicInformation = 0,
    ObjectTypeInformation = 2,
};
pub const ObjectBasicInformation = OBJECT_INFORMATION_CLASS.ObjectBasicInformation;
pub const ObjectTypeInformation = OBJECT_INFORMATION_CLASS.ObjectTypeInformation;

pub const PUBLIC_OBJECT_BASIC_INFORMATION = extern struct {
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
    Reserved: [10]u32,
};

pub const __PUBLIC_OBJECT_TYPE_INFORMATION = extern struct {
    TypeName: UNICODE_STRING,
    Reserved: [22]u32,
};

pub const KEY_VALUE_ENTRY = extern struct {
    ValueName: *UNICODE_STRING,
    DataLength: u32,
    DataOffset: u32,
    Type: u32,
};

pub const KEY_SET_INFORMATION_CLASS = extern enum(i32) {
    KeyWriteTimeInformation = 0,
    KeyWow64FlagsInformation = 1,
    KeyControlFlagsInformation = 2,
    KeySetVirtualizationInformation = 3,
    KeySetDebugInformation = 4,
    KeySetHandleTagsInformation = 5,
    MaxKeySetInfoClass = 6,
};
pub const KeyWriteTimeInformation = KEY_SET_INFORMATION_CLASS.KeyWriteTimeInformation;
pub const KeyWow64FlagsInformation = KEY_SET_INFORMATION_CLASS.KeyWow64FlagsInformation;
pub const KeyControlFlagsInformation = KEY_SET_INFORMATION_CLASS.KeyControlFlagsInformation;
pub const KeySetVirtualizationInformation = KEY_SET_INFORMATION_CLASS.KeySetVirtualizationInformation;
pub const KeySetDebugInformation = KEY_SET_INFORMATION_CLASS.KeySetDebugInformation;
pub const KeySetHandleTagsInformation = KEY_SET_INFORMATION_CLASS.KeySetHandleTagsInformation;
pub const MaxKeySetInfoClass = KEY_SET_INFORMATION_CLASS.MaxKeySetInfoClass;

pub const WINSTATIONINFOCLASS = extern enum(i32) {
    WinStationInformation = 8,
};
pub const WinStationInformation = WINSTATIONINFOCLASS.WinStationInformation;

pub const WINSTATIONINFORMATIONW = extern struct {
    Reserved2: [70]u8,
    LogonId: u32,
    Reserved3: [1140]u8,
};

pub const PWINSTATIONQUERYINFORMATIONW = fn(
    param0: HANDLE,
    param1: u32,
    param2: WINSTATIONINFOCLASS,
    param3: *c_void,
    param4: u32,
    param5: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const AVRF_BACKTRACE_INFORMATION = extern struct {
    Depth: u32,
    Index: u32,
    ReturnAddresses: [32]u64,
};

pub const eUserAllocationState = extern enum(i32) {
    AllocationStateUnknown = 0,
    AllocationStateBusy = 1,
    AllocationStateFree = 2,
};
pub const AllocationStateUnknown = eUserAllocationState.AllocationStateUnknown;
pub const AllocationStateBusy = eUserAllocationState.AllocationStateBusy;
pub const AllocationStateFree = eUserAllocationState.AllocationStateFree;

pub const eHeapAllocationState = extern enum(i32) {
    HeapFullPageHeap = 1073741824,
    HeapMetadata = -2147483648,
    HeapStateMask = -65536,
};
pub const HeapFullPageHeap = eHeapAllocationState.HeapFullPageHeap;
pub const HeapMetadata = eHeapAllocationState.HeapMetadata;
pub const HeapStateMask = eHeapAllocationState.HeapStateMask;

pub const eHeapEnumerationLevel = extern enum(i32) {
    HeapEnumerationEverything = 0,
    HeapEnumerationStop = -1,
};
pub const HeapEnumerationEverything = eHeapEnumerationLevel.HeapEnumerationEverything;
pub const HeapEnumerationStop = eHeapEnumerationLevel.HeapEnumerationStop;

pub const AVRF_HEAP_ALLOCATION = extern struct {
    HeapHandle: u64,
    UserAllocation: u64,
    UserAllocationSize: u64,
    Allocation: u64,
    AllocationSize: u64,
    UserAllocationState: u32,
    HeapState: u32,
    HeapContext: u64,
    BackTraceInformation: *AVRF_BACKTRACE_INFORMATION,
};

pub const eHANDLE_TRACE_OPERATIONS = extern enum(i32) {
    OperationDbUnused = 0,
    OperationDbOPEN = 1,
    OperationDbCLOSE = 2,
    OperationDbBADREF = 3,
};
pub const OperationDbUnused = eHANDLE_TRACE_OPERATIONS.OperationDbUnused;
pub const OperationDbOPEN = eHANDLE_TRACE_OPERATIONS.OperationDbOPEN;
pub const OperationDbCLOSE = eHANDLE_TRACE_OPERATIONS.OperationDbCLOSE;
pub const OperationDbBADREF = eHANDLE_TRACE_OPERATIONS.OperationDbBADREF;

pub const AVRF_HANDLE_OPERATION = extern struct {
    Handle: u64,
    ProcessId: u32,
    ThreadId: u32,
    OperationType: u32,
    Spare0: u32,
    BackTraceInformation: AVRF_BACKTRACE_INFORMATION,
};

pub const eAvrfResourceTypes = extern enum(i32) {
    AvrfResourceHeapAllocation = 0,
    AvrfResourceHandleTrace = 1,
    AvrfResourceMax = 2,
};
pub const AvrfResourceHeapAllocation = eAvrfResourceTypes.AvrfResourceHeapAllocation;
pub const AvrfResourceHandleTrace = eAvrfResourceTypes.AvrfResourceHandleTrace;
pub const AvrfResourceMax = eAvrfResourceTypes.AvrfResourceMax;

pub const AVRF_RESOURCE_ENUMERATE_CALLBACK = fn(
    ResourceDescription: *c_void,
    EnumerationContext: *c_void,
    EnumerationLevel: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const AVRF_HEAPALLOCATION_ENUMERATE_CALLBACK = fn(
    HeapAllocation: *AVRF_HEAP_ALLOCATION,
    EnumerationContext: *c_void,
    EnumerationLevel: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const AVRF_HANDLEOPERATION_ENUMERATE_CALLBACK = fn(
    HandleOperation: *AVRF_HANDLE_OPERATION,
    EnumerationContext: *c_void,
    EnumerationLevel: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

const CLSID_CameraUIControl_Value = @import("../zig.zig").Guid.initString("16D5A2BE-B1C5-47B3-8EAE-CCBCF452C7E8");
pub const CLSID_CameraUIControl = &CLSID_CameraUIControl_Value;

pub const CameraUIControlMode = extern enum(i32) {
    Browse = 0,
    Linear = 1,
};
pub const Browse = CameraUIControlMode.Browse;
pub const Linear = CameraUIControlMode.Linear;

pub const CameraUIControlLinearSelectionMode = extern enum(i32) {
    Single = 0,
    Multiple = 1,
};
pub const Single = CameraUIControlLinearSelectionMode.Single;
pub const Multiple = CameraUIControlLinearSelectionMode.Multiple;

pub const CameraUIControlCaptureMode = extern enum(i32) {
    PhotoOrVideo = 0,
    Photo = 1,
    Video = 2,
};
pub const PhotoOrVideo = CameraUIControlCaptureMode.PhotoOrVideo;
pub const Photo = CameraUIControlCaptureMode.Photo;
pub const Video = CameraUIControlCaptureMode.Video;

pub const CameraUIControlPhotoFormat = extern enum(i32) {
    Jpeg = 0,
    Png = 1,
    JpegXR = 2,
};
pub const Jpeg = CameraUIControlPhotoFormat.Jpeg;
pub const Png = CameraUIControlPhotoFormat.Png;
pub const JpegXR = CameraUIControlPhotoFormat.JpegXR;

pub const CameraUIControlVideoFormat = extern enum(i32) {
    Mp4 = 0,
    Wmv = 1,
};
pub const Mp4 = CameraUIControlVideoFormat.Mp4;
pub const Wmv = CameraUIControlVideoFormat.Wmv;

pub const CameraUIControlViewType = extern enum(i32) {
    SingleItem = 0,
    ItemList = 1,
};
pub const SingleItem = CameraUIControlViewType.SingleItem;
pub const ItemList = CameraUIControlViewType.ItemList;

const IID_ICameraUIControlEventCallback_Value = @import("../zig.zig").Guid.initString("1BFA0C2C-FBCD-4776-BDA4-88BF974E74F4");
pub const IID_ICameraUIControlEventCallback = &IID_ICameraUIControlEventCallback_Value;
pub const ICameraUIControlEventCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStartupComplete: fn(
            self: *const ICameraUIControlEventCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnSuspendComplete: fn(
            self: *const ICameraUIControlEventCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnItemCaptured: fn(
            self: *const ICameraUIControlEventCallback,
            pszPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnItemDeleted: fn(
            self: *const ICameraUIControlEventCallback,
            pszPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) void,
        OnClosed: fn(
            self: *const ICameraUIControlEventCallback,
        ) callconv(@import("std").os.windows.WINAPI) void,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnStartupComplete(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnStartupComplete(@ptrCast(*const ICameraUIControlEventCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnSuspendComplete(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnSuspendComplete(@ptrCast(*const ICameraUIControlEventCallback, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnItemCaptured(self: *const T, pszPath: [*:0]const u16) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnItemCaptured(@ptrCast(*const ICameraUIControlEventCallback, self), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnItemDeleted(self: *const T, pszPath: [*:0]const u16) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnItemDeleted(@ptrCast(*const ICameraUIControlEventCallback, self), pszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControlEventCallback_OnClosed(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ICameraUIControlEventCallback.VTable, self.vtable).OnClosed(@ptrCast(*const ICameraUIControlEventCallback, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICameraUIControl_Value = @import("../zig.zig").Guid.initString("B8733ADF-3D68-4B8F-BB08-E28A0BED0376");
pub const IID_ICameraUIControl = &IID_ICameraUIControl_Value;
pub const ICameraUIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Show: fn(
            self: *const ICameraUIControl,
            pWindow: *IUnknown,
            mode: CameraUIControlMode,
            selectionMode: CameraUIControlLinearSelectionMode,
            captureMode: CameraUIControlCaptureMode,
            photoFormat: CameraUIControlPhotoFormat,
            videoFormat: CameraUIControlVideoFormat,
            bHasCloseButton: BOOL,
            pEventCallback: ?*ICameraUIControlEventCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const ICameraUIControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const ICameraUIControl,
            pbDeferralRequired: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const ICameraUIControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentViewType: fn(
            self: *const ICameraUIControl,
            pViewType: *CameraUIControlViewType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveItem: fn(
            self: *const ICameraUIControl,
            pbstrActiveItemPath: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectedItems: fn(
            self: *const ICameraUIControl,
            ppSelectedItemPaths: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveCapturedItem: fn(
            self: *const ICameraUIControl,
            pszPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Show(self: *const T, pWindow: *IUnknown, mode: CameraUIControlMode, selectionMode: CameraUIControlLinearSelectionMode, captureMode: CameraUIControlCaptureMode, photoFormat: CameraUIControlPhotoFormat, videoFormat: CameraUIControlVideoFormat, bHasCloseButton: BOOL, pEventCallback: ?*ICameraUIControlEventCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Show(@ptrCast(*const ICameraUIControl, self), pWindow, mode, selectionMode, captureMode, photoFormat, videoFormat, bHasCloseButton, pEventCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Close(@ptrCast(*const ICameraUIControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Suspend(self: *const T, pbDeferralRequired: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Suspend(@ptrCast(*const ICameraUIControl, self), pbDeferralRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_Resume(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).Resume(@ptrCast(*const ICameraUIControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_GetCurrentViewType(self: *const T, pViewType: *CameraUIControlViewType) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).GetCurrentViewType(@ptrCast(*const ICameraUIControl, self), pViewType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_GetActiveItem(self: *const T, pbstrActiveItemPath: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).GetActiveItem(@ptrCast(*const ICameraUIControl, self), pbstrActiveItemPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_GetSelectedItems(self: *const T, ppSelectedItemPaths: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).GetSelectedItems(@ptrCast(*const ICameraUIControl, self), ppSelectedItemPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICameraUIControl_RemoveCapturedItem(self: *const T, pszPath: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICameraUIControl.VTable, self.vtable).RemoveCapturedItem(@ptrCast(*const ICameraUIControl, self), pszPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ERF = extern struct {
    erfOper: i32,
    erfType: i32,
    fError: BOOL,
};

pub const FCIERROR = extern enum(i32) {
    FCIERR_NONE = 0,
    FCIERR_OPEN_SRC = 1,
    FCIERR_READ_SRC = 2,
    FCIERR_ALLOC_FAIL = 3,
    FCIERR_TEMP_FILE = 4,
    FCIERR_BAD_COMPR_TYPE = 5,
    FCIERR_CAB_FILE = 6,
    FCIERR_USER_ABORT = 7,
    FCIERR_MCI_FAIL = 8,
    FCIERR_CAB_FORMAT_LIMIT = 9,
};
pub const FCIERR_NONE = FCIERROR.FCIERR_NONE;
pub const FCIERR_OPEN_SRC = FCIERROR.FCIERR_OPEN_SRC;
pub const FCIERR_READ_SRC = FCIERROR.FCIERR_READ_SRC;
pub const FCIERR_ALLOC_FAIL = FCIERROR.FCIERR_ALLOC_FAIL;
pub const FCIERR_TEMP_FILE = FCIERROR.FCIERR_TEMP_FILE;
pub const FCIERR_BAD_COMPR_TYPE = FCIERROR.FCIERR_BAD_COMPR_TYPE;
pub const FCIERR_CAB_FILE = FCIERROR.FCIERR_CAB_FILE;
pub const FCIERR_USER_ABORT = FCIERROR.FCIERR_USER_ABORT;
pub const FCIERR_MCI_FAIL = FCIERROR.FCIERR_MCI_FAIL;
pub const FCIERR_CAB_FORMAT_LIMIT = FCIERROR.FCIERR_CAB_FORMAT_LIMIT;

pub const CCAB = extern struct {
    cb: u32,
    cbFolderThresh: u32,
    cbReserveCFHeader: u32,
    cbReserveCFFolder: u32,
    cbReserveCFData: u32,
    iCab: i32,
    iDisk: i32,
    fFailOnIncompressible: i32,
    setID: u16,
    szDisk: [256]i8,
    szCab: [256]i8,
    szCabPath: [256]i8,
};

pub const PFNFCIALLOC = fn(
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFNFCIFREE = fn(
    memory: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFNFCIOPEN = fn(
    pszFile: PSTR,
    oflag: i32,
    pmode: i32,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const PFNFCIREAD = fn(
    hf: ?*c_void,
    memory: *c_void,
    cb: u32,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNFCIWRITE = fn(
    hf: ?*c_void,
    memory: *c_void,
    cb: u32,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNFCICLOSE = fn(
    hf: ?*c_void,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCISEEK = fn(
    hf: ?*c_void,
    dist: i32,
    seektype: i32,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCIDELETE = fn(
    pszFile: PSTR,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCIGETNEXTCABINET = fn(
    pccab: *CCAB,
    cbPrevCab: u32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFNFCIFILEPLACED = fn(
    pccab: *CCAB,
    pszFile: PSTR,
    cbFile: i32,
    fContinuation: BOOL,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCIGETOPENINFO = fn(
    pszName: PSTR,
    pdate: *u16,
    ptime: *u16,
    pattribs: *u16,
    err: *i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const PFNFCISTATUS = fn(
    typeStatus: u32,
    cb1: u32,
    cb2: u32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFCIGETTEMPFILE = fn(
    pszTempName: [*]i8,
    cbTempName: i32,
    pv: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const FDIERROR = extern enum(i32) {
    NONE = 0,
    CABINET_NOT_FOUND = 1,
    NOT_A_CABINET = 2,
    UNKNOWN_CABINET_VERSION = 3,
    CORRUPT_CABINET = 4,
    ALLOC_FAIL = 5,
    BAD_COMPR_TYPE = 6,
    MDI_FAIL = 7,
    TARGET_FILE = 8,
    RESERVE_MISMATCH = 9,
    WRONG_CABINET = 10,
    USER_ABORT = 11,
    EOF = 12,
};
pub const FDIERROR_NONE = FDIERROR.NONE;
pub const FDIERROR_CABINET_NOT_FOUND = FDIERROR.CABINET_NOT_FOUND;
pub const FDIERROR_NOT_A_CABINET = FDIERROR.NOT_A_CABINET;
pub const FDIERROR_UNKNOWN_CABINET_VERSION = FDIERROR.UNKNOWN_CABINET_VERSION;
pub const FDIERROR_CORRUPT_CABINET = FDIERROR.CORRUPT_CABINET;
pub const FDIERROR_ALLOC_FAIL = FDIERROR.ALLOC_FAIL;
pub const FDIERROR_BAD_COMPR_TYPE = FDIERROR.BAD_COMPR_TYPE;
pub const FDIERROR_MDI_FAIL = FDIERROR.MDI_FAIL;
pub const FDIERROR_TARGET_FILE = FDIERROR.TARGET_FILE;
pub const FDIERROR_RESERVE_MISMATCH = FDIERROR.RESERVE_MISMATCH;
pub const FDIERROR_WRONG_CABINET = FDIERROR.WRONG_CABINET;
pub const FDIERROR_USER_ABORT = FDIERROR.USER_ABORT;
pub const FDIERROR_EOF = FDIERROR.EOF;

pub const FDICABINETINFO = extern struct {
    cbCabinet: i32,
    cFolders: u16,
    cFiles: u16,
    setID: u16,
    iCabinet: u16,
    fReserve: BOOL,
    hasprev: BOOL,
    hasnext: BOOL,
};

pub const FDIDECRYPTTYPE = extern enum(i32) {
    fdidtNEW_CABINET = 0,
    fdidtNEW_FOLDER = 1,
    fdidtDECRYPT = 2,
};
pub const fdidtNEW_CABINET = FDIDECRYPTTYPE.fdidtNEW_CABINET;
pub const fdidtNEW_FOLDER = FDIDECRYPTTYPE.fdidtNEW_FOLDER;
pub const fdidtDECRYPT = FDIDECRYPTTYPE.fdidtDECRYPT;

pub const FDIDECRYPT = extern struct {
    fdidt: FDIDECRYPTTYPE,
    pvUser: *c_void,
    Anonymous: FDIDECRYPT._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PFNALLOC = fn(
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFNFREE = fn(
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFNOPEN = fn(
    pszFile: PSTR,
    oflag: i32,
    pmode: i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const PFNREAD = fn(
    hf: ?*c_void,
    pv: [*]u8,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNWRITE = fn(
    hf: ?*c_void,
    pv: [*]u8,
    cb: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNCLOSE = fn(
    hf: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNSEEK = fn(
    hf: ?*c_void,
    dist: i32,
    seektype: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNFDIDECRYPT = fn(
    pfdid: *FDIDECRYPT,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const FDINOTIFICATION = extern struct {
    cb: i32,
    psz1: *i8,
    psz2: *i8,
    psz3: *i8,
    pv: *c_void,
    hf: ?*c_void,
    date: u16,
    time: u16,
    attribs: u16,
    setID: u16,
    iCabinet: u16,
    iFolder: u16,
    fdie: FDIERROR,
};

pub const FDINOTIFICATIONTYPE = extern enum(i32) {
    fdintCABINET_INFO = 0,
    fdintPARTIAL_FILE = 1,
    fdintCOPY_FILE = 2,
    fdintCLOSE_FILE_INFO = 3,
    fdintNEXT_CABINET = 4,
    fdintENUMERATE = 5,
};
pub const fdintCABINET_INFO = FDINOTIFICATIONTYPE.fdintCABINET_INFO;
pub const fdintPARTIAL_FILE = FDINOTIFICATIONTYPE.fdintPARTIAL_FILE;
pub const fdintCOPY_FILE = FDINOTIFICATIONTYPE.fdintCOPY_FILE;
pub const fdintCLOSE_FILE_INFO = FDINOTIFICATIONTYPE.fdintCLOSE_FILE_INFO;
pub const fdintNEXT_CABINET = FDINOTIFICATIONTYPE.fdintNEXT_CABINET;
pub const fdintENUMERATE = FDINOTIFICATIONTYPE.fdintENUMERATE;

pub const PFNFDINOTIFY = fn(
    fdint: FDINOTIFICATIONTYPE,
    pfdin: *FDINOTIFICATION,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const FDISPILLFILE = extern struct {
    ach: [2]i8,
    cbFile: i32,
};

pub const VDMCONTEXT_WITHOUT_XSAVE = extern struct {
    ContextFlags: u32,
    Dr0: u32,
    Dr1: u32,
    Dr2: u32,
    Dr3: u32,
    Dr6: u32,
    Dr7: u32,
    FloatSave: FLOATING_SAVE_AREA,
    SegGs: u32,
    SegFs: u32,
    SegEs: u32,
    SegDs: u32,
    Edi: u32,
    Esi: u32,
    Ebx: u32,
    Edx: u32,
    Ecx: u32,
    Eax: u32,
    Ebp: u32,
    Eip: u32,
    SegCs: u32,
    EFlags: u32,
    Esp: u32,
    SegSs: u32,
};

pub const SEGMENT_NOTE = extern struct {
    Selector1: u16,
    Selector2: u16,
    Segment: u16,
    Module: [10]i8,
    FileName: [256]i8,
    Type: u16,
    Length: u32,
};

pub const IMAGE_NOTE = extern struct {
    Module: [10]i8,
    FileName: [256]i8,
    hModule: u16,
    hTask: u16,
};

pub const MODULEENTRY = extern struct {
    dwSize: u32,
    szModule: [10]i8,
    hModule: HANDLE,
    wcUsage: u16,
    szExePath: [256]i8,
    wNext: u16,
};

pub const TEMP_BP_NOTE = extern struct {
    Seg: u16,
    Offset: u32,
    bPM: BOOL,
};

pub const VDM_SEGINFO = extern struct {
    Selector: u16,
    SegNumber: u16,
    Length: u32,
    Type: u16,
    ModuleName: [9]i8,
    FileName: [255]i8,
};

pub const GLOBALENTRY = extern struct {
    dwSize: u32,
    dwAddress: u32,
    dwBlockSize: u32,
    hBlock: HANDLE,
    wcLock: u16,
    wcPageLock: u16,
    wFlags: u16,
    wHeapPresent: BOOL,
    hOwner: HANDLE,
    wType: u16,
    wData: u16,
    dwNext: u32,
    dwNextAlt: u32,
};

pub const DEBUGEVENTPROC = fn(
    param0: *DEBUG_EVENT,
    param1: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PROCESSENUMPROC = fn(
    dwProcessId: u32,
    dwAttributes: u32,
    lpUserDefined: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TASKENUMPROC = fn(
    dwThreadId: u32,
    hMod16: u16,
    hTask16: u16,
    lpUserDefined: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const TASKENUMPROCEX = fn(
    dwThreadId: u32,
    hMod16: u16,
    hTask16: u16,
    pszModName: *i8,
    pszFileName: *i8,
    lpUserDefined: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMPROCESSEXCEPTIONPROC = fn(
    param0: *DEBUG_EVENT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETTHREADSELECTORENTRYPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: u32,
    param3: *LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETPOINTERPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: u16,
    param3: u32,
    param4: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const VDMGETCONTEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMSETCONTEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMKILLWOWPROC = fn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMDETECTWOWPROC = fn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMBREAKTHREADPROC = fn(
    param0: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETSELECTORMODULEPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: u16,
    param3: *u32,
    param4: PSTR,
    param5: u32,
    param6: PSTR,
    param7: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETMODULESELECTORPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: u32,
    param3: PSTR,
    param4: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMMODULEFIRSTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *MODULEENTRY,
    param3: DEBUGEVENTPROC,
    param4: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMMODULENEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *MODULEENTRY,
    param3: DEBUGEVENTPROC,
    param4: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGLOBALFIRSTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *GLOBALENTRY,
    param3: u16,
    param4: DEBUGEVENTPROC,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGLOBALNEXTPROC = fn(
    param0: HANDLE,
    param1: HANDLE,
    param2: *GLOBALENTRY,
    param3: u16,
    param4: DEBUGEVENTPROC,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMENUMPROCESSWOWPROC = fn(
    param0: PROCESSENUMPROC,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VDMENUMTASKWOWPROC = fn(
    param0: u32,
    param1: TASKENUMPROC,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VDMENUMTASKWOWEXPROC = fn(
    param0: u32,
    param1: TASKENUMPROCEX,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VDMTERMINATETASKINWOWPROC = fn(
    param0: u32,
    param1: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMSTARTTASKINWOWPROC = fn(
    param0: u32,
    param1: PSTR,
    param2: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETDBGFLAGSPROC = fn(
    param0: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const VDMSETDBGFLAGSPROC = fn(
    param0: HANDLE,
    param1: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMISMODULELOADEDPROC = fn(
    param0: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETSEGMENTINFOPROC = fn(
    param0: u16,
    param1: u32,
    param2: BOOL,
    param3: VDM_SEGINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETSYMBOLPROC = fn(
    param0: PSTR,
    param1: u16,
    param2: u32,
    param3: BOOL,
    param4: BOOL,
    param5: *[256]u8,
    param6: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const VDMGETADDREXPRESSIONPROC = fn(
    param0: PSTR,
    param1: PSTR,
    param2: *u16,
    param3: *u32,
    param4: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const CLSID_EditionUpgradeHelper_Value = @import("../zig.zig").Guid.initString("01776DF3-B9AF-4E50-9B1C-56E93116D704");
pub const CLSID_EditionUpgradeHelper = &CLSID_EditionUpgradeHelper_Value;

const CLSID_EditionUpgradeBroker_Value = @import("../zig.zig").Guid.initString("C4270827-4F39-45DF-9288-12FF6B85A921");
pub const CLSID_EditionUpgradeBroker = &CLSID_EditionUpgradeBroker_Value;

const IID_IEditionUpgradeHelper_Value = @import("../zig.zig").Guid.initString("D3E9E342-5DEB-43B6-849E-6913B85D503A");
pub const IID_IEditionUpgradeHelper = &IID_IEditionUpgradeHelper_Value;
pub const IEditionUpgradeHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanUpgrade: fn(
            self: *const IEditionUpgradeHelper,
            isAllowed: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateOperatingSystem: fn(
            self: *const IEditionUpgradeHelper,
            contentId: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowProductKeyUI: fn(
            self: *const IEditionUpgradeHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOsProductContentId: fn(
            self: *const IEditionUpgradeHelper,
            contentId: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenuineLocalStatus: fn(
            self: *const IEditionUpgradeHelper,
            isGenuine: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_CanUpgrade(self: *const T, isAllowed: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).CanUpgrade(@ptrCast(*const IEditionUpgradeHelper, self), isAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_UpdateOperatingSystem(self: *const T, contentId: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).UpdateOperatingSystem(@ptrCast(*const IEditionUpgradeHelper, self), contentId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_ShowProductKeyUI(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).ShowProductKeyUI(@ptrCast(*const IEditionUpgradeHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_GetOsProductContentId(self: *const T, contentId: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).GetOsProductContentId(@ptrCast(*const IEditionUpgradeHelper, self), contentId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeHelper_GetGenuineLocalStatus(self: *const T, isGenuine: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeHelper.VTable, self.vtable).GetGenuineLocalStatus(@ptrCast(*const IEditionUpgradeHelper, self), isGenuine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWindowsLockModeHelper_Value = @import("../zig.zig").Guid.initString("F342D19E-CC22-4648-BB5D-03CCF75B47C5");
pub const IID_IWindowsLockModeHelper = &IID_IWindowsLockModeHelper_Value;
pub const IWindowsLockModeHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSMode: fn(
            self: *const IWindowsLockModeHelper,
            isSmode: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWindowsLockModeHelper_GetSMode(self: *const T, isSmode: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWindowsLockModeHelper.VTable, self.vtable).GetSMode(@ptrCast(*const IWindowsLockModeHelper, self), isSmode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEditionUpgradeBroker_Value = @import("../zig.zig").Guid.initString("FF19CBCF-9455-4937-B872-6B7929A460AF");
pub const IID_IEditionUpgradeBroker = &IID_IEditionUpgradeBroker_Value;
pub const IEditionUpgradeBroker = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeParentWindow: fn(
            self: *const IEditionUpgradeBroker,
            parentHandle: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateOperatingSystem: fn(
            self: *const IEditionUpgradeBroker,
            parameter: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowProductKeyUI: fn(
            self: *const IEditionUpgradeBroker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanUpgrade: fn(
            self: *const IEditionUpgradeBroker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_InitializeParentWindow(self: *const T, parentHandle: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).InitializeParentWindow(@ptrCast(*const IEditionUpgradeBroker, self), parentHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_UpdateOperatingSystem(self: *const T, parameter: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).UpdateOperatingSystem(@ptrCast(*const IEditionUpgradeBroker, self), parameter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_ShowProductKeyUI(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).ShowProductKeyUI(@ptrCast(*const IEditionUpgradeBroker, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEditionUpgradeBroker_CanUpgrade(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEditionUpgradeBroker.VTable, self.vtable).CanUpgrade(@ptrCast(*const IEditionUpgradeBroker, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IContainerActivationHelper_Value = @import("../zig.zig").Guid.initString("B524F93F-80D5-4EC7-AE9E-D66E93ADE1FA");
pub const IID_IContainerActivationHelper = &IID_IContainerActivationHelper_Value;
pub const IContainerActivationHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CanActivateClientVM: fn(
            self: *const IContainerActivationHelper,
            isAllowed: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IContainerActivationHelper_CanActivateClientVM(self: *const T, isAllowed: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IContainerActivationHelper.VTable, self.vtable).CanActivateClientVM(@ptrCast(*const IContainerActivationHelper, self), isAllowed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IClipServiceNotificationHelper_Value = @import("../zig.zig").Guid.initString("C39948F0-6142-44FD-98CA-E1681A8D68B5");
pub const IID_IClipServiceNotificationHelper = &IID_IClipServiceNotificationHelper_Value;
pub const IClipServiceNotificationHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowToast: fn(
            self: *const IClipServiceNotificationHelper,
            titleText: BSTR,
            bodyText: BSTR,
            packageName: BSTR,
            appId: BSTR,
            launchCommand: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClipServiceNotificationHelper_ShowToast(self: *const T, titleText: BSTR, bodyText: BSTR, packageName: BSTR, appId: BSTR, launchCommand: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClipServiceNotificationHelper.VTable, self.vtable).ShowToast(@ptrCast(*const IClipServiceNotificationHelper, self), titleText, bodyText, packageName, appId, launchCommand);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FEATURE_CHANGE_TIME = extern enum(i32) {
    READ = 0,
    MODULE_RELOAD = 1,
    SESSION = 2,
    REBOOT = 3,
};
pub const FEATURE_CHANGE_TIME_READ = FEATURE_CHANGE_TIME.READ;
pub const FEATURE_CHANGE_TIME_MODULE_RELOAD = FEATURE_CHANGE_TIME.MODULE_RELOAD;
pub const FEATURE_CHANGE_TIME_SESSION = FEATURE_CHANGE_TIME.SESSION;
pub const FEATURE_CHANGE_TIME_REBOOT = FEATURE_CHANGE_TIME.REBOOT;

pub const FEATURE_ENABLED_STATE = extern enum(i32) {
    DEFAULT = 0,
    DISABLED = 1,
    ENABLED = 2,
};
pub const FEATURE_ENABLED_STATE_DEFAULT = FEATURE_ENABLED_STATE.DEFAULT;
pub const FEATURE_ENABLED_STATE_DISABLED = FEATURE_ENABLED_STATE.DISABLED;
pub const FEATURE_ENABLED_STATE_ENABLED = FEATURE_ENABLED_STATE.ENABLED;

pub const FEATURE_ERROR = extern struct {
    hr: HRESULT,
    lineNumber: u16,
    file: [*:0]const u8,
    process: [*:0]const u8,
    module: [*:0]const u8,
    callerReturnAddressOffset: u32,
    callerModule: [*:0]const u8,
    message: [*:0]const u8,
    originLineNumber: u16,
    originFile: [*:0]const u8,
    originModule: [*:0]const u8,
    originCallerReturnAddressOffset: u32,
    originCallerModule: [*:0]const u8,
    originName: [*:0]const u8,
};

pub const FEATURE_STATE_CHANGE_SUBSCRIPTION__ = extern struct {
    unused: i32,
};

pub const FEATURE_STATE_CHANGE_CALLBACK = fn(
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFEATURE_STATE_CHANGE_CALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_FhConfigMgr_Value = @import("../zig.zig").Guid.initString("ED43BB3C-09E9-498A-9DF6-2177244C6DB4");
pub const CLSID_FhConfigMgr = &CLSID_FhConfigMgr_Value;

const CLSID_FhReassociation_Value = @import("../zig.zig").Guid.initString("4D728E35-16FA-4320-9E8B-BFD7100A8846");
pub const CLSID_FhReassociation = &CLSID_FhReassociation_Value;

pub const FH_TARGET_PROPERTY_TYPE = extern enum(i32) {
    FH_TARGET_NAME = 0,
    FH_TARGET_URL = 1,
    FH_TARGET_DRIVE_TYPE = 2,
    MAX_TARGET_PROPERTY = 3,
};
pub const FH_TARGET_NAME = FH_TARGET_PROPERTY_TYPE.FH_TARGET_NAME;
pub const FH_TARGET_URL = FH_TARGET_PROPERTY_TYPE.FH_TARGET_URL;
pub const FH_TARGET_DRIVE_TYPE = FH_TARGET_PROPERTY_TYPE.FH_TARGET_DRIVE_TYPE;
pub const MAX_TARGET_PROPERTY = FH_TARGET_PROPERTY_TYPE.MAX_TARGET_PROPERTY;

pub const FH_TARGET_DRIVE_TYPES = extern enum(i32) {
    FH_DRIVE_UNKNOWN = 0,
    FH_DRIVE_REMOVABLE = 2,
    FH_DRIVE_FIXED = 3,
    FH_DRIVE_REMOTE = 4,
};
pub const FH_DRIVE_UNKNOWN = FH_TARGET_DRIVE_TYPES.FH_DRIVE_UNKNOWN;
pub const FH_DRIVE_REMOVABLE = FH_TARGET_DRIVE_TYPES.FH_DRIVE_REMOVABLE;
pub const FH_DRIVE_FIXED = FH_TARGET_DRIVE_TYPES.FH_DRIVE_FIXED;
pub const FH_DRIVE_REMOTE = FH_TARGET_DRIVE_TYPES.FH_DRIVE_REMOTE;

const IID_IFhTarget_Value = @import("../zig.zig").Guid.initString("D87965FD-2BAD-4657-BD3B-9567EB300CED");
pub const IID_IFhTarget = &IID_IFhTarget_Value;
pub const IFhTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringProperty: fn(
            self: *const IFhTarget,
            PropertyType: FH_TARGET_PROPERTY_TYPE,
            PropertyValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumericalProperty: fn(
            self: *const IFhTarget,
            PropertyType: FH_TARGET_PROPERTY_TYPE,
            PropertyValue: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhTarget_GetStringProperty(self: *const T, PropertyType: FH_TARGET_PROPERTY_TYPE, PropertyValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhTarget.VTable, self.vtable).GetStringProperty(@ptrCast(*const IFhTarget, self), PropertyType, PropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhTarget_GetNumericalProperty(self: *const T, PropertyType: FH_TARGET_PROPERTY_TYPE, PropertyValue: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhTarget.VTable, self.vtable).GetNumericalProperty(@ptrCast(*const IFhTarget, self), PropertyType, PropertyValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFhScopeIterator_Value = @import("../zig.zig").Guid.initString("3197ABCE-532A-44C6-8615-F3666566A720");
pub const IID_IFhScopeIterator = &IID_IFhScopeIterator_Value;
pub const IFhScopeIterator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveToNextItem: fn(
            self: *const IFhScopeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItem: fn(
            self: *const IFhScopeIterator,
            Item: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhScopeIterator_MoveToNextItem(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhScopeIterator.VTable, self.vtable).MoveToNextItem(@ptrCast(*const IFhScopeIterator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhScopeIterator_GetItem(self: *const T, Item: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhScopeIterator.VTable, self.vtable).GetItem(@ptrCast(*const IFhScopeIterator, self), Item);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FH_PROTECTED_ITEM_CATEGORY = extern enum(i32) {
    FH_FOLDER = 0,
    FH_LIBRARY = 1,
    MAX_PROTECTED_ITEM_CATEGORY = 2,
};
pub const FH_FOLDER = FH_PROTECTED_ITEM_CATEGORY.FH_FOLDER;
pub const FH_LIBRARY = FH_PROTECTED_ITEM_CATEGORY.FH_LIBRARY;
pub const MAX_PROTECTED_ITEM_CATEGORY = FH_PROTECTED_ITEM_CATEGORY.MAX_PROTECTED_ITEM_CATEGORY;

pub const FH_LOCAL_POLICY_TYPE = extern enum(i32) {
    FH_FREQUENCY = 0,
    FH_RETENTION_TYPE = 1,
    FH_RETENTION_AGE = 2,
    MAX_LOCAL_POLICY = 3,
};
pub const FH_FREQUENCY = FH_LOCAL_POLICY_TYPE.FH_FREQUENCY;
pub const FH_RETENTION_TYPE = FH_LOCAL_POLICY_TYPE.FH_RETENTION_TYPE;
pub const FH_RETENTION_AGE = FH_LOCAL_POLICY_TYPE.FH_RETENTION_AGE;
pub const MAX_LOCAL_POLICY = FH_LOCAL_POLICY_TYPE.MAX_LOCAL_POLICY;

pub const FH_RETENTION_TYPES = extern enum(i32) {
    FH_RETENTION_DISABLED = 0,
    FH_RETENTION_UNLIMITED = 1,
    FH_RETENTION_AGE_BASED = 2,
    MAX_RETENTION_TYPE = 3,
};
pub const FH_RETENTION_DISABLED = FH_RETENTION_TYPES.FH_RETENTION_DISABLED;
pub const FH_RETENTION_UNLIMITED = FH_RETENTION_TYPES.FH_RETENTION_UNLIMITED;
pub const FH_RETENTION_AGE_BASED = FH_RETENTION_TYPES.FH_RETENTION_AGE_BASED;
pub const MAX_RETENTION_TYPE = FH_RETENTION_TYPES.MAX_RETENTION_TYPE;

pub const FH_BACKUP_STATUS = extern enum(i32) {
    FH_STATUS_DISABLED = 0,
    FH_STATUS_DISABLED_BY_GP = 1,
    FH_STATUS_ENABLED = 2,
    FH_STATUS_REHYDRATING = 3,
    MAX_BACKUP_STATUS = 4,
};
pub const FH_STATUS_DISABLED = FH_BACKUP_STATUS.FH_STATUS_DISABLED;
pub const FH_STATUS_DISABLED_BY_GP = FH_BACKUP_STATUS.FH_STATUS_DISABLED_BY_GP;
pub const FH_STATUS_ENABLED = FH_BACKUP_STATUS.FH_STATUS_ENABLED;
pub const FH_STATUS_REHYDRATING = FH_BACKUP_STATUS.FH_STATUS_REHYDRATING;
pub const MAX_BACKUP_STATUS = FH_BACKUP_STATUS.MAX_BACKUP_STATUS;

pub const FH_DEVICE_VALIDATION_RESULT = extern enum(i32) {
    FH_ACCESS_DENIED = 0,
    FH_INVALID_DRIVE_TYPE = 1,
    FH_READ_ONLY_PERMISSION = 2,
    FH_CURRENT_DEFAULT = 3,
    FH_NAMESPACE_EXISTS = 4,
    FH_TARGET_PART_OF_LIBRARY = 5,
    FH_VALID_TARGET = 6,
    MAX_VALIDATION_RESULT = 7,
};
pub const FH_ACCESS_DENIED = FH_DEVICE_VALIDATION_RESULT.FH_ACCESS_DENIED;
pub const FH_INVALID_DRIVE_TYPE = FH_DEVICE_VALIDATION_RESULT.FH_INVALID_DRIVE_TYPE;
pub const FH_READ_ONLY_PERMISSION = FH_DEVICE_VALIDATION_RESULT.FH_READ_ONLY_PERMISSION;
pub const FH_CURRENT_DEFAULT = FH_DEVICE_VALIDATION_RESULT.FH_CURRENT_DEFAULT;
pub const FH_NAMESPACE_EXISTS = FH_DEVICE_VALIDATION_RESULT.FH_NAMESPACE_EXISTS;
pub const FH_TARGET_PART_OF_LIBRARY = FH_DEVICE_VALIDATION_RESULT.FH_TARGET_PART_OF_LIBRARY;
pub const FH_VALID_TARGET = FH_DEVICE_VALIDATION_RESULT.FH_VALID_TARGET;
pub const MAX_VALIDATION_RESULT = FH_DEVICE_VALIDATION_RESULT.MAX_VALIDATION_RESULT;

const IID_IFhConfigMgr_Value = @import("../zig.zig").Guid.initString("6A5FEA5B-BF8F-4EE5-B8C3-44D8A0D7331C");
pub const IID_IFhConfigMgr = &IID_IFhConfigMgr_Value;
pub const IFhConfigMgr = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LoadConfiguration: fn(
            self: *const IFhConfigMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDefaultConfiguration: fn(
            self: *const IFhConfigMgr,
            OverwriteIfExists: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveConfiguration: fn(
            self: *const IFhConfigMgr,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRemoveExcludeRule: fn(
            self: *const IFhConfigMgr,
            Add: BOOL,
            Category: FH_PROTECTED_ITEM_CATEGORY,
            Item: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIncludeExcludeRules: fn(
            self: *const IFhConfigMgr,
            Include: BOOL,
            Category: FH_PROTECTED_ITEM_CATEGORY,
            Iterator: **IFhScopeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalPolicy: fn(
            self: *const IFhConfigMgr,
            LocalPolicyType: FH_LOCAL_POLICY_TYPE,
            PolicyValue: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLocalPolicy: fn(
            self: *const IFhConfigMgr,
            LocalPolicyType: FH_LOCAL_POLICY_TYPE,
            PolicyValue: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupStatus: fn(
            self: *const IFhConfigMgr,
            BackupStatus: *FH_BACKUP_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupStatus: fn(
            self: *const IFhConfigMgr,
            BackupStatus: FH_BACKUP_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTarget: fn(
            self: *const IFhConfigMgr,
            DefaultTarget: **IFhTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateTarget: fn(
            self: *const IFhConfigMgr,
            TargetUrl: BSTR,
            ValidationResult: *FH_DEVICE_VALIDATION_RESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProvisionAndSetNewTarget: fn(
            self: *const IFhConfigMgr,
            TargetUrl: BSTR,
            TargetName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDefaultTargetRecommendation: fn(
            self: *const IFhConfigMgr,
            Recommend: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryProtectionStatus: fn(
            self: *const IFhConfigMgr,
            ProtectionState: *u32,
            ProtectedUntilTime: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_LoadConfiguration(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).LoadConfiguration(@ptrCast(*const IFhConfigMgr, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_CreateDefaultConfiguration(self: *const T, OverwriteIfExists: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).CreateDefaultConfiguration(@ptrCast(*const IFhConfigMgr, self), OverwriteIfExists);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_SaveConfiguration(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).SaveConfiguration(@ptrCast(*const IFhConfigMgr, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_AddRemoveExcludeRule(self: *const T, Add: BOOL, Category: FH_PROTECTED_ITEM_CATEGORY, Item: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).AddRemoveExcludeRule(@ptrCast(*const IFhConfigMgr, self), Add, Category, Item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_GetIncludeExcludeRules(self: *const T, Include: BOOL, Category: FH_PROTECTED_ITEM_CATEGORY, Iterator: **IFhScopeIterator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).GetIncludeExcludeRules(@ptrCast(*const IFhConfigMgr, self), Include, Category, Iterator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_GetLocalPolicy(self: *const T, LocalPolicyType: FH_LOCAL_POLICY_TYPE, PolicyValue: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).GetLocalPolicy(@ptrCast(*const IFhConfigMgr, self), LocalPolicyType, PolicyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_SetLocalPolicy(self: *const T, LocalPolicyType: FH_LOCAL_POLICY_TYPE, PolicyValue: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).SetLocalPolicy(@ptrCast(*const IFhConfigMgr, self), LocalPolicyType, PolicyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_GetBackupStatus(self: *const T, BackupStatus: *FH_BACKUP_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).GetBackupStatus(@ptrCast(*const IFhConfigMgr, self), BackupStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_SetBackupStatus(self: *const T, BackupStatus: FH_BACKUP_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).SetBackupStatus(@ptrCast(*const IFhConfigMgr, self), BackupStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_GetDefaultTarget(self: *const T, DefaultTarget: **IFhTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).GetDefaultTarget(@ptrCast(*const IFhConfigMgr, self), DefaultTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_ValidateTarget(self: *const T, TargetUrl: BSTR, ValidationResult: *FH_DEVICE_VALIDATION_RESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).ValidateTarget(@ptrCast(*const IFhConfigMgr, self), TargetUrl, ValidationResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_ProvisionAndSetNewTarget(self: *const T, TargetUrl: BSTR, TargetName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).ProvisionAndSetNewTarget(@ptrCast(*const IFhConfigMgr, self), TargetUrl, TargetName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_ChangeDefaultTargetRecommendation(self: *const T, Recommend: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).ChangeDefaultTargetRecommendation(@ptrCast(*const IFhConfigMgr, self), Recommend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhConfigMgr_QueryProtectionStatus(self: *const T, ProtectionState: *u32, ProtectedUntilTime: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhConfigMgr.VTable, self.vtable).QueryProtectionStatus(@ptrCast(*const IFhConfigMgr, self), ProtectionState, ProtectedUntilTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFhReassociation_Value = @import("../zig.zig").Guid.initString("6544A28A-F68D-47AC-91EF-16B2B36AA3EE");
pub const IID_IFhReassociation = &IID_IFhReassociation_Value;
pub const IFhReassociation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateTarget: fn(
            self: *const IFhReassociation,
            TargetUrl: BSTR,
            ValidationResult: *FH_DEVICE_VALIDATION_RESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScanTargetForConfigurations: fn(
            self: *const IFhReassociation,
            TargetUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConfigurationDetails: fn(
            self: *const IFhReassociation,
            Index: u32,
            UserName: *BSTR,
            PcName: *BSTR,
            BackupTime: *FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectConfiguration: fn(
            self: *const IFhReassociation,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PerformReassociation: fn(
            self: *const IFhReassociation,
            OverwriteIfExists: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_ValidateTarget(self: *const T, TargetUrl: BSTR, ValidationResult: *FH_DEVICE_VALIDATION_RESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).ValidateTarget(@ptrCast(*const IFhReassociation, self), TargetUrl, ValidationResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_ScanTargetForConfigurations(self: *const T, TargetUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).ScanTargetForConfigurations(@ptrCast(*const IFhReassociation, self), TargetUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_GetConfigurationDetails(self: *const T, Index: u32, UserName: *BSTR, PcName: *BSTR, BackupTime: *FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).GetConfigurationDetails(@ptrCast(*const IFhReassociation, self), Index, UserName, PcName, BackupTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_SelectConfiguration(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).SelectConfiguration(@ptrCast(*const IFhReassociation, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFhReassociation_PerformReassociation(self: *const T, OverwriteIfExists: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFhReassociation.VTable, self.vtable).PerformReassociation(@ptrCast(*const IFhReassociation, self), OverwriteIfExists);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const FhBackupStopReason = extern enum(i32) {
    BackupInvalidStopReason = 0,
    BackupLimitUserBusyMachineOnAC = 1,
    BackupLimitUserIdleMachineOnDC = 2,
    BackupLimitUserBusyMachineOnDC = 3,
    BackupCancelled = 4,
};
pub const BackupInvalidStopReason = FhBackupStopReason.BackupInvalidStopReason;
pub const BackupLimitUserBusyMachineOnAC = FhBackupStopReason.BackupLimitUserBusyMachineOnAC;
pub const BackupLimitUserIdleMachineOnDC = FhBackupStopReason.BackupLimitUserIdleMachineOnDC;
pub const BackupLimitUserBusyMachineOnDC = FhBackupStopReason.BackupLimitUserBusyMachineOnDC;
pub const BackupCancelled = FhBackupStopReason.BackupCancelled;

pub const FH_SERVICE_PIPE_HANDLE__ = extern struct {
    unused: i32,
};

pub const DCICMD = extern struct {
    dwCommand: u32,
    dwParam1: u32,
    dwParam2: u32,
    dwVersion: u32,
    dwReserved: u32,
};

pub const DCICREATEINPUT = extern struct {
    cmd: DCICMD,
    dwCompression: u32,
    dwMask: [3]u32,
    dwWidth: u32,
    dwHeight: u32,
    dwDCICaps: u32,
    dwBitCount: u32,
    lpSurface: *c_void,
};

pub const DCISURFACEINFO = extern struct {
    dwSize: u32,
    dwDCICaps: u32,
    dwCompression: u32,
    dwMask: [3]u32,
    dwWidth: u32,
    dwHeight: u32,
    lStride: i32,
    dwBitCount: u32,
    dwOffSurface: ?*c_void,
    wSelSurface: u16,
    wReserved: u16,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    BeginAccess: ?*c_void,
    EndAccess: ?*c_void,
    DestroySurface: ?*c_void,
};

pub const ENUM_CALLBACK = fn(
    lpSurfaceInfo: *DCISURFACEINFO,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const DCIENUMINPUT = extern struct {
    cmd: DCICMD,
    rSrc: RECT,
    rDst: RECT,
    EnumCallback: ?*c_void,
    lpContext: *c_void,
};

pub const DCIOFFSCREEN = extern struct {
    dciInfo: DCISURFACEINFO,
    Draw: ?*c_void,
    SetClipList: ?*c_void,
    SetDestination: ?*c_void,
};

pub const DCIOVERLAY = extern struct {
    dciInfo: DCISURFACEINFO,
    dwChromakeyValue: u32,
    dwChromakeyMask: u32,
};

pub const HWINWATCH__ = extern struct {
    unused: i32,
};

pub const WINWATCHNOTIFYPROC = fn(
    hww: *HWINWATCH__,
    hwnd: HWND,
    code: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_WaaSAssessor_Value = @import("../zig.zig").Guid.initString("098EF871-FA9F-46AF-8958-C083515D7C9C");
pub const CLSID_WaaSAssessor = &CLSID_WaaSAssessor_Value;

const IID_IWaaSAssessor_Value = @import("../zig.zig").Guid.initString("2347BBEF-1A3B-45A4-902D-3E09C269B45E");
pub const IID_IWaaSAssessor = &IID_IWaaSAssessor_Value;
pub const IWaaSAssessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetOSUpdateAssessment: fn(
            self: *const IWaaSAssessor,
            result: *OSUpdateAssessment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWaaSAssessor_GetOSUpdateAssessment(self: *const T, result: *OSUpdateAssessment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWaaSAssessor.VTable, self.vtable).GetOSUpdateAssessment(@ptrCast(*const IWaaSAssessor, self), result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VMEML = extern struct {
    next: *VMEML,
    ptr: ?*c_void,
    size: u32,
    bDiscardable: BOOL,
};

pub const VMEMR = extern struct {
    next: *VMEMR,
    prev: *VMEMR,
    pUp: *VMEMR,
    pDown: *VMEMR,
    pLeft: *VMEMR,
    pRight: *VMEMR,
    ptr: ?*c_void,
    size: u32,
    x: u32,
    y: u32,
    cx: u32,
    cy: u32,
    flags: u32,
    pBits: ?*c_void,
    bDiscardable: BOOL,
};

pub const PROCESS_LIST = extern struct {
    lpLink: *PROCESS_LIST,
    dwProcessId: u32,
    dwRefCnt: u32,
    dwAlphaDepth: u32,
    dwZDepth: u32,
};

pub const DDMONITORINFO = extern struct {
    Manufacturer: u16,
    Product: u16,
    SerialNumber: u32,
    DeviceIdentifier: Guid,
    Mode640x480: i32,
    Mode800x600: i32,
    Mode1024x768: i32,
    Mode1280x1024: i32,
    Mode1600x1200: i32,
    ModeReserved1: i32,
    ModeReserved2: i32,
    ModeReserved3: i32,
};

pub const IDirectDrawClipperVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawPaletteVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawSurfaceVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawSurface2Vtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawSurface3Vtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawSurface4Vtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawSurface7Vtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawColorControlVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDraw2Vtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDraw4Vtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDraw7Vtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawKernelVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawSurfaceKernelVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawGammaControlVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const DD32BITDRIVERDATA = extern struct {
    szName: [260]i8,
    szEntryPoint: [64]i8,
    dwContext: u32,
};

pub const DDVERSIONDATA = extern struct {
    dwHALVersion: u32,
    dwReserved1: ?*c_void,
    dwReserved2: ?*c_void,
};

pub const LPDD32BITDRIVERINIT = fn(
    dwContext: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const VIDMEM = extern struct {
    dwFlags: u32,
    fpStart: ?*c_void,
    Anonymous1: VIDMEM._Anonymous1_e__Union,
    ddsCaps: DDSCAPS,
    ddsCapsAlt: DDSCAPS,
    Anonymous2: VIDMEM._Anonymous2_e__Union,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const VIDMEMINFO = extern struct {
    fpPrimary: ?*c_void,
    dwFlags: u32,
    dwDisplayWidth: u32,
    dwDisplayHeight: u32,
    lDisplayPitch: i32,
    ddpfDisplay: DDPIXELFORMAT,
    dwOffscreenAlign: u32,
    dwOverlayAlign: u32,
    dwTextureAlign: u32,
    dwZBufferAlign: u32,
    dwAlphaAlign: u32,
    dwNumHeaps: u32,
    pvmList: *VIDMEM,
};

pub const HEAPALIAS = extern struct {
    fpVidMem: ?*c_void,
    lpAlias: *c_void,
    dwAliasSize: u32,
};

pub const HEAPALIASINFO = extern struct {
    dwRefCnt: u32,
    dwFlags: u32,
    dwNumHeaps: u32,
    lpAliases: *HEAPALIAS,
};

pub const IUNKNOWN_LIST = extern struct {
    lpLink: *IUNKNOWN_LIST,
    lpGuid: *Guid,
    lpIUnknown: *IUnknown,
};

pub const LPDDHEL_INIT = fn(
    param0: *DDRAWI_DIRECTDRAW_GBL,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPDDHAL_SETCOLORKEY = fn(
    param0: *DDHAL_DRVSETCOLORKEYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_CANCREATESURFACE = fn(
    param0: *DDHAL_CANCREATESURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const LPDDHAL_WAITFORVERTICALBLANK = fn() callconv(@import("std").os.windows.WINAPI) void;

pub const LPDDHAL_CREATESURFACE = fn(
    param0: *DDHAL_CREATESURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_DESTROYDRIVER = fn(
    param0: *DDHAL_DESTROYDRIVERDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_SETMODE = fn(
    param0: *DDHAL_SETMODEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_CREATEPALETTE = fn(
    param0: *DDHAL_CREATEPALETTEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_GETSCANLINE = fn(
    param0: *DDHAL_GETSCANLINEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_SETEXCLUSIVEMODE = fn(
    param0: *DDHAL_SETEXCLUSIVEMODEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_FLIPTOGDISURFACE = fn(
    param0: *DDHAL_FLIPTOGDISURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_GETDRIVERINFO = fn(
    param0: *DDHAL_GETDRIVERINFODATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    DestroyDriver: LPDDHAL_DESTROYDRIVER,
    CreateSurface: LPDDHAL_CREATESURFACE,
    SetColorKey: LPDDHAL_SETCOLORKEY,
    SetMode: LPDDHAL_SETMODE,
    WaitForVerticalBlank: LPDDHAL_WAITFORVERTICALBLANK,
    CanCreateSurface: LPDDHAL_CANCREATESURFACE,
    CreatePalette: LPDDHAL_CREATEPALETTE,
    GetScanLine: LPDDHAL_GETSCANLINE,
    SetExclusiveMode: LPDDHAL_SETEXCLUSIVEMODE,
    FlipToGDISurface: LPDDHAL_FLIPTOGDISURFACE,
};

pub const LPDDHALPALCB_DESTROYPALETTE = fn(
    param0: *DDHAL_DESTROYPALETTEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALPALCB_SETENTRIES = fn(
    param0: *DDHAL_SETENTRIESDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDPALETTECALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    DestroyPalette: LPDDHALPALCB_DESTROYPALETTE,
    SetEntries: LPDDHALPALCB_SETENTRIES,
};

pub const LPDDHALSURFCB_LOCK = fn(
    param0: *DDHAL_LOCKDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_UNLOCK = fn(
    param0: *DDHAL_UNLOCKDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_BLT = fn(
    param0: *DDHAL_BLTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_UPDATEOVERLAY = fn(
    param0: *DDHAL_UPDATEOVERLAYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_SETOVERLAYPOSITION = fn(
    param0: *DDHAL_SETOVERLAYPOSITIONDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_SETPALETTE = fn(
    param0: *DDHAL_SETPALETTEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_FLIP = fn(
    param0: *DDHAL_FLIPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_DESTROYSURFACE = fn(
    param0: *DDHAL_DESTROYSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_SETCLIPLIST = fn(
    param0: *DDHAL_SETCLIPLISTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_ADDATTACHEDSURFACE = fn(
    param0: *DDHAL_ADDATTACHEDSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_SETCOLORKEY = fn(
    param0: *DDHAL_SETCOLORKEYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_GETBLTSTATUS = fn(
    param0: *DDHAL_GETBLTSTATUSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALSURFCB_GETFLIPSTATUS = fn(
    param0: *DDHAL_GETFLIPSTATUSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDSURFACECALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    DestroySurface: LPDDHALSURFCB_DESTROYSURFACE,
    Flip: LPDDHALSURFCB_FLIP,
    SetClipList: LPDDHALSURFCB_SETCLIPLIST,
    Lock: LPDDHALSURFCB_LOCK,
    Unlock: LPDDHALSURFCB_UNLOCK,
    Blt: LPDDHALSURFCB_BLT,
    SetColorKey: LPDDHALSURFCB_SETCOLORKEY,
    AddAttachedSurface: LPDDHALSURFCB_ADDATTACHEDSURFACE,
    GetBltStatus: LPDDHALSURFCB_GETBLTSTATUS,
    GetFlipStatus: LPDDHALSURFCB_GETFLIPSTATUS,
    UpdateOverlay: LPDDHALSURFCB_UPDATEOVERLAY,
    SetOverlayPosition: LPDDHALSURFCB_SETOVERLAYPOSITION,
    reserved4: *c_void,
    SetPalette: LPDDHALSURFCB_SETPALETTE,
};

pub const LPDDHAL_GETAVAILDRIVERMEMORY = fn(
    param0: *DDHAL_GETAVAILDRIVERMEMORYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_UPDATENONLOCALHEAP = fn(
    param0: *DDHAL_UPDATENONLOCALHEAPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_GETHEAPALIGNMENT = fn(
    param0: *DDHAL_GETHEAPALIGNMENTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDMISCELLANEOUSCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    GetAvailDriverMemory: LPDDHAL_GETAVAILDRIVERMEMORY,
    UpdateNonLocalHeap: LPDDHAL_UPDATENONLOCALHEAP,
    GetHeapAlignment: LPDDHAL_GETHEAPALIGNMENT,
    GetSysmemBltStatus: LPDDHALSURFCB_GETBLTSTATUS,
};

pub const LPDDHAL_CREATESURFACEEX = fn(
    param0: *DDHAL_CREATESURFACEEXDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_GETDRIVERSTATE = fn(
    param0: *DDHAL_GETDRIVERSTATEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHAL_DESTROYDDLOCAL = fn(
    param0: *DDHAL_DESTROYDDLOCALDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDMISCELLANEOUS2CALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    Reserved: *c_void,
    CreateSurfaceEx: LPDDHAL_CREATESURFACEEX,
    GetDriverState: LPDDHAL_GETDRIVERSTATE,
    DestroyDDLocal: LPDDHAL_DESTROYDDLOCAL,
};

pub const LPDDHALEXEBUFCB_CANCREATEEXEBUF = fn(
    param0: *DDHAL_CANCREATESURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALEXEBUFCB_CREATEEXEBUF = fn(
    param0: *DDHAL_CREATESURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALEXEBUFCB_DESTROYEXEBUF = fn(
    param0: *DDHAL_DESTROYSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALEXEBUFCB_LOCKEXEBUF = fn(
    param0: *DDHAL_LOCKDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALEXEBUFCB_UNLOCKEXEBUF = fn(
    param0: *DDHAL_UNLOCKDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDEXEBUFCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    CanCreateExecuteBuffer: LPDDHALEXEBUFCB_CANCREATEEXEBUF,
    CreateExecuteBuffer: LPDDHALEXEBUFCB_CREATEEXEBUF,
    DestroyExecuteBuffer: LPDDHALEXEBUFCB_DESTROYEXEBUF,
    LockExecuteBuffer: LPDDHALEXEBUFCB_LOCKEXEBUF,
    UnlockExecuteBuffer: LPDDHALEXEBUFCB_UNLOCKEXEBUF,
};

pub const LPDDHALVPORTCB_CANCREATEVIDEOPORT = fn(
    param0: *DDHAL_CANCREATEVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_CREATEVIDEOPORT = fn(
    param0: *DDHAL_CREATEVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_FLIP = fn(
    param0: *DDHAL_FLIPVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETBANDWIDTH = fn(
    param0: *DDHAL_GETVPORTBANDWIDTHDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETINPUTFORMATS = fn(
    param0: *DDHAL_GETVPORTINPUTFORMATDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETOUTPUTFORMATS = fn(
    param0: *DDHAL_GETVPORTOUTPUTFORMATDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETFIELD = fn(
    param0: *DDHAL_GETVPORTFIELDDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETLINE = fn(
    param0: *DDHAL_GETVPORTLINEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETVPORTCONNECT = fn(
    param0: *DDHAL_GETVPORTCONNECTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_DESTROYVPORT = fn(
    param0: *DDHAL_DESTROYVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETFLIPSTATUS = fn(
    param0: *DDHAL_GETVPORTFLIPSTATUSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_UPDATE = fn(
    param0: *DDHAL_UPDATEVPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_WAITFORSYNC = fn(
    param0: *DDHAL_WAITFORVPORTSYNCDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_GETSIGNALSTATUS = fn(
    param0: *DDHAL_GETVPORTSIGNALDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALVPORTCB_COLORCONTROL = fn(
    param0: *DDHAL_VPORTCOLORDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDVIDEOPORTCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    CanCreateVideoPort: LPDDHALVPORTCB_CANCREATEVIDEOPORT,
    CreateVideoPort: LPDDHALVPORTCB_CREATEVIDEOPORT,
    FlipVideoPort: LPDDHALVPORTCB_FLIP,
    GetVideoPortBandwidth: LPDDHALVPORTCB_GETBANDWIDTH,
    GetVideoPortInputFormats: LPDDHALVPORTCB_GETINPUTFORMATS,
    GetVideoPortOutputFormats: LPDDHALVPORTCB_GETOUTPUTFORMATS,
    lpReserved1: *c_void,
    GetVideoPortField: LPDDHALVPORTCB_GETFIELD,
    GetVideoPortLine: LPDDHALVPORTCB_GETLINE,
    GetVideoPortConnectInfo: LPDDHALVPORTCB_GETVPORTCONNECT,
    DestroyVideoPort: LPDDHALVPORTCB_DESTROYVPORT,
    GetVideoPortFlipStatus: LPDDHALVPORTCB_GETFLIPSTATUS,
    UpdateVideoPort: LPDDHALVPORTCB_UPDATE,
    WaitForVideoPortSync: LPDDHALVPORTCB_WAITFORSYNC,
    GetVideoSignalStatus: LPDDHALVPORTCB_GETSIGNALSTATUS,
    ColorControl: LPDDHALVPORTCB_COLORCONTROL,
};

pub const LPDDHALCOLORCB_COLORCONTROL = fn(
    param0: *DDHAL_COLORCONTROLDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDCOLORCONTROLCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    ColorControl: LPDDHALCOLORCB_COLORCONTROL,
};

pub const LPDDHALKERNELCB_SYNCSURFACE = fn(
    param0: *DDHAL_SYNCSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALKERNELCB_SYNCVIDEOPORT = fn(
    param0: *DDHAL_SYNCVIDEOPORTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDKERNELCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    SyncSurfaceData: LPDDHALKERNELCB_SYNCSURFACE,
    SyncVideoPortData: LPDDHALKERNELCB_SYNCVIDEOPORT,
};

pub const LPDDGAMMACALIBRATORPROC = fn(
    param0: *DDGAMMARAMP,
    param1: *u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPDDHALMOCOMPCB_GETGUIDS = fn(
    param0: *DDHAL_GETMOCOMPGUIDSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_GETFORMATS = fn(
    param0: *DDHAL_GETMOCOMPFORMATSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_CREATE = fn(
    param0: *DDHAL_CREATEMOCOMPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_GETCOMPBUFFINFO = fn(
    param0: *DDHAL_GETMOCOMPCOMPBUFFDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_GETINTERNALINFO = fn(
    param0: *DDHAL_GETINTERNALMOCOMPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_BEGINFRAME = fn(
    param0: *DDHAL_BEGINMOCOMPFRAMEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_ENDFRAME = fn(
    param0: *DDHAL_ENDMOCOMPFRAMEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_RENDER = fn(
    param0: *DDHAL_RENDERMOCOMPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_QUERYSTATUS = fn(
    param0: *DDHAL_QUERYMOCOMPSTATUSDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPDDHALMOCOMPCB_DESTROY = fn(
    param0: *DDHAL_DESTROYMOCOMPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DDHAL_DDMOTIONCOMPCALLBACKS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    GetMoCompGuids: LPDDHALMOCOMPCB_GETGUIDS,
    GetMoCompFormats: LPDDHALMOCOMPCB_GETFORMATS,
    CreateMoComp: LPDDHALMOCOMPCB_CREATE,
    GetMoCompBuffInfo: LPDDHALMOCOMPCB_GETCOMPBUFFINFO,
    GetInternalMoCompInfo: LPDDHALMOCOMPCB_GETINTERNALINFO,
    BeginMoCompFrame: LPDDHALMOCOMPCB_BEGINFRAME,
    EndMoCompFrame: LPDDHALMOCOMPCB_ENDFRAME,
    RenderMoComp: LPDDHALMOCOMPCB_RENDER,
    QueryMoCompStatus: LPDDHALMOCOMPCB_QUERYSTATUS,
    DestroyMoComp: LPDDHALMOCOMPCB_DESTROY,
};

pub const DDNONLOCALVIDMEMCAPS = extern struct {
    dwSize: u32,
    dwNLVBCaps: u32,
    dwNLVBCaps2: u32,
    dwNLVBCKeyCaps: u32,
    dwNLVBFXCaps: u32,
    dwNLVBRops: [8]u32,
};

pub const DDMORESURFACECAPS = extern struct {
    dwSize: u32,
    ddsCapsMore: DDSCAPSEX,
    ddsExtendedHeapRestrictions: [1]DDMORESURFACECAPS.tagExtendedHeapRestrictions,
    const tagExtendedHeapRestrictions = u32; // TODO: generate this nested type!
};

pub const DDSTEREOMODE = extern struct {
    dwSize: u32,
    dwHeight: u32,
    dwWidth: u32,
    dwBpp: u32,
    dwRefreshRate: u32,
    bSupported: BOOL,
};

pub const DDRAWI_DDRAWPALETTE_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDRAWPALETTE_LCL,
    lpLink: *DDRAWI_DDRAWPALETTE_INT,
    dwIntRefCnt: u32,
};

pub const DDRAWI_DDRAWPALETTE_GBL = extern struct {
    dwRefCnt: u32,
    dwFlags: u32,
    lpDD_lcl: *DDRAWI_DIRECTDRAW_LCL,
    dwProcessId: u32,
    lpColorTable: *PALETTEENTRY,
    Anonymous: DDRAWI_DDRAWPALETTE_GBL._Anonymous_e__Union,
    dwDriverReserved: u32,
    dwContentsStamp: u32,
    dwSaveStamp: u32,
    dwHandle: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DDRAWI_DDRAWPALETTE_LCL = extern struct {
    lpPalMore: u32,
    lpGbl: *DDRAWI_DDRAWPALETTE_GBL,
    dwUnused0: ?*c_void,
    dwLocalRefCnt: u32,
    pUnkOuter: *IUnknown,
    lpDD_lcl: *DDRAWI_DIRECTDRAW_LCL,
    dwReserved1: ?*c_void,
    dwDDRAWReserved1: ?*c_void,
    dwDDRAWReserved2: ?*c_void,
    dwDDRAWReserved3: ?*c_void,
};

pub const DDRAWI_DDRAWCLIPPER_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDRAWCLIPPER_LCL,
    lpLink: *DDRAWI_DDRAWCLIPPER_INT,
    dwIntRefCnt: u32,
};

pub const DDRAWI_DDRAWCLIPPER_GBL = extern struct {
    dwRefCnt: u32,
    dwFlags: u32,
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwProcessId: u32,
    dwReserved1: ?*c_void,
    hWnd: ?*c_void,
    lpStaticClipList: *RGNDATA,
};

pub const DDRAWI_DDRAWCLIPPER_LCL = extern struct {
    lpClipMore: u32,
    lpGbl: *DDRAWI_DDRAWCLIPPER_GBL,
    lpDD_lcl: *DDRAWI_DIRECTDRAW_LCL,
    dwLocalRefCnt: u32,
    pUnkOuter: *IUnknown,
    lpDD_int: *DDRAWI_DIRECTDRAW_INT,
    dwReserved1: ?*c_void,
    pAddrefedThisOwner: *IUnknown,
};

pub const ATTACHLIST = extern struct {
    dwFlags: u32,
    lpLink: *ATTACHLIST,
    lpAttached: *DDRAWI_DDRAWSURFACE_LCL,
    lpIAttached: *DDRAWI_DDRAWSURFACE_INT,
};

pub const DBLNODE = extern struct {
    next: *DBLNODE,
    prev: *DBLNODE,
    object: *DDRAWI_DDRAWSURFACE_LCL,
    object_int: *DDRAWI_DDRAWSURFACE_INT,
};

pub const ACCESSRECTLIST = extern struct {
    lpLink: *ACCESSRECTLIST,
    rDest: RECT,
    lpOwner: *DDRAWI_DIRECTDRAW_LCL,
    lpSurfaceData: *c_void,
    dwFlags: u32,
    lpHeapAliasInfo: *HEAPALIASINFO,
};

pub const DDRAWI_DDRAWSURFACE_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDRAWSURFACE_LCL,
    lpLink: *DDRAWI_DDRAWSURFACE_INT,
    dwIntRefCnt: u32,
};

pub const DDRAWI_DDRAWSURFACE_GBL = extern struct {
    dwRefCnt: u32,
    dwGlobalFlags: u32,
    Anonymous1: DDRAWI_DDRAWSURFACE_GBL._Anonymous1_e__Union,
    Anonymous2: DDRAWI_DDRAWSURFACE_GBL._Anonymous2_e__Union,
    Anonymous3: DDRAWI_DDRAWSURFACE_GBL._Anonymous3_e__Union,
    fpVidMem: ?*c_void,
    Anonymous4: DDRAWI_DDRAWSURFACE_GBL._Anonymous4_e__Union,
    wHeight: u16,
    wWidth: u16,
    dwUsageCount: u32,
    dwReserved1: ?*c_void,
    ddpfSurface: DDPIXELFORMAT,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const DDRAWI_DDRAWSURFACE_GBL_MORE = extern struct {
    dwSize: u32,
    Anonymous: DDRAWI_DDRAWSURFACE_GBL_MORE._Anonymous_e__Union,
    pPageTable: *u32,
    cPages: u32,
    dwSavedDCContext: ?*c_void,
    fpAliasedVidMem: ?*c_void,
    dwDriverReserved: ?*c_void,
    dwHELReserved: ?*c_void,
    cPageUnlocks: u32,
    hKernelSurface: ?*c_void,
    dwKernelRefCnt: u32,
    lpColorInfo: *DDCOLORCONTROL,
    fpNTAlias: ?*c_void,
    dwContentsStamp: u32,
    lpvUnswappedDriverReserved: *c_void,
    lpDDRAWReserved2: *c_void,
    dwDDRAWReserved1: u32,
    dwDDRAWReserved2: u32,
    fpAliasOfVidMem: ?*c_void,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DDRAWI_DDRAWSURFACE_MORE = extern struct {
    dwSize: u32,
    lpIUnknowns: *IUNKNOWN_LIST,
    lpDD_lcl: *DDRAWI_DIRECTDRAW_LCL,
    dwPageLockCount: u32,
    dwBytesAllocated: u32,
    lpDD_int: *DDRAWI_DIRECTDRAW_INT,
    dwMipMapCount: u32,
    lpDDIClipper: *DDRAWI_DDRAWCLIPPER_INT,
    lpHeapAliasInfo: *HEAPALIASINFO,
    dwOverlayFlags: u32,
    rgjunc: *c_void,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    lpddOverlayFX: *DDOVERLAYFX,
    ddsCapsEx: DDSCAPSEX,
    dwTextureStage: u32,
    lpDDRAWReserved: *c_void,
    lpDDRAWReserved2: *c_void,
    lpDDrawReserved3: *c_void,
    dwDDrawReserved4: u32,
    lpDDrawReserved5: *c_void,
    lpGammaRamp: *u32,
    lpOriginalGammaRamp: *u32,
    lpDDrawReserved6: *c_void,
    dwSurfaceHandle: u32,
    qwDDrawReserved8: [2]u32,
    lpDDrawReserved9: *c_void,
    cSurfaces: u32,
    pCreatedDDSurfaceDesc2: *DDSURFACEDESC2,
    slist: **DDRAWI_DDRAWSURFACE_LCL,
    dwFVF: u32,
    lpVB: *c_void,
};

pub const DDRAWI_DDRAWSURFACE_LCL = extern struct {
    lpSurfMore: *DDRAWI_DDRAWSURFACE_MORE,
    lpGbl: *DDRAWI_DDRAWSURFACE_GBL,
    hDDSurface: ?*c_void,
    lpAttachList: *ATTACHLIST,
    lpAttachListFrom: *ATTACHLIST,
    dwLocalRefCnt: u32,
    dwProcessId: u32,
    dwFlags: u32,
    ddsCaps: DDSCAPS,
    Anonymous1: DDRAWI_DDRAWSURFACE_LCL._Anonymous1_e__Union,
    Anonymous2: DDRAWI_DDRAWSURFACE_LCL._Anonymous2_e__Union,
    dwModeCreatedIn: u32,
    dwBackBufferCount: u32,
    ddckCKDestBlt: DDCOLORKEY,
    ddckCKSrcBlt: DDCOLORKEY,
    hDC: ?*c_void,
    dwReserved1: ?*c_void,
    ddckCKSrcOverlay: DDCOLORKEY,
    ddckCKDestOverlay: DDCOLORKEY,
    lpSurfaceOverlaying: *DDRAWI_DDRAWSURFACE_INT,
    dbnOverlayNode: DBLNODE,
    rcOverlaySrc: RECT,
    rcOverlayDest: RECT,
    dwClrXparent: u32,
    dwAlpha: u32,
    lOverlayX: i32,
    lOverlayY: i32,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const DDHALMODEINFO = extern struct {
    dwWidth: u32,
    dwHeight: u32,
    lPitch: i32,
    dwBPP: u32,
    wFlags: u16,
    wRefreshRate: u16,
    dwRBitMask: u32,
    dwGBitMask: u32,
    dwBBitMask: u32,
    dwAlphaBitMask: u32,
};

pub const DDRAWI_DIRECTDRAW_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DIRECTDRAW_LCL,
    lpLink: *DDRAWI_DIRECTDRAW_INT,
    dwIntRefCnt: u32,
};

pub const DDHAL_CALLBACKS = extern struct {
    cbDDCallbacks: DDHAL_DDCALLBACKS,
    cbDDSurfaceCallbacks: DDHAL_DDSURFACECALLBACKS,
    cbDDPaletteCallbacks: DDHAL_DDPALETTECALLBACKS,
    HALDD: DDHAL_DDCALLBACKS,
    HALDDSurface: DDHAL_DDSURFACECALLBACKS,
    HALDDPalette: DDHAL_DDPALETTECALLBACKS,
    HELDD: DDHAL_DDCALLBACKS,
    HELDDSurface: DDHAL_DDSURFACECALLBACKS,
    HELDDPalette: DDHAL_DDPALETTECALLBACKS,
    cbDDExeBufCallbacks: DDHAL_DDEXEBUFCALLBACKS,
    HALDDExeBuf: DDHAL_DDEXEBUFCALLBACKS,
    HELDDExeBuf: DDHAL_DDEXEBUFCALLBACKS,
    cbDDVideoPortCallbacks: DDHAL_DDVIDEOPORTCALLBACKS,
    HALDDVideoPort: DDHAL_DDVIDEOPORTCALLBACKS,
    cbDDColorControlCallbacks: DDHAL_DDCOLORCONTROLCALLBACKS,
    HALDDColorControl: DDHAL_DDCOLORCONTROLCALLBACKS,
    cbDDMiscellaneousCallbacks: DDHAL_DDMISCELLANEOUSCALLBACKS,
    HALDDMiscellaneous: DDHAL_DDMISCELLANEOUSCALLBACKS,
    cbDDKernelCallbacks: DDHAL_DDKERNELCALLBACKS,
    HALDDKernel: DDHAL_DDKERNELCALLBACKS,
    cbDDMotionCompCallbacks: DDHAL_DDMOTIONCOMPCALLBACKS,
    HALDDMotionComp: DDHAL_DDMOTIONCOMPCALLBACKS,
};

pub const DDRAWI_DIRECTDRAW_GBL = extern struct {
    dwRefCnt: u32,
    dwFlags: u32,
    fpPrimaryOrig: ?*c_void,
    ddCaps: DDCORECAPS,
    dwInternal1: u32,
    dwUnused1: [9]u32,
    lpDDCBtmp: *DDHAL_CALLBACKS,
    dsList: *DDRAWI_DDRAWSURFACE_INT,
    palList: *DDRAWI_DDRAWPALETTE_INT,
    clipperList: *DDRAWI_DDRAWCLIPPER_INT,
    lp16DD: *DDRAWI_DIRECTDRAW_GBL,
    dwMaxOverlays: u32,
    dwCurrOverlays: u32,
    dwMonitorFrequency: u32,
    ddHELCaps: DDCORECAPS,
    dwUnused2: [50]u32,
    ddckCKDestOverlay: DDCOLORKEY,
    ddckCKSrcOverlay: DDCOLORKEY,
    vmiData: VIDMEMINFO,
    lpDriverHandle: *c_void,
    lpExclusiveOwner: *DDRAWI_DIRECTDRAW_LCL,
    dwModeIndex: u32,
    dwModeIndexOrig: u32,
    dwNumFourCC: u32,
    lpdwFourCC: *u32,
    dwNumModes: u32,
    lpModeInfo: *DDHALMODEINFO,
    plProcessList: PROCESS_LIST,
    dwSurfaceLockCount: u32,
    dwAliasedLockCnt: u32,
    dwReserved3: ?*c_void,
    hDD: ?*c_void,
    cObsolete: [12]i8,
    dwReserved1: u32,
    dwReserved2: u32,
    dbnOverlayRoot: DBLNODE,
    lpwPDeviceFlags: *u16,
    dwPDevice: u32,
    dwWin16LockCnt: u32,
    dwUnused3: u32,
    hInstance: u32,
    dwEvent16: u32,
    dwSaveNumModes: u32,
    lpD3DGlobalDriverData: ?*c_void,
    lpD3DHALCallbacks: ?*c_void,
    ddBothCaps: DDCORECAPS,
    lpDDVideoPortCaps: *DDVIDEOPORTCAPS,
    dvpList: *DDRAWI_DDVIDEOPORT_INT,
    lpD3DHALCallbacks2: ?*c_void,
    rectDevice: RECT,
    cMonitors: u32,
    gpbmiSrc: *c_void,
    gpbmiDest: *c_void,
    phaiHeapAliases: *HEAPALIASINFO,
    hKernelHandle: ?*c_void,
    pfnNotifyProc: ?*c_void,
    lpDDKernelCaps: *DDKERNELCAPS,
    lpddNLVCaps: *DDNONLOCALVIDMEMCAPS,
    lpddNLVHELCaps: *DDNONLOCALVIDMEMCAPS,
    lpddNLVBothCaps: *DDNONLOCALVIDMEMCAPS,
    lpD3DExtendedCaps: ?*c_void,
    dwDOSBoxEvent: u32,
    rectDesktop: RECT,
    cDriverName: [32]i8,
    lpD3DHALCallbacks3: ?*c_void,
    dwNumZPixelFormats: u32,
    lpZPixelFormats: *DDPIXELFORMAT,
    mcList: *DDRAWI_DDMOTIONCOMP_INT,
    hDDVxd: u32,
    ddsCapsMore: DDSCAPSEX,
};

pub const DDRAWI_DIRECTDRAW_LCL = extern struct {
    lpDDMore: u32,
    lpGbl: *DDRAWI_DIRECTDRAW_GBL,
    dwUnused0: u32,
    dwLocalFlags: u32,
    dwLocalRefCnt: u32,
    dwProcessId: u32,
    pUnkOuter: *IUnknown,
    dwObsolete1: u32,
    hWnd: ?*c_void,
    hDC: ?*c_void,
    dwErrorMode: u32,
    lpPrimary: *DDRAWI_DDRAWSURFACE_INT,
    lpCB: *DDRAWI_DDRAWSURFACE_INT,
    dwPreferredMode: u32,
    hD3DInstance: HINSTANCE,
    pD3DIUnknown: *IUnknown,
    lpDDCB: *DDHAL_CALLBACKS,
    hDDVxd: ?*c_void,
    dwAppHackFlags: u32,
    hFocusWnd: ?*c_void,
    dwHotTracking: u32,
    dwIMEState: u32,
    hWndPopup: ?*c_void,
    hDD: ?*c_void,
    hGammaCalibrator: ?*c_void,
    lpGammaCalibrator: LPDDGAMMACALIBRATORPROC,
};

pub const DDRAWI_DDVIDEOPORT_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDVIDEOPORT_LCL,
    lpLink: *DDRAWI_DDVIDEOPORT_INT,
    dwIntRefCnt: u32,
    dwFlags: u32,
};

pub const DDRAWI_DDVIDEOPORT_LCL = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    ddvpDesc: DDVIDEOPORTDESC,
    ddvpInfo: DDVIDEOPORTINFO,
    lpSurface: *DDRAWI_DDRAWSURFACE_INT,
    lpVBISurface: *DDRAWI_DDRAWSURFACE_INT,
    lpFlipInts: **DDRAWI_DDRAWSURFACE_INT,
    dwNumAutoflip: u32,
    dwProcessID: u32,
    dwStateFlags: u32,
    dwFlags: u32,
    dwRefCnt: u32,
    fpLastFlip: ?*c_void,
    dwReserved1: ?*c_void,
    dwReserved2: ?*c_void,
    hDDVideoPort: HANDLE,
    dwNumVBIAutoflip: u32,
    lpVBIDesc: *DDVIDEOPORTDESC,
    lpVideoDesc: *DDVIDEOPORTDESC,
    lpVBIInfo: *DDVIDEOPORTINFO,
    lpVideoInfo: *DDVIDEOPORTINFO,
    dwVBIProcessID: u32,
    lpVPNotify: *DDRAWI_DDVIDEOPORT_INT,
};

pub const DDRAWI_DDMOTIONCOMP_INT = extern struct {
    lpVtbl: *c_void,
    lpLcl: *DDRAWI_DDMOTIONCOMP_LCL,
    lpLink: *DDRAWI_DDMOTIONCOMP_INT,
    dwIntRefCnt: u32,
};

pub const DDRAWI_DDMOTIONCOMP_LCL = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    guid: Guid,
    dwUncompWidth: u32,
    dwUncompHeight: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
    dwInternalFlags: u32,
    dwRefCnt: u32,
    dwProcessId: u32,
    hMoComp: HANDLE,
    dwDriverReserved1: u32,
    dwDriverReserved2: u32,
    dwDriverReserved3: u32,
    lpDriverReserved1: *c_void,
    lpDriverReserved2: *c_void,
    lpDriverReserved3: *c_void,
};

pub const DDHALINFO = extern struct {
    dwSize: u32,
    lpDDCallbacks: *DDHAL_DDCALLBACKS,
    lpDDSurfaceCallbacks: *DDHAL_DDSURFACECALLBACKS,
    lpDDPaletteCallbacks: *DDHAL_DDPALETTECALLBACKS,
    vmiData: VIDMEMINFO,
    ddCaps: DDCORECAPS,
    dwMonitorFrequency: u32,
    GetDriverInfo: LPDDHAL_GETDRIVERINFO,
    dwModeIndex: u32,
    lpdwFourCC: *u32,
    dwNumModes: u32,
    lpModeInfo: *DDHALMODEINFO,
    dwFlags: u32,
    lpPDevice: *c_void,
    hInstance: u32,
    lpD3DGlobalDriverData: ?*c_void,
    lpD3DHALCallbacks: ?*c_void,
    lpDDExeBufCallbacks: *DDHAL_DDEXEBUFCALLBACKS,
};

pub const LPDDHAL_SETINFO = fn(
    lpDDHalInfo: *DDHALINFO,
    reset: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPDDHAL_VIDMEMALLOC = fn(
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    heap: i32,
    dwWidth: u32,
    dwHeight: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const LPDDHAL_VIDMEMFREE = fn(
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    heap: i32,
    fpMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const DDHALDDRAWFNS = extern struct {
    dwSize: u32,
    lpSetInfo: LPDDHAL_SETINFO,
    lpVidMemAlloc: LPDDHAL_VIDMEMALLOC,
    lpVidMemFree: LPDDHAL_VIDMEMFREE,
};

pub const DDHAL_BLTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDDestSurface: *DDRAWI_DDRAWSURFACE_LCL,
    rDest: RECTL,
    lpDDSrcSurface: *DDRAWI_DDRAWSURFACE_LCL,
    rSrc: RECTL,
    dwFlags: u32,
    dwROPFlags: u32,
    bltFX: DDBLTFX,
    ddRVal: HRESULT,
    Blt: LPDDHALSURFCB_BLT,
    IsClipped: BOOL,
    rOrigDest: RECTL,
    rOrigSrc: RECTL,
    dwRectCnt: u32,
    prDestRects: *RECT,
};

pub const DDHAL_LOCKDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    bHasRect: u32,
    rArea: RECTL,
    lpSurfData: *c_void,
    ddRVal: HRESULT,
    Lock: LPDDHALSURFCB_LOCK,
    dwFlags: u32,
};

pub const DDHAL_UNLOCKDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    Unlock: LPDDHALSURFCB_UNLOCK,
};

pub const DDHAL_UPDATEOVERLAYDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDDestSurface: *DDRAWI_DDRAWSURFACE_LCL,
    rDest: RECTL,
    lpDDSrcSurface: *DDRAWI_DDRAWSURFACE_LCL,
    rSrc: RECTL,
    dwFlags: u32,
    overlayFX: DDOVERLAYFX,
    ddRVal: HRESULT,
    UpdateOverlay: LPDDHALSURFCB_UPDATEOVERLAY,
};

pub const DDHAL_SETOVERLAYPOSITIONDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSrcSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lpDDDestSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lXPos: i32,
    lYPos: i32,
    ddRVal: HRESULT,
    SetOverlayPosition: LPDDHALSURFCB_SETOVERLAYPOSITION,
};

pub const DDHAL_SETPALETTEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lpDDPalette: *DDRAWI_DDRAWPALETTE_GBL,
    ddRVal: HRESULT,
    SetPalette: LPDDHALSURFCB_SETPALETTE,
    Attach: BOOL,
};

pub const DDHAL_FLIPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpSurfCurr: *DDRAWI_DDRAWSURFACE_LCL,
    lpSurfTarg: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ddRVal: HRESULT,
    Flip: LPDDHALSURFCB_FLIP,
    lpSurfCurrLeft: *DDRAWI_DDRAWSURFACE_LCL,
    lpSurfTargLeft: *DDRAWI_DDRAWSURFACE_LCL,
};

pub const DDHAL_DESTROYSURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    DestroySurface: LPDDHALSURFCB_DESTROYSURFACE,
};

pub const DDHAL_SETCLIPLISTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    SetClipList: LPDDHALSURFCB_SETCLIPLIST,
};

pub const DDHAL_ADDATTACHEDSURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lpSurfAttached: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    AddAttachedSurface: LPDDHALSURFCB_ADDATTACHEDSURFACE,
};

pub const DDHAL_SETCOLORKEYDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ckNew: DDCOLORKEY,
    ddRVal: HRESULT,
    SetColorKey: LPDDHALSURFCB_SETCOLORKEY,
};

pub const DDHAL_GETBLTSTATUSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ddRVal: HRESULT,
    GetBltStatus: LPDDHALSURFCB_GETBLTSTATUS,
};

pub const DDHAL_GETFLIPSTATUSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ddRVal: HRESULT,
    GetFlipStatus: LPDDHALSURFCB_GETFLIPSTATUS,
};

pub const DDHAL_DESTROYPALETTEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDPalette: *DDRAWI_DDRAWPALETTE_GBL,
    ddRVal: HRESULT,
    DestroyPalette: LPDDHALPALCB_DESTROYPALETTE,
};

pub const DDHAL_SETENTRIESDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDPalette: *DDRAWI_DDRAWPALETTE_GBL,
    dwBase: u32,
    dwNumEntries: u32,
    lpEntries: *PALETTEENTRY,
    ddRVal: HRESULT,
    SetEntries: LPDDHALPALCB_SETENTRIES,
};

pub const DDHAL_CREATESURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurfaceDesc: *DDSURFACEDESC,
    lplpSList: **DDRAWI_DDRAWSURFACE_LCL,
    dwSCnt: u32,
    ddRVal: HRESULT,
    CreateSurface: LPDDHAL_CREATESURFACE,
};

pub const DDHAL_CANCREATESURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurfaceDesc: *DDSURFACEDESC,
    bIsDifferentPixelFormat: u32,
    ddRVal: HRESULT,
    CanCreateSurface: LPDDHAL_CANCREATESURFACE,
};

pub const DDHAL_CREATEPALETTEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDPalette: *DDRAWI_DDRAWPALETTE_GBL,
    lpColorTable: *PALETTEENTRY,
    ddRVal: HRESULT,
    CreatePalette: LPDDHAL_CREATEPALETTE,
    is_excl: BOOL,
};

pub const DDHAL_DESTROYDRIVERDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    ddRVal: HRESULT,
    DestroyDriver: LPDDHAL_DESTROYDRIVER,
};

pub const DDHAL_SETMODEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwModeIndex: u32,
    ddRVal: HRESULT,
    SetMode: LPDDHAL_SETMODE,
    inexcl: BOOL,
    useRefreshRate: BOOL,
};

pub const DDHAL_DRVSETCOLORKEYDATA = extern struct {
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ckNew: DDCOLORKEY,
    ddRVal: HRESULT,
    SetColorKey: LPDDHAL_SETCOLORKEY,
};

pub const DDHAL_GETSCANLINEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwScanLine: u32,
    ddRVal: HRESULT,
    GetScanLine: LPDDHAL_GETSCANLINE,
};

pub const DDHAL_SETEXCLUSIVEMODEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwEnterExcl: u32,
    dwReserved: u32,
    ddRVal: HRESULT,
    SetExclusiveMode: LPDDHAL_SETEXCLUSIVEMODE,
};

pub const DDHAL_FLIPTOGDISURFACEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwToGDI: u32,
    dwReserved: u32,
    ddRVal: HRESULT,
    FlipToGDISurface: LPDDHAL_FLIPTOGDISURFACE,
};

pub const DDHAL_CANCREATEVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpDDVideoPortDesc: *DDVIDEOPORTDESC,
    ddRVal: HRESULT,
    CanCreateVideoPort: LPDDHALVPORTCB_CANCREATEVIDEOPORT,
};

pub const DDHAL_CREATEVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpDDVideoPortDesc: *DDVIDEOPORTDESC,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    ddRVal: HRESULT,
    CreateVideoPort: LPDDHALVPORTCB_CREATEVIDEOPORT,
};

pub const DDHAL_FLIPVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    lpSurfCurr: *DDRAWI_DDRAWSURFACE_LCL,
    lpSurfTarg: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
    FlipVideoPort: LPDDHALVPORTCB_FLIP,
};

pub const DDHAL_GETVPORTBANDWIDTHDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    lpddpfFormat: *DDPIXELFORMAT,
    dwWidth: u32,
    dwHeight: u32,
    dwFlags: u32,
    lpBandwidth: *DDVIDEOPORTBANDWIDTH,
    ddRVal: HRESULT,
    GetVideoPortBandwidth: LPDDHALVPORTCB_GETBANDWIDTH,
};

pub const DDHAL_GETVPORTINPUTFORMATDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwFlags: u32,
    lpddpfFormat: *DDPIXELFORMAT,
    dwNumFormats: u32,
    ddRVal: HRESULT,
    GetVideoPortInputFormats: LPDDHALVPORTCB_GETINPUTFORMATS,
};

pub const DDHAL_GETVPORTOUTPUTFORMATDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwFlags: u32,
    lpddpfInputFormat: *DDPIXELFORMAT,
    lpddpfOutputFormats: *DDPIXELFORMAT,
    dwNumFormats: u32,
    ddRVal: HRESULT,
    GetVideoPortOutputFormats: LPDDHALVPORTCB_GETOUTPUTFORMATS,
};

pub const DDHAL_GETVPORTFIELDDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    bField: BOOL,
    ddRVal: HRESULT,
    GetVideoPortField: LPDDHALVPORTCB_GETFIELD,
};

pub const DDHAL_GETVPORTLINEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwLine: u32,
    ddRVal: HRESULT,
    GetVideoPortLine: LPDDHALVPORTCB_GETLINE,
};

pub const DDHAL_GETVPORTCONNECTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    dwPortId: u32,
    lpConnect: *DDVIDEOPORTCONNECT,
    dwNumEntries: u32,
    ddRVal: HRESULT,
    GetVideoPortConnectInfo: LPDDHALVPORTCB_GETVPORTCONNECT,
};

pub const DDHAL_DESTROYVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    ddRVal: HRESULT,
    DestroyVideoPort: LPDDHALVPORTCB_DESTROYVPORT,
};

pub const DDHAL_GETVPORTFLIPSTATUSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    fpSurface: ?*c_void,
    ddRVal: HRESULT,
    GetVideoPortFlipStatus: LPDDHALVPORTCB_GETFLIPSTATUS,
};

pub const DDHAL_UPDATEVPORTDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    lplpDDSurface: **DDRAWI_DDRAWSURFACE_INT,
    lplpDDVBISurface: **DDRAWI_DDRAWSURFACE_INT,
    lpVideoInfo: *DDVIDEOPORTINFO,
    dwFlags: u32,
    dwNumAutoflip: u32,
    dwNumVBIAutoflip: u32,
    ddRVal: HRESULT,
    UpdateVideoPort: LPDDHALVPORTCB_UPDATE,
};

pub const DDHAL_WAITFORVPORTSYNCDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwFlags: u32,
    dwLine: u32,
    dwTimeOut: u32,
    ddRVal: HRESULT,
    WaitForVideoPortSync: LPDDHALVPORTCB_WAITFORSYNC,
};

pub const DDHAL_GETVPORTSIGNALDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwStatus: u32,
    ddRVal: HRESULT,
    GetVideoSignalStatus: LPDDHALVPORTCB_GETSIGNALSTATUS,
};

pub const DDHAL_VPORTCOLORDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwFlags: u32,
    lpColorData: *DDCOLORCONTROL,
    ddRVal: HRESULT,
    ColorControl: LPDDHALVPORTCB_COLORCONTROL,
};

pub const DDHAL_COLORCONTROLDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    lpColorData: *DDCOLORCONTROL,
    dwFlags: u32,
    ddRVal: HRESULT,
    ColorControl: LPDDHALCOLORCB_COLORCONTROL,
};

pub const DDHAL_GETDRIVERINFODATA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    guidInfo: Guid,
    dwExpectedSize: u32,
    lpvData: *c_void,
    dwActualSize: u32,
    ddRVal: HRESULT,
    dwContext: ?*c_void,
};

pub const DDHAL_GETAVAILDRIVERMEMORYDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    DDSCaps: DDSCAPS,
    dwTotal: u32,
    dwFree: u32,
    ddRVal: HRESULT,
    GetAvailDriverMemory: LPDDHAL_GETAVAILDRIVERMEMORY,
    ddsCapsEx: DDSCAPSEX,
};

pub const DDHAL_UPDATENONLOCALHEAPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_GBL,
    dwHeap: u32,
    fpGARTLin: ?*c_void,
    fpGARTDev: ?*c_void,
    ulPolicyMaxBytes: ?*c_void,
    ddRVal: HRESULT,
    UpdateNonLocalHeap: LPDDHAL_UPDATENONLOCALHEAP,
};

pub const DDHAL_GETHEAPALIGNMENTDATA = extern struct {
    dwInstance: ?*c_void,
    dwHeap: u32,
    ddRVal: HRESULT,
    GetHeapAlignment: LPDDHAL_GETHEAPALIGNMENT,
    Alignment: HEAPALIGNMENT,
};

pub const DDHAL_CREATESURFACEEXDATA = extern struct {
    dwFlags: u32,
    lpDDLcl: *DDRAWI_DIRECTDRAW_LCL,
    lpDDSLcl: *DDRAWI_DDRAWSURFACE_LCL,
    ddRVal: HRESULT,
};

pub const DDHAL_GETDRIVERSTATEDATA = extern struct {
    dwFlags: u32,
    Anonymous: DDHAL_GETDRIVERSTATEDATA._Anonymous_e__Union,
    lpdwStates: *u32,
    dwLength: u32,
    ddRVal: HRESULT,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DDHAL_SYNCSURFACEDATA = extern struct {
    dwSize: u32,
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpDDSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwSurfaceOffset: u32,
    fpLockPtr: ?*c_void,
    lPitch: i32,
    dwOverlayOffset: u32,
    dwOverlaySrcWidth: u32,
    dwOverlaySrcHeight: u32,
    dwOverlayDestWidth: u32,
    dwOverlayDestHeight: u32,
    dwDriverReserved1: ?*c_void,
    dwDriverReserved2: ?*c_void,
    dwDriverReserved3: ?*c_void,
    ddRVal: HRESULT,
};

pub const DDHAL_SYNCVIDEOPORTDATA = extern struct {
    dwSize: u32,
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpVideoPort: *DDRAWI_DDVIDEOPORT_LCL,
    dwOriginOffset: u32,
    dwHeight: u32,
    dwVBIHeight: u32,
    dwDriverReserved1: ?*c_void,
    dwDriverReserved2: ?*c_void,
    dwDriverReserved3: ?*c_void,
    ddRVal: HRESULT,
};

pub const DDHAL_GETMOCOMPGUIDSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    dwNumGuids: u32,
    lpGuids: *Guid,
    ddRVal: HRESULT,
    GetMoCompGuids: LPDDHALMOCOMPCB_GETGUIDS,
};

pub const DDHAL_GETMOCOMPFORMATSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpGuid: *Guid,
    dwNumFormats: u32,
    lpFormats: *DDPIXELFORMAT,
    ddRVal: HRESULT,
    GetMoCompFormats: LPDDHALMOCOMPCB_GETFORMATS,
};

pub const DDHAL_CREATEMOCOMPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    lpGuid: *Guid,
    dwUncompWidth: u32,
    dwUncompHeight: u32,
    ddUncompPixelFormat: DDPIXELFORMAT,
    lpData: *c_void,
    dwDataSize: u32,
    ddRVal: HRESULT,
    CreateMoComp: LPDDHALMOCOMPCB_CREATE,
};

pub const DDMCCOMPBUFFERINFO = extern struct {
    dwSize: u32,
    dwNumCompBuffers: u32,
    dwWidthToCreate: u32,
    dwHeightToCreate: u32,
    dwBytesToAllocate: u32,
    ddCompCaps: DDSCAPS2,
    ddPixelFormat: DDPIXELFORMAT,
};

pub const DDHAL_GETMOCOMPCOMPBUFFDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpGuid: *Guid,
    dwWidth: u32,
    dwHeight: u32,
    ddPixelFormat: DDPIXELFORMAT,
    dwNumTypesCompBuffs: u32,
    lpCompBuffInfo: *DDMCCOMPBUFFERINFO,
    ddRVal: HRESULT,
    GetMoCompBuffInfo: LPDDHALMOCOMPCB_GETCOMPBUFFINFO,
};

pub const DDHAL_GETINTERNALMOCOMPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpGuid: *Guid,
    dwWidth: u32,
    dwHeight: u32,
    ddPixelFormat: DDPIXELFORMAT,
    dwScratchMemAlloc: u32,
    ddRVal: HRESULT,
    GetInternalMoCompInfo: LPDDHALMOCOMPCB_GETINTERNALINFO,
};

pub const DDHAL_BEGINMOCOMPFRAMEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    lpDestSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwInputDataSize: u32,
    lpInputData: *c_void,
    dwOutputDataSize: u32,
    lpOutputData: *c_void,
    ddRVal: HRESULT,
    BeginMoCompFrame: LPDDHALMOCOMPCB_BEGINFRAME,
};

pub const DDHAL_ENDMOCOMPFRAMEDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    lpInputData: *c_void,
    dwInputDataSize: u32,
    ddRVal: HRESULT,
    EndMoCompFrame: LPDDHALMOCOMPCB_ENDFRAME,
};

pub const DDMCBUFFERINFO = extern struct {
    dwSize: u32,
    lpCompSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwDataOffset: u32,
    dwDataSize: u32,
    lpPrivate: *c_void,
};

pub const DDHAL_RENDERMOCOMPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    dwNumBuffers: u32,
    lpBufferInfo: *DDMCBUFFERINFO,
    dwFunction: u32,
    lpInputData: *c_void,
    dwInputDataSize: u32,
    lpOutputData: *c_void,
    dwOutputDataSize: u32,
    ddRVal: HRESULT,
    RenderMoComp: LPDDHALMOCOMPCB_RENDER,
};

pub const DDHAL_QUERYMOCOMPSTATUSDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    lpSurface: *DDRAWI_DDRAWSURFACE_LCL,
    dwFlags: u32,
    ddRVal: HRESULT,
    QueryMoCompStatus: LPDDHALMOCOMPCB_QUERYSTATUS,
};

pub const DDHAL_DESTROYMOCOMPDATA = extern struct {
    lpDD: *DDRAWI_DIRECTDRAW_LCL,
    lpMoComp: *DDRAWI_DDMOTIONCOMP_LCL,
    ddRVal: HRESULT,
    DestroyMoComp: LPDDHALMOCOMPCB_DESTROY,
};

pub const PFNCHECKCONNECTIONWIZARD = fn(
    param0: u32,
    param1: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFNSETSHELLNEXT = fn(
    param0: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const _D3DHAL_CALLBACKS = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const _D3DHAL_GLOBALDRIVERDATA = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const STRENTRYA = extern struct {
    pszName: PSTR,
    pszValue: PSTR,
};

pub const STRENTRYW = extern struct {
    pszName: PWSTR,
    pszValue: PWSTR,
};

pub const STRTABLEA = extern struct {
    cEntries: u32,
    pse: *STRENTRYA,
};

pub const STRTABLEW = extern struct {
    cEntries: u32,
    pse: *STRENTRYW,
};

pub const REGINSTALLA = fn(
    hm: ?*c_void,
    pszSection: [*:0]const u8,
    pstTable: *STRTABLEA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const _CabInfoA = extern struct {
    pszCab: PSTR,
    pszInf: PSTR,
    pszSection: PSTR,
    szSrcPath: [260]i8,
    dwFlags: u32,
};

pub const _CabInfoW = extern struct {
    pszCab: PWSTR,
    pszInf: PWSTR,
    pszSection: PWSTR,
    szSrcPath: [260]u16,
    dwFlags: u32,
};

pub const PERUSERSECTIONA = extern struct {
    szGUID: [59]i8,
    szDispName: [128]i8,
    szLocale: [10]i8,
    szStub: [1040]i8,
    szVersion: [32]i8,
    szCompID: [128]i8,
    dwIsInstalled: u32,
    bRollback: BOOL,
};

pub const PERUSERSECTIONW = extern struct {
    szGUID: [59]u16,
    szDispName: [128]u16,
    szLocale: [10]u16,
    szStub: [1040]u16,
    szVersion: [32]u16,
    szCompID: [128]u16,
    dwIsInstalled: u32,
    bRollback: BOOL,
};

pub const IMESTRUCT = extern struct {
    fnc: u32,
    wParam: WPARAM,
    wCount: u32,
    dchSource: u32,
    dchDest: u32,
    lParam1: LPARAM,
    lParam2: LPARAM,
    lParam3: LPARAM,
};

pub const UNDETERMINESTRUCT = extern struct {
    dwSize: u32,
    uDefIMESize: u32,
    uDefIMEPos: u32,
    uUndetTextLen: u32,
    uUndetTextPos: u32,
    uUndetAttrPos: u32,
    uCursorPos: u32,
    uDeltaStart: u32,
    uDetermineTextLen: u32,
    uDetermineTextPos: u32,
    uDetermineDelimPos: u32,
    uYomiTextLen: u32,
    uYomiTextPos: u32,
    uYomiDelimPos: u32,
};

pub const STRINGEXSTRUCT = extern struct {
    dwSize: u32,
    uDeterminePos: u32,
    uDetermineDelimPos: u32,
    uYomiPos: u32,
    uYomiDelimPos: u32,
};

pub const DATETIME = extern struct {
    year: u16,
    month: u16,
    day: u16,
    hour: u16,
    min: u16,
    sec: u16,
};

pub const IMEPROA = extern struct {
    hWnd: HWND,
    InstDate: DATETIME,
    wVersion: u32,
    szDescription: [50]u8,
    szName: [80]u8,
    szOptions: [30]u8,
};

pub const IMEPROW = extern struct {
    hWnd: HWND,
    InstDate: DATETIME,
    wVersion: u32,
    szDescription: [50]u16,
    szName: [80]u16,
    szOptions: [30]u16,
};

const CLSID_WebBrowser_V1_Value = @import("../zig.zig").Guid.initString("EAB22AC3-30C1-11CF-A7EB-0000C05BAE0B");
pub const CLSID_WebBrowser_V1 = &CLSID_WebBrowser_V1_Value;

const CLSID_WebBrowser_Value = @import("../zig.zig").Guid.initString("8856F961-340A-11D0-A96B-00C04FD705A2");
pub const CLSID_WebBrowser = &CLSID_WebBrowser_Value;

const CLSID_InternetExplorer_Value = @import("../zig.zig").Guid.initString("0002DF01-0000-0000-C000-000000000046");
pub const CLSID_InternetExplorer = &CLSID_InternetExplorer_Value;

const CLSID_InternetExplorerMedium_Value = @import("../zig.zig").Guid.initString("D5E8041D-920F-45E9-B8FB-B1DEB82C6E5E");
pub const CLSID_InternetExplorerMedium = &CLSID_InternetExplorerMedium_Value;

const CLSID_ShellBrowserWindow_Value = @import("../zig.zig").Guid.initString("C08AFD90-F2A1-11D1-8455-00A0C91F3880");
pub const CLSID_ShellBrowserWindow = &CLSID_ShellBrowserWindow_Value;

const CLSID_ShellWindows_Value = @import("../zig.zig").Guid.initString("9BA05972-F6A8-11CF-A442-00A0C90A8F39");
pub const CLSID_ShellWindows = &CLSID_ShellWindows_Value;

const CLSID_ShellUIHelper_Value = @import("../zig.zig").Guid.initString("64AB4BB7-111E-11D1-8F79-00C04FC2FBE1");
pub const CLSID_ShellUIHelper = &CLSID_ShellUIHelper_Value;

const CLSID_ShellNameSpace_Value = @import("../zig.zig").Guid.initString("55136805-B2DE-11D1-B9F2-00A0C98BC547");
pub const CLSID_ShellNameSpace = &CLSID_ShellNameSpace_Value;

const CLSID_CScriptErrorList_Value = @import("../zig.zig").Guid.initString("EFD01300-160F-11D2-BB2E-00805FF7EFCA");
pub const CLSID_CScriptErrorList = &CLSID_CScriptErrorList_Value;

pub const CommandStateChangeConstants = extern enum(i32) {
    CSC_UPDATECOMMANDS = -1,
    CSC_NAVIGATEFORWARD = 1,
    CSC_NAVIGATEBACK = 2,
};
pub const CSC_UPDATECOMMANDS = CommandStateChangeConstants.CSC_UPDATECOMMANDS;
pub const CSC_NAVIGATEFORWARD = CommandStateChangeConstants.CSC_NAVIGATEFORWARD;
pub const CSC_NAVIGATEBACK = CommandStateChangeConstants.CSC_NAVIGATEBACK;

pub const SecureLockIconConstants = extern enum(i32) {
    secureLockIconUnsecure = 0,
    secureLockIconMixed = 1,
    secureLockIconSecureUnknownBits = 2,
    secureLockIconSecure40Bit = 3,
    secureLockIconSecure56Bit = 4,
    secureLockIconSecureFortezza = 5,
    secureLockIconSecure128Bit = 6,
};
pub const secureLockIconUnsecure = SecureLockIconConstants.secureLockIconUnsecure;
pub const secureLockIconMixed = SecureLockIconConstants.secureLockIconMixed;
pub const secureLockIconSecureUnknownBits = SecureLockIconConstants.secureLockIconSecureUnknownBits;
pub const secureLockIconSecure40Bit = SecureLockIconConstants.secureLockIconSecure40Bit;
pub const secureLockIconSecure56Bit = SecureLockIconConstants.secureLockIconSecure56Bit;
pub const secureLockIconSecureFortezza = SecureLockIconConstants.secureLockIconSecureFortezza;
pub const secureLockIconSecure128Bit = SecureLockIconConstants.secureLockIconSecure128Bit;

pub const NewProcessCauseConstants = extern enum(i32) {
    ProtectedModeRedirect = 1,
};
pub const ProtectedModeRedirect = NewProcessCauseConstants.ProtectedModeRedirect;

pub const BrowserNavConstants = extern enum(i32) {
    navOpenInNewWindow = 1,
    navNoHistory = 2,
    navNoReadFromCache = 4,
    navNoWriteToCache = 8,
    navAllowAutosearch = 16,
    navBrowserBar = 32,
    navHyperlink = 64,
    navEnforceRestricted = 128,
    navNewWindowsManaged = 256,
    navUntrustedForDownload = 512,
    navTrustedForActiveX = 1024,
    navOpenInNewTab = 2048,
    navOpenInBackgroundTab = 4096,
    navKeepWordWheelText = 8192,
    navVirtualTab = 16384,
    navBlockRedirectsXDomain = 32768,
    navOpenNewForegroundTab = 65536,
    navTravelLogScreenshot = 131072,
    navDeferUnload = 262144,
    navSpeculative = 524288,
    navSuggestNewWindow = 1048576,
    navSuggestNewTab = 2097152,
    navReserved1 = 4194304,
    navHomepageNavigate = 8388608,
    navRefresh = 16777216,
    navHostNavigation = 33554432,
    navReserved2 = 67108864,
    navReserved3 = 134217728,
    navReserved4 = 268435456,
    navReserved5 = 536870912,
    navReserved6 = 1073741824,
    navReserved7 = -2147483648,
};
pub const navOpenInNewWindow = BrowserNavConstants.navOpenInNewWindow;
pub const navNoHistory = BrowserNavConstants.navNoHistory;
pub const navNoReadFromCache = BrowserNavConstants.navNoReadFromCache;
pub const navNoWriteToCache = BrowserNavConstants.navNoWriteToCache;
pub const navAllowAutosearch = BrowserNavConstants.navAllowAutosearch;
pub const navBrowserBar = BrowserNavConstants.navBrowserBar;
pub const navHyperlink = BrowserNavConstants.navHyperlink;
pub const navEnforceRestricted = BrowserNavConstants.navEnforceRestricted;
pub const navNewWindowsManaged = BrowserNavConstants.navNewWindowsManaged;
pub const navUntrustedForDownload = BrowserNavConstants.navUntrustedForDownload;
pub const navTrustedForActiveX = BrowserNavConstants.navTrustedForActiveX;
pub const navOpenInNewTab = BrowserNavConstants.navOpenInNewTab;
pub const navOpenInBackgroundTab = BrowserNavConstants.navOpenInBackgroundTab;
pub const navKeepWordWheelText = BrowserNavConstants.navKeepWordWheelText;
pub const navVirtualTab = BrowserNavConstants.navVirtualTab;
pub const navBlockRedirectsXDomain = BrowserNavConstants.navBlockRedirectsXDomain;
pub const navOpenNewForegroundTab = BrowserNavConstants.navOpenNewForegroundTab;
pub const navTravelLogScreenshot = BrowserNavConstants.navTravelLogScreenshot;
pub const navDeferUnload = BrowserNavConstants.navDeferUnload;
pub const navSpeculative = BrowserNavConstants.navSpeculative;
pub const navSuggestNewWindow = BrowserNavConstants.navSuggestNewWindow;
pub const navSuggestNewTab = BrowserNavConstants.navSuggestNewTab;
pub const navReserved1 = BrowserNavConstants.navReserved1;
pub const navHomepageNavigate = BrowserNavConstants.navHomepageNavigate;
pub const navRefresh = BrowserNavConstants.navRefresh;
pub const navHostNavigation = BrowserNavConstants.navHostNavigation;
pub const navReserved2 = BrowserNavConstants.navReserved2;
pub const navReserved3 = BrowserNavConstants.navReserved3;
pub const navReserved4 = BrowserNavConstants.navReserved4;
pub const navReserved5 = BrowserNavConstants.navReserved5;
pub const navReserved6 = BrowserNavConstants.navReserved6;
pub const navReserved7 = BrowserNavConstants.navReserved7;

pub const RefreshConstants = extern enum(i32) {
    REFRESH_NORMAL = 0,
    REFRESH_IFEXPIRED = 1,
    REFRESH_COMPLETELY = 3,
};
pub const REFRESH_NORMAL = RefreshConstants.REFRESH_NORMAL;
pub const REFRESH_IFEXPIRED = RefreshConstants.REFRESH_IFEXPIRED;
pub const REFRESH_COMPLETELY = RefreshConstants.REFRESH_COMPLETELY;

const IID_IWebBrowser_Value = @import("../zig.zig").Guid.initString("EAB22AC1-30C1-11CF-A7EB-0000C05BAE0B");
pub const IID_IWebBrowser = &IID_IWebBrowser_Value;
pub const IWebBrowser = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GoBack: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoForward: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoHome: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GoSearch: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Navigate: fn(
            self: *const IWebBrowser,
            URL: BSTR,
            Flags: ?*VARIANT,
            TargetFrameName: ?*VARIANT,
            PostData: ?*VARIANT,
            Headers: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh2: fn(
            self: *const IWebBrowser,
            Level: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Stop: fn(
            self: *const IWebBrowser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Application: fn(
            self: *const IWebBrowser,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Parent: fn(
            self: *const IWebBrowser,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Container: fn(
            self: *const IWebBrowser,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Document: fn(
            self: *const IWebBrowser,
            ppDisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TopLevelContainer: fn(
            self: *const IWebBrowser,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Type: fn(
            self: *const IWebBrowser,
            Type: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Left: fn(
            self: *const IWebBrowser,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Left: fn(
            self: *const IWebBrowser,
            Left: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Top: fn(
            self: *const IWebBrowser,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Top: fn(
            self: *const IWebBrowser,
            Top: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Width: fn(
            self: *const IWebBrowser,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Width: fn(
            self: *const IWebBrowser,
            Width: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Height: fn(
            self: *const IWebBrowser,
            pl: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Height: fn(
            self: *const IWebBrowser,
            Height: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_LocationName: fn(
            self: *const IWebBrowser,
            LocationName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_LocationURL: fn(
            self: *const IWebBrowser,
            LocationURL: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Busy: fn(
            self: *const IWebBrowser,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoBack(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoBack(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoForward(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoForward(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoHome(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoHome(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_GoSearch(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).GoSearch(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Navigate(self: *const T, URL: BSTR, Flags: ?*VARIANT, TargetFrameName: ?*VARIANT, PostData: ?*VARIANT, Headers: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Navigate(@ptrCast(*const IWebBrowser, self), URL, Flags, TargetFrameName, PostData, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Refresh(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Refresh2(self: *const T, Level: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Refresh2(@ptrCast(*const IWebBrowser, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_Stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).Stop(@ptrCast(*const IWebBrowser, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Application(self: *const T, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Application(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Parent(self: *const T, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Parent(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Container(self: *const T, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Container(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Document(self: *const T, ppDisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Document(@ptrCast(*const IWebBrowser, self), ppDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_TopLevelContainer(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_TopLevelContainer(@ptrCast(*const IWebBrowser, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Type(self: *const T, Type: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Type(@ptrCast(*const IWebBrowser, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Left(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Left(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Left(self: *const T, Left: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Left(@ptrCast(*const IWebBrowser, self), Left);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Top(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Top(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Top(self: *const T, Top: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Top(@ptrCast(*const IWebBrowser, self), Top);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Width(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Width(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Width(self: *const T, Width: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Width(@ptrCast(*const IWebBrowser, self), Width);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Height(self: *const T, pl: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Height(@ptrCast(*const IWebBrowser, self), pl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_put_Height(self: *const T, Height: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).put_Height(@ptrCast(*const IWebBrowser, self), Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_LocationName(self: *const T, LocationName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_LocationName(@ptrCast(*const IWebBrowser, self), LocationName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_LocationURL(self: *const T, LocationURL: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_LocationURL(@ptrCast(*const IWebBrowser, self), LocationURL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser_get_Busy(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser.VTable, self.vtable).get_Busy(@ptrCast(*const IWebBrowser, self), pBool);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBrowserEvents_Value = @import("../zig.zig").Guid.initString("EAB22AC2-30C1-11CF-A7EB-0000C05BAE0B");
pub const IID_DWebBrowserEvents = &IID_DWebBrowserEvents_Value;
pub const DWebBrowserEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebBrowserApp_Value = @import("../zig.zig").Guid.initString("0002DF05-0000-0000-C000-000000000046");
pub const IID_IWebBrowserApp = &IID_IWebBrowserApp_Value;
pub const IWebBrowserApp = extern struct {
    pub const VTable = extern struct {
        base: IWebBrowser.VTable,
        Quit: fn(
            self: *const IWebBrowserApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClientToWindow: fn(
            self: *const IWebBrowserApp,
            pcx: *i32,
            pcy: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutProperty: fn(
            self: *const IWebBrowserApp,
            Property: BSTR,
            vtValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IWebBrowserApp,
            Property: BSTR,
            pvtValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Name: fn(
            self: *const IWebBrowserApp,
            Name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HWND: fn(
            self: *const IWebBrowserApp,
            pHWND: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FullName: fn(
            self: *const IWebBrowserApp,
            FullName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Path: fn(
            self: *const IWebBrowserApp,
            Path: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Visible: fn(
            self: *const IWebBrowserApp,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Visible: fn(
            self: *const IWebBrowserApp,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_StatusBar: fn(
            self: *const IWebBrowserApp,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_StatusBar: fn(
            self: *const IWebBrowserApp,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_StatusText: fn(
            self: *const IWebBrowserApp,
            StatusText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_StatusText: fn(
            self: *const IWebBrowserApp,
            StatusText: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ToolBar: fn(
            self: *const IWebBrowserApp,
            Value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ToolBar: fn(
            self: *const IWebBrowserApp,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_MenuBar: fn(
            self: *const IWebBrowserApp,
            Value: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_MenuBar: fn(
            self: *const IWebBrowserApp,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FullScreen: fn(
            self: *const IWebBrowserApp,
            pbFullScreen: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_FullScreen: fn(
            self: *const IWebBrowserApp,
            bFullScreen: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWebBrowser.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_Quit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).Quit(@ptrCast(*const IWebBrowserApp, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_ClientToWindow(self: *const T, pcx: *i32, pcy: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).ClientToWindow(@ptrCast(*const IWebBrowserApp, self), pcx, pcy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_PutProperty(self: *const T, Property: BSTR, vtValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).PutProperty(@ptrCast(*const IWebBrowserApp, self), Property, vtValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_GetProperty(self: *const T, Property: BSTR, pvtValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).GetProperty(@ptrCast(*const IWebBrowserApp, self), Property, pvtValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_Name(self: *const T, Name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_Name(@ptrCast(*const IWebBrowserApp, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_HWND(self: *const T, pHWND: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_HWND(@ptrCast(*const IWebBrowserApp, self), pHWND);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_FullName(self: *const T, FullName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_FullName(@ptrCast(*const IWebBrowserApp, self), FullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_Path(self: *const T, Path: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_Path(@ptrCast(*const IWebBrowserApp, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_Visible(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_Visible(@ptrCast(*const IWebBrowserApp, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_Visible(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_Visible(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_StatusBar(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_StatusBar(@ptrCast(*const IWebBrowserApp, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_StatusBar(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_StatusBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_StatusText(self: *const T, StatusText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_StatusText(@ptrCast(*const IWebBrowserApp, self), StatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_StatusText(self: *const T, StatusText: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_StatusText(@ptrCast(*const IWebBrowserApp, self), StatusText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_ToolBar(self: *const T, Value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_ToolBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_ToolBar(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_ToolBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_MenuBar(self: *const T, Value: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_MenuBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_MenuBar(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_MenuBar(@ptrCast(*const IWebBrowserApp, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_get_FullScreen(self: *const T, pbFullScreen: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).get_FullScreen(@ptrCast(*const IWebBrowserApp, self), pbFullScreen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowserApp_put_FullScreen(self: *const T, bFullScreen: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowserApp.VTable, self.vtable).put_FullScreen(@ptrCast(*const IWebBrowserApp, self), bFullScreen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebBrowser2_Value = @import("../zig.zig").Guid.initString("D30C1661-CDAF-11D0-8A3E-00C04FC9E26E");
pub const IID_IWebBrowser2 = &IID_IWebBrowser2_Value;
pub const IWebBrowser2 = extern struct {
    pub const VTable = extern struct {
        base: IWebBrowserApp.VTable,
        Navigate2: fn(
            self: *const IWebBrowser2,
            URL: *VARIANT,
            Flags: ?*VARIANT,
            TargetFrameName: ?*VARIANT,
            PostData: ?*VARIANT,
            Headers: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryStatusWB: fn(
            self: *const IWebBrowser2,
            cmdID: OLECMDID,
            pcmdf: *OLECMDF,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecWB: fn(
            self: *const IWebBrowser2,
            cmdID: OLECMDID,
            cmdexecopt: OLECMDEXECOPT,
            pvaIn: ?*VARIANT,
            pvaOut: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowBrowserBar: fn(
            self: *const IWebBrowser2,
            pvaClsid: *VARIANT,
            pvarShow: ?*VARIANT,
            pvarSize: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ReadyState: fn(
            self: *const IWebBrowser2,
            plReadyState: *READYSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Offline: fn(
            self: *const IWebBrowser2,
            pbOffline: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Offline: fn(
            self: *const IWebBrowser2,
            bOffline: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Silent: fn(
            self: *const IWebBrowser2,
            pbSilent: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Silent: fn(
            self: *const IWebBrowser2,
            bSilent: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_RegisterAsBrowser: fn(
            self: *const IWebBrowser2,
            pbRegister: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_RegisterAsBrowser: fn(
            self: *const IWebBrowser2,
            bRegister: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_RegisterAsDropTarget: fn(
            self: *const IWebBrowser2,
            pbRegister: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_RegisterAsDropTarget: fn(
            self: *const IWebBrowser2,
            bRegister: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TheaterMode: fn(
            self: *const IWebBrowser2,
            pbRegister: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_TheaterMode: fn(
            self: *const IWebBrowser2,
            bRegister: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AddressBar: fn(
            self: *const IWebBrowser2,
            Value: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_AddressBar: fn(
            self: *const IWebBrowser2,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Resizable: fn(
            self: *const IWebBrowser2,
            Value: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Resizable: fn(
            self: *const IWebBrowser2,
            Value: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWebBrowserApp.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_Navigate2(self: *const T, URL: *VARIANT, Flags: ?*VARIANT, TargetFrameName: ?*VARIANT, PostData: ?*VARIANT, Headers: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).Navigate2(@ptrCast(*const IWebBrowser2, self), URL, Flags, TargetFrameName, PostData, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_QueryStatusWB(self: *const T, cmdID: OLECMDID, pcmdf: *OLECMDF) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).QueryStatusWB(@ptrCast(*const IWebBrowser2, self), cmdID, pcmdf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_ExecWB(self: *const T, cmdID: OLECMDID, cmdexecopt: OLECMDEXECOPT, pvaIn: ?*VARIANT, pvaOut: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).ExecWB(@ptrCast(*const IWebBrowser2, self), cmdID, cmdexecopt, pvaIn, pvaOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_ShowBrowserBar(self: *const T, pvaClsid: *VARIANT, pvarShow: ?*VARIANT, pvarSize: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).ShowBrowserBar(@ptrCast(*const IWebBrowser2, self), pvaClsid, pvarShow, pvarSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_ReadyState(self: *const T, plReadyState: *READYSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_ReadyState(@ptrCast(*const IWebBrowser2, self), plReadyState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_Offline(self: *const T, pbOffline: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_Offline(@ptrCast(*const IWebBrowser2, self), pbOffline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_Offline(self: *const T, bOffline: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_Offline(@ptrCast(*const IWebBrowser2, self), bOffline);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_Silent(self: *const T, pbSilent: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_Silent(@ptrCast(*const IWebBrowser2, self), pbSilent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_Silent(self: *const T, bSilent: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_Silent(@ptrCast(*const IWebBrowser2, self), bSilent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_RegisterAsBrowser(self: *const T, pbRegister: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_RegisterAsBrowser(@ptrCast(*const IWebBrowser2, self), pbRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_RegisterAsBrowser(self: *const T, bRegister: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_RegisterAsBrowser(@ptrCast(*const IWebBrowser2, self), bRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_RegisterAsDropTarget(self: *const T, pbRegister: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_RegisterAsDropTarget(@ptrCast(*const IWebBrowser2, self), pbRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_RegisterAsDropTarget(self: *const T, bRegister: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_RegisterAsDropTarget(@ptrCast(*const IWebBrowser2, self), bRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_TheaterMode(self: *const T, pbRegister: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_TheaterMode(@ptrCast(*const IWebBrowser2, self), pbRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_TheaterMode(self: *const T, bRegister: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_TheaterMode(@ptrCast(*const IWebBrowser2, self), bRegister);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_AddressBar(self: *const T, Value: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_AddressBar(@ptrCast(*const IWebBrowser2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_AddressBar(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_AddressBar(@ptrCast(*const IWebBrowser2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_get_Resizable(self: *const T, Value: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).get_Resizable(@ptrCast(*const IWebBrowser2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBrowser2_put_Resizable(self: *const T, Value: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBrowser2.VTable, self.vtable).put_Resizable(@ptrCast(*const IWebBrowser2, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBrowserEvents2_Value = @import("../zig.zig").Guid.initString("34A715A0-6587-11D0-924A-0020AFC7AC4D");
pub const IID_DWebBrowserEvents2 = &IID_DWebBrowserEvents2_Value;
pub const DWebBrowserEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellWindowsEvents_Value = @import("../zig.zig").Guid.initString("FE4106E0-399A-11D0-A48C-00A0C90A8F39");
pub const IID_DShellWindowsEvents = &IID_DShellWindowsEvents_Value;
pub const DShellWindowsEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper_Value = @import("../zig.zig").Guid.initString("729FE2F8-1EA8-11D1-8F85-00C04FC2FBE1");
pub const IID_IShellUIHelper = &IID_IShellUIHelper_Value;
pub const IShellUIHelper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ResetFirstBootMode: fn(
            self: *const IShellUIHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetSafeMode: fn(
            self: *const IShellUIHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RefreshOfflineDesktop: fn(
            self: *const IShellUIHelper,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFavorite: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
            Title: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddChannel: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDesktopComponent: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
            Type: BSTR,
            Left: ?*VARIANT,
            Top: ?*VARIANT,
            Width: ?*VARIANT,
            Height: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSubscribed: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateAndFind: fn(
            self: *const IShellUIHelper,
            URL: BSTR,
            strQuery: BSTR,
            varTargetFrame: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportExportFavorites: fn(
            self: *const IShellUIHelper,
            fImport: i16,
            strImpExpPath: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoCompleteSaveForm: fn(
            self: *const IShellUIHelper,
            Form: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoScan: fn(
            self: *const IShellUIHelper,
            strSearch: BSTR,
            strFailureUrl: BSTR,
            pvarTargetFrame: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AutoCompleteAttach: fn(
            self: *const IShellUIHelper,
            Reserved: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowBrowserUI: fn(
            self: *const IShellUIHelper,
            bstrName: BSTR,
            pvarIn: *VARIANT,
            pvarOut: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ResetFirstBootMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ResetFirstBootMode(@ptrCast(*const IShellUIHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ResetSafeMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ResetSafeMode(@ptrCast(*const IShellUIHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_RefreshOfflineDesktop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).RefreshOfflineDesktop(@ptrCast(*const IShellUIHelper, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AddFavorite(self: *const T, URL: BSTR, Title: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AddFavorite(@ptrCast(*const IShellUIHelper, self), URL, Title);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AddChannel(self: *const T, URL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AddChannel(@ptrCast(*const IShellUIHelper, self), URL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AddDesktopComponent(self: *const T, URL: BSTR, Type: BSTR, Left: ?*VARIANT, Top: ?*VARIANT, Width: ?*VARIANT, Height: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AddDesktopComponent(@ptrCast(*const IShellUIHelper, self), URL, Type, Left, Top, Width, Height);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_IsSubscribed(self: *const T, URL: BSTR, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).IsSubscribed(@ptrCast(*const IShellUIHelper, self), URL, pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_NavigateAndFind(self: *const T, URL: BSTR, strQuery: BSTR, varTargetFrame: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).NavigateAndFind(@ptrCast(*const IShellUIHelper, self), URL, strQuery, varTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ImportExportFavorites(self: *const T, fImport: i16, strImpExpPath: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ImportExportFavorites(@ptrCast(*const IShellUIHelper, self), fImport, strImpExpPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AutoCompleteSaveForm(self: *const T, Form: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AutoCompleteSaveForm(@ptrCast(*const IShellUIHelper, self), Form);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AutoScan(self: *const T, strSearch: BSTR, strFailureUrl: BSTR, pvarTargetFrame: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AutoScan(@ptrCast(*const IShellUIHelper, self), strSearch, strFailureUrl, pvarTargetFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_AutoCompleteAttach(self: *const T, Reserved: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).AutoCompleteAttach(@ptrCast(*const IShellUIHelper, self), Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper_ShowBrowserUI(self: *const T, bstrName: BSTR, pvarIn: *VARIANT, pvarOut: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper.VTable, self.vtable).ShowBrowserUI(@ptrCast(*const IShellUIHelper, self), bstrName, pvarIn, pvarOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper2_Value = @import("../zig.zig").Guid.initString("A7FE6EDA-1932-4281-B881-87B31B8BC52C");
pub const IID_IShellUIHelper2 = &IID_IShellUIHelper2_Value;
pub const IShellUIHelper2 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper.VTable,
        AddSearchProvider: fn(
            self: *const IShellUIHelper2,
            URL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunOnceShown: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SkipRunOnce: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CustomizeSettings: fn(
            self: *const IShellUIHelper2,
            fSQM: i16,
            fPhishing: i16,
            bstrLocale: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SqmEnabled: fn(
            self: *const IShellUIHelper2,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PhishingEnabled: fn(
            self: *const IShellUIHelper2,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BrandImageUri: fn(
            self: *const IShellUIHelper2,
            pbstrUri: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SkipTabsWelcome: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiagnoseConnection: fn(
            self: *const IShellUIHelper2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CustomizeClearType: fn(
            self: *const IShellUIHelper2,
            fSet: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSearchProviderInstalled: fn(
            self: *const IShellUIHelper2,
            URL: BSTR,
            pdwResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSearchMigrated: fn(
            self: *const IShellUIHelper2,
            pfMigrated: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefaultSearchProvider: fn(
            self: *const IShellUIHelper2,
            pbstrName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunOnceRequiredSettingsComplete: fn(
            self: *const IShellUIHelper2,
            fComplete: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RunOnceHasShown: fn(
            self: *const IShellUIHelper2,
            pfShown: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SearchGuideUrl: fn(
            self: *const IShellUIHelper2,
            pbstrUrl: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_AddSearchProvider(self: *const T, URL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).AddSearchProvider(@ptrCast(*const IShellUIHelper2, self), URL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_RunOnceShown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).RunOnceShown(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SkipRunOnce(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SkipRunOnce(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_CustomizeSettings(self: *const T, fSQM: i16, fPhishing: i16, bstrLocale: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).CustomizeSettings(@ptrCast(*const IShellUIHelper2, self), fSQM, fPhishing, bstrLocale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SqmEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SqmEnabled(@ptrCast(*const IShellUIHelper2, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_PhishingEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).PhishingEnabled(@ptrCast(*const IShellUIHelper2, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_BrandImageUri(self: *const T, pbstrUri: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).BrandImageUri(@ptrCast(*const IShellUIHelper2, self), pbstrUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SkipTabsWelcome(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SkipTabsWelcome(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_DiagnoseConnection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).DiagnoseConnection(@ptrCast(*const IShellUIHelper2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_CustomizeClearType(self: *const T, fSet: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).CustomizeClearType(@ptrCast(*const IShellUIHelper2, self), fSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_IsSearchProviderInstalled(self: *const T, URL: BSTR, pdwResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).IsSearchProviderInstalled(@ptrCast(*const IShellUIHelper2, self), URL, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_IsSearchMigrated(self: *const T, pfMigrated: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).IsSearchMigrated(@ptrCast(*const IShellUIHelper2, self), pfMigrated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_DefaultSearchProvider(self: *const T, pbstrName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).DefaultSearchProvider(@ptrCast(*const IShellUIHelper2, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_RunOnceRequiredSettingsComplete(self: *const T, fComplete: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).RunOnceRequiredSettingsComplete(@ptrCast(*const IShellUIHelper2, self), fComplete);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_RunOnceHasShown(self: *const T, pfShown: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).RunOnceHasShown(@ptrCast(*const IShellUIHelper2, self), pfShown);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper2_SearchGuideUrl(self: *const T, pbstrUrl: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper2.VTable, self.vtable).SearchGuideUrl(@ptrCast(*const IShellUIHelper2, self), pbstrUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper3_Value = @import("../zig.zig").Guid.initString("528DF2EC-D419-40BC-9B6D-DCDBF9C1B25D");
pub const IID_IShellUIHelper3 = &IID_IShellUIHelper3_Value;
pub const IShellUIHelper3 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper2.VTable,
        AddService: fn(
            self: *const IShellUIHelper3,
            URL: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsServiceInstalled: fn(
            self: *const IShellUIHelper3,
            URL: BSTR,
            Verb: BSTR,
            pdwResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InPrivateFilteringEnabled: fn(
            self: *const IShellUIHelper3,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddToFavoritesBar: fn(
            self: *const IShellUIHelper3,
            URL: BSTR,
            Title: BSTR,
            Type: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BuildNewTabPage: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRecentlyClosedVisible: fn(
            self: *const IShellUIHelper3,
            fVisible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActivitiesVisible: fn(
            self: *const IShellUIHelper3,
            fVisible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContentDiscoveryReset: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSuggestedSitesEnabled: fn(
            self: *const IShellUIHelper3,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableSuggestedSites: fn(
            self: *const IShellUIHelper3,
            fEnable: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateToSuggestedSites: fn(
            self: *const IShellUIHelper3,
            bstrRelativeUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowTabsHelp: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowInPrivateHelp: fn(
            self: *const IShellUIHelper3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_AddService(self: *const T, URL: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).AddService(@ptrCast(*const IShellUIHelper3, self), URL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_IsServiceInstalled(self: *const T, URL: BSTR, Verb: BSTR, pdwResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).IsServiceInstalled(@ptrCast(*const IShellUIHelper3, self), URL, Verb, pdwResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_InPrivateFilteringEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).InPrivateFilteringEnabled(@ptrCast(*const IShellUIHelper3, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_AddToFavoritesBar(self: *const T, URL: BSTR, Title: BSTR, Type: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).AddToFavoritesBar(@ptrCast(*const IShellUIHelper3, self), URL, Title, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_BuildNewTabPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).BuildNewTabPage(@ptrCast(*const IShellUIHelper3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_SetRecentlyClosedVisible(self: *const T, fVisible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).SetRecentlyClosedVisible(@ptrCast(*const IShellUIHelper3, self), fVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_SetActivitiesVisible(self: *const T, fVisible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).SetActivitiesVisible(@ptrCast(*const IShellUIHelper3, self), fVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_ContentDiscoveryReset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).ContentDiscoveryReset(@ptrCast(*const IShellUIHelper3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_IsSuggestedSitesEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).IsSuggestedSitesEnabled(@ptrCast(*const IShellUIHelper3, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_EnableSuggestedSites(self: *const T, fEnable: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).EnableSuggestedSites(@ptrCast(*const IShellUIHelper3, self), fEnable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_NavigateToSuggestedSites(self: *const T, bstrRelativeUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).NavigateToSuggestedSites(@ptrCast(*const IShellUIHelper3, self), bstrRelativeUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_ShowTabsHelp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).ShowTabsHelp(@ptrCast(*const IShellUIHelper3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper3_ShowInPrivateHelp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper3.VTable, self.vtable).ShowInPrivateHelp(@ptrCast(*const IShellUIHelper3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper4_Value = @import("../zig.zig").Guid.initString("B36E6A53-8073-499E-824C-D776330A333E");
pub const IID_IShellUIHelper4 = &IID_IShellUIHelper4_Value;
pub const IShellUIHelper4 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper3.VTable,
        msIsSiteMode: fn(
            self: *const IShellUIHelper4,
            pfSiteMode: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeShowThumbBar: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeAddThumbBarButton: fn(
            self: *const IShellUIHelper4,
            bstrIconURL: BSTR,
            bstrTooltip: BSTR,
            pvarButtonID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeUpdateThumbBarButton: fn(
            self: *const IShellUIHelper4,
            ButtonID: VARIANT,
            fEnabled: i16,
            fVisible: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeSetIconOverlay: fn(
            self: *const IShellUIHelper4,
            IconUrl: BSTR,
            pvarDescription: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeClearIconOverlay: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msAddSiteMode: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeCreateJumpList: fn(
            self: *const IShellUIHelper4,
            bstrHeader: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeAddJumpListItem: fn(
            self: *const IShellUIHelper4,
            bstrName: BSTR,
            bstrActionUri: BSTR,
            bstrIconUri: BSTR,
            pvarWindowType: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeClearJumpList: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeShowJumpList: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeAddButtonStyle: fn(
            self: *const IShellUIHelper4,
            uiButtonID: VARIANT,
            bstrIconUrl: BSTR,
            bstrTooltip: BSTR,
            pvarStyleID: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeShowButtonStyle: fn(
            self: *const IShellUIHelper4,
            uiButtonID: VARIANT,
            uiStyleID: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeActivate: fn(
            self: *const IShellUIHelper4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msIsSiteModeFirstRun: fn(
            self: *const IShellUIHelper4,
            fPreserveState: i16,
            puiFirstRun: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msAddTrackingProtectionList: fn(
            self: *const IShellUIHelper4,
            URL: BSTR,
            bstrFilterName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msTrackingProtectionEnabled: fn(
            self: *const IShellUIHelper4,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msActiveXFilteringEnabled: fn(
            self: *const IShellUIHelper4,
            pfEnabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msIsSiteMode(self: *const T, pfSiteMode: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msIsSiteMode(@ptrCast(*const IShellUIHelper4, self), pfSiteMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeShowThumbBar(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeShowThumbBar(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeAddThumbBarButton(self: *const T, bstrIconURL: BSTR, bstrTooltip: BSTR, pvarButtonID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeAddThumbBarButton(@ptrCast(*const IShellUIHelper4, self), bstrIconURL, bstrTooltip, pvarButtonID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeUpdateThumbBarButton(self: *const T, ButtonID: VARIANT, fEnabled: i16, fVisible: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeUpdateThumbBarButton(@ptrCast(*const IShellUIHelper4, self), ButtonID, fEnabled, fVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeSetIconOverlay(self: *const T, IconUrl: BSTR, pvarDescription: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeSetIconOverlay(@ptrCast(*const IShellUIHelper4, self), IconUrl, pvarDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeClearIconOverlay(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeClearIconOverlay(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msAddSiteMode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msAddSiteMode(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeCreateJumpList(self: *const T, bstrHeader: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeCreateJumpList(@ptrCast(*const IShellUIHelper4, self), bstrHeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeAddJumpListItem(self: *const T, bstrName: BSTR, bstrActionUri: BSTR, bstrIconUri: BSTR, pvarWindowType: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeAddJumpListItem(@ptrCast(*const IShellUIHelper4, self), bstrName, bstrActionUri, bstrIconUri, pvarWindowType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeClearJumpList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeClearJumpList(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeShowJumpList(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeShowJumpList(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeAddButtonStyle(self: *const T, uiButtonID: VARIANT, bstrIconUrl: BSTR, bstrTooltip: BSTR, pvarStyleID: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeAddButtonStyle(@ptrCast(*const IShellUIHelper4, self), uiButtonID, bstrIconUrl, bstrTooltip, pvarStyleID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeShowButtonStyle(self: *const T, uiButtonID: VARIANT, uiStyleID: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeShowButtonStyle(@ptrCast(*const IShellUIHelper4, self), uiButtonID, uiStyleID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msSiteModeActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msSiteModeActivate(@ptrCast(*const IShellUIHelper4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msIsSiteModeFirstRun(self: *const T, fPreserveState: i16, puiFirstRun: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msIsSiteModeFirstRun(@ptrCast(*const IShellUIHelper4, self), fPreserveState, puiFirstRun);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msAddTrackingProtectionList(self: *const T, URL: BSTR, bstrFilterName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msAddTrackingProtectionList(@ptrCast(*const IShellUIHelper4, self), URL, bstrFilterName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msTrackingProtectionEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msTrackingProtectionEnabled(@ptrCast(*const IShellUIHelper4, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper4_msActiveXFilteringEnabled(self: *const T, pfEnabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper4.VTable, self.vtable).msActiveXFilteringEnabled(@ptrCast(*const IShellUIHelper4, self), pfEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper5_Value = @import("../zig.zig").Guid.initString("A2A08B09-103D-4D3F-B91C-EA455CA82EFA");
pub const IID_IShellUIHelper5 = &IID_IShellUIHelper5_Value;
pub const IShellUIHelper5 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper4.VTable,
        msProvisionNetworks: fn(
            self: *const IShellUIHelper5,
            bstrProvisioningXml: BSTR,
            puiResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msReportSafeUrl: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeRefreshBadge: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSiteModeClearBadge: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msDiagnoseConnectionUILess: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msLaunchNetworkClientHelp: fn(
            self: *const IShellUIHelper5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msChangeDefaultBrowser: fn(
            self: *const IShellUIHelper5,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msProvisionNetworks(self: *const T, bstrProvisioningXml: BSTR, puiResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msProvisionNetworks(@ptrCast(*const IShellUIHelper5, self), bstrProvisioningXml, puiResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msReportSafeUrl(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msReportSafeUrl(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msSiteModeRefreshBadge(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msSiteModeRefreshBadge(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msSiteModeClearBadge(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msSiteModeClearBadge(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msDiagnoseConnectionUILess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msDiagnoseConnectionUILess(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msLaunchNetworkClientHelp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msLaunchNetworkClientHelp(@ptrCast(*const IShellUIHelper5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper5_msChangeDefaultBrowser(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper5.VTable, self.vtable).msChangeDefaultBrowser(@ptrCast(*const IShellUIHelper5, self), fChange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper6_Value = @import("../zig.zig").Guid.initString("987A573E-46EE-4E89-96AB-DDF7F8FDC98C");
pub const IID_IShellUIHelper6 = &IID_IShellUIHelper6_Value;
pub const IShellUIHelper6 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper5.VTable,
        msStopPeriodicTileUpdate: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStartPeriodicTileUpdate: fn(
            self: *const IShellUIHelper6,
            pollingUris: VARIANT,
            startTime: VARIANT,
            uiUpdateRecurrence: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStartPeriodicTileUpdateBatch: fn(
            self: *const IShellUIHelper6,
            pollingUris: VARIANT,
            startTime: VARIANT,
            uiUpdateRecurrence: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msClearTile: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueue: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msPinnedSiteState: fn(
            self: *const IShellUIHelper6,
            pvarSiteState: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueueForSquare150x150: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueueForWide310x150: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msEnableTileNotificationQueueForSquare310x310: fn(
            self: *const IShellUIHelper6,
            fChange: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msScheduledTileNotification: fn(
            self: *const IShellUIHelper6,
            bstrNotificationXml: BSTR,
            bstrNotificationId: BSTR,
            bstrNotificationTag: BSTR,
            startTime: VARIANT,
            expirationTime: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msRemoveScheduledTileNotification: fn(
            self: *const IShellUIHelper6,
            bstrNotificationId: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStartPeriodicBadgeUpdate: fn(
            self: *const IShellUIHelper6,
            pollingUri: BSTR,
            startTime: VARIANT,
            uiUpdateRecurrence: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msStopPeriodicBadgeUpdate: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msLaunchInternetOptions: fn(
            self: *const IShellUIHelper6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper5.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStopPeriodicTileUpdate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStopPeriodicTileUpdate(@ptrCast(*const IShellUIHelper6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStartPeriodicTileUpdate(self: *const T, pollingUris: VARIANT, startTime: VARIANT, uiUpdateRecurrence: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStartPeriodicTileUpdate(@ptrCast(*const IShellUIHelper6, self), pollingUris, startTime, uiUpdateRecurrence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStartPeriodicTileUpdateBatch(self: *const T, pollingUris: VARIANT, startTime: VARIANT, uiUpdateRecurrence: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStartPeriodicTileUpdateBatch(@ptrCast(*const IShellUIHelper6, self), pollingUris, startTime, uiUpdateRecurrence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msClearTile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msClearTile(@ptrCast(*const IShellUIHelper6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueue(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueue(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msPinnedSiteState(self: *const T, pvarSiteState: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msPinnedSiteState(@ptrCast(*const IShellUIHelper6, self), pvarSiteState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueueForSquare150x150(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueueForSquare150x150(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueueForWide310x150(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueueForWide310x150(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msEnableTileNotificationQueueForSquare310x310(self: *const T, fChange: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msEnableTileNotificationQueueForSquare310x310(@ptrCast(*const IShellUIHelper6, self), fChange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msScheduledTileNotification(self: *const T, bstrNotificationXml: BSTR, bstrNotificationId: BSTR, bstrNotificationTag: BSTR, startTime: VARIANT, expirationTime: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msScheduledTileNotification(@ptrCast(*const IShellUIHelper6, self), bstrNotificationXml, bstrNotificationId, bstrNotificationTag, startTime, expirationTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msRemoveScheduledTileNotification(self: *const T, bstrNotificationId: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msRemoveScheduledTileNotification(@ptrCast(*const IShellUIHelper6, self), bstrNotificationId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStartPeriodicBadgeUpdate(self: *const T, pollingUri: BSTR, startTime: VARIANT, uiUpdateRecurrence: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStartPeriodicBadgeUpdate(@ptrCast(*const IShellUIHelper6, self), pollingUri, startTime, uiUpdateRecurrence);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msStopPeriodicBadgeUpdate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msStopPeriodicBadgeUpdate(@ptrCast(*const IShellUIHelper6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper6_msLaunchInternetOptions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper6.VTable, self.vtable).msLaunchInternetOptions(@ptrCast(*const IShellUIHelper6, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper7_Value = @import("../zig.zig").Guid.initString("60E567C8-9573-4AB2-A264-637C6C161CB1");
pub const IID_IShellUIHelper7 = &IID_IShellUIHelper7_Value;
pub const IShellUIHelper7 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper6.VTable,
        SetExperimentalFlag: fn(
            self: *const IShellUIHelper7,
            bstrFlagString: BSTR,
            vfFlag: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExperimentalFlag: fn(
            self: *const IShellUIHelper7,
            bstrFlagString: BSTR,
            vfFlag: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExperimentalValue: fn(
            self: *const IShellUIHelper7,
            bstrValueString: BSTR,
            dwValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExperimentalValue: fn(
            self: *const IShellUIHelper7,
            bstrValueString: BSTR,
            pdwValue: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetAllExperimentalFlagsAndValues: fn(
            self: *const IShellUIHelper7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNeedIEAutoLaunchFlag: fn(
            self: *const IShellUIHelper7,
            bstrUrl: BSTR,
            flag: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNeedIEAutoLaunchFlag: fn(
            self: *const IShellUIHelper7,
            bstrUrl: BSTR,
            flag: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasNeedIEAutoLaunchFlag: fn(
            self: *const IShellUIHelper7,
            bstrUrl: BSTR,
            exists: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LaunchIE: fn(
            self: *const IShellUIHelper7,
            bstrUrl: BSTR,
            automated: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper6.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_SetExperimentalFlag(self: *const T, bstrFlagString: BSTR, vfFlag: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).SetExperimentalFlag(@ptrCast(*const IShellUIHelper7, self), bstrFlagString, vfFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_GetExperimentalFlag(self: *const T, bstrFlagString: BSTR, vfFlag: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).GetExperimentalFlag(@ptrCast(*const IShellUIHelper7, self), bstrFlagString, vfFlag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_SetExperimentalValue(self: *const T, bstrValueString: BSTR, dwValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).SetExperimentalValue(@ptrCast(*const IShellUIHelper7, self), bstrValueString, dwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_GetExperimentalValue(self: *const T, bstrValueString: BSTR, pdwValue: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).GetExperimentalValue(@ptrCast(*const IShellUIHelper7, self), bstrValueString, pdwValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_ResetAllExperimentalFlagsAndValues(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).ResetAllExperimentalFlagsAndValues(@ptrCast(*const IShellUIHelper7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_GetNeedIEAutoLaunchFlag(self: *const T, bstrUrl: BSTR, flag: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).GetNeedIEAutoLaunchFlag(@ptrCast(*const IShellUIHelper7, self), bstrUrl, flag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_SetNeedIEAutoLaunchFlag(self: *const T, bstrUrl: BSTR, flag: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).SetNeedIEAutoLaunchFlag(@ptrCast(*const IShellUIHelper7, self), bstrUrl, flag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_HasNeedIEAutoLaunchFlag(self: *const T, bstrUrl: BSTR, exists: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).HasNeedIEAutoLaunchFlag(@ptrCast(*const IShellUIHelper7, self), bstrUrl, exists);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper7_LaunchIE(self: *const T, bstrUrl: BSTR, automated: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper7.VTable, self.vtable).LaunchIE(@ptrCast(*const IShellUIHelper7, self), bstrUrl, automated);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper8_Value = @import("../zig.zig").Guid.initString("66DEBCF2-05B0-4F07-B49B-B96241A65DB2");
pub const IID_IShellUIHelper8 = &IID_IShellUIHelper8_Value;
pub const IShellUIHelper8 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper7.VTable,
        GetCVListData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCVListLocalData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEMIEListData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEMIEListLocalData: fn(
            self: *const IShellUIHelper8,
            pbstrResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenFavoritesPane: fn(
            self: *const IShellUIHelper8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenFavoritesSettings: fn(
            self: *const IShellUIHelper8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LaunchInHVSI: fn(
            self: *const IShellUIHelper8,
            bstrUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper7.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetCVListData(self: *const T, pbstrResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetCVListData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetCVListLocalData(self: *const T, pbstrResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetCVListLocalData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetEMIEListData(self: *const T, pbstrResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetEMIEListData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_GetEMIEListLocalData(self: *const T, pbstrResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).GetEMIEListLocalData(@ptrCast(*const IShellUIHelper8, self), pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_OpenFavoritesPane(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).OpenFavoritesPane(@ptrCast(*const IShellUIHelper8, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_OpenFavoritesSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).OpenFavoritesSettings(@ptrCast(*const IShellUIHelper8, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper8_LaunchInHVSI(self: *const T, bstrUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper8.VTable, self.vtable).LaunchInHVSI(@ptrCast(*const IShellUIHelper8, self), bstrUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellUIHelper9_Value = @import("../zig.zig").Guid.initString("6CDF73B0-7F2F-451F-BC0F-63E0F3284E54");
pub const IID_IShellUIHelper9 = &IID_IShellUIHelper9_Value;
pub const IShellUIHelper9 = extern struct {
    pub const VTable = extern struct {
        base: IShellUIHelper8.VTable,
        GetOSSku: fn(
            self: *const IShellUIHelper9,
            pdwResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellUIHelper8.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellUIHelper9_GetOSSku(self: *const T, pdwResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellUIHelper9.VTable, self.vtable).GetOSSku(@ptrCast(*const IShellUIHelper9, self), pdwResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DShellNameSpaceEvents_Value = @import("../zig.zig").Guid.initString("55136806-B2DE-11D1-B9F2-00A0C98BC547");
pub const IID_DShellNameSpaceEvents = &IID_DShellNameSpaceEvents_Value;
pub const DShellNameSpaceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellFavoritesNameSpace_Value = @import("../zig.zig").Guid.initString("55136804-B2DE-11D1-B9F2-00A0C98BC547");
pub const IID_IShellFavoritesNameSpace = &IID_IShellFavoritesNameSpace_Value;
pub const IShellFavoritesNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        MoveSelectionUp: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveSelectionDown: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetSort: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NewFolder: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Synchronize: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Import: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Export: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeContextMenuCommand: fn(
            self: *const IShellFavoritesNameSpace,
            strCommand: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveSelectionTo: fn(
            self: *const IShellFavoritesNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_SubscriptionsEnabled: fn(
            self: *const IShellFavoritesNameSpace,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSubscriptionForSelection: fn(
            self: *const IShellFavoritesNameSpace,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSubscriptionForSelection: fn(
            self: *const IShellFavoritesNameSpace,
            pBool: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRoot: fn(
            self: *const IShellFavoritesNameSpace,
            bstrFullPath: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_MoveSelectionUp(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).MoveSelectionUp(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_MoveSelectionDown(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).MoveSelectionDown(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_ResetSort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).ResetSort(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_NewFolder(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).NewFolder(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_Synchronize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).Synchronize(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_Import(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).Import(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_Export(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).Export(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_InvokeContextMenuCommand(self: *const T, strCommand: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).InvokeContextMenuCommand(@ptrCast(*const IShellFavoritesNameSpace, self), strCommand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_MoveSelectionTo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).MoveSelectionTo(@ptrCast(*const IShellFavoritesNameSpace, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_get_SubscriptionsEnabled(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).get_SubscriptionsEnabled(@ptrCast(*const IShellFavoritesNameSpace, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_CreateSubscriptionForSelection(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).CreateSubscriptionForSelection(@ptrCast(*const IShellFavoritesNameSpace, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_DeleteSubscriptionForSelection(self: *const T, pBool: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).DeleteSubscriptionForSelection(@ptrCast(*const IShellFavoritesNameSpace, self), pBool);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellFavoritesNameSpace_SetRoot(self: *const T, bstrFullPath: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellFavoritesNameSpace.VTable, self.vtable).SetRoot(@ptrCast(*const IShellFavoritesNameSpace, self), bstrFullPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IShellNameSpace_Value = @import("../zig.zig").Guid.initString("E572D3C9-37BE-4AE2-825D-D521763E3108");
pub const IID_IShellNameSpace = &IID_IShellNameSpace_Value;
pub const IShellNameSpace = extern struct {
    pub const VTable = extern struct {
        base: IShellFavoritesNameSpace.VTable,
        get_EnumOptions: fn(
            self: *const IShellNameSpace,
            pgrfEnumFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_EnumOptions: fn(
            self: *const IShellNameSpace,
            lVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_SelectedItem: fn(
            self: *const IShellNameSpace,
            pItem: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_SelectedItem: fn(
            self: *const IShellNameSpace,
            pItem: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Root: fn(
            self: *const IShellNameSpace,
            pvar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Root: fn(
            self: *const IShellNameSpace,
            @"var": VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Depth: fn(
            self: *const IShellNameSpace,
            piDepth: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Depth: fn(
            self: *const IShellNameSpace,
            iDepth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Mode: fn(
            self: *const IShellNameSpace,
            puMode: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Mode: fn(
            self: *const IShellNameSpace,
            uMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Flags: fn(
            self: *const IShellNameSpace,
            pdwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Flags: fn(
            self: *const IShellNameSpace,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_TVFlags: fn(
            self: *const IShellNameSpace,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TVFlags: fn(
            self: *const IShellNameSpace,
            dwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Columns: fn(
            self: *const IShellNameSpace,
            bstrColumns: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Columns: fn(
            self: *const IShellNameSpace,
            bstrColumns: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CountViewTypes: fn(
            self: *const IShellNameSpace,
            piTypes: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetViewType: fn(
            self: *const IShellNameSpace,
            iType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectedItems: fn(
            self: *const IShellNameSpace,
            ppid: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Expand: fn(
            self: *const IShellNameSpace,
            @"var": VARIANT,
            iDepth: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnselectAll: fn(
            self: *const IShellNameSpace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IShellFavoritesNameSpace.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_EnumOptions(self: *const T, pgrfEnumFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_EnumOptions(@ptrCast(*const IShellNameSpace, self), pgrfEnumFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_EnumOptions(self: *const T, lVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_EnumOptions(@ptrCast(*const IShellNameSpace, self), lVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_SelectedItem(self: *const T, pItem: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_SelectedItem(@ptrCast(*const IShellNameSpace, self), pItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_SelectedItem(self: *const T, pItem: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_SelectedItem(@ptrCast(*const IShellNameSpace, self), pItem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Root(self: *const T, pvar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Root(@ptrCast(*const IShellNameSpace, self), pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Root(self: *const T, @"var": VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Root(@ptrCast(*const IShellNameSpace, self), @"var");
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Depth(self: *const T, piDepth: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Depth(@ptrCast(*const IShellNameSpace, self), piDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Depth(self: *const T, iDepth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Depth(@ptrCast(*const IShellNameSpace, self), iDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Mode(self: *const T, puMode: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Mode(@ptrCast(*const IShellNameSpace, self), puMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Mode(self: *const T, uMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Mode(@ptrCast(*const IShellNameSpace, self), uMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Flags(self: *const T, pdwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Flags(@ptrCast(*const IShellNameSpace, self), pdwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Flags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Flags(@ptrCast(*const IShellNameSpace, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_TVFlags(self: *const T, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_TVFlags(@ptrCast(*const IShellNameSpace, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_TVFlags(self: *const T, dwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_TVFlags(@ptrCast(*const IShellNameSpace, self), dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_Columns(self: *const T, bstrColumns: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_Columns(@ptrCast(*const IShellNameSpace, self), bstrColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_put_Columns(self: *const T, bstrColumns: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).put_Columns(@ptrCast(*const IShellNameSpace, self), bstrColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_get_CountViewTypes(self: *const T, piTypes: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).get_CountViewTypes(@ptrCast(*const IShellNameSpace, self), piTypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_SetViewType(self: *const T, iType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).SetViewType(@ptrCast(*const IShellNameSpace, self), iType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_SelectedItems(self: *const T, ppid: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).SelectedItems(@ptrCast(*const IShellNameSpace, self), ppid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_Expand(self: *const T, @"var": VARIANT, iDepth: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).Expand(@ptrCast(*const IShellNameSpace, self), @"var", iDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IShellNameSpace_UnselectAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IShellNameSpace.VTable, self.vtable).UnselectAll(@ptrCast(*const IShellNameSpace, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptErrorList_Value = @import("../zig.zig").Guid.initString("F3470F24-15FD-11D2-BB2E-00805FF7EFCA");
pub const IID_IScriptErrorList = &IID_IScriptErrorList_Value;
pub const IScriptErrorList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        advanceError: fn(
            self: *const IScriptErrorList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        retreatError: fn(
            self: *const IScriptErrorList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        canAdvanceError: fn(
            self: *const IScriptErrorList,
            pfCanAdvance: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        canRetreatError: fn(
            self: *const IScriptErrorList,
            pfCanRetreat: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorLine: fn(
            self: *const IScriptErrorList,
            plLine: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorChar: fn(
            self: *const IScriptErrorList,
            plChar: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorCode: fn(
            self: *const IScriptErrorList,
            plCode: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorMsg: fn(
            self: *const IScriptErrorList,
            pstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getErrorUrl: fn(
            self: *const IScriptErrorList,
            pstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAlwaysShowLockState: fn(
            self: *const IScriptErrorList,
            pfAlwaysShowLocked: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getDetailsPaneOpen: fn(
            self: *const IScriptErrorList,
            pfDetailsPaneOpen: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setDetailsPaneOpen: fn(
            self: *const IScriptErrorList,
            fDetailsPaneOpen: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPerErrorDisplay: fn(
            self: *const IScriptErrorList,
            pfPerErrorDisplay: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setPerErrorDisplay: fn(
            self: *const IScriptErrorList,
            fPerErrorDisplay: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_advanceError(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).advanceError(@ptrCast(*const IScriptErrorList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_retreatError(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).retreatError(@ptrCast(*const IScriptErrorList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_canAdvanceError(self: *const T, pfCanAdvance: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).canAdvanceError(@ptrCast(*const IScriptErrorList, self), pfCanAdvance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_canRetreatError(self: *const T, pfCanRetreat: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).canRetreatError(@ptrCast(*const IScriptErrorList, self), pfCanRetreat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorLine(self: *const T, plLine: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorLine(@ptrCast(*const IScriptErrorList, self), plLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorChar(self: *const T, plChar: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorChar(@ptrCast(*const IScriptErrorList, self), plChar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorCode(self: *const T, plCode: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorCode(@ptrCast(*const IScriptErrorList, self), plCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorMsg(self: *const T, pstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorMsg(@ptrCast(*const IScriptErrorList, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getErrorUrl(self: *const T, pstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getErrorUrl(@ptrCast(*const IScriptErrorList, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getAlwaysShowLockState(self: *const T, pfAlwaysShowLocked: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getAlwaysShowLockState(@ptrCast(*const IScriptErrorList, self), pfAlwaysShowLocked);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getDetailsPaneOpen(self: *const T, pfDetailsPaneOpen: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getDetailsPaneOpen(@ptrCast(*const IScriptErrorList, self), pfDetailsPaneOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_setDetailsPaneOpen(self: *const T, fDetailsPaneOpen: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).setDetailsPaneOpen(@ptrCast(*const IScriptErrorList, self), fDetailsPaneOpen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_getPerErrorDisplay(self: *const T, pfPerErrorDisplay: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).getPerErrorDisplay(@ptrCast(*const IScriptErrorList, self), pfPerErrorDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptErrorList_setPerErrorDisplay(self: *const T, fPerErrorDisplay: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptErrorList.VTable, self.vtable).setPerErrorDisplay(@ptrCast(*const IScriptErrorList, self), fPerErrorDisplay);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const JAVA_TRUST = extern struct {
    cbSize: u32,
    flag: u32,
    fAllActiveXPermissions: BOOL,
    fAllPermissions: BOOL,
    dwEncodingType: u32,
    pbJavaPermissions: *u8,
    cbJavaPermissions: u32,
    pbSigner: *u8,
    cbSigner: u32,
    pwszZone: [*:0]const u16,
    guidZone: Guid,
    hVerify: HRESULT,
};

const CLSID_IsolatedAppLauncher_Value = @import("../zig.zig").Guid.initString("BC812430-E75E-4FD1-9641-1F9F1E2D9A1F");
pub const CLSID_IsolatedAppLauncher = &CLSID_IsolatedAppLauncher_Value;

pub const IsolatedAppLauncherTelemetryParameters = extern struct {
    EnableForLaunch: BOOL,
    CorrelationGUID: Guid,
};

const IID_IIsolatedAppLauncher_Value = @import("../zig.zig").Guid.initString("F686878F-7B42-4CC4-96FB-F4F3B6E3D24D");
pub const IID_IIsolatedAppLauncher = &IID_IIsolatedAppLauncher_Value;
pub const IIsolatedAppLauncher = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Launch: fn(
            self: *const IIsolatedAppLauncher,
            appUserModelId: [*:0]const u16,
            arguments: [*:0]const u16,
            telemetryParameters: *const IsolatedAppLauncherTelemetryParameters,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIsolatedAppLauncher_Launch(self: *const T, appUserModelId: [*:0]const u16, arguments: [*:0]const u16, telemetryParameters: *const IsolatedAppLauncherTelemetryParameters) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIsolatedAppLauncher.VTable, self.vtable).Launch(@ptrCast(*const IIsolatedAppLauncher, self), appUserModelId, arguments, telemetryParameters);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_WSCProductList_Value = @import("../zig.zig").Guid.initString("17072F7B-9ABE-4A74-A261-1EB76B55107A");
pub const CLSID_WSCProductList = &CLSID_WSCProductList_Value;

const CLSID_WSCDefaultProduct_Value = @import("../zig.zig").Guid.initString("2981A36E-F22D-11E5-9CE9-5E5517507C66");
pub const CLSID_WSCDefaultProduct = &CLSID_WSCDefaultProduct_Value;

pub const WSC_SECURITY_PRODUCT_SUBSTATUS = extern enum(i32) {
    NOT_SET = 0,
    NO_ACTION = 1,
    ACTION_RECOMMENDED = 2,
    ACTION_NEEDED = 3,
};
pub const WSC_SECURITY_PRODUCT_SUBSTATUS_NOT_SET = WSC_SECURITY_PRODUCT_SUBSTATUS.NOT_SET;
pub const WSC_SECURITY_PRODUCT_SUBSTATUS_NO_ACTION = WSC_SECURITY_PRODUCT_SUBSTATUS.NO_ACTION;
pub const WSC_SECURITY_PRODUCT_SUBSTATUS_ACTION_RECOMMENDED = WSC_SECURITY_PRODUCT_SUBSTATUS.ACTION_RECOMMENDED;
pub const WSC_SECURITY_PRODUCT_SUBSTATUS_ACTION_NEEDED = WSC_SECURITY_PRODUCT_SUBSTATUS.ACTION_NEEDED;

pub const WSC_SECURITY_PRODUCT_STATE = extern enum(i32) {
    ON = 0,
    OFF = 1,
    SNOOZED = 2,
    EXPIRED = 3,
};
pub const WSC_SECURITY_PRODUCT_STATE_ON = WSC_SECURITY_PRODUCT_STATE.ON;
pub const WSC_SECURITY_PRODUCT_STATE_OFF = WSC_SECURITY_PRODUCT_STATE.OFF;
pub const WSC_SECURITY_PRODUCT_STATE_SNOOZED = WSC_SECURITY_PRODUCT_STATE.SNOOZED;
pub const WSC_SECURITY_PRODUCT_STATE_EXPIRED = WSC_SECURITY_PRODUCT_STATE.EXPIRED;

pub const SECURITY_PRODUCT_TYPE = extern enum(i32) {
    ANTIVIRUS = 0,
    FIREWALL = 1,
    ANTISPYWARE = 2,
};
pub const SECURITY_PRODUCT_TYPE_ANTIVIRUS = SECURITY_PRODUCT_TYPE.ANTIVIRUS;
pub const SECURITY_PRODUCT_TYPE_FIREWALL = SECURITY_PRODUCT_TYPE.FIREWALL;
pub const SECURITY_PRODUCT_TYPE_ANTISPYWARE = SECURITY_PRODUCT_TYPE.ANTISPYWARE;

pub const WSC_SECURITY_SIGNATURE_STATUS = extern enum(i32) {
    WSC_SECURITY_PRODUCT_OUT_OF_DATE = 0,
    WSC_SECURITY_PRODUCT_UP_TO_DATE = 1,
};
pub const WSC_SECURITY_PRODUCT_OUT_OF_DATE = WSC_SECURITY_SIGNATURE_STATUS.WSC_SECURITY_PRODUCT_OUT_OF_DATE;
pub const WSC_SECURITY_PRODUCT_UP_TO_DATE = WSC_SECURITY_SIGNATURE_STATUS.WSC_SECURITY_PRODUCT_UP_TO_DATE;

const IID_IWscProduct_Value = @import("../zig.zig").Guid.initString("8C38232E-3A45-4A27-92B0-1A16A975F669");
pub const IID_IWscProduct = &IID_IWscProduct_Value;
pub const IWscProduct = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_ProductName: fn(
            self: *const IWscProduct,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ProductState: fn(
            self: *const IWscProduct,
            pVal: *WSC_SECURITY_PRODUCT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_SignatureStatus: fn(
            self: *const IWscProduct,
            pVal: *WSC_SECURITY_SIGNATURE_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_RemediationPath: fn(
            self: *const IWscProduct,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ProductStateTimestamp: fn(
            self: *const IWscProduct,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ProductGuid: fn(
            self: *const IWscProduct,
            pVal: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ProductIsDefault: fn(
            self: *const IWscProduct,
            pVal: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductName(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductName(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductState(self: *const T, pVal: *WSC_SECURITY_PRODUCT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductState(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_SignatureStatus(self: *const T, pVal: *WSC_SECURITY_SIGNATURE_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_SignatureStatus(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_RemediationPath(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_RemediationPath(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductStateTimestamp(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductStateTimestamp(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductGuid(self: *const T, pVal: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductGuid(@ptrCast(*const IWscProduct, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct_get_ProductIsDefault(self: *const T, pVal: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct.VTable, self.vtable).get_ProductIsDefault(@ptrCast(*const IWscProduct, self), pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWscProduct2_Value = @import("../zig.zig").Guid.initString("F896CA54-FE09-4403-86D4-23CB488D81D8");
pub const IID_IWscProduct2 = &IID_IWscProduct2_Value;
pub const IWscProduct2 = extern struct {
    pub const VTable = extern struct {
        base: IWscProduct.VTable,
        get_AntivirusScanSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AntivirusSettingsSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AntivirusProtectionUpdateSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FirewallDomainProfileSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FirewallPrivateProfileSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FirewallPublicProfileSubstatus: fn(
            self: *const IWscProduct2,
            peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWscProduct.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_AntivirusScanSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_AntivirusScanSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_AntivirusSettingsSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_AntivirusSettingsSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_AntivirusProtectionUpdateSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_AntivirusProtectionUpdateSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_FirewallDomainProfileSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_FirewallDomainProfileSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_FirewallPrivateProfileSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_FirewallPrivateProfileSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct2_get_FirewallPublicProfileSubstatus(self: *const T, peStatus: *WSC_SECURITY_PRODUCT_SUBSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct2.VTable, self.vtable).get_FirewallPublicProfileSubstatus(@ptrCast(*const IWscProduct2, self), peStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWscProduct3_Value = @import("../zig.zig").Guid.initString("55536524-D1D1-4726-8C7C-04996A1904E7");
pub const IID_IWscProduct3 = &IID_IWscProduct3_Value;
pub const IWscProduct3 = extern struct {
    pub const VTable = extern struct {
        base: IWscProduct2.VTable,
        get_AntivirusDaysUntilExpired: fn(
            self: *const IWscProduct3,
            pdwDays: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWscProduct2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWscProduct3_get_AntivirusDaysUntilExpired(self: *const T, pdwDays: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWscProduct3.VTable, self.vtable).get_AntivirusDaysUntilExpired(@ptrCast(*const IWscProduct3, self), pdwDays);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSCProductList_Value = @import("../zig.zig").Guid.initString("722A338C-6E8E-4E72-AC27-1417FB0C81C2");
pub const IID_IWSCProductList = &IID_IWSCProductList_Value;
pub const IWSCProductList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Initialize: fn(
            self: *const IWSCProductList,
            provider: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Count: fn(
            self: *const IWSCProductList,
            pVal: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Item: fn(
            self: *const IWSCProductList,
            index: u32,
            pVal: **IWscProduct,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSCProductList_Initialize(self: *const T, provider: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSCProductList.VTable, self.vtable).Initialize(@ptrCast(*const IWSCProductList, self), provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSCProductList_get_Count(self: *const T, pVal: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSCProductList.VTable, self.vtable).get_Count(@ptrCast(*const IWSCProductList, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSCProductList_get_Item(self: *const T, index: u32, pVal: **IWscProduct) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSCProductList.VTable, self.vtable).get_Item(@ptrCast(*const IWSCProductList, self), index, pVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSCDefaultProduct_Value = @import("../zig.zig").Guid.initString("0476D69C-F21A-11E5-9CE9-5E5517507C66");
pub const IID_IWSCDefaultProduct = &IID_IWSCDefaultProduct_Value;
pub const IWSCDefaultProduct = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        SetDefaultProduct: fn(
            self: *const IWSCDefaultProduct,
            eType: SECURITY_PRODUCT_TYPE,
            pGuid: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSCDefaultProduct_SetDefaultProduct(self: *const T, eType: SECURITY_PRODUCT_TYPE, pGuid: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSCDefaultProduct.VTable, self.vtable).SetDefaultProduct(@ptrCast(*const IWSCDefaultProduct, self), eType, pGuid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const WSC_SECURITY_PROVIDER = extern enum(i32) {
    FIREWALL = 1,
    AUTOUPDATE_SETTINGS = 2,
    ANTIVIRUS = 4,
    ANTISPYWARE = 8,
    INTERNET_SETTINGS = 16,
    USER_ACCOUNT_CONTROL = 32,
    SERVICE = 64,
    NONE = 0,
    ALL = 127,
};
pub const WSC_SECURITY_PROVIDER_FIREWALL = WSC_SECURITY_PROVIDER.FIREWALL;
pub const WSC_SECURITY_PROVIDER_AUTOUPDATE_SETTINGS = WSC_SECURITY_PROVIDER.AUTOUPDATE_SETTINGS;
pub const WSC_SECURITY_PROVIDER_ANTIVIRUS = WSC_SECURITY_PROVIDER.ANTIVIRUS;
pub const WSC_SECURITY_PROVIDER_ANTISPYWARE = WSC_SECURITY_PROVIDER.ANTISPYWARE;
pub const WSC_SECURITY_PROVIDER_INTERNET_SETTINGS = WSC_SECURITY_PROVIDER.INTERNET_SETTINGS;
pub const WSC_SECURITY_PROVIDER_USER_ACCOUNT_CONTROL = WSC_SECURITY_PROVIDER.USER_ACCOUNT_CONTROL;
pub const WSC_SECURITY_PROVIDER_SERVICE = WSC_SECURITY_PROVIDER.SERVICE;
pub const WSC_SECURITY_PROVIDER_NONE = WSC_SECURITY_PROVIDER.NONE;
pub const WSC_SECURITY_PROVIDER_ALL = WSC_SECURITY_PROVIDER.ALL;

pub const WSC_SECURITY_PROVIDER_HEALTH = extern enum(i32) {
    GOOD = 0,
    NOTMONITORED = 1,
    POOR = 2,
    SNOOZE = 3,
};
pub const WSC_SECURITY_PROVIDER_HEALTH_GOOD = WSC_SECURITY_PROVIDER_HEALTH.GOOD;
pub const WSC_SECURITY_PROVIDER_HEALTH_NOTMONITORED = WSC_SECURITY_PROVIDER_HEALTH.NOTMONITORED;
pub const WSC_SECURITY_PROVIDER_HEALTH_POOR = WSC_SECURITY_PROVIDER_HEALTH.POOR;
pub const WSC_SECURITY_PROVIDER_HEALTH_SNOOZE = WSC_SECURITY_PROVIDER_HEALTH.SNOOZE;

pub const PFN_IO_COMPLETION = fn(
    pContext: *FIO_CONTEXT,
    lpo: *FH_OVERLAPPED,
    cb: u32,
    dwCompletionStatus: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const FH_OVERLAPPED = extern struct {
    Internal: ?*c_void,
    InternalHigh: ?*c_void,
    Offset: u32,
    OffsetHigh: u32,
    hEvent: HANDLE,
    pfnCompletion: PFN_IO_COMPLETION,
    Reserved1: ?*c_void,
    Reserved2: ?*c_void,
    Reserved3: ?*c_void,
    Reserved4: ?*c_void,
};

pub const FIO_CONTEXT = extern struct {
    m_dwTempHack: u32,
    m_dwSignature: u32,
    m_hFile: HANDLE,
    m_dwLinesOffset: u32,
    m_dwHeaderLength: u32,
};

pub const FCACHE_CREATE_CALLBACK = fn(
    lpstrName: PSTR,
    lpvData: *c_void,
    cbFileSize: *u32,
    cbFileSizeHigh: *u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const FCACHE_RICHCREATE_CALLBACK = fn(
    lpstrName: PSTR,
    lpvData: *c_void,
    cbFileSize: *u32,
    cbFileSizeHigh: *u32,
    pfDidWeScanIt: *BOOL,
    pfIsStuffed: *BOOL,
    pfStoredWithDots: *BOOL,
    pfStoredWithTerminatingDot: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const CACHE_KEY_COMPARE = fn(
    cbKey1: u32,
    lpbKey1: *u8,
    cbKey2: u32,
    lpbKey2: *u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CACHE_KEY_HASH = fn(
    lpbKey: *u8,
    cbKey: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const CACHE_READ_CALLBACK = fn(
    cb: u32,
    lpb: *u8,
    lpvContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CACHE_DESTROY_CALLBACK = fn(
    cb: u32,
    lpb: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const CACHE_ACCESS_CHECK = fn(
    pSecurityDescriptor: *c_void,
    hClientToken: HANDLE,
    dwDesiredAccess: u32,
    GenericMapping: *GENERIC_MAPPING,
    PrivilegeSet: *PRIVILEGE_SET,
    PrivilegeSetLength: *u32,
    GrantedAccess: *u32,
    AccessStatus: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const NAME_CACHE_CONTEXT = extern struct {
    m_dwSignature: u32,
};

pub const TDIEntityID = extern struct {
    tei_entity: u32,
    tei_instance: u32,
};

pub const TDIObjectID = extern struct {
    toi_entity: TDIEntityID,
    toi_class: u32,
    toi_type: u32,
    toi_id: u32,
};

pub const tcp_request_query_information_ex_xp = extern struct {
    ID: TDIObjectID,
    Context: [4]?*c_void,
};

pub const tcp_request_query_information_ex_w2k = extern struct {
    ID: TDIObjectID,
    Context: [16]u8,
};

pub const tcp_request_set_information_ex = extern struct {
    ID: TDIObjectID,
    BufferSize: u32,
    Buffer: [1]u8,
};

pub const TDI_TL_IO_CONTROL_TYPE = extern enum(i32) {
    EndpointIoControlType = 0,
    SetSockOptIoControlType = 1,
    GetSockOptIoControlType = 2,
    SocketIoControlType = 3,
};
pub const EndpointIoControlType = TDI_TL_IO_CONTROL_TYPE.EndpointIoControlType;
pub const SetSockOptIoControlType = TDI_TL_IO_CONTROL_TYPE.SetSockOptIoControlType;
pub const GetSockOptIoControlType = TDI_TL_IO_CONTROL_TYPE.GetSockOptIoControlType;
pub const SocketIoControlType = TDI_TL_IO_CONTROL_TYPE.SocketIoControlType;

pub const TDI_TL_IO_CONTROL_ENDPOINT = extern struct {
    Type: TDI_TL_IO_CONTROL_TYPE,
    Level: u32,
    Anonymous: TDI_TL_IO_CONTROL_ENDPOINT._Anonymous_e__Union,
    InputBuffer: *c_void,
    InputBufferLength: u32,
    OutputBuffer: *c_void,
    OutputBufferLength: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const WLDP_HOST = extern enum(i32) {
    RUNDLL32 = 0,
    SVCHOST = 1,
    MAX = 2,
};
pub const WLDP_HOST_RUNDLL32 = WLDP_HOST.RUNDLL32;
pub const WLDP_HOST_SVCHOST = WLDP_HOST.SVCHOST;
pub const WLDP_HOST_MAX = WLDP_HOST.MAX;

pub const WLDP_HOST_ID = extern enum(i32) {
    UNKNOWN = 0,
    GLOBAL = 1,
    VBA = 2,
    WSH = 3,
    POWERSHELL = 4,
    IE = 5,
    MSI = 6,
    ALL = 7,
    MAX = 8,
};
pub const WLDP_HOST_ID_UNKNOWN = WLDP_HOST_ID.UNKNOWN;
pub const WLDP_HOST_ID_GLOBAL = WLDP_HOST_ID.GLOBAL;
pub const WLDP_HOST_ID_VBA = WLDP_HOST_ID.VBA;
pub const WLDP_HOST_ID_WSH = WLDP_HOST_ID.WSH;
pub const WLDP_HOST_ID_POWERSHELL = WLDP_HOST_ID.POWERSHELL;
pub const WLDP_HOST_ID_IE = WLDP_HOST_ID.IE;
pub const WLDP_HOST_ID_MSI = WLDP_HOST_ID.MSI;
pub const WLDP_HOST_ID_ALL = WLDP_HOST_ID.ALL;
pub const WLDP_HOST_ID_MAX = WLDP_HOST_ID.MAX;

pub const DECISION_LOCATION = extern enum(i32) {
    REFRESH_GLOBAL_DATA = 0,
    PARAMETER_VALIDATION = 1,
    AUDIT = 2,
    FAILED_CONVERT_GUID = 3,
    ENTERPRISE_DEFINED_CLASS_ID = 4,
    GLOBAL_BUILT_IN_LIST = 5,
    PROVIDER_BUILT_IN_LIST = 6,
    ENFORCE_STATE_LIST = 7,
    NOT_FOUND = 8,
    UNKNOWN = 9,
};
pub const DECISION_LOCATION_REFRESH_GLOBAL_DATA = DECISION_LOCATION.REFRESH_GLOBAL_DATA;
pub const DECISION_LOCATION_PARAMETER_VALIDATION = DECISION_LOCATION.PARAMETER_VALIDATION;
pub const DECISION_LOCATION_AUDIT = DECISION_LOCATION.AUDIT;
pub const DECISION_LOCATION_FAILED_CONVERT_GUID = DECISION_LOCATION.FAILED_CONVERT_GUID;
pub const DECISION_LOCATION_ENTERPRISE_DEFINED_CLASS_ID = DECISION_LOCATION.ENTERPRISE_DEFINED_CLASS_ID;
pub const DECISION_LOCATION_GLOBAL_BUILT_IN_LIST = DECISION_LOCATION.GLOBAL_BUILT_IN_LIST;
pub const DECISION_LOCATION_PROVIDER_BUILT_IN_LIST = DECISION_LOCATION.PROVIDER_BUILT_IN_LIST;
pub const DECISION_LOCATION_ENFORCE_STATE_LIST = DECISION_LOCATION.ENFORCE_STATE_LIST;
pub const DECISION_LOCATION_NOT_FOUND = DECISION_LOCATION.NOT_FOUND;
pub const DECISION_LOCATION_UNKNOWN = DECISION_LOCATION.UNKNOWN;

pub const WLDP_KEY = extern enum(i32) {
    KEY_UNKNOWN = 0,
    KEY_OVERRIDE = 1,
    KEY_ALL_KEYS = 2,
};
pub const KEY_UNKNOWN = WLDP_KEY.KEY_UNKNOWN;
pub const KEY_OVERRIDE = WLDP_KEY.KEY_OVERRIDE;
pub const KEY_ALL_KEYS = WLDP_KEY.KEY_ALL_KEYS;

pub const VALUENAME = extern enum(i32) {
    UNKNOWN = 0,
    ENTERPRISE_DEFINED_CLASS_ID = 1,
    BUILT_IN_LIST = 2,
};
pub const VALUENAME_UNKNOWN = VALUENAME.UNKNOWN;
pub const VALUENAME_ENTERPRISE_DEFINED_CLASS_ID = VALUENAME.ENTERPRISE_DEFINED_CLASS_ID;
pub const VALUENAME_BUILT_IN_LIST = VALUENAME.BUILT_IN_LIST;

pub const WLDP_WINDOWS_LOCKDOWN_MODE = extern enum(i32) {
    UNLOCKED = 0,
    TRIAL = 1,
    LOCKED = 2,
    MAX = 3,
};
pub const WLDP_WINDOWS_LOCKDOWN_MODE_UNLOCKED = WLDP_WINDOWS_LOCKDOWN_MODE.UNLOCKED;
pub const WLDP_WINDOWS_LOCKDOWN_MODE_TRIAL = WLDP_WINDOWS_LOCKDOWN_MODE.TRIAL;
pub const WLDP_WINDOWS_LOCKDOWN_MODE_LOCKED = WLDP_WINDOWS_LOCKDOWN_MODE.LOCKED;
pub const WLDP_WINDOWS_LOCKDOWN_MODE_MAX = WLDP_WINDOWS_LOCKDOWN_MODE.MAX;

pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION = extern enum(i32) {
    NONE = 0,
    NOUNLOCK = 1,
    NOUNLOCK_PERMANENT = 2,
    MAX = 3,
};
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_NONE = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.NONE;
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_NOUNLOCK = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.NOUNLOCK;
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_NOUNLOCK_PERMANENT = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.NOUNLOCK_PERMANENT;
pub const WLDP_WINDOWS_LOCKDOWN_RESTRICTION_MAX = WLDP_WINDOWS_LOCKDOWN_RESTRICTION.MAX;

pub const WLDP_HOST_INFORMATION = extern struct {
    dwRevision: u32,
    dwHostId: WLDP_HOST_ID,
    szSource: [*:0]const u16,
    hSource: HANDLE,
};

pub const PWLDP_SETDYNAMICCODETRUST_API = fn(
    hFileHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_ISDYNAMICCODEPOLICYENABLED_API = fn(
    pbEnabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_QUERYDYNAMICODETRUST_API = fn(
    fileHandle: HANDLE,
    baseImage: ?[*]u8,
    imageSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_QUERYWINDOWSLOCKDOWNMODE_API = fn(
    lockdownMode: *WLDP_WINDOWS_LOCKDOWN_MODE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_QUERYWINDOWSLOCKDOWNRESTRICTION_API = fn(
    LockdownRestriction: *WLDP_WINDOWS_LOCKDOWN_RESTRICTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_SETWINDOWSLOCKDOWNRESTRICTION_API = fn(
    LockdownRestriction: WLDP_WINDOWS_LOCKDOWN_RESTRICTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PWLDP_WLDPISAPPAPPROVEDBYPOLICY_API = fn(
    PackageFamilyName: [*:0]const u16,
    PackageVersion: u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const XmlNodeType = extern enum(i32) {
    None = 0,
    Element = 1,
    Attribute = 2,
    Text = 3,
    CDATA = 4,
    ProcessingInstruction = 7,
    Comment = 8,
    DocumentType = 10,
    Whitespace = 13,
    EndElement = 15,
    XmlDeclaration = 17,
    _XmlNodeType_Last = 17,
};
pub const XmlNodeType_None = XmlNodeType.None;
pub const XmlNodeType_Element = XmlNodeType.Element;
pub const XmlNodeType_Attribute = XmlNodeType.Attribute;
pub const XmlNodeType_Text = XmlNodeType.Text;
pub const XmlNodeType_CDATA = XmlNodeType.CDATA;
pub const XmlNodeType_ProcessingInstruction = XmlNodeType.ProcessingInstruction;
pub const XmlNodeType_Comment = XmlNodeType.Comment;
pub const XmlNodeType_DocumentType = XmlNodeType.DocumentType;
pub const XmlNodeType_Whitespace = XmlNodeType.Whitespace;
pub const XmlNodeType_EndElement = XmlNodeType.EndElement;
pub const XmlNodeType_XmlDeclaration = XmlNodeType.XmlDeclaration;
pub const _XmlNodeType_Last = XmlNodeType._XmlNodeType_Last;

pub const XmlConformanceLevel = extern enum(i32) {
    Auto = 0,
    Fragment = 1,
    Document = 2,
    _XmlConformanceLevel_Last = 2,
};
pub const XmlConformanceLevel_Auto = XmlConformanceLevel.Auto;
pub const XmlConformanceLevel_Fragment = XmlConformanceLevel.Fragment;
pub const XmlConformanceLevel_Document = XmlConformanceLevel.Document;
pub const _XmlConformanceLevel_Last = XmlConformanceLevel._XmlConformanceLevel_Last;

pub const DtdProcessing = extern enum(i32) {
    Prohibit = 0,
    Parse = 1,
    _DtdProcessing_Last = 1,
};
pub const DtdProcessing_Prohibit = DtdProcessing.Prohibit;
pub const DtdProcessing_Parse = DtdProcessing.Parse;
pub const _DtdProcessing_Last = DtdProcessing._DtdProcessing_Last;

pub const XmlReadState = extern enum(i32) {
    Initial = 0,
    Interactive = 1,
    Error = 2,
    EndOfFile = 3,
    Closed = 4,
};
pub const XmlReadState_Initial = XmlReadState.Initial;
pub const XmlReadState_Interactive = XmlReadState.Interactive;
pub const XmlReadState_Error = XmlReadState.Error;
pub const XmlReadState_EndOfFile = XmlReadState.EndOfFile;
pub const XmlReadState_Closed = XmlReadState.Closed;

pub const XmlReaderProperty = extern enum(i32) {
    MultiLanguage = 0,
    ConformanceLevel = 1,
    RandomAccess = 2,
    XmlResolver = 3,
    DtdProcessing = 4,
    ReadState = 5,
    MaxElementDepth = 6,
    MaxEntityExpansion = 7,
    _XmlReaderProperty_Last = 7,
};
pub const XmlReaderProperty_MultiLanguage = XmlReaderProperty.MultiLanguage;
pub const XmlReaderProperty_ConformanceLevel = XmlReaderProperty.ConformanceLevel;
pub const XmlReaderProperty_RandomAccess = XmlReaderProperty.RandomAccess;
pub const XmlReaderProperty_XmlResolver = XmlReaderProperty.XmlResolver;
pub const XmlReaderProperty_DtdProcessing = XmlReaderProperty.DtdProcessing;
pub const XmlReaderProperty_ReadState = XmlReaderProperty.ReadState;
pub const XmlReaderProperty_MaxElementDepth = XmlReaderProperty.MaxElementDepth;
pub const XmlReaderProperty_MaxEntityExpansion = XmlReaderProperty.MaxEntityExpansion;
pub const _XmlReaderProperty_Last = XmlReaderProperty._XmlReaderProperty_Last;

pub const XmlError = extern enum(i32) {
    MX_E_MX = -1072894464,
    MX_E_INPUTEND = -1072894463,
    MX_E_ENCODING = -1072894462,
    MX_E_ENCODINGSWITCH = -1072894461,
    MX_E_ENCODINGSIGNATURE = -1072894460,
    WC_E_WC = -1072894432,
    WC_E_WHITESPACE = -1072894431,
    WC_E_SEMICOLON = -1072894430,
    WC_E_GREATERTHAN = -1072894429,
    WC_E_QUOTE = -1072894428,
    WC_E_EQUAL = -1072894427,
    WC_E_LESSTHAN = -1072894426,
    WC_E_HEXDIGIT = -1072894425,
    WC_E_DIGIT = -1072894424,
    WC_E_LEFTBRACKET = -1072894423,
    WC_E_LEFTPAREN = -1072894422,
    WC_E_XMLCHARACTER = -1072894421,
    WC_E_NAMECHARACTER = -1072894420,
    WC_E_SYNTAX = -1072894419,
    WC_E_CDSECT = -1072894418,
    WC_E_COMMENT = -1072894417,
    WC_E_CONDSECT = -1072894416,
    WC_E_DECLATTLIST = -1072894415,
    WC_E_DECLDOCTYPE = -1072894414,
    WC_E_DECLELEMENT = -1072894413,
    WC_E_DECLENTITY = -1072894412,
    WC_E_DECLNOTATION = -1072894411,
    WC_E_NDATA = -1072894410,
    WC_E_PUBLIC = -1072894409,
    WC_E_SYSTEM = -1072894408,
    WC_E_NAME = -1072894407,
    WC_E_ROOTELEMENT = -1072894406,
    WC_E_ELEMENTMATCH = -1072894405,
    WC_E_UNIQUEATTRIBUTE = -1072894404,
    WC_E_TEXTXMLDECL = -1072894403,
    WC_E_LEADINGXML = -1072894402,
    WC_E_TEXTDECL = -1072894401,
    WC_E_XMLDECL = -1072894400,
    WC_E_ENCNAME = -1072894399,
    WC_E_PUBLICID = -1072894398,
    WC_E_PESINTERNALSUBSET = -1072894397,
    WC_E_PESBETWEENDECLS = -1072894396,
    WC_E_NORECURSION = -1072894395,
    WC_E_ENTITYCONTENT = -1072894394,
    WC_E_UNDECLAREDENTITY = -1072894393,
    WC_E_PARSEDENTITY = -1072894392,
    WC_E_NOEXTERNALENTITYREF = -1072894391,
    WC_E_PI = -1072894390,
    WC_E_SYSTEMID = -1072894389,
    WC_E_QUESTIONMARK = -1072894388,
    WC_E_CDSECTEND = -1072894387,
    WC_E_MOREDATA = -1072894386,
    WC_E_DTDPROHIBITED = -1072894385,
    WC_E_INVALIDXMLSPACE = -1072894384,
    NC_E_NC = -1072894368,
    NC_E_QNAMECHARACTER = -1072894367,
    NC_E_QNAMECOLON = -1072894366,
    NC_E_NAMECOLON = -1072894365,
    NC_E_DECLAREDPREFIX = -1072894364,
    NC_E_UNDECLAREDPREFIX = -1072894363,
    NC_E_EMPTYURI = -1072894362,
    NC_E_XMLPREFIXRESERVED = -1072894361,
    NC_E_XMLNSPREFIXRESERVED = -1072894360,
    NC_E_XMLURIRESERVED = -1072894359,
    NC_E_XMLNSURIRESERVED = -1072894358,
    SC_E_SC = -1072894336,
    SC_E_MAXELEMENTDEPTH = -1072894335,
    SC_E_MAXENTITYEXPANSION = -1072894334,
    WR_E_WR = -1072894208,
    WR_E_NONWHITESPACE = -1072894207,
    WR_E_NSPREFIXDECLARED = -1072894206,
    WR_E_NSPREFIXWITHEMPTYNSURI = -1072894205,
    WR_E_DUPLICATEATTRIBUTE = -1072894204,
    WR_E_XMLNSPREFIXDECLARATION = -1072894203,
    WR_E_XMLPREFIXDECLARATION = -1072894202,
    WR_E_XMLURIDECLARATION = -1072894201,
    WR_E_XMLNSURIDECLARATION = -1072894200,
    WR_E_NAMESPACEUNDECLARED = -1072894199,
    WR_E_INVALIDXMLSPACE = -1072894198,
    WR_E_INVALIDACTION = -1072894197,
    WR_E_INVALIDSURROGATEPAIR = -1072894196,
    XML_E_INVALID_DECIMAL = -1072898019,
    XML_E_INVALID_HEXIDECIMAL = -1072898018,
    XML_E_INVALID_UNICODE = -1072898017,
    XML_E_INVALIDENCODING = -1072897938,
};
pub const MX_E_MX = XmlError.MX_E_MX;
pub const MX_E_INPUTEND = XmlError.MX_E_INPUTEND;
pub const MX_E_ENCODING = XmlError.MX_E_ENCODING;
pub const MX_E_ENCODINGSWITCH = XmlError.MX_E_ENCODINGSWITCH;
pub const MX_E_ENCODINGSIGNATURE = XmlError.MX_E_ENCODINGSIGNATURE;
pub const WC_E_WC = XmlError.WC_E_WC;
pub const WC_E_WHITESPACE = XmlError.WC_E_WHITESPACE;
pub const WC_E_SEMICOLON = XmlError.WC_E_SEMICOLON;
pub const WC_E_GREATERTHAN = XmlError.WC_E_GREATERTHAN;
pub const WC_E_QUOTE = XmlError.WC_E_QUOTE;
pub const WC_E_EQUAL = XmlError.WC_E_EQUAL;
pub const WC_E_LESSTHAN = XmlError.WC_E_LESSTHAN;
pub const WC_E_HEXDIGIT = XmlError.WC_E_HEXDIGIT;
pub const WC_E_DIGIT = XmlError.WC_E_DIGIT;
pub const WC_E_LEFTBRACKET = XmlError.WC_E_LEFTBRACKET;
pub const WC_E_LEFTPAREN = XmlError.WC_E_LEFTPAREN;
pub const WC_E_XMLCHARACTER = XmlError.WC_E_XMLCHARACTER;
pub const WC_E_NAMECHARACTER = XmlError.WC_E_NAMECHARACTER;
pub const WC_E_SYNTAX = XmlError.WC_E_SYNTAX;
pub const WC_E_CDSECT = XmlError.WC_E_CDSECT;
pub const WC_E_COMMENT = XmlError.WC_E_COMMENT;
pub const WC_E_CONDSECT = XmlError.WC_E_CONDSECT;
pub const WC_E_DECLATTLIST = XmlError.WC_E_DECLATTLIST;
pub const WC_E_DECLDOCTYPE = XmlError.WC_E_DECLDOCTYPE;
pub const WC_E_DECLELEMENT = XmlError.WC_E_DECLELEMENT;
pub const WC_E_DECLENTITY = XmlError.WC_E_DECLENTITY;
pub const WC_E_DECLNOTATION = XmlError.WC_E_DECLNOTATION;
pub const WC_E_NDATA = XmlError.WC_E_NDATA;
pub const WC_E_PUBLIC = XmlError.WC_E_PUBLIC;
pub const WC_E_SYSTEM = XmlError.WC_E_SYSTEM;
pub const WC_E_NAME = XmlError.WC_E_NAME;
pub const WC_E_ROOTELEMENT = XmlError.WC_E_ROOTELEMENT;
pub const WC_E_ELEMENTMATCH = XmlError.WC_E_ELEMENTMATCH;
pub const WC_E_UNIQUEATTRIBUTE = XmlError.WC_E_UNIQUEATTRIBUTE;
pub const WC_E_TEXTXMLDECL = XmlError.WC_E_TEXTXMLDECL;
pub const WC_E_LEADINGXML = XmlError.WC_E_LEADINGXML;
pub const WC_E_TEXTDECL = XmlError.WC_E_TEXTDECL;
pub const WC_E_XMLDECL = XmlError.WC_E_XMLDECL;
pub const WC_E_ENCNAME = XmlError.WC_E_ENCNAME;
pub const WC_E_PUBLICID = XmlError.WC_E_PUBLICID;
pub const WC_E_PESINTERNALSUBSET = XmlError.WC_E_PESINTERNALSUBSET;
pub const WC_E_PESBETWEENDECLS = XmlError.WC_E_PESBETWEENDECLS;
pub const WC_E_NORECURSION = XmlError.WC_E_NORECURSION;
pub const WC_E_ENTITYCONTENT = XmlError.WC_E_ENTITYCONTENT;
pub const WC_E_UNDECLAREDENTITY = XmlError.WC_E_UNDECLAREDENTITY;
pub const WC_E_PARSEDENTITY = XmlError.WC_E_PARSEDENTITY;
pub const WC_E_NOEXTERNALENTITYREF = XmlError.WC_E_NOEXTERNALENTITYREF;
pub const WC_E_PI = XmlError.WC_E_PI;
pub const WC_E_SYSTEMID = XmlError.WC_E_SYSTEMID;
pub const WC_E_QUESTIONMARK = XmlError.WC_E_QUESTIONMARK;
pub const WC_E_CDSECTEND = XmlError.WC_E_CDSECTEND;
pub const WC_E_MOREDATA = XmlError.WC_E_MOREDATA;
pub const WC_E_DTDPROHIBITED = XmlError.WC_E_DTDPROHIBITED;
pub const WC_E_INVALIDXMLSPACE = XmlError.WC_E_INVALIDXMLSPACE;
pub const NC_E_NC = XmlError.NC_E_NC;
pub const NC_E_QNAMECHARACTER = XmlError.NC_E_QNAMECHARACTER;
pub const NC_E_QNAMECOLON = XmlError.NC_E_QNAMECOLON;
pub const NC_E_NAMECOLON = XmlError.NC_E_NAMECOLON;
pub const NC_E_DECLAREDPREFIX = XmlError.NC_E_DECLAREDPREFIX;
pub const NC_E_UNDECLAREDPREFIX = XmlError.NC_E_UNDECLAREDPREFIX;
pub const NC_E_EMPTYURI = XmlError.NC_E_EMPTYURI;
pub const NC_E_XMLPREFIXRESERVED = XmlError.NC_E_XMLPREFIXRESERVED;
pub const NC_E_XMLNSPREFIXRESERVED = XmlError.NC_E_XMLNSPREFIXRESERVED;
pub const NC_E_XMLURIRESERVED = XmlError.NC_E_XMLURIRESERVED;
pub const NC_E_XMLNSURIRESERVED = XmlError.NC_E_XMLNSURIRESERVED;
pub const SC_E_SC = XmlError.SC_E_SC;
pub const SC_E_MAXELEMENTDEPTH = XmlError.SC_E_MAXELEMENTDEPTH;
pub const SC_E_MAXENTITYEXPANSION = XmlError.SC_E_MAXENTITYEXPANSION;
pub const WR_E_WR = XmlError.WR_E_WR;
pub const WR_E_NONWHITESPACE = XmlError.WR_E_NONWHITESPACE;
pub const WR_E_NSPREFIXDECLARED = XmlError.WR_E_NSPREFIXDECLARED;
pub const WR_E_NSPREFIXWITHEMPTYNSURI = XmlError.WR_E_NSPREFIXWITHEMPTYNSURI;
pub const WR_E_DUPLICATEATTRIBUTE = XmlError.WR_E_DUPLICATEATTRIBUTE;
pub const WR_E_XMLNSPREFIXDECLARATION = XmlError.WR_E_XMLNSPREFIXDECLARATION;
pub const WR_E_XMLPREFIXDECLARATION = XmlError.WR_E_XMLPREFIXDECLARATION;
pub const WR_E_XMLURIDECLARATION = XmlError.WR_E_XMLURIDECLARATION;
pub const WR_E_XMLNSURIDECLARATION = XmlError.WR_E_XMLNSURIDECLARATION;
pub const WR_E_NAMESPACEUNDECLARED = XmlError.WR_E_NAMESPACEUNDECLARED;
pub const WR_E_INVALIDXMLSPACE = XmlError.WR_E_INVALIDXMLSPACE;
pub const WR_E_INVALIDACTION = XmlError.WR_E_INVALIDACTION;
pub const WR_E_INVALIDSURROGATEPAIR = XmlError.WR_E_INVALIDSURROGATEPAIR;
pub const XML_E_INVALID_DECIMAL = XmlError.XML_E_INVALID_DECIMAL;
pub const XML_E_INVALID_HEXIDECIMAL = XmlError.XML_E_INVALID_HEXIDECIMAL;
pub const XML_E_INVALID_UNICODE = XmlError.XML_E_INVALID_UNICODE;
pub const XML_E_INVALIDENCODING = XmlError.XML_E_INVALIDENCODING;

pub const XmlStandalone = extern enum(i32) {
    Omit = 0,
    Yes = 1,
    No = 2,
    _XmlStandalone_Last = 2,
};
pub const XmlStandalone_Omit = XmlStandalone.Omit;
pub const XmlStandalone_Yes = XmlStandalone.Yes;
pub const XmlStandalone_No = XmlStandalone.No;
pub const _XmlStandalone_Last = XmlStandalone._XmlStandalone_Last;

pub const XmlWriterProperty = extern enum(i32) {
    MultiLanguage = 0,
    Indent = 1,
    ByteOrderMark = 2,
    OmitXmlDeclaration = 3,
    ConformanceLevel = 4,
    CompactEmptyElement = 5,
    _XmlWriterProperty_Last = 5,
};
pub const XmlWriterProperty_MultiLanguage = XmlWriterProperty.MultiLanguage;
pub const XmlWriterProperty_Indent = XmlWriterProperty.Indent;
pub const XmlWriterProperty_ByteOrderMark = XmlWriterProperty.ByteOrderMark;
pub const XmlWriterProperty_OmitXmlDeclaration = XmlWriterProperty.OmitXmlDeclaration;
pub const XmlWriterProperty_ConformanceLevel = XmlWriterProperty.ConformanceLevel;
pub const XmlWriterProperty_CompactEmptyElement = XmlWriterProperty.CompactEmptyElement;
pub const _XmlWriterProperty_Last = XmlWriterProperty._XmlWriterProperty_Last;

const IID_IXmlReader_Value = @import("../zig.zig").Guid.initString("7279FC81-709D-4095-B63D-69FE4B0D9030");
pub const IID_IXmlReader = &IID_IXmlReader_Value;
pub const IXmlReader = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetInput: fn(
            self: *const IXmlReader,
            pInput: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IXmlReader,
            nProperty: u32,
            ppValue: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IXmlReader,
            nProperty: u32,
            pValue: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Read: fn(
            self: *const IXmlReader,
            pNodeType: ?*XmlNodeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNodeType: fn(
            self: *const IXmlReader,
            pNodeType: *XmlNodeType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToFirstAttribute: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToNextAttribute: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToAttributeByName: fn(
            self: *const IXmlReader,
            pwszLocalName: [*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToElement: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQualifiedName: fn(
            self: *const IXmlReader,
            ppwszQualifiedName: ?*?PWSTR,
            pcwchQualifiedName: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamespaceUri: fn(
            self: *const IXmlReader,
            ppwszNamespaceUri: ?*?PWSTR,
            pcwchNamespaceUri: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocalName: fn(
            self: *const IXmlReader,
            ppwszLocalName: ?*?PWSTR,
            pcwchLocalName: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrefix: fn(
            self: *const IXmlReader,
            ppwszPrefix: ?*?PWSTR,
            pcwchPrefix: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IXmlReader,
            ppwszValue: ?*?PWSTR,
            pcwchValue: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadValueChunk: fn(
            self: *const IXmlReader,
            pwchBuffer: [*:0]u16,
            cwchChunkSize: u32,
            pcwchRead: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBaseUri: fn(
            self: *const IXmlReader,
            ppwszBaseUri: ?*?PWSTR,
            pcwchBaseUri: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDefault: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        IsEmptyElement: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        GetLineNumber: fn(
            self: *const IXmlReader,
            pnLineNumber: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinePosition: fn(
            self: *const IXmlReader,
            pnLinePosition: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributeCount: fn(
            self: *const IXmlReader,
            pnAttributeCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDepth: fn(
            self: *const IXmlReader,
            pnDepth: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEOF: fn(
            self: *const IXmlReader,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_SetInput(self: *const T, pInput: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).SetInput(@ptrCast(*const IXmlReader, self), pInput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetProperty(self: *const T, nProperty: u32, ppValue: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetProperty(@ptrCast(*const IXmlReader, self), nProperty, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_SetProperty(self: *const T, nProperty: u32, pValue: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).SetProperty(@ptrCast(*const IXmlReader, self), nProperty, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_Read(self: *const T, pNodeType: ?*XmlNodeType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).Read(@ptrCast(*const IXmlReader, self), pNodeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetNodeType(self: *const T, pNodeType: *XmlNodeType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetNodeType(@ptrCast(*const IXmlReader, self), pNodeType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_MoveToFirstAttribute(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).MoveToFirstAttribute(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_MoveToNextAttribute(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).MoveToNextAttribute(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_MoveToAttributeByName(self: *const T, pwszLocalName: [*:0]const u16, pwszNamespaceUri: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).MoveToAttributeByName(@ptrCast(*const IXmlReader, self), pwszLocalName, pwszNamespaceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_MoveToElement(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).MoveToElement(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetQualifiedName(self: *const T, ppwszQualifiedName: ?*?PWSTR, pcwchQualifiedName: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetQualifiedName(@ptrCast(*const IXmlReader, self), ppwszQualifiedName, pcwchQualifiedName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetNamespaceUri(self: *const T, ppwszNamespaceUri: ?*?PWSTR, pcwchNamespaceUri: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetNamespaceUri(@ptrCast(*const IXmlReader, self), ppwszNamespaceUri, pcwchNamespaceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetLocalName(self: *const T, ppwszLocalName: ?*?PWSTR, pcwchLocalName: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetLocalName(@ptrCast(*const IXmlReader, self), ppwszLocalName, pcwchLocalName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetPrefix(self: *const T, ppwszPrefix: ?*?PWSTR, pcwchPrefix: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetPrefix(@ptrCast(*const IXmlReader, self), ppwszPrefix, pcwchPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetValue(self: *const T, ppwszValue: ?*?PWSTR, pcwchValue: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetValue(@ptrCast(*const IXmlReader, self), ppwszValue, pcwchValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_ReadValueChunk(self: *const T, pwchBuffer: [*:0]u16, cwchChunkSize: u32, pcwchRead: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).ReadValueChunk(@ptrCast(*const IXmlReader, self), pwchBuffer, cwchChunkSize, pcwchRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetBaseUri(self: *const T, ppwszBaseUri: ?*?PWSTR, pcwchBaseUri: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetBaseUri(@ptrCast(*const IXmlReader, self), ppwszBaseUri, pcwchBaseUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_IsDefault(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).IsDefault(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_IsEmptyElement(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).IsEmptyElement(@ptrCast(*const IXmlReader, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetLineNumber(self: *const T, pnLineNumber: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetLineNumber(@ptrCast(*const IXmlReader, self), pnLineNumber);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetLinePosition(self: *const T, pnLinePosition: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetLinePosition(@ptrCast(*const IXmlReader, self), pnLinePosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetAttributeCount(self: *const T, pnAttributeCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetAttributeCount(@ptrCast(*const IXmlReader, self), pnAttributeCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_GetDepth(self: *const T, pnDepth: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).GetDepth(@ptrCast(*const IXmlReader, self), pnDepth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlReader_IsEOF(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IXmlReader.VTable, self.vtable).IsEOF(@ptrCast(*const IXmlReader, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXmlResolver_Value = @import("../zig.zig").Guid.initString("7279FC82-709D-4095-B63D-69FE4B0D9030");
pub const IID_IXmlResolver = &IID_IXmlResolver_Value;
pub const IXmlResolver = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResolveUri: fn(
            self: *const IXmlResolver,
            pwszBaseUri: ?[*:0]const u16,
            pwszPublicIdentifier: ?[*:0]const u16,
            pwszSystemIdentifier: ?[*:0]const u16,
            ppResolvedInput: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlResolver_ResolveUri(self: *const T, pwszBaseUri: ?[*:0]const u16, pwszPublicIdentifier: ?[*:0]const u16, pwszSystemIdentifier: ?[*:0]const u16, ppResolvedInput: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlResolver.VTable, self.vtable).ResolveUri(@ptrCast(*const IXmlResolver, self), pwszBaseUri, pwszPublicIdentifier, pwszSystemIdentifier, ppResolvedInput);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXmlWriter_Value = @import("../zig.zig").Guid.initString("7279FC88-709D-4095-B63D-69FE4B0D9030");
pub const IID_IXmlWriter = &IID_IXmlWriter_Value;
pub const IXmlWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetOutput: fn(
            self: *const IXmlWriter,
            pOutput: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IXmlWriter,
            nProperty: u32,
            ppValue: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IXmlWriter,
            nProperty: u32,
            pValue: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAttributes: fn(
            self: *const IXmlWriter,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAttributeString: fn(
            self: *const IXmlWriter,
            pwszPrefix: ?[*:0]const u16,
            pwszLocalName: ?[*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
            pwszValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteCData: fn(
            self: *const IXmlWriter,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteCharEntity: fn(
            self: *const IXmlWriter,
            wch: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteChars: fn(
            self: *const IXmlWriter,
            pwch: ?[*:0]const u16,
            cwch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteComment: fn(
            self: *const IXmlWriter,
            pwszComment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDocType: fn(
            self: *const IXmlWriter,
            pwszName: ?[*:0]const u16,
            pwszPublicId: ?[*:0]const u16,
            pwszSystemId: ?[*:0]const u16,
            pwszSubset: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteElementString: fn(
            self: *const IXmlWriter,
            pwszPrefix: ?[*:0]const u16,
            pwszLocalName: [*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
            pwszValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEndDocument: fn(
            self: *const IXmlWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEndElement: fn(
            self: *const IXmlWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEntityRef: fn(
            self: *const IXmlWriter,
            pwszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteFullEndElement: fn(
            self: *const IXmlWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteName: fn(
            self: *const IXmlWriter,
            pwszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNmToken: fn(
            self: *const IXmlWriter,
            pwszNmToken: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNode: fn(
            self: *const IXmlWriter,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNodeShallow: fn(
            self: *const IXmlWriter,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProcessingInstruction: fn(
            self: *const IXmlWriter,
            pwszName: [*:0]const u16,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteQualifiedName: fn(
            self: *const IXmlWriter,
            pwszLocalName: [*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteRaw: fn(
            self: *const IXmlWriter,
            pwszData: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteRawChars: fn(
            self: *const IXmlWriter,
            pwch: ?[*:0]const u16,
            cwch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStartDocument: fn(
            self: *const IXmlWriter,
            standalone: XmlStandalone,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStartElement: fn(
            self: *const IXmlWriter,
            pwszPrefix: ?[*:0]const u16,
            pwszLocalName: [*:0]const u16,
            pwszNamespaceUri: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteString: fn(
            self: *const IXmlWriter,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSurrogateCharEntity: fn(
            self: *const IXmlWriter,
            wchLow: u16,
            wchHigh: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWhitespace: fn(
            self: *const IXmlWriter,
            pwszWhitespace: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IXmlWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_SetOutput(self: *const T, pOutput: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).SetOutput(@ptrCast(*const IXmlWriter, self), pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_GetProperty(self: *const T, nProperty: u32, ppValue: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).GetProperty(@ptrCast(*const IXmlWriter, self), nProperty, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_SetProperty(self: *const T, nProperty: u32, pValue: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).SetProperty(@ptrCast(*const IXmlWriter, self), nProperty, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteAttributes(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteAttributes(@ptrCast(*const IXmlWriter, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteAttributeString(self: *const T, pwszPrefix: ?[*:0]const u16, pwszLocalName: ?[*:0]const u16, pwszNamespaceUri: ?[*:0]const u16, pwszValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteAttributeString(@ptrCast(*const IXmlWriter, self), pwszPrefix, pwszLocalName, pwszNamespaceUri, pwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteCData(self: *const T, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteCData(@ptrCast(*const IXmlWriter, self), pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteCharEntity(self: *const T, wch: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteCharEntity(@ptrCast(*const IXmlWriter, self), wch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteChars(self: *const T, pwch: ?[*:0]const u16, cwch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteChars(@ptrCast(*const IXmlWriter, self), pwch, cwch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteComment(self: *const T, pwszComment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteComment(@ptrCast(*const IXmlWriter, self), pwszComment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteDocType(self: *const T, pwszName: ?[*:0]const u16, pwszPublicId: ?[*:0]const u16, pwszSystemId: ?[*:0]const u16, pwszSubset: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteDocType(@ptrCast(*const IXmlWriter, self), pwszName, pwszPublicId, pwszSystemId, pwszSubset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteElementString(self: *const T, pwszPrefix: ?[*:0]const u16, pwszLocalName: [*:0]const u16, pwszNamespaceUri: ?[*:0]const u16, pwszValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteElementString(@ptrCast(*const IXmlWriter, self), pwszPrefix, pwszLocalName, pwszNamespaceUri, pwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteEndDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteEndDocument(@ptrCast(*const IXmlWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteEndElement(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteEndElement(@ptrCast(*const IXmlWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteEntityRef(self: *const T, pwszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteEntityRef(@ptrCast(*const IXmlWriter, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteFullEndElement(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteFullEndElement(@ptrCast(*const IXmlWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteName(self: *const T, pwszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteName(@ptrCast(*const IXmlWriter, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteNmToken(self: *const T, pwszNmToken: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteNmToken(@ptrCast(*const IXmlWriter, self), pwszNmToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteNode(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteNode(@ptrCast(*const IXmlWriter, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteNodeShallow(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteNodeShallow(@ptrCast(*const IXmlWriter, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteProcessingInstruction(self: *const T, pwszName: [*:0]const u16, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteProcessingInstruction(@ptrCast(*const IXmlWriter, self), pwszName, pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteQualifiedName(self: *const T, pwszLocalName: [*:0]const u16, pwszNamespaceUri: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteQualifiedName(@ptrCast(*const IXmlWriter, self), pwszLocalName, pwszNamespaceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteRaw(self: *const T, pwszData: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteRaw(@ptrCast(*const IXmlWriter, self), pwszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteRawChars(self: *const T, pwch: ?[*:0]const u16, cwch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteRawChars(@ptrCast(*const IXmlWriter, self), pwch, cwch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteStartDocument(self: *const T, standalone: XmlStandalone) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteStartDocument(@ptrCast(*const IXmlWriter, self), standalone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteStartElement(self: *const T, pwszPrefix: ?[*:0]const u16, pwszLocalName: [*:0]const u16, pwszNamespaceUri: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteStartElement(@ptrCast(*const IXmlWriter, self), pwszPrefix, pwszLocalName, pwszNamespaceUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteString(self: *const T, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteString(@ptrCast(*const IXmlWriter, self), pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteSurrogateCharEntity(self: *const T, wchLow: u16, wchHigh: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteSurrogateCharEntity(@ptrCast(*const IXmlWriter, self), wchLow, wchHigh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_WriteWhitespace(self: *const T, pwszWhitespace: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).WriteWhitespace(@ptrCast(*const IXmlWriter, self), pwszWhitespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriter_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriter.VTable, self.vtable).Flush(@ptrCast(*const IXmlWriter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXmlWriterLite_Value = @import("../zig.zig").Guid.initString("862494C6-1310-4AAD-B3CD-2DBEEBF670D3");
pub const IID_IXmlWriterLite = &IID_IXmlWriterLite_Value;
pub const IXmlWriterLite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetOutput: fn(
            self: *const IXmlWriterLite,
            pOutput: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IXmlWriterLite,
            nProperty: u32,
            ppValue: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IXmlWriterLite,
            nProperty: u32,
            pValue: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAttributes: fn(
            self: *const IXmlWriterLite,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteAttributeString: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
            pwszValue: ?[*:0]const u16,
            cwszValue: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteCData: fn(
            self: *const IXmlWriterLite,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteCharEntity: fn(
            self: *const IXmlWriterLite,
            wch: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteChars: fn(
            self: *const IXmlWriterLite,
            pwch: ?[*:0]const u16,
            cwch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteComment: fn(
            self: *const IXmlWriterLite,
            pwszComment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDocType: fn(
            self: *const IXmlWriterLite,
            pwszName: ?[*:0]const u16,
            pwszPublicId: ?[*:0]const u16,
            pwszSystemId: ?[*:0]const u16,
            pwszSubset: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteElementString: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
            pwszValue: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEndDocument: fn(
            self: *const IXmlWriterLite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEndElement: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteEntityRef: fn(
            self: *const IXmlWriterLite,
            pwszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteFullEndElement: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteName: fn(
            self: *const IXmlWriterLite,
            pwszName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNmToken: fn(
            self: *const IXmlWriterLite,
            pwszNmToken: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNode: fn(
            self: *const IXmlWriterLite,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteNodeShallow: fn(
            self: *const IXmlWriterLite,
            pReader: *IXmlReader,
            fWriteDefaultAttributes: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteProcessingInstruction: fn(
            self: *const IXmlWriterLite,
            pwszName: [*:0]const u16,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteRaw: fn(
            self: *const IXmlWriterLite,
            pwszData: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteRawChars: fn(
            self: *const IXmlWriterLite,
            pwch: ?[*:0]const u16,
            cwch: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStartDocument: fn(
            self: *const IXmlWriterLite,
            standalone: XmlStandalone,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteStartElement: fn(
            self: *const IXmlWriterLite,
            pwszQName: [*:0]const u16,
            cwszQName: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteString: fn(
            self: *const IXmlWriterLite,
            pwszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSurrogateCharEntity: fn(
            self: *const IXmlWriterLite,
            wchLow: u16,
            wchHigh: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWhitespace: fn(
            self: *const IXmlWriterLite,
            pwszWhitespace: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Flush: fn(
            self: *const IXmlWriterLite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_SetOutput(self: *const T, pOutput: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).SetOutput(@ptrCast(*const IXmlWriterLite, self), pOutput);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_GetProperty(self: *const T, nProperty: u32, ppValue: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).GetProperty(@ptrCast(*const IXmlWriterLite, self), nProperty, ppValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_SetProperty(self: *const T, nProperty: u32, pValue: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).SetProperty(@ptrCast(*const IXmlWriterLite, self), nProperty, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteAttributes(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteAttributes(@ptrCast(*const IXmlWriterLite, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteAttributeString(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32, pwszValue: ?[*:0]const u16, cwszValue: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteAttributeString(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName, pwszValue, cwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteCData(self: *const T, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteCData(@ptrCast(*const IXmlWriterLite, self), pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteCharEntity(self: *const T, wch: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteCharEntity(@ptrCast(*const IXmlWriterLite, self), wch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteChars(self: *const T, pwch: ?[*:0]const u16, cwch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteChars(@ptrCast(*const IXmlWriterLite, self), pwch, cwch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteComment(self: *const T, pwszComment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteComment(@ptrCast(*const IXmlWriterLite, self), pwszComment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteDocType(self: *const T, pwszName: ?[*:0]const u16, pwszPublicId: ?[*:0]const u16, pwszSystemId: ?[*:0]const u16, pwszSubset: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteDocType(@ptrCast(*const IXmlWriterLite, self), pwszName, pwszPublicId, pwszSystemId, pwszSubset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteElementString(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32, pwszValue: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteElementString(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName, pwszValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteEndDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteEndDocument(@ptrCast(*const IXmlWriterLite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteEndElement(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteEndElement(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteEntityRef(self: *const T, pwszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteEntityRef(@ptrCast(*const IXmlWriterLite, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteFullEndElement(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteFullEndElement(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteName(self: *const T, pwszName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteName(@ptrCast(*const IXmlWriterLite, self), pwszName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteNmToken(self: *const T, pwszNmToken: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteNmToken(@ptrCast(*const IXmlWriterLite, self), pwszNmToken);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteNode(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteNode(@ptrCast(*const IXmlWriterLite, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteNodeShallow(self: *const T, pReader: *IXmlReader, fWriteDefaultAttributes: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteNodeShallow(@ptrCast(*const IXmlWriterLite, self), pReader, fWriteDefaultAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteProcessingInstruction(self: *const T, pwszName: [*:0]const u16, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteProcessingInstruction(@ptrCast(*const IXmlWriterLite, self), pwszName, pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteRaw(self: *const T, pwszData: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteRaw(@ptrCast(*const IXmlWriterLite, self), pwszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteRawChars(self: *const T, pwch: ?[*:0]const u16, cwch: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteRawChars(@ptrCast(*const IXmlWriterLite, self), pwch, cwch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteStartDocument(self: *const T, standalone: XmlStandalone) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteStartDocument(@ptrCast(*const IXmlWriterLite, self), standalone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteStartElement(self: *const T, pwszQName: [*:0]const u16, cwszQName: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteStartElement(@ptrCast(*const IXmlWriterLite, self), pwszQName, cwszQName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteString(self: *const T, pwszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteString(@ptrCast(*const IXmlWriterLite, self), pwszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteSurrogateCharEntity(self: *const T, wchLow: u16, wchHigh: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteSurrogateCharEntity(@ptrCast(*const IXmlWriterLite, self), wchLow, wchHigh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_WriteWhitespace(self: *const T, pwszWhitespace: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).WriteWhitespace(@ptrCast(*const IXmlWriterLite, self), pwszWhitespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXmlWriterLite_Flush(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXmlWriterLite.VTable, self.vtable).Flush(@ptrCast(*const IXmlWriterLite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEVPROP_OPERATOR = extern enum(i32) {
    MODIFIER_NOT = 65536,
    MODIFIER_IGNORE_CASE = 131072,
    NONE = 0,
    EXISTS = 1,
    NOT_EXISTS = 65537,
    EQUALS = 2,
    NOT_EQUALS = 65538,
    GREATER_THAN = 3,
    LESS_THAN = 4,
    GREATER_THAN_EQUALS = 5,
    LESS_THAN_EQUALS = 6,
    EQUALS_IGNORE_CASE = 131074,
    NOT_EQUALS_IGNORE_CASE = 196610,
    BITWISE_AND = 7,
    BITWISE_OR = 8,
    BEGINS_WITH = 9,
    ENDS_WITH = 10,
    CONTAINS = 11,
    BEGINS_WITH_IGNORE_CASE = 131081,
    ENDS_WITH_IGNORE_CASE = 131082,
    CONTAINS_IGNORE_CASE = 131083,
    LIST_CONTAINS = 4096,
    LIST_ELEMENT_BEGINS_WITH = 8192,
    LIST_ELEMENT_ENDS_WITH = 12288,
    LIST_ELEMENT_CONTAINS = 16384,
    LIST_CONTAINS_IGNORE_CASE = 135168,
    LIST_ELEMENT_BEGINS_WITH_IGNORE_CASE = 139264,
    LIST_ELEMENT_ENDS_WITH_IGNORE_CASE = 143360,
    LIST_ELEMENT_CONTAINS_IGNORE_CASE = 147456,
    AND_OPEN = 1048576,
    AND_CLOSE = 2097152,
    OR_OPEN = 3145728,
    OR_CLOSE = 4194304,
    NOT_OPEN = 5242880,
    NOT_CLOSE = 6291456,
    ARRAY_CONTAINS = 268435456,
    MASK_EVAL = 4095,
    MASK_LIST = 61440,
    MASK_MODIFIER = 983040,
    MASK_NOT_LOGICAL = -267386881,
    MASK_LOGICAL = 267386880,
    MASK_ARRAY = -268435456,
};
pub const DEVPROP_OPERATOR_MODIFIER_NOT = DEVPROP_OPERATOR.MODIFIER_NOT;
pub const DEVPROP_OPERATOR_MODIFIER_IGNORE_CASE = DEVPROP_OPERATOR.MODIFIER_IGNORE_CASE;
pub const DEVPROP_OPERATOR_NONE = DEVPROP_OPERATOR.NONE;
pub const DEVPROP_OPERATOR_EXISTS = DEVPROP_OPERATOR.EXISTS;
pub const DEVPROP_OPERATOR_NOT_EXISTS = DEVPROP_OPERATOR.NOT_EXISTS;
pub const DEVPROP_OPERATOR_EQUALS = DEVPROP_OPERATOR.EQUALS;
pub const DEVPROP_OPERATOR_NOT_EQUALS = DEVPROP_OPERATOR.NOT_EQUALS;
pub const DEVPROP_OPERATOR_GREATER_THAN = DEVPROP_OPERATOR.GREATER_THAN;
pub const DEVPROP_OPERATOR_LESS_THAN = DEVPROP_OPERATOR.LESS_THAN;
pub const DEVPROP_OPERATOR_GREATER_THAN_EQUALS = DEVPROP_OPERATOR.GREATER_THAN_EQUALS;
pub const DEVPROP_OPERATOR_LESS_THAN_EQUALS = DEVPROP_OPERATOR.LESS_THAN_EQUALS;
pub const DEVPROP_OPERATOR_EQUALS_IGNORE_CASE = DEVPROP_OPERATOR.EQUALS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_NOT_EQUALS_IGNORE_CASE = DEVPROP_OPERATOR.NOT_EQUALS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_BITWISE_AND = DEVPROP_OPERATOR.BITWISE_AND;
pub const DEVPROP_OPERATOR_BITWISE_OR = DEVPROP_OPERATOR.BITWISE_OR;
pub const DEVPROP_OPERATOR_BEGINS_WITH = DEVPROP_OPERATOR.BEGINS_WITH;
pub const DEVPROP_OPERATOR_ENDS_WITH = DEVPROP_OPERATOR.ENDS_WITH;
pub const DEVPROP_OPERATOR_CONTAINS = DEVPROP_OPERATOR.CONTAINS;
pub const DEVPROP_OPERATOR_BEGINS_WITH_IGNORE_CASE = DEVPROP_OPERATOR.BEGINS_WITH_IGNORE_CASE;
pub const DEVPROP_OPERATOR_ENDS_WITH_IGNORE_CASE = DEVPROP_OPERATOR.ENDS_WITH_IGNORE_CASE;
pub const DEVPROP_OPERATOR_CONTAINS_IGNORE_CASE = DEVPROP_OPERATOR.CONTAINS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_LIST_CONTAINS = DEVPROP_OPERATOR.LIST_CONTAINS;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH = DEVPROP_OPERATOR.LIST_ELEMENT_BEGINS_WITH;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH = DEVPROP_OPERATOR.LIST_ELEMENT_ENDS_WITH;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS = DEVPROP_OPERATOR.LIST_ELEMENT_CONTAINS;
pub const DEVPROP_OPERATOR_LIST_CONTAINS_IGNORE_CASE = DEVPROP_OPERATOR.LIST_CONTAINS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_BEGINS_WITH_IGNORE_CASE = DEVPROP_OPERATOR.LIST_ELEMENT_BEGINS_WITH_IGNORE_CASE;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_ENDS_WITH_IGNORE_CASE = DEVPROP_OPERATOR.LIST_ELEMENT_ENDS_WITH_IGNORE_CASE;
pub const DEVPROP_OPERATOR_LIST_ELEMENT_CONTAINS_IGNORE_CASE = DEVPROP_OPERATOR.LIST_ELEMENT_CONTAINS_IGNORE_CASE;
pub const DEVPROP_OPERATOR_AND_OPEN = DEVPROP_OPERATOR.AND_OPEN;
pub const DEVPROP_OPERATOR_AND_CLOSE = DEVPROP_OPERATOR.AND_CLOSE;
pub const DEVPROP_OPERATOR_OR_OPEN = DEVPROP_OPERATOR.OR_OPEN;
pub const DEVPROP_OPERATOR_OR_CLOSE = DEVPROP_OPERATOR.OR_CLOSE;
pub const DEVPROP_OPERATOR_NOT_OPEN = DEVPROP_OPERATOR.NOT_OPEN;
pub const DEVPROP_OPERATOR_NOT_CLOSE = DEVPROP_OPERATOR.NOT_CLOSE;
pub const DEVPROP_OPERATOR_ARRAY_CONTAINS = DEVPROP_OPERATOR.ARRAY_CONTAINS;
pub const DEVPROP_OPERATOR_MASK_EVAL = DEVPROP_OPERATOR.MASK_EVAL;
pub const DEVPROP_OPERATOR_MASK_LIST = DEVPROP_OPERATOR.MASK_LIST;
pub const DEVPROP_OPERATOR_MASK_MODIFIER = DEVPROP_OPERATOR.MASK_MODIFIER;
pub const DEVPROP_OPERATOR_MASK_NOT_LOGICAL = DEVPROP_OPERATOR.MASK_NOT_LOGICAL;
pub const DEVPROP_OPERATOR_MASK_LOGICAL = DEVPROP_OPERATOR.MASK_LOGICAL;
pub const DEVPROP_OPERATOR_MASK_ARRAY = DEVPROP_OPERATOR.MASK_ARRAY;

pub const DEVPROP_FILTER_EXPRESSION = extern struct {
    Operator: DEVPROP_OPERATOR,
    Property: DEVPROPERTY,
};

pub const DEV_OBJECT_TYPE = extern enum(i32) {
    DevObjectTypeUnknown = 0,
    DevObjectTypeDeviceInterface = 1,
    DevObjectTypeDeviceContainer = 2,
    DevObjectTypeDevice = 3,
    DevObjectTypeDeviceInterfaceClass = 4,
    DevObjectTypeAEP = 5,
    DevObjectTypeAEPContainer = 6,
    DevObjectTypeDeviceInstallerClass = 7,
    DevObjectTypeDeviceInterfaceDisplay = 8,
    DevObjectTypeDeviceContainerDisplay = 9,
    DevObjectTypeAEPService = 10,
    DevObjectTypeDevicePanel = 11,
};
pub const DevObjectTypeUnknown = DEV_OBJECT_TYPE.DevObjectTypeUnknown;
pub const DevObjectTypeDeviceInterface = DEV_OBJECT_TYPE.DevObjectTypeDeviceInterface;
pub const DevObjectTypeDeviceContainer = DEV_OBJECT_TYPE.DevObjectTypeDeviceContainer;
pub const DevObjectTypeDevice = DEV_OBJECT_TYPE.DevObjectTypeDevice;
pub const DevObjectTypeDeviceInterfaceClass = DEV_OBJECT_TYPE.DevObjectTypeDeviceInterfaceClass;
pub const DevObjectTypeAEP = DEV_OBJECT_TYPE.DevObjectTypeAEP;
pub const DevObjectTypeAEPContainer = DEV_OBJECT_TYPE.DevObjectTypeAEPContainer;
pub const DevObjectTypeDeviceInstallerClass = DEV_OBJECT_TYPE.DevObjectTypeDeviceInstallerClass;
pub const DevObjectTypeDeviceInterfaceDisplay = DEV_OBJECT_TYPE.DevObjectTypeDeviceInterfaceDisplay;
pub const DevObjectTypeDeviceContainerDisplay = DEV_OBJECT_TYPE.DevObjectTypeDeviceContainerDisplay;
pub const DevObjectTypeAEPService = DEV_OBJECT_TYPE.DevObjectTypeAEPService;
pub const DevObjectTypeDevicePanel = DEV_OBJECT_TYPE.DevObjectTypeDevicePanel;

pub const DEV_QUERY_FLAGS = extern enum(i32) {
    DevQueryFlagNone = 0,
    DevQueryFlagUpdateResults = 1,
    DevQueryFlagAllProperties = 2,
    DevQueryFlagLocalize = 4,
    DevQueryFlagAsyncClose = 8,
};
pub const DevQueryFlagNone = DEV_QUERY_FLAGS.DevQueryFlagNone;
pub const DevQueryFlagUpdateResults = DEV_QUERY_FLAGS.DevQueryFlagUpdateResults;
pub const DevQueryFlagAllProperties = DEV_QUERY_FLAGS.DevQueryFlagAllProperties;
pub const DevQueryFlagLocalize = DEV_QUERY_FLAGS.DevQueryFlagLocalize;
pub const DevQueryFlagAsyncClose = DEV_QUERY_FLAGS.DevQueryFlagAsyncClose;

pub const DEV_QUERY_STATE = extern enum(i32) {
    DevQueryStateInitialized = 0,
    DevQueryStateEnumCompleted = 1,
    DevQueryStateAborted = 2,
    DevQueryStateClosed = 3,
};
pub const DevQueryStateInitialized = DEV_QUERY_STATE.DevQueryStateInitialized;
pub const DevQueryStateEnumCompleted = DEV_QUERY_STATE.DevQueryStateEnumCompleted;
pub const DevQueryStateAborted = DEV_QUERY_STATE.DevQueryStateAborted;
pub const DevQueryStateClosed = DEV_QUERY_STATE.DevQueryStateClosed;

pub const DEV_QUERY_RESULT_ACTION = extern enum(i32) {
    DevQueryResultStateChange = 0,
    DevQueryResultAdd = 1,
    DevQueryResultUpdate = 2,
    DevQueryResultRemove = 3,
};
pub const DevQueryResultStateChange = DEV_QUERY_RESULT_ACTION.DevQueryResultStateChange;
pub const DevQueryResultAdd = DEV_QUERY_RESULT_ACTION.DevQueryResultAdd;
pub const DevQueryResultUpdate = DEV_QUERY_RESULT_ACTION.DevQueryResultUpdate;
pub const DevQueryResultRemove = DEV_QUERY_RESULT_ACTION.DevQueryResultRemove;

pub const DEV_OBJECT = extern struct {
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    cPropertyCount: u32,
    pProperties: *const DEVPROPERTY,
};

pub const DEV_QUERY_RESULT_ACTION_DATA = extern struct {
    Action: DEV_QUERY_RESULT_ACTION,
    Data: DEV_QUERY_RESULT_ACTION_DATA._DEV_QUERY_RESULT_UPDATE_PAYLOAD,
    const _DEV_QUERY_RESULT_UPDATE_PAYLOAD = u32; // TODO: generate this nested type!
};

pub const DEV_QUERY_PARAMETER = extern struct {
    Key: DEVPROPKEY,
    Type: u32,
    BufferSize: u32,
    Buffer: *c_void,
};

pub const HDEVQUERY__ = extern struct {
    unused: i32,
};

pub const PDEV_QUERY_RESULT_CALLBACK = fn(
    hDevQuery: *HDEVQUERY__,
    pContext: ?*c_void,
    pActionData: *const DEV_QUERY_RESULT_ACTION_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const _GlobalFilter = extern enum(i32) {
    GF_FRAGMENTS = 2,
    GF_STRONGHOST = 8,
    GF_FRAGCACHE = 9,
};
pub const GF_FRAGMENTS = _GlobalFilter.GF_FRAGMENTS;
pub const GF_STRONGHOST = _GlobalFilter.GF_STRONGHOST;
pub const GF_FRAGCACHE = _GlobalFilter.GF_FRAGCACHE;

pub const _PfForwardAction = extern enum(i32) {
    PF_ACTION_FORWARD = 0,
    PF_ACTION_DROP = 1,
};
pub const PF_ACTION_FORWARD = _PfForwardAction.PF_ACTION_FORWARD;
pub const PF_ACTION_DROP = _PfForwardAction.PF_ACTION_DROP;

pub const _PfAddresType = extern enum(i32) {
    PF_IPV4 = 0,
    PF_IPV6 = 1,
};
pub const PF_IPV4 = _PfAddresType.PF_IPV4;
pub const PF_IPV6 = _PfAddresType.PF_IPV6;

pub const PF_FILTER_DESCRIPTOR = extern struct {
    dwFilterFlags: u32,
    dwRule: u32,
    pfatType: _PfAddresType,
    SrcAddr: *u8,
    SrcMask: *u8,
    DstAddr: *u8,
    DstMask: *u8,
    dwProtocol: u32,
    fLateBound: u32,
    wSrcPort: u16,
    wDstPort: u16,
    wSrcPortHighRange: u16,
    wDstPortHighRange: u16,
};

pub const PF_FILTER_STATS = extern struct {
    dwNumPacketsFiltered: u32,
    info: PF_FILTER_DESCRIPTOR,
};

pub const PF_INTERFACE_STATS = extern struct {
    pvDriverContext: *c_void,
    dwFlags: u32,
    dwInDrops: u32,
    dwOutDrops: u32,
    eaInAction: _PfForwardAction,
    eaOutAction: _PfForwardAction,
    dwNumInFilters: u32,
    dwNumOutFilters: u32,
    dwFrag: u32,
    dwSpoof: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    liSYN: LARGE_INTEGER,
    liTotalLogged: LARGE_INTEGER,
    dwLostLogEntries: u32,
    FilterInfo: [1]PF_FILTER_STATS,
};

pub const PF_LATEBIND_INFO = extern struct {
    SrcAddr: *u8,
    DstAddr: *u8,
    Mask: *u8,
};

pub const _PfFrameType = extern enum(i32) {
    PFFT_FILTER = 1,
    PFFT_FRAG = 2,
    PFFT_SPOOF = 3,
};
pub const PFFT_FILTER = _PfFrameType.PFFT_FILTER;
pub const PFFT_FRAG = _PfFrameType.PFFT_FRAG;
pub const PFFT_SPOOF = _PfFrameType.PFFT_SPOOF;

pub const _pfLogFrame = extern struct {
    Timestamp: LARGE_INTEGER,
    pfeTypeOfFrame: _PfFrameType,
    dwTotalSizeUsed: u32,
    dwFilterRule: u32,
    wSizeOfAdditionalData: u16,
    wSizeOfIpHeader: u16,
    dwInterfaceName: u32,
    dwIPIndex: u32,
    bPacketData: [1]u8,
};


//--------------------------------------------------------------------------------
// Section: Functions (474)
//--------------------------------------------------------------------------------
pub extern "RPCRT4" fn NdrSimpleStructMarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

pub extern "RPCRT4" fn NdrComplexStructMarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

pub extern "RPCRT4" fn NdrConformantArrayMarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

pub extern "RPCRT4" fn NdrComplexArrayMarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

pub extern "RPCRT4" fn NdrSimpleStructUnmarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    ppMemory: **u8,
    pFormat: *u8,
    fMustAlloc: u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

pub extern "RPCRT4" fn NdrComplexStructUnmarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    ppMemory: **u8,
    pFormat: *u8,
    fMustAlloc: u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

pub extern "RPCRT4" fn NdrComplexArrayUnmarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    ppMemory: **u8,
    pFormat: *u8,
    fMustAlloc: u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

pub extern "RPCRT4" fn NdrUserMarshalUnmarshall(
    pStubMsg: *MIDL_STUB_MESSAGE,
    ppMemory: **u8,
    pFormat: *u8,
    fMustAlloc: u8,
) callconv(@import("std").os.windows.WINAPI) *u8;

pub extern "RPCRT4" fn NdrSimpleStructBufferSize(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "RPCRT4" fn NdrComplexStructBufferSize(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "RPCRT4" fn NdrConformantArrayBufferSize(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "RPCRT4" fn NdrComplexArrayBufferSize(
    pStubMsg: *MIDL_STUB_MESSAGE,
    pMemory: *u8,
    pFormat: *u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "SspiCli" fn GetUserNameExA(
    NameFormat: EXTENDED_NAME_FORMAT,
    lpNameBuffer: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "SspiCli" fn GetUserNameExW(
    NameFormat: EXTENDED_NAME_FORMAT,
    lpNameBuffer: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "SECUR32" fn GetComputerObjectNameA(
    NameFormat: EXTENDED_NAME_FORMAT,
    lpNameBuffer: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "SECUR32" fn GetComputerObjectNameW(
    NameFormat: EXTENDED_NAME_FORMAT,
    lpNameBuffer: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "SECUR32" fn TranslateNameA(
    lpAccountName: [*:0]const u8,
    AccountNameFormat: EXTENDED_NAME_FORMAT,
    DesiredNameFormat: EXTENDED_NAME_FORMAT,
    lpTranslatedName: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "SECUR32" fn TranslateNameW(
    lpAccountName: [*:0]const u16,
    AccountNameFormat: EXTENDED_NAME_FORMAT,
    DesiredNameFormat: EXTENDED_NAME_FORMAT,
    lpTranslatedName: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "USER32" fn DisableProcessWindowsGhosting(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "NETAPI32" fn I_NetLogonControl2(
    ServerName: ?[*:0]const u16,
    FunctionCode: u32,
    QueryLevel: u32,
    Data: *u8,
    Buffer: **u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn RtlRaiseException(
    ExceptionRecord: *EXCEPTION_RECORD,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CompareFileTime(
    lpFileTime1: *const FILETIME,
    lpFileTime2: *const FILETIME,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn FileTimeToLocalFileTime(
    lpFileTime: *const FILETIME,
    lpLocalFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetFileTime(
    hFile: HANDLE,
    lpCreationTime: ?*FILETIME,
    lpLastAccessTime: ?*FILETIME,
    lpLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LocalFileTimeToFileTime(
    lpLocalFileTime: *const FILETIME,
    lpFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetFileTime(
    hFile: HANDLE,
    lpCreationTime: ?*const FILETIME,
    lpLastAccessTime: ?*const FILETIME,
    lpLastWriteTime: ?*const FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemWow64DirectoryA(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetSystemWow64DirectoryW(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-wow64-l1-1-1" fn GetSystemWow64Directory2A(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
    ImageFileMachineType: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-wow64-l1-1-1" fn GetSystemWow64Directory2W(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
    ImageFileMachineType: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn IsWow64GuestMachineSupported(
    WowGuestMachine: u16,
    MachineIsSupported: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "loadperf" fn InstallPerfDllW(
    szComputerName: ?[*:0]const u16,
    lpIniFile: [*:0]const u16,
    dwFlags: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "loadperf" fn InstallPerfDllA(
    szComputerName: ?[*:0]const u8,
    lpIniFile: [*:0]const u8,
    dwFlags: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ole32" fn CoInstall(
    pbc: *IBindCtx,
    dwFlags: u32,
    pClassSpec: *uCLSSPEC,
    pQuery: *QUERYCONTEXT,
    pszCodeBase: PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-apiquery-l2-1-0" fn IsApiSetImplemented(
    Contract: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetEnvironmentStringsW(
    NewEnvironment: [*]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetStdHandle(
    nStdHandle: STD_HANDLE_TYPE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn SetStdHandle(
    nStdHandle: STD_HANDLE_TYPE,
    hHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetStdHandleEx(
    nStdHandle: STD_HANDLE_TYPE,
    hHandle: HANDLE,
    phPrevValue: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ExpandEnvironmentStringsA(
    lpSrc: [*:0]const u8,
    lpDst: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn ExpandEnvironmentStringsW(
    lpSrc: [*:0]const u16,
    lpDst: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetCurrentDirectoryA(
    lpPathName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCurrentDirectoryW(
    lpPathName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCurrentDirectoryA(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetCurrentDirectoryW(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn CloseHandle(
    hObject: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DuplicateHandle(
    hSourceProcessHandle: HANDLE,
    hSourceHandle: HANDLE,
    hTargetProcessHandle: HANDLE,
    lpTargetHandle: *HANDLE,
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    dwOptions: DUPLICATE_HANDLE_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-handle-l1-1-0" fn CompareObjectHandles(
    hFirstObjectHandle: HANDLE,
    hSecondObjectHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetHandleInformation(
    hObject: HANDLE,
    lpdwFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetHandleInformation(
    hObject: HANDLE,
    dwMask: u32,
    dwFlags: HANDLE_FLAG_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryPerformanceCounter(
    lpPerformanceCount: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryPerformanceFrequency(
    lpFrequency: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessDynamicEHContinuationTargets(
    Process: HANDLE,
    NumberOfTargets: u16,
    Targets: [*]PROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsProcessorFeaturePresent(
    ProcessorFeature: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemTimes(
    lpIdleTime: ?*FILETIME,
    lpKernelTime: ?*FILETIME,
    lpUserTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemCpuSetInformation(
    Information: ?[*]SYSTEM_CPU_SET_INFORMATION,
    BufferLength: u32,
    ReturnedLength: *u32,
    Process: HANDLE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessDefaultCpuSets(
    Process: HANDLE,
    CpuSetIds: ?[*]u32,
    CpuSetIdCount: u32,
    RequiredIdCount: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessDefaultCpuSets(
    Process: HANDLE,
    CpuSetIds: ?[*]const u32,
    CpuSetIdCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadSelectedCpuSets(
    Thread: HANDLE,
    CpuSetIds: ?[*]u32,
    CpuSetIdCount: u32,
    RequiredIdCount: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadSelectedCpuSets(
    Thread: HANDLE,
    CpuSetIds: [*]const u32,
    CpuSetIdCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemInfo(
    lpSystemInfo: *SYSTEM_INFO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetSystemTime(
    lpSystemTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetSystemTimeAsFileTime(
    lpSystemTimeAsFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetLocalTime(
    lpSystemTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn IsUserCetAvailableInEnvironment(
    UserCetEnvironment: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemLeapSecondInformation(
    Enabled: *BOOL,
    Flags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetVersion(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetLocalTime(
    lpSystemTime: *const SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetTickCount(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetTickCount64(
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "KERNEL32" fn GetSystemTimeAdjustment(
    lpTimeAdjustment: *u32,
    lpTimeIncrement: *u32,
    lpTimeAdjustmentDisabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-sysinfo-l1-2-4" fn GetSystemTimeAdjustmentPrecise(
    lpTimeAdjustment: *u64,
    lpTimeIncrement: *u64,
    lpTimeAdjustmentDisabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemDirectoryA(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetSystemDirectoryW(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetWindowsDirectoryA(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetWindowsDirectoryW(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetSystemWindowsDirectoryA(
    lpBuffer: ?[*:0]u8,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetSystemWindowsDirectoryW(
    lpBuffer: ?[*:0]u16,
    uSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetComputerNameExA(
    NameType: COMPUTER_NAME_FORMAT,
    lpBuffer: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetComputerNameExW(
    NameType: COMPUTER_NAME_FORMAT,
    lpBuffer: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetComputerNameExW(
    NameType: COMPUTER_NAME_FORMAT,
    lpBuffer: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetSystemTime(
    lpSystemTime: *const SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetVersionExA(
    lpVersionInformation: *OSVERSIONINFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetVersionExW(
    lpVersionInformation: *OSVERSIONINFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNativeSystemInfo(
    lpSystemInfo: *SYSTEM_INFO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetSystemTimePreciseAsFileTime(
    lpSystemTimeAsFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetProductInfo(
    dwOSMajorVersion: u32,
    dwOSMinorVersion: u32,
    dwSpMajorVersion: u32,
    dwSpMinorVersion: u32,
    pdwReturnedProductType: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VerSetConditionMask(
    ConditionMask: u64,
    TypeMask: u32,
    Condition: u8,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "api-ms-win-core-sysinfo-l1-2-0" fn GetOsSafeBootMode(
    Flags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn EnumSystemFirmwareTables(
    FirmwareTableProviderSignature: u32,
    pFirmwareTableEnumBuffer: ?[*]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetSystemFirmwareTable(
    FirmwareTableProviderSignature: u32,
    FirmwareTableID: u32,
    pFirmwareTableBuffer: ?[*]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn DnsHostnameToComputerNameExW(
    Hostname: [*:0]const u16,
    ComputerName: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetComputerNameEx2W(
    NameType: COMPUTER_NAME_FORMAT,
    Flags: u32,
    lpBuffer: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetSystemTimeAdjustment(
    dwTimeAdjustment: u32,
    bTimeAdjustmentDisabled: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-sysinfo-l1-2-4" fn SetSystemTimeAdjustmentPrecise(
    dwTimeAdjustment: u64,
    bTimeAdjustmentDisabled: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-sysinfo-l1-2-3" fn GetOsManufacturingMode(
    pbEnabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-sysinfo-l1-2-3" fn GetIntegratedDisplaySize(
    sizeInInches: *f64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn SetComputerNameA(
    lpComputerName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetComputerNameW(
    lpComputerName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetComputerNameExA(
    NameType: COMPUTER_NAME_FORMAT,
    lpBuffer: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-realtime-l1-1-1" fn QueryInterruptTimePrecise(
    lpInterruptTimePrecise: *u64,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-realtime-l1-1-1" fn QueryUnbiasedInterruptTimePrecise(
    lpUnbiasedInterruptTimePrecise: *u64,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-realtime-l1-1-1" fn QueryInterruptTime(
    lpInterruptTime: *u64,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn QueryUnbiasedInterruptTime(
    UnbiasedTime: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-realtime-l1-1-2" fn QueryAuxiliaryCounterFrequency(
    lpAuxiliaryCounterFrequency: *u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-realtime-l1-1-2" fn ConvertAuxiliaryCounterToPerformanceCounter(
    ullAuxiliaryCounterValue: u64,
    lpPerformanceCounterValue: *u64,
    lpConversionError: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-realtime-l1-1-2" fn ConvertPerformanceCounterToAuxiliaryCounter(
    ullPerformanceCounterValue: u64,
    lpAuxiliaryCounterValue: *u64,
    lpConversionError: ?*u64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn GlobalCompact(
    dwMinFree: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GlobalFix(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GlobalUnfix(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GlobalWire(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn GlobalUnWire(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LocalShrink(
    hMem: ?*c_void,
    cbNewSize: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn LocalCompact(
    uMinFree: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn SetEnvironmentStringsA(
    NewEnvironment: [*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetHandleCount(
    uNumber: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn RequestDeviceWakeup(
    hDevice: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CancelDeviceWakeupRequest(
    hDevice: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetMessageWaitingIndicator(
    hMsgIndicator: HANDLE,
    ulMsgCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn MulDiv(
    nNumber: i32,
    nNumerator: i32,
    nDenominator: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn GetSystemRegistryQuota(
    pdwQuotaAllowed: ?*u32,
    pdwQuotaUsed: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FileTimeToDosDateTime(
    lpFileTime: *const FILETIME,
    lpFatDate: *u16,
    lpFatTime: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DosDateTimeToFileTime(
    wFatDate: u16,
    wFatTime: u16,
    lpFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn _lopen(
    lpPathName: [*:0]const u8,
    iReadWrite: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _lcreat(
    lpPathName: [*:0]const u8,
    iAttribute: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _lread(
    hFile: i32,
    lpBuffer: [*]u8,
    uBytes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn _lwrite(
    hFile: i32,
    lpBuffer: [*]const u8,
    uBytes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn _hread(
    hFile: i32,
    lpBuffer: [*]u8,
    lBytes: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _hwrite(
    hFile: i32,
    lpBuffer: [*]const u8,
    lBytes: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _lclose(
    hFile: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn _llseek(
    hFile: i32,
    lOffset: i32,
    iOrigin: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn OpenMutexA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenSemaphoreA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateWaitableTimerA(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    lpTimerName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenWaitableTimerA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpTimerName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateWaitableTimerExA(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    lpTimerName: ?[*:0]const u8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn GetStartupInfoA(
    lpStartupInfo: *STARTUPINFOA,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetFirmwareEnvironmentVariableA(
    lpName: [*:0]const u8,
    lpGuid: [*:0]const u8,
    pBuffer: ?[*]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetFirmwareEnvironmentVariableW(
    lpName: [*:0]const u16,
    lpGuid: [*:0]const u16,
    pBuffer: ?[*]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetFirmwareEnvironmentVariableExA(
    lpName: [*:0]const u8,
    lpGuid: [*:0]const u8,
    pBuffer: ?[*]u8,
    nSize: u32,
    pdwAttribubutes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetFirmwareEnvironmentVariableExW(
    lpName: [*:0]const u16,
    lpGuid: [*:0]const u16,
    pBuffer: ?[*]u8,
    nSize: u32,
    pdwAttribubutes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetFirmwareEnvironmentVariableA(
    lpName: [*:0]const u8,
    lpGuid: [*:0]const u8,
    pValue: ?[*]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetFirmwareEnvironmentVariableW(
    lpName: [*:0]const u16,
    lpGuid: [*:0]const u16,
    pValue: ?[*]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetFirmwareEnvironmentVariableExA(
    lpName: [*:0]const u8,
    lpGuid: [*:0]const u8,
    pValue: ?[*]u8,
    nSize: u32,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetFirmwareEnvironmentVariableExW(
    lpName: [*:0]const u16,
    lpGuid: [*:0]const u16,
    pValue: ?[*]u8,
    nSize: u32,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetFirmwareType(
    FirmwareType: *FIRMWARE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsNativeVhdBoot(
    NativeVhdBoot: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProfileIntA(
    lpAppName: [*:0]const u8,
    lpKeyName: [*:0]const u8,
    nDefault: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetProfileIntW(
    lpAppName: [*:0]const u16,
    lpKeyName: [*:0]const u16,
    nDefault: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpDefault: ?[*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpDefault: ?[*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn WriteProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProfileSectionA(
    lpAppName: [*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetProfileSectionW(
    lpAppName: [*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn WriteProfileSectionA(
    lpAppName: [*:0]const u8,
    lpString: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteProfileSectionW(
    lpAppName: [*:0]const u16,
    lpString: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetPrivateProfileIntA(
    lpAppName: [*:0]const u8,
    lpKeyName: [*:0]const u8,
    nDefault: i32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetPrivateProfileIntW(
    lpAppName: [*:0]const u16,
    lpKeyName: [*:0]const u16,
    nDefault: i32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetPrivateProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpDefault: ?[*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetPrivateProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpDefault: ?[*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn WritePrivateProfileStringA(
    lpAppName: ?[*:0]const u8,
    lpKeyName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WritePrivateProfileStringW(
    lpAppName: ?[*:0]const u16,
    lpKeyName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetPrivateProfileSectionA(
    lpAppName: [*:0]const u8,
    lpReturnedString: ?[*:0]u8,
    nSize: u32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetPrivateProfileSectionW(
    lpAppName: [*:0]const u16,
    lpReturnedString: ?[*:0]u16,
    nSize: u32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn WritePrivateProfileSectionA(
    lpAppName: ?[*:0]const u8,
    lpString: ?[*:0]const u8,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WritePrivateProfileSectionW(
    lpAppName: ?[*:0]const u16,
    lpString: ?[*:0]const u16,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetPrivateProfileSectionNamesA(
    lpszReturnBuffer: ?[*:0]u8,
    nSize: u32,
    lpFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetPrivateProfileSectionNamesW(
    lpszReturnBuffer: ?[*:0]u16,
    nSize: u32,
    lpFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetPrivateProfileStructA(
    lpszSection: [*:0]const u8,
    lpszKey: [*:0]const u8,
    lpStruct: ?[*]u8,
    uSizeStruct: u32,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetPrivateProfileStructW(
    lpszSection: [*:0]const u16,
    lpszKey: [*:0]const u16,
    lpStruct: ?[*]u8,
    uSizeStruct: u32,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WritePrivateProfileStructA(
    lpszSection: [*:0]const u8,
    lpszKey: [*:0]const u8,
    lpStruct: ?[*]u8,
    uSizeStruct: u32,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WritePrivateProfileStructW(
    lpszSection: [*:0]const u16,
    lpszKey: [*:0]const u16,
    lpStruct: ?[*]u8,
    uSizeStruct: u32,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsBadHugeReadPtr(
    lp: ?*const c_void,
    ucb: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsBadHugeWritePtr(
    lp: ?*c_void,
    ucb: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetComputerNameA(
    lpBuffer: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetComputerNameW(
    lpBuffer: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DnsHostnameToComputerNameA(
    Hostname: [*:0]const u8,
    ComputerName: ?[*:0]u8,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DnsHostnameToComputerNameW(
    Hostname: [*:0]const u16,
    ComputerName: ?[*:0]u16,
    nSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn GetUserNameA(
    lpBuffer: ?[*:0]u8,
    pcbBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn GetUserNameW(
    lpBuffer: ?[*:0]u16,
    pcbBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn IsTokenUntrusted(
    TokenHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetTimerQueueTimer(
    TimerQueue: HANDLE,
    Callback: WAITORTIMERCALLBACK,
    Parameter: ?*c_void,
    DueTime: u32,
    Period: u32,
    PreferIo: BOOL,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CancelTimerQueueTimer(
    TimerQueue: HANDLE,
    Timer: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn GetCurrentHwProfileA(
    lpHwProfileInfo: *HW_PROFILE_INFOA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn GetCurrentHwProfileW(
    lpHwProfileInfo: *HW_PROFILE_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VerifyVersionInfoA(
    lpVersionInformation: *OSVERSIONINFOEXA,
    dwTypeMask: u32,
    dwlConditionMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VerifyVersionInfoW(
    lpVersionInformation: *OSVERSIONINFOEXW,
    dwTypeMask: u32,
    dwlConditionMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SystemTimeToTzSpecificLocalTime(
    lpTimeZoneInformation: ?*const TIME_ZONE_INFORMATION,
    lpUniversalTime: *const SYSTEMTIME,
    lpLocalTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn TzSpecificLocalTimeToSystemTime(
    lpTimeZoneInformation: ?*const TIME_ZONE_INFORMATION,
    lpLocalTime: *const SYSTEMTIME,
    lpUniversalTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FileTimeToSystemTime(
    lpFileTime: *const FILETIME,
    lpSystemTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SystemTimeToFileTime(
    lpSystemTime: *const SYSTEMTIME,
    lpFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetTimeZoneInformation(
    lpTimeZoneInformation: *TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetTimeZoneInformation(
    lpTimeZoneInformation: *const TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetDynamicTimeZoneInformation(
    lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetDynamicTimeZoneInformation(
    pTimeZoneInformation: *DYNAMIC_TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetTimeZoneInformationForYear(
    wYear: u16,
    pdtzi: ?*DYNAMIC_TIME_ZONE_INFORMATION,
    ptzi: *TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn EnumDynamicTimeZoneInformation(
    dwIndex: u32,
    lpTimeZoneInformation: *DYNAMIC_TIME_ZONE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVAPI32" fn GetDynamicTimeZoneInformationEffectiveYears(
    lpTimeZoneInformation: *const DYNAMIC_TIME_ZONE_INFORMATION,
    FirstYear: *u32,
    LastYear: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SystemTimeToTzSpecificLocalTimeEx(
    lpTimeZoneInformation: ?*const DYNAMIC_TIME_ZONE_INFORMATION,
    lpUniversalTime: *const SYSTEMTIME,
    lpLocalTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn TzSpecificLocalTimeToSystemTimeEx(
    lpTimeZoneInformation: ?*const DYNAMIC_TIME_ZONE_INFORMATION,
    lpLocalTime: *const SYSTEMTIME,
    lpUniversalTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LocalFileTimeToLocalSystemTime(
    timeZoneInformation: ?*const TIME_ZONE_INFORMATION,
    localFileTime: *const FILETIME,
    localSystemTime: *SYSTEMTIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LocalSystemTimeToLocalFileTime(
    timeZoneInformation: ?*const TIME_ZONE_INFORMATION,
    localSystemTime: *const SYSTEMTIME,
    localFileTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateJobSet(
    NumJob: u32,
    UserJobSet: [*]JOB_SET_ARRAY,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReplacePartitionUnit(
    TargetPartition: PWSTR,
    SparePartition: PWSTR,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitializeContext2(
    Buffer: ?[*]u8,
    ContextFlags: u32,
    Context: **CONTEXT,
    ContextLength: *u32,
    XStateCompactionMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-backgroundtask-l1-1-0" fn RaiseCustomSystemEventTrigger(
    CustomSystemEventTriggerConfig: *CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVAPI32" fn RegCloseKey(
    hKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegOverridePredefKey(
    hKey: HKEY,
    hNewHKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegOpenUserClassesRoot(
    hToken: HANDLE,
    dwOptions: u32,
    samDesired: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegOpenCurrentUser(
    samDesired: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDisablePredefinedCache(
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDisablePredefinedCacheEx(
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegConnectRegistryA(
    lpMachineName: ?[*:0]const u8,
    hKey: HKEY,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegConnectRegistryW(
    lpMachineName: ?[*:0]const u16,
    hKey: HKEY,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegConnectRegistryExA(
    lpMachineName: ?[*:0]const u8,
    hKey: HKEY,
    Flags: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegConnectRegistryExW(
    lpMachineName: ?[*:0]const u16,
    hKey: HKEY,
    Flags: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegCreateKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegCreateKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegCreateKeyExA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
    Reserved: u32,
    lpClass: ?PSTR,
    dwOptions: u32,
    samDesired: u32,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: *HKEY,
    lpdwDisposition: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegCreateKeyExW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
    Reserved: u32,
    lpClass: ?PWSTR,
    dwOptions: u32,
    samDesired: u32,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: *HKEY,
    lpdwDisposition: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegCreateKeyTransactedA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
    Reserved: u32,
    lpClass: ?PSTR,
    dwOptions: u32,
    samDesired: u32,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: *HKEY,
    lpdwDisposition: ?*u32,
    hTransaction: HANDLE,
    pExtendedParemeter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegCreateKeyTransactedW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
    Reserved: u32,
    lpClass: ?PWSTR,
    dwOptions: u32,
    samDesired: u32,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    phkResult: *HKEY,
    lpdwDisposition: ?*u32,
    hTransaction: HANDLE,
    pExtendedParemeter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteKeyA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteKeyW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteKeyExA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
    samDesired: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteKeyExW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
    samDesired: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteKeyTransactedA(
    hKey: HKEY,
    lpSubKey: [*:0]const u8,
    samDesired: u32,
    Reserved: u32,
    hTransaction: HANDLE,
    pExtendedParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteKeyTransactedW(
    hKey: HKEY,
    lpSubKey: [*:0]const u16,
    samDesired: u32,
    Reserved: u32,
    hTransaction: HANDLE,
    pExtendedParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDisableReflectionKey(
    hBase: HKEY,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ADVAPI32" fn RegEnableReflectionKey(
    hBase: HKEY,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ADVAPI32" fn RegQueryReflectionKey(
    hBase: HKEY,
    bIsReflectionDisabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ADVAPI32" fn RegDeleteValueA(
    hKey: HKEY,
    lpValueName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteValueW(
    hKey: HKEY,
    lpValueName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegEnumKeyA(
    hKey: HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u8,
    cchName: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegEnumKeyW(
    hKey: HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u16,
    cchName: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegEnumKeyExA(
    hKey: HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u8,
    lpcchName: *u32,
    lpReserved: *u32,
    lpClass: ?[*:0]u8,
    lpcchClass: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegEnumKeyExW(
    hKey: HKEY,
    dwIndex: u32,
    lpName: ?[*:0]u16,
    lpcchName: *u32,
    lpReserved: *u32,
    lpClass: ?[*:0]u16,
    lpcchClass: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegEnumValueA(
    hKey: HKEY,
    dwIndex: u32,
    lpValueName: ?[*:0]u8,
    lpcchValueName: *u32,
    lpReserved: *u32,
    lpType: ?*u32,
    lpData: ?[*:0]u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegEnumValueW(
    hKey: HKEY,
    dwIndex: u32,
    lpValueName: ?[*:0]u16,
    lpcchValueName: *u32,
    lpReserved: *u32,
    lpType: ?*u32,
    lpData: ?[*:0]u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegFlushKey(
    hKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegLoadKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpFile: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegLoadKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpFile: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegNotifyChangeKeyValue(
    hKey: HKEY,
    bWatchSubtree: BOOL,
    dwNotifyFilter: u32,
    hEvent: HANDLE,
    fAsynchronous: BOOL,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegOpenKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegOpenKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegOpenKeyExA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    ulOptions: u32,
    samDesired: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegOpenKeyExW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    ulOptions: u32,
    samDesired: u32,
    phkResult: *HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegOpenKeyTransactedA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    ulOptions: u32,
    samDesired: u32,
    phkResult: *HKEY,
    hTransaction: HANDLE,
    pExtendedParemeter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegOpenKeyTransactedW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    ulOptions: u32,
    samDesired: u32,
    phkResult: *HKEY,
    hTransaction: HANDLE,
    pExtendedParemeter: *c_void,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegQueryInfoKeyA(
    hKey: HKEY,
    lpClass: ?[*:0]u8,
    lpcchClass: ?*u32,
    lpReserved: *u32,
    lpcSubKeys: ?*u32,
    lpcbMaxSubKeyLen: ?*u32,
    lpcbMaxClassLen: ?*u32,
    lpcValues: ?*u32,
    lpcbMaxValueNameLen: ?*u32,
    lpcbMaxValueLen: ?*u32,
    lpcbSecurityDescriptor: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegQueryInfoKeyW(
    hKey: HKEY,
    lpClass: ?[*:0]u16,
    lpcchClass: ?*u32,
    lpReserved: *u32,
    lpcSubKeys: ?*u32,
    lpcbMaxSubKeyLen: ?*u32,
    lpcbMaxClassLen: ?*u32,
    lpcValues: ?*u32,
    lpcbMaxValueNameLen: ?*u32,
    lpcbMaxValueLen: ?*u32,
    lpcbSecurityDescriptor: ?*u32,
    lpftLastWriteTime: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegQueryValueA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpData: ?[*:0]u8,
    lpcbData: ?*i32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegQueryValueW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpData: ?[*:0]u16,
    lpcbData: ?*i32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegQueryMultipleValuesA(
    hKey: HKEY,
    val_list: [*]VALENTA,
    num_vals: u32,
    lpValueBuf: ?[*:0]u8,
    ldwTotsize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegQueryMultipleValuesW(
    hKey: HKEY,
    val_list: [*]VALENTW,
    num_vals: u32,
    lpValueBuf: ?[*:0]u16,
    ldwTotsize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegQueryValueExA(
    hKey: HKEY,
    lpValueName: ?[*:0]const u8,
    lpReserved: *u32,
    lpType: ?*u32,
    lpData: ?[*:0]u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegQueryValueExW(
    hKey: HKEY,
    lpValueName: ?[*:0]const u16,
    lpReserved: *u32,
    lpType: ?*u32,
    lpData: ?[*:0]u8,
    lpcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegReplaceKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpNewFile: [*:0]const u8,
    lpOldFile: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegReplaceKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpNewFile: [*:0]const u16,
    lpOldFile: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegRestoreKeyA(
    hKey: HKEY,
    lpFile: [*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegRestoreKeyW(
    hKey: HKEY,
    lpFile: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegRenameKey(
    hKey: HKEY,
    lpSubKeyName: ?[*:0]const u16,
    lpNewKeyName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegSaveKeyA(
    hKey: HKEY,
    lpFile: [*:0]const u8,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegSaveKeyW(
    hKey: HKEY,
    lpFile: [*:0]const u16,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegSetValueA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    dwType: u32,
    lpData: ?[*:0]const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegSetValueW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    dwType: u32,
    lpData: ?[*:0]const u16,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegSetValueExA(
    hKey: HKEY,
    lpValueName: ?[*:0]const u8,
    Reserved: u32,
    dwType: u32,
    lpData: ?[*:0]const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegSetValueExW(
    hKey: HKEY,
    lpValueName: ?[*:0]const u16,
    Reserved: u32,
    dwType: u32,
    lpData: ?[*:0]const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegUnLoadKeyA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegUnLoadKeyW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteKeyValueA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpValueName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteKeyValueW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpValueName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegSetKeyValueA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpValueName: ?[*:0]const u8,
    dwType: u32,
    lpData: ?[*]const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegSetKeyValueW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpValueName: ?[*:0]const u16,
    dwType: u32,
    lpData: ?[*]const u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteTreeA(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegDeleteTreeW(
    hKey: HKEY,
    lpSubKey: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegCopyTreeA(
    hKeySrc: HKEY,
    lpSubKey: ?[*:0]const u8,
    hKeyDest: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegGetValueA(
    hkey: HKEY,
    lpSubKey: ?[*:0]const u8,
    lpValue: ?[*:0]const u8,
    dwFlags: u32,
    pdwType: ?*u32,
    pvData: ?[*]u8,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegGetValueW(
    hkey: HKEY,
    lpSubKey: ?[*:0]const u16,
    lpValue: ?[*:0]const u16,
    dwFlags: u32,
    pdwType: ?*u32,
    pvData: ?[*]u8,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegCopyTreeW(
    hKeySrc: HKEY,
    lpSubKey: ?[*:0]const u16,
    hKeyDest: HKEY,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegLoadMUIStringA(
    hKey: HKEY,
    pszValue: ?[*:0]const u8,
    pszOutBuf: ?[*:0]u8,
    cbOutBuf: u32,
    pcbData: ?*u32,
    Flags: u32,
    pszDirectory: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegLoadMUIStringW(
    hKey: HKEY,
    pszValue: ?[*:0]const u16,
    pszOutBuf: ?[*:0]u16,
    cbOutBuf: u32,
    pcbData: ?*u32,
    Flags: u32,
    pszDirectory: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegLoadAppKeyA(
    lpFile: [*:0]const u8,
    phkResult: *HKEY,
    samDesired: u32,
    dwOptions: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegLoadAppKeyW(
    lpFile: [*:0]const u16,
    phkResult: *HKEY,
    samDesired: u32,
    dwOptions: u32,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn CheckForHiberboot(
    pHiberboot: *u8,
    bClearFlag: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVAPI32" fn RegSaveKeyExA(
    hKey: HKEY,
    lpFile: [*:0]const u8,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ADVAPI32" fn RegSaveKeyExW(
    hKey: HKEY,
    lpFile: [*:0]const u16,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;

pub extern "ntdll" fn NtClose(
    Handle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtCreateFile(
    FileHandle: *HANDLE,
    DesiredAccess: u32,
    ObjectAttributes: *OBJECT_ATTRIBUTES,
    IoStatusBlock: *IO_STATUS_BLOCK,
    AllocationSize: *LARGE_INTEGER,
    FileAttributes: u32,
    ShareAccess: u32,
    CreateDisposition: u32,
    CreateOptions: u32,
    EaBuffer: *c_void,
    EaLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtOpenFile(
    FileHandle: *HANDLE,
    DesiredAccess: u32,
    ObjectAttributes: *OBJECT_ATTRIBUTES,
    IoStatusBlock: *IO_STATUS_BLOCK,
    ShareAccess: u32,
    OpenOptions: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtRenameKey(
    KeyHandle: HANDLE,
    NewName: *UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtNotifyChangeMultipleKeys(
    MasterKeyHandle: HANDLE,
    Count: u32,
    SubordinateObjects: ?[*]OBJECT_ATTRIBUTES,
    Event: HANDLE,
    ApcRoutine: ?PIO_APC_ROUTINE,
    ApcContext: ?*c_void,
    IoStatusBlock: *IO_STATUS_BLOCK,
    CompletionFilter: u32,
    WatchTree: u8,
    Buffer: ?[*]u8,
    BufferSize: u32,
    Asynchronous: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQueryMultipleValueKey(
    KeyHandle: HANDLE,
    ValueEntries: [*]KEY_VALUE_ENTRY,
    EntryCount: u32,
    ValueBuffer: [*]u8,
    BufferLength: *u32,
    RequiredBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtSetInformationKey(
    KeyHandle: HANDLE,
    KeySetInformationClass: KEY_SET_INFORMATION_CLASS,
    KeySetInformation: [*]u8,
    KeySetInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtDeviceIoControlFile(
    FileHandle: HANDLE,
    Event: HANDLE,
    ApcRoutine: PIO_APC_ROUTINE,
    ApcContext: *c_void,
    IoStatusBlock: *IO_STATUS_BLOCK,
    IoControlCode: u32,
    InputBuffer: *c_void,
    InputBufferLength: u32,
    OutputBuffer: *c_void,
    OutputBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtWaitForSingleObject(
    Handle: HANDLE,
    Alertable: u8,
    Timeout: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlIsNameLegalDOS8Dot3(
    Name: *UNICODE_STRING,
    OemName: *STRING,
    NameContainsSpaces: *u8,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ntdll" fn NtQueryObject(
    Handle: HANDLE,
    ObjectInformationClass: OBJECT_INFORMATION_CLASS,
    ObjectInformation: ?[*]u8,
    ObjectInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQuerySystemInformation(
    SystemInformationClass: SYSTEM_INFORMATION_CLASS,
    SystemInformation: *c_void,
    SystemInformationLength: u32,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQuerySystemTime(
    SystemTime: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlLocalTimeToSystemTime(
    LocalTime: *LARGE_INTEGER,
    SystemTime: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlTimeToSecondsSince1970(
    Time: *LARGE_INTEGER,
    ElapsedSeconds: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ntdll" fn RtlFreeAnsiString(
    AnsiString: *STRING,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlFreeUnicodeString(
    UnicodeString: *UNICODE_STRING,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlFreeOemString(
    OemString: *STRING,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlInitString(
    DestinationString: *STRING,
    SourceString: *i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlInitStringEx(
    DestinationString: *STRING,
    SourceString: *i8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlInitAnsiString(
    DestinationString: *STRING,
    SourceString: *i8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlInitAnsiStringEx(
    DestinationString: *STRING,
    SourceString: *i8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlInitUnicodeString(
    DestinationString: *UNICODE_STRING,
    SourceString: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlAnsiStringToUnicodeString(
    DestinationString: *UNICODE_STRING,
    SourceString: *STRING,
    AllocateDestinationString: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlUnicodeStringToAnsiString(
    DestinationString: *STRING,
    SourceString: *UNICODE_STRING,
    AllocateDestinationString: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlUnicodeStringToOemString(
    DestinationString: *STRING,
    SourceString: *UNICODE_STRING,
    AllocateDestinationString: u8,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlUnicodeToMultiByteSize(
    BytesInMultiByteString: *u32,
    UnicodeString: [*]u16,
    BytesInUnicodeString: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlCharToInteger(
    String: *i8,
    Base: u32,
    Value: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn RtlUniform(
    Seed: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "Cabinet" fn FCICreate(
    perf: *ERF,
    pfnfcifp: PFNFCIFILEPLACED,
    pfna: PFNFCIALLOC,
    pfnf: PFNFCIFREE,
    pfnopen: PFNFCIOPEN,
    pfnread: PFNFCIREAD,
    pfnwrite: PFNFCIWRITE,
    pfnclose: PFNFCICLOSE,
    pfnseek: PFNFCISEEK,
    pfndelete: PFNFCIDELETE,
    pfnfcigtf: PFNFCIGETTEMPFILE,
    pccab: *CCAB,
    pv: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "Cabinet" fn FCIAddFile(
    hfci: *c_void,
    pszSourceFile: PSTR,
    pszFileName: PSTR,
    fExecute: BOOL,
    pfnfcignc: PFNFCIGETNEXTCABINET,
    pfnfcis: PFNFCISTATUS,
    pfnfcigoi: PFNFCIGETOPENINFO,
    typeCompress: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FCIFlushCabinet(
    hfci: *c_void,
    fGetNextCab: BOOL,
    pfnfcignc: PFNFCIGETNEXTCABINET,
    pfnfcis: PFNFCISTATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FCIFlushFolder(
    hfci: *c_void,
    pfnfcignc: PFNFCIGETNEXTCABINET,
    pfnfcis: PFNFCISTATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FCIDestroy(
    hfci: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FDICreate(
    pfnalloc: PFNALLOC,
    pfnfree: PFNFREE,
    pfnopen: PFNOPEN,
    pfnread: PFNREAD,
    pfnwrite: PFNWRITE,
    pfnclose: PFNCLOSE,
    pfnseek: PFNSEEK,
    cpuType: i32,
    perf: *ERF,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "Cabinet" fn FDIIsCabinet(
    hfdi: *c_void,
    hf: ?*c_void,
    pfdici: ?*FDICABINETINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FDICopy(
    hfdi: *c_void,
    pszCabinet: PSTR,
    pszCabPath: PSTR,
    flags: i32,
    pfnfdin: PFNFDINOTIFY,
    pfnfdid: PFNFDIDECRYPT,
    pvUser: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FDIDestroy(
    hfdi: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Cabinet" fn FDITruncateCabinet(
    hfdi: *c_void,
    pszCabinetName: PSTR,
    iFolderToDelete: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn GetFeatureEnabledState(
    featureId: u32,
    changeTime: FEATURE_CHANGE_TIME,
) callconv(@import("std").os.windows.WINAPI) FEATURE_ENABLED_STATE;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn RecordFeatureUsage(
    featureId: u32,
    kind: u32,
    addend: u32,
    originName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn RecordFeatureError(
    featureId: u32,
    @"error": *const FEATURE_ERROR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn SubscribeFeatureStateChangeNotification(
    subscription: **FEATURE_STATE_CHANGE_SUBSCRIPTION__,
    callback: PFEATURE_STATE_CHANGE_CALLBACK,
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-0" fn UnsubscribeFeatureStateChangeNotification(
    subscription: *FEATURE_STATE_CHANGE_SUBSCRIPTION__,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-core-featurestaging-l1-1-1" fn GetFeatureVariant(
    featureId: u32,
    changeTime: FEATURE_CHANGE_TIME,
    payloadId: *u32,
    hasNotification: *BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "fhsvcctl" fn FhServiceOpenPipe(
    StartServiceIfStopped: BOOL,
    Pipe: **FH_SERVICE_PIPE_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "fhsvcctl" fn FhServiceClosePipe(
    Pipe: *FH_SERVICE_PIPE_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "fhsvcctl" fn FhServiceStartBackup(
    Pipe: *FH_SERVICE_PIPE_HANDLE__,
    LowPriorityIo: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "fhsvcctl" fn FhServiceStopBackup(
    Pipe: *FH_SERVICE_PIPE_HANDLE__,
    StopTracking: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "fhsvcctl" fn FhServiceReloadConfiguration(
    Pipe: *FH_SERVICE_PIPE_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "fhsvcctl" fn FhServiceBlockBackup(
    Pipe: *FH_SERVICE_PIPE_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "fhsvcctl" fn FhServiceUnblockBackup(
    Pipe: *FH_SERVICE_PIPE_HANDLE__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "DCIMAN32" fn DCIOpenProvider(
) callconv(@import("std").os.windows.WINAPI) HDC;

pub extern "DCIMAN32" fn DCICloseProvider(
    hdc: HDC,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "DCIMAN32" fn DCICreatePrimary(
    hdc: HDC,
    lplpSurface: **DCISURFACEINFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCICreateOffscreen(
    hdc: HDC,
    dwCompression: u32,
    dwRedMask: u32,
    dwGreenMask: u32,
    dwBlueMask: u32,
    dwWidth: u32,
    dwHeight: u32,
    dwDCICaps: u32,
    dwBitCount: u32,
    lplpSurface: **DCIOFFSCREEN,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCICreateOverlay(
    hdc: HDC,
    lpOffscreenSurf: *c_void,
    lplpSurface: **DCIOVERLAY,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCIEnum(
    hdc: HDC,
    lprDst: *RECT,
    lprSrc: *RECT,
    lpFnCallback: *c_void,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCISetSrcDestClip(
    pdci: *DCIOFFSCREEN,
    srcrc: *RECT,
    destrc: *RECT,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn WinWatchOpen(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) *HWINWATCH__;

pub extern "DCIMAN32" fn WinWatchClose(
    hWW: *HWINWATCH__,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "DCIMAN32" fn WinWatchGetClipList(
    hWW: *HWINWATCH__,
    prc: *RECT,
    size: u32,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "DCIMAN32" fn WinWatchDidStatusChange(
    hWW: *HWINWATCH__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "DCIMAN32" fn GetWindowRegionData(
    hwnd: HWND,
    size: u32,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "DCIMAN32" fn GetDCRegionData(
    hdc: HDC,
    size: u32,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "DCIMAN32" fn WinWatchNotify(
    hWW: *HWINWATCH__,
    NotifyCallback: WINWATCHNOTIFYPROC,
    NotifyParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "DCIMAN32" fn DCIEndAccess(
    pdci: *DCISURFACEINFO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "DCIMAN32" fn DCIBeginAccess(
    pdci: *DCISURFACEINFO,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCIDestroy(
    pdci: *DCISURFACEINFO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "DCIMAN32" fn DCIDraw(
    pdci: *DCIOFFSCREEN,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCISetClipList(
    pdci: *DCIOFFSCREEN,
    prd: *RGNDATA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "DCIMAN32" fn DCISetDestination(
    pdci: *DCIOFFSCREEN,
    dst: *RECT,
    src: *RECT,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "api-ms-win-dx-d3dkmt-l1-1-0" fn GdiEntry13(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVPACK" fn RunSetupCommandA(
    hWnd: HWND,
    szCmdName: [*:0]const u8,
    szInfSection: [*:0]const u8,
    szDir: [*:0]const u8,
    lpszTitle: [*:0]const u8,
    phEXE: *HANDLE,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RunSetupCommandW(
    hWnd: HWND,
    szCmdName: [*:0]const u16,
    szInfSection: [*:0]const u16,
    szDir: [*:0]const u16,
    lpszTitle: [*:0]const u16,
    phEXE: *HANDLE,
    dwFlags: u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn NeedRebootInit(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVPACK" fn NeedReboot(
    dwRebootCheck: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVPACK" fn RebootCheckOnInstallA(
    hwnd: HWND,
    pszINF: [*:0]const u8,
    pszSec: [*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RebootCheckOnInstallW(
    hwnd: HWND,
    pszINF: [*:0]const u16,
    pszSec: [*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn TranslateInfStringA(
    pszInfFilename: [*:0]const u8,
    pszInstallSection: [*:0]const u8,
    pszTranslateSection: [*:0]const u8,
    pszTranslateKey: [*:0]const u8,
    pszBuffer: ?[*:0]u8,
    cchBuffer: u32,
    pdwRequiredSize: *u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn TranslateInfStringW(
    pszInfFilename: [*:0]const u16,
    pszInstallSection: [*:0]const u16,
    pszTranslateSection: [*:0]const u16,
    pszTranslateKey: [*:0]const u16,
    pszBuffer: ?[*:0]u16,
    cchBuffer: u32,
    pdwRequiredSize: *u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegInstallA(
    hmod: ?*c_void,
    pszSection: [*:0]const u8,
    pstTable: *const STRTABLEA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegInstallW(
    hmod: ?*c_void,
    pszSection: [*:0]const u16,
    pstTable: *const STRTABLEW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn LaunchINFSectionExW(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: PWSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn ExecuteCabA(
    hwnd: HWND,
    pCab: *_CabInfoA,
    pReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn ExecuteCabW(
    hwnd: HWND,
    pCab: *_CabInfoW,
    pReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn AdvInstallFileA(
    hwnd: HWND,
    lpszSourceDir: [*:0]const u8,
    lpszSourceFile: [*:0]const u8,
    lpszDestDir: [*:0]const u8,
    lpszDestFile: [*:0]const u8,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn AdvInstallFileW(
    hwnd: HWND,
    lpszSourceDir: [*:0]const u16,
    lpszSourceFile: [*:0]const u16,
    lpszDestDir: [*:0]const u16,
    lpszDestFile: [*:0]const u16,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegSaveRestoreA(
    hWnd: HWND,
    pszTitleString: [*:0]const u8,
    hkBckupKey: HKEY,
    pcszRootKey: [*:0]const u8,
    pcszSubKey: [*:0]const u8,
    pcszValueName: [*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegSaveRestoreW(
    hWnd: HWND,
    pszTitleString: [*:0]const u16,
    hkBckupKey: HKEY,
    pcszRootKey: [*:0]const u16,
    pcszSubKey: [*:0]const u16,
    pcszValueName: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegSaveRestoreOnINFA(
    hWnd: HWND,
    pszTitle: [*:0]const u8,
    pszINF: [*:0]const u8,
    pszSection: [*:0]const u8,
    hHKLMBackKey: HKEY,
    hHKCUBackKey: HKEY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegSaveRestoreOnINFW(
    hWnd: HWND,
    pszTitle: [*:0]const u16,
    pszINF: [*:0]const u16,
    pszSection: [*:0]const u16,
    hHKLMBackKey: HKEY,
    hHKCUBackKey: HKEY,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegRestoreAllA(
    hWnd: HWND,
    pszTitleString: ?[*:0]const u8,
    hkBckupKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn RegRestoreAllW(
    hWnd: HWND,
    pszTitleString: ?[*:0]const u16,
    hkBckupKey: HKEY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveRestoreW(
    hDlg: HWND,
    lpFileList: ?PWSTR,
    lpDir: [*:0]const u16,
    lpBaseName: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveRestoreOnINFA(
    hWnd: HWND,
    pszTitle: [*:0]const u8,
    pszINF: [*:0]const u8,
    pszSection: [*:0]const u8,
    pszBackupDir: [*:0]const u8,
    pszBaseBackupFile: [*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveRestoreOnINFW(
    hWnd: HWND,
    pszTitle: [*:0]const u16,
    pszINF: [*:0]const u16,
    pszSection: [*:0]const u16,
    pszBackupDir: [*:0]const u16,
    pszBaseBackupFile: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn AddDelBackupEntryA(
    lpcszFileList: ?[*:0]const u8,
    lpcszBackupDir: ?[*:0]const u8,
    lpcszBaseName: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn AddDelBackupEntryW(
    lpcszFileList: ?[*:0]const u16,
    lpcszBackupDir: ?[*:0]const u16,
    lpcszBaseName: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveMarkNotExistA(
    lpFileList: ?[*:0]const u8,
    lpDir: ?[*:0]const u8,
    lpBaseName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn FileSaveMarkNotExistW(
    lpFileList: ?[*:0]const u16,
    lpDir: ?[*:0]const u16,
    lpBaseName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn GetVersionFromFileA(
    lpszFilename: [*:0]const u8,
    pdwMSVer: *u32,
    pdwLSVer: *u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn GetVersionFromFileW(
    lpszFilename: [*:0]const u16,
    pdwMSVer: *u32,
    pdwLSVer: *u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn GetVersionFromFileExA(
    lpszFilename: [*:0]const u8,
    pdwMSVer: *u32,
    pdwLSVer: *u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn GetVersionFromFileExW(
    lpszFilename: [*:0]const u16,
    pdwMSVer: *u32,
    pdwLSVer: *u32,
    bVersion: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn IsNTAdmin(
    dwReserved: u32,
    lpdwReserved: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVPACK" fn DelNodeA(
    pszFileOrDirName: [*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn DelNodeW(
    pszFileOrDirName: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn DelNodeRunDLL32W(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: PWSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn OpenINFEngineA(
    pszInfFilename: [*:0]const u8,
    pszInstallSection: [*:0]const u8,
    dwFlags: u32,
    phInf: **c_void,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn OpenINFEngineW(
    pszInfFilename: [*:0]const u16,
    pszInstallSection: [*:0]const u16,
    dwFlags: u32,
    phInf: **c_void,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn TranslateInfStringExA(
    hInf: *c_void,
    pszInfFilename: [*:0]const u8,
    pszTranslateSection: [*:0]const u8,
    pszTranslateKey: [*:0]const u8,
    pszBuffer: [*:0]u8,
    dwBufferSize: u32,
    pdwRequiredSize: *u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn TranslateInfStringExW(
    hInf: *c_void,
    pszInfFilename: [*:0]const u16,
    pszTranslateSection: [*:0]const u16,
    pszTranslateKey: [*:0]const u16,
    pszBuffer: [*:0]u16,
    dwBufferSize: u32,
    pdwRequiredSize: *u32,
    pvReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn CloseINFEngine(
    hInf: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn ExtractFilesA(
    pszCabName: [*:0]const u8,
    pszExpandDir: [*:0]const u8,
    dwFlags: u32,
    pszFileList: [*:0]const u8,
    lpReserved: *c_void,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn ExtractFilesW(
    pszCabName: [*:0]const u16,
    pszExpandDir: [*:0]const u16,
    dwFlags: u32,
    pszFileList: [*:0]const u16,
    lpReserved: *c_void,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn LaunchINFSectionW(
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    pszParams: PWSTR,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ADVPACK" fn UserInstStubWrapperA(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: [*:0]const u8,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn UserInstStubWrapperW(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: [*:0]const u16,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn UserUnInstStubWrapperA(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: [*:0]const u8,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn UserUnInstStubWrapperW(
    hwnd: HWND,
    hInstance: HINSTANCE,
    pszParms: [*:0]const u16,
    nShow: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn SetPerUserSecValuesA(
    pPerUser: *PERUSERSECTIONA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "ADVPACK" fn SetPerUserSecValuesW(
    pPerUser: *PERUSERSECTIONW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "USER32" fn SendIMEMessageExA(
    param0: HWND,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "USER32" fn SendIMEMessageExW(
    param0: HWND,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "USER32" fn IMPGetIMEA(
    param0: HWND,
    param1: *IMEPROA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPGetIMEW(
    param0: HWND,
    param1: *IMEPROW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPQueryIMEA(
    param0: *IMEPROA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPQueryIMEW(
    param0: *IMEPROW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPSetIMEA(
    param0: HWND,
    param1: *IMEPROA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IMPSetIMEW(
    param0: HWND,
    param1: *IMEPROW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn WINNLSGetIMEHotkey(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "USER32" fn WINNLSEnableIME(
    param0: HWND,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn WINNLSGetEnableStatus(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-security-isolatedcontainer-l1-1-1" fn IsProcessInWDAGContainer(
    Reserved: *c_void,
    isProcessInWDAGContainer: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-security-isolatedcontainer-l1-1-0" fn IsProcessInIsolatedContainer(
    isProcessInIsolatedContainer: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WSCAPI" fn WscRegisterForChanges(
    Reserved: *c_void,
    phCallbackRegistration: *HANDLE,
    lpCallbackAddress: LPTHREAD_START_ROUTINE,
    pContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WSCAPI" fn WscUnRegisterChanges(
    hRegistrationHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WSCAPI" fn WscRegisterForUserNotifications(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WSCAPI" fn WscGetSecurityProviderHealth(
    Providers: u32,
    pHealth: *WSC_SECURITY_PROVIDER_HEALTH,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WSCAPI" fn WscQueryAntiMalwareUri(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WSCAPI" fn WscGetAntiMalwareUri(
    ppszUri: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "APPHELP" fn ApphelpCheckShellObject(
    ObjectCLSID: *const Guid,
    bShimIfNecessary: BOOL,
    pullFlags: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "Wldp" fn WldpGetLockdownPolicy(
    hostInformation: ?*WLDP_HOST_INFORMATION,
    lockdownState: *u32,
    lockdownFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Wldp" fn WldpIsClassInApprovedList(
    classID: *const Guid,
    hostInformation: *WLDP_HOST_INFORMATION,
    isApproved: *BOOL,
    optionalFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Wldp" fn WldpSetDynamicCodeTrust(
    fileHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Wldp" fn WldpIsDynamicCodePolicyEnabled(
    isEnabled: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "Wldp" fn WldpQueryDynamicCodeTrust(
    fileHandle: HANDLE,
    baseImage: ?[*]u8,
    imageSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn CeipIsOptedIn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "XmlLite" fn CreateXmlReader(
    riid: *const Guid,
    ppvObject: **c_void,
    pMalloc: ?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlReaderInputWithEncodingCodePage(
    pInputStream: *IUnknown,
    pMalloc: ?*IMalloc,
    nEncodingCodePage: u32,
    fEncodingHint: BOOL,
    pwszBaseUri: ?[*:0]const u16,
    ppInput: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlReaderInputWithEncodingName(
    pInputStream: *IUnknown,
    pMalloc: ?*IMalloc,
    pwszEncodingName: [*:0]const u16,
    fEncodingHint: BOOL,
    pwszBaseUri: ?[*:0]const u16,
    ppInput: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlWriter(
    riid: *const Guid,
    ppvObject: **c_void,
    pMalloc: ?*IMalloc,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlWriterOutputWithEncodingCodePage(
    pOutputStream: *IUnknown,
    pMalloc: ?*IMalloc,
    nEncodingCodePage: u32,
    ppOutput: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "XmlLite" fn CreateXmlWriterOutputWithEncodingName(
    pOutputStream: *IUnknown,
    pMalloc: ?*IMalloc,
    pwszEncodingName: [*:0]const u16,
    ppOutput: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevCreateObjectQuery(
    ObjectType: DEV_OBJECT_TYPE,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevCreateObjectQueryEx(
    ObjectType: DEV_OBJECT_TYPE,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevCreateObjectQueryFromId(
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevCreateObjectQueryFromIdEx(
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevCreateObjectQueryFromIds(
    ObjectType: DEV_OBJECT_TYPE,
    pszzObjectIds: [*]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevCreateObjectQueryFromIdsEx(
    ObjectType: DEV_OBJECT_TYPE,
    pszzObjectIds: [*]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pCallback: PDEV_QUERY_RESULT_CALLBACK,
    pContext: ?*c_void,
    phDevQuery: **HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevCloseObjectQuery(
    hDevQuery: *HDEVQUERY__,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevGetObjects(
    ObjectType: DEV_OBJECT_TYPE,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    pcObjectCount: *u32,
    ppObjects: ?*const ?*const DEV_OBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevGetObjectsEx(
    ObjectType: DEV_OBJECT_TYPE,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: ?[*]const DEVPROPCOMPKEY,
    cFilterExpressionCount: u32,
    pFilter: ?[*]const DEVPROP_FILTER_EXPRESSION,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pcObjectCount: *u32,
    ppObjects: ?*const ?*const DEV_OBJECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevFreeObjects(
    cObjectCount: u32,
    pObjects: [*]const DEV_OBJECT,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevGetObjectProperties(
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: [*]const DEVPROPCOMPKEY,
    pcPropertyCount: *u32,
    ppProperties: *const *const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-1" fn DevGetObjectPropertiesEx(
    ObjectType: DEV_OBJECT_TYPE,
    pszObjectId: [*:0]const u16,
    QueryFlags: u32,
    cRequestedProperties: u32,
    pRequestedProperties: [*]const DEVPROPCOMPKEY,
    cExtendedParameterCount: u32,
    pExtendedParameters: ?[*]const DEV_QUERY_PARAMETER,
    pcPropertyCount: *u32,
    ppProperties: *const *const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevFreeObjectProperties(
    cPropertyCount: u32,
    pProperties: [*]const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "api-ms-win-devices-query-l1-1-0" fn DevFindProperty(
    pKey: *const DEVPROPKEY,
    Store: DEVPROPSTORE,
    pszLocaleName: [*:0]const u16,
    cProperties: u32,
    pProperties: ?[*]const DEVPROPERTY,
) callconv(@import("std").os.windows.WINAPI) *DEVPROPERTY;

pub extern "IPHLPAPI" fn PfCreateInterface(
    dwName: u32,
    inAction: _PfForwardAction,
    outAction: _PfForwardAction,
    bUseLog: BOOL,
    bMustBeUnique: BOOL,
    ppInterface: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfDeleteInterface(
    pInterface: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfAddFiltersToInterface(
    ih: *c_void,
    cInFilters: u32,
    pfiltIn: *PF_FILTER_DESCRIPTOR,
    cOutFilters: u32,
    pfiltOut: *PF_FILTER_DESCRIPTOR,
    pfHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfRemoveFiltersFromInterface(
    ih: *c_void,
    cInFilters: u32,
    pfiltIn: *PF_FILTER_DESCRIPTOR,
    cOutFilters: u32,
    pfiltOut: *PF_FILTER_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfRemoveFilterHandles(
    pInterface: *c_void,
    cFilters: u32,
    pvHandles: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfUnBindInterface(
    pInterface: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfBindInterfaceToIndex(
    pInterface: *c_void,
    dwIndex: u32,
    pfatLinkType: _PfAddresType,
    LinkIPAddress: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfBindInterfaceToIPAddress(
    pInterface: *c_void,
    pfatType: _PfAddresType,
    IPAddress: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfRebindFilters(
    pInterface: *c_void,
    pLateBindInfo: *PF_LATEBIND_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfAddGlobalFilterToInterface(
    pInterface: *c_void,
    gfFilter: _GlobalFilter,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfRemoveGlobalFilterFromInterface(
    pInterface: *c_void,
    gfFilter: _GlobalFilter,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfMakeLog(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfSetLogBuffer(
    pbBuffer: *u8,
    dwSize: u32,
    dwThreshold: u32,
    dwEntries: u32,
    pdwLoggedEntries: *u32,
    pdwLostEntries: *u32,
    pdwSizeUsed: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfDeleteLog(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfGetInterfaceStatistics(
    pInterface: *c_void,
    ppfStats: *PF_INTERFACE_STATS,
    pdwBufferSize: *u32,
    fResetCounters: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "IPHLPAPI" fn PfTestPacket(
    pInInterface: *c_void,
    pOutInterface: *c_void,
    cBytes: u32,
    pbPacket: *u8,
    ppAction: *_PfForwardAction,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-state-helpers-l1-1-0" fn GetRegistryValueWithFallbackW(
    hkeyPrimary: HKEY,
    pwszPrimarySubKey: ?[*:0]const u16,
    hkeyFallback: HKEY,
    pwszFallbackSubKey: ?[*:0]const u16,
    pwszValue: [*:0]const u16,
    dwFlags: u32,
    pdwType: ?*u32,
    pvData: ?*c_void,
    cbDataIn: u32,
    pcbDataOut: ?*u32,
) callconv(@import("std").os.windows.WINAPI) LSTATUS;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (109)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const OSVERSIONINFO = OSVERSIONINFOA;
        pub const OSVERSIONINFOEX = OSVERSIONINFOEXA;
        pub const PGET_SYSTEM_WOW64_DIRECTORY_ = PGET_SYSTEM_WOW64_DIRECTORY_A;
        pub const HW_PROFILE_INFO = HW_PROFILE_INFOA;
        pub const pvalue = pvalueA;
        pub const VALENT = VALENTA;
        pub const STRENTRY = STRENTRYA;
        pub const STRTABLE = STRTABLEA;
        pub const _CabInfo = _CabInfoA;
        pub const PERUSERSECTION = PERUSERSECTIONA;
        pub const IMEPRO = IMEPROA;
        pub const GetUserNameEx = GetUserNameExA;
        pub const GetComputerObjectName = GetComputerObjectNameA;
        pub const TranslateName = TranslateNameA;
        pub const GetSystemWow64Directory = GetSystemWow64DirectoryA;
        pub const GetSystemWow64Directory2 = GetSystemWow64Directory2A;
        pub const InstallPerfDll = InstallPerfDllA;
        pub const SetEnvironmentStrings = SetEnvironmentStringsA;
        pub const ExpandEnvironmentStrings = ExpandEnvironmentStringsA;
        pub const SetCurrentDirectory = SetCurrentDirectoryA;
        pub const GetCurrentDirectory = GetCurrentDirectoryA;
        pub const GetSystemDirectory = GetSystemDirectoryA;
        pub const GetWindowsDirectory = GetWindowsDirectoryA;
        pub const GetSystemWindowsDirectory = GetSystemWindowsDirectoryA;
        pub const GetComputerNameEx = GetComputerNameExA;
        pub const SetComputerNameEx = SetComputerNameExA;
        pub const GetVersionEx = GetVersionExA;
        pub const SetComputerName = SetComputerNameA;
        pub const GetFirmwareEnvironmentVariable = GetFirmwareEnvironmentVariableA;
        pub const GetFirmwareEnvironmentVariableEx = GetFirmwareEnvironmentVariableExA;
        pub const SetFirmwareEnvironmentVariable = SetFirmwareEnvironmentVariableA;
        pub const SetFirmwareEnvironmentVariableEx = SetFirmwareEnvironmentVariableExA;
        pub const GetProfileInt = GetProfileIntA;
        pub const GetProfileString = GetProfileStringA;
        pub const WriteProfileString = WriteProfileStringA;
        pub const GetProfileSection = GetProfileSectionA;
        pub const WriteProfileSection = WriteProfileSectionA;
        pub const GetPrivateProfileInt = GetPrivateProfileIntA;
        pub const GetPrivateProfileString = GetPrivateProfileStringA;
        pub const WritePrivateProfileString = WritePrivateProfileStringA;
        pub const GetPrivateProfileSection = GetPrivateProfileSectionA;
        pub const WritePrivateProfileSection = WritePrivateProfileSectionA;
        pub const GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesA;
        pub const GetPrivateProfileStruct = GetPrivateProfileStructA;
        pub const WritePrivateProfileStruct = WritePrivateProfileStructA;
        pub const GetComputerName = GetComputerNameA;
        pub const DnsHostnameToComputerName = DnsHostnameToComputerNameA;
        pub const GetUserName = GetUserNameA;
        pub const GetCurrentHwProfile = GetCurrentHwProfileA;
        pub const VerifyVersionInfo = VerifyVersionInfoA;
        pub const RegConnectRegistry = RegConnectRegistryA;
        pub const RegConnectRegistryEx = RegConnectRegistryExA;
        pub const RegCreateKey = RegCreateKeyA;
        pub const RegCreateKeyEx = RegCreateKeyExA;
        pub const RegCreateKeyTransacted = RegCreateKeyTransactedA;
        pub const RegDeleteKey = RegDeleteKeyA;
        pub const RegDeleteKeyEx = RegDeleteKeyExA;
        pub const RegDeleteKeyTransacted = RegDeleteKeyTransactedA;
        pub const RegDeleteValue = RegDeleteValueA;
        pub const RegEnumKey = RegEnumKeyA;
        pub const RegEnumKeyEx = RegEnumKeyExA;
        pub const RegEnumValue = RegEnumValueA;
        pub const RegLoadKey = RegLoadKeyA;
        pub const RegOpenKey = RegOpenKeyA;
        pub const RegOpenKeyEx = RegOpenKeyExA;
        pub const RegOpenKeyTransacted = RegOpenKeyTransactedA;
        pub const RegQueryInfoKey = RegQueryInfoKeyA;
        pub const RegQueryValue = RegQueryValueA;
        pub const RegQueryMultipleValues = RegQueryMultipleValuesA;
        pub const RegQueryValueEx = RegQueryValueExA;
        pub const RegReplaceKey = RegReplaceKeyA;
        pub const RegRestoreKey = RegRestoreKeyA;
        pub const RegSaveKey = RegSaveKeyA;
        pub const RegSetValue = RegSetValueA;
        pub const RegSetValueEx = RegSetValueExA;
        pub const RegUnLoadKey = RegUnLoadKeyA;
        pub const RegDeleteKeyValue = RegDeleteKeyValueA;
        pub const RegSetKeyValue = RegSetKeyValueA;
        pub const RegDeleteTree = RegDeleteTreeA;
        pub const RegCopyTree = RegCopyTreeA;
        pub const RegGetValue = RegGetValueA;
        pub const RegLoadMUIString = RegLoadMUIStringA;
        pub const RegLoadAppKey = RegLoadAppKeyA;
        pub const RegSaveKeyEx = RegSaveKeyExA;
        pub const RunSetupCommand = RunSetupCommandA;
        pub const RebootCheckOnInstall = RebootCheckOnInstallA;
        pub const TranslateInfString = TranslateInfStringA;
        pub const RegInstall = RegInstallA;
        pub const ExecuteCab = ExecuteCabA;
        pub const AdvInstallFile = AdvInstallFileA;
        pub const RegSaveRestore = RegSaveRestoreA;
        pub const RegSaveRestoreOnINF = RegSaveRestoreOnINFA;
        pub const RegRestoreAll = RegRestoreAllA;
        pub const FileSaveRestoreOnINF = FileSaveRestoreOnINFA;
        pub const AddDelBackupEntry = AddDelBackupEntryA;
        pub const FileSaveMarkNotExist = FileSaveMarkNotExistA;
        pub const GetVersionFromFile = GetVersionFromFileA;
        pub const GetVersionFromFileEx = GetVersionFromFileExA;
        pub const DelNode = DelNodeA;
        pub const OpenINFEngine = OpenINFEngineA;
        pub const TranslateInfStringEx = TranslateInfStringExA;
        pub const ExtractFiles = ExtractFilesA;
        pub const UserInstStubWrapper = UserInstStubWrapperA;
        pub const UserUnInstStubWrapper = UserUnInstStubWrapperA;
        pub const SetPerUserSecValues = SetPerUserSecValuesA;
        pub const SendIMEMessageEx = SendIMEMessageExA;
        pub const IMPGetIME = IMPGetIMEA;
        pub const IMPQueryIME = IMPQueryIMEA;
        pub const IMPSetIME = IMPSetIMEA;
    },
    .wide => struct {
        pub const OSVERSIONINFO = OSVERSIONINFOW;
        pub const OSVERSIONINFOEX = OSVERSIONINFOEXW;
        pub const PGET_SYSTEM_WOW64_DIRECTORY_ = PGET_SYSTEM_WOW64_DIRECTORY_W;
        pub const HW_PROFILE_INFO = HW_PROFILE_INFOW;
        pub const pvalue = pvalueW;
        pub const VALENT = VALENTW;
        pub const STRENTRY = STRENTRYW;
        pub const STRTABLE = STRTABLEW;
        pub const _CabInfo = _CabInfoW;
        pub const PERUSERSECTION = PERUSERSECTIONW;
        pub const IMEPRO = IMEPROW;
        pub const GetUserNameEx = GetUserNameExW;
        pub const GetComputerObjectName = GetComputerObjectNameW;
        pub const TranslateName = TranslateNameW;
        pub const GetSystemWow64Directory = GetSystemWow64DirectoryW;
        pub const GetSystemWow64Directory2 = GetSystemWow64Directory2W;
        pub const InstallPerfDll = InstallPerfDllW;
        pub const SetEnvironmentStrings = SetEnvironmentStringsW;
        pub const ExpandEnvironmentStrings = ExpandEnvironmentStringsW;
        pub const SetCurrentDirectory = SetCurrentDirectoryW;
        pub const GetCurrentDirectory = GetCurrentDirectoryW;
        pub const GetSystemDirectory = GetSystemDirectoryW;
        pub const GetWindowsDirectory = GetWindowsDirectoryW;
        pub const GetSystemWindowsDirectory = GetSystemWindowsDirectoryW;
        pub const GetComputerNameEx = GetComputerNameExW;
        pub const SetComputerNameEx = SetComputerNameExW;
        pub const GetVersionEx = GetVersionExW;
        pub const SetComputerName = SetComputerNameW;
        pub const GetFirmwareEnvironmentVariable = GetFirmwareEnvironmentVariableW;
        pub const GetFirmwareEnvironmentVariableEx = GetFirmwareEnvironmentVariableExW;
        pub const SetFirmwareEnvironmentVariable = SetFirmwareEnvironmentVariableW;
        pub const SetFirmwareEnvironmentVariableEx = SetFirmwareEnvironmentVariableExW;
        pub const GetProfileInt = GetProfileIntW;
        pub const GetProfileString = GetProfileStringW;
        pub const WriteProfileString = WriteProfileStringW;
        pub const GetProfileSection = GetProfileSectionW;
        pub const WriteProfileSection = WriteProfileSectionW;
        pub const GetPrivateProfileInt = GetPrivateProfileIntW;
        pub const GetPrivateProfileString = GetPrivateProfileStringW;
        pub const WritePrivateProfileString = WritePrivateProfileStringW;
        pub const GetPrivateProfileSection = GetPrivateProfileSectionW;
        pub const WritePrivateProfileSection = WritePrivateProfileSectionW;
        pub const GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesW;
        pub const GetPrivateProfileStruct = GetPrivateProfileStructW;
        pub const WritePrivateProfileStruct = WritePrivateProfileStructW;
        pub const GetComputerName = GetComputerNameW;
        pub const DnsHostnameToComputerName = DnsHostnameToComputerNameW;
        pub const GetUserName = GetUserNameW;
        pub const GetCurrentHwProfile = GetCurrentHwProfileW;
        pub const VerifyVersionInfo = VerifyVersionInfoW;
        pub const RegConnectRegistry = RegConnectRegistryW;
        pub const RegConnectRegistryEx = RegConnectRegistryExW;
        pub const RegCreateKey = RegCreateKeyW;
        pub const RegCreateKeyEx = RegCreateKeyExW;
        pub const RegCreateKeyTransacted = RegCreateKeyTransactedW;
        pub const RegDeleteKey = RegDeleteKeyW;
        pub const RegDeleteKeyEx = RegDeleteKeyExW;
        pub const RegDeleteKeyTransacted = RegDeleteKeyTransactedW;
        pub const RegDeleteValue = RegDeleteValueW;
        pub const RegEnumKey = RegEnumKeyW;
        pub const RegEnumKeyEx = RegEnumKeyExW;
        pub const RegEnumValue = RegEnumValueW;
        pub const RegLoadKey = RegLoadKeyW;
        pub const RegOpenKey = RegOpenKeyW;
        pub const RegOpenKeyEx = RegOpenKeyExW;
        pub const RegOpenKeyTransacted = RegOpenKeyTransactedW;
        pub const RegQueryInfoKey = RegQueryInfoKeyW;
        pub const RegQueryValue = RegQueryValueW;
        pub const RegQueryMultipleValues = RegQueryMultipleValuesW;
        pub const RegQueryValueEx = RegQueryValueExW;
        pub const RegReplaceKey = RegReplaceKeyW;
        pub const RegRestoreKey = RegRestoreKeyW;
        pub const RegSaveKey = RegSaveKeyW;
        pub const RegSetValue = RegSetValueW;
        pub const RegSetValueEx = RegSetValueExW;
        pub const RegUnLoadKey = RegUnLoadKeyW;
        pub const RegDeleteKeyValue = RegDeleteKeyValueW;
        pub const RegSetKeyValue = RegSetKeyValueW;
        pub const RegDeleteTree = RegDeleteTreeW;
        pub const RegCopyTree = RegCopyTreeW;
        pub const RegGetValue = RegGetValueW;
        pub const RegLoadMUIString = RegLoadMUIStringW;
        pub const RegLoadAppKey = RegLoadAppKeyW;
        pub const RegSaveKeyEx = RegSaveKeyExW;
        pub const RunSetupCommand = RunSetupCommandW;
        pub const RebootCheckOnInstall = RebootCheckOnInstallW;
        pub const TranslateInfString = TranslateInfStringW;
        pub const RegInstall = RegInstallW;
        pub const ExecuteCab = ExecuteCabW;
        pub const AdvInstallFile = AdvInstallFileW;
        pub const RegSaveRestore = RegSaveRestoreW;
        pub const RegSaveRestoreOnINF = RegSaveRestoreOnINFW;
        pub const RegRestoreAll = RegRestoreAllW;
        pub const FileSaveRestoreOnINF = FileSaveRestoreOnINFW;
        pub const AddDelBackupEntry = AddDelBackupEntryW;
        pub const FileSaveMarkNotExist = FileSaveMarkNotExistW;
        pub const GetVersionFromFile = GetVersionFromFileW;
        pub const GetVersionFromFileEx = GetVersionFromFileExW;
        pub const DelNode = DelNodeW;
        pub const OpenINFEngine = OpenINFEngineW;
        pub const TranslateInfStringEx = TranslateInfStringExW;
        pub const ExtractFiles = ExtractFilesW;
        pub const UserInstStubWrapper = UserInstStubWrapperW;
        pub const UserUnInstStubWrapper = UserUnInstStubWrapperW;
        pub const SetPerUserSecValues = SetPerUserSecValuesW;
        pub const SendIMEMessageEx = SendIMEMessageExW;
        pub const IMPGetIME = IMPGetIMEW;
        pub const IMPQueryIME = IMPQueryIMEW;
        pub const IMPSetIME = IMPSetIMEW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const OSVERSIONINFO = *opaque{};
        pub const OSVERSIONINFOEX = *opaque{};
        pub const PGET_SYSTEM_WOW64_DIRECTORY_ = *opaque{};
        pub const HW_PROFILE_INFO = *opaque{};
        pub const pvalue = *opaque{};
        pub const VALENT = *opaque{};
        pub const STRENTRY = *opaque{};
        pub const STRTABLE = *opaque{};
        pub const _CabInfo = *opaque{};
        pub const PERUSERSECTION = *opaque{};
        pub const IMEPRO = *opaque{};
        pub const GetUserNameEx = *opaque{};
        pub const GetComputerObjectName = *opaque{};
        pub const TranslateName = *opaque{};
        pub const GetSystemWow64Directory = *opaque{};
        pub const GetSystemWow64Directory2 = *opaque{};
        pub const InstallPerfDll = *opaque{};
        pub const SetEnvironmentStrings = *opaque{};
        pub const ExpandEnvironmentStrings = *opaque{};
        pub const SetCurrentDirectory = *opaque{};
        pub const GetCurrentDirectory = *opaque{};
        pub const GetSystemDirectory = *opaque{};
        pub const GetWindowsDirectory = *opaque{};
        pub const GetSystemWindowsDirectory = *opaque{};
        pub const GetComputerNameEx = *opaque{};
        pub const SetComputerNameEx = *opaque{};
        pub const GetVersionEx = *opaque{};
        pub const SetComputerName = *opaque{};
        pub const GetFirmwareEnvironmentVariable = *opaque{};
        pub const GetFirmwareEnvironmentVariableEx = *opaque{};
        pub const SetFirmwareEnvironmentVariable = *opaque{};
        pub const SetFirmwareEnvironmentVariableEx = *opaque{};
        pub const GetProfileInt = *opaque{};
        pub const GetProfileString = *opaque{};
        pub const WriteProfileString = *opaque{};
        pub const GetProfileSection = *opaque{};
        pub const WriteProfileSection = *opaque{};
        pub const GetPrivateProfileInt = *opaque{};
        pub const GetPrivateProfileString = *opaque{};
        pub const WritePrivateProfileString = *opaque{};
        pub const GetPrivateProfileSection = *opaque{};
        pub const WritePrivateProfileSection = *opaque{};
        pub const GetPrivateProfileSectionNames = *opaque{};
        pub const GetPrivateProfileStruct = *opaque{};
        pub const WritePrivateProfileStruct = *opaque{};
        pub const GetComputerName = *opaque{};
        pub const DnsHostnameToComputerName = *opaque{};
        pub const GetUserName = *opaque{};
        pub const GetCurrentHwProfile = *opaque{};
        pub const VerifyVersionInfo = *opaque{};
        pub const RegConnectRegistry = *opaque{};
        pub const RegConnectRegistryEx = *opaque{};
        pub const RegCreateKey = *opaque{};
        pub const RegCreateKeyEx = *opaque{};
        pub const RegCreateKeyTransacted = *opaque{};
        pub const RegDeleteKey = *opaque{};
        pub const RegDeleteKeyEx = *opaque{};
        pub const RegDeleteKeyTransacted = *opaque{};
        pub const RegDeleteValue = *opaque{};
        pub const RegEnumKey = *opaque{};
        pub const RegEnumKeyEx = *opaque{};
        pub const RegEnumValue = *opaque{};
        pub const RegLoadKey = *opaque{};
        pub const RegOpenKey = *opaque{};
        pub const RegOpenKeyEx = *opaque{};
        pub const RegOpenKeyTransacted = *opaque{};
        pub const RegQueryInfoKey = *opaque{};
        pub const RegQueryValue = *opaque{};
        pub const RegQueryMultipleValues = *opaque{};
        pub const RegQueryValueEx = *opaque{};
        pub const RegReplaceKey = *opaque{};
        pub const RegRestoreKey = *opaque{};
        pub const RegSaveKey = *opaque{};
        pub const RegSetValue = *opaque{};
        pub const RegSetValueEx = *opaque{};
        pub const RegUnLoadKey = *opaque{};
        pub const RegDeleteKeyValue = *opaque{};
        pub const RegSetKeyValue = *opaque{};
        pub const RegDeleteTree = *opaque{};
        pub const RegCopyTree = *opaque{};
        pub const RegGetValue = *opaque{};
        pub const RegLoadMUIString = *opaque{};
        pub const RegLoadAppKey = *opaque{};
        pub const RegSaveKeyEx = *opaque{};
        pub const RunSetupCommand = *opaque{};
        pub const RebootCheckOnInstall = *opaque{};
        pub const TranslateInfString = *opaque{};
        pub const RegInstall = *opaque{};
        pub const ExecuteCab = *opaque{};
        pub const AdvInstallFile = *opaque{};
        pub const RegSaveRestore = *opaque{};
        pub const RegSaveRestoreOnINF = *opaque{};
        pub const RegRestoreAll = *opaque{};
        pub const FileSaveRestoreOnINF = *opaque{};
        pub const AddDelBackupEntry = *opaque{};
        pub const FileSaveMarkNotExist = *opaque{};
        pub const GetVersionFromFile = *opaque{};
        pub const GetVersionFromFileEx = *opaque{};
        pub const DelNode = *opaque{};
        pub const OpenINFEngine = *opaque{};
        pub const TranslateInfStringEx = *opaque{};
        pub const ExtractFiles = *opaque{};
        pub const UserInstStubWrapper = *opaque{};
        pub const UserUnInstStubWrapper = *opaque{};
        pub const SetPerUserSecValues = *opaque{};
        pub const SendIMEMessageEx = *opaque{};
        pub const IMPGetIME = *opaque{};
        pub const IMPQueryIME = *opaque{};
        pub const IMPSetIME = *opaque{};
    } else struct {
        pub const OSVERSIONINFO = @compileError("'OSVERSIONINFO' requires that UNICODE be set to true or false in the root module");
        pub const OSVERSIONINFOEX = @compileError("'OSVERSIONINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const PGET_SYSTEM_WOW64_DIRECTORY_ = @compileError("'PGET_SYSTEM_WOW64_DIRECTORY_' requires that UNICODE be set to true or false in the root module");
        pub const HW_PROFILE_INFO = @compileError("'HW_PROFILE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const pvalue = @compileError("'pvalue' requires that UNICODE be set to true or false in the root module");
        pub const VALENT = @compileError("'VALENT' requires that UNICODE be set to true or false in the root module");
        pub const STRENTRY = @compileError("'STRENTRY' requires that UNICODE be set to true or false in the root module");
        pub const STRTABLE = @compileError("'STRTABLE' requires that UNICODE be set to true or false in the root module");
        pub const _CabInfo = @compileError("'_CabInfo' requires that UNICODE be set to true or false in the root module");
        pub const PERUSERSECTION = @compileError("'PERUSERSECTION' requires that UNICODE be set to true or false in the root module");
        pub const IMEPRO = @compileError("'IMEPRO' requires that UNICODE be set to true or false in the root module");
        pub const GetUserNameEx = @compileError("'GetUserNameEx' requires that UNICODE be set to true or false in the root module");
        pub const GetComputerObjectName = @compileError("'GetComputerObjectName' requires that UNICODE be set to true or false in the root module");
        pub const TranslateName = @compileError("'TranslateName' requires that UNICODE be set to true or false in the root module");
        pub const GetSystemWow64Directory = @compileError("'GetSystemWow64Directory' requires that UNICODE be set to true or false in the root module");
        pub const GetSystemWow64Directory2 = @compileError("'GetSystemWow64Directory2' requires that UNICODE be set to true or false in the root module");
        pub const InstallPerfDll = @compileError("'InstallPerfDll' requires that UNICODE be set to true or false in the root module");
        pub const SetEnvironmentStrings = @compileError("'SetEnvironmentStrings' requires that UNICODE be set to true or false in the root module");
        pub const ExpandEnvironmentStrings = @compileError("'ExpandEnvironmentStrings' requires that UNICODE be set to true or false in the root module");
        pub const SetCurrentDirectory = @compileError("'SetCurrentDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetCurrentDirectory = @compileError("'GetCurrentDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetSystemDirectory = @compileError("'GetSystemDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetWindowsDirectory = @compileError("'GetWindowsDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetSystemWindowsDirectory = @compileError("'GetSystemWindowsDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetComputerNameEx = @compileError("'GetComputerNameEx' requires that UNICODE be set to true or false in the root module");
        pub const SetComputerNameEx = @compileError("'SetComputerNameEx' requires that UNICODE be set to true or false in the root module");
        pub const GetVersionEx = @compileError("'GetVersionEx' requires that UNICODE be set to true or false in the root module");
        pub const SetComputerName = @compileError("'SetComputerName' requires that UNICODE be set to true or false in the root module");
        pub const GetFirmwareEnvironmentVariable = @compileError("'GetFirmwareEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const GetFirmwareEnvironmentVariableEx = @compileError("'GetFirmwareEnvironmentVariableEx' requires that UNICODE be set to true or false in the root module");
        pub const SetFirmwareEnvironmentVariable = @compileError("'SetFirmwareEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const SetFirmwareEnvironmentVariableEx = @compileError("'SetFirmwareEnvironmentVariableEx' requires that UNICODE be set to true or false in the root module");
        pub const GetProfileInt = @compileError("'GetProfileInt' requires that UNICODE be set to true or false in the root module");
        pub const GetProfileString = @compileError("'GetProfileString' requires that UNICODE be set to true or false in the root module");
        pub const WriteProfileString = @compileError("'WriteProfileString' requires that UNICODE be set to true or false in the root module");
        pub const GetProfileSection = @compileError("'GetProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const WriteProfileSection = @compileError("'WriteProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileInt = @compileError("'GetPrivateProfileInt' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileString = @compileError("'GetPrivateProfileString' requires that UNICODE be set to true or false in the root module");
        pub const WritePrivateProfileString = @compileError("'WritePrivateProfileString' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileSection = @compileError("'GetPrivateProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const WritePrivateProfileSection = @compileError("'WritePrivateProfileSection' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileSectionNames = @compileError("'GetPrivateProfileSectionNames' requires that UNICODE be set to true or false in the root module");
        pub const GetPrivateProfileStruct = @compileError("'GetPrivateProfileStruct' requires that UNICODE be set to true or false in the root module");
        pub const WritePrivateProfileStruct = @compileError("'WritePrivateProfileStruct' requires that UNICODE be set to true or false in the root module");
        pub const GetComputerName = @compileError("'GetComputerName' requires that UNICODE be set to true or false in the root module");
        pub const DnsHostnameToComputerName = @compileError("'DnsHostnameToComputerName' requires that UNICODE be set to true or false in the root module");
        pub const GetUserName = @compileError("'GetUserName' requires that UNICODE be set to true or false in the root module");
        pub const GetCurrentHwProfile = @compileError("'GetCurrentHwProfile' requires that UNICODE be set to true or false in the root module");
        pub const VerifyVersionInfo = @compileError("'VerifyVersionInfo' requires that UNICODE be set to true or false in the root module");
        pub const RegConnectRegistry = @compileError("'RegConnectRegistry' requires that UNICODE be set to true or false in the root module");
        pub const RegConnectRegistryEx = @compileError("'RegConnectRegistryEx' requires that UNICODE be set to true or false in the root module");
        pub const RegCreateKey = @compileError("'RegCreateKey' requires that UNICODE be set to true or false in the root module");
        pub const RegCreateKeyEx = @compileError("'RegCreateKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegCreateKeyTransacted = @compileError("'RegCreateKeyTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKey = @compileError("'RegDeleteKey' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKeyEx = @compileError("'RegDeleteKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKeyTransacted = @compileError("'RegDeleteKeyTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteValue = @compileError("'RegDeleteValue' requires that UNICODE be set to true or false in the root module");
        pub const RegEnumKey = @compileError("'RegEnumKey' requires that UNICODE be set to true or false in the root module");
        pub const RegEnumKeyEx = @compileError("'RegEnumKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegEnumValue = @compileError("'RegEnumValue' requires that UNICODE be set to true or false in the root module");
        pub const RegLoadKey = @compileError("'RegLoadKey' requires that UNICODE be set to true or false in the root module");
        pub const RegOpenKey = @compileError("'RegOpenKey' requires that UNICODE be set to true or false in the root module");
        pub const RegOpenKeyEx = @compileError("'RegOpenKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RegOpenKeyTransacted = @compileError("'RegOpenKeyTransacted' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryInfoKey = @compileError("'RegQueryInfoKey' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryValue = @compileError("'RegQueryValue' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryMultipleValues = @compileError("'RegQueryMultipleValues' requires that UNICODE be set to true or false in the root module");
        pub const RegQueryValueEx = @compileError("'RegQueryValueEx' requires that UNICODE be set to true or false in the root module");
        pub const RegReplaceKey = @compileError("'RegReplaceKey' requires that UNICODE be set to true or false in the root module");
        pub const RegRestoreKey = @compileError("'RegRestoreKey' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveKey = @compileError("'RegSaveKey' requires that UNICODE be set to true or false in the root module");
        pub const RegSetValue = @compileError("'RegSetValue' requires that UNICODE be set to true or false in the root module");
        pub const RegSetValueEx = @compileError("'RegSetValueEx' requires that UNICODE be set to true or false in the root module");
        pub const RegUnLoadKey = @compileError("'RegUnLoadKey' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteKeyValue = @compileError("'RegDeleteKeyValue' requires that UNICODE be set to true or false in the root module");
        pub const RegSetKeyValue = @compileError("'RegSetKeyValue' requires that UNICODE be set to true or false in the root module");
        pub const RegDeleteTree = @compileError("'RegDeleteTree' requires that UNICODE be set to true or false in the root module");
        pub const RegCopyTree = @compileError("'RegCopyTree' requires that UNICODE be set to true or false in the root module");
        pub const RegGetValue = @compileError("'RegGetValue' requires that UNICODE be set to true or false in the root module");
        pub const RegLoadMUIString = @compileError("'RegLoadMUIString' requires that UNICODE be set to true or false in the root module");
        pub const RegLoadAppKey = @compileError("'RegLoadAppKey' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveKeyEx = @compileError("'RegSaveKeyEx' requires that UNICODE be set to true or false in the root module");
        pub const RunSetupCommand = @compileError("'RunSetupCommand' requires that UNICODE be set to true or false in the root module");
        pub const RebootCheckOnInstall = @compileError("'RebootCheckOnInstall' requires that UNICODE be set to true or false in the root module");
        pub const TranslateInfString = @compileError("'TranslateInfString' requires that UNICODE be set to true or false in the root module");
        pub const RegInstall = @compileError("'RegInstall' requires that UNICODE be set to true or false in the root module");
        pub const ExecuteCab = @compileError("'ExecuteCab' requires that UNICODE be set to true or false in the root module");
        pub const AdvInstallFile = @compileError("'AdvInstallFile' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveRestore = @compileError("'RegSaveRestore' requires that UNICODE be set to true or false in the root module");
        pub const RegSaveRestoreOnINF = @compileError("'RegSaveRestoreOnINF' requires that UNICODE be set to true or false in the root module");
        pub const RegRestoreAll = @compileError("'RegRestoreAll' requires that UNICODE be set to true or false in the root module");
        pub const FileSaveRestoreOnINF = @compileError("'FileSaveRestoreOnINF' requires that UNICODE be set to true or false in the root module");
        pub const AddDelBackupEntry = @compileError("'AddDelBackupEntry' requires that UNICODE be set to true or false in the root module");
        pub const FileSaveMarkNotExist = @compileError("'FileSaveMarkNotExist' requires that UNICODE be set to true or false in the root module");
        pub const GetVersionFromFile = @compileError("'GetVersionFromFile' requires that UNICODE be set to true or false in the root module");
        pub const GetVersionFromFileEx = @compileError("'GetVersionFromFileEx' requires that UNICODE be set to true or false in the root module");
        pub const DelNode = @compileError("'DelNode' requires that UNICODE be set to true or false in the root module");
        pub const OpenINFEngine = @compileError("'OpenINFEngine' requires that UNICODE be set to true or false in the root module");
        pub const TranslateInfStringEx = @compileError("'TranslateInfStringEx' requires that UNICODE be set to true or false in the root module");
        pub const ExtractFiles = @compileError("'ExtractFiles' requires that UNICODE be set to true or false in the root module");
        pub const UserInstStubWrapper = @compileError("'UserInstStubWrapper' requires that UNICODE be set to true or false in the root module");
        pub const UserUnInstStubWrapper = @compileError("'UserUnInstStubWrapper' requires that UNICODE be set to true or false in the root module");
        pub const SetPerUserSecValues = @compileError("'SetPerUserSecValues' requires that UNICODE be set to true or false in the root module");
        pub const SendIMEMessageEx = @compileError("'SendIMEMessageEx' requires that UNICODE be set to true or false in the root module");
        pub const IMPGetIME = @compileError("'IMPGetIME' requires that UNICODE be set to true or false in the root module");
        pub const IMPQueryIME = @compileError("'IMPQueryIME' requires that UNICODE be set to true or false in the root module");
        pub const IMPSetIME = @compileError("'IMPSetIME' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (75)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IDispatch = @import("automation.zig").IDispatch;
const DDOVERLAYFX = @import("direct_draw.zig").DDOVERLAYFX;
const DDKERNELCAPS = @import("display_devices.zig").DDKERNELCAPS;
const OLECMDF = @import("com.zig").OLECMDF;
const OLECMDEXECOPT = @import("com.zig").OLECMDEXECOPT;
const FLOATING_SAVE_AREA = @import("system_services.zig").FLOATING_SAVE_AREA;
const DEVPROPERTY = @import("system_services.zig").DEVPROPERTY;
const MIDL_STUB_MESSAGE = @import("rpc.zig").MIDL_STUB_MESSAGE;
const NTSTATUS = @import("system_services.zig").NTSTATUS;
const CONTEXT = @import("debug.zig").CONTEXT;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const LRESULT = @import("system_services.zig").LRESULT;
const DDVIDEOPORTDESC = @import("display_devices.zig").DDVIDEOPORTDESC;
const DDCOLORCONTROL = @import("direct_draw.zig").DDCOLORCONTROL;
const LIST_ENTRY = @import("kernel.zig").LIST_ENTRY;
const DDCOLORKEY = @import("direct_show.zig").DDCOLORKEY;
const UNICODE_STRING = @import("security.zig").UNICODE_STRING;
const DDVIDEOPORTCONNECT = @import("core_audio.zig").DDVIDEOPORTCONNECT;
const PWSTR = @import("system_services.zig").PWSTR;
const IBindCtx = @import("com.zig").IBindCtx;
const LSTATUS = @import("system_services.zig").LSTATUS;
const DDCORECAPS = @import("display_devices.zig").DDCORECAPS;
const DDVIDEOPORTINFO = @import("display_devices.zig").DDVIDEOPORTINFO;
const SECURITY_ATTRIBUTES = @import("system_services.zig").SECURITY_ATTRIBUTES;
const BSTR = @import("automation.zig").BSTR;
const PSTR = @import("system_services.zig").PSTR;
const RECT = @import("display_devices.zig").RECT;
const LPTHREAD_START_ROUTINE = @import("system_services.zig").LPTHREAD_START_ROUTINE;
const DDSCAPS2 = @import("direct_draw.zig").DDSCAPS2;
const DEVPROPCOMPKEY = @import("system_services.zig").DEVPROPCOMPKEY;
const DEVPROPSTORE = @import("system_services.zig").DEVPROPSTORE;
const SYSTEM_CPU_SET_INFORMATION = @import("system_services.zig").SYSTEM_CPU_SET_INFORMATION;
const OLECMDID = @import("com.zig").OLECMDID;
const HANDLE = @import("system_services.zig").HANDLE;
const PALETTEENTRY = @import("gdi.zig").PALETTEENTRY;
const DEBUG_EVENT = @import("debug.zig").DEBUG_EVENT;
const RGNDATA = @import("gdi.zig").RGNDATA;
const EXCEPTION_RECORD = @import("debug.zig").EXCEPTION_RECORD;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const DDVIDEOPORTCAPS = @import("display_devices.zig").DDVIDEOPORTCAPS;
const HINSTANCE = @import("system_services.zig").HINSTANCE;
const WAITORTIMERCALLBACK = @import("system_services.zig").WAITORTIMERCALLBACK;
const DDHAL_DESTROYDDLOCALDATA = @import("display_devices.zig").DDHAL_DESTROYDDLOCALDATA;
const DEVPROPKEY = @import("system_services.zig").DEVPROPKEY;
const HDC = @import("gdi.zig").HDC;
const HRESULT = @import("com.zig").HRESULT;
const STARTUPINFOA = @import("system_services.zig").STARTUPINFOA;
const LDT_ENTRY = @import("debug.zig").LDT_ENTRY;
const BOOL = @import("system_services.zig").BOOL;
const PRIVILEGE_SET = @import("security.zig").PRIVILEGE_SET;
const DDSURFACEDESC = @import("direct_draw.zig").DDSURFACEDESC;
const JOB_SET_ARRAY = @import("system_services.zig").JOB_SET_ARRAY;
const IMalloc = @import("com.zig").IMalloc;
const QUERYCONTEXT = @import("com.zig").QUERYCONTEXT;
const SAFEARRAY = @import("automation.zig").SAFEARRAY;
const DDSURFACEDESC2 = @import("direct_draw.zig").DDSURFACEDESC2;
const IUnknown = @import("com.zig").IUnknown;
const DDGAMMARAMP = @import("direct_draw.zig").DDGAMMARAMP;
const READYSTATE = @import("direct_show.zig").READYSTATE;
const GENERIC_MAPPING = @import("security.zig").GENERIC_MAPPING;
const HWND = @import("windows_and_messaging.zig").HWND;
const DDVIDEOPORTBANDWIDTH = @import("display_devices.zig").DDVIDEOPORTBANDWIDTH;
const HEAPALIGNMENT = @import("display_devices.zig").HEAPALIGNMENT;
const PEB = @import("system_services.zig").PEB;
const LARGE_INTEGER = @import("system_services.zig").LARGE_INTEGER;
const VARIANT = @import("automation.zig").VARIANT;
const PROCESS_DYNAMIC_EH_CONTINUATION_TARGET = @import("system_services.zig").PROCESS_DYNAMIC_EH_CONTINUATION_TARGET;
const DDPIXELFORMAT = @import("direct_draw.zig").DDPIXELFORMAT;
const DDBLTFX = @import("direct_draw.zig").DDBLTFX;
const uCLSSPEC = @import("system_services.zig").uCLSSPEC;
const RECTL = @import("display_devices.zig").RECTL;
const DDSCAPS = @import("direct_draw.zig").DDSCAPS;
const CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = @import("system_services.zig").CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
const DDSCAPSEX = @import("direct_draw.zig").DDSCAPSEX;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = LPFIBER_START_ROUTINE;
    _ = PFIBER_CALLOUT_ROUTINE;
    _ = PUMS_SCHEDULER_ENTRY_POINT;
    _ = PGET_SYSTEM_WOW64_DIRECTORY_A;
    _ = PGET_SYSTEM_WOW64_DIRECTORY_W;
    _ = PQUERYACTCTXW_FUNC;
    _ = APPLICATION_RECOVERY_CALLBACK;
    _ = QUERYHANDLER;
    _ = PQUERYHANDLER;
    _ = PPS_POST_PROCESS_INIT_ROUTINE;
    _ = PIO_APC_ROUTINE;
    _ = PWINSTATIONQUERYINFORMATIONW;
    _ = AVRF_RESOURCE_ENUMERATE_CALLBACK;
    _ = AVRF_HEAPALLOCATION_ENUMERATE_CALLBACK;
    _ = AVRF_HANDLEOPERATION_ENUMERATE_CALLBACK;
    _ = PFNFCIALLOC;
    _ = PFNFCIFREE;
    _ = PFNFCIOPEN;
    _ = PFNFCIREAD;
    _ = PFNFCIWRITE;
    _ = PFNFCICLOSE;
    _ = PFNFCISEEK;
    _ = PFNFCIDELETE;
    _ = PFNFCIGETNEXTCABINET;
    _ = PFNFCIFILEPLACED;
    _ = PFNFCIGETOPENINFO;
    _ = PFNFCISTATUS;
    _ = PFNFCIGETTEMPFILE;
    _ = PFNALLOC;
    _ = PFNFREE;
    _ = PFNOPEN;
    _ = PFNREAD;
    _ = PFNWRITE;
    _ = PFNCLOSE;
    _ = PFNSEEK;
    _ = PFNFDIDECRYPT;
    _ = PFNFDINOTIFY;
    _ = DEBUGEVENTPROC;
    _ = PROCESSENUMPROC;
    _ = TASKENUMPROC;
    _ = TASKENUMPROCEX;
    _ = VDMPROCESSEXCEPTIONPROC;
    _ = VDMGETTHREADSELECTORENTRYPROC;
    _ = VDMGETPOINTERPROC;
    _ = VDMGETCONTEXTPROC;
    _ = VDMSETCONTEXTPROC;
    _ = VDMKILLWOWPROC;
    _ = VDMDETECTWOWPROC;
    _ = VDMBREAKTHREADPROC;
    _ = VDMGETSELECTORMODULEPROC;
    _ = VDMGETMODULESELECTORPROC;
    _ = VDMMODULEFIRSTPROC;
    _ = VDMMODULENEXTPROC;
    _ = VDMGLOBALFIRSTPROC;
    _ = VDMGLOBALNEXTPROC;
    _ = VDMENUMPROCESSWOWPROC;
    _ = VDMENUMTASKWOWPROC;
    _ = VDMENUMTASKWOWEXPROC;
    _ = VDMTERMINATETASKINWOWPROC;
    _ = VDMSTARTTASKINWOWPROC;
    _ = VDMGETDBGFLAGSPROC;
    _ = VDMSETDBGFLAGSPROC;
    _ = VDMISMODULELOADEDPROC;
    _ = VDMGETSEGMENTINFOPROC;
    _ = VDMGETSYMBOLPROC;
    _ = VDMGETADDREXPRESSIONPROC;
    _ = FEATURE_STATE_CHANGE_CALLBACK;
    _ = PFEATURE_STATE_CHANGE_CALLBACK;
    _ = ENUM_CALLBACK;
    _ = WINWATCHNOTIFYPROC;
    _ = LPDD32BITDRIVERINIT;
    _ = LPDDHEL_INIT;
    _ = LPDDHAL_SETCOLORKEY;
    _ = LPDDHAL_CANCREATESURFACE;
    _ = LPDDHAL_CREATESURFACE;
    _ = LPDDHAL_DESTROYDRIVER;
    _ = LPDDHAL_SETMODE;
    _ = LPDDHAL_CREATEPALETTE;
    _ = LPDDHAL_GETSCANLINE;
    _ = LPDDHAL_SETEXCLUSIVEMODE;
    _ = LPDDHAL_FLIPTOGDISURFACE;
    _ = LPDDHAL_GETDRIVERINFO;
    _ = LPDDHALPALCB_DESTROYPALETTE;
    _ = LPDDHALPALCB_SETENTRIES;
    _ = LPDDHALSURFCB_LOCK;
    _ = LPDDHALSURFCB_UNLOCK;
    _ = LPDDHALSURFCB_BLT;
    _ = LPDDHALSURFCB_UPDATEOVERLAY;
    _ = LPDDHALSURFCB_SETOVERLAYPOSITION;
    _ = LPDDHALSURFCB_SETPALETTE;
    _ = LPDDHALSURFCB_FLIP;
    _ = LPDDHALSURFCB_DESTROYSURFACE;
    _ = LPDDHALSURFCB_SETCLIPLIST;
    _ = LPDDHALSURFCB_ADDATTACHEDSURFACE;
    _ = LPDDHALSURFCB_SETCOLORKEY;
    _ = LPDDHALSURFCB_GETBLTSTATUS;
    _ = LPDDHALSURFCB_GETFLIPSTATUS;
    _ = LPDDHAL_GETAVAILDRIVERMEMORY;
    _ = LPDDHAL_UPDATENONLOCALHEAP;
    _ = LPDDHAL_GETHEAPALIGNMENT;
    _ = LPDDHAL_CREATESURFACEEX;
    _ = LPDDHAL_GETDRIVERSTATE;
    _ = LPDDHAL_DESTROYDDLOCAL;
    _ = LPDDHALEXEBUFCB_CANCREATEEXEBUF;
    _ = LPDDHALEXEBUFCB_CREATEEXEBUF;
    _ = LPDDHALEXEBUFCB_DESTROYEXEBUF;
    _ = LPDDHALEXEBUFCB_LOCKEXEBUF;
    _ = LPDDHALEXEBUFCB_UNLOCKEXEBUF;
    _ = LPDDHALVPORTCB_CANCREATEVIDEOPORT;
    _ = LPDDHALVPORTCB_CREATEVIDEOPORT;
    _ = LPDDHALVPORTCB_FLIP;
    _ = LPDDHALVPORTCB_GETBANDWIDTH;
    _ = LPDDHALVPORTCB_GETINPUTFORMATS;
    _ = LPDDHALVPORTCB_GETOUTPUTFORMATS;
    _ = LPDDHALVPORTCB_GETFIELD;
    _ = LPDDHALVPORTCB_GETLINE;
    _ = LPDDHALVPORTCB_GETVPORTCONNECT;
    _ = LPDDHALVPORTCB_DESTROYVPORT;
    _ = LPDDHALVPORTCB_GETFLIPSTATUS;
    _ = LPDDHALVPORTCB_UPDATE;
    _ = LPDDHALVPORTCB_WAITFORSYNC;
    _ = LPDDHALVPORTCB_GETSIGNALSTATUS;
    _ = LPDDHALVPORTCB_COLORCONTROL;
    _ = LPDDHALCOLORCB_COLORCONTROL;
    _ = LPDDHALKERNELCB_SYNCSURFACE;
    _ = LPDDHALKERNELCB_SYNCVIDEOPORT;
    _ = LPDDGAMMACALIBRATORPROC;
    _ = LPDDHALMOCOMPCB_GETGUIDS;
    _ = LPDDHALMOCOMPCB_GETFORMATS;
    _ = LPDDHALMOCOMPCB_CREATE;
    _ = LPDDHALMOCOMPCB_GETCOMPBUFFINFO;
    _ = LPDDHALMOCOMPCB_GETINTERNALINFO;
    _ = LPDDHALMOCOMPCB_BEGINFRAME;
    _ = LPDDHALMOCOMPCB_ENDFRAME;
    _ = LPDDHALMOCOMPCB_RENDER;
    _ = LPDDHALMOCOMPCB_QUERYSTATUS;
    _ = LPDDHALMOCOMPCB_DESTROY;
    _ = LPDDHAL_SETINFO;
    _ = LPDDHAL_VIDMEMALLOC;
    _ = LPDDHAL_VIDMEMFREE;
    _ = PFNCHECKCONNECTIONWIZARD;
    _ = PFNSETSHELLNEXT;
    _ = REGINSTALLA;
    _ = PFN_IO_COMPLETION;
    _ = FCACHE_CREATE_CALLBACK;
    _ = FCACHE_RICHCREATE_CALLBACK;
    _ = CACHE_KEY_COMPARE;
    _ = CACHE_KEY_HASH;
    _ = CACHE_READ_CALLBACK;
    _ = CACHE_DESTROY_CALLBACK;
    _ = CACHE_ACCESS_CHECK;
    _ = PWLDP_SETDYNAMICCODETRUST_API;
    _ = PWLDP_ISDYNAMICCODEPOLICYENABLED_API;
    _ = PWLDP_QUERYDYNAMICODETRUST_API;
    _ = PWLDP_QUERYWINDOWSLOCKDOWNMODE_API;
    _ = PWLDP_QUERYWINDOWSLOCKDOWNRESTRICTION_API;
    _ = PWLDP_SETWINDOWSLOCKDOWNRESTRICTION_API;
    _ = PWLDP_WLDPISAPPAPPROVEDBYPOLICY_API;
    _ = PDEV_QUERY_RESULT_CALLBACK;

    const constant_export_count = 3;
    const type_export_count = 556;
    const enum_value_export_count = 591;
    const com_iface_id_export_count = 70;
    const com_class_id_export_count = 23;
    const func_export_count = 474;
    const unicode_alias_count = 109;
    const import_count = 75;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
