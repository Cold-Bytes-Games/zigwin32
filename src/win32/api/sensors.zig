//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (17)
//--------------------------------------------------------------------------------
const CLSID_SensorManager_Value = @import("../zig.zig").Guid.initString("77a1c827-fcd2-4689-8915-9d613cc5fa3e");
pub const CLSID_SensorManager = &CLSID_SensorManager_Value;

const CLSID_SensorCollection_Value = @import("../zig.zig").Guid.initString("79c43adb-a429-469f-aa39-2f2b74b75937");
pub const CLSID_SensorCollection = &CLSID_SensorCollection_Value;

const CLSID_Sensor_Value = @import("../zig.zig").Guid.initString("e97ced00-523a-4133-bf6f-d3a2dae7f6ba");
pub const CLSID_Sensor = &CLSID_Sensor_Value;

const CLSID_SensorDataReport_Value = @import("../zig.zig").Guid.initString("4ea9d6ef-694b-4218-8816-ccda8da74bba");
pub const CLSID_SensorDataReport = &CLSID_SensorDataReport_Value;

pub const SensorState = extern enum(i32) {
    SENSOR_STATE_MIN = 0,
    SENSOR_STATE_READY = 0,
    SENSOR_STATE_NOT_AVAILABLE = 1,
    SENSOR_STATE_NO_DATA = 2,
    SENSOR_STATE_INITIALIZING = 3,
    SENSOR_STATE_ACCESS_DENIED = 4,
    SENSOR_STATE_ERROR = 5,
    SENSOR_STATE_MAX = 5,
};
pub const SENSOR_STATE_MIN = SensorState.SENSOR_STATE_MIN;
pub const SENSOR_STATE_READY = SensorState.SENSOR_STATE_READY;
pub const SENSOR_STATE_NOT_AVAILABLE = SensorState.SENSOR_STATE_NOT_AVAILABLE;
pub const SENSOR_STATE_NO_DATA = SensorState.SENSOR_STATE_NO_DATA;
pub const SENSOR_STATE_INITIALIZING = SensorState.SENSOR_STATE_INITIALIZING;
pub const SENSOR_STATE_ACCESS_DENIED = SensorState.SENSOR_STATE_ACCESS_DENIED;
pub const SENSOR_STATE_ERROR = SensorState.SENSOR_STATE_ERROR;
pub const SENSOR_STATE_MAX = SensorState.SENSOR_STATE_MAX;

pub const SensorConnectionType = extern enum(i32) {
    SENSOR_CONNECTION_TYPE_PC_INTEGRATED = 0,
    SENSOR_CONNECTION_TYPE_PC_ATTACHED = 1,
    SENSOR_CONNECTION_TYPE_PC_EXTERNAL = 2,
};
pub const SENSOR_CONNECTION_TYPE_PC_INTEGRATED = SensorConnectionType.SENSOR_CONNECTION_TYPE_PC_INTEGRATED;
pub const SENSOR_CONNECTION_TYPE_PC_ATTACHED = SensorConnectionType.SENSOR_CONNECTION_TYPE_PC_ATTACHED;
pub const SENSOR_CONNECTION_TYPE_PC_EXTERNAL = SensorConnectionType.SENSOR_CONNECTION_TYPE_PC_EXTERNAL;

pub const LOCATION_DESIRED_ACCURACY = extern enum(i32) {
    DEFAULT = 0,
    HIGH = 1,
};
pub const LOCATION_DESIRED_ACCURACY_DEFAULT = LOCATION_DESIRED_ACCURACY.DEFAULT;
pub const LOCATION_DESIRED_ACCURACY_HIGH = LOCATION_DESIRED_ACCURACY.HIGH;

pub const LOCATION_POSITION_SOURCE = extern enum(i32) {
    CELLULAR = 0,
    SATELLITE = 1,
    WIFI = 2,
    IPADDRESS = 3,
    UNKNOWN = 4,
};
pub const LOCATION_POSITION_SOURCE_CELLULAR = LOCATION_POSITION_SOURCE.CELLULAR;
pub const LOCATION_POSITION_SOURCE_SATELLITE = LOCATION_POSITION_SOURCE.SATELLITE;
pub const LOCATION_POSITION_SOURCE_WIFI = LOCATION_POSITION_SOURCE.WIFI;
pub const LOCATION_POSITION_SOURCE_IPADDRESS = LOCATION_POSITION_SOURCE.IPADDRESS;
pub const LOCATION_POSITION_SOURCE_UNKNOWN = LOCATION_POSITION_SOURCE.UNKNOWN;

pub const SimpleDeviceOrientation = extern enum(i32) {
    SIMPLE_DEVICE_ORIENTATION_NOT_ROTATED = 0,
    SIMPLE_DEVICE_ORIENTATION_ROTATED_90 = 1,
    SIMPLE_DEVICE_ORIENTATION_ROTATED_180 = 2,
    SIMPLE_DEVICE_ORIENTATION_ROTATED_270 = 3,
    SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_UP = 4,
    SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_DOWN = 5,
};
pub const SIMPLE_DEVICE_ORIENTATION_NOT_ROTATED = SimpleDeviceOrientation.SIMPLE_DEVICE_ORIENTATION_NOT_ROTATED;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_90 = SimpleDeviceOrientation.SIMPLE_DEVICE_ORIENTATION_ROTATED_90;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_180 = SimpleDeviceOrientation.SIMPLE_DEVICE_ORIENTATION_ROTATED_180;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_270 = SimpleDeviceOrientation.SIMPLE_DEVICE_ORIENTATION_ROTATED_270;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_UP = SimpleDeviceOrientation.SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_UP;
pub const SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_DOWN = SimpleDeviceOrientation.SIMPLE_DEVICE_ORIENTATION_ROTATED_FACE_DOWN;

pub const MagnetometerAccuracy = extern enum(i32) {
    MAGNETOMETER_ACCURACY_UNKNOWN = 0,
    MAGNETOMETER_ACCURACY_UNRELIABLE = 1,
    MAGNETOMETER_ACCURACY_APPROXIMATE = 2,
    MAGNETOMETER_ACCURACY_HIGH = 3,
};
pub const MAGNETOMETER_ACCURACY_UNKNOWN = MagnetometerAccuracy.MAGNETOMETER_ACCURACY_UNKNOWN;
pub const MAGNETOMETER_ACCURACY_UNRELIABLE = MagnetometerAccuracy.MAGNETOMETER_ACCURACY_UNRELIABLE;
pub const MAGNETOMETER_ACCURACY_APPROXIMATE = MagnetometerAccuracy.MAGNETOMETER_ACCURACY_APPROXIMATE;
pub const MAGNETOMETER_ACCURACY_HIGH = MagnetometerAccuracy.MAGNETOMETER_ACCURACY_HIGH;

const IID_ISensorManager_Value = @import("../zig.zig").Guid.initString("bd77db67-45a8-42dc-8d00-6dcf15f8377a");
pub const IID_ISensorManager = &IID_ISensorManager_Value;
pub const ISensorManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSensorsByCategory: fn(
            self: *const ISensorManager,
            sensorCategory: *Guid,
            ppSensorsFound: ?*?*ISensorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorsByType: fn(
            self: *const ISensorManager,
            sensorType: *Guid,
            ppSensorsFound: ?*?*ISensorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorByID: fn(
            self: *const ISensorManager,
            sensorID: *Guid,
            ppSensor: ?*?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventSink: fn(
            self: *const ISensorManager,
            pEvents: ?*ISensorManagerEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RequestPermissions: fn(
            self: *const ISensorManager,
            hParent: HWND,
            pSensors: ?*ISensorCollection,
            fModal: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_GetSensorsByCategory(self: *const T, sensorCategory: *Guid, ppSensorsFound: ?*?*ISensorCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).GetSensorsByCategory(@ptrCast(*const ISensorManager, self), sensorCategory, ppSensorsFound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_GetSensorsByType(self: *const T, sensorType: *Guid, ppSensorsFound: ?*?*ISensorCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).GetSensorsByType(@ptrCast(*const ISensorManager, self), sensorType, ppSensorsFound);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_GetSensorByID(self: *const T, sensorID: *Guid, ppSensor: ?*?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).GetSensorByID(@ptrCast(*const ISensorManager, self), sensorID, ppSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_SetEventSink(self: *const T, pEvents: ?*ISensorManagerEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).SetEventSink(@ptrCast(*const ISensorManager, self), pEvents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManager_RequestPermissions(self: *const T, hParent: HWND, pSensors: ?*ISensorCollection, fModal: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManager.VTable, self.vtable).RequestPermissions(@ptrCast(*const ISensorManager, self), hParent, pSensors, fModal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ILocationPermissions_Value = @import("../zig.zig").Guid.initString("d5fb0a7f-e74e-44f5-8e02-4806863a274f");
pub const IID_ILocationPermissions = &IID_ILocationPermissions_Value;
pub const ILocationPermissions = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetGlobalLocationPermission: fn(
            self: *const ILocationPermissions,
            pfEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckLocationCapability: fn(
            self: *const ILocationPermissions,
            dwClientThreadId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocationPermissions_GetGlobalLocationPermission(self: *const T, pfEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocationPermissions.VTable, self.vtable).GetGlobalLocationPermission(@ptrCast(*const ILocationPermissions, self), pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILocationPermissions_CheckLocationCapability(self: *const T, dwClientThreadId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILocationPermissions.VTable, self.vtable).CheckLocationCapability(@ptrCast(*const ILocationPermissions, self), dwClientThreadId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISensorCollection_Value = @import("../zig.zig").Guid.initString("23571e11-e545-4dd8-a337-b89bf44b10df");
pub const IID_ISensorCollection = &IID_ISensorCollection_Value;
pub const ISensorCollection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetAt: fn(
            self: *const ISensorCollection,
            ulIndex: u32,
            ppSensor: ?*?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ISensorCollection,
            pCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ISensorCollection,
            pSensor: ?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ISensorCollection,
            pSensor: ?*ISensor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveByID: fn(
            self: *const ISensorCollection,
            sensorID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const ISensorCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_GetAt(self: *const T, ulIndex: u32, ppSensor: ?*?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).GetAt(@ptrCast(*const ISensorCollection, self), ulIndex, ppSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_GetCount(self: *const T, pCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).GetCount(@ptrCast(*const ISensorCollection, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_Add(self: *const T, pSensor: ?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).Add(@ptrCast(*const ISensorCollection, self), pSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_Remove(self: *const T, pSensor: ?*ISensor) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).Remove(@ptrCast(*const ISensorCollection, self), pSensor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_RemoveByID(self: *const T, sensorID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).RemoveByID(@ptrCast(*const ISensorCollection, self), sensorID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorCollection_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorCollection.VTable, self.vtable).Clear(@ptrCast(*const ISensorCollection, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISensor_Value = @import("../zig.zig").Guid.initString("5fa08f80-2657-458e-af75-46f73fa6ac5c");
pub const IID_ISensor = &IID_ISensor_Value;
pub const ISensor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetID: fn(
            self: *const ISensor,
            pID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCategory: fn(
            self: *const ISensor,
            pSensorCategory: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ISensor,
            pSensorType: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFriendlyName: fn(
            self: *const ISensor,
            pFriendlyName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ISensor,
            key: *const PROPERTYKEY,
            pProperty: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const ISensor,
            pKeys: ?*IPortableDeviceKeyCollection,
            ppProperties: ?*?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedDataFields: fn(
            self: *const ISensor,
            ppDataFields: ?*?*IPortableDeviceKeyCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperties: fn(
            self: *const ISensor,
            pProperties: ?*IPortableDeviceValues,
            ppResults: ?*?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupportsDataField: fn(
            self: *const ISensor,
            key: *const PROPERTYKEY,
            pIsSupported: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const ISensor,
            pState: *SensorState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: fn(
            self: *const ISensor,
            ppDataReport: ?*?*ISensorDataReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SupportsEvent: fn(
            self: *const ISensor,
            eventGuid: *const Guid,
            pIsSupported: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventInterest: fn(
            self: *const ISensor,
            ppValues: ?[*]?*Guid,
            pCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventInterest: fn(
            self: *const ISensor,
            pValues: ?[*]Guid,
            count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventSink: fn(
            self: *const ISensor,
            pEvents: ?*ISensorEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetID(self: *const T, pID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetID(@ptrCast(*const ISensor, self), pID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetCategory(self: *const T, pSensorCategory: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetCategory(@ptrCast(*const ISensor, self), pSensorCategory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetType(self: *const T, pSensorType: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetType(@ptrCast(*const ISensor, self), pSensorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetFriendlyName(self: *const T, pFriendlyName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetFriendlyName(@ptrCast(*const ISensor, self), pFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetProperty(self: *const T, key: *const PROPERTYKEY, pProperty: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetProperty(@ptrCast(*const ISensor, self), key, pProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetProperties(self: *const T, pKeys: ?*IPortableDeviceKeyCollection, ppProperties: ?*?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetProperties(@ptrCast(*const ISensor, self), pKeys, ppProperties);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetSupportedDataFields(self: *const T, ppDataFields: ?*?*IPortableDeviceKeyCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetSupportedDataFields(@ptrCast(*const ISensor, self), ppDataFields);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SetProperties(self: *const T, pProperties: ?*IPortableDeviceValues, ppResults: ?*?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SetProperties(@ptrCast(*const ISensor, self), pProperties, ppResults);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SupportsDataField(self: *const T, key: *const PROPERTYKEY, pIsSupported: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SupportsDataField(@ptrCast(*const ISensor, self), key, pIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetState(self: *const T, pState: *SensorState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetState(@ptrCast(*const ISensor, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetData(self: *const T, ppDataReport: ?*?*ISensorDataReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetData(@ptrCast(*const ISensor, self), ppDataReport);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SupportsEvent(self: *const T, eventGuid: *const Guid, pIsSupported: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SupportsEvent(@ptrCast(*const ISensor, self), eventGuid, pIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_GetEventInterest(self: *const T, ppValues: ?[*]?*Guid, pCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).GetEventInterest(@ptrCast(*const ISensor, self), ppValues, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SetEventInterest(self: *const T, pValues: ?[*]Guid, count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SetEventInterest(@ptrCast(*const ISensor, self), pValues, count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensor_SetEventSink(self: *const T, pEvents: ?*ISensorEvents) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensor.VTable, self.vtable).SetEventSink(@ptrCast(*const ISensor, self), pEvents);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISensorDataReport_Value = @import("../zig.zig").Guid.initString("0ab9df9b-c4b5-4796-8898-0470706a2e1d");
pub const IID_ISensorDataReport = &IID_ISensorDataReport_Value;
pub const ISensorDataReport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTimestamp: fn(
            self: *const ISensorDataReport,
            pTimeStamp: *SYSTEMTIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorValue: fn(
            self: *const ISensorDataReport,
            pKey: *const PROPERTYKEY,
            pValue: *PROPVARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSensorValues: fn(
            self: *const ISensorDataReport,
            pKeys: ?*IPortableDeviceKeyCollection,
            ppValues: ?*?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorDataReport_GetTimestamp(self: *const T, pTimeStamp: *SYSTEMTIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorDataReport.VTable, self.vtable).GetTimestamp(@ptrCast(*const ISensorDataReport, self), pTimeStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorDataReport_GetSensorValue(self: *const T, pKey: *const PROPERTYKEY, pValue: *PROPVARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorDataReport.VTable, self.vtable).GetSensorValue(@ptrCast(*const ISensorDataReport, self), pKey, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorDataReport_GetSensorValues(self: *const T, pKeys: ?*IPortableDeviceKeyCollection, ppValues: ?*?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorDataReport.VTable, self.vtable).GetSensorValues(@ptrCast(*const ISensorDataReport, self), pKeys, ppValues);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISensorManagerEvents_Value = @import("../zig.zig").Guid.initString("9b3b0b86-266a-4aad-b21f-fde5501001b7");
pub const IID_ISensorManagerEvents = &IID_ISensorManagerEvents_Value;
pub const ISensorManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnSensorEnter: fn(
            self: *const ISensorManagerEvents,
            pSensor: ?*ISensor,
            state: SensorState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorManagerEvents_OnSensorEnter(self: *const T, pSensor: ?*ISensor, state: SensorState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorManagerEvents.VTable, self.vtable).OnSensorEnter(@ptrCast(*const ISensorManagerEvents, self), pSensor, state);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISensorEvents_Value = @import("../zig.zig").Guid.initString("5d8dcc91-4641-47e7-b7c3-b74f48a6c391");
pub const IID_ISensorEvents = &IID_ISensorEvents_Value;
pub const ISensorEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnStateChanged: fn(
            self: *const ISensorEvents,
            pSensor: ?*ISensor,
            state: SensorState,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDataUpdated: fn(
            self: *const ISensorEvents,
            pSensor: ?*ISensor,
            pNewData: ?*ISensorDataReport,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEvent: fn(
            self: *const ISensorEvents,
            pSensor: ?*ISensor,
            eventID: *const Guid,
            pEventData: ?*IPortableDeviceValues,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLeave: fn(
            self: *const ISensorEvents,
            ID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnStateChanged(self: *const T, pSensor: ?*ISensor, state: SensorState) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnStateChanged(@ptrCast(*const ISensorEvents, self), pSensor, state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnDataUpdated(self: *const T, pSensor: ?*ISensor, pNewData: ?*ISensorDataReport) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnDataUpdated(@ptrCast(*const ISensorEvents, self), pSensor, pNewData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnEvent(self: *const T, pSensor: ?*ISensor, eventID: *const Guid, pEventData: ?*IPortableDeviceValues) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnEvent(@ptrCast(*const ISensorEvents, self), pSensor, eventID, pEventData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISensorEvents_OnLeave(self: *const T, ID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISensorEvents.VTable, self.vtable).OnLeave(@ptrCast(*const ISensorEvents, self), ID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (11)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IUnknown = @import("com.zig").IUnknown;
const SYSTEMTIME = @import("windows_programming.zig").SYSTEMTIME;
const HRESULT = @import("com.zig").HRESULT;
const PROPERTYKEY = @import("windows_properties_system.zig").PROPERTYKEY;
const PROPVARIANT = @import("structured_storage.zig").PROPVARIANT;
const BSTR = @import("automation.zig").BSTR;
const IPortableDeviceKeyCollection = @import("windows_portable_devices.zig").IPortableDeviceKeyCollection;
const BOOL = @import("system_services.zig").BOOL;
const HWND = @import("windows_and_messaging.zig").HWND;
const IPortableDeviceValues = @import("windows_portable_devices.zig").IPortableDeviceValues;

test {
    const constant_export_count = 0;
    const type_export_count = 13;
    const enum_value_export_count = 28;
    const com_iface_id_export_count = 7;
    const com_class_id_export_count = 4;
    const func_export_count = 0;
    const unicode_alias_count = 0;
    const import_count = 11;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
