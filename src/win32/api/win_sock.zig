//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (10)
//--------------------------------------------------------------------------------
pub const LM_HB_Extension : i32 = 128;
pub const LM_HB1_PnP : i32 = 1;
pub const LM_HB1_PDA_Palmtop : i32 = 2;
pub const LM_HB1_Computer : i32 = 4;
pub const LM_HB1_Printer : i32 = 8;
pub const LM_HB1_Modem : i32 = 16;
pub const LM_HB1_Fax : i32 = 32;
pub const LM_HB1_LANAccess : i32 = 64;
pub const LM_HB2_Telephony : i32 = 1;
pub const LM_HB2_FileServer : i32 = 2;

//--------------------------------------------------------------------------------
// Section: Types (299)
//--------------------------------------------------------------------------------
// TODO: this type has a FreeFunc 'WSACloseEvent', what can Zig do with this information?
pub const HWSAEVENT = ?*c_void;

pub const BLOB = extern struct {
    cbSize: u32,
    pBlobData: *u8,
};

pub const in_addr = extern struct {
    S_un: in_addr._S_un_e__Union,
    const _S_un_e__Union = u32; // TODO: generate this nested type!
};

pub const SOCKADDR = extern struct {
    sa_family: u16,
    sa_data: [14]i8,
};

pub const SOCKET_ADDRESS = extern struct {
    lpSockaddr: *SOCKADDR,
    iSockaddrLength: i32,
};

pub const CSADDR_INFO = extern struct {
    LocalAddr: SOCKET_ADDRESS,
    RemoteAddr: SOCKET_ADDRESS,
    iSocketType: i32,
    iProtocol: i32,
};

pub const sockaddr_storage_xp = extern struct {
    ss_family: i16,
    __ss_pad1: [6]i8,
    __ss_align: i64,
    __ss_pad2: [112]i8,
};

pub const SOCKET_PROCESSOR_AFFINITY = extern struct {
    Processor: PROCESSOR_NUMBER,
    NumaNodeId: u16,
    Reserved: u16,
};

pub const IPPROTO = extern enum(i32) {
    HOPOPTS = 0,
    ICMP = 1,
    IGMP = 2,
    GGP = 3,
    IPV4 = 4,
    ST = 5,
    TCP = 6,
    CBT = 7,
    EGP = 8,
    IGP = 9,
    PUP = 12,
    UDP = 17,
    IDP = 22,
    RDP = 27,
    IPV6 = 41,
    ROUTING = 43,
    FRAGMENT = 44,
    ESP = 50,
    AH = 51,
    ICMPV6 = 58,
    NONE = 59,
    DSTOPTS = 60,
    ND = 77,
    ICLFXBM = 78,
    PIM = 103,
    PGM = 113,
    L2TP = 115,
    SCTP = 132,
    RAW = 255,
    MAX = 256,
    RESERVED_RAW = 257,
    RESERVED_IPSEC = 258,
    RESERVED_IPSECOFFLOAD = 259,
    RESERVED_WNV = 260,
    RESERVED_MAX = 261,
};
pub const IPPROTO_HOPOPTS = IPPROTO.HOPOPTS;
pub const IPPROTO_ICMP = IPPROTO.ICMP;
pub const IPPROTO_IGMP = IPPROTO.IGMP;
pub const IPPROTO_GGP = IPPROTO.GGP;
pub const IPPROTO_IPV4 = IPPROTO.IPV4;
pub const IPPROTO_ST = IPPROTO.ST;
pub const IPPROTO_TCP = IPPROTO.TCP;
pub const IPPROTO_CBT = IPPROTO.CBT;
pub const IPPROTO_EGP = IPPROTO.EGP;
pub const IPPROTO_IGP = IPPROTO.IGP;
pub const IPPROTO_PUP = IPPROTO.PUP;
pub const IPPROTO_UDP = IPPROTO.UDP;
pub const IPPROTO_IDP = IPPROTO.IDP;
pub const IPPROTO_RDP = IPPROTO.RDP;
pub const IPPROTO_IPV6 = IPPROTO.IPV6;
pub const IPPROTO_ROUTING = IPPROTO.ROUTING;
pub const IPPROTO_FRAGMENT = IPPROTO.FRAGMENT;
pub const IPPROTO_ESP = IPPROTO.ESP;
pub const IPPROTO_AH = IPPROTO.AH;
pub const IPPROTO_ICMPV6 = IPPROTO.ICMPV6;
pub const IPPROTO_NONE = IPPROTO.NONE;
pub const IPPROTO_DSTOPTS = IPPROTO.DSTOPTS;
pub const IPPROTO_ND = IPPROTO.ND;
pub const IPPROTO_ICLFXBM = IPPROTO.ICLFXBM;
pub const IPPROTO_PIM = IPPROTO.PIM;
pub const IPPROTO_PGM = IPPROTO.PGM;
pub const IPPROTO_L2TP = IPPROTO.L2TP;
pub const IPPROTO_SCTP = IPPROTO.SCTP;
pub const IPPROTO_RAW = IPPROTO.RAW;
pub const IPPROTO_MAX = IPPROTO.MAX;
pub const IPPROTO_RESERVED_RAW = IPPROTO.RESERVED_RAW;
pub const IPPROTO_RESERVED_IPSEC = IPPROTO.RESERVED_IPSEC;
pub const IPPROTO_RESERVED_IPSECOFFLOAD = IPPROTO.RESERVED_IPSECOFFLOAD;
pub const IPPROTO_RESERVED_WNV = IPPROTO.RESERVED_WNV;
pub const IPPROTO_RESERVED_MAX = IPPROTO.RESERVED_MAX;

pub const SCOPE_ID = extern struct {
    Anonymous: SCOPE_ID._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const sockaddr_in = extern struct {
    sin_family: u16,
    sin_port: u16,
    sin_addr: in_addr,
    sin_zero: [8]i8,
};

pub const sockaddr_dl = extern struct {
    sdl_family: u16,
    sdl_data: [8]u8,
    sdl_zero: [4]u8,
};

pub const WSABUF = extern struct {
    len: u32,
    buf: *i8,
};

pub const WSAMSG = extern struct {
    name: *SOCKADDR,
    namelen: i32,
    lpBuffers: *WSABUF,
    dwBufferCount: u32,
    Control: WSABUF,
    dwFlags: u32,
};

pub const cmsghdr = extern struct {
    cmsg_len: ?*c_void,
    cmsg_level: i32,
    cmsg_type: i32,
};

pub const ADDRINFOA = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: ?*c_void,
    ai_canonname: *i8,
    ai_addr: *SOCKADDR,
    ai_next: *ADDRINFOA,
};

pub const addrinfoW = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: ?*c_void,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_next: *addrinfoW,
};

pub const addrinfoexA = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: ?*c_void,
    ai_canonname: *i8,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: ?*c_void,
    ai_provider: *Guid,
    ai_next: *addrinfoexA,
};

pub const addrinfoexW = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: ?*c_void,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: ?*c_void,
    ai_provider: *Guid,
    ai_next: *addrinfoexW,
};

pub const addrinfoex2A = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: ?*c_void,
    ai_canonname: *i8,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: ?*c_void,
    ai_provider: *Guid,
    ai_next: *addrinfoex2A,
    ai_version: i32,
    ai_fqdn: *i8,
};

pub const addrinfoex2W = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: ?*c_void,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: ?*c_void,
    ai_provider: *Guid,
    ai_next: *addrinfoex2W,
    ai_version: i32,
    ai_fqdn: PWSTR,
};

pub const addrinfoex3 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: ?*c_void,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: ?*c_void,
    ai_provider: *Guid,
    ai_next: *addrinfoex3,
    ai_version: i32,
    ai_fqdn: PWSTR,
    ai_interfaceindex: i32,
};

pub const addrinfoex4 = extern struct {
    ai_flags: i32,
    ai_family: i32,
    ai_socktype: i32,
    ai_protocol: i32,
    ai_addrlen: ?*c_void,
    ai_canonname: PWSTR,
    ai_addr: *SOCKADDR,
    ai_blob: *c_void,
    ai_bloblen: ?*c_void,
    ai_provider: *Guid,
    ai_next: *addrinfoex4,
    ai_version: i32,
    ai_fqdn: PWSTR,
    ai_interfaceindex: i32,
    ai_resolutionhandle: HANDLE,
};

pub const fd_set = extern struct {
    fd_count: u32,
    fd_array: [64]?*c_void,
};

pub const timeval = extern struct {
    tv_sec: i32,
    tv_usec: i32,
};

pub const hostent = extern struct {
    h_name: *i8,
    h_aliases: **i8,
    h_addrtype: i16,
    h_length: i16,
    h_addr_list: **i8,
};

pub const netent = extern struct {
    n_name: *i8,
    n_aliases: **i8,
    n_addrtype: i16,
    n_net: u32,
};

pub const servent = extern struct {
    s_name: *i8,
    s_aliases: **i8,
    s_port: i16,
    s_proto: *i8,
};

pub const protoent = extern struct {
    p_name: *i8,
    p_aliases: **i8,
    p_proto: i16,
};

pub const WSAData = extern struct {
    wVersion: u16,
    wHighVersion: u16,
    szDescription: [257]i8,
    szSystemStatus: [129]i8,
    iMaxSockets: u16,
    iMaxUdpDg: u16,
    lpVendorInfo: *i8,
};

pub const sockproto = extern struct {
    sp_family: u16,
    sp_protocol: u16,
};

pub const linger = extern struct {
    l_onoff: u16,
    l_linger: u16,
};

pub const WSANETWORKEVENTS = extern struct {
    lNetworkEvents: i32,
    iErrorCode: [10]i32,
};

pub const WSAPROTOCOLCHAIN = extern struct {
    ChainLen: i32,
    ChainEntries: [7]u32,
};

pub const WSAPROTOCOL_INFOA = extern struct {
    dwServiceFlags1: u32,
    dwServiceFlags2: u32,
    dwServiceFlags3: u32,
    dwServiceFlags4: u32,
    dwProviderFlags: u32,
    ProviderId: Guid,
    dwCatalogEntryId: u32,
    ProtocolChain: WSAPROTOCOLCHAIN,
    iVersion: i32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    iProtocolMaxOffset: i32,
    iNetworkByteOrder: i32,
    iSecurityScheme: i32,
    dwMessageSize: u32,
    dwProviderReserved: u32,
    szProtocol: [256]i8,
};

pub const WSAPROTOCOL_INFOW = extern struct {
    dwServiceFlags1: u32,
    dwServiceFlags2: u32,
    dwServiceFlags3: u32,
    dwServiceFlags4: u32,
    dwProviderFlags: u32,
    ProviderId: Guid,
    dwCatalogEntryId: u32,
    ProtocolChain: WSAPROTOCOLCHAIN,
    iVersion: i32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    iProtocolMaxOffset: i32,
    iNetworkByteOrder: i32,
    iSecurityScheme: i32,
    dwMessageSize: u32,
    dwProviderReserved: u32,
    szProtocol: [256]u16,
};

pub const LPCONDITIONPROC = fn(
    lpCallerId: *WSABUF,
    lpCallerData: *WSABUF,
    lpSQOS: *QOS,
    lpGQOS: *QOS,
    lpCalleeId: *WSABUF,
    lpCalleeData: *WSABUF,
    g: *u32,
    dwCallbackData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSAOVERLAPPED_COMPLETION_ROUTINE = fn(
    dwError: u32,
    cbTransferred: u32,
    lpOverlapped: *OVERLAPPED,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSACOMPLETIONTYPE = extern enum(i32) {
    NSP_NOTIFY_IMMEDIATELY = 0,
    NSP_NOTIFY_HWND = 1,
    NSP_NOTIFY_EVENT = 2,
    NSP_NOTIFY_PORT = 3,
    NSP_NOTIFY_APC = 4,
};
pub const NSP_NOTIFY_IMMEDIATELY = WSACOMPLETIONTYPE.NSP_NOTIFY_IMMEDIATELY;
pub const NSP_NOTIFY_HWND = WSACOMPLETIONTYPE.NSP_NOTIFY_HWND;
pub const NSP_NOTIFY_EVENT = WSACOMPLETIONTYPE.NSP_NOTIFY_EVENT;
pub const NSP_NOTIFY_PORT = WSACOMPLETIONTYPE.NSP_NOTIFY_PORT;
pub const NSP_NOTIFY_APC = WSACOMPLETIONTYPE.NSP_NOTIFY_APC;

pub const WSACOMPLETION = extern struct {
    Type: WSACOMPLETIONTYPE,
    Parameters: WSACOMPLETION._Parameters_e__Union,
    const _Parameters_e__Union = u32; // TODO: generate this nested type!
};

pub const AFPROTOCOLS = extern struct {
    iAddressFamily: i32,
    iProtocol: i32,
};

pub const WSAECOMPARATOR = extern enum(i32) {
    COMP_EQUAL = 0,
    COMP_NOTLESS = 1,
};
pub const COMP_EQUAL = WSAECOMPARATOR.COMP_EQUAL;
pub const COMP_NOTLESS = WSAECOMPARATOR.COMP_NOTLESS;

pub const WSAVERSION = extern struct {
    dwVersion: u32,
    ecHow: WSAECOMPARATOR,
};

pub const WSAQUERYSETA = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: PSTR,
    lpServiceClassId: *Guid,
    lpVersion: *WSAVERSION,
    lpszComment: PSTR,
    dwNameSpace: u32,
    lpNSProviderId: *Guid,
    lpszContext: PSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: *AFPROTOCOLS,
    lpszQueryString: PSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: *CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: *BLOB,
};

pub const WSAQUERYSETW = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: PWSTR,
    lpServiceClassId: *Guid,
    lpVersion: *WSAVERSION,
    lpszComment: PWSTR,
    dwNameSpace: u32,
    lpNSProviderId: *Guid,
    lpszContext: PWSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: *AFPROTOCOLS,
    lpszQueryString: PWSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: *CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: *BLOB,
};

pub const WSAQUERYSET2A = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: PSTR,
    lpVersion: *WSAVERSION,
    lpszComment: PSTR,
    dwNameSpace: u32,
    lpNSProviderId: *Guid,
    lpszContext: PSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: *AFPROTOCOLS,
    lpszQueryString: PSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: *CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: *BLOB,
};

pub const WSAQUERYSET2W = extern struct {
    dwSize: u32,
    lpszServiceInstanceName: PWSTR,
    lpVersion: *WSAVERSION,
    lpszComment: PWSTR,
    dwNameSpace: u32,
    lpNSProviderId: *Guid,
    lpszContext: PWSTR,
    dwNumberOfProtocols: u32,
    lpafpProtocols: *AFPROTOCOLS,
    lpszQueryString: PWSTR,
    dwNumberOfCsAddrs: u32,
    lpcsaBuffer: *CSADDR_INFO,
    dwOutputFlags: u32,
    lpBlob: *BLOB,
};

pub const WSAESETSERVICEOP = extern enum(i32) {
    RNRSERVICE_REGISTER = 0,
    RNRSERVICE_DEREGISTER = 1,
    RNRSERVICE_DELETE = 2,
};
pub const RNRSERVICE_REGISTER = WSAESETSERVICEOP.RNRSERVICE_REGISTER;
pub const RNRSERVICE_DEREGISTER = WSAESETSERVICEOP.RNRSERVICE_DEREGISTER;
pub const RNRSERVICE_DELETE = WSAESETSERVICEOP.RNRSERVICE_DELETE;

pub const WSANSCLASSINFOA = extern struct {
    lpszName: PSTR,
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValue: *c_void,
};

pub const WSANSCLASSINFOW = extern struct {
    lpszName: PWSTR,
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValue: *c_void,
};

pub const WSASERVICECLASSINFOA = extern struct {
    lpServiceClassId: *Guid,
    lpszServiceClassName: PSTR,
    dwCount: u32,
    lpClassInfos: *WSANSCLASSINFOA,
};

pub const WSASERVICECLASSINFOW = extern struct {
    lpServiceClassId: *Guid,
    lpszServiceClassName: PWSTR,
    dwCount: u32,
    lpClassInfos: *WSANSCLASSINFOW,
};

pub const WSANAMESPACE_INFOA = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: PSTR,
};

pub const WSANAMESPACE_INFOW = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: PWSTR,
};

pub const WSANAMESPACE_INFOEXA = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: PSTR,
    ProviderSpecific: BLOB,
};

pub const WSANAMESPACE_INFOEXW = extern struct {
    NSProviderId: Guid,
    dwNameSpace: u32,
    fActive: BOOL,
    dwVersion: u32,
    lpszIdentifier: PWSTR,
    ProviderSpecific: BLOB,
};

pub const WSAPOLLFD = extern struct {
    fd: ?*c_void,
    events: i16,
    revents: i16,
};

pub const in6_addr = extern struct {
    u: in6_addr._u_e__Union,
    const _u_e__Union = u32; // TODO: generate this nested type!
};

pub const sockaddr_in6_old = extern struct {
    sin6_family: i16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: in6_addr,
};

pub const sockaddr_gen = u32; // TODO: implement StructOrUnion types?

pub const INTERFACE_INFO = extern struct {
    iiFlags: u32,
    iiAddress: sockaddr_gen,
    iiBroadcastAddress: sockaddr_gen,
    iiNetmask: sockaddr_gen,
};

pub const INTERFACE_INFO_EX = extern struct {
    iiFlags: u32,
    iiAddress: SOCKET_ADDRESS,
    iiBroadcastAddress: SOCKET_ADDRESS,
    iiNetmask: SOCKET_ADDRESS,
};

pub const PMTUD_STATE = extern enum(i32) {
    IP_PMTUDISC_NOT_SET = 0,
    IP_PMTUDISC_DO = 1,
    IP_PMTUDISC_DONT = 2,
    IP_PMTUDISC_PROBE = 3,
    IP_PMTUDISC_MAX = 4,
};
pub const IP_PMTUDISC_NOT_SET = PMTUD_STATE.IP_PMTUDISC_NOT_SET;
pub const IP_PMTUDISC_DO = PMTUD_STATE.IP_PMTUDISC_DO;
pub const IP_PMTUDISC_DONT = PMTUD_STATE.IP_PMTUDISC_DONT;
pub const IP_PMTUDISC_PROBE = PMTUD_STATE.IP_PMTUDISC_PROBE;
pub const IP_PMTUDISC_MAX = PMTUD_STATE.IP_PMTUDISC_MAX;

pub const sockaddr_in6_w2ksp1 = extern struct {
    sin6_family: i16,
    sin6_port: u16,
    sin6_flowinfo: u32,
    sin6_addr: in6_addr,
    sin6_scope_id: u32,
};

pub const MULTICAST_MODE_TYPE = extern enum(i32) {
    MCAST_INCLUDE = 0,
    MCAST_EXCLUDE = 1,
};
pub const MCAST_INCLUDE = MULTICAST_MODE_TYPE.MCAST_INCLUDE;
pub const MCAST_EXCLUDE = MULTICAST_MODE_TYPE.MCAST_EXCLUDE;

pub const ip_mreq = extern struct {
    imr_multiaddr: in_addr,
    imr_interface: in_addr,
};

pub const ip_mreq_source = extern struct {
    imr_multiaddr: in_addr,
    imr_sourceaddr: in_addr,
    imr_interface: in_addr,
};

pub const ip_msfilter = extern struct {
    imsf_multiaddr: in_addr,
    imsf_interface: in_addr,
    imsf_fmode: MULTICAST_MODE_TYPE,
    imsf_numsrc: u32,
    imsf_slist: [1]in_addr,
};

pub const ipv6_mreq = extern struct {
    ipv6mr_multiaddr: in6_addr,
    ipv6mr_interface: u32,
};

pub const group_req = extern struct {
    gr_interface: u32,
    gr_group: SOCKADDR_STORAGE_LH,
};

pub const group_source_req = extern struct {
    gsr_interface: u32,
    gsr_group: SOCKADDR_STORAGE_LH,
    gsr_source: SOCKADDR_STORAGE_LH,
};

pub const group_filter = extern struct {
    gf_interface: u32,
    gf_group: SOCKADDR_STORAGE_LH,
    gf_fmode: MULTICAST_MODE_TYPE,
    gf_numsrc: u32,
    gf_slist: [1]SOCKADDR_STORAGE_LH,
};

pub const in_pktinfo = extern struct {
    ipi_addr: in_addr,
    ipi_ifindex: u32,
};

pub const in6_pktinfo = extern struct {
    ipi6_addr: in6_addr,
    ipi6_ifindex: u32,
};

pub const in_pktinfo_ex = extern struct {
    pkt_info: in_pktinfo,
    scope_id: SCOPE_ID,
};

pub const in6_pktinfo_ex = extern struct {
    pkt_info: in6_pktinfo,
    scope_id: SCOPE_ID,
};

pub const in_recverr = extern struct {
    protocol: IPPROTO,
    info: u32,
    type: u8,
    code: u8,
};

pub const icmp_error_info = extern struct {
    srcaddress: SOCKADDR_INET,
    protocol: IPPROTO,
    type: u8,
    code: u8,
};

pub const eWINDOW_ADVANCE_METHOD = extern enum(i32) {
    E_WINDOW_ADVANCE_BY_TIME = 1,
    E_WINDOW_USE_AS_DATA_CACHE = 2,
};
pub const E_WINDOW_ADVANCE_BY_TIME = eWINDOW_ADVANCE_METHOD.E_WINDOW_ADVANCE_BY_TIME;
pub const E_WINDOW_USE_AS_DATA_CACHE = eWINDOW_ADVANCE_METHOD.E_WINDOW_USE_AS_DATA_CACHE;

pub const RM_SEND_WINDOW = extern struct {
    RateKbitsPerSec: u32,
    WindowSizeInMSecs: u32,
    WindowSizeInBytes: u32,
};

pub const RM_SENDER_STATS = extern struct {
    DataBytesSent: u64,
    TotalBytesSent: u64,
    NaksReceived: u64,
    NaksReceivedTooLate: u64,
    NumOutstandingNaks: u64,
    NumNaksAfterRData: u64,
    RepairPacketsSent: u64,
    BufferSpaceAvailable: u64,
    TrailingEdgeSeqId: u64,
    LeadingEdgeSeqId: u64,
    RateKBitsPerSecOverall: u64,
    RateKBitsPerSecLast: u64,
    TotalODataPacketsSent: u64,
};

pub const RM_RECEIVER_STATS = extern struct {
    NumODataPacketsReceived: u64,
    NumRDataPacketsReceived: u64,
    NumDuplicateDataPackets: u64,
    DataBytesReceived: u64,
    TotalBytesReceived: u64,
    RateKBitsPerSecOverall: u64,
    RateKBitsPerSecLast: u64,
    TrailingEdgeSeqId: u64,
    LeadingEdgeSeqId: u64,
    AverageSequencesInWindow: u64,
    MinSequencesInWindow: u64,
    MaxSequencesInWindow: u64,
    FirstNakSequenceNumber: u64,
    NumPendingNaks: u64,
    NumOutstandingNaks: u64,
    NumDataPacketsBuffered: u64,
    TotalSelectiveNaksSent: u64,
    TotalParityNaksSent: u64,
};

pub const RM_FEC_INFO = extern struct {
    FECBlockSize: u16,
    FECProActivePackets: u16,
    FECGroupSize: u8,
    fFECOnDemandParityEnabled: u8,
};

pub const IPX_ADDRESS_DATA = extern struct {
    adapternum: i32,
    netnum: [4]u8,
    nodenum: [6]u8,
    wan: u8,
    status: u8,
    maxpkt: i32,
    linkspeed: u32,
};

pub const IPX_NETNUM_DATA = extern struct {
    netnum: [4]u8,
    hopcount: u16,
    netdelay: u16,
    cardnum: i32,
    router: [6]u8,
};

pub const IPX_SPXCONNSTATUS_DATA = extern struct {
    ConnectionState: u8,
    WatchDogActive: u8,
    LocalConnectionId: u16,
    RemoteConnectionId: u16,
    LocalSequenceNumber: u16,
    LocalAckNumber: u16,
    LocalAllocNumber: u16,
    RemoteAckNumber: u16,
    RemoteAllocNumber: u16,
    LocalSocket: u16,
    ImmediateAddress: [6]u8,
    RemoteNetwork: [4]u8,
    RemoteNode: [6]u8,
    RemoteSocket: u16,
    RetransmissionCount: u16,
    EstimatedRoundTripDelay: u16,
    RetransmittedPackets: u16,
    SuppressedPacket: u16,
};

pub const LM_IRPARMS = extern struct {
    nTXDataBytes: u32,
    nRXDataBytes: u32,
    nBaudRate: u32,
    thresholdTime: u32,
    discTime: u32,
    nMSLinkTurn: u16,
    nTXPackets: u8,
    nRXPackets: u8,
};

pub const SOCKADDR_IRDA = extern struct {
    irdaAddressFamily: u16,
    irdaDeviceID: [4]u8,
    irdaServiceName: [25]i8,
};

pub const WINDOWS_IRDA_DEVICE_INFO = extern struct {
    irdaDeviceID: [4]u8,
    irdaDeviceName: [22]i8,
    irdaDeviceHints1: u8,
    irdaDeviceHints2: u8,
    irdaCharSet: u8,
};

pub const WCE_IRDA_DEVICE_INFO = extern struct {
    irdaDeviceID: [4]u8,
    irdaDeviceName: [22]i8,
    Reserved: [2]u8,
};

pub const WINDOWS_DEVICELIST = extern struct {
    numDevice: u32,
    Device: [1]WINDOWS_IRDA_DEVICE_INFO,
};

pub const WCE_DEVICELIST = extern struct {
    numDevice: u32,
    Device: [1]WCE_IRDA_DEVICE_INFO,
};

pub const WINDOWS_IAS_SET = extern struct {
    irdaClassName: [64]i8,
    irdaAttribName: [256]i8,
    irdaAttribType: u32,
    irdaAttribute: WINDOWS_IAS_SET._irdaAttribute_e__Union,
    const _irdaAttribute_e__Union = u32; // TODO: generate this nested type!
};

pub const WINDOWS_IAS_QUERY = extern struct {
    irdaDeviceID: [4]u8,
    irdaClassName: [64]i8,
    irdaAttribName: [256]i8,
    irdaAttribType: u32,
    irdaAttribute: WINDOWS_IAS_QUERY._irdaAttribute_e__Union,
    const _irdaAttribute_e__Union = u32; // TODO: generate this nested type!
};

pub const NL_BANDWIDTH_FLAG = extern enum(i32) {
    NlbwDisabled = 0,
    NlbwEnabled = 1,
    NlbwUnchanged = -1,
};
pub const NlbwDisabled = NL_BANDWIDTH_FLAG.NlbwDisabled;
pub const NlbwEnabled = NL_BANDWIDTH_FLAG.NlbwEnabled;
pub const NlbwUnchanged = NL_BANDWIDTH_FLAG.NlbwUnchanged;

pub const NL_PATH_BANDWIDTH_ROD = extern struct {
    Bandwidth: u64,
    Instability: u64,
    BandwidthPeaked: u8,
};

pub const NL_NETWORK_CATEGORY = extern enum(i32) {
    NetworkCategoryPublic = 0,
    NetworkCategoryPrivate = 1,
    NetworkCategoryDomainAuthenticated = 2,
    NetworkCategoryUnchanged = -1,
    NetworkCategoryUnknown = -1,
};
pub const NetworkCategoryPublic = NL_NETWORK_CATEGORY.NetworkCategoryPublic;
pub const NetworkCategoryPrivate = NL_NETWORK_CATEGORY.NetworkCategoryPrivate;
pub const NetworkCategoryDomainAuthenticated = NL_NETWORK_CATEGORY.NetworkCategoryDomainAuthenticated;
pub const NetworkCategoryUnchanged = NL_NETWORK_CATEGORY.NetworkCategoryUnchanged;
pub const NetworkCategoryUnknown = NL_NETWORK_CATEGORY.NetworkCategoryUnknown;

pub const NL_INTERFACE_NETWORK_CATEGORY_STATE = extern enum(i32) {
    NlincCategoryUnknown = 0,
    NlincPublic = 1,
    NlincPrivate = 2,
    NlincDomainAuthenticated = 3,
    NlincCategoryStateMax = 4,
};
pub const NlincCategoryUnknown = NL_INTERFACE_NETWORK_CATEGORY_STATE.NlincCategoryUnknown;
pub const NlincPublic = NL_INTERFACE_NETWORK_CATEGORY_STATE.NlincPublic;
pub const NlincPrivate = NL_INTERFACE_NETWORK_CATEGORY_STATE.NlincPrivate;
pub const NlincDomainAuthenticated = NL_INTERFACE_NETWORK_CATEGORY_STATE.NlincDomainAuthenticated;
pub const NlincCategoryStateMax = NL_INTERFACE_NETWORK_CATEGORY_STATE.NlincCategoryStateMax;

pub const TCPSTATE = extern enum(i32) {
    CLOSED = 0,
    LISTEN = 1,
    SYN_SENT = 2,
    SYN_RCVD = 3,
    ESTABLISHED = 4,
    FIN_WAIT_1 = 5,
    FIN_WAIT_2 = 6,
    CLOSE_WAIT = 7,
    CLOSING = 8,
    LAST_ACK = 9,
    TIME_WAIT = 10,
    MAX = 11,
};
pub const TCPSTATE_CLOSED = TCPSTATE.CLOSED;
pub const TCPSTATE_LISTEN = TCPSTATE.LISTEN;
pub const TCPSTATE_SYN_SENT = TCPSTATE.SYN_SENT;
pub const TCPSTATE_SYN_RCVD = TCPSTATE.SYN_RCVD;
pub const TCPSTATE_ESTABLISHED = TCPSTATE.ESTABLISHED;
pub const TCPSTATE_FIN_WAIT_1 = TCPSTATE.FIN_WAIT_1;
pub const TCPSTATE_FIN_WAIT_2 = TCPSTATE.FIN_WAIT_2;
pub const TCPSTATE_CLOSE_WAIT = TCPSTATE.CLOSE_WAIT;
pub const TCPSTATE_CLOSING = TCPSTATE.CLOSING;
pub const TCPSTATE_LAST_ACK = TCPSTATE.LAST_ACK;
pub const TCPSTATE_TIME_WAIT = TCPSTATE.TIME_WAIT;
pub const TCPSTATE_MAX = TCPSTATE.MAX;

pub const TRANSPORT_SETTING_ID = extern struct {
    Guid: Guid,
};

pub const tcp_keepalive = extern struct {
    onoff: u32,
    keepalivetime: u32,
    keepaliveinterval: u32,
};

pub const CONTROL_CHANNEL_TRIGGER_STATUS = extern enum(i32) {
    INVALID = 0,
    SOFTWARE_SLOT_ALLOCATED = 1,
    HARDWARE_SLOT_ALLOCATED = 2,
    POLICY_ERROR = 3,
    SYSTEM_ERROR = 4,
    TRANSPORT_DISCONNECTED = 5,
    SERVICE_UNAVAILABLE = 6,
};
pub const CONTROL_CHANNEL_TRIGGER_STATUS_INVALID = CONTROL_CHANNEL_TRIGGER_STATUS.INVALID;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SOFTWARE_SLOT_ALLOCATED = CONTROL_CHANNEL_TRIGGER_STATUS.SOFTWARE_SLOT_ALLOCATED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_HARDWARE_SLOT_ALLOCATED = CONTROL_CHANNEL_TRIGGER_STATUS.HARDWARE_SLOT_ALLOCATED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_POLICY_ERROR = CONTROL_CHANNEL_TRIGGER_STATUS.POLICY_ERROR;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SYSTEM_ERROR = CONTROL_CHANNEL_TRIGGER_STATUS.SYSTEM_ERROR;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_TRANSPORT_DISCONNECTED = CONTROL_CHANNEL_TRIGGER_STATUS.TRANSPORT_DISCONNECTED;
pub const CONTROL_CHANNEL_TRIGGER_STATUS_SERVICE_UNAVAILABLE = CONTROL_CHANNEL_TRIGGER_STATUS.SERVICE_UNAVAILABLE;

pub const REAL_TIME_NOTIFICATION_SETTING_INPUT = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    BrokerEventGuid: Guid,
};

pub const REAL_TIME_NOTIFICATION_SETTING_INPUT_EX = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    BrokerEventGuid: Guid,
    Unmark: u8,
};

pub const REAL_TIME_NOTIFICATION_SETTING_OUTPUT = extern struct {
    ChannelStatus: CONTROL_CHANNEL_TRIGGER_STATUS,
};

pub const ASSOCIATE_NAMERES_CONTEXT_INPUT = extern struct {
    TransportSettingId: TRANSPORT_SETTING_ID,
    Handle: u64,
};

pub const RCVALL_VALUE = extern enum(i32) {
    RCVALL_OFF = 0,
    RCVALL_ON = 1,
    RCVALL_SOCKETLEVELONLY = 2,
    RCVALL_IPLEVEL = 3,
};
pub const RCVALL_OFF = RCVALL_VALUE.RCVALL_OFF;
pub const RCVALL_ON = RCVALL_VALUE.RCVALL_ON;
pub const RCVALL_SOCKETLEVELONLY = RCVALL_VALUE.RCVALL_SOCKETLEVELONLY;
pub const RCVALL_IPLEVEL = RCVALL_VALUE.RCVALL_IPLEVEL;

pub const RCVALL_IF = extern struct {
    Mode: RCVALL_VALUE,
    Interface: u32,
};

pub const TCP_INITIAL_RTO_PARAMETERS = extern struct {
    Rtt: u16,
    MaxSynRetransmissions: u8,
};

pub const TCP_ICW_LEVEL = extern enum(i32) {
    DEFAULT = 0,
    HIGH = 1,
    VERY_HIGH = 2,
    AGGRESSIVE = 3,
    EXPERIMENTAL = 4,
    COMPAT = 254,
    MAX = 255,
};
pub const TCP_ICW_LEVEL_DEFAULT = TCP_ICW_LEVEL.DEFAULT;
pub const TCP_ICW_LEVEL_HIGH = TCP_ICW_LEVEL.HIGH;
pub const TCP_ICW_LEVEL_VERY_HIGH = TCP_ICW_LEVEL.VERY_HIGH;
pub const TCP_ICW_LEVEL_AGGRESSIVE = TCP_ICW_LEVEL.AGGRESSIVE;
pub const TCP_ICW_LEVEL_EXPERIMENTAL = TCP_ICW_LEVEL.EXPERIMENTAL;
pub const TCP_ICW_LEVEL_COMPAT = TCP_ICW_LEVEL.COMPAT;
pub const TCP_ICW_LEVEL_MAX = TCP_ICW_LEVEL.MAX;

pub const TCP_ICW_PARAMETERS = extern struct {
    Level: TCP_ICW_LEVEL,
};

pub const TCP_ACK_FREQUENCY_PARAMETERS = extern struct {
    TcpDelayedAckFrequency: u8,
};

pub const TCP_INFO_v0 = extern struct {
    State: TCPSTATE,
    Mss: u32,
    ConnectionTimeMs: u64,
    TimestampsEnabled: u8,
    RttUs: u32,
    MinRttUs: u32,
    BytesInFlight: u32,
    Cwnd: u32,
    SndWnd: u32,
    RcvWnd: u32,
    RcvBuf: u32,
    BytesOut: u64,
    BytesIn: u64,
    BytesReordered: u32,
    BytesRetrans: u32,
    FastRetrans: u32,
    DupAcksIn: u32,
    TimeoutEpisodes: u32,
    SynRetrans: u8,
};

pub const TCP_INFO_v1 = extern struct {
    State: TCPSTATE,
    Mss: u32,
    ConnectionTimeMs: u64,
    TimestampsEnabled: u8,
    RttUs: u32,
    MinRttUs: u32,
    BytesInFlight: u32,
    Cwnd: u32,
    SndWnd: u32,
    RcvWnd: u32,
    RcvBuf: u32,
    BytesOut: u64,
    BytesIn: u64,
    BytesReordered: u32,
    BytesRetrans: u32,
    FastRetrans: u32,
    DupAcksIn: u32,
    TimeoutEpisodes: u32,
    SynRetrans: u8,
    SndLimTransRwin: u32,
    SndLimTimeRwin: u32,
    SndLimBytesRwin: u64,
    SndLimTransCwnd: u32,
    SndLimTimeCwnd: u32,
    SndLimBytesCwnd: u64,
    SndLimTransSnd: u32,
    SndLimTimeSnd: u32,
    SndLimBytesSnd: u64,
};

pub const INET_PORT_RANGE = extern struct {
    StartPort: u16,
    NumberOfPorts: u16,
};

pub const INET_PORT_RESERVATION_TOKEN = extern struct {
    Token: u64,
};

pub const INET_PORT_RESERVATION_INSTANCE = extern struct {
    Reservation: INET_PORT_RANGE,
    Token: INET_PORT_RESERVATION_TOKEN,
};

pub const INET_PORT_RESERVATION_INFORMATION = extern struct {
    OwningPid: u32,
};

pub const SOCKET_USAGE_TYPE = extern enum(i32) {
    SYSTEM_CRITICAL_SOCKET = 1,
};
pub const SYSTEM_CRITICAL_SOCKET = SOCKET_USAGE_TYPE.SYSTEM_CRITICAL_SOCKET;

pub const SOCKET_SECURITY_PROTOCOL = extern enum(i32) {
    DEFAULT = 0,
    IPSEC = 1,
    IPSEC2 = 2,
    INVALID = 3,
};
pub const SOCKET_SECURITY_PROTOCOL_DEFAULT = SOCKET_SECURITY_PROTOCOL.DEFAULT;
pub const SOCKET_SECURITY_PROTOCOL_IPSEC = SOCKET_SECURITY_PROTOCOL.IPSEC;
pub const SOCKET_SECURITY_PROTOCOL_IPSEC2 = SOCKET_SECURITY_PROTOCOL.IPSEC2;
pub const SOCKET_SECURITY_PROTOCOL_INVALID = SOCKET_SECURITY_PROTOCOL.INVALID;

pub const SOCKET_SECURITY_SETTINGS = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    SecurityFlags: u32,
};

pub const SOCKET_SECURITY_SETTINGS_IPSEC = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    SecurityFlags: u32,
    IpsecFlags: u32,
    AuthipMMPolicyKey: Guid,
    AuthipQMPolicyKey: Guid,
    Reserved: Guid,
    Reserved2: u64,
    UserNameStringLen: u32,
    DomainNameStringLen: u32,
    PasswordStringLen: u32,
    AllStrings: [1]u16,
};

pub const SOCKET_PEER_TARGET_NAME = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE_LH,
    PeerTargetNameStringLen: u32,
    AllStrings: [1]u16,
};

pub const SOCKET_SECURITY_QUERY_TEMPLATE = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE_LH,
    PeerTokenAccessMask: u32,
};

pub const SOCKET_SECURITY_QUERY_TEMPLATE_IPSEC2 = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    PeerAddress: SOCKADDR_STORAGE_LH,
    PeerTokenAccessMask: u32,
    Flags: u32,
    FieldMask: u32,
};

pub const SOCKET_SECURITY_QUERY_INFO = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    Flags: u32,
    PeerApplicationAccessTokenHandle: u64,
    PeerMachineAccessTokenHandle: u64,
};

pub const SOCKET_SECURITY_QUERY_INFO_IPSEC2 = extern struct {
    SecurityProtocol: SOCKET_SECURITY_PROTOCOL,
    Flags: u32,
    PeerApplicationAccessTokenHandle: u64,
    PeerMachineAccessTokenHandle: u64,
    MmSaId: u64,
    QmSaId: u64,
    NegotiationWinerr: u32,
    SaLookupContext: Guid,
};

pub const RSS_SCALABILITY_INFO = extern struct {
    RssEnabled: u8,
};

pub const WSA_COMPATIBILITY_BEHAVIOR_ID = extern enum(i32) {
    WsaBehaviorAll = 0,
    WsaBehaviorReceiveBuffering = 1,
    WsaBehaviorAutoTuning = 2,
};
pub const WsaBehaviorAll = WSA_COMPATIBILITY_BEHAVIOR_ID.WsaBehaviorAll;
pub const WsaBehaviorReceiveBuffering = WSA_COMPATIBILITY_BEHAVIOR_ID.WsaBehaviorReceiveBuffering;
pub const WsaBehaviorAutoTuning = WSA_COMPATIBILITY_BEHAVIOR_ID.WsaBehaviorAutoTuning;

pub const WSA_COMPATIBILITY_MODE = extern struct {
    BehaviorId: WSA_COMPATIBILITY_BEHAVIOR_ID,
    TargetOsVersion: u32,
};

pub const RIO_BUFFERID_t = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const RIO_CQ_t = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const RIO_RQ_t = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const RIORESULT = extern struct {
    Status: i32,
    BytesTransferred: u32,
    SocketContext: u64,
    RequestContext: u64,
};

pub const RIO_BUF = extern struct {
    BufferId: *RIO_BUFFERID_t,
    Offset: u32,
    Length: u32,
};

pub const RIO_CMSG_BUFFER = extern struct {
    TotalLength: u32,
};

pub const ATM_ADDRESS = extern struct {
    AddressType: u32,
    NumofDigits: u32,
    Addr: [20]u8,
};

pub const ATM_BLLI = extern struct {
    Layer2Protocol: u32,
    Layer2UserSpecifiedProtocol: u32,
    Layer3Protocol: u32,
    Layer3UserSpecifiedProtocol: u32,
    Layer3IPI: u32,
    SnapID: [5]u8,
};

pub const ATM_BHLI = extern struct {
    HighLayerInfoType: u32,
    HighLayerInfoLength: u32,
    HighLayerInfo: [8]u8,
};

pub const sockaddr_atm = extern struct {
    satm_family: u16,
    satm_number: ATM_ADDRESS,
    satm_blli: ATM_BLLI,
    satm_bhli: ATM_BHLI,
};

pub const Q2931_IE_TYPE = extern enum(i32) {
    IE_AALParameters = 0,
    IE_TrafficDescriptor = 1,
    IE_BroadbandBearerCapability = 2,
    IE_BHLI = 3,
    IE_BLLI = 4,
    IE_CalledPartyNumber = 5,
    IE_CalledPartySubaddress = 6,
    IE_CallingPartyNumber = 7,
    IE_CallingPartySubaddress = 8,
    IE_Cause = 9,
    IE_QOSClass = 10,
    IE_TransitNetworkSelection = 11,
};
pub const IE_AALParameters = Q2931_IE_TYPE.IE_AALParameters;
pub const IE_TrafficDescriptor = Q2931_IE_TYPE.IE_TrafficDescriptor;
pub const IE_BroadbandBearerCapability = Q2931_IE_TYPE.IE_BroadbandBearerCapability;
pub const IE_BHLI = Q2931_IE_TYPE.IE_BHLI;
pub const IE_BLLI = Q2931_IE_TYPE.IE_BLLI;
pub const IE_CalledPartyNumber = Q2931_IE_TYPE.IE_CalledPartyNumber;
pub const IE_CalledPartySubaddress = Q2931_IE_TYPE.IE_CalledPartySubaddress;
pub const IE_CallingPartyNumber = Q2931_IE_TYPE.IE_CallingPartyNumber;
pub const IE_CallingPartySubaddress = Q2931_IE_TYPE.IE_CallingPartySubaddress;
pub const IE_Cause = Q2931_IE_TYPE.IE_Cause;
pub const IE_QOSClass = Q2931_IE_TYPE.IE_QOSClass;
pub const IE_TransitNetworkSelection = Q2931_IE_TYPE.IE_TransitNetworkSelection;

pub const Q2931_IE = extern struct {
    IEType: Q2931_IE_TYPE,
    IELength: u32,
    IE: [1]u8,
};

pub const AAL_TYPE = extern enum(i32) {
    AALTYPE_5 = 5,
    AALTYPE_USER = 16,
};
pub const AALTYPE_5 = AAL_TYPE.AALTYPE_5;
pub const AALTYPE_USER = AAL_TYPE.AALTYPE_USER;

pub const AAL5_PARAMETERS = extern struct {
    ForwardMaxCPCSSDUSize: u32,
    BackwardMaxCPCSSDUSize: u32,
    Mode: u8,
    SSCSType: u8,
};

pub const AALUSER_PARAMETERS = extern struct {
    UserDefined: u32,
};

pub const AAL_PARAMETERS_IE = extern struct {
    AALType: AAL_TYPE,
    AALSpecificParameters: AAL_PARAMETERS_IE._AALSpecificParameters_e__Union,
    const _AALSpecificParameters_e__Union = u32; // TODO: generate this nested type!
};

pub const ATM_TD = extern struct {
    PeakCellRate_CLP0: u32,
    PeakCellRate_CLP01: u32,
    SustainableCellRate_CLP0: u32,
    SustainableCellRate_CLP01: u32,
    MaxBurstSize_CLP0: u32,
    MaxBurstSize_CLP01: u32,
    Tagging: BOOL,
};

pub const ATM_TRAFFIC_DESCRIPTOR_IE = extern struct {
    Forward: ATM_TD,
    Backward: ATM_TD,
    BestEffort: BOOL,
};

pub const ATM_BROADBAND_BEARER_CAPABILITY_IE = extern struct {
    BearerClass: u8,
    TrafficType: u8,
    TimingRequirements: u8,
    ClippingSusceptability: u8,
    UserPlaneConnectionConfig: u8,
};

pub const ATM_BLLI_IE = extern struct {
    Layer2Protocol: u32,
    Layer2Mode: u8,
    Layer2WindowSize: u8,
    Layer2UserSpecifiedProtocol: u32,
    Layer3Protocol: u32,
    Layer3Mode: u8,
    Layer3DefaultPacketSize: u8,
    Layer3PacketWindowSize: u8,
    Layer3UserSpecifiedProtocol: u32,
    Layer3IPI: u32,
    SnapID: [5]u8,
};

pub const ATM_CALLING_PARTY_NUMBER_IE = extern struct {
    ATM_Number: ATM_ADDRESS,
    Presentation_Indication: u8,
    Screening_Indicator: u8,
};

pub const ATM_CAUSE_IE = extern struct {
    Location: u8,
    Cause: u8,
    DiagnosticsLength: u8,
    Diagnostics: [4]u8,
};

pub const ATM_QOS_CLASS_IE = extern struct {
    QOSClassForward: u8,
    QOSClassBackward: u8,
};

pub const ATM_TRANSIT_NETWORK_SELECTION_IE = extern struct {
    TypeOfNetworkId: u8,
    NetworkIdPlan: u8,
    NetworkIdLength: u8,
    NetworkId: [1]u8,
};

pub const ATM_CONNECTION_ID = extern struct {
    DeviceNumber: u32,
    VPI: u32,
    VCI: u32,
};

pub const ATM_PVC_PARAMS = extern struct {
    PvcConnectionId: ATM_CONNECTION_ID,
    PvcQos: QOS,
};

pub const NAPI_PROVIDER_TYPE = extern enum(i32) {
    ProviderType_Application = 1,
    ProviderType_Service = 2,
};
pub const ProviderType_Application = NAPI_PROVIDER_TYPE.ProviderType_Application;
pub const ProviderType_Service = NAPI_PROVIDER_TYPE.ProviderType_Service;

pub const NAPI_PROVIDER_LEVEL = extern enum(i32) {
    ProviderLevel_None = 0,
    ProviderLevel_Secondary = 1,
    ProviderLevel_Primary = 2,
};
pub const ProviderLevel_None = NAPI_PROVIDER_LEVEL.ProviderLevel_None;
pub const ProviderLevel_Secondary = NAPI_PROVIDER_LEVEL.ProviderLevel_Secondary;
pub const ProviderLevel_Primary = NAPI_PROVIDER_LEVEL.ProviderLevel_Primary;

pub const NAPI_DOMAIN_DESCRIPTION_BLOB = extern struct {
    AuthLevel: u32,
    cchDomainName: u32,
    OffsetNextDomainDescription: u32,
    OffsetThisDomainName: u32,
};

pub const NAPI_PROVIDER_INSTALLATION_BLOB = extern struct {
    dwVersion: u32,
    dwProviderType: u32,
    fSupportsWildCard: u32,
    cDomains: u32,
    OffsetFirstDomain: u32,
};

pub const TRANSMIT_FILE_BUFFERS = extern struct {
    Head: *c_void,
    HeadLength: u32,
    Tail: *c_void,
    TailLength: u32,
};

pub const LPFN_TRANSMITFILE = fn(
    hSocket: ?*c_void,
    hFile: HANDLE,
    nNumberOfBytesToWrite: u32,
    nNumberOfBytesPerSend: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpTransmitBuffers: ?*TRANSMIT_FILE_BUFFERS,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_ACCEPTEX = fn(
    sListenSocket: ?*c_void,
    sAcceptSocket: ?*c_void,
    lpOutputBuffer: *c_void,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    lpdwBytesReceived: *u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_GETACCEPTEXSOCKADDRS = fn(
    lpOutputBuffer: *c_void,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    LocalSockaddr: **SOCKADDR,
    LocalSockaddrLength: *i32,
    RemoteSockaddr: **SOCKADDR,
    RemoteSockaddrLength: *i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TRANSMIT_PACKETS_ELEMENT = extern struct {
    dwElFlags: u32,
    cLength: u32,
    Anonymous: TRANSMIT_PACKETS_ELEMENT._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const LPFN_TRANSMITPACKETS = fn(
    hSocket: ?*c_void,
    lpPacketArray: ?*TRANSMIT_PACKETS_ELEMENT,
    nElementCount: u32,
    nSendSize: u32,
    lpOverlapped: ?*OVERLAPPED,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_CONNECTEX = fn(
    s: ?*c_void,
    name: [*]const SOCKADDR,
    namelen: i32,
    lpSendBuffer: ?[*]u8,
    dwSendDataLength: u32,
    lpdwBytesSent: *u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_DISCONNECTEX = fn(
    s: ?*c_void,
    lpOverlapped: ?*OVERLAPPED,
    dwFlags: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const NLA_BLOB_DATA_TYPE = extern enum(i32) {
    NLA_RAW_DATA = 0,
    NLA_INTERFACE = 1,
    NLA_802_1X_LOCATION = 2,
    NLA_CONNECTIVITY = 3,
    NLA_ICS = 4,
};
pub const NLA_RAW_DATA = NLA_BLOB_DATA_TYPE.NLA_RAW_DATA;
pub const NLA_INTERFACE = NLA_BLOB_DATA_TYPE.NLA_INTERFACE;
pub const NLA_802_1X_LOCATION = NLA_BLOB_DATA_TYPE.NLA_802_1X_LOCATION;
pub const NLA_CONNECTIVITY = NLA_BLOB_DATA_TYPE.NLA_CONNECTIVITY;
pub const NLA_ICS = NLA_BLOB_DATA_TYPE.NLA_ICS;

pub const NLA_CONNECTIVITY_TYPE = extern enum(i32) {
    NLA_NETWORK_AD_HOC = 0,
    NLA_NETWORK_MANAGED = 1,
    NLA_NETWORK_UNMANAGED = 2,
    NLA_NETWORK_UNKNOWN = 3,
};
pub const NLA_NETWORK_AD_HOC = NLA_CONNECTIVITY_TYPE.NLA_NETWORK_AD_HOC;
pub const NLA_NETWORK_MANAGED = NLA_CONNECTIVITY_TYPE.NLA_NETWORK_MANAGED;
pub const NLA_NETWORK_UNMANAGED = NLA_CONNECTIVITY_TYPE.NLA_NETWORK_UNMANAGED;
pub const NLA_NETWORK_UNKNOWN = NLA_CONNECTIVITY_TYPE.NLA_NETWORK_UNKNOWN;

pub const NLA_INTERNET = extern enum(i32) {
    UNKNOWN = 0,
    NO = 1,
    YES = 2,
};
pub const NLA_INTERNET_UNKNOWN = NLA_INTERNET.UNKNOWN;
pub const NLA_INTERNET_NO = NLA_INTERNET.NO;
pub const NLA_INTERNET_YES = NLA_INTERNET.YES;

pub const NLA_BLOB = extern struct {
    header: NLA_BLOB._header_e__Struct,
    data: NLA_BLOB._data_e__Union,
    const _data_e__Union = u32; // TODO: generate this nested type!
    const _header_e__Struct = u32; // TODO: generate this nested type!
};

pub const LPFN_WSARECVMSG = fn(
    s: ?*c_void,
    lpMsg: *WSAMSG,
    lpdwNumberOfBytesRecvd: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSAPOLLDATA = extern struct {
    result: i32,
    fds: u32,
    timeout: i32,
    fdArray: [1]WSAPOLLFD,
};

pub const WSASENDMSG = extern struct {
    lpMsg: *WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: *u32,
    lpOverlapped: *OVERLAPPED,
    lpCompletionRoutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE,
};

pub const LPFN_WSASENDMSG = fn(
    s: ?*c_void,
    lpMsg: *WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_WSAPOLL = fn(
    fdarray: *WSAPOLLFD,
    nfds: u32,
    timeout: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_RIORECEIVE = fn(
    SocketQueue: *RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    Flags: u32,
    RequestContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIORECEIVEEX = fn(
    SocketQueue: *RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    pLocalAddress: ?*RIO_BUF,
    pRemoteAddress: ?*RIO_BUF,
    pControlContext: ?*RIO_BUF,
    pFlags: ?*RIO_BUF,
    Flags: u32,
    RequestContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_RIOSEND = fn(
    SocketQueue: *RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    Flags: u32,
    RequestContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIOSENDEX = fn(
    SocketQueue: *RIO_RQ_t,
    pData: [*]RIO_BUF,
    DataBufferCount: u32,
    pLocalAddress: ?*RIO_BUF,
    pRemoteAddress: ?*RIO_BUF,
    pControlContext: ?*RIO_BUF,
    pFlags: ?*RIO_BUF,
    Flags: u32,
    RequestContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIOCLOSECOMPLETIONQUEUE = fn(
    CQ: *RIO_CQ_t,
) callconv(@import("std").os.windows.WINAPI) void;

pub const RIO_NOTIFICATION_COMPLETION_TYPE = extern enum(i32) {
    RIO_EVENT_COMPLETION = 1,
    RIO_IOCP_COMPLETION = 2,
};
pub const RIO_EVENT_COMPLETION = RIO_NOTIFICATION_COMPLETION_TYPE.RIO_EVENT_COMPLETION;
pub const RIO_IOCP_COMPLETION = RIO_NOTIFICATION_COMPLETION_TYPE.RIO_IOCP_COMPLETION;

pub const RIO_NOTIFICATION_COMPLETION = extern struct {
    Type: RIO_NOTIFICATION_COMPLETION_TYPE,
    Anonymous: RIO_NOTIFICATION_COMPLETION._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const LPFN_RIOCREATECOMPLETIONQUEUE = fn(
    QueueSize: u32,
    NotificationCompletion: ?*RIO_NOTIFICATION_COMPLETION,
) callconv(@import("std").os.windows.WINAPI) *RIO_CQ_t;

pub const LPFN_RIOCREATEREQUESTQUEUE = fn(
    Socket: ?*c_void,
    MaxOutstandingReceive: u32,
    MaxReceiveDataBuffers: u32,
    MaxOutstandingSend: u32,
    MaxSendDataBuffers: u32,
    ReceiveCQ: *RIO_CQ_t,
    SendCQ: *RIO_CQ_t,
    SocketContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) *RIO_RQ_t;

pub const LPFN_RIODEQUEUECOMPLETION = fn(
    CQ: *RIO_CQ_t,
    Array: [*]RIORESULT,
    ArraySize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPFN_RIODEREGISTERBUFFER = fn(
    BufferId: *RIO_BUFFERID_t,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPFN_RIONOTIFY = fn(
    CQ: *RIO_CQ_t,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPFN_RIOREGISTERBUFFER = fn(
    DataBuffer: [*]u8,
    DataLength: u32,
) callconv(@import("std").os.windows.WINAPI) *RIO_BUFFERID_t;

pub const LPFN_RIORESIZECOMPLETIONQUEUE = fn(
    CQ: *RIO_CQ_t,
    QueueSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFN_RIORESIZEREQUESTQUEUE = fn(
    RQ: *RIO_RQ_t,
    MaxOutstandingReceive: u32,
    MaxOutstandingSend: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const RIO_EXTENSION_FUNCTION_TABLE = extern struct {
    cbSize: u32,
    RIOReceive: LPFN_RIORECEIVE,
    RIOReceiveEx: LPFN_RIORECEIVEEX,
    RIOSend: LPFN_RIOSEND,
    RIOSendEx: LPFN_RIOSENDEX,
    RIOCloseCompletionQueue: LPFN_RIOCLOSECOMPLETIONQUEUE,
    RIOCreateCompletionQueue: LPFN_RIOCREATECOMPLETIONQUEUE,
    RIOCreateRequestQueue: LPFN_RIOCREATEREQUESTQUEUE,
    RIODequeueCompletion: LPFN_RIODEQUEUECOMPLETION,
    RIODeregisterBuffer: LPFN_RIODEREGISTERBUFFER,
    RIONotify: LPFN_RIONOTIFY,
    RIORegisterBuffer: LPFN_RIOREGISTERBUFFER,
    RIOResizeCompletionQueue: LPFN_RIORESIZECOMPLETIONQUEUE,
    RIOResizeRequestQueue: LPFN_RIORESIZEREQUESTQUEUE,
};

pub const WSPData = extern struct {
    wVersion: u16,
    wHighVersion: u16,
    szDescription: [256]u16,
};

pub const WSATHREADID = extern struct {
    ThreadHandle: HANDLE,
    Reserved: ?*c_void,
};

pub const LPBLOCKINGCALLBACK = fn(
    dwContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWSAUSERAPC = fn(
    dwContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPWSPACCEPT = fn(
    s: ?*c_void,
    addr: ?[*]SOCKADDR,
    addrlen: ?*i32,
    lpfnCondition: ?LPCONDITIONPROC,
    dwCallbackData: ?*c_void,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const LPWSPADDRESSTOSTRING = fn(
    lpsaAddress: [*]SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpszAddressString: [*:0]u16,
    lpdwAddressStringLength: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPASYNCSELECT = fn(
    s: ?*c_void,
    hWnd: HWND,
    wMsg: u32,
    lEvent: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPBIND = fn(
    s: ?*c_void,
    name: [*]const SOCKADDR,
    namelen: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCANCELBLOCKINGCALL = fn(
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCLEANUP = fn(
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCLOSESOCKET = fn(
    s: ?*c_void,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPCONNECT = fn(
    s: ?*c_void,
    name: [*]const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPDUPLICATESOCKET = fn(
    s: ?*c_void,
    dwProcessId: u32,
    lpProtocolInfo: *WSAPROTOCOL_INFOW,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPENUMNETWORKEVENTS = fn(
    s: ?*c_void,
    hEventObject: HANDLE,
    lpNetworkEvents: *WSANETWORKEVENTS,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPEVENTSELECT = fn(
    s: ?*c_void,
    hEventObject: HANDLE,
    lNetworkEvents: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETOVERLAPPEDRESULT = fn(
    s: ?*c_void,
    lpOverlapped: *OVERLAPPED,
    lpcbTransfer: *u32,
    fWait: BOOL,
    lpdwFlags: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWSPGETPEERNAME = fn(
    s: ?*c_void,
    name: [*]SOCKADDR,
    namelen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETSOCKNAME = fn(
    s: ?*c_void,
    name: [*]SOCKADDR,
    namelen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETSOCKOPT = fn(
    s: ?*c_void,
    level: i32,
    optname: i32,
    optval: [*]i8,
    optlen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPGETQOSBYNAME = fn(
    s: ?*c_void,
    lpQOSName: *WSABUF,
    lpQOS: *QOS,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWSPIOCTL = fn(
    s: ?*c_void,
    dwIoControlCode: u32,
    lpvInBuffer: ?[*]u8,
    cbInBuffer: u32,
    lpvOutBuffer: ?[*]u8,
    cbOutBuffer: u32,
    lpcbBytesReturned: *u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPJOINLEAF = fn(
    s: ?*c_void,
    name: [*]const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    dwFlags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const LPWSPLISTEN = fn(
    s: ?*c_void,
    backlog: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPRECV = fn(
    s: ?*c_void,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: *u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPRECVDISCONNECT = fn(
    s: ?*c_void,
    lpInboundDisconnectData: ?*WSABUF,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPRECVFROM = fn(
    s: ?*c_void,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: *u32,
    lpFrom: ?[*]SOCKADDR,
    lpFromlen: ?*i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSELECT = fn(
    nfds: i32,
    readfds: ?*fd_set,
    writefds: ?*fd_set,
    exceptfds: ?*fd_set,
    timeout: ?*const timeval,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSEND = fn(
    s: ?*c_void,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSENDDISCONNECT = fn(
    s: ?*c_void,
    lpOutboundDisconnectData: ?*WSABUF,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSENDTO = fn(
    s: ?*c_void,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    lpTo: ?[*]const SOCKADDR,
    iTolen: i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
    lpThreadId: ?*WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSETSOCKOPT = fn(
    s: ?*c_void,
    level: i32,
    optname: i32,
    optval: ?[*]const i8,
    optlen: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSHUTDOWN = fn(
    s: ?*c_void,
    how: i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSPSOCKET = fn(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    g: u32,
    dwFlags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const LPWSPSTRINGTOADDRESS = fn(
    AddressString: PWSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpAddress: [*]SOCKADDR,
    lpAddressLength: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSPPROC_TABLE = extern struct {
    lpWSPAccept: LPWSPACCEPT,
    lpWSPAddressToString: LPWSPADDRESSTOSTRING,
    lpWSPAsyncSelect: LPWSPASYNCSELECT,
    lpWSPBind: LPWSPBIND,
    lpWSPCancelBlockingCall: LPWSPCANCELBLOCKINGCALL,
    lpWSPCleanup: LPWSPCLEANUP,
    lpWSPCloseSocket: LPWSPCLOSESOCKET,
    lpWSPConnect: LPWSPCONNECT,
    lpWSPDuplicateSocket: LPWSPDUPLICATESOCKET,
    lpWSPEnumNetworkEvents: LPWSPENUMNETWORKEVENTS,
    lpWSPEventSelect: LPWSPEVENTSELECT,
    lpWSPGetOverlappedResult: LPWSPGETOVERLAPPEDRESULT,
    lpWSPGetPeerName: LPWSPGETPEERNAME,
    lpWSPGetSockName: LPWSPGETSOCKNAME,
    lpWSPGetSockOpt: LPWSPGETSOCKOPT,
    lpWSPGetQOSByName: LPWSPGETQOSBYNAME,
    lpWSPIoctl: LPWSPIOCTL,
    lpWSPJoinLeaf: LPWSPJOINLEAF,
    lpWSPListen: LPWSPLISTEN,
    lpWSPRecv: LPWSPRECV,
    lpWSPRecvDisconnect: LPWSPRECVDISCONNECT,
    lpWSPRecvFrom: LPWSPRECVFROM,
    lpWSPSelect: LPWSPSELECT,
    lpWSPSend: LPWSPSEND,
    lpWSPSendDisconnect: LPWSPSENDDISCONNECT,
    lpWSPSendTo: LPWSPSENDTO,
    lpWSPSetSockOpt: LPWSPSETSOCKOPT,
    lpWSPShutdown: LPWSPSHUTDOWN,
    lpWSPSocket: LPWSPSOCKET,
    lpWSPStringToAddress: LPWSPSTRINGTOADDRESS,
};

pub const LPWPUCLOSEEVENT = fn(
    hEvent: HANDLE,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUCLOSESOCKETHANDLE = fn(
    s: ?*c_void,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUCREATEEVENT = fn(
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const LPWPUCREATESOCKETHANDLE = fn(
    dwCatalogEntryId: u32,
    dwContext: ?*c_void,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const LPWPUFDISSET = fn(
    s: ?*c_void,
    fdset: *fd_set,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUGETPROVIDERPATH = fn(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUMODIFYIFSHANDLE = fn(
    dwCatalogEntryId: u32,
    ProposedHandle: ?*c_void,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const LPWPUPOSTMESSAGE = fn(
    hWnd: HWND,
    Msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUQUERYBLOCKINGCALLBACK = fn(
    dwCatalogEntryId: u32,
    lplpfnCallback: *LPBLOCKINGCALLBACK,
    lpdwContext: *?*c_void,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUQUERYSOCKETHANDLECONTEXT = fn(
    s: ?*c_void,
    lpContext: *?*c_void,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUQUEUEAPC = fn(
    lpThreadId: *WSATHREADID,
    lpfnUserApc: LPWSAUSERAPC,
    dwContext: ?*c_void,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPURESETEVENT = fn(
    hEvent: HANDLE,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUSETEVENT = fn(
    hEvent: HANDLE,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPWPUOPENCURRENTTHREAD = fn(
    lpThreadId: *WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUCLOSETHREAD = fn(
    lpThreadId: *WSATHREADID,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWPUCOMPLETEOVERLAPPEDREQUEST = fn(
    s: ?*c_void,
    lpOverlapped: *OVERLAPPED,
    dwError: u32,
    cbTransferred: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSPUPCALLTABLE = extern struct {
    lpWPUCloseEvent: LPWPUCLOSEEVENT,
    lpWPUCloseSocketHandle: LPWPUCLOSESOCKETHANDLE,
    lpWPUCreateEvent: LPWPUCREATEEVENT,
    lpWPUCreateSocketHandle: LPWPUCREATESOCKETHANDLE,
    lpWPUFDIsSet: LPWPUFDISSET,
    lpWPUGetProviderPath: LPWPUGETPROVIDERPATH,
    lpWPUModifyIFSHandle: LPWPUMODIFYIFSHANDLE,
    lpWPUPostMessage: LPWPUPOSTMESSAGE,
    lpWPUQueryBlockingCallback: LPWPUQUERYBLOCKINGCALLBACK,
    lpWPUQuerySocketHandleContext: LPWPUQUERYSOCKETHANDLECONTEXT,
    lpWPUQueueApc: LPWPUQUEUEAPC,
    lpWPUResetEvent: LPWPURESETEVENT,
    lpWPUSetEvent: LPWPUSETEVENT,
    lpWPUOpenCurrentThread: LPWPUOPENCURRENTTHREAD,
    lpWPUCloseThread: LPWPUCLOSETHREAD,
};

pub const LPWSPSTARTUP = fn(
    wVersionRequested: u16,
    lpWSPData: *WSPData,
    lpProtocolInfo: *WSAPROTOCOL_INFOW,
    UpcallTable: WSPUPCALLTABLE,
    lpProcTable: *WSPPROC_TABLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCENUMPROTOCOLS = fn(
    lpiProtocols: ?*i32,
    lpProtocolBuffer: ?[*]WSAPROTOCOL_INFOW,
    lpdwBufferLength: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCDEINSTALLPROVIDER = fn(
    lpProviderId: *Guid,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCINSTALLPROVIDER = fn(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCGETPROVIDERPATH = fn(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCUPDATEPROVIDER = fn(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WSC_PROVIDER_INFO_TYPE = extern enum(i32) {
    ProviderInfoLspCategories = 0,
    ProviderInfoAudit = 1,
};
pub const ProviderInfoLspCategories = WSC_PROVIDER_INFO_TYPE.ProviderInfoLspCategories;
pub const ProviderInfoAudit = WSC_PROVIDER_INFO_TYPE.ProviderInfoAudit;

pub const WSC_PROVIDER_AUDIT_INFO = extern struct {
    RecordSize: u32,
    Reserved: *c_void,
};

pub const LPWSCINSTALLNAMESPACE = fn(
    lpszIdentifier: PWSTR,
    lpszPathName: PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCUNINSTALLNAMESPACE = fn(
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCENABLENSPROVIDER = fn(
    lpProviderId: *Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPCLEANUP = fn(
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPLOOKUPSERVICEBEGIN = fn(
    lpProviderId: *Guid,
    lpqsRestrictions: *WSAQUERYSETW,
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
    dwControlFlags: u32,
    lphLookup: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPLOOKUPSERVICENEXT = fn(
    hLookup: HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: *u32,
    lpqsResults: [*]WSAQUERYSETW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPIOCTL = fn(
    hLookup: HANDLE,
    dwControlCode: u32,
    lpvInBuffer: [*]u8,
    cbInBuffer: u32,
    lpvOutBuffer: [*]u8,
    cbOutBuffer: u32,
    lpcbBytesReturned: *u32,
    lpCompletion: ?*WSACOMPLETION,
    lpThreadId: *WSATHREADID,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPLOOKUPSERVICEEND = fn(
    hLookup: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPSETSERVICE = fn(
    lpProviderId: *Guid,
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
    lpqsRegInfo: *WSAQUERYSETW,
    essOperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPINSTALLSERVICECLASS = fn(
    lpProviderId: *Guid,
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPREMOVESERVICECLASS = fn(
    lpProviderId: *Guid,
    lpServiceClassId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPGETSERVICECLASSINFO = fn(
    lpProviderId: *Guid,
    lpdwBufSize: *u32,
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NSP_ROUTINE = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    NSPCleanup: LPNSPCLEANUP,
    NSPLookupServiceBegin: LPNSPLOOKUPSERVICEBEGIN,
    NSPLookupServiceNext: LPNSPLOOKUPSERVICENEXT,
    NSPLookupServiceEnd: LPNSPLOOKUPSERVICEEND,
    NSPSetService: LPNSPSETSERVICE,
    NSPInstallServiceClass: LPNSPINSTALLSERVICECLASS,
    NSPRemoveServiceClass: LPNSPREMOVESERVICECLASS,
    NSPGetServiceClassInfo: LPNSPGETSERVICECLASSINFO,
    NSPIoctl: LPNSPIOCTL,
};

pub const LPNSPSTARTUP = fn(
    lpProviderId: *Guid,
    lpnspRoutines: *NSP_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2STARTUP = fn(
    lpProviderId: *Guid,
    ppvClientSessionArg: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2CLEANUP = fn(
    lpProviderId: *Guid,
    pvClientSessionArg: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2LOOKUPSERVICEBEGIN = fn(
    lpProviderId: *Guid,
    lpqsRestrictions: *WSAQUERYSET2W,
    dwControlFlags: u32,
    lpvClientSessionArg: *c_void,
    lphLookup: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2LOOKUPSERVICENEXTEX = fn(
    hAsyncCall: HANDLE,
    hLookup: HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: *u32,
    lpqsResults: *WSAQUERYSET2W,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPNSPV2LOOKUPSERVICEEND = fn(
    hLookup: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPNSPV2SETSERVICEEX = fn(
    hAsyncCall: HANDLE,
    lpProviderId: *Guid,
    lpqsRegInfo: *WSAQUERYSET2W,
    essOperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
    lpvClientSessionArg: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPNSPV2CLIENTSESSIONRUNDOWN = fn(
    lpProviderId: *Guid,
    pvClientSessionArg: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const NSPV2_ROUTINE = extern struct {
    cbSize: u32,
    dwMajorVersion: u32,
    dwMinorVersion: u32,
    NSPv2Startup: LPNSPV2STARTUP,
    NSPv2Cleanup: LPNSPV2CLEANUP,
    NSPv2LookupServiceBegin: LPNSPV2LOOKUPSERVICEBEGIN,
    NSPv2LookupServiceNextEx: LPNSPV2LOOKUPSERVICENEXTEX,
    NSPv2LookupServiceEnd: LPNSPV2LOOKUPSERVICEEND,
    NSPv2SetServiceEx: LPNSPV2SETSERVICEEX,
    NSPv2ClientSessionRundown: LPNSPV2CLIENTSESSIONRUNDOWN,
};

pub const NS_INFOA = extern struct {
    dwNameSpace: u32,
    dwNameSpaceFlags: u32,
    lpNameSpace: PSTR,
};

pub const NS_INFOW = extern struct {
    dwNameSpace: u32,
    dwNameSpaceFlags: u32,
    lpNameSpace: PWSTR,
};

pub const SERVICE_TYPE_VALUE = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    dwValueNameOffset: u32,
    dwValueOffset: u32,
};

pub const SERVICE_TYPE_VALUE_ABSA = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValueName: PSTR,
    lpValue: *c_void,
};

pub const SERVICE_TYPE_VALUE_ABSW = extern struct {
    dwNameSpace: u32,
    dwValueType: u32,
    dwValueSize: u32,
    lpValueName: PWSTR,
    lpValue: *c_void,
};

pub const SERVICE_TYPE_INFO = extern struct {
    dwTypeNameOffset: u32,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE,
};

pub const SERVICE_TYPE_INFO_ABSA = extern struct {
    lpTypeName: PSTR,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE_ABSA,
};

pub const SERVICE_TYPE_INFO_ABSW = extern struct {
    lpTypeName: PWSTR,
    dwValueCount: u32,
    Values: [1]SERVICE_TYPE_VALUE_ABSW,
};

pub const SERVICE_ADDRESS = extern struct {
    dwAddressType: u32,
    dwAddressFlags: u32,
    dwAddressLength: u32,
    dwPrincipalLength: u32,
    lpAddress: *u8,
    lpPrincipal: *u8,
};

pub const SERVICE_ADDRESSES = extern struct {
    dwAddressCount: u32,
    Addresses: [1]SERVICE_ADDRESS,
};

pub const SERVICE_INFOA = extern struct {
    lpServiceType: *Guid,
    lpServiceName: PSTR,
    lpComment: PSTR,
    lpLocale: PSTR,
    dwDisplayHint: u32,
    dwVersion: u32,
    dwTime: u32,
    lpMachineName: PSTR,
    lpServiceAddress: *SERVICE_ADDRESSES,
    ServiceSpecificInfo: BLOB,
};

pub const SERVICE_INFOW = extern struct {
    lpServiceType: *Guid,
    lpServiceName: PWSTR,
    lpComment: PWSTR,
    lpLocale: PWSTR,
    dwDisplayHint: u32,
    dwVersion: u32,
    dwTime: u32,
    lpMachineName: PWSTR,
    lpServiceAddress: *SERVICE_ADDRESSES,
    ServiceSpecificInfo: BLOB,
};

pub const NS_SERVICE_INFOA = extern struct {
    dwNameSpace: u32,
    ServiceInfo: SERVICE_INFOA,
};

pub const NS_SERVICE_INFOW = extern struct {
    dwNameSpace: u32,
    ServiceInfo: SERVICE_INFOW,
};

pub const PROTOCOL_INFOA = extern struct {
    dwServiceFlags: u32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    dwMessageSize: u32,
    lpProtocol: PSTR,
};

pub const PROTOCOL_INFOW = extern struct {
    dwServiceFlags: u32,
    iAddressFamily: i32,
    iMaxSockAddr: i32,
    iMinSockAddr: i32,
    iSocketType: i32,
    iProtocol: i32,
    dwMessageSize: u32,
    lpProtocol: PWSTR,
};

pub const NETRESOURCE2A = extern struct {
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    dwDisplayType: u32,
    lpLocalName: PSTR,
    lpRemoteName: PSTR,
    lpComment: PSTR,
    ns_info: NS_INFOA,
    ServiceType: Guid,
    dwProtocols: u32,
    lpiProtocols: *i32,
};

pub const NETRESOURCE2W = extern struct {
    dwScope: u32,
    dwType: u32,
    dwUsage: u32,
    dwDisplayType: u32,
    lpLocalName: PWSTR,
    lpRemoteName: PWSTR,
    lpComment: PWSTR,
    ns_info: NS_INFOA,
    ServiceType: Guid,
    dwProtocols: u32,
    lpiProtocols: *i32,
};

pub const LPFN_NSPAPI = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPSERVICE_CALLBACK_PROC = fn(
    lParam: LPARAM,
    hAsyncTaskHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SERVICE_ASYNC_INFO = extern struct {
    lpServiceCallbackProc: LPSERVICE_CALLBACK_PROC,
    lParam: LPARAM,
    hAsyncTaskHandle: HANDLE,
};

pub const LPLOOKUPSERVICE_COMPLETION_ROUTINE = fn(
    dwError: u32,
    dwBytes: u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPWSCWRITEPROVIDERORDER = fn(
    lpwdCatalogEntryId: *u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPWSCWRITENAMESPACEORDER = fn(
    lpProviderId: *Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;


//--------------------------------------------------------------------------------
// Section: Functions (170)
//--------------------------------------------------------------------------------
pub extern "WS2_32" fn __WSAFDIsSet(
    fd: ?*c_void,
    param1: *fd_set,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn accept(
    s: ?*c_void,
    addr: ?[*]SOCKADDR,
    addrlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "WS2_32" fn bind(
    s: ?*c_void,
    name: [*]const SOCKADDR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn closesocket(
    s: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn connect(
    s: ?*c_void,
    name: [*]const SOCKADDR,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn ioctlsocket(
    s: ?*c_void,
    cmd: i32,
    argp: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn getpeername(
    s: ?*c_void,
    name: [*]SOCKADDR,
    namelen: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn getsockname(
    s: ?*c_void,
    name: [*]SOCKADDR,
    namelen: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn getsockopt(
    s: ?*c_void,
    level: i32,
    optname: i32,
    optval: [*]i8,
    optlen: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn htonl(
    hostlong: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WS2_32" fn htons(
    hostshort: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "WS2_32" fn inet_addr(
    cp: *const i8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WS2_32" fn inet_ntoa(
    in: in_addr,
) callconv(@import("std").os.windows.WINAPI) *i8;

pub extern "WS2_32" fn listen(
    s: ?*c_void,
    backlog: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn ntohl(
    netlong: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WS2_32" fn ntohs(
    netshort: u16,
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "WS2_32" fn recv(
    s: ?*c_void,
    buf: [*]i8,
    len: i32,
    flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn recvfrom(
    s: ?*c_void,
    buf: [*]i8,
    len: i32,
    flags: i32,
    from: ?[*]SOCKADDR,
    fromlen: ?*i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn select(
    nfds: i32,
    readfds: ?*fd_set,
    writefds: ?*fd_set,
    exceptfds: ?*fd_set,
    timeout: ?*const timeval,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn send(
    s: ?*c_void,
    buf: [*]const i8,
    len: i32,
    flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn sendto(
    s: ?*c_void,
    buf: [*]const i8,
    len: i32,
    flags: i32,
    to: [*]const SOCKADDR,
    tolen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn setsockopt(
    s: ?*c_void,
    level: i32,
    optname: i32,
    optval: ?[*]const i8,
    optlen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn shutdown(
    s: ?*c_void,
    how: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn socket(
    af: i32,
    type: i32,
    protocol: i32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "WS2_32" fn gethostbyaddr(
    addr: [*]const i8,
    len: i32,
    type: i32,
) callconv(@import("std").os.windows.WINAPI) *hostent;

pub extern "WS2_32" fn gethostbyname(
    name: *const i8,
) callconv(@import("std").os.windows.WINAPI) *hostent;

pub extern "WS2_32" fn gethostname(
    name: [*]i8,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn GetHostNameW(
    name: [*:0]u16,
    namelen: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn getservbyport(
    port: i32,
    proto: ?*const i8,
) callconv(@import("std").os.windows.WINAPI) *servent;

pub extern "WS2_32" fn getservbyname(
    name: *const i8,
    proto: ?*const i8,
) callconv(@import("std").os.windows.WINAPI) *servent;

pub extern "WS2_32" fn getprotobynumber(
    number: i32,
) callconv(@import("std").os.windows.WINAPI) *protoent;

pub extern "WS2_32" fn getprotobyname(
    name: *const i8,
) callconv(@import("std").os.windows.WINAPI) *protoent;

pub extern "WS2_32" fn WSAStartup(
    wVersionRequested: u16,
    lpWSAData: *WSAData,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSACleanup(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSASetLastError(
    iError: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WS2_32" fn WSAGetLastError(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAIsBlocking(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSAUnhookBlockingHook(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSASetBlockingHook(
    lpBlockFunc: FARPROC,
) callconv(@import("std").os.windows.WINAPI) FARPROC;

pub extern "WS2_32" fn WSACancelBlockingCall(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAAsyncGetServByName(
    hWnd: HWND,
    wMsg: u32,
    name: *const i8,
    proto: *const i8,
    buf: [*]i8,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WS2_32" fn WSAAsyncGetServByPort(
    hWnd: HWND,
    wMsg: u32,
    port: i32,
    proto: *const i8,
    buf: [*]i8,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WS2_32" fn WSAAsyncGetProtoByName(
    hWnd: HWND,
    wMsg: u32,
    name: *const i8,
    buf: [*]i8,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WS2_32" fn WSAAsyncGetProtoByNumber(
    hWnd: HWND,
    wMsg: u32,
    number: i32,
    buf: [*]i8,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WS2_32" fn WSAAsyncGetHostByName(
    hWnd: HWND,
    wMsg: u32,
    name: *const i8,
    buf: [*]i8,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WS2_32" fn WSAAsyncGetHostByAddr(
    hWnd: HWND,
    wMsg: u32,
    addr: [*]const i8,
    len: i32,
    type: i32,
    buf: [*]i8,
    buflen: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WS2_32" fn WSACancelAsyncRequest(
    hAsyncTaskHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAAsyncSelect(
    s: ?*c_void,
    hWnd: HWND,
    wMsg: u32,
    lEvent: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAAccept(
    s: ?*c_void,
    addr: ?[*]SOCKADDR,
    addrlen: ?*i32,
    lpfnCondition: ?LPCONDITIONPROC,
    dwCallbackData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "WS2_32" fn WSACloseEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSAConnect(
    s: ?*c_void,
    name: [*]const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAConnectByNameW(
    s: ?*c_void,
    nodename: PWSTR,
    servicename: PWSTR,
    LocalAddressLength: ?*u32,
    LocalAddress: ?[*]SOCKADDR,
    RemoteAddressLength: ?*u32,
    RemoteAddress: ?[*]SOCKADDR,
    timeout: ?*const timeval,
    Reserved: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSAConnectByNameA(
    s: ?*c_void,
    nodename: [*:0]const u8,
    servicename: [*:0]const u8,
    LocalAddressLength: ?*u32,
    LocalAddress: ?[*]SOCKADDR,
    RemoteAddressLength: ?*u32,
    RemoteAddress: ?[*]SOCKADDR,
    timeout: ?*const timeval,
    Reserved: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSAConnectByList(
    s: ?*c_void,
    SocketAddress: *SOCKET_ADDRESS_LIST,
    LocalAddressLength: ?*u32,
    LocalAddress: ?[*]SOCKADDR,
    RemoteAddressLength: ?*u32,
    RemoteAddress: ?[*]SOCKADDR,
    timeout: ?*const timeval,
    Reserved: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSACreateEvent(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WS2_32" fn WSADuplicateSocketA(
    s: ?*c_void,
    dwProcessId: u32,
    lpProtocolInfo: *WSAPROTOCOL_INFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSADuplicateSocketW(
    s: ?*c_void,
    dwProcessId: u32,
    lpProtocolInfo: *WSAPROTOCOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAEnumNetworkEvents(
    s: ?*c_void,
    hEventObject: HANDLE,
    lpNetworkEvents: *WSANETWORKEVENTS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAEnumProtocolsA(
    lpiProtocols: ?*i32,
    lpProtocolBuffer: ?[*]WSAPROTOCOL_INFOA,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAEnumProtocolsW(
    lpiProtocols: ?*i32,
    lpProtocolBuffer: ?[*]WSAPROTOCOL_INFOW,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAEventSelect(
    s: ?*c_void,
    hEventObject: HANDLE,
    lNetworkEvents: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAGetOverlappedResult(
    s: ?*c_void,
    lpOverlapped: *OVERLAPPED,
    lpcbTransfer: *u32,
    fWait: BOOL,
    lpdwFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSAGetQOSByName(
    s: ?*c_void,
    lpQOSName: *WSABUF,
    lpQOS: *QOS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSAHtonl(
    s: ?*c_void,
    hostlong: u32,
    lpnetlong: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAHtons(
    s: ?*c_void,
    hostshort: u16,
    lpnetshort: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAIoctl(
    s: ?*c_void,
    dwIoControlCode: u32,
    lpvInBuffer: ?[*]u8,
    cbInBuffer: u32,
    lpvOutBuffer: ?[*]u8,
    cbOutBuffer: u32,
    lpcbBytesReturned: *u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAJoinLeaf(
    s: ?*c_void,
    name: [*]const SOCKADDR,
    namelen: i32,
    lpCallerData: ?*WSABUF,
    lpCalleeData: ?*WSABUF,
    lpSQOS: ?*QOS,
    lpGQOS: ?*QOS,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "WS2_32" fn WSANtohl(
    s: ?*c_void,
    netlong: u32,
    lphostlong: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSANtohs(
    s: ?*c_void,
    netshort: u16,
    lphostshort: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSARecv(
    s: ?*c_void,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: *u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSARecvDisconnect(
    s: ?*c_void,
    lpInboundDisconnectData: ?*WSABUF,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSARecvFrom(
    s: ?*c_void,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesRecvd: ?*u32,
    lpFlags: *u32,
    lpFrom: ?[*]SOCKADDR,
    lpFromlen: ?*i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAResetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSASend(
    s: ?*c_void,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSASendMsg(
    Handle: ?*c_void,
    lpMsg: *WSAMSG,
    dwFlags: u32,
    lpNumberOfBytesSent: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSASendDisconnect(
    s: ?*c_void,
    lpOutboundDisconnectData: ?*WSABUF,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSASendTo(
    s: ?*c_void,
    lpBuffers: [*]WSABUF,
    dwBufferCount: u32,
    lpNumberOfBytesSent: ?*u32,
    dwFlags: u32,
    lpTo: ?[*]const SOCKADDR,
    iTolen: i32,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSASetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WS2_32" fn WSASocketA(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    g: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "WS2_32" fn WSASocketW(
    af: i32,
    type: i32,
    protocol: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    g: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "WS2_32" fn WSAWaitForMultipleEvents(
    cEvents: u32,
    lphEvents: [*]const HANDLE,
    fWaitAll: BOOL,
    dwTimeout: u32,
    fAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WS2_32" fn WSAAddressToStringA(
    lpsaAddress: [*]SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    lpszAddressString: [*:0]u8,
    lpdwAddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAAddressToStringW(
    lpsaAddress: [*]SOCKADDR,
    dwAddressLength: u32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpszAddressString: [*:0]u16,
    lpdwAddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAStringToAddressA(
    AddressString: PSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOA,
    lpAddress: [*]SOCKADDR,
    lpAddressLength: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAStringToAddressW(
    AddressString: PWSTR,
    AddressFamily: i32,
    lpProtocolInfo: ?*WSAPROTOCOL_INFOW,
    lpAddress: [*]SOCKADDR,
    lpAddressLength: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSALookupServiceBeginA(
    lpqsRestrictions: *WSAQUERYSETA,
    dwControlFlags: u32,
    lphLookup: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSALookupServiceBeginW(
    lpqsRestrictions: *WSAQUERYSETW,
    dwControlFlags: u32,
    lphLookup: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSALookupServiceNextA(
    hLookup: HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: *u32,
    lpqsResults: [*]WSAQUERYSETA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSALookupServiceNextW(
    hLookup: HANDLE,
    dwControlFlags: u32,
    lpdwBufferLength: *u32,
    lpqsResults: ?[*]WSAQUERYSETW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSANSPIoctl(
    hLookup: HANDLE,
    dwControlCode: u32,
    lpvInBuffer: ?[*]u8,
    cbInBuffer: u32,
    lpvOutBuffer: ?[*]u8,
    cbOutBuffer: u32,
    lpcbBytesReturned: *u32,
    lpCompletion: ?*WSACOMPLETION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSALookupServiceEnd(
    hLookup: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAInstallServiceClassA(
    lpServiceClassInfo: *WSASERVICECLASSINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAInstallServiceClassW(
    lpServiceClassInfo: *WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSARemoveServiceClass(
    lpServiceClassId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAGetServiceClassInfoA(
    lpProviderId: *Guid,
    lpServiceClassId: *Guid,
    lpdwBufSize: *u32,
    lpServiceClassInfo: [*]WSASERVICECLASSINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAGetServiceClassInfoW(
    lpProviderId: *Guid,
    lpServiceClassId: *Guid,
    lpdwBufSize: *u32,
    lpServiceClassInfo: [*]WSASERVICECLASSINFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAEnumNameSpaceProvidersA(
    lpdwBufferLength: *u32,
    lpnspBuffer: [*]WSANAMESPACE_INFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAEnumNameSpaceProvidersW(
    lpdwBufferLength: *u32,
    lpnspBuffer: [*]WSANAMESPACE_INFOW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAEnumNameSpaceProvidersExA(
    lpdwBufferLength: *u32,
    lpnspBuffer: [*]WSANAMESPACE_INFOEXA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAEnumNameSpaceProvidersExW(
    lpdwBufferLength: *u32,
    lpnspBuffer: [*]WSANAMESPACE_INFOEXW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAGetServiceClassNameByClassIdA(
    lpServiceClassId: *Guid,
    lpszServiceClassName: [*:0]u8,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAGetServiceClassNameByClassIdW(
    lpServiceClassId: *Guid,
    lpszServiceClassName: [*:0]u16,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSASetServiceA(
    lpqsRegInfo: *WSAQUERYSETA,
    essoperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSASetServiceW(
    lpqsRegInfo: *WSAQUERYSETW,
    essoperation: WSAESETSERVICEOP,
    dwControlFlags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAProviderConfigChange(
    lpNotificationHandle: *HANDLE,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAPoll(
    fdArray: *WSAPOLLFD,
    fds: u32,
    timeout: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4AddressToStringExA(
    Address: *const in_addr,
    Port: u16,
    AddressString: [*:0]u8,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv4StringToAddressExA(
    AddressString: [*:0]const u8,
    Strict: u8,
    Address: *in_addr,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6AddressToStringExA(
    Address: *const in6_addr,
    ScopeId: u32,
    Port: u16,
    AddressString: [*:0]u8,
    AddressStringLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "ntdll" fn RtlIpv6StringToAddressExA(
    AddressString: [*:0]const u8,
    Address: *in6_addr,
    ScopeId: *u32,
    Port: *u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn WSARecvEx(
    s: ?*c_void,
    buf: [*]i8,
    len: i32,
    flags: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn TransmitFile(
    hSocket: ?*c_void,
    hFile: HANDLE,
    nNumberOfBytesToWrite: u32,
    nNumberOfBytesPerSend: u32,
    lpOverlapped: ?*OVERLAPPED,
    lpTransmitBuffers: ?*TRANSMIT_FILE_BUFFERS,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSWSOCK" fn AcceptEx(
    sListenSocket: ?*c_void,
    sAcceptSocket: ?*c_void,
    lpOutputBuffer: *c_void,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    lpdwBytesReceived: *u32,
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "MSWSOCK" fn GetAcceptExSockaddrs(
    lpOutputBuffer: *c_void,
    dwReceiveDataLength: u32,
    dwLocalAddressLength: u32,
    dwRemoteAddressLength: u32,
    LocalSockaddr: **SOCKADDR,
    LocalSockaddrLength: *i32,
    RemoteSockaddr: **SOCKADDR,
    RemoteSockaddrLength: *i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WS2_32" fn WSCEnumProtocols(
    lpiProtocols: ?*i32,
    lpProtocolBuffer: ?[*]WSAPROTOCOL_INFOW,
    lpdwBufferLength: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCDeinstallProvider(
    lpProviderId: *Guid,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCInstallProvider(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCGetProviderPath(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]u16,
    lpProviderDllPathLen: *i32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCUpdateProvider(
    lpProviderId: *Guid,
    lpszProviderDllPath: [*:0]const u16,
    lpProtocolInfoList: [*]const WSAPROTOCOL_INFOW,
    dwNumberOfEntries: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCSetProviderInfo(
    lpProviderId: *Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    Info: [*:0]u8,
    InfoSize: ?*c_void,
    Flags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCGetProviderInfo(
    lpProviderId: *Guid,
    InfoType: WSC_PROVIDER_INFO_TYPE,
    Info: [*:0]u8,
    InfoSize: *?*c_void,
    Flags: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCSetApplicationCategory(
    Path: [*:0]const u16,
    PathLength: u32,
    Extra: ?[*:0]const u16,
    ExtraLength: u32,
    PermittedLspCategories: u32,
    pPrevPermLspCat: ?*u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCGetApplicationCategory(
    Path: [*:0]const u16,
    PathLength: u32,
    Extra: ?[*:0]const u16,
    ExtraLength: u32,
    pPermittedLspCategories: *u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WPUCompleteOverlappedRequest(
    s: ?*c_void,
    lpOverlapped: *OVERLAPPED,
    dwError: u32,
    cbTransferred: u32,
    lpErrno: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCInstallNameSpace(
    lpszIdentifier: PWSTR,
    lpszPathName: PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCUnInstallNameSpace(
    lpProviderId: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCInstallNameSpaceEx(
    lpszIdentifier: PWSTR,
    lpszPathName: PWSTR,
    dwNameSpace: u32,
    dwVersion: u32,
    lpProviderId: *Guid,
    lpProviderSpecific: *BLOB,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCEnableNSProvider(
    lpProviderId: *Guid,
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAAdvertiseProvider(
    puuidProviderId: *const Guid,
    pNSPv2Routine: *const NSPV2_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAUnadvertiseProvider(
    puuidProviderId: *const Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSAProviderCompleteAsyncCall(
    hAsyncCall: HANDLE,
    iRetCode: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn EnumProtocolsA(
    lpiProtocols: ?*i32,
    lpProtocolBuffer: [*]u8,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn EnumProtocolsW(
    lpiProtocols: ?*i32,
    lpProtocolBuffer: [*]u8,
    lpdwBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn GetAddressByNameA(
    dwNameSpace: u32,
    lpServiceType: *Guid,
    lpServiceName: ?PSTR,
    lpiProtocols: ?*i32,
    dwResolution: u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpCsaddrBuffer: [*]u8,
    lpdwBufferLength: *u32,
    lpAliasBuffer: ?[*:0]u8,
    lpdwAliasBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn GetAddressByNameW(
    dwNameSpace: u32,
    lpServiceType: *Guid,
    lpServiceName: ?PWSTR,
    lpiProtocols: ?*i32,
    dwResolution: u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpCsaddrBuffer: [*]u8,
    lpdwBufferLength: *u32,
    lpAliasBuffer: ?[*:0]u16,
    lpdwAliasBufferLength: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn GetTypeByNameA(
    lpServiceName: PSTR,
    lpServiceType: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn GetTypeByNameW(
    lpServiceName: PWSTR,
    lpServiceType: *Guid,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn GetNameByTypeA(
    lpServiceType: *Guid,
    lpServiceName: [*:0]u8,
    dwNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn GetNameByTypeW(
    lpServiceType: *Guid,
    lpServiceName: [*:0]u16,
    dwNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn SetServiceA(
    dwNameSpace: u32,
    dwOperation: u32,
    dwFlags: u32,
    lpServiceInfo: *SERVICE_INFOA,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpdwStatusFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn SetServiceW(
    dwNameSpace: u32,
    dwOperation: u32,
    dwFlags: u32,
    lpServiceInfo: *SERVICE_INFOW,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
    lpdwStatusFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn GetServiceA(
    dwNameSpace: u32,
    lpGuid: *Guid,
    lpServiceName: PSTR,
    dwProperties: u32,
    lpBuffer: [*]u8,
    lpdwBufferSize: *u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "MSWSOCK" fn GetServiceW(
    dwNameSpace: u32,
    lpGuid: *Guid,
    lpServiceName: PWSTR,
    dwProperties: u32,
    lpBuffer: [*]u8,
    lpdwBufferSize: *u32,
    lpServiceAsyncInfo: ?*SERVICE_ASYNC_INFO,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn getaddrinfo(
    pNodeName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    pHints: ?*const ADDRINFOA,
    ppResult: **ADDRINFOA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn GetAddrInfoW(
    pNodeName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    pHints: ?*const addrinfoW,
    ppResult: **addrinfoW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn GetAddrInfoExA(
    pName: ?[*:0]const u8,
    pServiceName: ?[*:0]const u8,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    hints: ?*const addrinfoexA,
    ppResult: **addrinfoexA,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn GetAddrInfoExW(
    pName: ?[*:0]const u16,
    pServiceName: ?[*:0]const u16,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    hints: ?*const addrinfoexW,
    ppResult: **addrinfoexW,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn GetAddrInfoExCancel(
    lpHandle: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn GetAddrInfoExOverlappedResult(
    lpOverlapped: *OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn SetAddrInfoExA(
    pName: [*:0]const u8,
    pServiceName: ?[*:0]const u8,
    pAddresses: ?*SOCKET_ADDRESS,
    dwAddressCount: u32,
    lpBlob: ?*BLOB,
    dwFlags: u32,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn SetAddrInfoExW(
    pName: [*:0]const u16,
    pServiceName: ?[*:0]const u16,
    pAddresses: ?*SOCKET_ADDRESS,
    dwAddressCount: u32,
    lpBlob: ?*BLOB,
    dwFlags: u32,
    dwNameSpace: u32,
    lpNspId: ?*Guid,
    timeout: ?*timeval,
    lpOverlapped: ?*OVERLAPPED,
    lpCompletionRoutine: ?LPLOOKUPSERVICE_COMPLETION_ROUTINE,
    lpNameHandle: ?*HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn freeaddrinfo(
    pAddrInfo: ?*ADDRINFOA,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WS2_32" fn FreeAddrInfoW(
    pAddrInfo: ?*addrinfoW,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WS2_32" fn FreeAddrInfoEx(
    pAddrInfoEx: ?*addrinfoexA,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WS2_32" fn FreeAddrInfoExW(
    pAddrInfoEx: ?*addrinfoexW,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WS2_32" fn getnameinfo(
    pSockaddr: [*]const SOCKADDR,
    SockaddrLength: i32,
    pNodeBuffer: ?[*]u8,
    NodeBufferSize: u32,
    pServiceBuffer: ?[*]u8,
    ServiceBufferSize: u32,
    Flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn GetNameInfoW(
    pSockaddr: [*]const SOCKADDR,
    SockaddrLength: i32,
    pNodeBuffer: ?[*]u16,
    NodeBufferSize: u32,
    pServiceBuffer: ?[*]u16,
    ServiceBufferSize: u32,
    Flags: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn inet_pton(
    Family: i32,
    pszAddrString: [*:0]const u8,
    pAddrBuf: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn InetPtonW(
    Family: i32,
    pszAddrString: [*:0]const u16,
    pAddrBuf: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn inet_ntop(
    Family: i32,
    pAddr: *const c_void,
    pStringBuf: [*:0]u8,
    StringBufSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "WS2_32" fn InetNtopW(
    Family: i32,
    pAddr: *const c_void,
    pStringBuf: [*:0]u16,
    StringBufSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) PWSTR;

pub extern "fwpuclnt" fn WSASetSocketSecurity(
    Socket: ?*c_void,
    SecuritySettings: ?[*]const SOCKET_SECURITY_SETTINGS,
    SecuritySettingsLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "fwpuclnt" fn WSAQuerySocketSecurity(
    Socket: ?*c_void,
    SecurityQueryTemplate: ?[*]const SOCKET_SECURITY_QUERY_TEMPLATE,
    SecurityQueryTemplateLen: u32,
    SecurityQueryInfo: ?[*]SOCKET_SECURITY_QUERY_INFO,
    SecurityQueryInfoLen: *u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "fwpuclnt" fn WSASetSocketPeerTargetName(
    Socket: ?*c_void,
    PeerTargetName: [*]const SOCKET_PEER_TARGET_NAME,
    PeerTargetNameLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "fwpuclnt" fn WSADeleteSocketPeerTargetName(
    Socket: ?*c_void,
    PeerAddr: [*]const SOCKADDR,
    PeerAddrLen: u32,
    Overlapped: ?*OVERLAPPED,
    CompletionRoutine: ?LPWSAOVERLAPPED_COMPLETION_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "fwpuclnt" fn WSAImpersonateSocketPeer(
    Socket: ?*c_void,
    PeerAddr: ?[*]const SOCKADDR,
    PeerAddrLen: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "fwpuclnt" fn WSARevertImpersonation(
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "Windows.Networking" fn SetSocketMediaStreamingMode(
    value: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WS2_32" fn WSCWriteProviderOrder(
    lpwdCatalogEntryId: *u32,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WS2_32" fn WSCWriteNameSpaceOrder(
    lpProviderId: *Guid,
    dwNumberOfEntries: u32,
) callconv(@import("std").os.windows.WINAPI) i32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (38)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const addrinfoex = addrinfoexA;
        pub const addrinfoex2 = addrinfoex2A;
        pub const WSAPROTOCOL_INFO = WSAPROTOCOL_INFOA;
        pub const WSAQUERYSET = WSAQUERYSETA;
        pub const WSAQUERYSET2 = WSAQUERYSET2A;
        pub const WSANSCLASSINFO = WSANSCLASSINFOA;
        pub const WSASERVICECLASSINFO = WSASERVICECLASSINFOA;
        pub const WSANAMESPACE_INFO = WSANAMESPACE_INFOA;
        pub const WSANAMESPACE_INFOEX = WSANAMESPACE_INFOEXA;
        pub const NS_INFO = NS_INFOA;
        pub const SERVICE_TYPE_VALUE_ABS = SERVICE_TYPE_VALUE_ABSA;
        pub const SERVICE_TYPE_INFO_ABS = SERVICE_TYPE_INFO_ABSA;
        pub const SERVICE_INFO = SERVICE_INFOA;
        pub const NS_SERVICE_INFO = NS_SERVICE_INFOA;
        pub const PROTOCOL_INFO = PROTOCOL_INFOA;
        pub const NETRESOURCE2 = NETRESOURCE2A;
        pub const WSAConnectByName = WSAConnectByNameA;
        pub const WSADuplicateSocket = WSADuplicateSocketA;
        pub const WSAEnumProtocols = WSAEnumProtocolsA;
        pub const WSASocket = WSASocketA;
        pub const WSAAddressToString = WSAAddressToStringA;
        pub const WSAStringToAddress = WSAStringToAddressA;
        pub const WSALookupServiceBegin = WSALookupServiceBeginA;
        pub const WSALookupServiceNext = WSALookupServiceNextA;
        pub const WSAInstallServiceClass = WSAInstallServiceClassA;
        pub const WSAGetServiceClassInfo = WSAGetServiceClassInfoA;
        pub const WSAEnumNameSpaceProviders = WSAEnumNameSpaceProvidersA;
        pub const WSAEnumNameSpaceProvidersEx = WSAEnumNameSpaceProvidersExA;
        pub const WSAGetServiceClassNameByClassId = WSAGetServiceClassNameByClassIdA;
        pub const WSASetService = WSASetServiceA;
        pub const EnumProtocols = EnumProtocolsA;
        pub const GetAddressByName = GetAddressByNameA;
        pub const GetTypeByName = GetTypeByNameA;
        pub const GetNameByType = GetNameByTypeA;
        pub const SetService = SetServiceA;
        pub const GetService = GetServiceA;
        pub const GetAddrInfoEx = GetAddrInfoExA;
        pub const SetAddrInfoEx = SetAddrInfoExA;
    },
    .wide => struct {
        pub const addrinfoex = addrinfoexW;
        pub const addrinfoex2 = addrinfoex2W;
        pub const WSAPROTOCOL_INFO = WSAPROTOCOL_INFOW;
        pub const WSAQUERYSET = WSAQUERYSETW;
        pub const WSAQUERYSET2 = WSAQUERYSET2W;
        pub const WSANSCLASSINFO = WSANSCLASSINFOW;
        pub const WSASERVICECLASSINFO = WSASERVICECLASSINFOW;
        pub const WSANAMESPACE_INFO = WSANAMESPACE_INFOW;
        pub const WSANAMESPACE_INFOEX = WSANAMESPACE_INFOEXW;
        pub const NS_INFO = NS_INFOW;
        pub const SERVICE_TYPE_VALUE_ABS = SERVICE_TYPE_VALUE_ABSW;
        pub const SERVICE_TYPE_INFO_ABS = SERVICE_TYPE_INFO_ABSW;
        pub const SERVICE_INFO = SERVICE_INFOW;
        pub const NS_SERVICE_INFO = NS_SERVICE_INFOW;
        pub const PROTOCOL_INFO = PROTOCOL_INFOW;
        pub const NETRESOURCE2 = NETRESOURCE2W;
        pub const WSAConnectByName = WSAConnectByNameW;
        pub const WSADuplicateSocket = WSADuplicateSocketW;
        pub const WSAEnumProtocols = WSAEnumProtocolsW;
        pub const WSASocket = WSASocketW;
        pub const WSAAddressToString = WSAAddressToStringW;
        pub const WSAStringToAddress = WSAStringToAddressW;
        pub const WSALookupServiceBegin = WSALookupServiceBeginW;
        pub const WSALookupServiceNext = WSALookupServiceNextW;
        pub const WSAInstallServiceClass = WSAInstallServiceClassW;
        pub const WSAGetServiceClassInfo = WSAGetServiceClassInfoW;
        pub const WSAEnumNameSpaceProviders = WSAEnumNameSpaceProvidersW;
        pub const WSAEnumNameSpaceProvidersEx = WSAEnumNameSpaceProvidersExW;
        pub const WSAGetServiceClassNameByClassId = WSAGetServiceClassNameByClassIdW;
        pub const WSASetService = WSASetServiceW;
        pub const EnumProtocols = EnumProtocolsW;
        pub const GetAddressByName = GetAddressByNameW;
        pub const GetTypeByName = GetTypeByNameW;
        pub const GetNameByType = GetNameByTypeW;
        pub const SetService = SetServiceW;
        pub const GetService = GetServiceW;
        pub const GetAddrInfoEx = GetAddrInfoExW;
        pub const SetAddrInfoEx = SetAddrInfoExW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const addrinfoex = *opaque{};
        pub const addrinfoex2 = *opaque{};
        pub const WSAPROTOCOL_INFO = *opaque{};
        pub const WSAQUERYSET = *opaque{};
        pub const WSAQUERYSET2 = *opaque{};
        pub const WSANSCLASSINFO = *opaque{};
        pub const WSASERVICECLASSINFO = *opaque{};
        pub const WSANAMESPACE_INFO = *opaque{};
        pub const WSANAMESPACE_INFOEX = *opaque{};
        pub const NS_INFO = *opaque{};
        pub const SERVICE_TYPE_VALUE_ABS = *opaque{};
        pub const SERVICE_TYPE_INFO_ABS = *opaque{};
        pub const SERVICE_INFO = *opaque{};
        pub const NS_SERVICE_INFO = *opaque{};
        pub const PROTOCOL_INFO = *opaque{};
        pub const NETRESOURCE2 = *opaque{};
        pub const WSAConnectByName = *opaque{};
        pub const WSADuplicateSocket = *opaque{};
        pub const WSAEnumProtocols = *opaque{};
        pub const WSASocket = *opaque{};
        pub const WSAAddressToString = *opaque{};
        pub const WSAStringToAddress = *opaque{};
        pub const WSALookupServiceBegin = *opaque{};
        pub const WSALookupServiceNext = *opaque{};
        pub const WSAInstallServiceClass = *opaque{};
        pub const WSAGetServiceClassInfo = *opaque{};
        pub const WSAEnumNameSpaceProviders = *opaque{};
        pub const WSAEnumNameSpaceProvidersEx = *opaque{};
        pub const WSAGetServiceClassNameByClassId = *opaque{};
        pub const WSASetService = *opaque{};
        pub const EnumProtocols = *opaque{};
        pub const GetAddressByName = *opaque{};
        pub const GetTypeByName = *opaque{};
        pub const GetNameByType = *opaque{};
        pub const SetService = *opaque{};
        pub const GetService = *opaque{};
        pub const GetAddrInfoEx = *opaque{};
        pub const SetAddrInfoEx = *opaque{};
    } else struct {
        pub const addrinfoex = @compileError("'addrinfoex' requires that UNICODE be set to true or false in the root module");
        pub const addrinfoex2 = @compileError("'addrinfoex2' requires that UNICODE be set to true or false in the root module");
        pub const WSAPROTOCOL_INFO = @compileError("'WSAPROTOCOL_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WSAQUERYSET = @compileError("'WSAQUERYSET' requires that UNICODE be set to true or false in the root module");
        pub const WSAQUERYSET2 = @compileError("'WSAQUERYSET2' requires that UNICODE be set to true or false in the root module");
        pub const WSANSCLASSINFO = @compileError("'WSANSCLASSINFO' requires that UNICODE be set to true or false in the root module");
        pub const WSASERVICECLASSINFO = @compileError("'WSASERVICECLASSINFO' requires that UNICODE be set to true or false in the root module");
        pub const WSANAMESPACE_INFO = @compileError("'WSANAMESPACE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const WSANAMESPACE_INFOEX = @compileError("'WSANAMESPACE_INFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NS_INFO = @compileError("'NS_INFO' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_TYPE_VALUE_ABS = @compileError("'SERVICE_TYPE_VALUE_ABS' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_TYPE_INFO_ABS = @compileError("'SERVICE_TYPE_INFO_ABS' requires that UNICODE be set to true or false in the root module");
        pub const SERVICE_INFO = @compileError("'SERVICE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const NS_SERVICE_INFO = @compileError("'NS_SERVICE_INFO' requires that UNICODE be set to true or false in the root module");
        pub const PROTOCOL_INFO = @compileError("'PROTOCOL_INFO' requires that UNICODE be set to true or false in the root module");
        pub const NETRESOURCE2 = @compileError("'NETRESOURCE2' requires that UNICODE be set to true or false in the root module");
        pub const WSAConnectByName = @compileError("'WSAConnectByName' requires that UNICODE be set to true or false in the root module");
        pub const WSADuplicateSocket = @compileError("'WSADuplicateSocket' requires that UNICODE be set to true or false in the root module");
        pub const WSAEnumProtocols = @compileError("'WSAEnumProtocols' requires that UNICODE be set to true or false in the root module");
        pub const WSASocket = @compileError("'WSASocket' requires that UNICODE be set to true or false in the root module");
        pub const WSAAddressToString = @compileError("'WSAAddressToString' requires that UNICODE be set to true or false in the root module");
        pub const WSAStringToAddress = @compileError("'WSAStringToAddress' requires that UNICODE be set to true or false in the root module");
        pub const WSALookupServiceBegin = @compileError("'WSALookupServiceBegin' requires that UNICODE be set to true or false in the root module");
        pub const WSALookupServiceNext = @compileError("'WSALookupServiceNext' requires that UNICODE be set to true or false in the root module");
        pub const WSAInstallServiceClass = @compileError("'WSAInstallServiceClass' requires that UNICODE be set to true or false in the root module");
        pub const WSAGetServiceClassInfo = @compileError("'WSAGetServiceClassInfo' requires that UNICODE be set to true or false in the root module");
        pub const WSAEnumNameSpaceProviders = @compileError("'WSAEnumNameSpaceProviders' requires that UNICODE be set to true or false in the root module");
        pub const WSAEnumNameSpaceProvidersEx = @compileError("'WSAEnumNameSpaceProvidersEx' requires that UNICODE be set to true or false in the root module");
        pub const WSAGetServiceClassNameByClassId = @compileError("'WSAGetServiceClassNameByClassId' requires that UNICODE be set to true or false in the root module");
        pub const WSASetService = @compileError("'WSASetService' requires that UNICODE be set to true or false in the root module");
        pub const EnumProtocols = @compileError("'EnumProtocols' requires that UNICODE be set to true or false in the root module");
        pub const GetAddressByName = @compileError("'GetAddressByName' requires that UNICODE be set to true or false in the root module");
        pub const GetTypeByName = @compileError("'GetTypeByName' requires that UNICODE be set to true or false in the root module");
        pub const GetNameByType = @compileError("'GetNameByType' requires that UNICODE be set to true or false in the root module");
        pub const SetService = @compileError("'SetService' requires that UNICODE be set to true or false in the root module");
        pub const GetService = @compileError("'GetService' requires that UNICODE be set to true or false in the root module");
        pub const GetAddrInfoEx = @compileError("'GetAddrInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const SetAddrInfoEx = @compileError("'SetAddrInfoEx' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (16)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const PWSTR = @import("system_services.zig").PWSTR;
const PROCESSOR_NUMBER = @import("system_services.zig").PROCESSOR_NUMBER;
const SOCKADDR_STORAGE_LH = @import("network_drivers.zig").SOCKADDR_STORAGE_LH;
const SOCKET_ADDRESS_LIST = @import("network_drivers.zig").SOCKET_ADDRESS_LIST;
const HRESULT = @import("com.zig").HRESULT;
const PSTR = @import("system_services.zig").PSTR;
const BOOL = @import("system_services.zig").BOOL;
const HWND = @import("windows_and_messaging.zig").HWND;
const QOS = @import("quality_of_service.zig").QOS;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;
const FARPROC = @import("system_services.zig").FARPROC;
const HANDLE = @import("system_services.zig").HANDLE;
const SOCKADDR_INET = @import("ip_helper.zig").SOCKADDR_INET;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = LPCONDITIONPROC;
    _ = LPWSAOVERLAPPED_COMPLETION_ROUTINE;
    _ = LPFN_TRANSMITFILE;
    _ = LPFN_ACCEPTEX;
    _ = LPFN_GETACCEPTEXSOCKADDRS;
    _ = LPFN_TRANSMITPACKETS;
    _ = LPFN_CONNECTEX;
    _ = LPFN_DISCONNECTEX;
    _ = LPFN_WSARECVMSG;
    _ = LPFN_WSASENDMSG;
    _ = LPFN_WSAPOLL;
    _ = LPFN_RIORECEIVE;
    _ = LPFN_RIORECEIVEEX;
    _ = LPFN_RIOSEND;
    _ = LPFN_RIOSENDEX;
    _ = LPFN_RIOCLOSECOMPLETIONQUEUE;
    _ = LPFN_RIOCREATECOMPLETIONQUEUE;
    _ = LPFN_RIOCREATEREQUESTQUEUE;
    _ = LPFN_RIODEQUEUECOMPLETION;
    _ = LPFN_RIODEREGISTERBUFFER;
    _ = LPFN_RIONOTIFY;
    _ = LPFN_RIOREGISTERBUFFER;
    _ = LPFN_RIORESIZECOMPLETIONQUEUE;
    _ = LPFN_RIORESIZEREQUESTQUEUE;
    _ = LPBLOCKINGCALLBACK;
    _ = LPWSAUSERAPC;
    _ = LPWSPACCEPT;
    _ = LPWSPADDRESSTOSTRING;
    _ = LPWSPASYNCSELECT;
    _ = LPWSPBIND;
    _ = LPWSPCANCELBLOCKINGCALL;
    _ = LPWSPCLEANUP;
    _ = LPWSPCLOSESOCKET;
    _ = LPWSPCONNECT;
    _ = LPWSPDUPLICATESOCKET;
    _ = LPWSPENUMNETWORKEVENTS;
    _ = LPWSPEVENTSELECT;
    _ = LPWSPGETOVERLAPPEDRESULT;
    _ = LPWSPGETPEERNAME;
    _ = LPWSPGETSOCKNAME;
    _ = LPWSPGETSOCKOPT;
    _ = LPWSPGETQOSBYNAME;
    _ = LPWSPIOCTL;
    _ = LPWSPJOINLEAF;
    _ = LPWSPLISTEN;
    _ = LPWSPRECV;
    _ = LPWSPRECVDISCONNECT;
    _ = LPWSPRECVFROM;
    _ = LPWSPSELECT;
    _ = LPWSPSEND;
    _ = LPWSPSENDDISCONNECT;
    _ = LPWSPSENDTO;
    _ = LPWSPSETSOCKOPT;
    _ = LPWSPSHUTDOWN;
    _ = LPWSPSOCKET;
    _ = LPWSPSTRINGTOADDRESS;
    _ = LPWPUCLOSEEVENT;
    _ = LPWPUCLOSESOCKETHANDLE;
    _ = LPWPUCREATEEVENT;
    _ = LPWPUCREATESOCKETHANDLE;
    _ = LPWPUFDISSET;
    _ = LPWPUGETPROVIDERPATH;
    _ = LPWPUMODIFYIFSHANDLE;
    _ = LPWPUPOSTMESSAGE;
    _ = LPWPUQUERYBLOCKINGCALLBACK;
    _ = LPWPUQUERYSOCKETHANDLECONTEXT;
    _ = LPWPUQUEUEAPC;
    _ = LPWPURESETEVENT;
    _ = LPWPUSETEVENT;
    _ = LPWPUOPENCURRENTTHREAD;
    _ = LPWPUCLOSETHREAD;
    _ = LPWPUCOMPLETEOVERLAPPEDREQUEST;
    _ = LPWSPSTARTUP;
    _ = LPWSCENUMPROTOCOLS;
    _ = LPWSCDEINSTALLPROVIDER;
    _ = LPWSCINSTALLPROVIDER;
    _ = LPWSCGETPROVIDERPATH;
    _ = LPWSCUPDATEPROVIDER;
    _ = LPWSCINSTALLNAMESPACE;
    _ = LPWSCUNINSTALLNAMESPACE;
    _ = LPWSCENABLENSPROVIDER;
    _ = LPNSPCLEANUP;
    _ = LPNSPLOOKUPSERVICEBEGIN;
    _ = LPNSPLOOKUPSERVICENEXT;
    _ = LPNSPIOCTL;
    _ = LPNSPLOOKUPSERVICEEND;
    _ = LPNSPSETSERVICE;
    _ = LPNSPINSTALLSERVICECLASS;
    _ = LPNSPREMOVESERVICECLASS;
    _ = LPNSPGETSERVICECLASSINFO;
    _ = LPNSPSTARTUP;
    _ = LPNSPV2STARTUP;
    _ = LPNSPV2CLEANUP;
    _ = LPNSPV2LOOKUPSERVICEBEGIN;
    _ = LPNSPV2LOOKUPSERVICENEXTEX;
    _ = LPNSPV2LOOKUPSERVICEEND;
    _ = LPNSPV2SETSERVICEEX;
    _ = LPNSPV2CLIENTSESSIONRUNDOWN;
    _ = LPFN_NSPAPI;
    _ = LPSERVICE_CALLBACK_PROC;
    _ = LPLOOKUPSERVICE_COMPLETION_ROUTINE;
    _ = LPWSCWRITEPROVIDERORDER;
    _ = LPWSCWRITENAMESPACEORDER;

    const constant_export_count = 10;
    const type_export_count = 299;
    const enum_value_export_count = 140;
    const com_iface_id_export_count = 0;
    const com_class_id_export_count = 0;
    const func_export_count = 170;
    const unicode_alias_count = 38;
    const import_count = 16;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
