//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (9877)
//--------------------------------------------------------------------------------
pub const TRUE : i32 = 1;
pub const FALSE : i32 = 0;
pub const RT_CURSOR : u16 = 1;
pub const RT_BITMAP : u16 = 2;
pub const RT_ICON : u16 = 3;
pub const RT_MENU : u16 = 4;
pub const RT_DIALOG : u16 = 5;
pub const RT_STRING : u16 = 6;
pub const RT_FONTDIR : u16 = 7;
pub const RT_FONT : u16 = 8;
pub const RT_ACCELERATOR : u16 = 9;
pub const RT_RCDATA : u16 = 10;
pub const RT_MESSAGETABLE : u16 = 11;
pub const DIFFERENCE : i32 = 11;
pub const RT_GROUP_CURSOR : u16 = 12;
pub const RT_GROUP_ICON : u16 = 14;
pub const RT_VERSION : u16 = 16;
pub const RT_DLGINCLUDE : u16 = 17;
pub const RT_PLUGPLAY : u16 = 19;
pub const RT_VXD : u16 = 20;
pub const RT_ANICURSOR : u16 = 21;
pub const RT_ANIICON : u16 = 22;
pub const RT_HTML : u16 = 23;
pub const RT_MANIFEST : u16 = 24;
pub const CREATEPROCESS_MANIFEST_RESOURCE_ID : u16 = 1;
pub const ISOLATIONAWARE_MANIFEST_RESOURCE_ID : u16 = 2;
pub const ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID : u16 = 3;
pub const ISOLATIONPOLICY_MANIFEST_RESOURCE_ID : u16 = 4;
pub const ISOLATIONPOLICY_BROWSER_MANIFEST_RESOURCE_ID : u16 = 5;
pub const MINIMUM_RESERVED_MANIFEST_RESOURCE_ID : u16 = 1;
pub const MAXIMUM_RESERVED_MANIFEST_RESOURCE_ID : u16 = 16;
pub const SETWALLPAPER_DEFAULT : i32 = -1;
pub const SB_HORZ : i32 = 0;
pub const SB_VERT : i32 = 1;
pub const SB_CTL : i32 = 2;
pub const SB_BOTH : i32 = 3;
pub const SB_LINEUP : i32 = 0;
pub const SB_LINELEFT : i32 = 0;
pub const SB_LINEDOWN : i32 = 1;
pub const SB_LINERIGHT : i32 = 1;
pub const SB_PAGEUP : i32 = 2;
pub const SB_PAGELEFT : i32 = 2;
pub const SB_PAGEDOWN : i32 = 3;
pub const SB_PAGERIGHT : i32 = 3;
pub const SB_THUMBPOSITION : i32 = 4;
pub const SB_THUMBTRACK : i32 = 5;
pub const SB_TOP : i32 = 6;
pub const SB_LEFT : i32 = 6;
pub const SB_BOTTOM : i32 = 7;
pub const SB_RIGHT : i32 = 7;
pub const SB_ENDSCROLL : i32 = 8;
pub const SW_HIDE : i32 = 0;
pub const SW_SHOWNORMAL : i32 = 1;
pub const SW_NORMAL : i32 = 1;
pub const SW_SHOWMINIMIZED : i32 = 2;
pub const SW_SHOWMAXIMIZED : i32 = 3;
pub const SW_MAXIMIZE : i32 = 3;
pub const SW_SHOWNOACTIVATE : i32 = 4;
pub const SW_SHOW : i32 = 5;
pub const SW_MINIMIZE : i32 = 6;
pub const SW_SHOWMINNOACTIVE : i32 = 7;
pub const SW_SHOWNA : i32 = 8;
pub const SW_RESTORE : i32 = 9;
pub const SW_SHOWDEFAULT : i32 = 10;
pub const SW_FORCEMINIMIZE : i32 = 11;
pub const SW_MAX : i32 = 11;
pub const HIDE_WINDOW : i32 = 0;
pub const SHOW_OPENWINDOW : i32 = 1;
pub const SHOW_ICONWINDOW : i32 = 2;
pub const SHOW_FULLSCREEN : i32 = 3;
pub const SHOW_OPENNOACTIVATE : i32 = 4;
pub const SW_PARENTCLOSING : i32 = 1;
pub const SW_OTHERZOOM : i32 = 2;
pub const SW_PARENTOPENING : i32 = 3;
pub const SW_OTHERUNZOOM : i32 = 4;
pub const AW_HOR_POSITIVE : i32 = 1;
pub const AW_HOR_NEGATIVE : i32 = 2;
pub const AW_VER_POSITIVE : i32 = 4;
pub const AW_VER_NEGATIVE : i32 = 8;
pub const AW_CENTER : i32 = 16;
pub const AW_HIDE : i32 = 65536;
pub const AW_ACTIVATE : i32 = 131072;
pub const AW_SLIDE : i32 = 262144;
pub const AW_BLEND : i32 = 524288;
pub const KF_EXTENDED : i32 = 256;
pub const KF_DLGMODE : i32 = 2048;
pub const KF_MENUMODE : i32 = 4096;
pub const KF_ALTDOWN : i32 = 8192;
pub const KF_REPEAT : i32 = 16384;
pub const KF_UP : i32 = 32768;
pub const VK_LBUTTON : i32 = 1;
pub const VK_RBUTTON : i32 = 2;
pub const VK_CANCEL : i32 = 3;
pub const VK_MBUTTON : i32 = 4;
pub const VK_XBUTTON1 : i32 = 5;
pub const VK_XBUTTON2 : i32 = 6;
pub const VK_BACK : i32 = 8;
pub const VK_TAB : i32 = 9;
pub const VK_CLEAR : i32 = 12;
pub const VK_RETURN : i32 = 13;
pub const VK_SHIFT : i32 = 16;
pub const VK_CONTROL : i32 = 17;
pub const VK_MENU : i32 = 18;
pub const VK_PAUSE : i32 = 19;
pub const VK_CAPITAL : i32 = 20;
pub const VK_KANA : i32 = 21;
pub const VK_HANGEUL : i32 = 21;
pub const VK_HANGUL : i32 = 21;
pub const VK_JUNJA : i32 = 23;
pub const VK_FINAL : i32 = 24;
pub const VK_HANJA : i32 = 25;
pub const VK_KANJI : i32 = 25;
pub const VK_ESCAPE : i32 = 27;
pub const VK_CONVERT : i32 = 28;
pub const VK_NONCONVERT : i32 = 29;
pub const VK_ACCEPT : i32 = 30;
pub const VK_MODECHANGE : i32 = 31;
pub const VK_SPACE : i32 = 32;
pub const VK_PRIOR : i32 = 33;
pub const VK_NEXT : i32 = 34;
pub const VK_END : i32 = 35;
pub const VK_HOME : i32 = 36;
pub const VK_LEFT : i32 = 37;
pub const VK_UP : i32 = 38;
pub const VK_RIGHT : i32 = 39;
pub const VK_DOWN : i32 = 40;
pub const VK_SELECT : i32 = 41;
pub const VK_PRINT : i32 = 42;
pub const VK_EXECUTE : i32 = 43;
pub const VK_SNAPSHOT : i32 = 44;
pub const VK_INSERT : i32 = 45;
pub const VK_DELETE : i32 = 46;
pub const VK_HELP : i32 = 47;
pub const VK_LWIN : i32 = 91;
pub const VK_RWIN : i32 = 92;
pub const VK_APPS : i32 = 93;
pub const VK_SLEEP : i32 = 95;
pub const VK_NUMPAD0 : i32 = 96;
pub const VK_NUMPAD1 : i32 = 97;
pub const VK_NUMPAD2 : i32 = 98;
pub const VK_NUMPAD3 : i32 = 99;
pub const VK_NUMPAD4 : i32 = 100;
pub const VK_NUMPAD5 : i32 = 101;
pub const VK_NUMPAD6 : i32 = 102;
pub const VK_NUMPAD7 : i32 = 103;
pub const VK_NUMPAD8 : i32 = 104;
pub const VK_NUMPAD9 : i32 = 105;
pub const VK_MULTIPLY : i32 = 106;
pub const VK_ADD : i32 = 107;
pub const VK_SEPARATOR : i32 = 108;
pub const VK_SUBTRACT : i32 = 109;
pub const VK_DECIMAL : i32 = 110;
pub const VK_DIVIDE : i32 = 111;
pub const VK_F1 : i32 = 112;
pub const VK_F2 : i32 = 113;
pub const VK_F3 : i32 = 114;
pub const VK_F4 : i32 = 115;
pub const VK_F5 : i32 = 116;
pub const VK_F6 : i32 = 117;
pub const VK_F7 : i32 = 118;
pub const VK_F8 : i32 = 119;
pub const VK_F9 : i32 = 120;
pub const VK_F10 : i32 = 121;
pub const VK_F11 : i32 = 122;
pub const VK_F12 : i32 = 123;
pub const VK_F13 : i32 = 124;
pub const VK_F14 : i32 = 125;
pub const VK_F15 : i32 = 126;
pub const VK_F16 : i32 = 127;
pub const VK_F17 : i32 = 128;
pub const VK_F18 : i32 = 129;
pub const VK_F19 : i32 = 130;
pub const VK_F20 : i32 = 131;
pub const VK_F21 : i32 = 132;
pub const VK_F22 : i32 = 133;
pub const VK_F23 : i32 = 134;
pub const VK_F24 : i32 = 135;
pub const VK_NAVIGATION_VIEW : i32 = 136;
pub const VK_NAVIGATION_MENU : i32 = 137;
pub const VK_NAVIGATION_UP : i32 = 138;
pub const VK_NAVIGATION_DOWN : i32 = 139;
pub const VK_NAVIGATION_LEFT : i32 = 140;
pub const VK_NAVIGATION_RIGHT : i32 = 141;
pub const VK_NAVIGATION_ACCEPT : i32 = 142;
pub const VK_NAVIGATION_CANCEL : i32 = 143;
pub const VK_NUMLOCK : i32 = 144;
pub const VK_SCROLL : i32 = 145;
pub const VK_OEM_NEC_EQUAL : i32 = 146;
pub const VK_OEM_FJ_JISHO : i32 = 146;
pub const VK_OEM_FJ_MASSHOU : i32 = 147;
pub const VK_OEM_FJ_TOUROKU : i32 = 148;
pub const VK_OEM_FJ_LOYA : i32 = 149;
pub const VK_OEM_FJ_ROYA : i32 = 150;
pub const VK_LSHIFT : i32 = 160;
pub const VK_RSHIFT : i32 = 161;
pub const VK_LCONTROL : i32 = 162;
pub const VK_RCONTROL : i32 = 163;
pub const VK_LMENU : i32 = 164;
pub const VK_RMENU : i32 = 165;
pub const VK_BROWSER_BACK : i32 = 166;
pub const VK_BROWSER_FORWARD : i32 = 167;
pub const VK_BROWSER_REFRESH : i32 = 168;
pub const VK_BROWSER_STOP : i32 = 169;
pub const VK_BROWSER_SEARCH : i32 = 170;
pub const VK_BROWSER_FAVORITES : i32 = 171;
pub const VK_BROWSER_HOME : i32 = 172;
pub const VK_VOLUME_MUTE : i32 = 173;
pub const VK_VOLUME_DOWN : i32 = 174;
pub const VK_VOLUME_UP : i32 = 175;
pub const VK_MEDIA_NEXT_TRACK : i32 = 176;
pub const VK_MEDIA_PREV_TRACK : i32 = 177;
pub const VK_MEDIA_STOP : i32 = 178;
pub const VK_MEDIA_PLAY_PAUSE : i32 = 179;
pub const VK_LAUNCH_MAIL : i32 = 180;
pub const VK_LAUNCH_MEDIA_SELECT : i32 = 181;
pub const VK_LAUNCH_APP1 : i32 = 182;
pub const VK_LAUNCH_APP2 : i32 = 183;
pub const VK_OEM_1 : i32 = 186;
pub const VK_OEM_PLUS : i32 = 187;
pub const VK_OEM_COMMA : i32 = 188;
pub const VK_OEM_MINUS : i32 = 189;
pub const VK_OEM_PERIOD : i32 = 190;
pub const VK_OEM_2 : i32 = 191;
pub const VK_OEM_3 : i32 = 192;
pub const VK_GAMEPAD_A : i32 = 195;
pub const VK_GAMEPAD_B : i32 = 196;
pub const VK_GAMEPAD_X : i32 = 197;
pub const VK_GAMEPAD_Y : i32 = 198;
pub const VK_GAMEPAD_RIGHT_SHOULDER : i32 = 199;
pub const VK_GAMEPAD_LEFT_SHOULDER : i32 = 200;
pub const VK_GAMEPAD_LEFT_TRIGGER : i32 = 201;
pub const VK_GAMEPAD_RIGHT_TRIGGER : i32 = 202;
pub const VK_GAMEPAD_DPAD_UP : i32 = 203;
pub const VK_GAMEPAD_DPAD_DOWN : i32 = 204;
pub const VK_GAMEPAD_DPAD_LEFT : i32 = 205;
pub const VK_GAMEPAD_DPAD_RIGHT : i32 = 206;
pub const VK_GAMEPAD_MENU : i32 = 207;
pub const VK_GAMEPAD_VIEW : i32 = 208;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON : i32 = 209;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON : i32 = 210;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_UP : i32 = 211;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_DOWN : i32 = 212;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT : i32 = 213;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_LEFT : i32 = 214;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_UP : i32 = 215;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN : i32 = 216;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT : i32 = 217;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT : i32 = 218;
pub const VK_OEM_4 : i32 = 219;
pub const VK_OEM_5 : i32 = 220;
pub const VK_OEM_6 : i32 = 221;
pub const VK_OEM_7 : i32 = 222;
pub const VK_OEM_8 : i32 = 223;
pub const VK_OEM_AX : i32 = 225;
pub const VK_OEM_102 : i32 = 226;
pub const VK_ICO_HELP : i32 = 227;
pub const VK_ICO_00 : i32 = 228;
pub const VK_PROCESSKEY : i32 = 229;
pub const VK_ICO_CLEAR : i32 = 230;
pub const VK_PACKET : i32 = 231;
pub const VK_OEM_RESET : i32 = 233;
pub const VK_OEM_JUMP : i32 = 234;
pub const VK_OEM_PA1 : i32 = 235;
pub const VK_OEM_PA2 : i32 = 236;
pub const VK_OEM_PA3 : i32 = 237;
pub const VK_OEM_WSCTRL : i32 = 238;
pub const VK_OEM_CUSEL : i32 = 239;
pub const VK_OEM_ATTN : i32 = 240;
pub const VK_OEM_FINISH : i32 = 241;
pub const VK_OEM_COPY : i32 = 242;
pub const VK_OEM_AUTO : i32 = 243;
pub const VK_OEM_ENLW : i32 = 244;
pub const VK_OEM_BACKTAB : i32 = 245;
pub const VK_ATTN : i32 = 246;
pub const VK_CRSEL : i32 = 247;
pub const VK_EXSEL : i32 = 248;
pub const VK_EREOF : i32 = 249;
pub const VK_PLAY : i32 = 250;
pub const VK_ZOOM : i32 = 251;
pub const VK_NONAME : i32 = 252;
pub const VK_PA1 : i32 = 253;
pub const VK_OEM_CLEAR : i32 = 254;
pub const WH_MIN : i32 = -1;
pub const WH_MSGFILTER : i32 = -1;
pub const WH_JOURNALRECORD : i32 = 0;
pub const WH_JOURNALPLAYBACK : i32 = 1;
pub const WH_KEYBOARD : i32 = 2;
pub const WH_GETMESSAGE : i32 = 3;
pub const WH_CALLWNDPROC : i32 = 4;
pub const WH_CBT : i32 = 5;
pub const WH_SYSMSGFILTER : i32 = 6;
pub const WH_MOUSE : i32 = 7;
pub const WH_HARDWARE : i32 = 8;
pub const WH_DEBUG : i32 = 9;
pub const WH_SHELL : i32 = 10;
pub const WH_FOREGROUNDIDLE : i32 = 11;
pub const WH_CALLWNDPROCRET : i32 = 12;
pub const WH_KEYBOARD_LL : i32 = 13;
pub const WH_MOUSE_LL : i32 = 14;
pub const WH_MAX : i32 = 14;
pub const WH_MINHOOK : i32 = -1;
pub const WH_MAXHOOK : i32 = 14;
pub const HC_ACTION : i32 = 0;
pub const HC_GETNEXT : i32 = 1;
pub const HC_SKIP : i32 = 2;
pub const HC_NOREMOVE : i32 = 3;
pub const HC_NOREM : i32 = 3;
pub const HC_SYSMODALON : i32 = 4;
pub const HC_SYSMODALOFF : i32 = 5;
pub const HCBT_MOVESIZE : i32 = 0;
pub const HCBT_MINMAX : i32 = 1;
pub const HCBT_QS : i32 = 2;
pub const HCBT_CREATEWND : i32 = 3;
pub const HCBT_DESTROYWND : i32 = 4;
pub const HCBT_ACTIVATE : i32 = 5;
pub const HCBT_CLICKSKIPPED : i32 = 6;
pub const HCBT_KEYSKIPPED : i32 = 7;
pub const HCBT_SYSCOMMAND : i32 = 8;
pub const HCBT_SETFOCUS : i32 = 9;
pub const WTS_CONSOLE_CONNECT : i32 = 1;
pub const WTS_CONSOLE_DISCONNECT : i32 = 2;
pub const WTS_REMOTE_CONNECT : i32 = 3;
pub const WTS_REMOTE_DISCONNECT : i32 = 4;
pub const WTS_SESSION_LOGON : i32 = 5;
pub const WTS_SESSION_LOGOFF : i32 = 6;
pub const WTS_SESSION_LOCK : i32 = 7;
pub const WTS_SESSION_UNLOCK : i32 = 8;
pub const WTS_SESSION_REMOTE_CONTROL : i32 = 9;
pub const WTS_SESSION_CREATE : i32 = 10;
pub const WTS_SESSION_TERMINATE : i32 = 11;
pub const MSGF_DIALOGBOX : i32 = 0;
pub const MSGF_MESSAGEBOX : i32 = 1;
pub const MSGF_MENU : i32 = 2;
pub const MSGF_SCROLLBAR : i32 = 5;
pub const MSGF_NEXTWINDOW : i32 = 6;
pub const MSGF_MAX : i32 = 8;
pub const MSGF_USER : i32 = 4096;
pub const HSHELL_WINDOWCREATED : i32 = 1;
pub const HSHELL_WINDOWDESTROYED : i32 = 2;
pub const HSHELL_ACTIVATESHELLWINDOW : i32 = 3;
pub const HSHELL_WINDOWACTIVATED : i32 = 4;
pub const HSHELL_GETMINRECT : i32 = 5;
pub const HSHELL_REDRAW : i32 = 6;
pub const HSHELL_TASKMAN : i32 = 7;
pub const HSHELL_LANGUAGE : i32 = 8;
pub const HSHELL_SYSMENU : i32 = 9;
pub const HSHELL_ENDTASK : i32 = 10;
pub const HSHELL_ACCESSIBILITYSTATE : i32 = 11;
pub const HSHELL_APPCOMMAND : i32 = 12;
pub const HSHELL_WINDOWREPLACED : i32 = 13;
pub const HSHELL_WINDOWREPLACING : i32 = 14;
pub const HSHELL_MONITORCHANGED : i32 = 16;
pub const HSHELL_HIGHBIT : i32 = 32768;
pub const HSHELL_FLASH : i32 = 32774;
pub const HSHELL_RUDEAPPACTIVATED : i32 = 32772;
pub const APPCOMMAND_BROWSER_BACKWARD : i32 = 1;
pub const APPCOMMAND_BROWSER_FORWARD : i32 = 2;
pub const APPCOMMAND_BROWSER_REFRESH : i32 = 3;
pub const APPCOMMAND_BROWSER_STOP : i32 = 4;
pub const APPCOMMAND_BROWSER_SEARCH : i32 = 5;
pub const APPCOMMAND_BROWSER_FAVORITES : i32 = 6;
pub const APPCOMMAND_BROWSER_HOME : i32 = 7;
pub const APPCOMMAND_VOLUME_MUTE : i32 = 8;
pub const APPCOMMAND_VOLUME_DOWN : i32 = 9;
pub const APPCOMMAND_VOLUME_UP : i32 = 10;
pub const APPCOMMAND_MEDIA_NEXTTRACK : i32 = 11;
pub const APPCOMMAND_MEDIA_PREVIOUSTRACK : i32 = 12;
pub const APPCOMMAND_MEDIA_STOP : i32 = 13;
pub const APPCOMMAND_MEDIA_PLAY_PAUSE : i32 = 14;
pub const APPCOMMAND_LAUNCH_MAIL : i32 = 15;
pub const APPCOMMAND_LAUNCH_MEDIA_SELECT : i32 = 16;
pub const APPCOMMAND_LAUNCH_APP1 : i32 = 17;
pub const APPCOMMAND_LAUNCH_APP2 : i32 = 18;
pub const APPCOMMAND_BASS_DOWN : i32 = 19;
pub const APPCOMMAND_BASS_BOOST : i32 = 20;
pub const APPCOMMAND_BASS_UP : i32 = 21;
pub const APPCOMMAND_TREBLE_DOWN : i32 = 22;
pub const APPCOMMAND_TREBLE_UP : i32 = 23;
pub const APPCOMMAND_MICROPHONE_VOLUME_MUTE : i32 = 24;
pub const APPCOMMAND_MICROPHONE_VOLUME_DOWN : i32 = 25;
pub const APPCOMMAND_MICROPHONE_VOLUME_UP : i32 = 26;
pub const APPCOMMAND_HELP : i32 = 27;
pub const APPCOMMAND_FIND : i32 = 28;
pub const APPCOMMAND_NEW : i32 = 29;
pub const APPCOMMAND_OPEN : i32 = 30;
pub const APPCOMMAND_CLOSE : i32 = 31;
pub const APPCOMMAND_SAVE : i32 = 32;
pub const APPCOMMAND_PRINT : i32 = 33;
pub const APPCOMMAND_UNDO : i32 = 34;
pub const APPCOMMAND_REDO : i32 = 35;
pub const APPCOMMAND_COPY : i32 = 36;
pub const APPCOMMAND_CUT : i32 = 37;
pub const APPCOMMAND_PASTE : i32 = 38;
pub const APPCOMMAND_REPLY_TO_MAIL : i32 = 39;
pub const APPCOMMAND_FORWARD_MAIL : i32 = 40;
pub const APPCOMMAND_SEND_MAIL : i32 = 41;
pub const APPCOMMAND_SPELL_CHECK : i32 = 42;
pub const APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE : i32 = 43;
pub const APPCOMMAND_MIC_ON_OFF_TOGGLE : i32 = 44;
pub const APPCOMMAND_CORRECTION_LIST : i32 = 45;
pub const APPCOMMAND_MEDIA_PLAY : i32 = 46;
pub const APPCOMMAND_MEDIA_PAUSE : i32 = 47;
pub const APPCOMMAND_MEDIA_RECORD : i32 = 48;
pub const APPCOMMAND_MEDIA_FAST_FORWARD : i32 = 49;
pub const APPCOMMAND_MEDIA_REWIND : i32 = 50;
pub const APPCOMMAND_MEDIA_CHANNEL_UP : i32 = 51;
pub const APPCOMMAND_MEDIA_CHANNEL_DOWN : i32 = 52;
pub const APPCOMMAND_DELETE : i32 = 53;
pub const APPCOMMAND_DWM_FLIP3D : i32 = 54;
pub const FAPPCOMMAND_MOUSE : i32 = 32768;
pub const FAPPCOMMAND_KEY : i32 = 0;
pub const FAPPCOMMAND_OEM : i32 = 4096;
pub const FAPPCOMMAND_MASK : i32 = 61440;
pub const LLKHF_EXTENDED : i32 = 1;
pub const LLKHF_INJECTED : i32 = 16;
pub const LLKHF_ALTDOWN : i32 = 32;
pub const LLKHF_UP : i32 = 128;
pub const LLKHF_LOWER_IL_INJECTED : i32 = 2;
pub const LLMHF_INJECTED : i32 = 1;
pub const LLMHF_LOWER_IL_INJECTED : i32 = 2;
pub const HKL_PREV : i32 = 0;
pub const HKL_NEXT : i32 = 1;
pub const KLF_ACTIVATE : i32 = 1;
pub const KLF_SUBSTITUTE_OK : i32 = 2;
pub const KLF_REORDER : i32 = 8;
pub const KLF_REPLACELANG : i32 = 16;
pub const KLF_NOTELLSHELL : i32 = 128;
pub const KLF_SETFORPROCESS : i32 = 256;
pub const KLF_SHIFTLOCK : i32 = 65536;
pub const KLF_RESET : i32 = 1073741824;
pub const INPUTLANGCHANGE_SYSCHARSET : i32 = 1;
pub const INPUTLANGCHANGE_FORWARD : i32 = 2;
pub const INPUTLANGCHANGE_BACKWARD : i32 = 4;
pub const KL_NAMELENGTH : i32 = 9;
pub const GMMP_USE_DISPLAY_POINTS : i32 = 1;
pub const GMMP_USE_HIGH_RESOLUTION_POINTS : i32 = 2;
pub const DESKTOP_READOBJECTS : i32 = 1;
pub const DESKTOP_CREATEWINDOW : i32 = 2;
pub const DESKTOP_CREATEMENU : i32 = 4;
pub const DESKTOP_HOOKCONTROL : i32 = 8;
pub const DESKTOP_JOURNALRECORD : i32 = 16;
pub const DESKTOP_JOURNALPLAYBACK : i32 = 32;
pub const DESKTOP_ENUMERATE : i32 = 64;
pub const DESKTOP_WRITEOBJECTS : i32 = 128;
pub const DESKTOP_SWITCHDESKTOP : i32 = 256;
pub const DF_ALLOWOTHERACCOUNTHOOK : i32 = 1;
pub const WINSTA_ENUMDESKTOPS : i32 = 1;
pub const WINSTA_READATTRIBUTES : i32 = 2;
pub const WINSTA_ACCESSCLIPBOARD : i32 = 4;
pub const WINSTA_CREATEDESKTOP : i32 = 8;
pub const WINSTA_WRITEATTRIBUTES : i32 = 16;
pub const WINSTA_ACCESSGLOBALATOMS : i32 = 32;
pub const WINSTA_EXITWINDOWS : i32 = 64;
pub const WINSTA_ENUMERATE : i32 = 256;
pub const WINSTA_READSCREEN : i32 = 512;
pub const WINSTA_ALL_ACCESS : i32 = 895;
pub const CWF_CREATE_ONLY : i32 = 1;
pub const WSF_VISIBLE : i32 = 1;
pub const UOI_FLAGS : i32 = 1;
pub const UOI_NAME : i32 = 2;
pub const UOI_TYPE : i32 = 3;
pub const UOI_USER_SID : i32 = 4;
pub const UOI_HEAPSIZE : i32 = 5;
pub const UOI_IO : i32 = 6;
pub const UOI_TIMERPROC_EXCEPTION_SUPPRESSION : i32 = 7;
pub const GWL_WNDPROC : i32 = -4;
pub const GWL_HINSTANCE : i32 = -6;
pub const GWL_HWNDPARENT : i32 = -8;
pub const GWL_STYLE : i32 = -16;
pub const GWL_EXSTYLE : i32 = -20;
pub const GWL_USERDATA : i32 = -21;
pub const GWL_ID : i32 = -12;
pub const GWLP_WNDPROC : i32 = -4;
pub const GWLP_HINSTANCE : i32 = -6;
pub const GWLP_HWNDPARENT : i32 = -8;
pub const GWLP_USERDATA : i32 = -21;
pub const GWLP_ID : i32 = -12;
pub const GCL_MENUNAME : i32 = -8;
pub const GCL_HBRBACKGROUND : i32 = -10;
pub const GCL_HCURSOR : i32 = -12;
pub const GCL_HICON : i32 = -14;
pub const GCL_HMODULE : i32 = -16;
pub const GCL_CBWNDEXTRA : i32 = -18;
pub const GCL_CBCLSEXTRA : i32 = -20;
pub const GCL_WNDPROC : i32 = -24;
pub const GCL_STYLE : i32 = -26;
pub const GCW_ATOM : i32 = -32;
pub const GCL_HICONSM : i32 = -34;
pub const GCLP_MENUNAME : i32 = -8;
pub const GCLP_HBRBACKGROUND : i32 = -10;
pub const GCLP_HCURSOR : i32 = -12;
pub const GCLP_HICON : i32 = -14;
pub const GCLP_HMODULE : i32 = -16;
pub const GCLP_WNDPROC : i32 = -24;
pub const GCLP_HICONSM : i32 = -34;
pub const WM_NULL : i32 = 0;
pub const WM_CREATE : i32 = 1;
pub const WM_DESTROY : i32 = 2;
pub const WM_MOVE : i32 = 3;
pub const WM_SIZE : i32 = 5;
pub const WM_ACTIVATE : i32 = 6;
pub const WA_INACTIVE : i32 = 0;
pub const WA_ACTIVE : i32 = 1;
pub const WA_CLICKACTIVE : i32 = 2;
pub const WM_SETFOCUS : i32 = 7;
pub const WM_KILLFOCUS : i32 = 8;
pub const WM_ENABLE : i32 = 10;
pub const WM_SETREDRAW : i32 = 11;
pub const WM_SETTEXT : i32 = 12;
pub const WM_GETTEXT : i32 = 13;
pub const WM_GETTEXTLENGTH : i32 = 14;
pub const WM_PAINT : i32 = 15;
pub const WM_CLOSE : i32 = 16;
pub const WM_QUERYENDSESSION : i32 = 17;
pub const WM_QUERYOPEN : i32 = 19;
pub const WM_ENDSESSION : i32 = 22;
pub const WM_QUIT : i32 = 18;
pub const WM_ERASEBKGND : i32 = 20;
pub const WM_SYSCOLORCHANGE : i32 = 21;
pub const WM_SHOWWINDOW : i32 = 24;
pub const WM_WININICHANGE : i32 = 26;
pub const WM_SETTINGCHANGE : i32 = 26;
pub const WM_DEVMODECHANGE : i32 = 27;
pub const WM_ACTIVATEAPP : i32 = 28;
pub const WM_FONTCHANGE : i32 = 29;
pub const WM_TIMECHANGE : i32 = 30;
pub const WM_CANCELMODE : i32 = 31;
pub const WM_SETCURSOR : i32 = 32;
pub const WM_MOUSEACTIVATE : i32 = 33;
pub const WM_CHILDACTIVATE : i32 = 34;
pub const WM_QUEUESYNC : i32 = 35;
pub const WM_GETMINMAXINFO : i32 = 36;
pub const WM_PAINTICON : i32 = 38;
pub const WM_ICONERASEBKGND : i32 = 39;
pub const WM_NEXTDLGCTL : i32 = 40;
pub const WM_SPOOLERSTATUS : i32 = 42;
pub const WM_DRAWITEM : i32 = 43;
pub const WM_MEASUREITEM : i32 = 44;
pub const WM_DELETEITEM : i32 = 45;
pub const WM_VKEYTOITEM : i32 = 46;
pub const WM_CHARTOITEM : i32 = 47;
pub const WM_SETFONT : i32 = 48;
pub const WM_GETFONT : i32 = 49;
pub const WM_SETHOTKEY : i32 = 50;
pub const WM_GETHOTKEY : i32 = 51;
pub const WM_QUERYDRAGICON : i32 = 55;
pub const WM_COMPAREITEM : i32 = 57;
pub const WM_GETOBJECT : i32 = 61;
pub const WM_COMPACTING : i32 = 65;
pub const WM_COMMNOTIFY : i32 = 68;
pub const WM_WINDOWPOSCHANGING : i32 = 70;
pub const WM_WINDOWPOSCHANGED : i32 = 71;
pub const WM_POWER : i32 = 72;
pub const PWR_OK : i32 = 1;
pub const PWR_FAIL : i32 = -1;
pub const PWR_SUSPENDREQUEST : i32 = 1;
pub const PWR_SUSPENDRESUME : i32 = 2;
pub const PWR_CRITICALRESUME : i32 = 3;
pub const WM_COPYDATA : i32 = 74;
pub const WM_CANCELJOURNAL : i32 = 75;
pub const WM_NOTIFY : i32 = 78;
pub const WM_INPUTLANGCHANGEREQUEST : i32 = 80;
pub const WM_INPUTLANGCHANGE : i32 = 81;
pub const WM_TCARD : i32 = 82;
pub const WM_HELP : i32 = 83;
pub const WM_USERCHANGED : i32 = 84;
pub const WM_NOTIFYFORMAT : i32 = 85;
pub const NFR_ANSI : i32 = 1;
pub const NFR_UNICODE : i32 = 2;
pub const NF_QUERY : i32 = 3;
pub const NF_REQUERY : i32 = 4;
pub const WM_CONTEXTMENU : i32 = 123;
pub const WM_STYLECHANGING : i32 = 124;
pub const WM_STYLECHANGED : i32 = 125;
pub const WM_DISPLAYCHANGE : i32 = 126;
pub const WM_GETICON : i32 = 127;
pub const WM_SETICON : i32 = 128;
pub const WM_NCCREATE : i32 = 129;
pub const WM_NCDESTROY : i32 = 130;
pub const WM_NCCALCSIZE : i32 = 131;
pub const WM_NCHITTEST : i32 = 132;
pub const WM_NCPAINT : i32 = 133;
pub const WM_NCACTIVATE : i32 = 134;
pub const WM_GETDLGCODE : i32 = 135;
pub const WM_SYNCPAINT : i32 = 136;
pub const WM_NCMOUSEMOVE : i32 = 160;
pub const WM_NCLBUTTONDOWN : i32 = 161;
pub const WM_NCLBUTTONUP : i32 = 162;
pub const WM_NCLBUTTONDBLCLK : i32 = 163;
pub const WM_NCRBUTTONDOWN : i32 = 164;
pub const WM_NCRBUTTONUP : i32 = 165;
pub const WM_NCRBUTTONDBLCLK : i32 = 166;
pub const WM_NCMBUTTONDOWN : i32 = 167;
pub const WM_NCMBUTTONUP : i32 = 168;
pub const WM_NCMBUTTONDBLCLK : i32 = 169;
pub const WM_NCXBUTTONDOWN : i32 = 171;
pub const WM_NCXBUTTONUP : i32 = 172;
pub const WM_NCXBUTTONDBLCLK : i32 = 173;
pub const WM_INPUT_DEVICE_CHANGE : i32 = 254;
pub const WM_INPUT : i32 = 255;
pub const WM_KEYFIRST : i32 = 256;
pub const WM_KEYDOWN : i32 = 256;
pub const WM_KEYUP : i32 = 257;
pub const WM_CHAR : i32 = 258;
pub const WM_DEADCHAR : i32 = 259;
pub const WM_SYSKEYDOWN : i32 = 260;
pub const WM_SYSKEYUP : i32 = 261;
pub const WM_SYSCHAR : i32 = 262;
pub const WM_SYSDEADCHAR : i32 = 263;
pub const WM_UNICHAR : i32 = 265;
pub const WM_KEYLAST : i32 = 265;
pub const UNICODE_NOCHAR : i32 = 65535;
pub const WM_IME_STARTCOMPOSITION : i32 = 269;
pub const WM_IME_ENDCOMPOSITION : i32 = 270;
pub const WM_IME_COMPOSITION : i32 = 271;
pub const WM_IME_KEYLAST : i32 = 271;
pub const WM_INITDIALOG : i32 = 272;
pub const WM_COMMAND : i32 = 273;
pub const WM_SYSCOMMAND : i32 = 274;
pub const WM_TIMER : i32 = 275;
pub const WM_HSCROLL : i32 = 276;
pub const WM_VSCROLL : i32 = 277;
pub const WM_INITMENU : i32 = 278;
pub const WM_INITMENUPOPUP : i32 = 279;
pub const WM_GESTURE : i32 = 281;
pub const WM_GESTURENOTIFY : i32 = 282;
pub const WM_MENUSELECT : i32 = 287;
pub const WM_MENUCHAR : i32 = 288;
pub const WM_ENTERIDLE : i32 = 289;
pub const WM_MENURBUTTONUP : i32 = 290;
pub const WM_MENUDRAG : i32 = 291;
pub const WM_MENUGETOBJECT : i32 = 292;
pub const WM_UNINITMENUPOPUP : i32 = 293;
pub const WM_MENUCOMMAND : i32 = 294;
pub const WM_CHANGEUISTATE : i32 = 295;
pub const WM_UPDATEUISTATE : i32 = 296;
pub const WM_QUERYUISTATE : i32 = 297;
pub const UIS_SET : i32 = 1;
pub const UIS_CLEAR : i32 = 2;
pub const UIS_INITIALIZE : i32 = 3;
pub const UISF_HIDEFOCUS : i32 = 1;
pub const UISF_HIDEACCEL : i32 = 2;
pub const UISF_ACTIVE : i32 = 4;
pub const WM_CTLCOLORMSGBOX : i32 = 306;
pub const WM_CTLCOLOREDIT : i32 = 307;
pub const WM_CTLCOLORLISTBOX : i32 = 308;
pub const WM_CTLCOLORBTN : i32 = 309;
pub const WM_CTLCOLORDLG : i32 = 310;
pub const WM_CTLCOLORSCROLLBAR : i32 = 311;
pub const WM_CTLCOLORSTATIC : i32 = 312;
pub const MN_GETHMENU : i32 = 481;
pub const WM_MOUSEFIRST : i32 = 512;
pub const WM_MOUSEMOVE : i32 = 512;
pub const WM_LBUTTONDOWN : i32 = 513;
pub const WM_LBUTTONUP : i32 = 514;
pub const WM_LBUTTONDBLCLK : i32 = 515;
pub const WM_RBUTTONDOWN : i32 = 516;
pub const WM_RBUTTONUP : i32 = 517;
pub const WM_RBUTTONDBLCLK : i32 = 518;
pub const WM_MBUTTONDOWN : i32 = 519;
pub const WM_MBUTTONUP : i32 = 520;
pub const WM_MBUTTONDBLCLK : i32 = 521;
pub const WM_MOUSEWHEEL : i32 = 522;
pub const WM_XBUTTONDOWN : i32 = 523;
pub const WM_XBUTTONUP : i32 = 524;
pub const WM_XBUTTONDBLCLK : i32 = 525;
pub const WM_MOUSEHWHEEL : i32 = 526;
pub const WM_MOUSELAST : i32 = 526;
pub const WHEEL_DELTA : i32 = 120;
pub const WHEEL_PAGESCROLL : u32 = 4294967295;
pub const XBUTTON1 : i32 = 1;
pub const XBUTTON2 : i32 = 2;
pub const WM_PARENTNOTIFY : i32 = 528;
pub const WM_ENTERMENULOOP : i32 = 529;
pub const WM_EXITMENULOOP : i32 = 530;
pub const WM_NEXTMENU : i32 = 531;
pub const WM_SIZING : i32 = 532;
pub const WM_CAPTURECHANGED : i32 = 533;
pub const WM_MOVING : i32 = 534;
pub const WM_POWERBROADCAST : i32 = 536;
pub const PBT_APMQUERYSUSPEND : i32 = 0;
pub const PBT_APMQUERYSTANDBY : i32 = 1;
pub const PBT_APMQUERYSUSPENDFAILED : i32 = 2;
pub const PBT_APMQUERYSTANDBYFAILED : i32 = 3;
pub const PBT_APMSUSPEND : i32 = 4;
pub const PBT_APMSTANDBY : i32 = 5;
pub const PBT_APMRESUMECRITICAL : i32 = 6;
pub const PBT_APMRESUMESUSPEND : i32 = 7;
pub const PBT_APMRESUMESTANDBY : i32 = 8;
pub const PBTF_APMRESUMEFROMFAILURE : i32 = 1;
pub const PBT_APMBATTERYLOW : i32 = 9;
pub const PBT_APMPOWERSTATUSCHANGE : i32 = 10;
pub const PBT_APMOEMEVENT : i32 = 11;
pub const PBT_APMRESUMEAUTOMATIC : i32 = 18;
pub const PBT_POWERSETTINGCHANGE : i32 = 32787;
pub const WM_DEVICECHANGE : i32 = 537;
pub const WM_MDICREATE : i32 = 544;
pub const WM_MDIDESTROY : i32 = 545;
pub const WM_MDIACTIVATE : i32 = 546;
pub const WM_MDIRESTORE : i32 = 547;
pub const WM_MDINEXT : i32 = 548;
pub const WM_MDIMAXIMIZE : i32 = 549;
pub const WM_MDITILE : i32 = 550;
pub const WM_MDICASCADE : i32 = 551;
pub const WM_MDIICONARRANGE : i32 = 552;
pub const WM_MDIGETACTIVE : i32 = 553;
pub const WM_MDISETMENU : i32 = 560;
pub const WM_ENTERSIZEMOVE : i32 = 561;
pub const WM_EXITSIZEMOVE : i32 = 562;
pub const WM_DROPFILES : i32 = 563;
pub const WM_MDIREFRESHMENU : i32 = 564;
pub const WM_POINTERDEVICECHANGE : i32 = 568;
pub const WM_POINTERDEVICEINRANGE : i32 = 569;
pub const WM_POINTERDEVICEOUTOFRANGE : i32 = 570;
pub const WM_TOUCH : i32 = 576;
pub const WM_NCPOINTERUPDATE : i32 = 577;
pub const WM_NCPOINTERDOWN : i32 = 578;
pub const WM_NCPOINTERUP : i32 = 579;
pub const WM_POINTERUPDATE : i32 = 581;
pub const WM_POINTERDOWN : i32 = 582;
pub const WM_POINTERUP : i32 = 583;
pub const WM_POINTERENTER : i32 = 585;
pub const WM_POINTERLEAVE : i32 = 586;
pub const WM_POINTERACTIVATE : i32 = 587;
pub const WM_POINTERCAPTURECHANGED : i32 = 588;
pub const WM_TOUCHHITTESTING : i32 = 589;
pub const WM_POINTERWHEEL : i32 = 590;
pub const WM_POINTERHWHEEL : i32 = 591;
pub const DM_POINTERHITTEST : i32 = 592;
pub const WM_POINTERROUTEDTO : i32 = 593;
pub const WM_POINTERROUTEDAWAY : i32 = 594;
pub const WM_POINTERROUTEDRELEASED : i32 = 595;
pub const WM_IME_SETCONTEXT : i32 = 641;
pub const WM_IME_NOTIFY : i32 = 642;
pub const WM_IME_CONTROL : i32 = 643;
pub const WM_IME_COMPOSITIONFULL : i32 = 644;
pub const WM_IME_SELECT : i32 = 645;
pub const WM_IME_CHAR : i32 = 646;
pub const WM_IME_REQUEST : i32 = 648;
pub const WM_IME_KEYDOWN : i32 = 656;
pub const WM_IME_KEYUP : i32 = 657;
pub const WM_MOUSEHOVER : i32 = 673;
pub const WM_MOUSELEAVE : i32 = 675;
pub const WM_NCMOUSEHOVER : i32 = 672;
pub const WM_NCMOUSELEAVE : i32 = 674;
pub const WM_WTSSESSION_CHANGE : i32 = 689;
pub const WM_TABLET_FIRST : i32 = 704;
pub const WM_TABLET_LAST : i32 = 735;
pub const WM_DPICHANGED : i32 = 736;
pub const WM_DPICHANGED_BEFOREPARENT : i32 = 738;
pub const WM_DPICHANGED_AFTERPARENT : i32 = 739;
pub const WM_GETDPISCALEDSIZE : i32 = 740;
pub const WM_CUT : i32 = 768;
pub const WM_COPY : i32 = 769;
pub const WM_PASTE : i32 = 770;
pub const WM_CLEAR : i32 = 771;
pub const WM_UNDO : i32 = 772;
pub const WM_RENDERFORMAT : i32 = 773;
pub const WM_RENDERALLFORMATS : i32 = 774;
pub const WM_DESTROYCLIPBOARD : i32 = 775;
pub const WM_DRAWCLIPBOARD : i32 = 776;
pub const WM_PAINTCLIPBOARD : i32 = 777;
pub const WM_VSCROLLCLIPBOARD : i32 = 778;
pub const WM_SIZECLIPBOARD : i32 = 779;
pub const WM_ASKCBFORMATNAME : i32 = 780;
pub const WM_CHANGECBCHAIN : i32 = 781;
pub const WM_HSCROLLCLIPBOARD : i32 = 782;
pub const WM_QUERYNEWPALETTE : i32 = 783;
pub const WM_PALETTEISCHANGING : i32 = 784;
pub const WM_PALETTECHANGED : i32 = 785;
pub const WM_HOTKEY : i32 = 786;
pub const WM_PRINT : i32 = 791;
pub const WM_PRINTCLIENT : i32 = 792;
pub const WM_APPCOMMAND : i32 = 793;
pub const WM_THEMECHANGED : i32 = 794;
pub const WM_CLIPBOARDUPDATE : i32 = 797;
pub const WM_DWMCOMPOSITIONCHANGED : i32 = 798;
pub const WM_DWMNCRENDERINGCHANGED : i32 = 799;
pub const WM_DWMCOLORIZATIONCOLORCHANGED : i32 = 800;
pub const WM_DWMWINDOWMAXIMIZEDCHANGE : i32 = 801;
pub const WM_DWMSENDICONICTHUMBNAIL : i32 = 803;
pub const WM_DWMSENDICONICLIVEPREVIEWBITMAP : i32 = 806;
pub const WM_GETTITLEBARINFOEX : i32 = 831;
pub const WM_HANDHELDFIRST : i32 = 856;
pub const WM_HANDHELDLAST : i32 = 863;
pub const WM_AFXFIRST : i32 = 864;
pub const WM_AFXLAST : i32 = 895;
pub const WM_PENWINFIRST : i32 = 896;
pub const WM_PENWINLAST : i32 = 911;
pub const WM_APP : i32 = 32768;
pub const WM_USER : i32 = 1024;
pub const WMSZ_LEFT : i32 = 1;
pub const WMSZ_RIGHT : i32 = 2;
pub const WMSZ_TOP : i32 = 3;
pub const WMSZ_TOPLEFT : i32 = 4;
pub const WMSZ_TOPRIGHT : i32 = 5;
pub const WMSZ_BOTTOM : i32 = 6;
pub const WMSZ_BOTTOMLEFT : i32 = 7;
pub const WMSZ_BOTTOMRIGHT : i32 = 8;
pub const HTERROR : i32 = -2;
pub const HTTRANSPARENT : i32 = -1;
pub const HTNOWHERE : i32 = 0;
pub const HTCLIENT : i32 = 1;
pub const HTCAPTION : i32 = 2;
pub const HTSYSMENU : i32 = 3;
pub const HTGROWBOX : i32 = 4;
pub const HTSIZE : i32 = 4;
pub const HTMENU : i32 = 5;
pub const HTHSCROLL : i32 = 6;
pub const HTVSCROLL : i32 = 7;
pub const HTMINBUTTON : i32 = 8;
pub const HTMAXBUTTON : i32 = 9;
pub const HTLEFT : i32 = 10;
pub const HTRIGHT : i32 = 11;
pub const HTTOP : i32 = 12;
pub const HTTOPLEFT : i32 = 13;
pub const HTTOPRIGHT : i32 = 14;
pub const HTBOTTOM : i32 = 15;
pub const HTBOTTOMLEFT : i32 = 16;
pub const HTBOTTOMRIGHT : i32 = 17;
pub const HTBORDER : i32 = 18;
pub const HTREDUCE : i32 = 8;
pub const HTZOOM : i32 = 9;
pub const HTSIZEFIRST : i32 = 10;
pub const HTSIZELAST : i32 = 17;
pub const HTOBJECT : i32 = 19;
pub const HTCLOSE : i32 = 20;
pub const HTHELP : i32 = 21;
pub const SMTO_NORMAL : i32 = 0;
pub const SMTO_BLOCK : i32 = 1;
pub const SMTO_ABORTIFHUNG : i32 = 2;
pub const SMTO_NOTIMEOUTIFNOTHUNG : i32 = 8;
pub const SMTO_ERRORONEXIT : i32 = 32;
pub const MA_ACTIVATE : i32 = 1;
pub const MA_ACTIVATEANDEAT : i32 = 2;
pub const MA_NOACTIVATE : i32 = 3;
pub const MA_NOACTIVATEANDEAT : i32 = 4;
pub const ICON_SMALL : i32 = 0;
pub const ICON_BIG : i32 = 1;
pub const ICON_SMALL2 : i32 = 2;
pub const SIZE_RESTORED : i32 = 0;
pub const SIZE_MINIMIZED : i32 = 1;
pub const SIZE_MAXIMIZED : i32 = 2;
pub const SIZE_MAXSHOW : i32 = 3;
pub const SIZE_MAXHIDE : i32 = 4;
pub const SIZENORMAL : i32 = 0;
pub const SIZEICONIC : i32 = 1;
pub const SIZEFULLSCREEN : i32 = 2;
pub const SIZEZOOMSHOW : i32 = 3;
pub const SIZEZOOMHIDE : i32 = 4;
pub const WVR_ALIGNTOP : i32 = 16;
pub const WVR_ALIGNLEFT : i32 = 32;
pub const WVR_ALIGNBOTTOM : i32 = 64;
pub const WVR_ALIGNRIGHT : i32 = 128;
pub const WVR_HREDRAW : i32 = 256;
pub const WVR_VREDRAW : i32 = 512;
pub const WVR_REDRAW : i32 = 768;
pub const WVR_VALIDRECTS : i32 = 1024;
pub const MK_LBUTTON : i32 = 1;
pub const MK_RBUTTON : i32 = 2;
pub const MK_SHIFT : i32 = 4;
pub const MK_CONTROL : i32 = 8;
pub const MK_MBUTTON : i32 = 16;
pub const MK_XBUTTON1 : i32 = 32;
pub const MK_XBUTTON2 : i32 = 64;
pub const TME_HOVER : u32 = 1;
pub const TME_LEAVE : u32 = 2;
pub const TME_NONCLIENT : u32 = 16;
pub const TME_QUERY : u32 = 1073741824;
pub const TME_CANCEL : u32 = 2147483648;
pub const HOVER_DEFAULT : u32 = 4294967295;
pub const WS_OVERLAPPED : u32 = 0;
pub const WS_POPUP : u32 = 2147483648;
pub const WS_CHILD : u32 = 1073741824;
pub const WS_MINIMIZE : u32 = 536870912;
pub const WS_VISIBLE : u32 = 268435456;
pub const WS_DISABLED : u32 = 134217728;
pub const WS_CLIPSIBLINGS : u32 = 67108864;
pub const WS_CLIPCHILDREN : u32 = 33554432;
pub const WS_MAXIMIZE : u32 = 16777216;
pub const WS_CAPTION : u32 = 12582912;
pub const WS_BORDER : u32 = 8388608;
pub const WS_DLGFRAME : u32 = 4194304;
pub const WS_VSCROLL : u32 = 2097152;
pub const WS_HSCROLL : u32 = 1048576;
pub const WS_SYSMENU : u32 = 524288;
pub const WS_THICKFRAME : u32 = 262144;
pub const WS_GROUP : u32 = 131072;
pub const WS_TABSTOP : u32 = 65536;
pub const WS_MINIMIZEBOX : u32 = 131072;
pub const WS_MAXIMIZEBOX : u32 = 65536;
pub const WS_TILED : u32 = 0;
pub const WS_ICONIC : u32 = 536870912;
pub const WS_SIZEBOX : u32 = 262144;
pub const WS_TILEDWINDOW : u32 = 13565952;
pub const WS_OVERLAPPEDWINDOW : u32 = 13565952;
pub const WS_POPUPWINDOW : u32 = 2156396544;
pub const WS_CHILDWINDOW : u32 = 1073741824;
pub const WS_EX_DLGMODALFRAME : i32 = 1;
pub const WS_EX_NOPARENTNOTIFY : i32 = 4;
pub const WS_EX_TOPMOST : i32 = 8;
pub const WS_EX_ACCEPTFILES : i32 = 16;
pub const WS_EX_TRANSPARENT : i32 = 32;
pub const WS_EX_MDICHILD : i32 = 64;
pub const WS_EX_TOOLWINDOW : i32 = 128;
pub const WS_EX_WINDOWEDGE : i32 = 256;
pub const WS_EX_CLIENTEDGE : i32 = 512;
pub const WS_EX_CONTEXTHELP : i32 = 1024;
pub const WS_EX_RIGHT : i32 = 4096;
pub const WS_EX_LEFT : i32 = 0;
pub const WS_EX_RTLREADING : i32 = 8192;
pub const WS_EX_LTRREADING : i32 = 0;
pub const WS_EX_LEFTSCROLLBAR : i32 = 16384;
pub const WS_EX_RIGHTSCROLLBAR : i32 = 0;
pub const WS_EX_CONTROLPARENT : i32 = 65536;
pub const WS_EX_STATICEDGE : i32 = 131072;
pub const WS_EX_APPWINDOW : i32 = 262144;
pub const WS_EX_OVERLAPPEDWINDOW : i32 = 768;
pub const WS_EX_PALETTEWINDOW : i32 = 392;
pub const WS_EX_NOINHERITLAYOUT : i32 = 1048576;
pub const WS_EX_NOREDIRECTIONBITMAP : i32 = 2097152;
pub const WS_EX_LAYOUTRTL : i32 = 4194304;
pub const WS_EX_COMPOSITED : i32 = 33554432;
pub const WS_EX_NOACTIVATE : i32 = 134217728;
pub const CS_VREDRAW : i32 = 1;
pub const CS_HREDRAW : i32 = 2;
pub const CS_DBLCLKS : i32 = 8;
pub const CS_OWNDC : i32 = 32;
pub const CS_CLASSDC : i32 = 64;
pub const CS_PARENTDC : i32 = 128;
pub const CS_NOCLOSE : i32 = 512;
pub const CS_SAVEBITS : i32 = 2048;
pub const CS_BYTEALIGNCLIENT : i32 = 4096;
pub const CS_BYTEALIGNWINDOW : i32 = 8192;
pub const CS_GLOBALCLASS : i32 = 16384;
pub const CS_IME : i32 = 65536;
pub const CS_DROPSHADOW : i32 = 131072;
pub const PRF_CHECKVISIBLE : i32 = 1;
pub const PRF_NONCLIENT : i32 = 2;
pub const PRF_CLIENT : i32 = 4;
pub const PRF_ERASEBKGND : i32 = 8;
pub const PRF_CHILDREN : i32 = 16;
pub const PRF_OWNED : i32 = 32;
pub const BDR_RAISEDOUTER : i32 = 1;
pub const BDR_SUNKENOUTER : i32 = 2;
pub const BDR_RAISEDINNER : i32 = 4;
pub const BDR_SUNKENINNER : i32 = 8;
pub const BDR_OUTER : i32 = 3;
pub const BDR_INNER : i32 = 12;
pub const BDR_RAISED : i32 = 5;
pub const BDR_SUNKEN : i32 = 10;
pub const EDGE_RAISED : i32 = 5;
pub const EDGE_SUNKEN : i32 = 10;
pub const EDGE_ETCHED : i32 = 6;
pub const EDGE_BUMP : i32 = 9;
pub const BF_LEFT : i32 = 1;
pub const BF_TOP : i32 = 2;
pub const BF_RIGHT : i32 = 4;
pub const BF_BOTTOM : i32 = 8;
pub const BF_TOPLEFT : i32 = 3;
pub const BF_TOPRIGHT : i32 = 6;
pub const BF_BOTTOMLEFT : i32 = 9;
pub const BF_BOTTOMRIGHT : i32 = 12;
pub const BF_RECT : i32 = 15;
pub const BF_DIAGONAL : i32 = 16;
pub const BF_DIAGONAL_ENDTOPRIGHT : i32 = 22;
pub const BF_DIAGONAL_ENDTOPLEFT : i32 = 19;
pub const BF_DIAGONAL_ENDBOTTOMLEFT : i32 = 25;
pub const BF_DIAGONAL_ENDBOTTOMRIGHT : i32 = 28;
pub const BF_MIDDLE : i32 = 2048;
pub const BF_SOFT : i32 = 4096;
pub const BF_ADJUST : i32 = 8192;
pub const BF_FLAT : i32 = 16384;
pub const BF_MONO : i32 = 32768;
pub const DFC_CAPTION : i32 = 1;
pub const DFC_MENU : i32 = 2;
pub const DFC_SCROLL : i32 = 3;
pub const DFC_BUTTON : i32 = 4;
pub const DFC_POPUPMENU : i32 = 5;
pub const DFCS_CAPTIONCLOSE : i32 = 0;
pub const DFCS_CAPTIONMIN : i32 = 1;
pub const DFCS_CAPTIONMAX : i32 = 2;
pub const DFCS_CAPTIONRESTORE : i32 = 3;
pub const DFCS_CAPTIONHELP : i32 = 4;
pub const DFCS_MENUARROW : i32 = 0;
pub const DFCS_MENUCHECK : i32 = 1;
pub const DFCS_MENUBULLET : i32 = 2;
pub const DFCS_MENUARROWRIGHT : i32 = 4;
pub const DFCS_SCROLLUP : i32 = 0;
pub const DFCS_SCROLLDOWN : i32 = 1;
pub const DFCS_SCROLLLEFT : i32 = 2;
pub const DFCS_SCROLLRIGHT : i32 = 3;
pub const DFCS_SCROLLCOMBOBOX : i32 = 5;
pub const DFCS_SCROLLSIZEGRIP : i32 = 8;
pub const DFCS_SCROLLSIZEGRIPRIGHT : i32 = 16;
pub const DFCS_BUTTONCHECK : i32 = 0;
pub const DFCS_BUTTONRADIOIMAGE : i32 = 1;
pub const DFCS_BUTTONRADIOMASK : i32 = 2;
pub const DFCS_BUTTONRADIO : i32 = 4;
pub const DFCS_BUTTON3STATE : i32 = 8;
pub const DFCS_BUTTONPUSH : i32 = 16;
pub const DFCS_INACTIVE : i32 = 256;
pub const DFCS_PUSHED : i32 = 512;
pub const DFCS_CHECKED : i32 = 1024;
pub const DFCS_TRANSPARENT : i32 = 2048;
pub const DFCS_HOT : i32 = 4096;
pub const DFCS_ADJUSTRECT : i32 = 8192;
pub const DFCS_FLAT : i32 = 16384;
pub const DFCS_MONO : i32 = 32768;
pub const DC_ACTIVE : i32 = 1;
pub const DC_SMALLCAP : i32 = 2;
pub const DC_ICON : i32 = 4;
pub const DC_TEXT : i32 = 8;
pub const DC_INBUTTON : i32 = 16;
pub const DC_GRADIENT : i32 = 32;
pub const DC_BUTTONS : i32 = 4096;
pub const IDANI_OPEN : i32 = 1;
pub const IDANI_CAPTION : i32 = 3;
pub const CF_TEXT : i32 = 1;
pub const CF_BITMAP : i32 = 2;
pub const CF_METAFILEPICT : i32 = 3;
pub const CF_SYLK : i32 = 4;
pub const CF_DIF : i32 = 5;
pub const CF_TIFF : i32 = 6;
pub const CF_OEMTEXT : i32 = 7;
pub const CF_DIB : i32 = 8;
pub const CF_PALETTE : i32 = 9;
pub const CF_PENDATA : i32 = 10;
pub const CF_RIFF : i32 = 11;
pub const CF_WAVE : i32 = 12;
pub const CF_UNICODETEXT : i32 = 13;
pub const CF_ENHMETAFILE : i32 = 14;
pub const CF_HDROP : i32 = 15;
pub const CF_LOCALE : i32 = 16;
pub const CF_DIBV5 : i32 = 17;
pub const CF_MAX : i32 = 18;
pub const CF_OWNERDISPLAY : i32 = 128;
pub const CF_DSPTEXT : i32 = 129;
pub const CF_DSPBITMAP : i32 = 130;
pub const CF_DSPMETAFILEPICT : i32 = 131;
pub const CF_DSPENHMETAFILE : i32 = 142;
pub const CF_PRIVATEFIRST : i32 = 512;
pub const CF_PRIVATELAST : i32 = 767;
pub const CF_GDIOBJFIRST : i32 = 768;
pub const CF_GDIOBJLAST : i32 = 1023;
pub const FVIRTKEY : i32 = 1;
pub const FNOINVERT : i32 = 2;
pub const FSHIFT : i32 = 4;
pub const FCONTROL : i32 = 8;
pub const FALT : i32 = 16;
pub const WPF_SETMINPOSITION : i32 = 1;
pub const WPF_RESTORETOMAXIMIZED : i32 = 2;
pub const WPF_ASYNCWINDOWPLACEMENT : i32 = 4;
pub const ODT_MENU : i32 = 1;
pub const ODT_LISTBOX : i32 = 2;
pub const ODT_COMBOBOX : i32 = 3;
pub const ODT_BUTTON : i32 = 4;
pub const ODT_STATIC : i32 = 5;
pub const ODA_DRAWENTIRE : i32 = 1;
pub const ODA_SELECT : i32 = 2;
pub const ODA_FOCUS : i32 = 4;
pub const ODS_SELECTED : i32 = 1;
pub const ODS_GRAYED : i32 = 2;
pub const ODS_DISABLED : i32 = 4;
pub const ODS_CHECKED : i32 = 8;
pub const ODS_FOCUS : i32 = 16;
pub const ODS_DEFAULT : i32 = 32;
pub const ODS_COMBOBOXEDIT : i32 = 4096;
pub const ODS_HOTLIGHT : i32 = 64;
pub const ODS_INACTIVE : i32 = 128;
pub const ODS_NOACCEL : i32 = 256;
pub const ODS_NOFOCUSRECT : i32 = 512;
pub const PM_NOREMOVE : i32 = 0;
pub const PM_REMOVE : i32 = 1;
pub const PM_NOYIELD : i32 = 2;
pub const PM_QS_INPUT : i32 = 470220800;
pub const PM_QS_POSTMESSAGE : i32 = 9961472;
pub const PM_QS_PAINT : i32 = 2097152;
pub const PM_QS_SENDMESSAGE : i32 = 4194304;
pub const MOD_ALT : i32 = 1;
pub const MOD_CONTROL : i32 = 2;
pub const MOD_SHIFT : i32 = 4;
pub const MOD_WIN : i32 = 8;
pub const MOD_NOREPEAT : i32 = 16384;
pub const IDHOT_SNAPWINDOW : i32 = -1;
pub const IDHOT_SNAPDESKTOP : i32 = -2;
pub const ENDSESSION_CLOSEAPP : u32 = 1;
pub const ENDSESSION_CRITICAL : u32 = 1073741824;
pub const ENDSESSION_LOGOFF : u32 = 2147483648;
pub const EWX_LOGOFF : i32 = 0;
pub const EWX_SHUTDOWN : i32 = 1;
pub const EWX_REBOOT : i32 = 2;
pub const EWX_FORCE : i32 = 4;
pub const EWX_POWEROFF : i32 = 8;
pub const EWX_FORCEIFHUNG : i32 = 16;
pub const EWX_QUICKRESOLVE : i32 = 32;
pub const EWX_RESTARTAPPS : i32 = 64;
pub const EWX_HYBRID_SHUTDOWN : i32 = 4194304;
pub const EWX_BOOTOPTIONS : i32 = 16777216;
pub const EWX_ARSO : i32 = 67108864;
pub const BSM_ALLCOMPONENTS : i32 = 0;
pub const BSM_VXDS : i32 = 1;
pub const BSM_NETDRIVER : i32 = 2;
pub const BSM_INSTALLABLEDRIVERS : i32 = 4;
pub const BSM_APPLICATIONS : i32 = 8;
pub const BSM_ALLDESKTOPS : i32 = 16;
pub const BSF_QUERY : i32 = 1;
pub const BSF_IGNORECURRENTTASK : i32 = 2;
pub const BSF_FLUSHDISK : i32 = 4;
pub const BSF_NOHANG : i32 = 8;
pub const BSF_POSTMESSAGE : i32 = 16;
pub const BSF_FORCEIFHUNG : i32 = 32;
pub const BSF_NOTIMEOUTIFNOTHUNG : i32 = 64;
pub const BSF_ALLOWSFW : i32 = 128;
pub const BSF_SENDNOTIFYMESSAGE : i32 = 256;
pub const BSF_RETURNHDESK : i32 = 512;
pub const BSF_LUID : i32 = 1024;
pub const BROADCAST_QUERY_DENY : i32 = 1112363332;
pub const DEVICE_NOTIFY_WINDOW_HANDLE : i32 = 0;
pub const DEVICE_NOTIFY_SERVICE_HANDLE : i32 = 1;
pub const DEVICE_NOTIFY_ALL_INTERFACE_CLASSES : i32 = 4;
pub const HWND_BROADCAST : i32 = 65535;
pub const HWND_MESSAGE : i32 = -3;
pub const ISMEX_NOSEND : i32 = 0;
pub const ISMEX_SEND : i32 = 1;
pub const ISMEX_NOTIFY : i32 = 2;
pub const ISMEX_CALLBACK : i32 = 4;
pub const ISMEX_REPLIED : i32 = 8;
pub const CW_USEDEFAULT : i32 = -2147483648;
pub const HWND_DESKTOP : i32 = 0;
pub const PW_CLIENTONLY : i32 = 1;
pub const PW_RENDERFULLCONTENT : i32 = 2;
pub const LWA_COLORKEY : i32 = 1;
pub const LWA_ALPHA : i32 = 2;
pub const ULW_COLORKEY : i32 = 1;
pub const ULW_ALPHA : i32 = 2;
pub const ULW_OPAQUE : i32 = 4;
pub const ULW_EX_NORESIZE : i32 = 8;
pub const FLASHW_STOP : i32 = 0;
pub const FLASHW_CAPTION : i32 = 1;
pub const FLASHW_TRAY : i32 = 2;
pub const FLASHW_ALL : i32 = 3;
pub const FLASHW_TIMER : i32 = 4;
pub const FLASHW_TIMERNOFG : i32 = 12;
pub const WDA_NONE : i32 = 0;
pub const WDA_MONITOR : i32 = 1;
pub const WDA_EXCLUDEFROMCAPTURE : i32 = 17;
pub const SWP_NOSIZE : i32 = 1;
pub const SWP_NOMOVE : i32 = 2;
pub const SWP_NOZORDER : i32 = 4;
pub const SWP_NOREDRAW : i32 = 8;
pub const SWP_NOACTIVATE : i32 = 16;
pub const SWP_FRAMECHANGED : i32 = 32;
pub const SWP_SHOWWINDOW : i32 = 64;
pub const SWP_HIDEWINDOW : i32 = 128;
pub const SWP_NOCOPYBITS : i32 = 256;
pub const SWP_NOOWNERZORDER : i32 = 512;
pub const SWP_NOSENDCHANGING : i32 = 1024;
pub const SWP_DRAWFRAME : i32 = 32;
pub const SWP_NOREPOSITION : i32 = 512;
pub const SWP_DEFERERASE : i32 = 8192;
pub const SWP_ASYNCWINDOWPOS : i32 = 16384;
pub const HWND_TOP : i32 = 0;
pub const HWND_BOTTOM : i32 = 1;
pub const HWND_TOPMOST : i32 = -1;
pub const HWND_NOTOPMOST : i32 = -2;
pub const DLGWINDOWEXTRA : i32 = 30;
pub const KEYEVENTF_EXTENDEDKEY : i32 = 1;
pub const KEYEVENTF_KEYUP : i32 = 2;
pub const KEYEVENTF_UNICODE : i32 = 4;
pub const KEYEVENTF_SCANCODE : i32 = 8;
pub const MOUSEEVENTF_MOVE : i32 = 1;
pub const MOUSEEVENTF_LEFTDOWN : i32 = 2;
pub const MOUSEEVENTF_LEFTUP : i32 = 4;
pub const MOUSEEVENTF_RIGHTDOWN : i32 = 8;
pub const MOUSEEVENTF_RIGHTUP : i32 = 16;
pub const MOUSEEVENTF_MIDDLEDOWN : i32 = 32;
pub const MOUSEEVENTF_MIDDLEUP : i32 = 64;
pub const MOUSEEVENTF_XDOWN : i32 = 128;
pub const MOUSEEVENTF_XUP : i32 = 256;
pub const MOUSEEVENTF_WHEEL : i32 = 2048;
pub const MOUSEEVENTF_HWHEEL : i32 = 4096;
pub const MOUSEEVENTF_MOVE_NOCOALESCE : i32 = 8192;
pub const MOUSEEVENTF_VIRTUALDESK : i32 = 16384;
pub const MOUSEEVENTF_ABSOLUTE : i32 = 32768;
pub const INPUT_MOUSE : i32 = 0;
pub const INPUT_KEYBOARD : i32 = 1;
pub const INPUT_HARDWARE : i32 = 2;
pub const TOUCHEVENTF_MOVE : i32 = 1;
pub const TOUCHEVENTF_DOWN : i32 = 2;
pub const TOUCHEVENTF_UP : i32 = 4;
pub const TOUCHEVENTF_INRANGE : i32 = 8;
pub const TOUCHEVENTF_PRIMARY : i32 = 16;
pub const TOUCHEVENTF_NOCOALESCE : i32 = 32;
pub const TOUCHEVENTF_PEN : i32 = 64;
pub const TOUCHEVENTF_PALM : i32 = 128;
pub const TOUCHINPUTMASKF_TIMEFROMSYSTEM : i32 = 1;
pub const TOUCHINPUTMASKF_EXTRAINFO : i32 = 2;
pub const TOUCHINPUTMASKF_CONTACTAREA : i32 = 4;
pub const TWF_FINETOUCH : i32 = 1;
pub const TWF_WANTPALM : i32 = 2;
pub const POINTER_FLAG_NONE : i32 = 0;
pub const POINTER_FLAG_NEW : i32 = 1;
pub const POINTER_FLAG_INRANGE : i32 = 2;
pub const POINTER_FLAG_INCONTACT : i32 = 4;
pub const POINTER_FLAG_FIRSTBUTTON : i32 = 16;
pub const POINTER_FLAG_SECONDBUTTON : i32 = 32;
pub const POINTER_FLAG_THIRDBUTTON : i32 = 64;
pub const POINTER_FLAG_FOURTHBUTTON : i32 = 128;
pub const POINTER_FLAG_FIFTHBUTTON : i32 = 256;
pub const POINTER_FLAG_PRIMARY : i32 = 8192;
pub const POINTER_FLAG_CONFIDENCE : i32 = 16384;
pub const POINTER_FLAG_CANCELED : i32 = 32768;
pub const POINTER_FLAG_DOWN : i32 = 65536;
pub const POINTER_FLAG_UPDATE : i32 = 131072;
pub const POINTER_FLAG_UP : i32 = 262144;
pub const POINTER_FLAG_WHEEL : i32 = 524288;
pub const POINTER_FLAG_HWHEEL : i32 = 1048576;
pub const POINTER_FLAG_CAPTURECHANGED : i32 = 2097152;
pub const POINTER_FLAG_HASTRANSFORM : i32 = 4194304;
pub const POINTER_MOD_SHIFT : i32 = 4;
pub const POINTER_MOD_CTRL : i32 = 8;
pub const TOUCH_FLAG_NONE : i32 = 0;
pub const TOUCH_MASK_NONE : i32 = 0;
pub const TOUCH_MASK_CONTACTAREA : i32 = 1;
pub const TOUCH_MASK_ORIENTATION : i32 = 2;
pub const TOUCH_MASK_PRESSURE : i32 = 4;
pub const PEN_FLAG_NONE : i32 = 0;
pub const PEN_FLAG_BARREL : i32 = 1;
pub const PEN_FLAG_INVERTED : i32 = 2;
pub const PEN_FLAG_ERASER : i32 = 4;
pub const PEN_MASK_NONE : i32 = 0;
pub const PEN_MASK_PRESSURE : i32 = 1;
pub const PEN_MASK_ROTATION : i32 = 2;
pub const PEN_MASK_TILT_X : i32 = 4;
pub const PEN_MASK_TILT_Y : i32 = 8;
pub const POINTER_MESSAGE_FLAG_NEW : i32 = 1;
pub const POINTER_MESSAGE_FLAG_INRANGE : i32 = 2;
pub const POINTER_MESSAGE_FLAG_INCONTACT : i32 = 4;
pub const POINTER_MESSAGE_FLAG_FIRSTBUTTON : i32 = 16;
pub const POINTER_MESSAGE_FLAG_SECONDBUTTON : i32 = 32;
pub const POINTER_MESSAGE_FLAG_THIRDBUTTON : i32 = 64;
pub const POINTER_MESSAGE_FLAG_FOURTHBUTTON : i32 = 128;
pub const POINTER_MESSAGE_FLAG_FIFTHBUTTON : i32 = 256;
pub const POINTER_MESSAGE_FLAG_PRIMARY : i32 = 8192;
pub const POINTER_MESSAGE_FLAG_CONFIDENCE : i32 = 16384;
pub const POINTER_MESSAGE_FLAG_CANCELED : i32 = 32768;
pub const PA_ACTIVATE : i32 = 1;
pub const PA_NOACTIVATE : i32 = 3;
pub const MAX_TOUCH_COUNT : i32 = 256;
pub const TOUCH_FEEDBACK_DEFAULT : i32 = 1;
pub const TOUCH_FEEDBACK_INDIRECT : i32 = 2;
pub const TOUCH_FEEDBACK_NONE : i32 = 3;
pub const TOUCH_HIT_TESTING_DEFAULT : i32 = 0;
pub const TOUCH_HIT_TESTING_CLIENT : i32 = 1;
pub const TOUCH_HIT_TESTING_NONE : i32 = 2;
pub const TOUCH_HIT_TESTING_PROXIMITY_CLOSEST : i32 = 0;
pub const TOUCH_HIT_TESTING_PROXIMITY_FARTHEST : i32 = 4095;
pub const GWFS_INCLUDE_ANCESTORS : i32 = 1;
pub const MAPVK_VK_TO_VSC : i32 = 0;
pub const MAPVK_VSC_TO_VK : i32 = 1;
pub const MAPVK_VK_TO_CHAR : i32 = 2;
pub const MAPVK_VSC_TO_VK_EX : i32 = 3;
pub const MAPVK_VK_TO_VSC_EX : i32 = 4;
pub const MWMO_WAITALL : i32 = 1;
pub const MWMO_ALERTABLE : i32 = 2;
pub const MWMO_INPUTAVAILABLE : i32 = 4;
pub const QS_KEY : i32 = 1;
pub const QS_MOUSEMOVE : i32 = 2;
pub const QS_MOUSEBUTTON : i32 = 4;
pub const QS_POSTMESSAGE : i32 = 8;
pub const QS_TIMER : i32 = 16;
pub const QS_PAINT : i32 = 32;
pub const QS_SENDMESSAGE : i32 = 64;
pub const QS_HOTKEY : i32 = 128;
pub const QS_ALLPOSTMESSAGE : i32 = 256;
pub const QS_RAWINPUT : i32 = 1024;
pub const QS_TOUCH : i32 = 2048;
pub const QS_POINTER : i32 = 4096;
pub const QS_MOUSE : i32 = 6;
pub const QS_INPUT : i32 = 7175;
pub const QS_ALLEVENTS : i32 = 7359;
pub const QS_ALLINPUT : i32 = 7423;
pub const USER_TIMER_MAXIMUM : i32 = 2147483647;
pub const USER_TIMER_MINIMUM : i32 = 10;
pub const TIMERV_DEFAULT_COALESCING : u32 = 0;
pub const TIMERV_NO_COALESCING : u32 = 4294967295;
pub const TIMERV_COALESCING_MIN : u32 = 1;
pub const TIMERV_COALESCING_MAX : u32 = 2147483637;
pub const SM_CXSCREEN : i32 = 0;
pub const SM_CYSCREEN : i32 = 1;
pub const SM_CXVSCROLL : i32 = 2;
pub const SM_CYHSCROLL : i32 = 3;
pub const SM_CYCAPTION : i32 = 4;
pub const SM_CXBORDER : i32 = 5;
pub const SM_CYBORDER : i32 = 6;
pub const SM_CXDLGFRAME : i32 = 7;
pub const SM_CYDLGFRAME : i32 = 8;
pub const SM_CYVTHUMB : i32 = 9;
pub const SM_CXHTHUMB : i32 = 10;
pub const SM_CXICON : i32 = 11;
pub const SM_CYICON : i32 = 12;
pub const SM_CXCURSOR : i32 = 13;
pub const SM_CYCURSOR : i32 = 14;
pub const SM_CYMENU : i32 = 15;
pub const SM_CXFULLSCREEN : i32 = 16;
pub const SM_CYFULLSCREEN : i32 = 17;
pub const SM_CYKANJIWINDOW : i32 = 18;
pub const SM_MOUSEPRESENT : i32 = 19;
pub const SM_CYVSCROLL : i32 = 20;
pub const SM_CXHSCROLL : i32 = 21;
pub const SM_DEBUG : i32 = 22;
pub const SM_SWAPBUTTON : i32 = 23;
pub const SM_RESERVED1 : i32 = 24;
pub const SM_RESERVED2 : i32 = 25;
pub const SM_RESERVED3 : i32 = 26;
pub const SM_RESERVED4 : i32 = 27;
pub const SM_CXMIN : i32 = 28;
pub const SM_CYMIN : i32 = 29;
pub const SM_CXSIZE : i32 = 30;
pub const SM_CYSIZE : i32 = 31;
pub const SM_CXFRAME : i32 = 32;
pub const SM_CYFRAME : i32 = 33;
pub const SM_CXMINTRACK : i32 = 34;
pub const SM_CYMINTRACK : i32 = 35;
pub const SM_CXDOUBLECLK : i32 = 36;
pub const SM_CYDOUBLECLK : i32 = 37;
pub const SM_CXICONSPACING : i32 = 38;
pub const SM_CYICONSPACING : i32 = 39;
pub const SM_MENUDROPALIGNMENT : i32 = 40;
pub const SM_PENWINDOWS : i32 = 41;
pub const SM_DBCSENABLED : i32 = 42;
pub const SM_CMOUSEBUTTONS : i32 = 43;
pub const SM_CXFIXEDFRAME : i32 = 7;
pub const SM_CYFIXEDFRAME : i32 = 8;
pub const SM_CXSIZEFRAME : i32 = 32;
pub const SM_CYSIZEFRAME : i32 = 33;
pub const SM_SECURE : i32 = 44;
pub const SM_CXEDGE : i32 = 45;
pub const SM_CYEDGE : i32 = 46;
pub const SM_CXMINSPACING : i32 = 47;
pub const SM_CYMINSPACING : i32 = 48;
pub const SM_CXSMICON : i32 = 49;
pub const SM_CYSMICON : i32 = 50;
pub const SM_CYSMCAPTION : i32 = 51;
pub const SM_CXSMSIZE : i32 = 52;
pub const SM_CYSMSIZE : i32 = 53;
pub const SM_CXMENUSIZE : i32 = 54;
pub const SM_CYMENUSIZE : i32 = 55;
pub const SM_ARRANGE : i32 = 56;
pub const SM_CXMINIMIZED : i32 = 57;
pub const SM_CYMINIMIZED : i32 = 58;
pub const SM_CXMAXTRACK : i32 = 59;
pub const SM_CYMAXTRACK : i32 = 60;
pub const SM_CXMAXIMIZED : i32 = 61;
pub const SM_CYMAXIMIZED : i32 = 62;
pub const SM_NETWORK : i32 = 63;
pub const SM_CLEANBOOT : i32 = 67;
pub const SM_CXDRAG : i32 = 68;
pub const SM_CYDRAG : i32 = 69;
pub const SM_SHOWSOUNDS : i32 = 70;
pub const SM_CXMENUCHECK : i32 = 71;
pub const SM_CYMENUCHECK : i32 = 72;
pub const SM_SLOWMACHINE : i32 = 73;
pub const SM_MIDEASTENABLED : i32 = 74;
pub const SM_MOUSEWHEELPRESENT : i32 = 75;
pub const SM_XVIRTUALSCREEN : i32 = 76;
pub const SM_YVIRTUALSCREEN : i32 = 77;
pub const SM_CXVIRTUALSCREEN : i32 = 78;
pub const SM_CYVIRTUALSCREEN : i32 = 79;
pub const SM_CMONITORS : i32 = 80;
pub const SM_SAMEDISPLAYFORMAT : i32 = 81;
pub const SM_IMMENABLED : i32 = 82;
pub const SM_CXFOCUSBORDER : i32 = 83;
pub const SM_CYFOCUSBORDER : i32 = 84;
pub const SM_TABLETPC : i32 = 86;
pub const SM_MEDIACENTER : i32 = 87;
pub const SM_STARTER : i32 = 88;
pub const SM_SERVERR2 : i32 = 89;
pub const SM_MOUSEHORIZONTALWHEELPRESENT : i32 = 91;
pub const SM_CXPADDEDBORDER : i32 = 92;
pub const SM_DIGITIZER : i32 = 94;
pub const SM_MAXIMUMTOUCHES : i32 = 95;
pub const SM_CMETRICS : i32 = 97;
pub const SM_REMOTESESSION : i32 = 4096;
pub const SM_SHUTTINGDOWN : i32 = 8192;
pub const SM_REMOTECONTROL : i32 = 8193;
pub const SM_CARETBLINKINGENABLED : i32 = 8194;
pub const SM_CONVERTIBLESLATEMODE : i32 = 8195;
pub const SM_SYSTEMDOCKED : i32 = 8196;
pub const PMB_ACTIVE : i32 = 1;
pub const MNC_IGNORE : i32 = 0;
pub const MNC_CLOSE : i32 = 1;
pub const MNC_EXECUTE : i32 = 2;
pub const MNC_SELECT : i32 = 3;
pub const MNS_NOCHECK : u32 = 2147483648;
pub const MNS_MODELESS : u32 = 1073741824;
pub const MNS_DRAGDROP : u32 = 536870912;
pub const MNS_AUTODISMISS : u32 = 268435456;
pub const MNS_NOTIFYBYPOS : u32 = 134217728;
pub const MNS_CHECKORBMP : u32 = 67108864;
pub const MIM_MAXHEIGHT : u32 = 1;
pub const MIM_BACKGROUND : u32 = 2;
pub const MIM_HELPID : u32 = 4;
pub const MIM_MENUDATA : u32 = 8;
pub const MIM_STYLE : u32 = 16;
pub const MIM_APPLYTOSUBMENUS : u32 = 2147483648;
pub const MND_CONTINUE : i32 = 0;
pub const MND_ENDMENU : i32 = 1;
pub const MNGOF_TOPGAP : i32 = 1;
pub const MNGOF_BOTTOMGAP : i32 = 2;
pub const MNGO_NOINTERFACE : i32 = 0;
pub const MNGO_NOERROR : i32 = 1;
pub const MIIM_STATE : i32 = 1;
pub const MIIM_ID : i32 = 2;
pub const MIIM_SUBMENU : i32 = 4;
pub const MIIM_CHECKMARKS : i32 = 8;
pub const MIIM_TYPE : i32 = 16;
pub const MIIM_DATA : i32 = 32;
pub const MIIM_STRING : i32 = 64;
pub const MIIM_BITMAP : i32 = 128;
pub const MIIM_FTYPE : i32 = 256;
pub const HBMMENU_CALLBACK : i32 = -1;
pub const HBMMENU_SYSTEM : i32 = 1;
pub const HBMMENU_MBAR_RESTORE : i32 = 2;
pub const HBMMENU_MBAR_MINIMIZE : i32 = 3;
pub const HBMMENU_MBAR_CLOSE : i32 = 5;
pub const HBMMENU_MBAR_CLOSE_D : i32 = 6;
pub const HBMMENU_MBAR_MINIMIZE_D : i32 = 7;
pub const HBMMENU_POPUP_CLOSE : i32 = 8;
pub const HBMMENU_POPUP_RESTORE : i32 = 9;
pub const HBMMENU_POPUP_MAXIMIZE : i32 = 10;
pub const HBMMENU_POPUP_MINIMIZE : i32 = 11;
pub const TPM_LEFTBUTTON : i32 = 0;
pub const TPM_RIGHTBUTTON : i32 = 2;
pub const TPM_LEFTALIGN : i32 = 0;
pub const TPM_CENTERALIGN : i32 = 4;
pub const TPM_RIGHTALIGN : i32 = 8;
pub const TPM_TOPALIGN : i32 = 0;
pub const TPM_VCENTERALIGN : i32 = 16;
pub const TPM_BOTTOMALIGN : i32 = 32;
pub const TPM_HORIZONTAL : i32 = 0;
pub const TPM_VERTICAL : i32 = 64;
pub const TPM_NONOTIFY : i32 = 128;
pub const TPM_RETURNCMD : i32 = 256;
pub const TPM_RECURSE : i32 = 1;
pub const TPM_HORPOSANIMATION : i32 = 1024;
pub const TPM_HORNEGANIMATION : i32 = 2048;
pub const TPM_VERPOSANIMATION : i32 = 4096;
pub const TPM_VERNEGANIMATION : i32 = 8192;
pub const TPM_NOANIMATION : i32 = 16384;
pub const TPM_LAYOUTRTL : i32 = 32768;
pub const TPM_WORKAREA : i32 = 65536;
pub const DOF_EXECUTABLE : i32 = 32769;
pub const DOF_DOCUMENT : i32 = 32770;
pub const DOF_DIRECTORY : i32 = 32771;
pub const DOF_MULTIPLE : i32 = 32772;
pub const DOF_PROGMAN : i32 = 1;
pub const DOF_SHELLDATA : i32 = 2;
pub const DO_DROPFILE : i32 = 1162627398;
pub const DO_PRINTFILE : i32 = 1414419024;
pub const DT_TOP : i32 = 0;
pub const DT_LEFT : i32 = 0;
pub const DT_CENTER : i32 = 1;
pub const DT_RIGHT : i32 = 2;
pub const DT_VCENTER : i32 = 4;
pub const DT_BOTTOM : i32 = 8;
pub const DT_WORDBREAK : i32 = 16;
pub const DT_SINGLELINE : i32 = 32;
pub const DT_EXPANDTABS : i32 = 64;
pub const DT_TABSTOP : i32 = 128;
pub const DT_NOCLIP : i32 = 256;
pub const DT_EXTERNALLEADING : i32 = 512;
pub const DT_CALCRECT : i32 = 1024;
pub const DT_NOPREFIX : i32 = 2048;
pub const DT_INTERNAL : i32 = 4096;
pub const DT_EDITCONTROL : i32 = 8192;
pub const DT_PATH_ELLIPSIS : i32 = 16384;
pub const DT_END_ELLIPSIS : i32 = 32768;
pub const DT_MODIFYSTRING : i32 = 65536;
pub const DT_RTLREADING : i32 = 131072;
pub const DT_WORD_ELLIPSIS : i32 = 262144;
pub const DT_NOFULLWIDTHCHARBREAK : i32 = 524288;
pub const DT_HIDEPREFIX : i32 = 1048576;
pub const DT_PREFIXONLY : i32 = 2097152;
pub const DST_COMPLEX : i32 = 0;
pub const DST_TEXT : i32 = 1;
pub const DST_PREFIXTEXT : i32 = 2;
pub const DST_ICON : i32 = 3;
pub const DST_BITMAP : i32 = 4;
pub const DSS_NORMAL : i32 = 0;
pub const DSS_UNION : i32 = 16;
pub const DSS_DISABLED : i32 = 32;
pub const DSS_MONO : i32 = 128;
pub const DSS_HIDEPREFIX : i32 = 512;
pub const DSS_PREFIXONLY : i32 = 1024;
pub const DSS_RIGHT : i32 = 32768;
pub const ASFW_ANY : u32 = 4294967295;
pub const LSFW_LOCK : i32 = 1;
pub const LSFW_UNLOCK : i32 = 2;
pub const DCX_WINDOW : i32 = 1;
pub const DCX_CACHE : i32 = 2;
pub const DCX_NORESETATTRS : i32 = 4;
pub const DCX_CLIPCHILDREN : i32 = 8;
pub const DCX_CLIPSIBLINGS : i32 = 16;
pub const DCX_PARENTCLIP : i32 = 32;
pub const DCX_EXCLUDERGN : i32 = 64;
pub const DCX_INTERSECTRGN : i32 = 128;
pub const DCX_EXCLUDEUPDATE : i32 = 256;
pub const DCX_INTERSECTUPDATE : i32 = 512;
pub const DCX_LOCKWINDOWUPDATE : i32 = 1024;
pub const DCX_VALIDATE : i32 = 2097152;
pub const RDW_INVALIDATE : i32 = 1;
pub const RDW_INTERNALPAINT : i32 = 2;
pub const RDW_ERASE : i32 = 4;
pub const RDW_VALIDATE : i32 = 8;
pub const RDW_NOINTERNALPAINT : i32 = 16;
pub const RDW_NOERASE : i32 = 32;
pub const RDW_NOCHILDREN : i32 = 64;
pub const RDW_ALLCHILDREN : i32 = 128;
pub const RDW_UPDATENOW : i32 = 256;
pub const RDW_ERASENOW : i32 = 512;
pub const RDW_FRAME : i32 = 1024;
pub const RDW_NOFRAME : i32 = 2048;
pub const SW_SCROLLCHILDREN : i32 = 1;
pub const SW_INVALIDATE : i32 = 2;
pub const SW_ERASE : i32 = 4;
pub const SW_SMOOTHSCROLL : i32 = 16;
pub const ESB_ENABLE_BOTH : i32 = 0;
pub const ESB_DISABLE_BOTH : i32 = 3;
pub const ESB_DISABLE_LEFT : i32 = 1;
pub const ESB_DISABLE_RIGHT : i32 = 2;
pub const ESB_DISABLE_UP : i32 = 1;
pub const ESB_DISABLE_DOWN : i32 = 2;
pub const ESB_DISABLE_LTUP : i32 = 1;
pub const ESB_DISABLE_RTDN : i32 = 2;
pub const HELPINFO_WINDOW : i32 = 1;
pub const HELPINFO_MENUITEM : i32 = 2;
pub const MB_OK : i32 = 0;
pub const MB_OKCANCEL : i32 = 1;
pub const MB_ABORTRETRYIGNORE : i32 = 2;
pub const MB_YESNOCANCEL : i32 = 3;
pub const MB_YESNO : i32 = 4;
pub const MB_RETRYCANCEL : i32 = 5;
pub const MB_CANCELTRYCONTINUE : i32 = 6;
pub const MB_ICONHAND : i32 = 16;
pub const MB_ICONQUESTION : i32 = 32;
pub const MB_ICONEXCLAMATION : i32 = 48;
pub const MB_ICONASTERISK : i32 = 64;
pub const MB_USERICON : i32 = 128;
pub const MB_ICONWARNING : i32 = 48;
pub const MB_ICONERROR : i32 = 16;
pub const MB_ICONINFORMATION : i32 = 64;
pub const MB_ICONSTOP : i32 = 16;
pub const MB_DEFBUTTON1 : i32 = 0;
pub const MB_DEFBUTTON2 : i32 = 256;
pub const MB_DEFBUTTON3 : i32 = 512;
pub const MB_DEFBUTTON4 : i32 = 768;
pub const MB_APPLMODAL : i32 = 0;
pub const MB_SYSTEMMODAL : i32 = 4096;
pub const MB_TASKMODAL : i32 = 8192;
pub const MB_HELP : i32 = 16384;
pub const MB_NOFOCUS : i32 = 32768;
pub const MB_SETFOREGROUND : i32 = 65536;
pub const MB_DEFAULT_DESKTOP_ONLY : i32 = 131072;
pub const MB_TOPMOST : i32 = 262144;
pub const MB_RIGHT : i32 = 524288;
pub const MB_RTLREADING : i32 = 1048576;
pub const MB_SERVICE_NOTIFICATION : i32 = 2097152;
pub const MB_SERVICE_NOTIFICATION_NT3X : i32 = 262144;
pub const MB_TYPEMASK : i32 = 15;
pub const MB_ICONMASK : i32 = 240;
pub const MB_DEFMASK : i32 = 3840;
pub const MB_MODEMASK : i32 = 12288;
pub const MB_MISCMASK : i32 = 49152;
pub const CWP_ALL : i32 = 0;
pub const CWP_SKIPINVISIBLE : i32 = 1;
pub const CWP_SKIPDISABLED : i32 = 2;
pub const CWP_SKIPTRANSPARENT : i32 = 4;
pub const CTLCOLOR_MSGBOX : i32 = 0;
pub const CTLCOLOR_EDIT : i32 = 1;
pub const CTLCOLOR_LISTBOX : i32 = 2;
pub const CTLCOLOR_BTN : i32 = 3;
pub const CTLCOLOR_DLG : i32 = 4;
pub const CTLCOLOR_SCROLLBAR : i32 = 5;
pub const CTLCOLOR_STATIC : i32 = 6;
pub const CTLCOLOR_MAX : i32 = 7;
pub const COLOR_SCROLLBAR : i32 = 0;
pub const COLOR_BACKGROUND : i32 = 1;
pub const COLOR_ACTIVECAPTION : i32 = 2;
pub const COLOR_INACTIVECAPTION : i32 = 3;
pub const COLOR_MENU : i32 = 4;
pub const COLOR_WINDOW : i32 = 5;
pub const COLOR_WINDOWFRAME : i32 = 6;
pub const COLOR_MENUTEXT : i32 = 7;
pub const COLOR_WINDOWTEXT : i32 = 8;
pub const COLOR_CAPTIONTEXT : i32 = 9;
pub const COLOR_ACTIVEBORDER : i32 = 10;
pub const COLOR_INACTIVEBORDER : i32 = 11;
pub const COLOR_APPWORKSPACE : i32 = 12;
pub const COLOR_HIGHLIGHT : i32 = 13;
pub const COLOR_HIGHLIGHTTEXT : i32 = 14;
pub const COLOR_BTNFACE : i32 = 15;
pub const COLOR_BTNSHADOW : i32 = 16;
pub const COLOR_GRAYTEXT : i32 = 17;
pub const COLOR_BTNTEXT : i32 = 18;
pub const COLOR_INACTIVECAPTIONTEXT : i32 = 19;
pub const COLOR_BTNHIGHLIGHT : i32 = 20;
pub const COLOR_3DDKSHADOW : i32 = 21;
pub const COLOR_3DLIGHT : i32 = 22;
pub const COLOR_INFOTEXT : i32 = 23;
pub const COLOR_INFOBK : i32 = 24;
pub const COLOR_HOTLIGHT : i32 = 26;
pub const COLOR_GRADIENTACTIVECAPTION : i32 = 27;
pub const COLOR_GRADIENTINACTIVECAPTION : i32 = 28;
pub const COLOR_MENUHILIGHT : i32 = 29;
pub const COLOR_MENUBAR : i32 = 30;
pub const COLOR_DESKTOP : i32 = 1;
pub const COLOR_3DFACE : i32 = 15;
pub const COLOR_3DSHADOW : i32 = 16;
pub const COLOR_3DHIGHLIGHT : i32 = 20;
pub const COLOR_3DHILIGHT : i32 = 20;
pub const COLOR_BTNHILIGHT : i32 = 20;
pub const GW_HWNDFIRST : i32 = 0;
pub const GW_HWNDLAST : i32 = 1;
pub const GW_HWNDNEXT : i32 = 2;
pub const GW_HWNDPREV : i32 = 3;
pub const GW_OWNER : i32 = 4;
pub const GW_CHILD : i32 = 5;
pub const GW_ENABLEDPOPUP : i32 = 6;
pub const GW_MAX : i32 = 6;
pub const MF_INSERT : i32 = 0;
pub const MF_CHANGE : i32 = 128;
pub const MF_APPEND : i32 = 256;
pub const MF_DELETE : i32 = 512;
pub const MF_REMOVE : i32 = 4096;
pub const MF_BYCOMMAND : i32 = 0;
pub const MF_BYPOSITION : i32 = 1024;
pub const MF_SEPARATOR : i32 = 2048;
pub const MF_ENABLED : i32 = 0;
pub const MF_GRAYED : i32 = 1;
pub const MF_DISABLED : i32 = 2;
pub const MF_UNCHECKED : i32 = 0;
pub const MF_CHECKED : i32 = 8;
pub const MF_USECHECKBITMAPS : i32 = 512;
pub const MF_STRING : i32 = 0;
pub const MF_BITMAP : i32 = 4;
pub const MF_OWNERDRAW : i32 = 256;
pub const MF_POPUP : i32 = 16;
pub const MF_MENUBARBREAK : i32 = 32;
pub const MF_MENUBREAK : i32 = 64;
pub const MF_UNHILITE : i32 = 0;
pub const MF_HILITE : i32 = 128;
pub const MF_DEFAULT : i32 = 4096;
pub const MF_SYSMENU : i32 = 8192;
pub const MF_HELP : i32 = 16384;
pub const MF_RIGHTJUSTIFY : i32 = 16384;
pub const MF_MOUSESELECT : i32 = 32768;
pub const MF_END : i32 = 128;
pub const MFT_STRING : i32 = 0;
pub const MFT_BITMAP : i32 = 4;
pub const MFT_MENUBARBREAK : i32 = 32;
pub const MFT_MENUBREAK : i32 = 64;
pub const MFT_OWNERDRAW : i32 = 256;
pub const MFT_RADIOCHECK : i32 = 512;
pub const MFT_SEPARATOR : i32 = 2048;
pub const MFT_RIGHTORDER : i32 = 8192;
pub const MFT_RIGHTJUSTIFY : i32 = 16384;
pub const MFS_GRAYED : i32 = 3;
pub const MFS_DISABLED : i32 = 3;
pub const MFS_CHECKED : i32 = 8;
pub const MFS_HILITE : i32 = 128;
pub const MFS_ENABLED : i32 = 0;
pub const MFS_UNCHECKED : i32 = 0;
pub const MFS_UNHILITE : i32 = 0;
pub const MFS_DEFAULT : i32 = 4096;
pub const SC_SIZE : i32 = 61440;
pub const SC_MOVE : i32 = 61456;
pub const SC_MINIMIZE : i32 = 61472;
pub const SC_MAXIMIZE : i32 = 61488;
pub const SC_NEXTWINDOW : i32 = 61504;
pub const SC_PREVWINDOW : i32 = 61520;
pub const SC_CLOSE : i32 = 61536;
pub const SC_VSCROLL : i32 = 61552;
pub const SC_HSCROLL : i32 = 61568;
pub const SC_MOUSEMENU : i32 = 61584;
pub const SC_KEYMENU : i32 = 61696;
pub const SC_ARRANGE : i32 = 61712;
pub const SC_RESTORE : i32 = 61728;
pub const SC_TASKLIST : i32 = 61744;
pub const SC_SCREENSAVE : i32 = 61760;
pub const SC_HOTKEY : i32 = 61776;
pub const SC_DEFAULT : i32 = 61792;
pub const SC_MONITORPOWER : i32 = 61808;
pub const SC_CONTEXTHELP : i32 = 61824;
pub const SC_SEPARATOR : i32 = 61455;
pub const SCF_ISSECURE : i32 = 1;
pub const SC_ICON : i32 = 61472;
pub const SC_ZOOM : i32 = 61488;
pub const IDC_ARROW : u16 = 32512;
pub const IDC_IBEAM : u16 = 32513;
pub const IDC_WAIT : u16 = 32514;
pub const IDC_CROSS : u16 = 32515;
pub const IDC_UPARROW : u16 = 32516;
pub const IDC_SIZE : u16 = 32640;
pub const IDC_ICON : u16 = 32641;
pub const IDC_SIZENWSE : u16 = 32642;
pub const IDC_SIZENESW : u16 = 32643;
pub const IDC_SIZEWE : u16 = 32644;
pub const IDC_SIZENS : u16 = 32645;
pub const IDC_SIZEALL : u16 = 32646;
pub const IDC_NO : u16 = 32648;
pub const IDC_HAND : u16 = 32649;
pub const IDC_APPSTARTING : i32 = 32650;
pub const IDC_HELP : i32 = 32651;
pub const IDC_PIN : i32 = 32671;
pub const IDC_PERSON : i32 = 32672;
pub const IMAGE_BITMAP : i32 = 0;
pub const IMAGE_ICON : i32 = 1;
pub const IMAGE_CURSOR : i32 = 2;
pub const IMAGE_ENHMETAFILE : i32 = 3;
pub const LR_DEFAULTCOLOR : i32 = 0;
pub const LR_MONOCHROME : i32 = 1;
pub const LR_COLOR : i32 = 2;
pub const LR_COPYRETURNORG : i32 = 4;
pub const LR_COPYDELETEORG : i32 = 8;
pub const LR_LOADFROMFILE : i32 = 16;
pub const LR_LOADTRANSPARENT : i32 = 32;
pub const LR_DEFAULTSIZE : i32 = 64;
pub const LR_VGACOLOR : i32 = 128;
pub const LR_LOADMAP3DCOLORS : i32 = 4096;
pub const LR_CREATEDIBSECTION : i32 = 8192;
pub const LR_COPYFROMRESOURCE : i32 = 16384;
pub const LR_SHARED : i32 = 32768;
pub const RES_ICON : i32 = 1;
pub const RES_CURSOR : i32 = 2;
pub const OBM_CLOSE : i32 = 32754;
pub const OBM_UPARROW : i32 = 32753;
pub const OBM_DNARROW : i32 = 32752;
pub const OBM_RGARROW : i32 = 32751;
pub const OBM_LFARROW : i32 = 32750;
pub const OBM_REDUCE : i32 = 32749;
pub const OBM_ZOOM : i32 = 32748;
pub const OBM_RESTORE : i32 = 32747;
pub const OBM_REDUCED : i32 = 32746;
pub const OBM_ZOOMD : i32 = 32745;
pub const OBM_RESTORED : i32 = 32744;
pub const OBM_UPARROWD : i32 = 32743;
pub const OBM_DNARROWD : i32 = 32742;
pub const OBM_RGARROWD : i32 = 32741;
pub const OBM_LFARROWD : i32 = 32740;
pub const OBM_MNARROW : i32 = 32739;
pub const OBM_COMBO : i32 = 32738;
pub const OBM_UPARROWI : i32 = 32737;
pub const OBM_DNARROWI : i32 = 32736;
pub const OBM_RGARROWI : i32 = 32735;
pub const OBM_LFARROWI : i32 = 32734;
pub const OBM_OLD_CLOSE : i32 = 32767;
pub const OBM_SIZE : i32 = 32766;
pub const OBM_OLD_UPARROW : i32 = 32765;
pub const OBM_OLD_DNARROW : i32 = 32764;
pub const OBM_OLD_RGARROW : i32 = 32763;
pub const OBM_OLD_LFARROW : i32 = 32762;
pub const OBM_BTSIZE : i32 = 32761;
pub const OBM_CHECK : i32 = 32760;
pub const OBM_CHECKBOXES : i32 = 32759;
pub const OBM_BTNCORNERS : i32 = 32758;
pub const OBM_OLD_REDUCE : i32 = 32757;
pub const OBM_OLD_ZOOM : i32 = 32756;
pub const OBM_OLD_RESTORE : i32 = 32755;
pub const OCR_NORMAL : i32 = 32512;
pub const OCR_IBEAM : i32 = 32513;
pub const OCR_WAIT : i32 = 32514;
pub const OCR_CROSS : i32 = 32515;
pub const OCR_UP : i32 = 32516;
pub const OCR_SIZE : i32 = 32640;
pub const OCR_ICON : i32 = 32641;
pub const OCR_SIZENWSE : i32 = 32642;
pub const OCR_SIZENESW : i32 = 32643;
pub const OCR_SIZEWE : i32 = 32644;
pub const OCR_SIZENS : i32 = 32645;
pub const OCR_SIZEALL : i32 = 32646;
pub const OCR_ICOCUR : i32 = 32647;
pub const OCR_NO : i32 = 32648;
pub const OCR_HAND : i32 = 32649;
pub const OCR_APPSTARTING : i32 = 32650;
pub const OIC_SAMPLE : i32 = 32512;
pub const OIC_HAND : i32 = 32513;
pub const OIC_QUES : i32 = 32514;
pub const OIC_BANG : i32 = 32515;
pub const OIC_NOTE : i32 = 32516;
pub const OIC_WINLOGO : i32 = 32517;
pub const OIC_WARNING : i32 = 32515;
pub const OIC_ERROR : i32 = 32513;
pub const OIC_INFORMATION : i32 = 32516;
pub const OIC_SHIELD : i32 = 32518;
pub const ORD_LANGDRIVER : i32 = 1;
pub const IDI_APPLICATION : u16 = 32512;
pub const IDI_HAND : u16 = 32513;
pub const IDI_QUESTION : u16 = 32514;
pub const IDI_EXCLAMATION : u16 = 32515;
pub const IDI_ASTERISK : u16 = 32516;
pub const IDI_WINLOGO : u16 = 32517;
pub const IDI_SHIELD : u16 = 32518;
pub const IDI_WARNING : u16 = 32515;
pub const IDI_ERROR : u16 = 32513;
pub const IDI_INFORMATION : u16 = 32516;
pub const IDOK : i32 = 1;
pub const IDCANCEL : i32 = 2;
pub const IDABORT : i32 = 3;
pub const IDRETRY : i32 = 4;
pub const IDIGNORE : i32 = 5;
pub const IDYES : i32 = 6;
pub const IDNO : i32 = 7;
pub const IDCLOSE : i32 = 8;
pub const IDHELP : i32 = 9;
pub const IDTRYAGAIN : i32 = 10;
pub const IDCONTINUE : i32 = 11;
pub const IDTIMEOUT : i32 = 32000;
pub const ES_LEFT : i32 = 0;
pub const ES_CENTER : i32 = 1;
pub const ES_RIGHT : i32 = 2;
pub const ES_MULTILINE : i32 = 4;
pub const ES_UPPERCASE : i32 = 8;
pub const ES_LOWERCASE : i32 = 16;
pub const ES_PASSWORD : i32 = 32;
pub const ES_AUTOVSCROLL : i32 = 64;
pub const ES_AUTOHSCROLL : i32 = 128;
pub const ES_NOHIDESEL : i32 = 256;
pub const ES_OEMCONVERT : i32 = 1024;
pub const ES_READONLY : i32 = 2048;
pub const ES_WANTRETURN : i32 = 4096;
pub const ES_NUMBER : i32 = 8192;
pub const EN_SETFOCUS : i32 = 256;
pub const EN_KILLFOCUS : i32 = 512;
pub const EN_CHANGE : i32 = 768;
pub const EN_UPDATE : i32 = 1024;
pub const EN_ERRSPACE : i32 = 1280;
pub const EN_MAXTEXT : i32 = 1281;
pub const EN_HSCROLL : i32 = 1537;
pub const EN_VSCROLL : i32 = 1538;
pub const EN_ALIGN_LTR_EC : i32 = 1792;
pub const EN_ALIGN_RTL_EC : i32 = 1793;
pub const EN_BEFORE_PASTE : i32 = 2048;
pub const EN_AFTER_PASTE : i32 = 2049;
pub const EC_LEFTMARGIN : i32 = 1;
pub const EC_RIGHTMARGIN : i32 = 2;
pub const EC_USEFONTINFO : i32 = 65535;
pub const EMSIS_COMPOSITIONSTRING : i32 = 1;
pub const EIMES_GETCOMPSTRATONCE : i32 = 1;
pub const EIMES_CANCELCOMPSTRINFOCUS : i32 = 2;
pub const EIMES_COMPLETECOMPSTRKILLFOCUS : i32 = 4;
pub const EM_GETSEL : i32 = 176;
pub const EM_SETSEL : i32 = 177;
pub const EM_GETRECT : i32 = 178;
pub const EM_SETRECT : i32 = 179;
pub const EM_SETRECTNP : i32 = 180;
pub const EM_SCROLL : i32 = 181;
pub const EM_LINESCROLL : i32 = 182;
pub const EM_SCROLLCARET : i32 = 183;
pub const EM_GETMODIFY : i32 = 184;
pub const EM_SETMODIFY : i32 = 185;
pub const EM_GETLINECOUNT : i32 = 186;
pub const EM_LINEINDEX : i32 = 187;
pub const EM_SETHANDLE : i32 = 188;
pub const EM_GETHANDLE : i32 = 189;
pub const EM_GETTHUMB : i32 = 190;
pub const EM_LINELENGTH : i32 = 193;
pub const EM_REPLACESEL : i32 = 194;
pub const EM_GETLINE : i32 = 196;
pub const EM_LIMITTEXT : i32 = 197;
pub const EM_CANUNDO : i32 = 198;
pub const EM_UNDO : i32 = 199;
pub const EM_FMTLINES : i32 = 200;
pub const EM_LINEFROMCHAR : i32 = 201;
pub const EM_SETTABSTOPS : i32 = 203;
pub const EM_SETPASSWORDCHAR : i32 = 204;
pub const EM_EMPTYUNDOBUFFER : i32 = 205;
pub const EM_GETFIRSTVISIBLELINE : i32 = 206;
pub const EM_SETREADONLY : i32 = 207;
pub const EM_SETWORDBREAKPROC : i32 = 208;
pub const EM_GETWORDBREAKPROC : i32 = 209;
pub const EM_GETPASSWORDCHAR : i32 = 210;
pub const EM_SETMARGINS : i32 = 211;
pub const EM_GETMARGINS : i32 = 212;
pub const EM_SETLIMITTEXT : i32 = 197;
pub const EM_GETLIMITTEXT : i32 = 213;
pub const EM_POSFROMCHAR : i32 = 214;
pub const EM_CHARFROMPOS : i32 = 215;
pub const EM_SETIMESTATUS : i32 = 216;
pub const EM_GETIMESTATUS : i32 = 217;
pub const EM_ENABLEFEATURE : i32 = 218;
pub const WB_LEFT : i32 = 0;
pub const WB_RIGHT : i32 = 1;
pub const WB_ISDELIMITER : i32 = 2;
pub const BS_PUSHBUTTON : i32 = 0;
pub const BS_DEFPUSHBUTTON : i32 = 1;
pub const BS_CHECKBOX : i32 = 2;
pub const BS_AUTOCHECKBOX : i32 = 3;
pub const BS_RADIOBUTTON : i32 = 4;
pub const BS_3STATE : i32 = 5;
pub const BS_AUTO3STATE : i32 = 6;
pub const BS_GROUPBOX : i32 = 7;
pub const BS_USERBUTTON : i32 = 8;
pub const BS_AUTORADIOBUTTON : i32 = 9;
pub const BS_PUSHBOX : i32 = 10;
pub const BS_OWNERDRAW : i32 = 11;
pub const BS_TYPEMASK : i32 = 15;
pub const BS_LEFTTEXT : i32 = 32;
pub const BS_TEXT : i32 = 0;
pub const BS_ICON : i32 = 64;
pub const BS_BITMAP : i32 = 128;
pub const BS_LEFT : i32 = 256;
pub const BS_RIGHT : i32 = 512;
pub const BS_CENTER : i32 = 768;
pub const BS_TOP : i32 = 1024;
pub const BS_BOTTOM : i32 = 2048;
pub const BS_VCENTER : i32 = 3072;
pub const BS_PUSHLIKE : i32 = 4096;
pub const BS_MULTILINE : i32 = 8192;
pub const BS_NOTIFY : i32 = 16384;
pub const BS_FLAT : i32 = 32768;
pub const BS_RIGHTBUTTON : i32 = 32;
pub const BN_CLICKED : i32 = 0;
pub const BN_PAINT : i32 = 1;
pub const BN_HILITE : i32 = 2;
pub const BN_UNHILITE : i32 = 3;
pub const BN_DISABLE : i32 = 4;
pub const BN_DOUBLECLICKED : i32 = 5;
pub const BN_PUSHED : i32 = 2;
pub const BN_UNPUSHED : i32 = 3;
pub const BN_DBLCLK : i32 = 5;
pub const BN_SETFOCUS : i32 = 6;
pub const BN_KILLFOCUS : i32 = 7;
pub const BM_GETCHECK : i32 = 240;
pub const BM_SETCHECK : i32 = 241;
pub const BM_GETSTATE : i32 = 242;
pub const BM_SETSTATE : i32 = 243;
pub const BM_SETSTYLE : i32 = 244;
pub const BM_CLICK : i32 = 245;
pub const BM_GETIMAGE : i32 = 246;
pub const BM_SETIMAGE : i32 = 247;
pub const BM_SETDONTCLICK : i32 = 248;
pub const BST_UNCHECKED : i32 = 0;
pub const BST_CHECKED : i32 = 1;
pub const BST_INDETERMINATE : i32 = 2;
pub const BST_PUSHED : i32 = 4;
pub const BST_FOCUS : i32 = 8;
pub const SS_LEFT : i32 = 0;
pub const SS_CENTER : i32 = 1;
pub const SS_RIGHT : i32 = 2;
pub const SS_ICON : i32 = 3;
pub const SS_BLACKRECT : i32 = 4;
pub const SS_GRAYRECT : i32 = 5;
pub const SS_WHITERECT : i32 = 6;
pub const SS_BLACKFRAME : i32 = 7;
pub const SS_GRAYFRAME : i32 = 8;
pub const SS_WHITEFRAME : i32 = 9;
pub const SS_USERITEM : i32 = 10;
pub const SS_SIMPLE : i32 = 11;
pub const SS_LEFTNOWORDWRAP : i32 = 12;
pub const SS_OWNERDRAW : i32 = 13;
pub const SS_BITMAP : i32 = 14;
pub const SS_ENHMETAFILE : i32 = 15;
pub const SS_ETCHEDHORZ : i32 = 16;
pub const SS_ETCHEDVERT : i32 = 17;
pub const SS_ETCHEDFRAME : i32 = 18;
pub const SS_TYPEMASK : i32 = 31;
pub const SS_REALSIZECONTROL : i32 = 64;
pub const SS_NOPREFIX : i32 = 128;
pub const SS_NOTIFY : i32 = 256;
pub const SS_CENTERIMAGE : i32 = 512;
pub const SS_RIGHTJUST : i32 = 1024;
pub const SS_REALSIZEIMAGE : i32 = 2048;
pub const SS_SUNKEN : i32 = 4096;
pub const SS_EDITCONTROL : i32 = 8192;
pub const SS_ENDELLIPSIS : i32 = 16384;
pub const SS_PATHELLIPSIS : i32 = 32768;
pub const SS_WORDELLIPSIS : i32 = 49152;
pub const SS_ELLIPSISMASK : i32 = 49152;
pub const STM_SETICON : i32 = 368;
pub const STM_GETICON : i32 = 369;
pub const STM_SETIMAGE : i32 = 370;
pub const STM_GETIMAGE : i32 = 371;
pub const STN_CLICKED : i32 = 0;
pub const STN_DBLCLK : i32 = 1;
pub const STN_ENABLE : i32 = 2;
pub const STN_DISABLE : i32 = 3;
pub const STM_MSGMAX : i32 = 372;
pub const WC_DIALOG : u16 = 32770;
pub const DWL_MSGRESULT : i32 = 0;
pub const DWL_DLGPROC : i32 = 4;
pub const DWL_USER : i32 = 8;
pub const DWLP_MSGRESULT : i32 = 0;
pub const DDL_READWRITE : i32 = 0;
pub const DDL_READONLY : i32 = 1;
pub const DDL_HIDDEN : i32 = 2;
pub const DDL_SYSTEM : i32 = 4;
pub const DDL_DIRECTORY : i32 = 16;
pub const DDL_ARCHIVE : i32 = 32;
pub const DDL_POSTMSGS : i32 = 8192;
pub const DDL_DRIVES : i32 = 16384;
pub const DDL_EXCLUSIVE : i32 = 32768;
pub const DS_ABSALIGN : i32 = 1;
pub const DS_SYSMODAL : i32 = 2;
pub const DS_LOCALEDIT : i32 = 32;
pub const DS_SETFONT : i32 = 64;
pub const DS_MODALFRAME : i32 = 128;
pub const DS_NOIDLEMSG : i32 = 256;
pub const DS_SETFOREGROUND : i32 = 512;
pub const DS_3DLOOK : i32 = 4;
pub const DS_FIXEDSYS : i32 = 8;
pub const DS_NOFAILCREATE : i32 = 16;
pub const DS_CONTROL : i32 = 1024;
pub const DS_CENTER : i32 = 2048;
pub const DS_CENTERMOUSE : i32 = 4096;
pub const DS_CONTEXTHELP : i32 = 8192;
pub const DS_SHELLFONT : i32 = 72;
pub const DS_USEPIXELS : i32 = 32768;
pub const DM_GETDEFID : i32 = 1024;
pub const DM_SETDEFID : i32 = 1025;
pub const DM_REPOSITION : i32 = 1026;
pub const DC_HASDEFID : i32 = 21323;
pub const DLGC_WANTARROWS : i32 = 1;
pub const DLGC_WANTTAB : i32 = 2;
pub const DLGC_WANTALLKEYS : i32 = 4;
pub const DLGC_WANTMESSAGE : i32 = 4;
pub const DLGC_HASSETSEL : i32 = 8;
pub const DLGC_DEFPUSHBUTTON : i32 = 16;
pub const DLGC_UNDEFPUSHBUTTON : i32 = 32;
pub const DLGC_RADIOBUTTON : i32 = 64;
pub const DLGC_WANTCHARS : i32 = 128;
pub const DLGC_STATIC : i32 = 256;
pub const DLGC_BUTTON : i32 = 8192;
pub const LB_CTLCODE : i32 = 0;
pub const LB_OKAY : i32 = 0;
pub const LB_ERR : i32 = -1;
pub const LB_ERRSPACE : i32 = -2;
pub const LBN_ERRSPACE : i32 = -2;
pub const LBN_SELCHANGE : i32 = 1;
pub const LBN_DBLCLK : i32 = 2;
pub const LBN_SELCANCEL : i32 = 3;
pub const LBN_SETFOCUS : i32 = 4;
pub const LBN_KILLFOCUS : i32 = 5;
pub const LB_ADDSTRING : i32 = 384;
pub const LB_INSERTSTRING : i32 = 385;
pub const LB_DELETESTRING : i32 = 386;
pub const LB_SELITEMRANGEEX : i32 = 387;
pub const LB_RESETCONTENT : i32 = 388;
pub const LB_SETSEL : i32 = 389;
pub const LB_SETCURSEL : i32 = 390;
pub const LB_GETSEL : i32 = 391;
pub const LB_GETCURSEL : i32 = 392;
pub const LB_GETTEXT : i32 = 393;
pub const LB_GETTEXTLEN : i32 = 394;
pub const LB_GETCOUNT : i32 = 395;
pub const LB_SELECTSTRING : i32 = 396;
pub const LB_DIR : i32 = 397;
pub const LB_GETTOPINDEX : i32 = 398;
pub const LB_FINDSTRING : i32 = 399;
pub const LB_GETSELCOUNT : i32 = 400;
pub const LB_GETSELITEMS : i32 = 401;
pub const LB_SETTABSTOPS : i32 = 402;
pub const LB_GETHORIZONTALEXTENT : i32 = 403;
pub const LB_SETHORIZONTALEXTENT : i32 = 404;
pub const LB_SETCOLUMNWIDTH : i32 = 405;
pub const LB_ADDFILE : i32 = 406;
pub const LB_SETTOPINDEX : i32 = 407;
pub const LB_GETITEMRECT : i32 = 408;
pub const LB_GETITEMDATA : i32 = 409;
pub const LB_SETITEMDATA : i32 = 410;
pub const LB_SELITEMRANGE : i32 = 411;
pub const LB_SETANCHORINDEX : i32 = 412;
pub const LB_GETANCHORINDEX : i32 = 413;
pub const LB_SETCARETINDEX : i32 = 414;
pub const LB_GETCARETINDEX : i32 = 415;
pub const LB_SETITEMHEIGHT : i32 = 416;
pub const LB_GETITEMHEIGHT : i32 = 417;
pub const LB_FINDSTRINGEXACT : i32 = 418;
pub const LB_SETLOCALE : i32 = 421;
pub const LB_GETLOCALE : i32 = 422;
pub const LB_SETCOUNT : i32 = 423;
pub const LB_INITSTORAGE : i32 = 424;
pub const LB_ITEMFROMPOINT : i32 = 425;
pub const LB_MULTIPLEADDSTRING : i32 = 433;
pub const LB_GETLISTBOXINFO : i32 = 434;
pub const LB_MSGMAX : i32 = 435;
pub const LBS_NOTIFY : u32 = 1;
pub const LBS_SORT : u32 = 2;
pub const LBS_NOREDRAW : u32 = 4;
pub const LBS_MULTIPLESEL : u32 = 8;
pub const LBS_OWNERDRAWFIXED : u32 = 16;
pub const LBS_OWNERDRAWVARIABLE : u32 = 32;
pub const LBS_HASSTRINGS : u32 = 64;
pub const LBS_USETABSTOPS : u32 = 128;
pub const LBS_NOINTEGRALHEIGHT : u32 = 256;
pub const LBS_MULTICOLUMN : u32 = 512;
pub const LBS_WANTKEYBOARDINPUT : u32 = 1024;
pub const LBS_EXTENDEDSEL : u32 = 2048;
pub const LBS_DISABLENOSCROLL : u32 = 4096;
pub const LBS_NODATA : u32 = 8192;
pub const LBS_NOSEL : u32 = 16384;
pub const LBS_COMBOBOX : u32 = 32768;
pub const LBS_STANDARD : u32 = 10485763;
pub const CB_OKAY : i32 = 0;
pub const CB_ERR : i32 = -1;
pub const CB_ERRSPACE : i32 = -2;
pub const CBN_ERRSPACE : i32 = -1;
pub const CBN_SELCHANGE : i32 = 1;
pub const CBN_DBLCLK : i32 = 2;
pub const CBN_SETFOCUS : i32 = 3;
pub const CBN_KILLFOCUS : i32 = 4;
pub const CBN_EDITCHANGE : i32 = 5;
pub const CBN_EDITUPDATE : i32 = 6;
pub const CBN_DROPDOWN : i32 = 7;
pub const CBN_CLOSEUP : i32 = 8;
pub const CBN_SELENDOK : i32 = 9;
pub const CBN_SELENDCANCEL : i32 = 10;
pub const CBS_SIMPLE : i32 = 1;
pub const CBS_DROPDOWN : i32 = 2;
pub const CBS_DROPDOWNLIST : i32 = 3;
pub const CBS_OWNERDRAWFIXED : i32 = 16;
pub const CBS_OWNERDRAWVARIABLE : i32 = 32;
pub const CBS_AUTOHSCROLL : i32 = 64;
pub const CBS_OEMCONVERT : i32 = 128;
pub const CBS_SORT : i32 = 256;
pub const CBS_HASSTRINGS : i32 = 512;
pub const CBS_NOINTEGRALHEIGHT : i32 = 1024;
pub const CBS_DISABLENOSCROLL : i32 = 2048;
pub const CBS_UPPERCASE : i32 = 8192;
pub const CBS_LOWERCASE : i32 = 16384;
pub const CB_GETEDITSEL : i32 = 320;
pub const CB_LIMITTEXT : i32 = 321;
pub const CB_SETEDITSEL : i32 = 322;
pub const CB_ADDSTRING : i32 = 323;
pub const CB_DELETESTRING : i32 = 324;
pub const CB_DIR : i32 = 325;
pub const CB_GETCOUNT : i32 = 326;
pub const CB_GETCURSEL : i32 = 327;
pub const CB_GETLBTEXT : i32 = 328;
pub const CB_GETLBTEXTLEN : i32 = 329;
pub const CB_INSERTSTRING : i32 = 330;
pub const CB_RESETCONTENT : i32 = 331;
pub const CB_FINDSTRING : i32 = 332;
pub const CB_SELECTSTRING : i32 = 333;
pub const CB_SETCURSEL : i32 = 334;
pub const CB_SHOWDROPDOWN : i32 = 335;
pub const CB_GETITEMDATA : i32 = 336;
pub const CB_SETITEMDATA : i32 = 337;
pub const CB_GETDROPPEDCONTROLRECT : i32 = 338;
pub const CB_SETITEMHEIGHT : i32 = 339;
pub const CB_GETITEMHEIGHT : i32 = 340;
pub const CB_SETEXTENDEDUI : i32 = 341;
pub const CB_GETEXTENDEDUI : i32 = 342;
pub const CB_GETDROPPEDSTATE : i32 = 343;
pub const CB_FINDSTRINGEXACT : i32 = 344;
pub const CB_SETLOCALE : i32 = 345;
pub const CB_GETLOCALE : i32 = 346;
pub const CB_GETTOPINDEX : i32 = 347;
pub const CB_SETTOPINDEX : i32 = 348;
pub const CB_GETHORIZONTALEXTENT : i32 = 349;
pub const CB_SETHORIZONTALEXTENT : i32 = 350;
pub const CB_GETDROPPEDWIDTH : i32 = 351;
pub const CB_SETDROPPEDWIDTH : i32 = 352;
pub const CB_INITSTORAGE : i32 = 353;
pub const CB_MULTIPLEADDSTRING : i32 = 355;
pub const CB_GETCOMBOBOXINFO : i32 = 356;
pub const CB_MSGMAX : i32 = 357;
pub const SBS_HORZ : i32 = 0;
pub const SBS_VERT : i32 = 1;
pub const SBS_TOPALIGN : i32 = 2;
pub const SBS_LEFTALIGN : i32 = 2;
pub const SBS_BOTTOMALIGN : i32 = 4;
pub const SBS_RIGHTALIGN : i32 = 4;
pub const SBS_SIZEBOXTOPLEFTALIGN : i32 = 2;
pub const SBS_SIZEBOXBOTTOMRIGHTALIGN : i32 = 4;
pub const SBS_SIZEBOX : i32 = 8;
pub const SBS_SIZEGRIP : i32 = 16;
pub const SBM_SETPOS : i32 = 224;
pub const SBM_GETPOS : i32 = 225;
pub const SBM_SETRANGE : i32 = 226;
pub const SBM_SETRANGEREDRAW : i32 = 230;
pub const SBM_GETRANGE : i32 = 227;
pub const SBM_ENABLE_ARROWS : i32 = 228;
pub const SBM_SETSCROLLINFO : i32 = 233;
pub const SBM_GETSCROLLINFO : i32 = 234;
pub const SBM_GETSCROLLBARINFO : i32 = 235;
pub const SIF_RANGE : i32 = 1;
pub const SIF_PAGE : i32 = 2;
pub const SIF_POS : i32 = 4;
pub const SIF_DISABLENOSCROLL : i32 = 8;
pub const SIF_TRACKPOS : i32 = 16;
pub const SIF_ALL : i32 = 23;
pub const MDIS_ALLCHILDSTYLES : i32 = 1;
pub const MDITILE_VERTICAL : i32 = 0;
pub const MDITILE_HORIZONTAL : i32 = 1;
pub const MDITILE_SKIPDISABLED : i32 = 2;
pub const MDITILE_ZORDER : i32 = 4;
pub const HELP_CONTEXT : i32 = 1;
pub const HELP_QUIT : i32 = 2;
pub const HELP_INDEX : i32 = 3;
pub const HELP_CONTENTS : i32 = 3;
pub const HELP_HELPONHELP : i32 = 4;
pub const HELP_SETINDEX : i32 = 5;
pub const HELP_SETCONTENTS : i32 = 5;
pub const HELP_CONTEXTPOPUP : i32 = 8;
pub const HELP_FORCEFILE : i32 = 9;
pub const HELP_KEY : i32 = 257;
pub const HELP_COMMAND : i32 = 258;
pub const HELP_PARTIALKEY : i32 = 261;
pub const HELP_MULTIKEY : i32 = 513;
pub const HELP_SETWINPOS : i32 = 515;
pub const HELP_CONTEXTMENU : i32 = 10;
pub const HELP_FINDER : i32 = 11;
pub const HELP_WM_HELP : i32 = 12;
pub const HELP_SETPOPUP_POS : i32 = 13;
pub const HELP_TCARD : i32 = 32768;
pub const HELP_TCARD_DATA : i32 = 16;
pub const HELP_TCARD_OTHER_CALLER : i32 = 17;
pub const IDH_NO_HELP : i32 = 28440;
pub const IDH_MISSING_CONTEXT : i32 = 28441;
pub const IDH_GENERIC_HELP_BUTTON : i32 = 28442;
pub const IDH_OK : i32 = 28443;
pub const IDH_CANCEL : i32 = 28444;
pub const IDH_HELP : i32 = 28445;
pub const GR_GDIOBJECTS : i32 = 0;
pub const GR_USEROBJECTS : i32 = 1;
pub const GR_GDIOBJECTS_PEAK : i32 = 2;
pub const GR_USEROBJECTS_PEAK : i32 = 4;
pub const GR_GLOBAL : i32 = -2;
pub const SPI_GETBEEP : i32 = 1;
pub const SPI_SETBEEP : i32 = 2;
pub const SPI_GETMOUSE : i32 = 3;
pub const SPI_SETMOUSE : i32 = 4;
pub const SPI_GETBORDER : i32 = 5;
pub const SPI_SETBORDER : i32 = 6;
pub const SPI_GETKEYBOARDSPEED : i32 = 10;
pub const SPI_SETKEYBOARDSPEED : i32 = 11;
pub const SPI_LANGDRIVER : i32 = 12;
pub const SPI_ICONHORIZONTALSPACING : i32 = 13;
pub const SPI_GETSCREENSAVETIMEOUT : i32 = 14;
pub const SPI_SETSCREENSAVETIMEOUT : i32 = 15;
pub const SPI_GETSCREENSAVEACTIVE : i32 = 16;
pub const SPI_SETSCREENSAVEACTIVE : i32 = 17;
pub const SPI_GETGRIDGRANULARITY : i32 = 18;
pub const SPI_SETGRIDGRANULARITY : i32 = 19;
pub const SPI_SETDESKWALLPAPER : i32 = 20;
pub const SPI_SETDESKPATTERN : i32 = 21;
pub const SPI_GETKEYBOARDDELAY : i32 = 22;
pub const SPI_SETKEYBOARDDELAY : i32 = 23;
pub const SPI_ICONVERTICALSPACING : i32 = 24;
pub const SPI_GETICONTITLEWRAP : i32 = 25;
pub const SPI_SETICONTITLEWRAP : i32 = 26;
pub const SPI_GETMENUDROPALIGNMENT : i32 = 27;
pub const SPI_SETMENUDROPALIGNMENT : i32 = 28;
pub const SPI_SETDOUBLECLKWIDTH : i32 = 29;
pub const SPI_SETDOUBLECLKHEIGHT : i32 = 30;
pub const SPI_GETICONTITLELOGFONT : i32 = 31;
pub const SPI_SETDOUBLECLICKTIME : i32 = 32;
pub const SPI_SETMOUSEBUTTONSWAP : i32 = 33;
pub const SPI_SETICONTITLELOGFONT : i32 = 34;
pub const SPI_GETFASTTASKSWITCH : i32 = 35;
pub const SPI_SETFASTTASKSWITCH : i32 = 36;
pub const SPI_SETDRAGFULLWINDOWS : i32 = 37;
pub const SPI_GETDRAGFULLWINDOWS : i32 = 38;
pub const SPI_GETNONCLIENTMETRICS : i32 = 41;
pub const SPI_SETNONCLIENTMETRICS : i32 = 42;
pub const SPI_GETMINIMIZEDMETRICS : i32 = 43;
pub const SPI_SETMINIMIZEDMETRICS : i32 = 44;
pub const SPI_GETICONMETRICS : i32 = 45;
pub const SPI_SETICONMETRICS : i32 = 46;
pub const SPI_SETWORKAREA : i32 = 47;
pub const SPI_GETWORKAREA : i32 = 48;
pub const SPI_SETPENWINDOWS : i32 = 49;
pub const SPI_GETHIGHCONTRAST : i32 = 66;
pub const SPI_SETHIGHCONTRAST : i32 = 67;
pub const SPI_GETKEYBOARDPREF : i32 = 68;
pub const SPI_SETKEYBOARDPREF : i32 = 69;
pub const SPI_GETSCREENREADER : i32 = 70;
pub const SPI_SETSCREENREADER : i32 = 71;
pub const SPI_GETANIMATION : i32 = 72;
pub const SPI_SETANIMATION : i32 = 73;
pub const SPI_GETFONTSMOOTHING : i32 = 74;
pub const SPI_SETFONTSMOOTHING : i32 = 75;
pub const SPI_SETDRAGWIDTH : i32 = 76;
pub const SPI_SETDRAGHEIGHT : i32 = 77;
pub const SPI_SETHANDHELD : i32 = 78;
pub const SPI_GETLOWPOWERTIMEOUT : i32 = 79;
pub const SPI_GETPOWEROFFTIMEOUT : i32 = 80;
pub const SPI_SETLOWPOWERTIMEOUT : i32 = 81;
pub const SPI_SETPOWEROFFTIMEOUT : i32 = 82;
pub const SPI_GETLOWPOWERACTIVE : i32 = 83;
pub const SPI_GETPOWEROFFACTIVE : i32 = 84;
pub const SPI_SETLOWPOWERACTIVE : i32 = 85;
pub const SPI_SETPOWEROFFACTIVE : i32 = 86;
pub const SPI_SETCURSORS : i32 = 87;
pub const SPI_SETICONS : i32 = 88;
pub const SPI_GETDEFAULTINPUTLANG : i32 = 89;
pub const SPI_SETDEFAULTINPUTLANG : i32 = 90;
pub const SPI_SETLANGTOGGLE : i32 = 91;
pub const SPI_GETWINDOWSEXTENSION : i32 = 92;
pub const SPI_SETMOUSETRAILS : i32 = 93;
pub const SPI_GETMOUSETRAILS : i32 = 94;
pub const SPI_SETSCREENSAVERRUNNING : i32 = 97;
pub const SPI_SCREENSAVERRUNNING : i32 = 97;
pub const SPI_GETFILTERKEYS : i32 = 50;
pub const SPI_SETFILTERKEYS : i32 = 51;
pub const SPI_GETTOGGLEKEYS : i32 = 52;
pub const SPI_SETTOGGLEKEYS : i32 = 53;
pub const SPI_GETMOUSEKEYS : i32 = 54;
pub const SPI_SETMOUSEKEYS : i32 = 55;
pub const SPI_GETSHOWSOUNDS : i32 = 56;
pub const SPI_SETSHOWSOUNDS : i32 = 57;
pub const SPI_GETSTICKYKEYS : i32 = 58;
pub const SPI_SETSTICKYKEYS : i32 = 59;
pub const SPI_GETACCESSTIMEOUT : i32 = 60;
pub const SPI_SETACCESSTIMEOUT : i32 = 61;
pub const SPI_GETSERIALKEYS : i32 = 62;
pub const SPI_SETSERIALKEYS : i32 = 63;
pub const SPI_GETSOUNDSENTRY : i32 = 64;
pub const SPI_SETSOUNDSENTRY : i32 = 65;
pub const SPI_GETSNAPTODEFBUTTON : i32 = 95;
pub const SPI_SETSNAPTODEFBUTTON : i32 = 96;
pub const SPI_GETMOUSEHOVERWIDTH : i32 = 98;
pub const SPI_SETMOUSEHOVERWIDTH : i32 = 99;
pub const SPI_GETMOUSEHOVERHEIGHT : i32 = 100;
pub const SPI_SETMOUSEHOVERHEIGHT : i32 = 101;
pub const SPI_GETMOUSEHOVERTIME : i32 = 102;
pub const SPI_SETMOUSEHOVERTIME : i32 = 103;
pub const SPI_GETWHEELSCROLLLINES : i32 = 104;
pub const SPI_SETWHEELSCROLLLINES : i32 = 105;
pub const SPI_GETMENUSHOWDELAY : i32 = 106;
pub const SPI_SETMENUSHOWDELAY : i32 = 107;
pub const SPI_GETWHEELSCROLLCHARS : i32 = 108;
pub const SPI_SETWHEELSCROLLCHARS : i32 = 109;
pub const SPI_GETSHOWIMEUI : i32 = 110;
pub const SPI_SETSHOWIMEUI : i32 = 111;
pub const SPI_GETMOUSESPEED : i32 = 112;
pub const SPI_SETMOUSESPEED : i32 = 113;
pub const SPI_GETSCREENSAVERRUNNING : i32 = 114;
pub const SPI_GETDESKWALLPAPER : i32 = 115;
pub const SPI_GETAUDIODESCRIPTION : i32 = 116;
pub const SPI_SETAUDIODESCRIPTION : i32 = 117;
pub const SPI_GETSCREENSAVESECURE : i32 = 118;
pub const SPI_SETSCREENSAVESECURE : i32 = 119;
pub const SPI_GETHUNGAPPTIMEOUT : i32 = 120;
pub const SPI_SETHUNGAPPTIMEOUT : i32 = 121;
pub const SPI_GETWAITTOKILLTIMEOUT : i32 = 122;
pub const SPI_SETWAITTOKILLTIMEOUT : i32 = 123;
pub const SPI_GETWAITTOKILLSERVICETIMEOUT : i32 = 124;
pub const SPI_SETWAITTOKILLSERVICETIMEOUT : i32 = 125;
pub const SPI_GETMOUSEDOCKTHRESHOLD : i32 = 126;
pub const SPI_SETMOUSEDOCKTHRESHOLD : i32 = 127;
pub const SPI_GETPENDOCKTHRESHOLD : i32 = 128;
pub const SPI_SETPENDOCKTHRESHOLD : i32 = 129;
pub const SPI_GETWINARRANGING : i32 = 130;
pub const SPI_SETWINARRANGING : i32 = 131;
pub const SPI_GETMOUSEDRAGOUTTHRESHOLD : i32 = 132;
pub const SPI_SETMOUSEDRAGOUTTHRESHOLD : i32 = 133;
pub const SPI_GETPENDRAGOUTTHRESHOLD : i32 = 134;
pub const SPI_SETPENDRAGOUTTHRESHOLD : i32 = 135;
pub const SPI_GETMOUSESIDEMOVETHRESHOLD : i32 = 136;
pub const SPI_SETMOUSESIDEMOVETHRESHOLD : i32 = 137;
pub const SPI_GETPENSIDEMOVETHRESHOLD : i32 = 138;
pub const SPI_SETPENSIDEMOVETHRESHOLD : i32 = 139;
pub const SPI_GETDRAGFROMMAXIMIZE : i32 = 140;
pub const SPI_SETDRAGFROMMAXIMIZE : i32 = 141;
pub const SPI_GETSNAPSIZING : i32 = 142;
pub const SPI_SETSNAPSIZING : i32 = 143;
pub const SPI_GETDOCKMOVING : i32 = 144;
pub const SPI_SETDOCKMOVING : i32 = 145;
pub const MAX_TOUCH_PREDICTION_FILTER_TAPS : i32 = 3;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_LATENCY : i32 = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_SAMPLETIME : i32 = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_USE_HW_TIMESTAMP : i32 = 1;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_DELTA : f32 = 1.0e-03;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MIN : f32 = 9.0e-01;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MAX : f32 = 9.99e-01;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_LEARNING_RATE : f32 = 1.0e-03;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_EXPO_SMOOTH_ALPHA : f32 = 9.9e-01;
pub const SPI_GETTOUCHPREDICTIONPARAMETERS : i32 = 156;
pub const SPI_SETTOUCHPREDICTIONPARAMETERS : i32 = 157;
pub const MAX_LOGICALDPIOVERRIDE : i32 = 2;
pub const MIN_LOGICALDPIOVERRIDE : i32 = -2;
pub const SPI_GETLOGICALDPIOVERRIDE : i32 = 158;
pub const SPI_SETLOGICALDPIOVERRIDE : i32 = 159;
pub const SPI_GETMENURECT : i32 = 162;
pub const SPI_SETMENURECT : i32 = 163;
pub const SPI_GETACTIVEWINDOWTRACKING : i32 = 4096;
pub const SPI_SETACTIVEWINDOWTRACKING : i32 = 4097;
pub const SPI_GETMENUANIMATION : i32 = 4098;
pub const SPI_SETMENUANIMATION : i32 = 4099;
pub const SPI_GETCOMBOBOXANIMATION : i32 = 4100;
pub const SPI_SETCOMBOBOXANIMATION : i32 = 4101;
pub const SPI_GETLISTBOXSMOOTHSCROLLING : i32 = 4102;
pub const SPI_SETLISTBOXSMOOTHSCROLLING : i32 = 4103;
pub const SPI_GETGRADIENTCAPTIONS : i32 = 4104;
pub const SPI_SETGRADIENTCAPTIONS : i32 = 4105;
pub const SPI_GETKEYBOARDCUES : i32 = 4106;
pub const SPI_SETKEYBOARDCUES : i32 = 4107;
pub const SPI_GETMENUUNDERLINES : i32 = 4106;
pub const SPI_SETMENUUNDERLINES : i32 = 4107;
pub const SPI_GETACTIVEWNDTRKZORDER : i32 = 4108;
pub const SPI_SETACTIVEWNDTRKZORDER : i32 = 4109;
pub const SPI_GETHOTTRACKING : i32 = 4110;
pub const SPI_SETHOTTRACKING : i32 = 4111;
pub const SPI_GETMENUFADE : i32 = 4114;
pub const SPI_SETMENUFADE : i32 = 4115;
pub const SPI_GETSELECTIONFADE : i32 = 4116;
pub const SPI_SETSELECTIONFADE : i32 = 4117;
pub const SPI_GETTOOLTIPANIMATION : i32 = 4118;
pub const SPI_SETTOOLTIPANIMATION : i32 = 4119;
pub const SPI_GETTOOLTIPFADE : i32 = 4120;
pub const SPI_SETTOOLTIPFADE : i32 = 4121;
pub const SPI_GETCURSORSHADOW : i32 = 4122;
pub const SPI_SETCURSORSHADOW : i32 = 4123;
pub const SPI_GETMOUSESONAR : i32 = 4124;
pub const SPI_SETMOUSESONAR : i32 = 4125;
pub const SPI_GETMOUSECLICKLOCK : i32 = 4126;
pub const SPI_SETMOUSECLICKLOCK : i32 = 4127;
pub const SPI_GETMOUSEVANISH : i32 = 4128;
pub const SPI_SETMOUSEVANISH : i32 = 4129;
pub const SPI_GETFLATMENU : i32 = 4130;
pub const SPI_SETFLATMENU : i32 = 4131;
pub const SPI_GETDROPSHADOW : i32 = 4132;
pub const SPI_SETDROPSHADOW : i32 = 4133;
pub const SPI_GETBLOCKSENDINPUTRESETS : i32 = 4134;
pub const SPI_SETBLOCKSENDINPUTRESETS : i32 = 4135;
pub const SPI_GETUIEFFECTS : i32 = 4158;
pub const SPI_SETUIEFFECTS : i32 = 4159;
pub const SPI_GETDISABLEOVERLAPPEDCONTENT : i32 = 4160;
pub const SPI_SETDISABLEOVERLAPPEDCONTENT : i32 = 4161;
pub const SPI_GETCLIENTAREAANIMATION : i32 = 4162;
pub const SPI_SETCLIENTAREAANIMATION : i32 = 4163;
pub const SPI_GETCLEARTYPE : i32 = 4168;
pub const SPI_SETCLEARTYPE : i32 = 4169;
pub const SPI_GETSPEECHRECOGNITION : i32 = 4170;
pub const SPI_SETSPEECHRECOGNITION : i32 = 4171;
pub const SPI_GETCARETBROWSING : i32 = 4172;
pub const SPI_SETCARETBROWSING : i32 = 4173;
pub const SPI_GETTHREADLOCALINPUTSETTINGS : i32 = 4174;
pub const SPI_SETTHREADLOCALINPUTSETTINGS : i32 = 4175;
pub const SPI_GETSYSTEMLANGUAGEBAR : i32 = 4176;
pub const SPI_SETSYSTEMLANGUAGEBAR : i32 = 4177;
pub const SPI_GETFOREGROUNDLOCKTIMEOUT : i32 = 8192;
pub const SPI_SETFOREGROUNDLOCKTIMEOUT : i32 = 8193;
pub const SPI_GETACTIVEWNDTRKTIMEOUT : i32 = 8194;
pub const SPI_SETACTIVEWNDTRKTIMEOUT : i32 = 8195;
pub const SPI_GETFOREGROUNDFLASHCOUNT : i32 = 8196;
pub const SPI_SETFOREGROUNDFLASHCOUNT : i32 = 8197;
pub const SPI_GETCARETWIDTH : i32 = 8198;
pub const SPI_SETCARETWIDTH : i32 = 8199;
pub const SPI_GETMOUSECLICKLOCKTIME : i32 = 8200;
pub const SPI_SETMOUSECLICKLOCKTIME : i32 = 8201;
pub const SPI_GETFONTSMOOTHINGTYPE : i32 = 8202;
pub const SPI_SETFONTSMOOTHINGTYPE : i32 = 8203;
pub const FE_FONTSMOOTHINGSTANDARD : i32 = 1;
pub const FE_FONTSMOOTHINGCLEARTYPE : i32 = 2;
pub const SPI_GETFONTSMOOTHINGCONTRAST : i32 = 8204;
pub const SPI_SETFONTSMOOTHINGCONTRAST : i32 = 8205;
pub const SPI_GETFOCUSBORDERWIDTH : i32 = 8206;
pub const SPI_SETFOCUSBORDERWIDTH : i32 = 8207;
pub const SPI_GETFOCUSBORDERHEIGHT : i32 = 8208;
pub const SPI_SETFOCUSBORDERHEIGHT : i32 = 8209;
pub const SPI_GETFONTSMOOTHINGORIENTATION : i32 = 8210;
pub const SPI_SETFONTSMOOTHINGORIENTATION : i32 = 8211;
pub const FE_FONTSMOOTHINGORIENTATIONBGR : i32 = 0;
pub const FE_FONTSMOOTHINGORIENTATIONRGB : i32 = 1;
pub const SPI_GETMINIMUMHITRADIUS : i32 = 8212;
pub const SPI_SETMINIMUMHITRADIUS : i32 = 8213;
pub const SPI_GETMESSAGEDURATION : i32 = 8214;
pub const SPI_SETMESSAGEDURATION : i32 = 8215;
pub const SPI_GETCONTACTVISUALIZATION : i32 = 8216;
pub const SPI_SETCONTACTVISUALIZATION : i32 = 8217;
pub const CONTACTVISUALIZATION_OFF : i32 = 0;
pub const CONTACTVISUALIZATION_ON : i32 = 1;
pub const CONTACTVISUALIZATION_PRESENTATIONMODE : i32 = 2;
pub const SPI_GETGESTUREVISUALIZATION : i32 = 8218;
pub const SPI_SETGESTUREVISUALIZATION : i32 = 8219;
pub const GESTUREVISUALIZATION_OFF : i32 = 0;
pub const GESTUREVISUALIZATION_ON : i32 = 31;
pub const GESTUREVISUALIZATION_TAP : i32 = 1;
pub const GESTUREVISUALIZATION_DOUBLETAP : i32 = 2;
pub const GESTUREVISUALIZATION_PRESSANDTAP : i32 = 4;
pub const GESTUREVISUALIZATION_PRESSANDHOLD : i32 = 8;
pub const GESTUREVISUALIZATION_RIGHTTAP : i32 = 16;
pub const SPI_GETMOUSEWHEELROUTING : i32 = 8220;
pub const SPI_SETMOUSEWHEELROUTING : i32 = 8221;
pub const MOUSEWHEEL_ROUTING_FOCUS : i32 = 0;
pub const MOUSEWHEEL_ROUTING_HYBRID : i32 = 1;
pub const MOUSEWHEEL_ROUTING_MOUSE_POS : i32 = 2;
pub const SPI_GETPENVISUALIZATION : i32 = 8222;
pub const SPI_SETPENVISUALIZATION : i32 = 8223;
pub const PENVISUALIZATION_ON : i32 = 35;
pub const PENVISUALIZATION_OFF : i32 = 0;
pub const PENVISUALIZATION_TAP : i32 = 1;
pub const PENVISUALIZATION_DOUBLETAP : i32 = 2;
pub const PENVISUALIZATION_CURSOR : i32 = 32;
pub const SPI_GETPENARBITRATIONTYPE : i32 = 8224;
pub const SPI_SETPENARBITRATIONTYPE : i32 = 8225;
pub const PENARBITRATIONTYPE_NONE : i32 = 0;
pub const PENARBITRATIONTYPE_WIN8 : i32 = 1;
pub const PENARBITRATIONTYPE_FIS : i32 = 2;
pub const PENARBITRATIONTYPE_SPT : i32 = 3;
pub const PENARBITRATIONTYPE_MAX : i32 = 4;
pub const SPI_GETCARETTIMEOUT : i32 = 8226;
pub const SPI_SETCARETTIMEOUT : i32 = 8227;
pub const SPI_GETHANDEDNESS : i32 = 8228;
pub const SPI_SETHANDEDNESS : i32 = 8229;
pub const SPIF_UPDATEINIFILE : i32 = 1;
pub const SPIF_SENDWININICHANGE : i32 = 2;
pub const SPIF_SENDCHANGE : i32 = 2;
pub const METRICS_USEDEFAULT : i32 = -1;
pub const ARW_BOTTOMLEFT : i32 = 0;
pub const ARW_BOTTOMRIGHT : i32 = 1;
pub const ARW_TOPLEFT : i32 = 2;
pub const ARW_TOPRIGHT : i32 = 3;
pub const ARW_STARTMASK : i32 = 3;
pub const ARW_STARTRIGHT : i32 = 1;
pub const ARW_STARTTOP : i32 = 2;
pub const ARW_LEFT : i32 = 0;
pub const ARW_RIGHT : i32 = 0;
pub const ARW_UP : i32 = 4;
pub const ARW_DOWN : i32 = 4;
pub const ARW_HIDE : i32 = 8;
pub const SERKF_SERIALKEYSON : i32 = 1;
pub const SERKF_AVAILABLE : i32 = 2;
pub const SERKF_INDICATOR : i32 = 4;
pub const HCF_HIGHCONTRASTON : i32 = 1;
pub const HCF_AVAILABLE : i32 = 2;
pub const HCF_HOTKEYACTIVE : i32 = 4;
pub const HCF_CONFIRMHOTKEY : i32 = 8;
pub const HCF_HOTKEYSOUND : i32 = 16;
pub const HCF_INDICATOR : i32 = 32;
pub const HCF_HOTKEYAVAILABLE : i32 = 64;
pub const HCF_LOGONDESKTOP : i32 = 256;
pub const HCF_DEFAULTDESKTOP : i32 = 512;
pub const HCF_OPTION_NOTHEMECHANGE : i32 = 4096;
pub const CDS_UPDATEREGISTRY : i32 = 1;
pub const CDS_TEST : i32 = 2;
pub const CDS_FULLSCREEN : i32 = 4;
pub const CDS_GLOBAL : i32 = 8;
pub const CDS_SET_PRIMARY : i32 = 16;
pub const CDS_VIDEOPARAMETERS : i32 = 32;
pub const CDS_ENABLE_UNSAFE_MODES : i32 = 256;
pub const CDS_DISABLE_UNSAFE_MODES : i32 = 512;
pub const CDS_RESET : i32 = 1073741824;
pub const CDS_RESET_EX : i32 = 536870912;
pub const CDS_NORESET : i32 = 268435456;
pub const DISP_CHANGE_SUCCESSFUL : i32 = 0;
pub const DISP_CHANGE_RESTART : i32 = 1;
pub const DISP_CHANGE_FAILED : i32 = -1;
pub const DISP_CHANGE_BADMODE : i32 = -2;
pub const DISP_CHANGE_NOTUPDATED : i32 = -3;
pub const DISP_CHANGE_BADFLAGS : i32 = -4;
pub const DISP_CHANGE_BADPARAM : i32 = -5;
pub const DISP_CHANGE_BADDUALVIEW : i32 = -6;
pub const ENUM_CURRENT_SETTINGS : u32 = 4294967295;
pub const ENUM_REGISTRY_SETTINGS : u32 = 4294967294;
pub const EDS_RAWMODE : i32 = 2;
pub const EDS_ROTATEDMODE : i32 = 4;
pub const EDD_GET_DEVICE_INTERFACE_NAME : i32 = 1;
pub const FKF_FILTERKEYSON : i32 = 1;
pub const FKF_AVAILABLE : i32 = 2;
pub const FKF_HOTKEYACTIVE : i32 = 4;
pub const FKF_CONFIRMHOTKEY : i32 = 8;
pub const FKF_HOTKEYSOUND : i32 = 16;
pub const FKF_INDICATOR : i32 = 32;
pub const FKF_CLICKON : i32 = 64;
pub const SKF_STICKYKEYSON : u32 = 1;
pub const SKF_AVAILABLE : u32 = 2;
pub const SKF_HOTKEYACTIVE : u32 = 4;
pub const SKF_CONFIRMHOTKEY : u32 = 8;
pub const SKF_HOTKEYSOUND : u32 = 16;
pub const SKF_INDICATOR : u32 = 32;
pub const SKF_AUDIBLEFEEDBACK : u32 = 64;
pub const SKF_TRISTATE : u32 = 128;
pub const SKF_TWOKEYSOFF : u32 = 256;
pub const SKF_LALTLATCHED : u32 = 268435456;
pub const SKF_LCTLLATCHED : u32 = 67108864;
pub const SKF_LSHIFTLATCHED : u32 = 16777216;
pub const SKF_RALTLATCHED : u32 = 536870912;
pub const SKF_RCTLLATCHED : u32 = 134217728;
pub const SKF_RSHIFTLATCHED : u32 = 33554432;
pub const SKF_LWINLATCHED : u32 = 1073741824;
pub const SKF_RWINLATCHED : u32 = 2147483648;
pub const SKF_LALTLOCKED : u32 = 1048576;
pub const SKF_LCTLLOCKED : u32 = 262144;
pub const SKF_LSHIFTLOCKED : u32 = 65536;
pub const SKF_RALTLOCKED : u32 = 2097152;
pub const SKF_RCTLLOCKED : u32 = 524288;
pub const SKF_RSHIFTLOCKED : u32 = 131072;
pub const SKF_LWINLOCKED : u32 = 4194304;
pub const SKF_RWINLOCKED : u32 = 8388608;
pub const MKF_MOUSEKEYSON : u32 = 1;
pub const MKF_AVAILABLE : u32 = 2;
pub const MKF_HOTKEYACTIVE : u32 = 4;
pub const MKF_CONFIRMHOTKEY : u32 = 8;
pub const MKF_HOTKEYSOUND : u32 = 16;
pub const MKF_INDICATOR : u32 = 32;
pub const MKF_MODIFIERS : u32 = 64;
pub const MKF_REPLACENUMBERS : u32 = 128;
pub const MKF_LEFTBUTTONSEL : u32 = 268435456;
pub const MKF_RIGHTBUTTONSEL : u32 = 536870912;
pub const MKF_LEFTBUTTONDOWN : u32 = 16777216;
pub const MKF_RIGHTBUTTONDOWN : u32 = 33554432;
pub const MKF_MOUSEMODE : u32 = 2147483648;
pub const ATF_TIMEOUTON : i32 = 1;
pub const ATF_ONOFFFEEDBACK : i32 = 2;
pub const SSGF_NONE : i32 = 0;
pub const SSGF_DISPLAY : i32 = 3;
pub const SSTF_NONE : i32 = 0;
pub const SSTF_CHARS : i32 = 1;
pub const SSTF_BORDER : i32 = 2;
pub const SSTF_DISPLAY : i32 = 3;
pub const SSWF_NONE : i32 = 0;
pub const SSWF_TITLE : i32 = 1;
pub const SSWF_WINDOW : i32 = 2;
pub const SSWF_DISPLAY : i32 = 3;
pub const SSWF_CUSTOM : i32 = 4;
pub const SSF_SOUNDSENTRYON : i32 = 1;
pub const SSF_AVAILABLE : i32 = 2;
pub const SSF_INDICATOR : i32 = 4;
pub const TKF_TOGGLEKEYSON : i32 = 1;
pub const TKF_AVAILABLE : i32 = 2;
pub const TKF_HOTKEYACTIVE : i32 = 4;
pub const TKF_CONFIRMHOTKEY : i32 = 8;
pub const TKF_HOTKEYSOUND : i32 = 16;
pub const TKF_INDICATOR : i32 = 32;
pub const SLE_ERROR : i32 = 1;
pub const SLE_MINORERROR : i32 = 2;
pub const SLE_WARNING : i32 = 3;
pub const MONITOR_DEFAULTTONULL : i32 = 0;
pub const MONITOR_DEFAULTTOPRIMARY : i32 = 1;
pub const MONITOR_DEFAULTTONEAREST : i32 = 2;
pub const MONITORINFOF_PRIMARY : i32 = 1;
pub const CCHDEVICENAME : i32 = 32;
pub const WINEVENT_OUTOFCONTEXT : i32 = 0;
pub const WINEVENT_SKIPOWNTHREAD : i32 = 1;
pub const WINEVENT_SKIPOWNPROCESS : i32 = 2;
pub const WINEVENT_INCONTEXT : i32 = 4;
pub const CHILDID_SELF : i32 = 0;
pub const INDEXID_OBJECT : i32 = 0;
pub const INDEXID_CONTAINER : i32 = 0;
pub const OBJID_WINDOW : i32 = 0;
pub const OBJID_SYSMENU : i32 = -1;
pub const OBJID_TITLEBAR : i32 = -2;
pub const OBJID_MENU : i32 = -3;
pub const OBJID_CLIENT : i32 = -4;
pub const OBJID_VSCROLL : i32 = -5;
pub const OBJID_HSCROLL : i32 = -6;
pub const OBJID_SIZEGRIP : i32 = -7;
pub const OBJID_CARET : i32 = -8;
pub const OBJID_CURSOR : i32 = -9;
pub const OBJID_ALERT : i32 = -10;
pub const OBJID_SOUND : i32 = -11;
pub const OBJID_QUERYCLASSNAMEIDX : i32 = -12;
pub const OBJID_NATIVEOM : i32 = -16;
pub const EVENT_MIN : i32 = 1;
pub const EVENT_MAX : i32 = 2147483647;
pub const EVENT_SYSTEM_SOUND : i32 = 1;
pub const EVENT_SYSTEM_ALERT : i32 = 2;
pub const EVENT_SYSTEM_FOREGROUND : i32 = 3;
pub const EVENT_SYSTEM_MENUSTART : i32 = 4;
pub const EVENT_SYSTEM_MENUEND : i32 = 5;
pub const EVENT_SYSTEM_MENUPOPUPSTART : i32 = 6;
pub const EVENT_SYSTEM_MENUPOPUPEND : i32 = 7;
pub const EVENT_SYSTEM_CAPTURESTART : i32 = 8;
pub const EVENT_SYSTEM_CAPTUREEND : i32 = 9;
pub const EVENT_SYSTEM_MOVESIZESTART : i32 = 10;
pub const EVENT_SYSTEM_MOVESIZEEND : i32 = 11;
pub const EVENT_SYSTEM_CONTEXTHELPSTART : i32 = 12;
pub const EVENT_SYSTEM_CONTEXTHELPEND : i32 = 13;
pub const EVENT_SYSTEM_DRAGDROPSTART : i32 = 14;
pub const EVENT_SYSTEM_DRAGDROPEND : i32 = 15;
pub const EVENT_SYSTEM_DIALOGSTART : i32 = 16;
pub const EVENT_SYSTEM_DIALOGEND : i32 = 17;
pub const EVENT_SYSTEM_SCROLLINGSTART : i32 = 18;
pub const EVENT_SYSTEM_SCROLLINGEND : i32 = 19;
pub const EVENT_SYSTEM_SWITCHSTART : i32 = 20;
pub const EVENT_SYSTEM_SWITCHEND : i32 = 21;
pub const EVENT_SYSTEM_MINIMIZESTART : i32 = 22;
pub const EVENT_SYSTEM_MINIMIZEEND : i32 = 23;
pub const EVENT_SYSTEM_DESKTOPSWITCH : i32 = 32;
pub const EVENT_SYSTEM_SWITCHER_APPGRABBED : i32 = 36;
pub const EVENT_SYSTEM_SWITCHER_APPOVERTARGET : i32 = 37;
pub const EVENT_SYSTEM_SWITCHER_APPDROPPED : i32 = 38;
pub const EVENT_SYSTEM_SWITCHER_CANCELLED : i32 = 39;
pub const EVENT_SYSTEM_IME_KEY_NOTIFICATION : i32 = 41;
pub const EVENT_SYSTEM_END : i32 = 255;
pub const EVENT_OEM_DEFINED_START : i32 = 257;
pub const EVENT_OEM_DEFINED_END : i32 = 511;
pub const EVENT_UIA_EVENTID_START : i32 = 19968;
pub const EVENT_UIA_EVENTID_END : i32 = 20223;
pub const EVENT_UIA_PROPID_START : i32 = 29952;
pub const EVENT_UIA_PROPID_END : i32 = 30207;
pub const EVENT_CONSOLE_CARET : i32 = 16385;
pub const EVENT_CONSOLE_UPDATE_REGION : i32 = 16386;
pub const EVENT_CONSOLE_UPDATE_SIMPLE : i32 = 16387;
pub const EVENT_CONSOLE_UPDATE_SCROLL : i32 = 16388;
pub const EVENT_CONSOLE_LAYOUT : i32 = 16389;
pub const EVENT_CONSOLE_START_APPLICATION : i32 = 16390;
pub const EVENT_CONSOLE_END_APPLICATION : i32 = 16391;
pub const CONSOLE_APPLICATION_16BIT : i32 = 1;
pub const CONSOLE_CARET_SELECTION : i32 = 1;
pub const CONSOLE_CARET_VISIBLE : i32 = 2;
pub const EVENT_CONSOLE_END : i32 = 16639;
pub const EVENT_OBJECT_CREATE : i32 = 32768;
pub const EVENT_OBJECT_DESTROY : i32 = 32769;
pub const EVENT_OBJECT_SHOW : i32 = 32770;
pub const EVENT_OBJECT_HIDE : i32 = 32771;
pub const EVENT_OBJECT_REORDER : i32 = 32772;
pub const EVENT_OBJECT_FOCUS : i32 = 32773;
pub const EVENT_OBJECT_SELECTION : i32 = 32774;
pub const EVENT_OBJECT_SELECTIONADD : i32 = 32775;
pub const EVENT_OBJECT_SELECTIONREMOVE : i32 = 32776;
pub const EVENT_OBJECT_SELECTIONWITHIN : i32 = 32777;
pub const EVENT_OBJECT_STATECHANGE : i32 = 32778;
pub const EVENT_OBJECT_LOCATIONCHANGE : i32 = 32779;
pub const EVENT_OBJECT_NAMECHANGE : i32 = 32780;
pub const EVENT_OBJECT_DESCRIPTIONCHANGE : i32 = 32781;
pub const EVENT_OBJECT_VALUECHANGE : i32 = 32782;
pub const EVENT_OBJECT_PARENTCHANGE : i32 = 32783;
pub const EVENT_OBJECT_HELPCHANGE : i32 = 32784;
pub const EVENT_OBJECT_DEFACTIONCHANGE : i32 = 32785;
pub const EVENT_OBJECT_ACCELERATORCHANGE : i32 = 32786;
pub const EVENT_OBJECT_INVOKED : i32 = 32787;
pub const EVENT_OBJECT_TEXTSELECTIONCHANGED : i32 = 32788;
pub const EVENT_OBJECT_CONTENTSCROLLED : i32 = 32789;
pub const EVENT_SYSTEM_ARRANGMENTPREVIEW : i32 = 32790;
pub const EVENT_OBJECT_CLOAKED : i32 = 32791;
pub const EVENT_OBJECT_UNCLOAKED : i32 = 32792;
pub const EVENT_OBJECT_LIVEREGIONCHANGED : i32 = 32793;
pub const EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED : i32 = 32800;
pub const EVENT_OBJECT_DRAGSTART : i32 = 32801;
pub const EVENT_OBJECT_DRAGCANCEL : i32 = 32802;
pub const EVENT_OBJECT_DRAGCOMPLETE : i32 = 32803;
pub const EVENT_OBJECT_DRAGENTER : i32 = 32804;
pub const EVENT_OBJECT_DRAGLEAVE : i32 = 32805;
pub const EVENT_OBJECT_DRAGDROPPED : i32 = 32806;
pub const EVENT_OBJECT_IME_SHOW : i32 = 32807;
pub const EVENT_OBJECT_IME_HIDE : i32 = 32808;
pub const EVENT_OBJECT_IME_CHANGE : i32 = 32809;
pub const EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED : i32 = 32816;
pub const EVENT_OBJECT_END : i32 = 33023;
pub const EVENT_AIA_START : i32 = 40960;
pub const EVENT_AIA_END : i32 = 45055;
pub const SOUND_SYSTEM_STARTUP : i32 = 1;
pub const SOUND_SYSTEM_SHUTDOWN : i32 = 2;
pub const SOUND_SYSTEM_BEEP : i32 = 3;
pub const SOUND_SYSTEM_ERROR : i32 = 4;
pub const SOUND_SYSTEM_QUESTION : i32 = 5;
pub const SOUND_SYSTEM_WARNING : i32 = 6;
pub const SOUND_SYSTEM_INFORMATION : i32 = 7;
pub const SOUND_SYSTEM_MAXIMIZE : i32 = 8;
pub const SOUND_SYSTEM_MINIMIZE : i32 = 9;
pub const SOUND_SYSTEM_RESTOREUP : i32 = 10;
pub const SOUND_SYSTEM_RESTOREDOWN : i32 = 11;
pub const SOUND_SYSTEM_APPSTART : i32 = 12;
pub const SOUND_SYSTEM_FAULT : i32 = 13;
pub const SOUND_SYSTEM_APPEND : i32 = 14;
pub const SOUND_SYSTEM_MENUCOMMAND : i32 = 15;
pub const SOUND_SYSTEM_MENUPOPUP : i32 = 16;
pub const CSOUND_SYSTEM : i32 = 16;
pub const ALERT_SYSTEM_INFORMATIONAL : i32 = 1;
pub const ALERT_SYSTEM_WARNING : i32 = 2;
pub const ALERT_SYSTEM_ERROR : i32 = 3;
pub const ALERT_SYSTEM_QUERY : i32 = 4;
pub const ALERT_SYSTEM_CRITICAL : i32 = 5;
pub const CALERT_SYSTEM : i32 = 6;
pub const GUI_CARETBLINKING : i32 = 1;
pub const GUI_INMOVESIZE : i32 = 2;
pub const GUI_INMENUMODE : i32 = 4;
pub const GUI_SYSTEMMENUMODE : i32 = 8;
pub const GUI_POPUPMENUMODE : i32 = 16;
pub const GUI_16BITTASK : i32 = 32;
pub const USER_DEFAULT_SCREEN_DPI : i32 = 96;
pub const STATE_SYSTEM_UNAVAILABLE : i32 = 1;
pub const STATE_SYSTEM_SELECTED : i32 = 2;
pub const STATE_SYSTEM_FOCUSED : i32 = 4;
pub const STATE_SYSTEM_PRESSED : i32 = 8;
pub const STATE_SYSTEM_CHECKED : i32 = 16;
pub const STATE_SYSTEM_MIXED : i32 = 32;
pub const STATE_SYSTEM_INDETERMINATE : i32 = 32;
pub const STATE_SYSTEM_READONLY : i32 = 64;
pub const STATE_SYSTEM_HOTTRACKED : i32 = 128;
pub const STATE_SYSTEM_DEFAULT : i32 = 256;
pub const STATE_SYSTEM_EXPANDED : i32 = 512;
pub const STATE_SYSTEM_COLLAPSED : i32 = 1024;
pub const STATE_SYSTEM_BUSY : i32 = 2048;
pub const STATE_SYSTEM_FLOATING : i32 = 4096;
pub const STATE_SYSTEM_MARQUEED : i32 = 8192;
pub const STATE_SYSTEM_ANIMATED : i32 = 16384;
pub const STATE_SYSTEM_INVISIBLE : i32 = 32768;
pub const STATE_SYSTEM_OFFSCREEN : i32 = 65536;
pub const STATE_SYSTEM_SIZEABLE : i32 = 131072;
pub const STATE_SYSTEM_MOVEABLE : i32 = 262144;
pub const STATE_SYSTEM_SELFVOICING : i32 = 524288;
pub const STATE_SYSTEM_FOCUSABLE : i32 = 1048576;
pub const STATE_SYSTEM_SELECTABLE : i32 = 2097152;
pub const STATE_SYSTEM_LINKED : i32 = 4194304;
pub const STATE_SYSTEM_TRAVERSED : i32 = 8388608;
pub const STATE_SYSTEM_MULTISELECTABLE : i32 = 16777216;
pub const STATE_SYSTEM_EXTSELECTABLE : i32 = 33554432;
pub const STATE_SYSTEM_ALERT_LOW : i32 = 67108864;
pub const STATE_SYSTEM_ALERT_MEDIUM : i32 = 134217728;
pub const STATE_SYSTEM_ALERT_HIGH : i32 = 268435456;
pub const STATE_SYSTEM_PROTECTED : i32 = 536870912;
pub const STATE_SYSTEM_VALID : i32 = 1073741823;
pub const CCHILDREN_TITLEBAR : i32 = 5;
pub const CCHILDREN_SCROLLBAR : i32 = 5;
pub const CURSOR_SHOWING : i32 = 1;
pub const CURSOR_SUPPRESSED : i32 = 2;
pub const WS_ACTIVECAPTION : i32 = 1;
pub const GA_PARENT : i32 = 1;
pub const GA_ROOT : i32 = 2;
pub const GA_ROOTOWNER : i32 = 3;
pub const RIM_INPUT : i32 = 0;
pub const RIM_INPUTSINK : i32 = 1;
pub const RIM_TYPEMOUSE : i32 = 0;
pub const RIM_TYPEKEYBOARD : i32 = 1;
pub const RIM_TYPEHID : i32 = 2;
pub const RIM_TYPEMAX : i32 = 2;
pub const RI_MOUSE_LEFT_BUTTON_DOWN : i32 = 1;
pub const RI_MOUSE_LEFT_BUTTON_UP : i32 = 2;
pub const RI_MOUSE_RIGHT_BUTTON_DOWN : i32 = 4;
pub const RI_MOUSE_RIGHT_BUTTON_UP : i32 = 8;
pub const RI_MOUSE_MIDDLE_BUTTON_DOWN : i32 = 16;
pub const RI_MOUSE_MIDDLE_BUTTON_UP : i32 = 32;
pub const RI_MOUSE_BUTTON_1_DOWN : i32 = 1;
pub const RI_MOUSE_BUTTON_1_UP : i32 = 2;
pub const RI_MOUSE_BUTTON_2_DOWN : i32 = 4;
pub const RI_MOUSE_BUTTON_2_UP : i32 = 8;
pub const RI_MOUSE_BUTTON_3_DOWN : i32 = 16;
pub const RI_MOUSE_BUTTON_3_UP : i32 = 32;
pub const RI_MOUSE_BUTTON_4_DOWN : i32 = 64;
pub const RI_MOUSE_BUTTON_4_UP : i32 = 128;
pub const RI_MOUSE_BUTTON_5_DOWN : i32 = 256;
pub const RI_MOUSE_BUTTON_5_UP : i32 = 512;
pub const RI_MOUSE_WHEEL : i32 = 1024;
pub const RI_MOUSE_HWHEEL : i32 = 2048;
pub const MOUSE_MOVE_RELATIVE : i32 = 0;
pub const MOUSE_MOVE_ABSOLUTE : i32 = 1;
pub const MOUSE_VIRTUAL_DESKTOP : i32 = 2;
pub const MOUSE_ATTRIBUTES_CHANGED : i32 = 4;
pub const MOUSE_MOVE_NOCOALESCE : i32 = 8;
pub const KEYBOARD_OVERRUN_MAKE_CODE : i32 = 255;
pub const RI_KEY_MAKE : i32 = 0;
pub const RI_KEY_BREAK : i32 = 1;
pub const RI_KEY_E0 : i32 = 2;
pub const RI_KEY_E1 : i32 = 4;
pub const RI_KEY_TERMSRV_SET_LED : i32 = 8;
pub const RI_KEY_TERMSRV_SHADOW : i32 = 16;
pub const RID_INPUT : i32 = 268435459;
pub const RID_HEADER : i32 = 268435461;
pub const RIDI_PREPARSEDDATA : i32 = 536870917;
pub const RIDI_DEVICENAME : i32 = 536870919;
pub const RIDI_DEVICEINFO : i32 = 536870923;
pub const RIDEV_REMOVE : i32 = 1;
pub const RIDEV_EXCLUDE : i32 = 16;
pub const RIDEV_PAGEONLY : i32 = 32;
pub const RIDEV_NOLEGACY : i32 = 48;
pub const RIDEV_INPUTSINK : i32 = 256;
pub const RIDEV_CAPTUREMOUSE : i32 = 512;
pub const RIDEV_NOHOTKEYS : i32 = 512;
pub const RIDEV_APPKEYS : i32 = 1024;
pub const RIDEV_EXINPUTSINK : i32 = 4096;
pub const RIDEV_DEVNOTIFY : i32 = 8192;
pub const RIDEV_EXMODEMASK : i32 = 240;
pub const GIDC_ARRIVAL : i32 = 1;
pub const GIDC_REMOVAL : i32 = 2;
pub const POINTER_DEVICE_PRODUCT_STRING_MAX : i32 = 520;
pub const PDC_ARRIVAL : i32 = 1;
pub const PDC_REMOVAL : i32 = 2;
pub const PDC_ORIENTATION_0 : i32 = 4;
pub const PDC_ORIENTATION_90 : i32 = 8;
pub const PDC_ORIENTATION_180 : i32 = 16;
pub const PDC_ORIENTATION_270 : i32 = 32;
pub const PDC_MODE_DEFAULT : i32 = 64;
pub const PDC_MODE_CENTERED : i32 = 128;
pub const PDC_MAPPING_CHANGE : i32 = 256;
pub const PDC_RESOLUTION : i32 = 512;
pub const PDC_ORIGIN : i32 = 1024;
pub const PDC_MODE_ASPECTRATIOPRESERVED : i32 = 2048;
pub const MSGFLT_ADD : i32 = 1;
pub const MSGFLT_REMOVE : i32 = 2;
pub const MSGFLTINFO_NONE : i32 = 0;
pub const MSGFLTINFO_ALREADYALLOWED_FORWND : i32 = 1;
pub const MSGFLTINFO_ALREADYDISALLOWED_FORWND : i32 = 2;
pub const MSGFLTINFO_ALLOWED_HIGHER : i32 = 3;
pub const MSGFLT_RESET : i32 = 0;
pub const MSGFLT_ALLOW : i32 = 1;
pub const MSGFLT_DISALLOW : i32 = 2;
pub const GF_BEGIN : i32 = 1;
pub const GF_INERTIA : i32 = 2;
pub const GF_END : i32 = 4;
pub const GID_BEGIN : i32 = 1;
pub const GID_END : i32 = 2;
pub const GID_ZOOM : i32 = 3;
pub const GID_PAN : i32 = 4;
pub const GID_ROTATE : i32 = 5;
pub const GID_TWOFINGERTAP : i32 = 6;
pub const GID_PRESSANDTAP : i32 = 7;
pub const GID_ROLLOVER : i32 = 7;
pub const GC_ALLGESTURES : i32 = 1;
pub const GC_ZOOM : i32 = 1;
pub const GC_PAN : i32 = 1;
pub const GC_PAN_WITH_SINGLE_FINGER_VERTICALLY : i32 = 2;
pub const GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY : i32 = 4;
pub const GC_PAN_WITH_GUTTER : i32 = 8;
pub const GC_PAN_WITH_INERTIA : i32 = 16;
pub const GC_ROTATE : i32 = 1;
pub const GC_TWOFINGERTAP : i32 = 1;
pub const GC_PRESSANDTAP : i32 = 1;
pub const GC_ROLLOVER : i32 = 1;
pub const GESTURECONFIGMAXCOUNT : i32 = 256;
pub const NID_INTEGRATED_TOUCH : i32 = 1;
pub const NID_EXTERNAL_TOUCH : i32 = 2;
pub const NID_INTEGRATED_PEN : i32 = 4;
pub const NID_EXTERNAL_PEN : i32 = 8;
pub const NID_MULTI_INPUT : i32 = 64;
pub const NID_READY : i32 = 128;
pub const MAX_STR_BLOCKREASON : i32 = 256;
pub const DXGI_CREATE_FACTORY_DEBUG : u32 = 1;
pub const INFINITE : u32 = 4294967295;
pub const FACILITY_NULL : i32 = 0;
pub const FACILITY_RPC : i32 = 1;
pub const FACILITY_DISPATCH : i32 = 2;
pub const FACILITY_STORAGE : i32 = 3;
pub const FACILITY_ITF : i32 = 4;
pub const FACILITY_WIN32 : i32 = 7;
pub const FACILITY_WINDOWS : i32 = 8;
pub const FACILITY_SSPI : i32 = 9;
pub const FACILITY_SECURITY : i32 = 9;
pub const FACILITY_CONTROL : i32 = 10;
pub const FACILITY_CERT : i32 = 11;
pub const FACILITY_INTERNET : i32 = 12;
pub const FACILITY_MEDIASERVER : i32 = 13;
pub const FACILITY_MSMQ : i32 = 14;
pub const FACILITY_SETUPAPI : i32 = 15;
pub const FACILITY_SCARD : i32 = 16;
pub const FACILITY_COMPLUS : i32 = 17;
pub const FACILITY_AAF : i32 = 18;
pub const FACILITY_URT : i32 = 19;
pub const FACILITY_ACS : i32 = 20;
pub const FACILITY_DPLAY : i32 = 21;
pub const FACILITY_UMI : i32 = 22;
pub const FACILITY_SXS : i32 = 23;
pub const FACILITY_WINDOWS_CE : i32 = 24;
pub const FACILITY_HTTP : i32 = 25;
pub const FACILITY_USERMODE_COMMONLOG : i32 = 26;
pub const FACILITY_WER : i32 = 27;
pub const FACILITY_USERMODE_FILTER_MANAGER : i32 = 31;
pub const FACILITY_BACKGROUNDCOPY : i32 = 32;
pub const FACILITY_CONFIGURATION : i32 = 33;
pub const FACILITY_WIA : i32 = 33;
pub const FACILITY_STATE_MANAGEMENT : i32 = 34;
pub const FACILITY_METADIRECTORY : i32 = 35;
pub const FACILITY_WINDOWSUPDATE : i32 = 36;
pub const FACILITY_DIRECTORYSERVICE : i32 = 37;
pub const FACILITY_GRAPHICS : i32 = 38;
pub const FACILITY_SHELL : i32 = 39;
pub const FACILITY_NAP : i32 = 39;
pub const FACILITY_TPM_SERVICES : i32 = 40;
pub const FACILITY_TPM_SOFTWARE : i32 = 41;
pub const FACILITY_UI : i32 = 42;
pub const FACILITY_XAML : i32 = 43;
pub const FACILITY_ACTION_QUEUE : i32 = 44;
pub const FACILITY_PLA : i32 = 48;
pub const FACILITY_WINDOWS_SETUP : i32 = 48;
pub const FACILITY_FVE : i32 = 49;
pub const FACILITY_FWP : i32 = 50;
pub const FACILITY_WINRM : i32 = 51;
pub const FACILITY_NDIS : i32 = 52;
pub const FACILITY_USERMODE_HYPERVISOR : i32 = 53;
pub const FACILITY_CMI : i32 = 54;
pub const FACILITY_USERMODE_VIRTUALIZATION : i32 = 55;
pub const FACILITY_USERMODE_VOLMGR : i32 = 56;
pub const FACILITY_BCD : i32 = 57;
pub const FACILITY_USERMODE_VHD : i32 = 58;
pub const FACILITY_USERMODE_HNS : i32 = 59;
pub const FACILITY_SDIAG : i32 = 60;
pub const FACILITY_WEBSERVICES : i32 = 61;
pub const FACILITY_WINPE : i32 = 61;
pub const FACILITY_WPN : i32 = 62;
pub const FACILITY_WINDOWS_STORE : i32 = 63;
pub const FACILITY_INPUT : i32 = 64;
pub const FACILITY_QUIC : i32 = 65;
pub const FACILITY_EAP : i32 = 66;
pub const FACILITY_WINDOWS_DEFENDER : i32 = 80;
pub const FACILITY_OPC : i32 = 81;
pub const FACILITY_XPS : i32 = 82;
pub const FACILITY_MBN : i32 = 84;
pub const FACILITY_POWERSHELL : i32 = 84;
pub const FACILITY_RAS : i32 = 83;
pub const FACILITY_P2P_INT : i32 = 98;
pub const FACILITY_P2P : i32 = 99;
pub const FACILITY_DAF : i32 = 100;
pub const FACILITY_BLUETOOTH_ATT : i32 = 101;
pub const FACILITY_AUDIO : i32 = 102;
pub const FACILITY_STATEREPOSITORY : i32 = 103;
pub const FACILITY_VISUALCPP : i32 = 109;
pub const FACILITY_SCRIPT : i32 = 112;
pub const FACILITY_PARSE : i32 = 113;
pub const FACILITY_BLB : i32 = 120;
pub const FACILITY_BLB_CLI : i32 = 121;
pub const FACILITY_WSBAPP : i32 = 122;
pub const FACILITY_BLBUI : i32 = 128;
pub const FACILITY_USN : i32 = 129;
pub const FACILITY_USERMODE_VOLSNAP : i32 = 130;
pub const FACILITY_TIERING : i32 = 131;
pub const FACILITY_WSB_ONLINE : i32 = 133;
pub const FACILITY_ONLINE_ID : i32 = 134;
pub const FACILITY_DEVICE_UPDATE_AGENT : i32 = 135;
pub const FACILITY_DRVSERVICING : i32 = 136;
pub const FACILITY_DLS : i32 = 153;
pub const FACILITY_DELIVERY_OPTIMIZATION : i32 = 208;
pub const FACILITY_USERMODE_SPACES : i32 = 231;
pub const FACILITY_USER_MODE_SECURITY_CORE : i32 = 232;
pub const FACILITY_USERMODE_LICENSING : i32 = 234;
pub const FACILITY_SOS : i32 = 160;
pub const FACILITY_DEBUGGERS : i32 = 176;
pub const FACILITY_SPP : i32 = 256;
pub const FACILITY_RESTORE : i32 = 256;
pub const FACILITY_DMSERVER : i32 = 256;
pub const FACILITY_DEPLOYMENT_SERVICES_SERVER : i32 = 257;
pub const FACILITY_DEPLOYMENT_SERVICES_IMAGING : i32 = 258;
pub const FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT : i32 = 259;
pub const FACILITY_DEPLOYMENT_SERVICES_UTIL : i32 = 260;
pub const FACILITY_DEPLOYMENT_SERVICES_BINLSVC : i32 = 261;
pub const FACILITY_DEPLOYMENT_SERVICES_PXE : i32 = 263;
pub const FACILITY_DEPLOYMENT_SERVICES_TFTP : i32 = 264;
pub const FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT : i32 = 272;
pub const FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING : i32 = 278;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER : i32 = 289;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT : i32 = 290;
pub const FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER : i32 = 293;
pub const FACILITY_LINGUISTIC_SERVICES : i32 = 305;
pub const FACILITY_AUDIOSTREAMING : i32 = 1094;
pub const FACILITY_TTD : i32 = 1490;
pub const FACILITY_ACCELERATOR : i32 = 1536;
pub const FACILITY_WMAAECMA : i32 = 1996;
pub const FACILITY_DIRECTMUSIC : i32 = 2168;
pub const FACILITY_DIRECT3D10 : i32 = 2169;
pub const FACILITY_DXGI : i32 = 2170;
pub const FACILITY_DXGI_DDI : i32 = 2171;
pub const FACILITY_DIRECT3D11 : i32 = 2172;
pub const FACILITY_DIRECT3D11_DEBUG : i32 = 2173;
pub const FACILITY_DIRECT3D12 : i32 = 2174;
pub const FACILITY_DIRECT3D12_DEBUG : i32 = 2175;
pub const FACILITY_DXCORE : i32 = 2176;
pub const FACILITY_LEAP : i32 = 2184;
pub const FACILITY_AUDCLNT : i32 = 2185;
pub const FACILITY_WINCODEC_DWRITE_DWM : i32 = 2200;
pub const FACILITY_WINML : i32 = 2192;
pub const FACILITY_DIRECT2D : i32 = 2201;
pub const FACILITY_DEFRAG : i32 = 2304;
pub const FACILITY_USERMODE_SDBUS : i32 = 2305;
pub const FACILITY_JSCRIPT : i32 = 2306;
pub const FACILITY_PIDGENX : i32 = 2561;
pub const FACILITY_EAS : i32 = 85;
pub const FACILITY_WEB : i32 = 885;
pub const FACILITY_WEB_SOCKET : i32 = 886;
pub const FACILITY_MOBILE : i32 = 1793;
pub const FACILITY_SQLITE : i32 = 1967;
pub const FACILITY_UTC : i32 = 1989;
pub const FACILITY_WEP : i32 = 2049;
pub const FACILITY_SYNCENGINE : i32 = 2050;
pub const FACILITY_XBOX : i32 = 2339;
pub const FACILITY_GAME : i32 = 2340;
pub const FACILITY_PIX : i32 = 2748;
pub const ERROR_SUCCESS : i32 = 0;
pub const NO_ERROR : i32 = 0;
pub const SEC_E_OK : i32 = 0;
pub const ERROR_INVALID_FUNCTION : i32 = 1;
pub const ERROR_FILE_NOT_FOUND : i32 = 2;
pub const ERROR_PATH_NOT_FOUND : i32 = 3;
pub const ERROR_TOO_MANY_OPEN_FILES : i32 = 4;
pub const ERROR_ACCESS_DENIED : i32 = 5;
pub const ERROR_INVALID_HANDLE : i32 = 6;
pub const ERROR_ARENA_TRASHED : i32 = 7;
pub const ERROR_NOT_ENOUGH_MEMORY : i32 = 8;
pub const ERROR_INVALID_BLOCK : i32 = 9;
pub const ERROR_BAD_ENVIRONMENT : i32 = 10;
pub const ERROR_BAD_FORMAT : i32 = 11;
pub const ERROR_INVALID_ACCESS : i32 = 12;
pub const ERROR_INVALID_DATA : i32 = 13;
pub const ERROR_OUTOFMEMORY : i32 = 14;
pub const ERROR_INVALID_DRIVE : i32 = 15;
pub const ERROR_CURRENT_DIRECTORY : i32 = 16;
pub const ERROR_NOT_SAME_DEVICE : i32 = 17;
pub const ERROR_NO_MORE_FILES : i32 = 18;
pub const ERROR_WRITE_PROTECT : i32 = 19;
pub const ERROR_BAD_UNIT : i32 = 20;
pub const ERROR_NOT_READY : i32 = 21;
pub const ERROR_BAD_COMMAND : i32 = 22;
pub const ERROR_CRC : i32 = 23;
pub const ERROR_BAD_LENGTH : i32 = 24;
pub const ERROR_SEEK : i32 = 25;
pub const ERROR_NOT_DOS_DISK : i32 = 26;
pub const ERROR_SECTOR_NOT_FOUND : i32 = 27;
pub const ERROR_OUT_OF_PAPER : i32 = 28;
pub const ERROR_WRITE_FAULT : i32 = 29;
pub const ERROR_READ_FAULT : i32 = 30;
pub const ERROR_GEN_FAILURE : i32 = 31;
pub const ERROR_SHARING_VIOLATION : i32 = 32;
pub const ERROR_LOCK_VIOLATION : i32 = 33;
pub const ERROR_WRONG_DISK : i32 = 34;
pub const ERROR_SHARING_BUFFER_EXCEEDED : i32 = 36;
pub const ERROR_HANDLE_EOF : i32 = 38;
pub const ERROR_HANDLE_DISK_FULL : i32 = 39;
pub const ERROR_NOT_SUPPORTED : i32 = 50;
pub const ERROR_REM_NOT_LIST : i32 = 51;
pub const ERROR_DUP_NAME : i32 = 52;
pub const ERROR_BAD_NETPATH : i32 = 53;
pub const ERROR_NETWORK_BUSY : i32 = 54;
pub const ERROR_DEV_NOT_EXIST : i32 = 55;
pub const ERROR_TOO_MANY_CMDS : i32 = 56;
pub const ERROR_ADAP_HDW_ERR : i32 = 57;
pub const ERROR_BAD_NET_RESP : i32 = 58;
pub const ERROR_UNEXP_NET_ERR : i32 = 59;
pub const ERROR_BAD_REM_ADAP : i32 = 60;
pub const ERROR_PRINTQ_FULL : i32 = 61;
pub const ERROR_NO_SPOOL_SPACE : i32 = 62;
pub const ERROR_PRINT_CANCELLED : i32 = 63;
pub const ERROR_NETNAME_DELETED : i32 = 64;
pub const ERROR_NETWORK_ACCESS_DENIED : i32 = 65;
pub const ERROR_BAD_DEV_TYPE : i32 = 66;
pub const ERROR_BAD_NET_NAME : i32 = 67;
pub const ERROR_TOO_MANY_NAMES : i32 = 68;
pub const ERROR_TOO_MANY_SESS : i32 = 69;
pub const ERROR_SHARING_PAUSED : i32 = 70;
pub const ERROR_REQ_NOT_ACCEP : i32 = 71;
pub const ERROR_REDIR_PAUSED : i32 = 72;
pub const ERROR_FILE_EXISTS : i32 = 80;
pub const ERROR_CANNOT_MAKE : i32 = 82;
pub const ERROR_FAIL_I24 : i32 = 83;
pub const ERROR_OUT_OF_STRUCTURES : i32 = 84;
pub const ERROR_ALREADY_ASSIGNED : i32 = 85;
pub const ERROR_INVALID_PASSWORD : i32 = 86;
pub const ERROR_INVALID_PARAMETER : i32 = 87;
pub const ERROR_NET_WRITE_FAULT : i32 = 88;
pub const ERROR_NO_PROC_SLOTS : i32 = 89;
pub const ERROR_TOO_MANY_SEMAPHORES : i32 = 100;
pub const ERROR_EXCL_SEM_ALREADY_OWNED : i32 = 101;
pub const ERROR_SEM_IS_SET : i32 = 102;
pub const ERROR_TOO_MANY_SEM_REQUESTS : i32 = 103;
pub const ERROR_INVALID_AT_INTERRUPT_TIME : i32 = 104;
pub const ERROR_SEM_OWNER_DIED : i32 = 105;
pub const ERROR_SEM_USER_LIMIT : i32 = 106;
pub const ERROR_DISK_CHANGE : i32 = 107;
pub const ERROR_DRIVE_LOCKED : i32 = 108;
pub const ERROR_BROKEN_PIPE : i32 = 109;
pub const ERROR_OPEN_FAILED : i32 = 110;
pub const ERROR_BUFFER_OVERFLOW : i32 = 111;
pub const ERROR_DISK_FULL : i32 = 112;
pub const ERROR_NO_MORE_SEARCH_HANDLES : i32 = 113;
pub const ERROR_INVALID_TARGET_HANDLE : i32 = 114;
pub const ERROR_INVALID_CATEGORY : i32 = 117;
pub const ERROR_INVALID_VERIFY_SWITCH : i32 = 118;
pub const ERROR_BAD_DRIVER_LEVEL : i32 = 119;
pub const ERROR_CALL_NOT_IMPLEMENTED : i32 = 120;
pub const ERROR_SEM_TIMEOUT : i32 = 121;
pub const ERROR_INSUFFICIENT_BUFFER : i32 = 122;
pub const ERROR_INVALID_NAME : i32 = 123;
pub const ERROR_INVALID_LEVEL : i32 = 124;
pub const ERROR_NO_VOLUME_LABEL : i32 = 125;
pub const ERROR_MOD_NOT_FOUND : i32 = 126;
pub const ERROR_PROC_NOT_FOUND : i32 = 127;
pub const ERROR_WAIT_NO_CHILDREN : i32 = 128;
pub const ERROR_CHILD_NOT_COMPLETE : i32 = 129;
pub const ERROR_DIRECT_ACCESS_HANDLE : i32 = 130;
pub const ERROR_NEGATIVE_SEEK : i32 = 131;
pub const ERROR_SEEK_ON_DEVICE : i32 = 132;
pub const ERROR_IS_JOIN_TARGET : i32 = 133;
pub const ERROR_IS_JOINED : i32 = 134;
pub const ERROR_IS_SUBSTED : i32 = 135;
pub const ERROR_NOT_JOINED : i32 = 136;
pub const ERROR_NOT_SUBSTED : i32 = 137;
pub const ERROR_JOIN_TO_JOIN : i32 = 138;
pub const ERROR_SUBST_TO_SUBST : i32 = 139;
pub const ERROR_JOIN_TO_SUBST : i32 = 140;
pub const ERROR_SUBST_TO_JOIN : i32 = 141;
pub const ERROR_BUSY_DRIVE : i32 = 142;
pub const ERROR_SAME_DRIVE : i32 = 143;
pub const ERROR_DIR_NOT_ROOT : i32 = 144;
pub const ERROR_DIR_NOT_EMPTY : i32 = 145;
pub const ERROR_IS_SUBST_PATH : i32 = 146;
pub const ERROR_IS_JOIN_PATH : i32 = 147;
pub const ERROR_PATH_BUSY : i32 = 148;
pub const ERROR_IS_SUBST_TARGET : i32 = 149;
pub const ERROR_SYSTEM_TRACE : i32 = 150;
pub const ERROR_INVALID_EVENT_COUNT : i32 = 151;
pub const ERROR_TOO_MANY_MUXWAITERS : i32 = 152;
pub const ERROR_INVALID_LIST_FORMAT : i32 = 153;
pub const ERROR_LABEL_TOO_LONG : i32 = 154;
pub const ERROR_TOO_MANY_TCBS : i32 = 155;
pub const ERROR_SIGNAL_REFUSED : i32 = 156;
pub const ERROR_DISCARDED : i32 = 157;
pub const ERROR_NOT_LOCKED : i32 = 158;
pub const ERROR_BAD_THREADID_ADDR : i32 = 159;
pub const ERROR_BAD_ARGUMENTS : i32 = 160;
pub const ERROR_BAD_PATHNAME : i32 = 161;
pub const ERROR_SIGNAL_PENDING : i32 = 162;
pub const ERROR_MAX_THRDS_REACHED : i32 = 164;
pub const ERROR_LOCK_FAILED : i32 = 167;
pub const ERROR_BUSY : i32 = 170;
pub const ERROR_DEVICE_SUPPORT_IN_PROGRESS : i32 = 171;
pub const ERROR_CANCEL_VIOLATION : i32 = 173;
pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED : i32 = 174;
pub const ERROR_INVALID_SEGMENT_NUMBER : i32 = 180;
pub const ERROR_INVALID_ORDINAL : i32 = 182;
pub const ERROR_ALREADY_EXISTS : i32 = 183;
pub const ERROR_INVALID_FLAG_NUMBER : i32 = 186;
pub const ERROR_SEM_NOT_FOUND : i32 = 187;
pub const ERROR_INVALID_STARTING_CODESEG : i32 = 188;
pub const ERROR_INVALID_STACKSEG : i32 = 189;
pub const ERROR_INVALID_MODULETYPE : i32 = 190;
pub const ERROR_INVALID_EXE_SIGNATURE : i32 = 191;
pub const ERROR_EXE_MARKED_INVALID : i32 = 192;
pub const ERROR_BAD_EXE_FORMAT : i32 = 193;
pub const ERROR_ITERATED_DATA_EXCEEDS_64k : i32 = 194;
pub const ERROR_INVALID_MINALLOCSIZE : i32 = 195;
pub const ERROR_DYNLINK_FROM_INVALID_RING : i32 = 196;
pub const ERROR_IOPL_NOT_ENABLED : i32 = 197;
pub const ERROR_INVALID_SEGDPL : i32 = 198;
pub const ERROR_AUTODATASEG_EXCEEDS_64k : i32 = 199;
pub const ERROR_RING2SEG_MUST_BE_MOVABLE : i32 = 200;
pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM : i32 = 201;
pub const ERROR_INFLOOP_IN_RELOC_CHAIN : i32 = 202;
pub const ERROR_ENVVAR_NOT_FOUND : i32 = 203;
pub const ERROR_NO_SIGNAL_SENT : i32 = 205;
pub const ERROR_FILENAME_EXCED_RANGE : i32 = 206;
pub const ERROR_RING2_STACK_IN_USE : i32 = 207;
pub const ERROR_META_EXPANSION_TOO_LONG : i32 = 208;
pub const ERROR_INVALID_SIGNAL_NUMBER : i32 = 209;
pub const ERROR_THREAD_1_INACTIVE : i32 = 210;
pub const ERROR_LOCKED : i32 = 212;
pub const ERROR_TOO_MANY_MODULES : i32 = 214;
pub const ERROR_NESTING_NOT_ALLOWED : i32 = 215;
pub const ERROR_EXE_MACHINE_TYPE_MISMATCH : i32 = 216;
pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY : i32 = 217;
pub const ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY : i32 = 218;
pub const ERROR_FILE_CHECKED_OUT : i32 = 220;
pub const ERROR_CHECKOUT_REQUIRED : i32 = 221;
pub const ERROR_BAD_FILE_TYPE : i32 = 222;
pub const ERROR_FILE_TOO_LARGE : i32 = 223;
pub const ERROR_FORMS_AUTH_REQUIRED : i32 = 224;
pub const ERROR_VIRUS_INFECTED : i32 = 225;
pub const ERROR_VIRUS_DELETED : i32 = 226;
pub const ERROR_PIPE_LOCAL : i32 = 229;
pub const ERROR_BAD_PIPE : i32 = 230;
pub const ERROR_PIPE_BUSY : i32 = 231;
pub const ERROR_NO_DATA : i32 = 232;
pub const ERROR_PIPE_NOT_CONNECTED : i32 = 233;
pub const ERROR_MORE_DATA : i32 = 234;
pub const ERROR_NO_WORK_DONE : i32 = 235;
pub const ERROR_VC_DISCONNECTED : i32 = 240;
pub const ERROR_INVALID_EA_NAME : i32 = 254;
pub const ERROR_EA_LIST_INCONSISTENT : i32 = 255;
pub const WAIT_TIMEOUT : i32 = 258;
pub const ERROR_NO_MORE_ITEMS : i32 = 259;
pub const ERROR_CANNOT_COPY : i32 = 266;
pub const ERROR_DIRECTORY : i32 = 267;
pub const ERROR_EAS_DIDNT_FIT : i32 = 275;
pub const ERROR_EA_FILE_CORRUPT : i32 = 276;
pub const ERROR_EA_TABLE_FULL : i32 = 277;
pub const ERROR_INVALID_EA_HANDLE : i32 = 278;
pub const ERROR_EAS_NOT_SUPPORTED : i32 = 282;
pub const ERROR_NOT_OWNER : i32 = 288;
pub const ERROR_TOO_MANY_POSTS : i32 = 298;
pub const ERROR_PARTIAL_COPY : i32 = 299;
pub const ERROR_OPLOCK_NOT_GRANTED : i32 = 300;
pub const ERROR_INVALID_OPLOCK_PROTOCOL : i32 = 301;
pub const ERROR_DISK_TOO_FRAGMENTED : i32 = 302;
pub const ERROR_DELETE_PENDING : i32 = 303;
pub const ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING : i32 = 304;
pub const ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME : i32 = 305;
pub const ERROR_SECURITY_STREAM_IS_INCONSISTENT : i32 = 306;
pub const ERROR_INVALID_LOCK_RANGE : i32 = 307;
pub const ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT : i32 = 308;
pub const ERROR_NOTIFICATION_GUID_ALREADY_DEFINED : i32 = 309;
pub const ERROR_INVALID_EXCEPTION_HANDLER : i32 = 310;
pub const ERROR_DUPLICATE_PRIVILEGES : i32 = 311;
pub const ERROR_NO_RANGES_PROCESSED : i32 = 312;
pub const ERROR_NOT_ALLOWED_ON_SYSTEM_FILE : i32 = 313;
pub const ERROR_DISK_RESOURCES_EXHAUSTED : i32 = 314;
pub const ERROR_INVALID_TOKEN : i32 = 315;
pub const ERROR_DEVICE_FEATURE_NOT_SUPPORTED : i32 = 316;
pub const ERROR_MR_MID_NOT_FOUND : i32 = 317;
pub const ERROR_SCOPE_NOT_FOUND : i32 = 318;
pub const ERROR_UNDEFINED_SCOPE : i32 = 319;
pub const ERROR_INVALID_CAP : i32 = 320;
pub const ERROR_DEVICE_UNREACHABLE : i32 = 321;
pub const ERROR_DEVICE_NO_RESOURCES : i32 = 322;
pub const ERROR_DATA_CHECKSUM_ERROR : i32 = 323;
pub const ERROR_INTERMIXED_KERNEL_EA_OPERATION : i32 = 324;
pub const ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED : i32 = 326;
pub const ERROR_OFFSET_ALIGNMENT_VIOLATION : i32 = 327;
pub const ERROR_INVALID_FIELD_IN_PARAMETER_LIST : i32 = 328;
pub const ERROR_OPERATION_IN_PROGRESS : i32 = 329;
pub const ERROR_BAD_DEVICE_PATH : i32 = 330;
pub const ERROR_TOO_MANY_DESCRIPTORS : i32 = 331;
pub const ERROR_SCRUB_DATA_DISABLED : i32 = 332;
pub const ERROR_NOT_REDUNDANT_STORAGE : i32 = 333;
pub const ERROR_RESIDENT_FILE_NOT_SUPPORTED : i32 = 334;
pub const ERROR_COMPRESSED_FILE_NOT_SUPPORTED : i32 = 335;
pub const ERROR_DIRECTORY_NOT_SUPPORTED : i32 = 336;
pub const ERROR_NOT_READ_FROM_COPY : i32 = 337;
pub const ERROR_FT_WRITE_FAILURE : i32 = 338;
pub const ERROR_FT_DI_SCAN_REQUIRED : i32 = 339;
pub const ERROR_INVALID_KERNEL_INFO_VERSION : i32 = 340;
pub const ERROR_INVALID_PEP_INFO_VERSION : i32 = 341;
pub const ERROR_OBJECT_NOT_EXTERNALLY_BACKED : i32 = 342;
pub const ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN : i32 = 343;
pub const ERROR_COMPRESSION_NOT_BENEFICIAL : i32 = 344;
pub const ERROR_STORAGE_TOPOLOGY_ID_MISMATCH : i32 = 345;
pub const ERROR_BLOCKED_BY_PARENTAL_CONTROLS : i32 = 346;
pub const ERROR_BLOCK_TOO_MANY_REFERENCES : i32 = 347;
pub const ERROR_MARKED_TO_DISALLOW_WRITES : i32 = 348;
pub const ERROR_ENCLAVE_FAILURE : i32 = 349;
pub const ERROR_FAIL_NOACTION_REBOOT : i32 = 350;
pub const ERROR_FAIL_SHUTDOWN : i32 = 351;
pub const ERROR_FAIL_RESTART : i32 = 352;
pub const ERROR_MAX_SESSIONS_REACHED : i32 = 353;
pub const ERROR_NETWORK_ACCESS_DENIED_EDP : i32 = 354;
pub const ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL : i32 = 355;
pub const ERROR_EDP_POLICY_DENIES_OPERATION : i32 = 356;
pub const ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED : i32 = 357;
pub const ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT : i32 = 358;
pub const ERROR_DEVICE_IN_MAINTENANCE : i32 = 359;
pub const ERROR_NOT_SUPPORTED_ON_DAX : i32 = 360;
pub const ERROR_DAX_MAPPING_EXISTS : i32 = 361;
pub const ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING : i32 = 362;
pub const ERROR_CLOUD_FILE_METADATA_CORRUPT : i32 = 363;
pub const ERROR_CLOUD_FILE_METADATA_TOO_LARGE : i32 = 364;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE : i32 = 365;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH : i32 = 366;
pub const ERROR_CHILD_PROCESS_BLOCKED : i32 = 367;
pub const ERROR_STORAGE_LOST_DATA_PERSISTENCE : i32 = 368;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE : i32 = 369;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT : i32 = 370;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY : i32 = 371;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN : i32 = 372;
pub const ERROR_GDI_HANDLE_LEAK : i32 = 373;
pub const ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS : i32 = 374;
pub const ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED : i32 = 375;
pub const ERROR_NOT_A_CLOUD_FILE : i32 = 376;
pub const ERROR_CLOUD_FILE_NOT_IN_SYNC : i32 = 377;
pub const ERROR_CLOUD_FILE_ALREADY_CONNECTED : i32 = 378;
pub const ERROR_CLOUD_FILE_NOT_SUPPORTED : i32 = 379;
pub const ERROR_CLOUD_FILE_INVALID_REQUEST : i32 = 380;
pub const ERROR_CLOUD_FILE_READ_ONLY_VOLUME : i32 = 381;
pub const ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY : i32 = 382;
pub const ERROR_CLOUD_FILE_VALIDATION_FAILED : i32 = 383;
pub const ERROR_SMB1_NOT_AVAILABLE : i32 = 384;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION : i32 = 385;
pub const ERROR_CLOUD_FILE_AUTHENTICATION_FAILED : i32 = 386;
pub const ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES : i32 = 387;
pub const ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE : i32 = 388;
pub const ERROR_CLOUD_FILE_UNSUCCESSFUL : i32 = 389;
pub const ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT : i32 = 390;
pub const ERROR_CLOUD_FILE_IN_USE : i32 = 391;
pub const ERROR_CLOUD_FILE_PINNED : i32 = 392;
pub const ERROR_CLOUD_FILE_REQUEST_ABORTED : i32 = 393;
pub const ERROR_CLOUD_FILE_PROPERTY_CORRUPT : i32 = 394;
pub const ERROR_CLOUD_FILE_ACCESS_DENIED : i32 = 395;
pub const ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS : i32 = 396;
pub const ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT : i32 = 397;
pub const ERROR_CLOUD_FILE_REQUEST_CANCELED : i32 = 398;
pub const ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED : i32 = 399;
pub const ERROR_THREAD_MODE_ALREADY_BACKGROUND : i32 = 400;
pub const ERROR_THREAD_MODE_NOT_BACKGROUND : i32 = 401;
pub const ERROR_PROCESS_MODE_ALREADY_BACKGROUND : i32 = 402;
pub const ERROR_PROCESS_MODE_NOT_BACKGROUND : i32 = 403;
pub const ERROR_CLOUD_FILE_PROVIDER_TERMINATED : i32 = 404;
pub const ERROR_NOT_A_CLOUD_SYNC_ROOT : i32 = 405;
pub const ERROR_FILE_PROTECTED_UNDER_DPL : i32 = 406;
pub const ERROR_VOLUME_NOT_CLUSTER_ALIGNED : i32 = 407;
pub const ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND : i32 = 408;
pub const ERROR_APPX_FILE_NOT_ENCRYPTED : i32 = 409;
pub const ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED : i32 = 410;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET : i32 = 411;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE : i32 = 412;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER : i32 = 413;
pub const ERROR_LINUX_SUBSYSTEM_NOT_PRESENT : i32 = 414;
pub const ERROR_FT_READ_FAILURE : i32 = 415;
pub const ERROR_STORAGE_RESERVE_ID_INVALID : i32 = 416;
pub const ERROR_STORAGE_RESERVE_DOES_NOT_EXIST : i32 = 417;
pub const ERROR_STORAGE_RESERVE_ALREADY_EXISTS : i32 = 418;
pub const ERROR_STORAGE_RESERVE_NOT_EMPTY : i32 = 419;
pub const ERROR_NOT_A_DAX_VOLUME : i32 = 420;
pub const ERROR_NOT_DAX_MAPPABLE : i32 = 421;
pub const ERROR_TIME_SENSITIVE_THREAD : i32 = 422;
pub const ERROR_DPL_NOT_SUPPORTED_FOR_USER : i32 = 423;
pub const ERROR_CASE_DIFFERING_NAMES_IN_DIR : i32 = 424;
pub const ERROR_FILE_NOT_SUPPORTED : i32 = 425;
pub const ERROR_CLOUD_FILE_REQUEST_TIMEOUT : i32 = 426;
pub const ERROR_NO_TASK_QUEUE : i32 = 427;
pub const ERROR_SRC_SRV_DLL_LOAD_FAILED : i32 = 428;
pub const ERROR_NOT_SUPPORTED_WITH_BTT : i32 = 429;
pub const ERROR_ENCRYPTION_DISABLED : i32 = 430;
pub const ERROR_ENCRYPTING_METADATA_DISALLOWED : i32 = 431;
pub const ERROR_CANT_CLEAR_ENCRYPTION_FLAG : i32 = 432;
pub const ERROR_NO_SUCH_DEVICE : i32 = 433;
pub const ERROR_CLOUD_FILE_DEHYDRATION_DISALLOWED : i32 = 434;
pub const ERROR_FILE_SNAP_IN_PROGRESS : i32 = 435;
pub const ERROR_FILE_SNAP_USER_SECTION_NOT_SUPPORTED : i32 = 436;
pub const ERROR_FILE_SNAP_MODIFY_NOT_SUPPORTED : i32 = 437;
pub const ERROR_FILE_SNAP_IO_NOT_COORDINATED : i32 = 438;
pub const ERROR_FILE_SNAP_UNEXPECTED_ERROR : i32 = 439;
pub const ERROR_FILE_SNAP_INVALID_PARAMETER : i32 = 440;
pub const ERROR_UNSATISFIED_DEPENDENCIES : i32 = 441;
pub const ERROR_CASE_SENSITIVE_PATH : i32 = 442;
pub const ERROR_UNEXPECTED_NTCACHEMANAGER_ERROR : i32 = 443;
pub const ERROR_CAPAUTHZ_NOT_DEVUNLOCKED : i32 = 450;
pub const ERROR_CAPAUTHZ_CHANGE_TYPE : i32 = 451;
pub const ERROR_CAPAUTHZ_NOT_PROVISIONED : i32 = 452;
pub const ERROR_CAPAUTHZ_NOT_AUTHORIZED : i32 = 453;
pub const ERROR_CAPAUTHZ_NO_POLICY : i32 = 454;
pub const ERROR_CAPAUTHZ_DB_CORRUPTED : i32 = 455;
pub const ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG : i32 = 456;
pub const ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY : i32 = 457;
pub const ERROR_CAPAUTHZ_SCCD_PARSE_ERROR : i32 = 458;
pub const ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED : i32 = 459;
pub const ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH : i32 = 460;
pub const ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT : i32 = 480;
pub const ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT : i32 = 481;
pub const ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT : i32 = 482;
pub const ERROR_DEVICE_HARDWARE_ERROR : i32 = 483;
pub const ERROR_INVALID_ADDRESS : i32 = 487;
pub const ERROR_VRF_CFG_AND_IO_ENABLED : i32 = 1183;
pub const ERROR_PARTITION_TERMINATING : i32 = 1184;
pub const ERROR_USER_PROFILE_LOAD : i32 = 500;
pub const ERROR_ARITHMETIC_OVERFLOW : i32 = 534;
pub const ERROR_PIPE_CONNECTED : i32 = 535;
pub const ERROR_PIPE_LISTENING : i32 = 536;
pub const ERROR_VERIFIER_STOP : i32 = 537;
pub const ERROR_ABIOS_ERROR : i32 = 538;
pub const ERROR_WX86_WARNING : i32 = 539;
pub const ERROR_WX86_ERROR : i32 = 540;
pub const ERROR_TIMER_NOT_CANCELED : i32 = 541;
pub const ERROR_UNWIND : i32 = 542;
pub const ERROR_BAD_STACK : i32 = 543;
pub const ERROR_INVALID_UNWIND_TARGET : i32 = 544;
pub const ERROR_INVALID_PORT_ATTRIBUTES : i32 = 545;
pub const ERROR_PORT_MESSAGE_TOO_LONG : i32 = 546;
pub const ERROR_INVALID_QUOTA_LOWER : i32 = 547;
pub const ERROR_DEVICE_ALREADY_ATTACHED : i32 = 548;
pub const ERROR_INSTRUCTION_MISALIGNMENT : i32 = 549;
pub const ERROR_PROFILING_NOT_STARTED : i32 = 550;
pub const ERROR_PROFILING_NOT_STOPPED : i32 = 551;
pub const ERROR_COULD_NOT_INTERPRET : i32 = 552;
pub const ERROR_PROFILING_AT_LIMIT : i32 = 553;
pub const ERROR_CANT_WAIT : i32 = 554;
pub const ERROR_CANT_TERMINATE_SELF : i32 = 555;
pub const ERROR_UNEXPECTED_MM_CREATE_ERR : i32 = 556;
pub const ERROR_UNEXPECTED_MM_MAP_ERROR : i32 = 557;
pub const ERROR_UNEXPECTED_MM_EXTEND_ERR : i32 = 558;
pub const ERROR_BAD_FUNCTION_TABLE : i32 = 559;
pub const ERROR_NO_GUID_TRANSLATION : i32 = 560;
pub const ERROR_INVALID_LDT_SIZE : i32 = 561;
pub const ERROR_INVALID_LDT_OFFSET : i32 = 563;
pub const ERROR_INVALID_LDT_DESCRIPTOR : i32 = 564;
pub const ERROR_TOO_MANY_THREADS : i32 = 565;
pub const ERROR_THREAD_NOT_IN_PROCESS : i32 = 566;
pub const ERROR_PAGEFILE_QUOTA_EXCEEDED : i32 = 567;
pub const ERROR_LOGON_SERVER_CONFLICT : i32 = 568;
pub const ERROR_SYNCHRONIZATION_REQUIRED : i32 = 569;
pub const ERROR_NET_OPEN_FAILED : i32 = 570;
pub const ERROR_IO_PRIVILEGE_FAILED : i32 = 571;
pub const ERROR_CONTROL_C_EXIT : i32 = 572;
pub const ERROR_MISSING_SYSTEMFILE : i32 = 573;
pub const ERROR_UNHANDLED_EXCEPTION : i32 = 574;
pub const ERROR_APP_INIT_FAILURE : i32 = 575;
pub const ERROR_PAGEFILE_CREATE_FAILED : i32 = 576;
pub const ERROR_INVALID_IMAGE_HASH : i32 = 577;
pub const ERROR_NO_PAGEFILE : i32 = 578;
pub const ERROR_ILLEGAL_FLOAT_CONTEXT : i32 = 579;
pub const ERROR_NO_EVENT_PAIR : i32 = 580;
pub const ERROR_DOMAIN_CTRLR_CONFIG_ERROR : i32 = 581;
pub const ERROR_ILLEGAL_CHARACTER : i32 = 582;
pub const ERROR_UNDEFINED_CHARACTER : i32 = 583;
pub const ERROR_FLOPPY_VOLUME : i32 = 584;
pub const ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT : i32 = 585;
pub const ERROR_BACKUP_CONTROLLER : i32 = 586;
pub const ERROR_MUTANT_LIMIT_EXCEEDED : i32 = 587;
pub const ERROR_FS_DRIVER_REQUIRED : i32 = 588;
pub const ERROR_CANNOT_LOAD_REGISTRY_FILE : i32 = 589;
pub const ERROR_DEBUG_ATTACH_FAILED : i32 = 590;
pub const ERROR_SYSTEM_PROCESS_TERMINATED : i32 = 591;
pub const ERROR_DATA_NOT_ACCEPTED : i32 = 592;
pub const ERROR_VDM_HARD_ERROR : i32 = 593;
pub const ERROR_DRIVER_CANCEL_TIMEOUT : i32 = 594;
pub const ERROR_REPLY_MESSAGE_MISMATCH : i32 = 595;
pub const ERROR_LOST_WRITEBEHIND_DATA : i32 = 596;
pub const ERROR_CLIENT_SERVER_PARAMETERS_INVALID : i32 = 597;
pub const ERROR_NOT_TINY_STREAM : i32 = 598;
pub const ERROR_STACK_OVERFLOW_READ : i32 = 599;
pub const ERROR_CONVERT_TO_LARGE : i32 = 600;
pub const ERROR_FOUND_OUT_OF_SCOPE : i32 = 601;
pub const ERROR_ALLOCATE_BUCKET : i32 = 602;
pub const ERROR_MARSHALL_OVERFLOW : i32 = 603;
pub const ERROR_INVALID_VARIANT : i32 = 604;
pub const ERROR_BAD_COMPRESSION_BUFFER : i32 = 605;
pub const ERROR_AUDIT_FAILED : i32 = 606;
pub const ERROR_TIMER_RESOLUTION_NOT_SET : i32 = 607;
pub const ERROR_INSUFFICIENT_LOGON_INFO : i32 = 608;
pub const ERROR_BAD_DLL_ENTRYPOINT : i32 = 609;
pub const ERROR_BAD_SERVICE_ENTRYPOINT : i32 = 610;
pub const ERROR_IP_ADDRESS_CONFLICT1 : i32 = 611;
pub const ERROR_IP_ADDRESS_CONFLICT2 : i32 = 612;
pub const ERROR_REGISTRY_QUOTA_LIMIT : i32 = 613;
pub const ERROR_NO_CALLBACK_ACTIVE : i32 = 614;
pub const ERROR_PWD_TOO_SHORT : i32 = 615;
pub const ERROR_PWD_TOO_RECENT : i32 = 616;
pub const ERROR_PWD_HISTORY_CONFLICT : i32 = 617;
pub const ERROR_UNSUPPORTED_COMPRESSION : i32 = 618;
pub const ERROR_INVALID_HW_PROFILE : i32 = 619;
pub const ERROR_INVALID_PLUGPLAY_DEVICE_PATH : i32 = 620;
pub const ERROR_QUOTA_LIST_INCONSISTENT : i32 = 621;
pub const ERROR_EVALUATION_EXPIRATION : i32 = 622;
pub const ERROR_ILLEGAL_DLL_RELOCATION : i32 = 623;
pub const ERROR_DLL_INIT_FAILED_LOGOFF : i32 = 624;
pub const ERROR_VALIDATE_CONTINUE : i32 = 625;
pub const ERROR_NO_MORE_MATCHES : i32 = 626;
pub const ERROR_RANGE_LIST_CONFLICT : i32 = 627;
pub const ERROR_SERVER_SID_MISMATCH : i32 = 628;
pub const ERROR_CANT_ENABLE_DENY_ONLY : i32 = 629;
pub const ERROR_FLOAT_MULTIPLE_FAULTS : i32 = 630;
pub const ERROR_FLOAT_MULTIPLE_TRAPS : i32 = 631;
pub const ERROR_NOINTERFACE : i32 = 632;
pub const ERROR_DRIVER_FAILED_SLEEP : i32 = 633;
pub const ERROR_CORRUPT_SYSTEM_FILE : i32 = 634;
pub const ERROR_COMMITMENT_MINIMUM : i32 = 635;
pub const ERROR_PNP_RESTART_ENUMERATION : i32 = 636;
pub const ERROR_SYSTEM_IMAGE_BAD_SIGNATURE : i32 = 637;
pub const ERROR_PNP_REBOOT_REQUIRED : i32 = 638;
pub const ERROR_INSUFFICIENT_POWER : i32 = 639;
pub const ERROR_MULTIPLE_FAULT_VIOLATION : i32 = 640;
pub const ERROR_SYSTEM_SHUTDOWN : i32 = 641;
pub const ERROR_PORT_NOT_SET : i32 = 642;
pub const ERROR_DS_VERSION_CHECK_FAILURE : i32 = 643;
pub const ERROR_RANGE_NOT_FOUND : i32 = 644;
pub const ERROR_NOT_SAFE_MODE_DRIVER : i32 = 646;
pub const ERROR_FAILED_DRIVER_ENTRY : i32 = 647;
pub const ERROR_DEVICE_ENUMERATION_ERROR : i32 = 648;
pub const ERROR_MOUNT_POINT_NOT_RESOLVED : i32 = 649;
pub const ERROR_INVALID_DEVICE_OBJECT_PARAMETER : i32 = 650;
pub const ERROR_MCA_OCCURED : i32 = 651;
pub const ERROR_DRIVER_DATABASE_ERROR : i32 = 652;
pub const ERROR_SYSTEM_HIVE_TOO_LARGE : i32 = 653;
pub const ERROR_DRIVER_FAILED_PRIOR_UNLOAD : i32 = 654;
pub const ERROR_VOLSNAP_PREPARE_HIBERNATE : i32 = 655;
pub const ERROR_HIBERNATION_FAILURE : i32 = 656;
pub const ERROR_PWD_TOO_LONG : i32 = 657;
pub const ERROR_FILE_SYSTEM_LIMITATION : i32 = 665;
pub const ERROR_ASSERTION_FAILURE : i32 = 668;
pub const ERROR_ACPI_ERROR : i32 = 669;
pub const ERROR_WOW_ASSERTION : i32 = 670;
pub const ERROR_PNP_BAD_MPS_TABLE : i32 = 671;
pub const ERROR_PNP_TRANSLATION_FAILED : i32 = 672;
pub const ERROR_PNP_IRQ_TRANSLATION_FAILED : i32 = 673;
pub const ERROR_PNP_INVALID_ID : i32 = 674;
pub const ERROR_WAKE_SYSTEM_DEBUGGER : i32 = 675;
pub const ERROR_HANDLES_CLOSED : i32 = 676;
pub const ERROR_EXTRANEOUS_INFORMATION : i32 = 677;
pub const ERROR_RXACT_COMMIT_NECESSARY : i32 = 678;
pub const ERROR_MEDIA_CHECK : i32 = 679;
pub const ERROR_GUID_SUBSTITUTION_MADE : i32 = 680;
pub const ERROR_STOPPED_ON_SYMLINK : i32 = 681;
pub const ERROR_LONGJUMP : i32 = 682;
pub const ERROR_PLUGPLAY_QUERY_VETOED : i32 = 683;
pub const ERROR_UNWIND_CONSOLIDATE : i32 = 684;
pub const ERROR_REGISTRY_HIVE_RECOVERED : i32 = 685;
pub const ERROR_DLL_MIGHT_BE_INSECURE : i32 = 686;
pub const ERROR_DLL_MIGHT_BE_INCOMPATIBLE : i32 = 687;
pub const ERROR_DBG_EXCEPTION_NOT_HANDLED : i32 = 688;
pub const ERROR_DBG_REPLY_LATER : i32 = 689;
pub const ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE : i32 = 690;
pub const ERROR_DBG_TERMINATE_THREAD : i32 = 691;
pub const ERROR_DBG_TERMINATE_PROCESS : i32 = 692;
pub const ERROR_DBG_CONTROL_C : i32 = 693;
pub const ERROR_DBG_PRINTEXCEPTION_C : i32 = 694;
pub const ERROR_DBG_RIPEXCEPTION : i32 = 695;
pub const ERROR_DBG_CONTROL_BREAK : i32 = 696;
pub const ERROR_DBG_COMMAND_EXCEPTION : i32 = 697;
pub const ERROR_OBJECT_NAME_EXISTS : i32 = 698;
pub const ERROR_THREAD_WAS_SUSPENDED : i32 = 699;
pub const ERROR_IMAGE_NOT_AT_BASE : i32 = 700;
pub const ERROR_RXACT_STATE_CREATED : i32 = 701;
pub const ERROR_SEGMENT_NOTIFICATION : i32 = 702;
pub const ERROR_BAD_CURRENT_DIRECTORY : i32 = 703;
pub const ERROR_FT_READ_RECOVERY_FROM_BACKUP : i32 = 704;
pub const ERROR_FT_WRITE_RECOVERY : i32 = 705;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH : i32 = 706;
pub const ERROR_RECEIVE_PARTIAL : i32 = 707;
pub const ERROR_RECEIVE_EXPEDITED : i32 = 708;
pub const ERROR_RECEIVE_PARTIAL_EXPEDITED : i32 = 709;
pub const ERROR_EVENT_DONE : i32 = 710;
pub const ERROR_EVENT_PENDING : i32 = 711;
pub const ERROR_CHECKING_FILE_SYSTEM : i32 = 712;
pub const ERROR_FATAL_APP_EXIT : i32 = 713;
pub const ERROR_PREDEFINED_HANDLE : i32 = 714;
pub const ERROR_WAS_UNLOCKED : i32 = 715;
pub const ERROR_SERVICE_NOTIFICATION : i32 = 716;
pub const ERROR_WAS_LOCKED : i32 = 717;
pub const ERROR_LOG_HARD_ERROR : i32 = 718;
pub const ERROR_ALREADY_WIN32 : i32 = 719;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE : i32 = 720;
pub const ERROR_NO_YIELD_PERFORMED : i32 = 721;
pub const ERROR_TIMER_RESUME_IGNORED : i32 = 722;
pub const ERROR_ARBITRATION_UNHANDLED : i32 = 723;
pub const ERROR_CARDBUS_NOT_SUPPORTED : i32 = 724;
pub const ERROR_MP_PROCESSOR_MISMATCH : i32 = 725;
pub const ERROR_HIBERNATED : i32 = 726;
pub const ERROR_RESUME_HIBERNATION : i32 = 727;
pub const ERROR_FIRMWARE_UPDATED : i32 = 728;
pub const ERROR_DRIVERS_LEAKING_LOCKED_PAGES : i32 = 729;
pub const ERROR_WAKE_SYSTEM : i32 = 730;
pub const ERROR_WAIT_1 : i32 = 731;
pub const ERROR_WAIT_2 : i32 = 732;
pub const ERROR_WAIT_3 : i32 = 733;
pub const ERROR_WAIT_63 : i32 = 734;
pub const ERROR_ABANDONED_WAIT_0 : i32 = 735;
pub const ERROR_ABANDONED_WAIT_63 : i32 = 736;
pub const ERROR_USER_APC : i32 = 737;
pub const ERROR_KERNEL_APC : i32 = 738;
pub const ERROR_ALERTED : i32 = 739;
pub const ERROR_ELEVATION_REQUIRED : i32 = 740;
pub const ERROR_REPARSE : i32 = 741;
pub const ERROR_OPLOCK_BREAK_IN_PROGRESS : i32 = 742;
pub const ERROR_VOLUME_MOUNTED : i32 = 743;
pub const ERROR_RXACT_COMMITTED : i32 = 744;
pub const ERROR_NOTIFY_CLEANUP : i32 = 745;
pub const ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED : i32 = 746;
pub const ERROR_PAGE_FAULT_TRANSITION : i32 = 747;
pub const ERROR_PAGE_FAULT_DEMAND_ZERO : i32 = 748;
pub const ERROR_PAGE_FAULT_COPY_ON_WRITE : i32 = 749;
pub const ERROR_PAGE_FAULT_GUARD_PAGE : i32 = 750;
pub const ERROR_PAGE_FAULT_PAGING_FILE : i32 = 751;
pub const ERROR_CACHE_PAGE_LOCKED : i32 = 752;
pub const ERROR_CRASH_DUMP : i32 = 753;
pub const ERROR_BUFFER_ALL_ZEROS : i32 = 754;
pub const ERROR_REPARSE_OBJECT : i32 = 755;
pub const ERROR_RESOURCE_REQUIREMENTS_CHANGED : i32 = 756;
pub const ERROR_TRANSLATION_COMPLETE : i32 = 757;
pub const ERROR_NOTHING_TO_TERMINATE : i32 = 758;
pub const ERROR_PROCESS_NOT_IN_JOB : i32 = 759;
pub const ERROR_PROCESS_IN_JOB : i32 = 760;
pub const ERROR_VOLSNAP_HIBERNATE_READY : i32 = 761;
pub const ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY : i32 = 762;
pub const ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED : i32 = 763;
pub const ERROR_INTERRUPT_STILL_CONNECTED : i32 = 764;
pub const ERROR_WAIT_FOR_OPLOCK : i32 = 765;
pub const ERROR_DBG_EXCEPTION_HANDLED : i32 = 766;
pub const ERROR_DBG_CONTINUE : i32 = 767;
pub const ERROR_CALLBACK_POP_STACK : i32 = 768;
pub const ERROR_COMPRESSION_DISABLED : i32 = 769;
pub const ERROR_CANTFETCHBACKWARDS : i32 = 770;
pub const ERROR_CANTSCROLLBACKWARDS : i32 = 771;
pub const ERROR_ROWSNOTRELEASED : i32 = 772;
pub const ERROR_BAD_ACCESSOR_FLAGS : i32 = 773;
pub const ERROR_ERRORS_ENCOUNTERED : i32 = 774;
pub const ERROR_NOT_CAPABLE : i32 = 775;
pub const ERROR_REQUEST_OUT_OF_SEQUENCE : i32 = 776;
pub const ERROR_VERSION_PARSE_ERROR : i32 = 777;
pub const ERROR_BADSTARTPOSITION : i32 = 778;
pub const ERROR_MEMORY_HARDWARE : i32 = 779;
pub const ERROR_DISK_REPAIR_DISABLED : i32 = 780;
pub const ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE : i32 = 781;
pub const ERROR_SYSTEM_POWERSTATE_TRANSITION : i32 = 782;
pub const ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION : i32 = 783;
pub const ERROR_MCA_EXCEPTION : i32 = 784;
pub const ERROR_ACCESS_AUDIT_BY_POLICY : i32 = 785;
pub const ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY : i32 = 786;
pub const ERROR_ABANDON_HIBERFILE : i32 = 787;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED : i32 = 788;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR : i32 = 789;
pub const ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR : i32 = 790;
pub const ERROR_BAD_MCFG_TABLE : i32 = 791;
pub const ERROR_DISK_REPAIR_REDIRECTED : i32 = 792;
pub const ERROR_DISK_REPAIR_UNSUCCESSFUL : i32 = 793;
pub const ERROR_CORRUPT_LOG_OVERFULL : i32 = 794;
pub const ERROR_CORRUPT_LOG_CORRUPTED : i32 = 795;
pub const ERROR_CORRUPT_LOG_UNAVAILABLE : i32 = 796;
pub const ERROR_CORRUPT_LOG_DELETED_FULL : i32 = 797;
pub const ERROR_CORRUPT_LOG_CLEARED : i32 = 798;
pub const ERROR_ORPHAN_NAME_EXHAUSTED : i32 = 799;
pub const ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE : i32 = 800;
pub const ERROR_CANNOT_GRANT_REQUESTED_OPLOCK : i32 = 801;
pub const ERROR_CANNOT_BREAK_OPLOCK : i32 = 802;
pub const ERROR_OPLOCK_HANDLE_CLOSED : i32 = 803;
pub const ERROR_NO_ACE_CONDITION : i32 = 804;
pub const ERROR_INVALID_ACE_CONDITION : i32 = 805;
pub const ERROR_FILE_HANDLE_REVOKED : i32 = 806;
pub const ERROR_IMAGE_AT_DIFFERENT_BASE : i32 = 807;
pub const ERROR_ENCRYPTED_IO_NOT_POSSIBLE : i32 = 808;
pub const ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS : i32 = 809;
pub const ERROR_QUOTA_ACTIVITY : i32 = 810;
pub const ERROR_HANDLE_REVOKED : i32 = 811;
pub const ERROR_CALLBACK_INVOKE_INLINE : i32 = 812;
pub const ERROR_CPU_SET_INVALID : i32 = 813;
pub const ERROR_ENCLAVE_NOT_TERMINATED : i32 = 814;
pub const ERROR_ENCLAVE_VIOLATION : i32 = 815;
pub const ERROR_EA_ACCESS_DENIED : i32 = 994;
pub const ERROR_OPERATION_ABORTED : i32 = 995;
pub const ERROR_IO_INCOMPLETE : i32 = 996;
pub const ERROR_IO_PENDING : i32 = 997;
pub const ERROR_NOACCESS : i32 = 998;
pub const ERROR_SWAPERROR : i32 = 999;
pub const ERROR_STACK_OVERFLOW : i32 = 1001;
pub const ERROR_INVALID_MESSAGE : i32 = 1002;
pub const ERROR_CAN_NOT_COMPLETE : i32 = 1003;
pub const ERROR_INVALID_FLAGS : i32 = 1004;
pub const ERROR_UNRECOGNIZED_VOLUME : i32 = 1005;
pub const ERROR_FILE_INVALID : i32 = 1006;
pub const ERROR_FULLSCREEN_MODE : i32 = 1007;
pub const ERROR_NO_TOKEN : i32 = 1008;
pub const ERROR_BADDB : i32 = 1009;
pub const ERROR_BADKEY : i32 = 1010;
pub const ERROR_CANTOPEN : i32 = 1011;
pub const ERROR_CANTREAD : i32 = 1012;
pub const ERROR_CANTWRITE : i32 = 1013;
pub const ERROR_REGISTRY_RECOVERED : i32 = 1014;
pub const ERROR_REGISTRY_CORRUPT : i32 = 1015;
pub const ERROR_REGISTRY_IO_FAILED : i32 = 1016;
pub const ERROR_NOT_REGISTRY_FILE : i32 = 1017;
pub const ERROR_KEY_DELETED : i32 = 1018;
pub const ERROR_NO_LOG_SPACE : i32 = 1019;
pub const ERROR_KEY_HAS_CHILDREN : i32 = 1020;
pub const ERROR_CHILD_MUST_BE_VOLATILE : i32 = 1021;
pub const ERROR_NOTIFY_ENUM_DIR : i32 = 1022;
pub const ERROR_DEPENDENT_SERVICES_RUNNING : i32 = 1051;
pub const ERROR_INVALID_SERVICE_CONTROL : i32 = 1052;
pub const ERROR_SERVICE_REQUEST_TIMEOUT : i32 = 1053;
pub const ERROR_SERVICE_NO_THREAD : i32 = 1054;
pub const ERROR_SERVICE_DATABASE_LOCKED : i32 = 1055;
pub const ERROR_SERVICE_ALREADY_RUNNING : i32 = 1056;
pub const ERROR_INVALID_SERVICE_ACCOUNT : i32 = 1057;
pub const ERROR_SERVICE_DISABLED : i32 = 1058;
pub const ERROR_CIRCULAR_DEPENDENCY : i32 = 1059;
pub const ERROR_SERVICE_DOES_NOT_EXIST : i32 = 1060;
pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL : i32 = 1061;
pub const ERROR_SERVICE_NOT_ACTIVE : i32 = 1062;
pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT : i32 = 1063;
pub const ERROR_EXCEPTION_IN_SERVICE : i32 = 1064;
pub const ERROR_DATABASE_DOES_NOT_EXIST : i32 = 1065;
pub const ERROR_SERVICE_SPECIFIC_ERROR : i32 = 1066;
pub const ERROR_PROCESS_ABORTED : i32 = 1067;
pub const ERROR_SERVICE_DEPENDENCY_FAIL : i32 = 1068;
pub const ERROR_SERVICE_LOGON_FAILED : i32 = 1069;
pub const ERROR_SERVICE_START_HANG : i32 = 1070;
pub const ERROR_INVALID_SERVICE_LOCK : i32 = 1071;
pub const ERROR_SERVICE_MARKED_FOR_DELETE : i32 = 1072;
pub const ERROR_SERVICE_EXISTS : i32 = 1073;
pub const ERROR_ALREADY_RUNNING_LKG : i32 = 1074;
pub const ERROR_SERVICE_DEPENDENCY_DELETED : i32 = 1075;
pub const ERROR_BOOT_ALREADY_ACCEPTED : i32 = 1076;
pub const ERROR_SERVICE_NEVER_STARTED : i32 = 1077;
pub const ERROR_DUPLICATE_SERVICE_NAME : i32 = 1078;
pub const ERROR_DIFFERENT_SERVICE_ACCOUNT : i32 = 1079;
pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE : i32 = 1080;
pub const ERROR_CANNOT_DETECT_PROCESS_ABORT : i32 = 1081;
pub const ERROR_NO_RECOVERY_PROGRAM : i32 = 1082;
pub const ERROR_SERVICE_NOT_IN_EXE : i32 = 1083;
pub const ERROR_NOT_SAFEBOOT_SERVICE : i32 = 1084;
pub const ERROR_END_OF_MEDIA : i32 = 1100;
pub const ERROR_FILEMARK_DETECTED : i32 = 1101;
pub const ERROR_BEGINNING_OF_MEDIA : i32 = 1102;
pub const ERROR_SETMARK_DETECTED : i32 = 1103;
pub const ERROR_NO_DATA_DETECTED : i32 = 1104;
pub const ERROR_PARTITION_FAILURE : i32 = 1105;
pub const ERROR_INVALID_BLOCK_LENGTH : i32 = 1106;
pub const ERROR_DEVICE_NOT_PARTITIONED : i32 = 1107;
pub const ERROR_UNABLE_TO_LOCK_MEDIA : i32 = 1108;
pub const ERROR_UNABLE_TO_UNLOAD_MEDIA : i32 = 1109;
pub const ERROR_MEDIA_CHANGED : i32 = 1110;
pub const ERROR_BUS_RESET : i32 = 1111;
pub const ERROR_NO_MEDIA_IN_DRIVE : i32 = 1112;
pub const ERROR_NO_UNICODE_TRANSLATION : i32 = 1113;
pub const ERROR_DLL_INIT_FAILED : i32 = 1114;
pub const ERROR_SHUTDOWN_IN_PROGRESS : i32 = 1115;
pub const ERROR_NO_SHUTDOWN_IN_PROGRESS : i32 = 1116;
pub const ERROR_IO_DEVICE : i32 = 1117;
pub const ERROR_SERIAL_NO_DEVICE : i32 = 1118;
pub const ERROR_IRQ_BUSY : i32 = 1119;
pub const ERROR_MORE_WRITES : i32 = 1120;
pub const ERROR_COUNTER_TIMEOUT : i32 = 1121;
pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND : i32 = 1122;
pub const ERROR_FLOPPY_WRONG_CYLINDER : i32 = 1123;
pub const ERROR_FLOPPY_UNKNOWN_ERROR : i32 = 1124;
pub const ERROR_FLOPPY_BAD_REGISTERS : i32 = 1125;
pub const ERROR_DISK_RECALIBRATE_FAILED : i32 = 1126;
pub const ERROR_DISK_OPERATION_FAILED : i32 = 1127;
pub const ERROR_DISK_RESET_FAILED : i32 = 1128;
pub const ERROR_EOM_OVERFLOW : i32 = 1129;
pub const ERROR_NOT_ENOUGH_SERVER_MEMORY : i32 = 1130;
pub const ERROR_POSSIBLE_DEADLOCK : i32 = 1131;
pub const ERROR_MAPPED_ALIGNMENT : i32 = 1132;
pub const ERROR_SET_POWER_STATE_VETOED : i32 = 1140;
pub const ERROR_SET_POWER_STATE_FAILED : i32 = 1141;
pub const ERROR_TOO_MANY_LINKS : i32 = 1142;
pub const ERROR_OLD_WIN_VERSION : i32 = 1150;
pub const ERROR_APP_WRONG_OS : i32 = 1151;
pub const ERROR_SINGLE_INSTANCE_APP : i32 = 1152;
pub const ERROR_RMODE_APP : i32 = 1153;
pub const ERROR_INVALID_DLL : i32 = 1154;
pub const ERROR_NO_ASSOCIATION : i32 = 1155;
pub const ERROR_DDE_FAIL : i32 = 1156;
pub const ERROR_DLL_NOT_FOUND : i32 = 1157;
pub const ERROR_NO_MORE_USER_HANDLES : i32 = 1158;
pub const ERROR_MESSAGE_SYNC_ONLY : i32 = 1159;
pub const ERROR_SOURCE_ELEMENT_EMPTY : i32 = 1160;
pub const ERROR_DESTINATION_ELEMENT_FULL : i32 = 1161;
pub const ERROR_ILLEGAL_ELEMENT_ADDRESS : i32 = 1162;
pub const ERROR_MAGAZINE_NOT_PRESENT : i32 = 1163;
pub const ERROR_DEVICE_REINITIALIZATION_NEEDED : i32 = 1164;
pub const ERROR_DEVICE_REQUIRES_CLEANING : i32 = 1165;
pub const ERROR_DEVICE_DOOR_OPEN : i32 = 1166;
pub const ERROR_DEVICE_NOT_CONNECTED : i32 = 1167;
pub const ERROR_NOT_FOUND : i32 = 1168;
pub const ERROR_NO_MATCH : i32 = 1169;
pub const ERROR_SET_NOT_FOUND : i32 = 1170;
pub const ERROR_POINT_NOT_FOUND : i32 = 1171;
pub const ERROR_NO_TRACKING_SERVICE : i32 = 1172;
pub const ERROR_NO_VOLUME_ID : i32 = 1173;
pub const ERROR_UNABLE_TO_REMOVE_REPLACED : i32 = 1175;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT : i32 = 1176;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 : i32 = 1177;
pub const ERROR_JOURNAL_DELETE_IN_PROGRESS : i32 = 1178;
pub const ERROR_JOURNAL_NOT_ACTIVE : i32 = 1179;
pub const ERROR_POTENTIAL_FILE_FOUND : i32 = 1180;
pub const ERROR_JOURNAL_ENTRY_DELETED : i32 = 1181;
pub const ERROR_SHUTDOWN_IS_SCHEDULED : i32 = 1190;
pub const ERROR_SHUTDOWN_USERS_LOGGED_ON : i32 = 1191;
pub const ERROR_BAD_DEVICE : i32 = 1200;
pub const ERROR_CONNECTION_UNAVAIL : i32 = 1201;
pub const ERROR_DEVICE_ALREADY_REMEMBERED : i32 = 1202;
pub const ERROR_NO_NET_OR_BAD_PATH : i32 = 1203;
pub const ERROR_BAD_PROVIDER : i32 = 1204;
pub const ERROR_CANNOT_OPEN_PROFILE : i32 = 1205;
pub const ERROR_BAD_PROFILE : i32 = 1206;
pub const ERROR_NOT_CONTAINER : i32 = 1207;
pub const ERROR_EXTENDED_ERROR : i32 = 1208;
pub const ERROR_INVALID_GROUPNAME : i32 = 1209;
pub const ERROR_INVALID_COMPUTERNAME : i32 = 1210;
pub const ERROR_INVALID_EVENTNAME : i32 = 1211;
pub const ERROR_INVALID_DOMAINNAME : i32 = 1212;
pub const ERROR_INVALID_SERVICENAME : i32 = 1213;
pub const ERROR_INVALID_NETNAME : i32 = 1214;
pub const ERROR_INVALID_SHARENAME : i32 = 1215;
pub const ERROR_INVALID_PASSWORDNAME : i32 = 1216;
pub const ERROR_INVALID_MESSAGENAME : i32 = 1217;
pub const ERROR_INVALID_MESSAGEDEST : i32 = 1218;
pub const ERROR_SESSION_CREDENTIAL_CONFLICT : i32 = 1219;
pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED : i32 = 1220;
pub const ERROR_DUP_DOMAINNAME : i32 = 1221;
pub const ERROR_NO_NETWORK : i32 = 1222;
pub const ERROR_CANCELLED : i32 = 1223;
pub const ERROR_USER_MAPPED_FILE : i32 = 1224;
pub const ERROR_CONNECTION_REFUSED : i32 = 1225;
pub const ERROR_GRACEFUL_DISCONNECT : i32 = 1226;
pub const ERROR_ADDRESS_ALREADY_ASSOCIATED : i32 = 1227;
pub const ERROR_ADDRESS_NOT_ASSOCIATED : i32 = 1228;
pub const ERROR_CONNECTION_INVALID : i32 = 1229;
pub const ERROR_CONNECTION_ACTIVE : i32 = 1230;
pub const ERROR_NETWORK_UNREACHABLE : i32 = 1231;
pub const ERROR_HOST_UNREACHABLE : i32 = 1232;
pub const ERROR_PROTOCOL_UNREACHABLE : i32 = 1233;
pub const ERROR_PORT_UNREACHABLE : i32 = 1234;
pub const ERROR_REQUEST_ABORTED : i32 = 1235;
pub const ERROR_CONNECTION_ABORTED : i32 = 1236;
pub const ERROR_RETRY : i32 = 1237;
pub const ERROR_CONNECTION_COUNT_LIMIT : i32 = 1238;
pub const ERROR_LOGIN_TIME_RESTRICTION : i32 = 1239;
pub const ERROR_LOGIN_WKSTA_RESTRICTION : i32 = 1240;
pub const ERROR_INCORRECT_ADDRESS : i32 = 1241;
pub const ERROR_ALREADY_REGISTERED : i32 = 1242;
pub const ERROR_SERVICE_NOT_FOUND : i32 = 1243;
pub const ERROR_NOT_AUTHENTICATED : i32 = 1244;
pub const ERROR_NOT_LOGGED_ON : i32 = 1245;
pub const ERROR_CONTINUE : i32 = 1246;
pub const ERROR_ALREADY_INITIALIZED : i32 = 1247;
pub const ERROR_NO_MORE_DEVICES : i32 = 1248;
pub const ERROR_NO_SUCH_SITE : i32 = 1249;
pub const ERROR_DOMAIN_CONTROLLER_EXISTS : i32 = 1250;
pub const ERROR_ONLY_IF_CONNECTED : i32 = 1251;
pub const ERROR_OVERRIDE_NOCHANGES : i32 = 1252;
pub const ERROR_BAD_USER_PROFILE : i32 = 1253;
pub const ERROR_NOT_SUPPORTED_ON_SBS : i32 = 1254;
pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS : i32 = 1255;
pub const ERROR_HOST_DOWN : i32 = 1256;
pub const ERROR_NON_ACCOUNT_SID : i32 = 1257;
pub const ERROR_NON_DOMAIN_SID : i32 = 1258;
pub const ERROR_APPHELP_BLOCK : i32 = 1259;
pub const ERROR_ACCESS_DISABLED_BY_POLICY : i32 = 1260;
pub const ERROR_REG_NAT_CONSUMPTION : i32 = 1261;
pub const ERROR_CSCSHARE_OFFLINE : i32 = 1262;
pub const ERROR_PKINIT_FAILURE : i32 = 1263;
pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE : i32 = 1264;
pub const ERROR_DOWNGRADE_DETECTED : i32 = 1265;
pub const ERROR_MACHINE_LOCKED : i32 = 1271;
pub const ERROR_SMB_GUEST_LOGON_BLOCKED : i32 = 1272;
pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA : i32 = 1273;
pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED : i32 = 1274;
pub const ERROR_DRIVER_BLOCKED : i32 = 1275;
pub const ERROR_INVALID_IMPORT_OF_NON_DLL : i32 = 1276;
pub const ERROR_ACCESS_DISABLED_WEBBLADE : i32 = 1277;
pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER : i32 = 1278;
pub const ERROR_RECOVERY_FAILURE : i32 = 1279;
pub const ERROR_ALREADY_FIBER : i32 = 1280;
pub const ERROR_ALREADY_THREAD : i32 = 1281;
pub const ERROR_STACK_BUFFER_OVERRUN : i32 = 1282;
pub const ERROR_PARAMETER_QUOTA_EXCEEDED : i32 = 1283;
pub const ERROR_DEBUGGER_INACTIVE : i32 = 1284;
pub const ERROR_DELAY_LOAD_FAILED : i32 = 1285;
pub const ERROR_VDM_DISALLOWED : i32 = 1286;
pub const ERROR_UNIDENTIFIED_ERROR : i32 = 1287;
pub const ERROR_INVALID_CRUNTIME_PARAMETER : i32 = 1288;
pub const ERROR_BEYOND_VDL : i32 = 1289;
pub const ERROR_INCOMPATIBLE_SERVICE_SID_TYPE : i32 = 1290;
pub const ERROR_DRIVER_PROCESS_TERMINATED : i32 = 1291;
pub const ERROR_IMPLEMENTATION_LIMIT : i32 = 1292;
pub const ERROR_PROCESS_IS_PROTECTED : i32 = 1293;
pub const ERROR_SERVICE_NOTIFY_CLIENT_LAGGING : i32 = 1294;
pub const ERROR_DISK_QUOTA_EXCEEDED : i32 = 1295;
pub const ERROR_CONTENT_BLOCKED : i32 = 1296;
pub const ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE : i32 = 1297;
pub const ERROR_APP_HANG : i32 = 1298;
pub const ERROR_INVALID_LABEL : i32 = 1299;
pub const ERROR_NOT_ALL_ASSIGNED : i32 = 1300;
pub const ERROR_SOME_NOT_MAPPED : i32 = 1301;
pub const ERROR_NO_QUOTAS_FOR_ACCOUNT : i32 = 1302;
pub const ERROR_LOCAL_USER_SESSION_KEY : i32 = 1303;
pub const ERROR_NULL_LM_PASSWORD : i32 = 1304;
pub const ERROR_UNKNOWN_REVISION : i32 = 1305;
pub const ERROR_REVISION_MISMATCH : i32 = 1306;
pub const ERROR_INVALID_OWNER : i32 = 1307;
pub const ERROR_INVALID_PRIMARY_GROUP : i32 = 1308;
pub const ERROR_NO_IMPERSONATION_TOKEN : i32 = 1309;
pub const ERROR_CANT_DISABLE_MANDATORY : i32 = 1310;
pub const ERROR_NO_LOGON_SERVERS : i32 = 1311;
pub const ERROR_NO_SUCH_LOGON_SESSION : i32 = 1312;
pub const ERROR_NO_SUCH_PRIVILEGE : i32 = 1313;
pub const ERROR_PRIVILEGE_NOT_HELD : i32 = 1314;
pub const ERROR_INVALID_ACCOUNT_NAME : i32 = 1315;
pub const ERROR_USER_EXISTS : i32 = 1316;
pub const ERROR_NO_SUCH_USER : i32 = 1317;
pub const ERROR_GROUP_EXISTS : i32 = 1318;
pub const ERROR_NO_SUCH_GROUP : i32 = 1319;
pub const ERROR_MEMBER_IN_GROUP : i32 = 1320;
pub const ERROR_MEMBER_NOT_IN_GROUP : i32 = 1321;
pub const ERROR_LAST_ADMIN : i32 = 1322;
pub const ERROR_WRONG_PASSWORD : i32 = 1323;
pub const ERROR_ILL_FORMED_PASSWORD : i32 = 1324;
pub const ERROR_PASSWORD_RESTRICTION : i32 = 1325;
pub const ERROR_LOGON_FAILURE : i32 = 1326;
pub const ERROR_ACCOUNT_RESTRICTION : i32 = 1327;
pub const ERROR_INVALID_LOGON_HOURS : i32 = 1328;
pub const ERROR_INVALID_WORKSTATION : i32 = 1329;
pub const ERROR_PASSWORD_EXPIRED : i32 = 1330;
pub const ERROR_ACCOUNT_DISABLED : i32 = 1331;
pub const ERROR_NONE_MAPPED : i32 = 1332;
pub const ERROR_TOO_MANY_LUIDS_REQUESTED : i32 = 1333;
pub const ERROR_LUIDS_EXHAUSTED : i32 = 1334;
pub const ERROR_INVALID_SUB_AUTHORITY : i32 = 1335;
pub const ERROR_INVALID_ACL : i32 = 1336;
pub const ERROR_INVALID_SID : i32 = 1337;
pub const ERROR_INVALID_SECURITY_DESCR : i32 = 1338;
pub const ERROR_BAD_INHERITANCE_ACL : i32 = 1340;
pub const ERROR_SERVER_DISABLED : i32 = 1341;
pub const ERROR_SERVER_NOT_DISABLED : i32 = 1342;
pub const ERROR_INVALID_ID_AUTHORITY : i32 = 1343;
pub const ERROR_ALLOTTED_SPACE_EXCEEDED : i32 = 1344;
pub const ERROR_INVALID_GROUP_ATTRIBUTES : i32 = 1345;
pub const ERROR_BAD_IMPERSONATION_LEVEL : i32 = 1346;
pub const ERROR_CANT_OPEN_ANONYMOUS : i32 = 1347;
pub const ERROR_BAD_VALIDATION_CLASS : i32 = 1348;
pub const ERROR_BAD_TOKEN_TYPE : i32 = 1349;
pub const ERROR_NO_SECURITY_ON_OBJECT : i32 = 1350;
pub const ERROR_CANT_ACCESS_DOMAIN_INFO : i32 = 1351;
pub const ERROR_INVALID_SERVER_STATE : i32 = 1352;
pub const ERROR_INVALID_DOMAIN_STATE : i32 = 1353;
pub const ERROR_INVALID_DOMAIN_ROLE : i32 = 1354;
pub const ERROR_NO_SUCH_DOMAIN : i32 = 1355;
pub const ERROR_DOMAIN_EXISTS : i32 = 1356;
pub const ERROR_DOMAIN_LIMIT_EXCEEDED : i32 = 1357;
pub const ERROR_INTERNAL_DB_CORRUPTION : i32 = 1358;
pub const ERROR_INTERNAL_ERROR : i32 = 1359;
pub const ERROR_GENERIC_NOT_MAPPED : i32 = 1360;
pub const ERROR_BAD_DESCRIPTOR_FORMAT : i32 = 1361;
pub const ERROR_NOT_LOGON_PROCESS : i32 = 1362;
pub const ERROR_LOGON_SESSION_EXISTS : i32 = 1363;
pub const ERROR_NO_SUCH_PACKAGE : i32 = 1364;
pub const ERROR_BAD_LOGON_SESSION_STATE : i32 = 1365;
pub const ERROR_LOGON_SESSION_COLLISION : i32 = 1366;
pub const ERROR_INVALID_LOGON_TYPE : i32 = 1367;
pub const ERROR_CANNOT_IMPERSONATE : i32 = 1368;
pub const ERROR_RXACT_INVALID_STATE : i32 = 1369;
pub const ERROR_RXACT_COMMIT_FAILURE : i32 = 1370;
pub const ERROR_SPECIAL_ACCOUNT : i32 = 1371;
pub const ERROR_SPECIAL_GROUP : i32 = 1372;
pub const ERROR_SPECIAL_USER : i32 = 1373;
pub const ERROR_MEMBERS_PRIMARY_GROUP : i32 = 1374;
pub const ERROR_TOKEN_ALREADY_IN_USE : i32 = 1375;
pub const ERROR_NO_SUCH_ALIAS : i32 = 1376;
pub const ERROR_MEMBER_NOT_IN_ALIAS : i32 = 1377;
pub const ERROR_MEMBER_IN_ALIAS : i32 = 1378;
pub const ERROR_ALIAS_EXISTS : i32 = 1379;
pub const ERROR_LOGON_NOT_GRANTED : i32 = 1380;
pub const ERROR_TOO_MANY_SECRETS : i32 = 1381;
pub const ERROR_SECRET_TOO_LONG : i32 = 1382;
pub const ERROR_INTERNAL_DB_ERROR : i32 = 1383;
pub const ERROR_TOO_MANY_CONTEXT_IDS : i32 = 1384;
pub const ERROR_LOGON_TYPE_NOT_GRANTED : i32 = 1385;
pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED : i32 = 1386;
pub const ERROR_NO_SUCH_MEMBER : i32 = 1387;
pub const ERROR_INVALID_MEMBER : i32 = 1388;
pub const ERROR_TOO_MANY_SIDS : i32 = 1389;
pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED : i32 = 1390;
pub const ERROR_NO_INHERITANCE : i32 = 1391;
pub const ERROR_FILE_CORRUPT : i32 = 1392;
pub const ERROR_DISK_CORRUPT : i32 = 1393;
pub const ERROR_NO_USER_SESSION_KEY : i32 = 1394;
pub const ERROR_LICENSE_QUOTA_EXCEEDED : i32 = 1395;
pub const ERROR_WRONG_TARGET_NAME : i32 = 1396;
pub const ERROR_MUTUAL_AUTH_FAILED : i32 = 1397;
pub const ERROR_TIME_SKEW : i32 = 1398;
pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED : i32 = 1399;
pub const ERROR_INVALID_WINDOW_HANDLE : i32 = 1400;
pub const ERROR_INVALID_MENU_HANDLE : i32 = 1401;
pub const ERROR_INVALID_CURSOR_HANDLE : i32 = 1402;
pub const ERROR_INVALID_ACCEL_HANDLE : i32 = 1403;
pub const ERROR_INVALID_HOOK_HANDLE : i32 = 1404;
pub const ERROR_INVALID_DWP_HANDLE : i32 = 1405;
pub const ERROR_TLW_WITH_WSCHILD : i32 = 1406;
pub const ERROR_CANNOT_FIND_WND_CLASS : i32 = 1407;
pub const ERROR_WINDOW_OF_OTHER_THREAD : i32 = 1408;
pub const ERROR_HOTKEY_ALREADY_REGISTERED : i32 = 1409;
pub const ERROR_CLASS_ALREADY_EXISTS : i32 = 1410;
pub const ERROR_CLASS_DOES_NOT_EXIST : i32 = 1411;
pub const ERROR_CLASS_HAS_WINDOWS : i32 = 1412;
pub const ERROR_INVALID_INDEX : i32 = 1413;
pub const ERROR_INVALID_ICON_HANDLE : i32 = 1414;
pub const ERROR_PRIVATE_DIALOG_INDEX : i32 = 1415;
pub const ERROR_LISTBOX_ID_NOT_FOUND : i32 = 1416;
pub const ERROR_NO_WILDCARD_CHARACTERS : i32 = 1417;
pub const ERROR_CLIPBOARD_NOT_OPEN : i32 = 1418;
pub const ERROR_HOTKEY_NOT_REGISTERED : i32 = 1419;
pub const ERROR_WINDOW_NOT_DIALOG : i32 = 1420;
pub const ERROR_CONTROL_ID_NOT_FOUND : i32 = 1421;
pub const ERROR_INVALID_COMBOBOX_MESSAGE : i32 = 1422;
pub const ERROR_WINDOW_NOT_COMBOBOX : i32 = 1423;
pub const ERROR_INVALID_EDIT_HEIGHT : i32 = 1424;
pub const ERROR_DC_NOT_FOUND : i32 = 1425;
pub const ERROR_INVALID_HOOK_FILTER : i32 = 1426;
pub const ERROR_INVALID_FILTER_PROC : i32 = 1427;
pub const ERROR_HOOK_NEEDS_HMOD : i32 = 1428;
pub const ERROR_GLOBAL_ONLY_HOOK : i32 = 1429;
pub const ERROR_JOURNAL_HOOK_SET : i32 = 1430;
pub const ERROR_HOOK_NOT_INSTALLED : i32 = 1431;
pub const ERROR_INVALID_LB_MESSAGE : i32 = 1432;
pub const ERROR_SETCOUNT_ON_BAD_LB : i32 = 1433;
pub const ERROR_LB_WITHOUT_TABSTOPS : i32 = 1434;
pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD : i32 = 1435;
pub const ERROR_CHILD_WINDOW_MENU : i32 = 1436;
pub const ERROR_NO_SYSTEM_MENU : i32 = 1437;
pub const ERROR_INVALID_MSGBOX_STYLE : i32 = 1438;
pub const ERROR_INVALID_SPI_VALUE : i32 = 1439;
pub const ERROR_SCREEN_ALREADY_LOCKED : i32 = 1440;
pub const ERROR_HWNDS_HAVE_DIFF_PARENT : i32 = 1441;
pub const ERROR_NOT_CHILD_WINDOW : i32 = 1442;
pub const ERROR_INVALID_GW_COMMAND : i32 = 1443;
pub const ERROR_INVALID_THREAD_ID : i32 = 1444;
pub const ERROR_NON_MDICHILD_WINDOW : i32 = 1445;
pub const ERROR_POPUP_ALREADY_ACTIVE : i32 = 1446;
pub const ERROR_NO_SCROLLBARS : i32 = 1447;
pub const ERROR_INVALID_SCROLLBAR_RANGE : i32 = 1448;
pub const ERROR_INVALID_SHOWWIN_COMMAND : i32 = 1449;
pub const ERROR_NO_SYSTEM_RESOURCES : i32 = 1450;
pub const ERROR_NONPAGED_SYSTEM_RESOURCES : i32 = 1451;
pub const ERROR_PAGED_SYSTEM_RESOURCES : i32 = 1452;
pub const ERROR_WORKING_SET_QUOTA : i32 = 1453;
pub const ERROR_PAGEFILE_QUOTA : i32 = 1454;
pub const ERROR_COMMITMENT_LIMIT : i32 = 1455;
pub const ERROR_MENU_ITEM_NOT_FOUND : i32 = 1456;
pub const ERROR_INVALID_KEYBOARD_HANDLE : i32 = 1457;
pub const ERROR_HOOK_TYPE_NOT_ALLOWED : i32 = 1458;
pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION : i32 = 1459;
pub const ERROR_TIMEOUT : i32 = 1460;
pub const ERROR_INVALID_MONITOR_HANDLE : i32 = 1461;
pub const ERROR_INCORRECT_SIZE : i32 = 1462;
pub const ERROR_SYMLINK_CLASS_DISABLED : i32 = 1463;
pub const ERROR_SYMLINK_NOT_SUPPORTED : i32 = 1464;
pub const ERROR_XML_PARSE_ERROR : i32 = 1465;
pub const ERROR_XMLDSIG_ERROR : i32 = 1466;
pub const ERROR_RESTART_APPLICATION : i32 = 1467;
pub const ERROR_WRONG_COMPARTMENT : i32 = 1468;
pub const ERROR_AUTHIP_FAILURE : i32 = 1469;
pub const ERROR_NO_NVRAM_RESOURCES : i32 = 1470;
pub const ERROR_NOT_GUI_PROCESS : i32 = 1471;
pub const ERROR_EVENTLOG_FILE_CORRUPT : i32 = 1500;
pub const ERROR_EVENTLOG_CANT_START : i32 = 1501;
pub const ERROR_LOG_FILE_FULL : i32 = 1502;
pub const ERROR_EVENTLOG_FILE_CHANGED : i32 = 1503;
pub const ERROR_CONTAINER_ASSIGNED : i32 = 1504;
pub const ERROR_JOB_NO_CONTAINER : i32 = 1505;
pub const ERROR_INVALID_TASK_NAME : i32 = 1550;
pub const ERROR_INVALID_TASK_INDEX : i32 = 1551;
pub const ERROR_THREAD_ALREADY_IN_TASK : i32 = 1552;
pub const ERROR_INSTALL_SERVICE_FAILURE : i32 = 1601;
pub const ERROR_INSTALL_USEREXIT : i32 = 1602;
pub const ERROR_INSTALL_FAILURE : i32 = 1603;
pub const ERROR_INSTALL_SUSPEND : i32 = 1604;
pub const ERROR_UNKNOWN_PRODUCT : i32 = 1605;
pub const ERROR_UNKNOWN_FEATURE : i32 = 1606;
pub const ERROR_UNKNOWN_COMPONENT : i32 = 1607;
pub const ERROR_UNKNOWN_PROPERTY : i32 = 1608;
pub const ERROR_INVALID_HANDLE_STATE : i32 = 1609;
pub const ERROR_BAD_CONFIGURATION : i32 = 1610;
pub const ERROR_INDEX_ABSENT : i32 = 1611;
pub const ERROR_INSTALL_SOURCE_ABSENT : i32 = 1612;
pub const ERROR_INSTALL_PACKAGE_VERSION : i32 = 1613;
pub const ERROR_PRODUCT_UNINSTALLED : i32 = 1614;
pub const ERROR_BAD_QUERY_SYNTAX : i32 = 1615;
pub const ERROR_INVALID_FIELD : i32 = 1616;
pub const ERROR_DEVICE_REMOVED : i32 = 1617;
pub const ERROR_INSTALL_ALREADY_RUNNING : i32 = 1618;
pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED : i32 = 1619;
pub const ERROR_INSTALL_PACKAGE_INVALID : i32 = 1620;
pub const ERROR_INSTALL_UI_FAILURE : i32 = 1621;
pub const ERROR_INSTALL_LOG_FAILURE : i32 = 1622;
pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED : i32 = 1623;
pub const ERROR_INSTALL_TRANSFORM_FAILURE : i32 = 1624;
pub const ERROR_INSTALL_PACKAGE_REJECTED : i32 = 1625;
pub const ERROR_FUNCTION_NOT_CALLED : i32 = 1626;
pub const ERROR_FUNCTION_FAILED : i32 = 1627;
pub const ERROR_INVALID_TABLE : i32 = 1628;
pub const ERROR_DATATYPE_MISMATCH : i32 = 1629;
pub const ERROR_UNSUPPORTED_TYPE : i32 = 1630;
pub const ERROR_CREATE_FAILED : i32 = 1631;
pub const ERROR_INSTALL_TEMP_UNWRITABLE : i32 = 1632;
pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED : i32 = 1633;
pub const ERROR_INSTALL_NOTUSED : i32 = 1634;
pub const ERROR_PATCH_PACKAGE_OPEN_FAILED : i32 = 1635;
pub const ERROR_PATCH_PACKAGE_INVALID : i32 = 1636;
pub const ERROR_PATCH_PACKAGE_UNSUPPORTED : i32 = 1637;
pub const ERROR_PRODUCT_VERSION : i32 = 1638;
pub const ERROR_INVALID_COMMAND_LINE : i32 = 1639;
pub const ERROR_INSTALL_REMOTE_DISALLOWED : i32 = 1640;
pub const ERROR_SUCCESS_REBOOT_INITIATED : i32 = 1641;
pub const ERROR_PATCH_TARGET_NOT_FOUND : i32 = 1642;
pub const ERROR_PATCH_PACKAGE_REJECTED : i32 = 1643;
pub const ERROR_INSTALL_TRANSFORM_REJECTED : i32 = 1644;
pub const ERROR_INSTALL_REMOTE_PROHIBITED : i32 = 1645;
pub const ERROR_PATCH_REMOVAL_UNSUPPORTED : i32 = 1646;
pub const ERROR_UNKNOWN_PATCH : i32 = 1647;
pub const ERROR_PATCH_NO_SEQUENCE : i32 = 1648;
pub const ERROR_PATCH_REMOVAL_DISALLOWED : i32 = 1649;
pub const ERROR_INVALID_PATCH_XML : i32 = 1650;
pub const ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT : i32 = 1651;
pub const ERROR_INSTALL_SERVICE_SAFEBOOT : i32 = 1652;
pub const ERROR_FAIL_FAST_EXCEPTION : i32 = 1653;
pub const ERROR_INSTALL_REJECTED : i32 = 1654;
pub const ERROR_DYNAMIC_CODE_BLOCKED : i32 = 1655;
pub const ERROR_NOT_SAME_OBJECT : i32 = 1656;
pub const ERROR_STRICT_CFG_VIOLATION : i32 = 1657;
pub const ERROR_SET_CONTEXT_DENIED : i32 = 1660;
pub const ERROR_CROSS_PARTITION_VIOLATION : i32 = 1661;
pub const ERROR_RETURN_ADDRESS_HIJACK_ATTEMPT : i32 = 1662;
pub const RPC_S_INVALID_STRING_BINDING : i32 = 1700;
pub const RPC_S_WRONG_KIND_OF_BINDING : i32 = 1701;
pub const RPC_S_INVALID_BINDING : i32 = 1702;
pub const RPC_S_PROTSEQ_NOT_SUPPORTED : i32 = 1703;
pub const RPC_S_INVALID_RPC_PROTSEQ : i32 = 1704;
pub const RPC_S_INVALID_STRING_UUID : i32 = 1705;
pub const RPC_S_INVALID_ENDPOINT_FORMAT : i32 = 1706;
pub const RPC_S_INVALID_NET_ADDR : i32 = 1707;
pub const RPC_S_NO_ENDPOINT_FOUND : i32 = 1708;
pub const RPC_S_INVALID_TIMEOUT : i32 = 1709;
pub const RPC_S_OBJECT_NOT_FOUND : i32 = 1710;
pub const RPC_S_ALREADY_REGISTERED : i32 = 1711;
pub const RPC_S_TYPE_ALREADY_REGISTERED : i32 = 1712;
pub const RPC_S_ALREADY_LISTENING : i32 = 1713;
pub const RPC_S_NO_PROTSEQS_REGISTERED : i32 = 1714;
pub const RPC_S_NOT_LISTENING : i32 = 1715;
pub const RPC_S_UNKNOWN_MGR_TYPE : i32 = 1716;
pub const RPC_S_UNKNOWN_IF : i32 = 1717;
pub const RPC_S_NO_BINDINGS : i32 = 1718;
pub const RPC_S_NO_PROTSEQS : i32 = 1719;
pub const RPC_S_CANT_CREATE_ENDPOINT : i32 = 1720;
pub const RPC_S_OUT_OF_RESOURCES : i32 = 1721;
pub const RPC_S_SERVER_UNAVAILABLE : i32 = 1722;
pub const RPC_S_SERVER_TOO_BUSY : i32 = 1723;
pub const RPC_S_INVALID_NETWORK_OPTIONS : i32 = 1724;
pub const RPC_S_NO_CALL_ACTIVE : i32 = 1725;
pub const RPC_S_CALL_FAILED : i32 = 1726;
pub const RPC_S_CALL_FAILED_DNE : i32 = 1727;
pub const RPC_S_PROTOCOL_ERROR : i32 = 1728;
pub const RPC_S_PROXY_ACCESS_DENIED : i32 = 1729;
pub const RPC_S_UNSUPPORTED_TRANS_SYN : i32 = 1730;
pub const RPC_S_UNSUPPORTED_TYPE : i32 = 1732;
pub const RPC_S_INVALID_TAG : i32 = 1733;
pub const RPC_S_INVALID_BOUND : i32 = 1734;
pub const RPC_S_NO_ENTRY_NAME : i32 = 1735;
pub const RPC_S_INVALID_NAME_SYNTAX : i32 = 1736;
pub const RPC_S_UNSUPPORTED_NAME_SYNTAX : i32 = 1737;
pub const RPC_S_UUID_NO_ADDRESS : i32 = 1739;
pub const RPC_S_DUPLICATE_ENDPOINT : i32 = 1740;
pub const RPC_S_UNKNOWN_AUTHN_TYPE : i32 = 1741;
pub const RPC_S_MAX_CALLS_TOO_SMALL : i32 = 1742;
pub const RPC_S_STRING_TOO_LONG : i32 = 1743;
pub const RPC_S_PROTSEQ_NOT_FOUND : i32 = 1744;
pub const RPC_S_PROCNUM_OUT_OF_RANGE : i32 = 1745;
pub const RPC_S_BINDING_HAS_NO_AUTH : i32 = 1746;
pub const RPC_S_UNKNOWN_AUTHN_SERVICE : i32 = 1747;
pub const RPC_S_UNKNOWN_AUTHN_LEVEL : i32 = 1748;
pub const RPC_S_INVALID_AUTH_IDENTITY : i32 = 1749;
pub const RPC_S_UNKNOWN_AUTHZ_SERVICE : i32 = 1750;
pub const EPT_S_INVALID_ENTRY : i32 = 1751;
pub const EPT_S_CANT_PERFORM_OP : i32 = 1752;
pub const EPT_S_NOT_REGISTERED : i32 = 1753;
pub const RPC_S_NOTHING_TO_EXPORT : i32 = 1754;
pub const RPC_S_INCOMPLETE_NAME : i32 = 1755;
pub const RPC_S_INVALID_VERS_OPTION : i32 = 1756;
pub const RPC_S_NO_MORE_MEMBERS : i32 = 1757;
pub const RPC_S_NOT_ALL_OBJS_UNEXPORTED : i32 = 1758;
pub const RPC_S_INTERFACE_NOT_FOUND : i32 = 1759;
pub const RPC_S_ENTRY_ALREADY_EXISTS : i32 = 1760;
pub const RPC_S_ENTRY_NOT_FOUND : i32 = 1761;
pub const RPC_S_NAME_SERVICE_UNAVAILABLE : i32 = 1762;
pub const RPC_S_INVALID_NAF_ID : i32 = 1763;
pub const RPC_S_CANNOT_SUPPORT : i32 = 1764;
pub const RPC_S_NO_CONTEXT_AVAILABLE : i32 = 1765;
pub const RPC_S_INTERNAL_ERROR : i32 = 1766;
pub const RPC_S_ZERO_DIVIDE : i32 = 1767;
pub const RPC_S_ADDRESS_ERROR : i32 = 1768;
pub const RPC_S_FP_DIV_ZERO : i32 = 1769;
pub const RPC_S_FP_UNDERFLOW : i32 = 1770;
pub const RPC_S_FP_OVERFLOW : i32 = 1771;
pub const RPC_X_NO_MORE_ENTRIES : i32 = 1772;
pub const RPC_X_SS_CHAR_TRANS_OPEN_FAIL : i32 = 1773;
pub const RPC_X_SS_CHAR_TRANS_SHORT_FILE : i32 = 1774;
pub const RPC_X_SS_IN_NULL_CONTEXT : i32 = 1775;
pub const RPC_X_SS_CONTEXT_DAMAGED : i32 = 1777;
pub const RPC_X_SS_HANDLES_MISMATCH : i32 = 1778;
pub const RPC_X_SS_CANNOT_GET_CALL_HANDLE : i32 = 1779;
pub const RPC_X_NULL_REF_POINTER : i32 = 1780;
pub const RPC_X_ENUM_VALUE_OUT_OF_RANGE : i32 = 1781;
pub const RPC_X_BYTE_COUNT_TOO_SMALL : i32 = 1782;
pub const RPC_X_BAD_STUB_DATA : i32 = 1783;
pub const ERROR_INVALID_USER_BUFFER : i32 = 1784;
pub const ERROR_UNRECOGNIZED_MEDIA : i32 = 1785;
pub const ERROR_NO_TRUST_LSA_SECRET : i32 = 1786;
pub const ERROR_NO_TRUST_SAM_ACCOUNT : i32 = 1787;
pub const ERROR_TRUSTED_DOMAIN_FAILURE : i32 = 1788;
pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE : i32 = 1789;
pub const ERROR_TRUST_FAILURE : i32 = 1790;
pub const RPC_S_CALL_IN_PROGRESS : i32 = 1791;
pub const ERROR_NETLOGON_NOT_STARTED : i32 = 1792;
pub const ERROR_ACCOUNT_EXPIRED : i32 = 1793;
pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES : i32 = 1794;
pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED : i32 = 1795;
pub const ERROR_UNKNOWN_PORT : i32 = 1796;
pub const ERROR_UNKNOWN_PRINTER_DRIVER : i32 = 1797;
pub const ERROR_UNKNOWN_PRINTPROCESSOR : i32 = 1798;
pub const ERROR_INVALID_SEPARATOR_FILE : i32 = 1799;
pub const ERROR_INVALID_PRIORITY : i32 = 1800;
pub const ERROR_INVALID_PRINTER_NAME : i32 = 1801;
pub const ERROR_PRINTER_ALREADY_EXISTS : i32 = 1802;
pub const ERROR_INVALID_PRINTER_COMMAND : i32 = 1803;
pub const ERROR_INVALID_DATATYPE : i32 = 1804;
pub const ERROR_INVALID_ENVIRONMENT : i32 = 1805;
pub const RPC_S_NO_MORE_BINDINGS : i32 = 1806;
pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT : i32 = 1807;
pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT : i32 = 1808;
pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT : i32 = 1809;
pub const ERROR_DOMAIN_TRUST_INCONSISTENT : i32 = 1810;
pub const ERROR_SERVER_HAS_OPEN_HANDLES : i32 = 1811;
pub const ERROR_RESOURCE_DATA_NOT_FOUND : i32 = 1812;
pub const ERROR_RESOURCE_TYPE_NOT_FOUND : i32 = 1813;
pub const ERROR_RESOURCE_NAME_NOT_FOUND : i32 = 1814;
pub const ERROR_RESOURCE_LANG_NOT_FOUND : i32 = 1815;
pub const ERROR_NOT_ENOUGH_QUOTA : i32 = 1816;
pub const RPC_S_NO_INTERFACES : i32 = 1817;
pub const RPC_S_CALL_CANCELLED : i32 = 1818;
pub const RPC_S_BINDING_INCOMPLETE : i32 = 1819;
pub const RPC_S_COMM_FAILURE : i32 = 1820;
pub const RPC_S_UNSUPPORTED_AUTHN_LEVEL : i32 = 1821;
pub const RPC_S_NO_PRINC_NAME : i32 = 1822;
pub const RPC_S_NOT_RPC_ERROR : i32 = 1823;
pub const RPC_S_UUID_LOCAL_ONLY : i32 = 1824;
pub const RPC_S_SEC_PKG_ERROR : i32 = 1825;
pub const RPC_S_NOT_CANCELLED : i32 = 1826;
pub const RPC_X_INVALID_ES_ACTION : i32 = 1827;
pub const RPC_X_WRONG_ES_VERSION : i32 = 1828;
pub const RPC_X_WRONG_STUB_VERSION : i32 = 1829;
pub const RPC_X_INVALID_PIPE_OBJECT : i32 = 1830;
pub const RPC_X_WRONG_PIPE_ORDER : i32 = 1831;
pub const RPC_X_WRONG_PIPE_VERSION : i32 = 1832;
pub const RPC_S_COOKIE_AUTH_FAILED : i32 = 1833;
pub const RPC_S_DO_NOT_DISTURB : i32 = 1834;
pub const RPC_S_SYSTEM_HANDLE_COUNT_EXCEEDED : i32 = 1835;
pub const RPC_S_SYSTEM_HANDLE_TYPE_MISMATCH : i32 = 1836;
pub const RPC_S_GROUP_MEMBER_NOT_FOUND : i32 = 1898;
pub const EPT_S_CANT_CREATE : i32 = 1899;
pub const RPC_S_INVALID_OBJECT : i32 = 1900;
pub const ERROR_INVALID_TIME : i32 = 1901;
pub const ERROR_INVALID_FORM_NAME : i32 = 1902;
pub const ERROR_INVALID_FORM_SIZE : i32 = 1903;
pub const ERROR_ALREADY_WAITING : i32 = 1904;
pub const ERROR_PRINTER_DELETED : i32 = 1905;
pub const ERROR_INVALID_PRINTER_STATE : i32 = 1906;
pub const ERROR_PASSWORD_MUST_CHANGE : i32 = 1907;
pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND : i32 = 1908;
pub const ERROR_ACCOUNT_LOCKED_OUT : i32 = 1909;
pub const OR_INVALID_OXID : i32 = 1910;
pub const OR_INVALID_OID : i32 = 1911;
pub const OR_INVALID_SET : i32 = 1912;
pub const RPC_S_SEND_INCOMPLETE : i32 = 1913;
pub const RPC_S_INVALID_ASYNC_HANDLE : i32 = 1914;
pub const RPC_S_INVALID_ASYNC_CALL : i32 = 1915;
pub const RPC_X_PIPE_CLOSED : i32 = 1916;
pub const RPC_X_PIPE_DISCIPLINE_ERROR : i32 = 1917;
pub const RPC_X_PIPE_EMPTY : i32 = 1918;
pub const ERROR_NO_SITENAME : i32 = 1919;
pub const ERROR_CANT_ACCESS_FILE : i32 = 1920;
pub const ERROR_CANT_RESOLVE_FILENAME : i32 = 1921;
pub const RPC_S_ENTRY_TYPE_MISMATCH : i32 = 1922;
pub const RPC_S_NOT_ALL_OBJS_EXPORTED : i32 = 1923;
pub const RPC_S_INTERFACE_NOT_EXPORTED : i32 = 1924;
pub const RPC_S_PROFILE_NOT_ADDED : i32 = 1925;
pub const RPC_S_PRF_ELT_NOT_ADDED : i32 = 1926;
pub const RPC_S_PRF_ELT_NOT_REMOVED : i32 = 1927;
pub const RPC_S_GRP_ELT_NOT_ADDED : i32 = 1928;
pub const RPC_S_GRP_ELT_NOT_REMOVED : i32 = 1929;
pub const ERROR_KM_DRIVER_BLOCKED : i32 = 1930;
pub const ERROR_CONTEXT_EXPIRED : i32 = 1931;
pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED : i32 = 1932;
pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED : i32 = 1933;
pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED : i32 = 1934;
pub const ERROR_AUTHENTICATION_FIREWALL_FAILED : i32 = 1935;
pub const ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED : i32 = 1936;
pub const ERROR_NTLM_BLOCKED : i32 = 1937;
pub const ERROR_PASSWORD_CHANGE_REQUIRED : i32 = 1938;
pub const ERROR_LOST_MODE_LOGON_RESTRICTION : i32 = 1939;
pub const ERROR_INVALID_PIXEL_FORMAT : i32 = 2000;
pub const ERROR_BAD_DRIVER : i32 = 2001;
pub const ERROR_INVALID_WINDOW_STYLE : i32 = 2002;
pub const ERROR_METAFILE_NOT_SUPPORTED : i32 = 2003;
pub const ERROR_TRANSFORM_NOT_SUPPORTED : i32 = 2004;
pub const ERROR_CLIPPING_NOT_SUPPORTED : i32 = 2005;
pub const ERROR_INVALID_CMM : i32 = 2010;
pub const ERROR_INVALID_PROFILE : i32 = 2011;
pub const ERROR_TAG_NOT_FOUND : i32 = 2012;
pub const ERROR_TAG_NOT_PRESENT : i32 = 2013;
pub const ERROR_DUPLICATE_TAG : i32 = 2014;
pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE : i32 = 2015;
pub const ERROR_PROFILE_NOT_FOUND : i32 = 2016;
pub const ERROR_INVALID_COLORSPACE : i32 = 2017;
pub const ERROR_ICM_NOT_ENABLED : i32 = 2018;
pub const ERROR_DELETING_ICM_XFORM : i32 = 2019;
pub const ERROR_INVALID_TRANSFORM : i32 = 2020;
pub const ERROR_COLORSPACE_MISMATCH : i32 = 2021;
pub const ERROR_INVALID_COLORINDEX : i32 = 2022;
pub const ERROR_PROFILE_DOES_NOT_MATCH_DEVICE : i32 = 2023;
pub const ERROR_CONNECTED_OTHER_PASSWORD : i32 = 2108;
pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT : i32 = 2109;
pub const ERROR_BAD_USERNAME : i32 = 2202;
pub const ERROR_NOT_CONNECTED : i32 = 2250;
pub const ERROR_OPEN_FILES : i32 = 2401;
pub const ERROR_ACTIVE_CONNECTIONS : i32 = 2402;
pub const ERROR_DEVICE_IN_USE : i32 = 2404;
pub const ERROR_UNKNOWN_PRINT_MONITOR : i32 = 3000;
pub const ERROR_PRINTER_DRIVER_IN_USE : i32 = 3001;
pub const ERROR_SPOOL_FILE_NOT_FOUND : i32 = 3002;
pub const ERROR_SPL_NO_STARTDOC : i32 = 3003;
pub const ERROR_SPL_NO_ADDJOB : i32 = 3004;
pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED : i32 = 3005;
pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED : i32 = 3006;
pub const ERROR_INVALID_PRINT_MONITOR : i32 = 3007;
pub const ERROR_PRINT_MONITOR_IN_USE : i32 = 3008;
pub const ERROR_PRINTER_HAS_JOBS_QUEUED : i32 = 3009;
pub const ERROR_SUCCESS_REBOOT_REQUIRED : i32 = 3010;
pub const ERROR_SUCCESS_RESTART_REQUIRED : i32 = 3011;
pub const ERROR_PRINTER_NOT_FOUND : i32 = 3012;
pub const ERROR_PRINTER_DRIVER_WARNED : i32 = 3013;
pub const ERROR_PRINTER_DRIVER_BLOCKED : i32 = 3014;
pub const ERROR_PRINTER_DRIVER_PACKAGE_IN_USE : i32 = 3015;
pub const ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND : i32 = 3016;
pub const ERROR_FAIL_REBOOT_REQUIRED : i32 = 3017;
pub const ERROR_FAIL_REBOOT_INITIATED : i32 = 3018;
pub const ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED : i32 = 3019;
pub const ERROR_PRINT_JOB_RESTART_REQUIRED : i32 = 3020;
pub const ERROR_INVALID_PRINTER_DRIVER_MANIFEST : i32 = 3021;
pub const ERROR_PRINTER_NOT_SHAREABLE : i32 = 3022;
pub const ERROR_REQUEST_PAUSED : i32 = 3050;
pub const ERROR_APPEXEC_CONDITION_NOT_SATISFIED : i32 = 3060;
pub const ERROR_APPEXEC_HANDLE_INVALIDATED : i32 = 3061;
pub const ERROR_APPEXEC_INVALID_HOST_GENERATION : i32 = 3062;
pub const ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION : i32 = 3063;
pub const ERROR_APPEXEC_INVALID_HOST_STATE : i32 = 3064;
pub const ERROR_APPEXEC_NO_DONOR : i32 = 3065;
pub const ERROR_APPEXEC_HOST_ID_MISMATCH : i32 = 3066;
pub const ERROR_APPEXEC_UNKNOWN_USER : i32 = 3067;
pub const ERROR_IO_REISSUE_AS_CACHED : i32 = 3950;
pub const ERROR_WINS_INTERNAL : i32 = 4000;
pub const ERROR_CAN_NOT_DEL_LOCAL_WINS : i32 = 4001;
pub const ERROR_STATIC_INIT : i32 = 4002;
pub const ERROR_INC_BACKUP : i32 = 4003;
pub const ERROR_FULL_BACKUP : i32 = 4004;
pub const ERROR_REC_NON_EXISTENT : i32 = 4005;
pub const ERROR_RPL_NOT_ALLOWED : i32 = 4006;
pub const PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED : i32 = 4050;
pub const PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO : i32 = 4051;
pub const PEERDIST_ERROR_MISSING_DATA : i32 = 4052;
pub const PEERDIST_ERROR_NO_MORE : i32 = 4053;
pub const PEERDIST_ERROR_NOT_INITIALIZED : i32 = 4054;
pub const PEERDIST_ERROR_ALREADY_INITIALIZED : i32 = 4055;
pub const PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS : i32 = 4056;
pub const PEERDIST_ERROR_INVALIDATED : i32 = 4057;
pub const PEERDIST_ERROR_ALREADY_EXISTS : i32 = 4058;
pub const PEERDIST_ERROR_OPERATION_NOTFOUND : i32 = 4059;
pub const PEERDIST_ERROR_ALREADY_COMPLETED : i32 = 4060;
pub const PEERDIST_ERROR_OUT_OF_BOUNDS : i32 = 4061;
pub const PEERDIST_ERROR_VERSION_UNSUPPORTED : i32 = 4062;
pub const PEERDIST_ERROR_INVALID_CONFIGURATION : i32 = 4063;
pub const PEERDIST_ERROR_NOT_LICENSED : i32 = 4064;
pub const PEERDIST_ERROR_SERVICE_UNAVAILABLE : i32 = 4065;
pub const PEERDIST_ERROR_TRUST_FAILURE : i32 = 4066;
pub const ERROR_DHCP_ADDRESS_CONFLICT : i32 = 4100;
pub const ERROR_WMI_GUID_NOT_FOUND : i32 = 4200;
pub const ERROR_WMI_INSTANCE_NOT_FOUND : i32 = 4201;
pub const ERROR_WMI_ITEMID_NOT_FOUND : i32 = 4202;
pub const ERROR_WMI_TRY_AGAIN : i32 = 4203;
pub const ERROR_WMI_DP_NOT_FOUND : i32 = 4204;
pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF : i32 = 4205;
pub const ERROR_WMI_ALREADY_ENABLED : i32 = 4206;
pub const ERROR_WMI_GUID_DISCONNECTED : i32 = 4207;
pub const ERROR_WMI_SERVER_UNAVAILABLE : i32 = 4208;
pub const ERROR_WMI_DP_FAILED : i32 = 4209;
pub const ERROR_WMI_INVALID_MOF : i32 = 4210;
pub const ERROR_WMI_INVALID_REGINFO : i32 = 4211;
pub const ERROR_WMI_ALREADY_DISABLED : i32 = 4212;
pub const ERROR_WMI_READ_ONLY : i32 = 4213;
pub const ERROR_WMI_SET_FAILURE : i32 = 4214;
pub const ERROR_NOT_APPCONTAINER : i32 = 4250;
pub const ERROR_APPCONTAINER_REQUIRED : i32 = 4251;
pub const ERROR_NOT_SUPPORTED_IN_APPCONTAINER : i32 = 4252;
pub const ERROR_INVALID_PACKAGE_SID_LENGTH : i32 = 4253;
pub const ERROR_INVALID_MEDIA : i32 = 4300;
pub const ERROR_INVALID_LIBRARY : i32 = 4301;
pub const ERROR_INVALID_MEDIA_POOL : i32 = 4302;
pub const ERROR_DRIVE_MEDIA_MISMATCH : i32 = 4303;
pub const ERROR_MEDIA_OFFLINE : i32 = 4304;
pub const ERROR_LIBRARY_OFFLINE : i32 = 4305;
pub const ERROR_EMPTY : i32 = 4306;
pub const ERROR_NOT_EMPTY : i32 = 4307;
pub const ERROR_MEDIA_UNAVAILABLE : i32 = 4308;
pub const ERROR_RESOURCE_DISABLED : i32 = 4309;
pub const ERROR_INVALID_CLEANER : i32 = 4310;
pub const ERROR_UNABLE_TO_CLEAN : i32 = 4311;
pub const ERROR_OBJECT_NOT_FOUND : i32 = 4312;
pub const ERROR_DATABASE_FAILURE : i32 = 4313;
pub const ERROR_DATABASE_FULL : i32 = 4314;
pub const ERROR_MEDIA_INCOMPATIBLE : i32 = 4315;
pub const ERROR_RESOURCE_NOT_PRESENT : i32 = 4316;
pub const ERROR_INVALID_OPERATION : i32 = 4317;
pub const ERROR_MEDIA_NOT_AVAILABLE : i32 = 4318;
pub const ERROR_DEVICE_NOT_AVAILABLE : i32 = 4319;
pub const ERROR_REQUEST_REFUSED : i32 = 4320;
pub const ERROR_INVALID_DRIVE_OBJECT : i32 = 4321;
pub const ERROR_LIBRARY_FULL : i32 = 4322;
pub const ERROR_MEDIUM_NOT_ACCESSIBLE : i32 = 4323;
pub const ERROR_UNABLE_TO_LOAD_MEDIUM : i32 = 4324;
pub const ERROR_UNABLE_TO_INVENTORY_DRIVE : i32 = 4325;
pub const ERROR_UNABLE_TO_INVENTORY_SLOT : i32 = 4326;
pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT : i32 = 4327;
pub const ERROR_TRANSPORT_FULL : i32 = 4328;
pub const ERROR_CONTROLLING_IEPORT : i32 = 4329;
pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA : i32 = 4330;
pub const ERROR_CLEANER_SLOT_SET : i32 = 4331;
pub const ERROR_CLEANER_SLOT_NOT_SET : i32 = 4332;
pub const ERROR_CLEANER_CARTRIDGE_SPENT : i32 = 4333;
pub const ERROR_UNEXPECTED_OMID : i32 = 4334;
pub const ERROR_CANT_DELETE_LAST_ITEM : i32 = 4335;
pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE : i32 = 4336;
pub const ERROR_VOLUME_CONTAINS_SYS_FILES : i32 = 4337;
pub const ERROR_INDIGENOUS_TYPE : i32 = 4338;
pub const ERROR_NO_SUPPORTING_DRIVES : i32 = 4339;
pub const ERROR_CLEANER_CARTRIDGE_INSTALLED : i32 = 4340;
pub const ERROR_IEPORT_FULL : i32 = 4341;
pub const ERROR_FILE_OFFLINE : i32 = 4350;
pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE : i32 = 4351;
pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR : i32 = 4352;
pub const ERROR_NOT_A_REPARSE_POINT : i32 = 4390;
pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT : i32 = 4391;
pub const ERROR_INVALID_REPARSE_DATA : i32 = 4392;
pub const ERROR_REPARSE_TAG_INVALID : i32 = 4393;
pub const ERROR_REPARSE_TAG_MISMATCH : i32 = 4394;
pub const ERROR_REPARSE_POINT_ENCOUNTERED : i32 = 4395;
pub const ERROR_APP_DATA_NOT_FOUND : i32 = 4400;
pub const ERROR_APP_DATA_EXPIRED : i32 = 4401;
pub const ERROR_APP_DATA_CORRUPT : i32 = 4402;
pub const ERROR_APP_DATA_LIMIT_EXCEEDED : i32 = 4403;
pub const ERROR_APP_DATA_REBOOT_REQUIRED : i32 = 4404;
pub const ERROR_SECUREBOOT_ROLLBACK_DETECTED : i32 = 4420;
pub const ERROR_SECUREBOOT_POLICY_VIOLATION : i32 = 4421;
pub const ERROR_SECUREBOOT_INVALID_POLICY : i32 = 4422;
pub const ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND : i32 = 4423;
pub const ERROR_SECUREBOOT_POLICY_NOT_SIGNED : i32 = 4424;
pub const ERROR_SECUREBOOT_NOT_ENABLED : i32 = 4425;
pub const ERROR_SECUREBOOT_FILE_REPLACED : i32 = 4426;
pub const ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED : i32 = 4427;
pub const ERROR_SECUREBOOT_POLICY_UNKNOWN : i32 = 4428;
pub const ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION : i32 = 4429;
pub const ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH : i32 = 4430;
pub const ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED : i32 = 4431;
pub const ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH : i32 = 4432;
pub const ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING : i32 = 4433;
pub const ERROR_SECUREBOOT_NOT_BASE_POLICY : i32 = 4434;
pub const ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY : i32 = 4435;
pub const ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED : i32 = 4440;
pub const ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED : i32 = 4441;
pub const ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED : i32 = 4442;
pub const ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED : i32 = 4443;
pub const ERROR_ALREADY_HAS_STREAM_ID : i32 = 4444;
pub const ERROR_SMR_GARBAGE_COLLECTION_REQUIRED : i32 = 4445;
pub const ERROR_WOF_WIM_HEADER_CORRUPT : i32 = 4446;
pub const ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT : i32 = 4447;
pub const ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT : i32 = 4448;
pub const ERROR_VOLUME_NOT_SIS_ENABLED : i32 = 4500;
pub const ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED : i32 = 4550;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION : i32 = 4551;
pub const ERROR_SYSTEM_INTEGRITY_INVALID_POLICY : i32 = 4552;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED : i32 = 4553;
pub const ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES : i32 = 4554;
pub const ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED : i32 = 4555;
pub const ERROR_VSM_NOT_INITIALIZED : i32 = 4560;
pub const ERROR_VSM_DMA_PROTECTION_NOT_IN_USE : i32 = 4561;
pub const ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED : i32 = 4570;
pub const ERROR_PLATFORM_MANIFEST_INVALID : i32 = 4571;
pub const ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED : i32 = 4572;
pub const ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED : i32 = 4573;
pub const ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND : i32 = 4574;
pub const ERROR_PLATFORM_MANIFEST_NOT_ACTIVE : i32 = 4575;
pub const ERROR_PLATFORM_MANIFEST_NOT_SIGNED : i32 = 4576;
pub const ERROR_DEPENDENT_RESOURCE_EXISTS : i32 = 5001;
pub const ERROR_DEPENDENCY_NOT_FOUND : i32 = 5002;
pub const ERROR_DEPENDENCY_ALREADY_EXISTS : i32 = 5003;
pub const ERROR_RESOURCE_NOT_ONLINE : i32 = 5004;
pub const ERROR_HOST_NODE_NOT_AVAILABLE : i32 = 5005;
pub const ERROR_RESOURCE_NOT_AVAILABLE : i32 = 5006;
pub const ERROR_RESOURCE_NOT_FOUND : i32 = 5007;
pub const ERROR_SHUTDOWN_CLUSTER : i32 = 5008;
pub const ERROR_CANT_EVICT_ACTIVE_NODE : i32 = 5009;
pub const ERROR_OBJECT_ALREADY_EXISTS : i32 = 5010;
pub const ERROR_OBJECT_IN_LIST : i32 = 5011;
pub const ERROR_GROUP_NOT_AVAILABLE : i32 = 5012;
pub const ERROR_GROUP_NOT_FOUND : i32 = 5013;
pub const ERROR_GROUP_NOT_ONLINE : i32 = 5014;
pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER : i32 = 5015;
pub const ERROR_HOST_NODE_NOT_GROUP_OWNER : i32 = 5016;
pub const ERROR_RESMON_CREATE_FAILED : i32 = 5017;
pub const ERROR_RESMON_ONLINE_FAILED : i32 = 5018;
pub const ERROR_RESOURCE_ONLINE : i32 = 5019;
pub const ERROR_QUORUM_RESOURCE : i32 = 5020;
pub const ERROR_NOT_QUORUM_CAPABLE : i32 = 5021;
pub const ERROR_CLUSTER_SHUTTING_DOWN : i32 = 5022;
pub const ERROR_INVALID_STATE : i32 = 5023;
pub const ERROR_RESOURCE_PROPERTIES_STORED : i32 = 5024;
pub const ERROR_NOT_QUORUM_CLASS : i32 = 5025;
pub const ERROR_CORE_RESOURCE : i32 = 5026;
pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED : i32 = 5027;
pub const ERROR_QUORUMLOG_OPEN_FAILED : i32 = 5028;
pub const ERROR_CLUSTERLOG_CORRUPT : i32 = 5029;
pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE : i32 = 5030;
pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE : i32 = 5031;
pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND : i32 = 5032;
pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE : i32 = 5033;
pub const ERROR_QUORUM_OWNER_ALIVE : i32 = 5034;
pub const ERROR_NETWORK_NOT_AVAILABLE : i32 = 5035;
pub const ERROR_NODE_NOT_AVAILABLE : i32 = 5036;
pub const ERROR_ALL_NODES_NOT_AVAILABLE : i32 = 5037;
pub const ERROR_RESOURCE_FAILED : i32 = 5038;
pub const ERROR_CLUSTER_INVALID_NODE : i32 = 5039;
pub const ERROR_CLUSTER_NODE_EXISTS : i32 = 5040;
pub const ERROR_CLUSTER_JOIN_IN_PROGRESS : i32 = 5041;
pub const ERROR_CLUSTER_NODE_NOT_FOUND : i32 = 5042;
pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND : i32 = 5043;
pub const ERROR_CLUSTER_NETWORK_EXISTS : i32 = 5044;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND : i32 = 5045;
pub const ERROR_CLUSTER_NETINTERFACE_EXISTS : i32 = 5046;
pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND : i32 = 5047;
pub const ERROR_CLUSTER_INVALID_REQUEST : i32 = 5048;
pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER : i32 = 5049;
pub const ERROR_CLUSTER_NODE_DOWN : i32 = 5050;
pub const ERROR_CLUSTER_NODE_UNREACHABLE : i32 = 5051;
pub const ERROR_CLUSTER_NODE_NOT_MEMBER : i32 = 5052;
pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS : i32 = 5053;
pub const ERROR_CLUSTER_INVALID_NETWORK : i32 = 5054;
pub const ERROR_CLUSTER_NODE_UP : i32 = 5056;
pub const ERROR_CLUSTER_IPADDR_IN_USE : i32 = 5057;
pub const ERROR_CLUSTER_NODE_NOT_PAUSED : i32 = 5058;
pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT : i32 = 5059;
pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL : i32 = 5060;
pub const ERROR_CLUSTER_NODE_ALREADY_UP : i32 = 5061;
pub const ERROR_CLUSTER_NODE_ALREADY_DOWN : i32 = 5062;
pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE : i32 = 5063;
pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE : i32 = 5064;
pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER : i32 = 5065;
pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK : i32 = 5066;
pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS : i32 = 5067;
pub const ERROR_INVALID_OPERATION_ON_QUORUM : i32 = 5068;
pub const ERROR_DEPENDENCY_NOT_ALLOWED : i32 = 5069;
pub const ERROR_CLUSTER_NODE_PAUSED : i32 = 5070;
pub const ERROR_NODE_CANT_HOST_RESOURCE : i32 = 5071;
pub const ERROR_CLUSTER_NODE_NOT_READY : i32 = 5072;
pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN : i32 = 5073;
pub const ERROR_CLUSTER_JOIN_ABORTED : i32 = 5074;
pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS : i32 = 5075;
pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED : i32 = 5076;
pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED : i32 = 5077;
pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND : i32 = 5078;
pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED : i32 = 5079;
pub const ERROR_CLUSTER_RESNAME_NOT_FOUND : i32 = 5080;
pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED : i32 = 5081;
pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST : i32 = 5082;
pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH : i32 = 5083;
pub const ERROR_RESMON_INVALID_STATE : i32 = 5084;
pub const ERROR_CLUSTER_GUM_NOT_LOCKER : i32 = 5085;
pub const ERROR_QUORUM_DISK_NOT_FOUND : i32 = 5086;
pub const ERROR_DATABASE_BACKUP_CORRUPT : i32 = 5087;
pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT : i32 = 5088;
pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE : i32 = 5089;
pub const ERROR_NO_ADMIN_ACCESS_POINT : i32 = 5090;
pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE : i32 = 5890;
pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND : i32 = 5891;
pub const ERROR_CLUSTER_MEMBERSHIP_HALT : i32 = 5892;
pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH : i32 = 5893;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP : i32 = 5894;
pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH : i32 = 5895;
pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP : i32 = 5896;
pub const ERROR_CLUSTER_PARAMETER_MISMATCH : i32 = 5897;
pub const ERROR_NODE_CANNOT_BE_CLUSTERED : i32 = 5898;
pub const ERROR_CLUSTER_WRONG_OS_VERSION : i32 = 5899;
pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME : i32 = 5900;
pub const ERROR_CLUSCFG_ALREADY_COMMITTED : i32 = 5901;
pub const ERROR_CLUSCFG_ROLLBACK_FAILED : i32 = 5902;
pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT : i32 = 5903;
pub const ERROR_CLUSTER_OLD_VERSION : i32 = 5904;
pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME : i32 = 5905;
pub const ERROR_CLUSTER_NO_NET_ADAPTERS : i32 = 5906;
pub const ERROR_CLUSTER_POISONED : i32 = 5907;
pub const ERROR_CLUSTER_GROUP_MOVING : i32 = 5908;
pub const ERROR_CLUSTER_RESOURCE_TYPE_BUSY : i32 = 5909;
pub const ERROR_RESOURCE_CALL_TIMED_OUT : i32 = 5910;
pub const ERROR_INVALID_CLUSTER_IPV6_ADDRESS : i32 = 5911;
pub const ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION : i32 = 5912;
pub const ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS : i32 = 5913;
pub const ERROR_CLUSTER_PARTIAL_SEND : i32 = 5914;
pub const ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION : i32 = 5915;
pub const ERROR_CLUSTER_INVALID_STRING_TERMINATION : i32 = 5916;
pub const ERROR_CLUSTER_INVALID_STRING_FORMAT : i32 = 5917;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS : i32 = 5918;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS : i32 = 5919;
pub const ERROR_CLUSTER_NULL_DATA : i32 = 5920;
pub const ERROR_CLUSTER_PARTIAL_READ : i32 = 5921;
pub const ERROR_CLUSTER_PARTIAL_WRITE : i32 = 5922;
pub const ERROR_CLUSTER_CANT_DESERIALIZE_DATA : i32 = 5923;
pub const ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT : i32 = 5924;
pub const ERROR_CLUSTER_NO_QUORUM : i32 = 5925;
pub const ERROR_CLUSTER_INVALID_IPV6_NETWORK : i32 = 5926;
pub const ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK : i32 = 5927;
pub const ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP : i32 = 5928;
pub const ERROR_DEPENDENCY_TREE_TOO_COMPLEX : i32 = 5929;
pub const ERROR_EXCEPTION_IN_RESOURCE_CALL : i32 = 5930;
pub const ERROR_CLUSTER_RHS_FAILED_INITIALIZATION : i32 = 5931;
pub const ERROR_CLUSTER_NOT_INSTALLED : i32 = 5932;
pub const ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE : i32 = 5933;
pub const ERROR_CLUSTER_MAX_NODES_IN_CLUSTER : i32 = 5934;
pub const ERROR_CLUSTER_TOO_MANY_NODES : i32 = 5935;
pub const ERROR_CLUSTER_OBJECT_ALREADY_USED : i32 = 5936;
pub const ERROR_NONCORE_GROUPS_FOUND : i32 = 5937;
pub const ERROR_FILE_SHARE_RESOURCE_CONFLICT : i32 = 5938;
pub const ERROR_CLUSTER_EVICT_INVALID_REQUEST : i32 = 5939;
pub const ERROR_CLUSTER_SINGLETON_RESOURCE : i32 = 5940;
pub const ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE : i32 = 5941;
pub const ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED : i32 = 5942;
pub const ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR : i32 = 5943;
pub const ERROR_CLUSTER_GROUP_BUSY : i32 = 5944;
pub const ERROR_CLUSTER_NOT_SHARED_VOLUME : i32 = 5945;
pub const ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR : i32 = 5946;
pub const ERROR_CLUSTER_SHARED_VOLUMES_IN_USE : i32 = 5947;
pub const ERROR_CLUSTER_USE_SHARED_VOLUMES_API : i32 = 5948;
pub const ERROR_CLUSTER_BACKUP_IN_PROGRESS : i32 = 5949;
pub const ERROR_NON_CSV_PATH : i32 = 5950;
pub const ERROR_CSV_VOLUME_NOT_LOCAL : i32 = 5951;
pub const ERROR_CLUSTER_WATCHDOG_TERMINATING : i32 = 5952;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES : i32 = 5953;
pub const ERROR_CLUSTER_INVALID_NODE_WEIGHT : i32 = 5954;
pub const ERROR_CLUSTER_RESOURCE_VETOED_CALL : i32 = 5955;
pub const ERROR_RESMON_SYSTEM_RESOURCES_LACKING : i32 = 5956;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION : i32 = 5957;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE : i32 = 5958;
pub const ERROR_CLUSTER_GROUP_QUEUED : i32 = 5959;
pub const ERROR_CLUSTER_RESOURCE_LOCKED_STATUS : i32 = 5960;
pub const ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED : i32 = 5961;
pub const ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS : i32 = 5962;
pub const ERROR_CLUSTER_DISK_NOT_CONNECTED : i32 = 5963;
pub const ERROR_DISK_NOT_CSV_CAPABLE : i32 = 5964;
pub const ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE : i32 = 5965;
pub const ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED : i32 = 5966;
pub const ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED : i32 = 5967;
pub const ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES : i32 = 5968;
pub const ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES : i32 = 5969;
pub const ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE : i32 = 5970;
pub const ERROR_CLUSTER_AFFINITY_CONFLICT : i32 = 5971;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE : i32 = 5972;
pub const ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS : i32 = 5973;
pub const ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED : i32 = 5974;
pub const ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED : i32 = 5975;
pub const ERROR_CLUSTER_UPGRADE_IN_PROGRESS : i32 = 5976;
pub const ERROR_CLUSTER_UPGRADE_INCOMPLETE : i32 = 5977;
pub const ERROR_CLUSTER_NODE_IN_GRACE_PERIOD : i32 = 5978;
pub const ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT : i32 = 5979;
pub const ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER : i32 = 5980;
pub const ERROR_CLUSTER_RESOURCE_NOT_MONITORED : i32 = 5981;
pub const ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED : i32 = 5982;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICATED : i32 = 5983;
pub const ERROR_CLUSTER_NODE_ISOLATED : i32 = 5984;
pub const ERROR_CLUSTER_NODE_QUARANTINED : i32 = 5985;
pub const ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED : i32 = 5986;
pub const ERROR_CLUSTER_SPACE_DEGRADED : i32 = 5987;
pub const ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED : i32 = 5988;
pub const ERROR_CLUSTER_CSV_INVALID_HANDLE : i32 = 5989;
pub const ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR : i32 = 5990;
pub const ERROR_GROUPSET_NOT_AVAILABLE : i32 = 5991;
pub const ERROR_GROUPSET_NOT_FOUND : i32 = 5992;
pub const ERROR_GROUPSET_CANT_PROVIDE : i32 = 5993;
pub const ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND : i32 = 5994;
pub const ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY : i32 = 5995;
pub const ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION : i32 = 5996;
pub const ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS : i32 = 5997;
pub const ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME : i32 = 5998;
pub const ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE : i32 = 5999;
pub const ERROR_ENCRYPTION_FAILED : i32 = 6000;
pub const ERROR_DECRYPTION_FAILED : i32 = 6001;
pub const ERROR_FILE_ENCRYPTED : i32 = 6002;
pub const ERROR_NO_RECOVERY_POLICY : i32 = 6003;
pub const ERROR_NO_EFS : i32 = 6004;
pub const ERROR_WRONG_EFS : i32 = 6005;
pub const ERROR_NO_USER_KEYS : i32 = 6006;
pub const ERROR_FILE_NOT_ENCRYPTED : i32 = 6007;
pub const ERROR_NOT_EXPORT_FORMAT : i32 = 6008;
pub const ERROR_FILE_READ_ONLY : i32 = 6009;
pub const ERROR_DIR_EFS_DISALLOWED : i32 = 6010;
pub const ERROR_EFS_SERVER_NOT_TRUSTED : i32 = 6011;
pub const ERROR_BAD_RECOVERY_POLICY : i32 = 6012;
pub const ERROR_EFS_ALG_BLOB_TOO_BIG : i32 = 6013;
pub const ERROR_VOLUME_NOT_SUPPORT_EFS : i32 = 6014;
pub const ERROR_EFS_DISABLED : i32 = 6015;
pub const ERROR_EFS_VERSION_NOT_SUPPORT : i32 = 6016;
pub const ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE : i32 = 6017;
pub const ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER : i32 = 6018;
pub const ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE : i32 = 6019;
pub const ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE : i32 = 6020;
pub const ERROR_CS_ENCRYPTION_FILE_NOT_CSE : i32 = 6021;
pub const ERROR_ENCRYPTION_POLICY_DENIES_OPERATION : i32 = 6022;
pub const ERROR_WIP_ENCRYPTION_FAILED : i32 = 6023;
pub const ERROR_NO_BROWSER_SERVERS_FOUND : i32 = 6118;
pub const SCHED_E_SERVICE_NOT_LOCALSYSTEM : i32 = 6200;
pub const ERROR_CLUSTER_OBJECT_IS_CLUSTER_SET_VM : i32 = 6250;
pub const ERROR_LOG_SECTOR_INVALID : i32 = 6600;
pub const ERROR_LOG_SECTOR_PARITY_INVALID : i32 = 6601;
pub const ERROR_LOG_SECTOR_REMAPPED : i32 = 6602;
pub const ERROR_LOG_BLOCK_INCOMPLETE : i32 = 6603;
pub const ERROR_LOG_INVALID_RANGE : i32 = 6604;
pub const ERROR_LOG_BLOCKS_EXHAUSTED : i32 = 6605;
pub const ERROR_LOG_READ_CONTEXT_INVALID : i32 = 6606;
pub const ERROR_LOG_RESTART_INVALID : i32 = 6607;
pub const ERROR_LOG_BLOCK_VERSION : i32 = 6608;
pub const ERROR_LOG_BLOCK_INVALID : i32 = 6609;
pub const ERROR_LOG_READ_MODE_INVALID : i32 = 6610;
pub const ERROR_LOG_NO_RESTART : i32 = 6611;
pub const ERROR_LOG_METADATA_CORRUPT : i32 = 6612;
pub const ERROR_LOG_METADATA_INVALID : i32 = 6613;
pub const ERROR_LOG_METADATA_INCONSISTENT : i32 = 6614;
pub const ERROR_LOG_RESERVATION_INVALID : i32 = 6615;
pub const ERROR_LOG_CANT_DELETE : i32 = 6616;
pub const ERROR_LOG_CONTAINER_LIMIT_EXCEEDED : i32 = 6617;
pub const ERROR_LOG_START_OF_LOG : i32 = 6618;
pub const ERROR_LOG_POLICY_ALREADY_INSTALLED : i32 = 6619;
pub const ERROR_LOG_POLICY_NOT_INSTALLED : i32 = 6620;
pub const ERROR_LOG_POLICY_INVALID : i32 = 6621;
pub const ERROR_LOG_POLICY_CONFLICT : i32 = 6622;
pub const ERROR_LOG_PINNED_ARCHIVE_TAIL : i32 = 6623;
pub const ERROR_LOG_RECORD_NONEXISTENT : i32 = 6624;
pub const ERROR_LOG_RECORDS_RESERVED_INVALID : i32 = 6625;
pub const ERROR_LOG_SPACE_RESERVED_INVALID : i32 = 6626;
pub const ERROR_LOG_TAIL_INVALID : i32 = 6627;
pub const ERROR_LOG_FULL : i32 = 6628;
pub const ERROR_COULD_NOT_RESIZE_LOG : i32 = 6629;
pub const ERROR_LOG_MULTIPLEXED : i32 = 6630;
pub const ERROR_LOG_DEDICATED : i32 = 6631;
pub const ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS : i32 = 6632;
pub const ERROR_LOG_ARCHIVE_IN_PROGRESS : i32 = 6633;
pub const ERROR_LOG_EPHEMERAL : i32 = 6634;
pub const ERROR_LOG_NOT_ENOUGH_CONTAINERS : i32 = 6635;
pub const ERROR_LOG_CLIENT_ALREADY_REGISTERED : i32 = 6636;
pub const ERROR_LOG_CLIENT_NOT_REGISTERED : i32 = 6637;
pub const ERROR_LOG_FULL_HANDLER_IN_PROGRESS : i32 = 6638;
pub const ERROR_LOG_CONTAINER_READ_FAILED : i32 = 6639;
pub const ERROR_LOG_CONTAINER_WRITE_FAILED : i32 = 6640;
pub const ERROR_LOG_CONTAINER_OPEN_FAILED : i32 = 6641;
pub const ERROR_LOG_CONTAINER_STATE_INVALID : i32 = 6642;
pub const ERROR_LOG_STATE_INVALID : i32 = 6643;
pub const ERROR_LOG_PINNED : i32 = 6644;
pub const ERROR_LOG_METADATA_FLUSH_FAILED : i32 = 6645;
pub const ERROR_LOG_INCONSISTENT_SECURITY : i32 = 6646;
pub const ERROR_LOG_APPENDED_FLUSH_FAILED : i32 = 6647;
pub const ERROR_LOG_PINNED_RESERVATION : i32 = 6648;
pub const ERROR_INVALID_TRANSACTION : i32 = 6700;
pub const ERROR_TRANSACTION_NOT_ACTIVE : i32 = 6701;
pub const ERROR_TRANSACTION_REQUEST_NOT_VALID : i32 = 6702;
pub const ERROR_TRANSACTION_NOT_REQUESTED : i32 = 6703;
pub const ERROR_TRANSACTION_ALREADY_ABORTED : i32 = 6704;
pub const ERROR_TRANSACTION_ALREADY_COMMITTED : i32 = 6705;
pub const ERROR_TM_INITIALIZATION_FAILED : i32 = 6706;
pub const ERROR_RESOURCEMANAGER_READ_ONLY : i32 = 6707;
pub const ERROR_TRANSACTION_NOT_JOINED : i32 = 6708;
pub const ERROR_TRANSACTION_SUPERIOR_EXISTS : i32 = 6709;
pub const ERROR_CRM_PROTOCOL_ALREADY_EXISTS : i32 = 6710;
pub const ERROR_TRANSACTION_PROPAGATION_FAILED : i32 = 6711;
pub const ERROR_CRM_PROTOCOL_NOT_FOUND : i32 = 6712;
pub const ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER : i32 = 6713;
pub const ERROR_CURRENT_TRANSACTION_NOT_VALID : i32 = 6714;
pub const ERROR_TRANSACTION_NOT_FOUND : i32 = 6715;
pub const ERROR_RESOURCEMANAGER_NOT_FOUND : i32 = 6716;
pub const ERROR_ENLISTMENT_NOT_FOUND : i32 = 6717;
pub const ERROR_TRANSACTIONMANAGER_NOT_FOUND : i32 = 6718;
pub const ERROR_TRANSACTIONMANAGER_NOT_ONLINE : i32 = 6719;
pub const ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION : i32 = 6720;
pub const ERROR_TRANSACTION_NOT_ROOT : i32 = 6721;
pub const ERROR_TRANSACTION_OBJECT_EXPIRED : i32 = 6722;
pub const ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED : i32 = 6723;
pub const ERROR_TRANSACTION_RECORD_TOO_LONG : i32 = 6724;
pub const ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED : i32 = 6725;
pub const ERROR_TRANSACTION_INTEGRITY_VIOLATED : i32 = 6726;
pub const ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH : i32 = 6727;
pub const ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT : i32 = 6728;
pub const ERROR_TRANSACTION_MUST_WRITETHROUGH : i32 = 6729;
pub const ERROR_TRANSACTION_NO_SUPERIOR : i32 = 6730;
pub const ERROR_HEURISTIC_DAMAGE_POSSIBLE : i32 = 6731;
pub const ERROR_TRANSACTIONAL_CONFLICT : i32 = 6800;
pub const ERROR_RM_NOT_ACTIVE : i32 = 6801;
pub const ERROR_RM_METADATA_CORRUPT : i32 = 6802;
pub const ERROR_DIRECTORY_NOT_RM : i32 = 6803;
pub const ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE : i32 = 6805;
pub const ERROR_LOG_RESIZE_INVALID_SIZE : i32 = 6806;
pub const ERROR_OBJECT_NO_LONGER_EXISTS : i32 = 6807;
pub const ERROR_STREAM_MINIVERSION_NOT_FOUND : i32 = 6808;
pub const ERROR_STREAM_MINIVERSION_NOT_VALID : i32 = 6809;
pub const ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION : i32 = 6810;
pub const ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT : i32 = 6811;
pub const ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS : i32 = 6812;
pub const ERROR_REMOTE_FILE_VERSION_MISMATCH : i32 = 6814;
pub const ERROR_HANDLE_NO_LONGER_VALID : i32 = 6815;
pub const ERROR_NO_TXF_METADATA : i32 = 6816;
pub const ERROR_LOG_CORRUPTION_DETECTED : i32 = 6817;
pub const ERROR_CANT_RECOVER_WITH_HANDLE_OPEN : i32 = 6818;
pub const ERROR_RM_DISCONNECTED : i32 = 6819;
pub const ERROR_ENLISTMENT_NOT_SUPERIOR : i32 = 6820;
pub const ERROR_RECOVERY_NOT_NEEDED : i32 = 6821;
pub const ERROR_RM_ALREADY_STARTED : i32 = 6822;
pub const ERROR_FILE_IDENTITY_NOT_PERSISTENT : i32 = 6823;
pub const ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY : i32 = 6824;
pub const ERROR_CANT_CROSS_RM_BOUNDARY : i32 = 6825;
pub const ERROR_TXF_DIR_NOT_EMPTY : i32 = 6826;
pub const ERROR_INDOUBT_TRANSACTIONS_EXIST : i32 = 6827;
pub const ERROR_TM_VOLATILE : i32 = 6828;
pub const ERROR_ROLLBACK_TIMER_EXPIRED : i32 = 6829;
pub const ERROR_TXF_ATTRIBUTE_CORRUPT : i32 = 6830;
pub const ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION : i32 = 6831;
pub const ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED : i32 = 6832;
pub const ERROR_LOG_GROWTH_FAILED : i32 = 6833;
pub const ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE : i32 = 6834;
pub const ERROR_TXF_METADATA_ALREADY_PRESENT : i32 = 6835;
pub const ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET : i32 = 6836;
pub const ERROR_TRANSACTION_REQUIRED_PROMOTION : i32 = 6837;
pub const ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION : i32 = 6838;
pub const ERROR_TRANSACTIONS_NOT_FROZEN : i32 = 6839;
pub const ERROR_TRANSACTION_FREEZE_IN_PROGRESS : i32 = 6840;
pub const ERROR_NOT_SNAPSHOT_VOLUME : i32 = 6841;
pub const ERROR_NO_SAVEPOINT_WITH_OPEN_FILES : i32 = 6842;
pub const ERROR_DATA_LOST_REPAIR : i32 = 6843;
pub const ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION : i32 = 6844;
pub const ERROR_TM_IDENTITY_MISMATCH : i32 = 6845;
pub const ERROR_FLOATED_SECTION : i32 = 6846;
pub const ERROR_CANNOT_ACCEPT_TRANSACTED_WORK : i32 = 6847;
pub const ERROR_CANNOT_ABORT_TRANSACTIONS : i32 = 6848;
pub const ERROR_BAD_CLUSTERS : i32 = 6849;
pub const ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION : i32 = 6850;
pub const ERROR_VOLUME_DIRTY : i32 = 6851;
pub const ERROR_NO_LINK_TRACKING_IN_TRANSACTION : i32 = 6852;
pub const ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION : i32 = 6853;
pub const ERROR_EXPIRED_HANDLE : i32 = 6854;
pub const ERROR_TRANSACTION_NOT_ENLISTED : i32 = 6855;
pub const ERROR_CTX_WINSTATION_NAME_INVALID : i32 = 7001;
pub const ERROR_CTX_INVALID_PD : i32 = 7002;
pub const ERROR_CTX_PD_NOT_FOUND : i32 = 7003;
pub const ERROR_CTX_WD_NOT_FOUND : i32 = 7004;
pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY : i32 = 7005;
pub const ERROR_CTX_SERVICE_NAME_COLLISION : i32 = 7006;
pub const ERROR_CTX_CLOSE_PENDING : i32 = 7007;
pub const ERROR_CTX_NO_OUTBUF : i32 = 7008;
pub const ERROR_CTX_MODEM_INF_NOT_FOUND : i32 = 7009;
pub const ERROR_CTX_INVALID_MODEMNAME : i32 = 7010;
pub const ERROR_CTX_MODEM_RESPONSE_ERROR : i32 = 7011;
pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT : i32 = 7012;
pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER : i32 = 7013;
pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE : i32 = 7014;
pub const ERROR_CTX_MODEM_RESPONSE_BUSY : i32 = 7015;
pub const ERROR_CTX_MODEM_RESPONSE_VOICE : i32 = 7016;
pub const ERROR_CTX_TD_ERROR : i32 = 7017;
pub const ERROR_CTX_WINSTATION_NOT_FOUND : i32 = 7022;
pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS : i32 = 7023;
pub const ERROR_CTX_WINSTATION_BUSY : i32 = 7024;
pub const ERROR_CTX_BAD_VIDEO_MODE : i32 = 7025;
pub const ERROR_CTX_GRAPHICS_INVALID : i32 = 7035;
pub const ERROR_CTX_LOGON_DISABLED : i32 = 7037;
pub const ERROR_CTX_NOT_CONSOLE : i32 = 7038;
pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT : i32 = 7040;
pub const ERROR_CTX_CONSOLE_DISCONNECT : i32 = 7041;
pub const ERROR_CTX_CONSOLE_CONNECT : i32 = 7042;
pub const ERROR_CTX_SHADOW_DENIED : i32 = 7044;
pub const ERROR_CTX_WINSTATION_ACCESS_DENIED : i32 = 7045;
pub const ERROR_CTX_INVALID_WD : i32 = 7049;
pub const ERROR_CTX_SHADOW_INVALID : i32 = 7050;
pub const ERROR_CTX_SHADOW_DISABLED : i32 = 7051;
pub const ERROR_CTX_CLIENT_LICENSE_IN_USE : i32 = 7052;
pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET : i32 = 7053;
pub const ERROR_CTX_LICENSE_NOT_AVAILABLE : i32 = 7054;
pub const ERROR_CTX_LICENSE_CLIENT_INVALID : i32 = 7055;
pub const ERROR_CTX_LICENSE_EXPIRED : i32 = 7056;
pub const ERROR_CTX_SHADOW_NOT_RUNNING : i32 = 7057;
pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE : i32 = 7058;
pub const ERROR_ACTIVATION_COUNT_EXCEEDED : i32 = 7059;
pub const ERROR_CTX_WINSTATIONS_DISABLED : i32 = 7060;
pub const ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED : i32 = 7061;
pub const ERROR_CTX_SESSION_IN_USE : i32 = 7062;
pub const ERROR_CTX_NO_FORCE_LOGOFF : i32 = 7063;
pub const ERROR_CTX_ACCOUNT_RESTRICTION : i32 = 7064;
pub const ERROR_RDP_PROTOCOL_ERROR : i32 = 7065;
pub const ERROR_CTX_CDM_CONNECT : i32 = 7066;
pub const ERROR_CTX_CDM_DISCONNECT : i32 = 7067;
pub const ERROR_CTX_SECURITY_LAYER_ERROR : i32 = 7068;
pub const ERROR_TS_INCOMPATIBLE_SESSIONS : i32 = 7069;
pub const ERROR_TS_VIDEO_SUBSYSTEM_ERROR : i32 = 7070;
pub const FRS_ERR_INVALID_API_SEQUENCE : i32 = 8001;
pub const FRS_ERR_STARTING_SERVICE : i32 = 8002;
pub const FRS_ERR_STOPPING_SERVICE : i32 = 8003;
pub const FRS_ERR_INTERNAL_API : i32 = 8004;
pub const FRS_ERR_INTERNAL : i32 = 8005;
pub const FRS_ERR_SERVICE_COMM : i32 = 8006;
pub const FRS_ERR_INSUFFICIENT_PRIV : i32 = 8007;
pub const FRS_ERR_AUTHENTICATION : i32 = 8008;
pub const FRS_ERR_PARENT_INSUFFICIENT_PRIV : i32 = 8009;
pub const FRS_ERR_PARENT_AUTHENTICATION : i32 = 8010;
pub const FRS_ERR_CHILD_TO_PARENT_COMM : i32 = 8011;
pub const FRS_ERR_PARENT_TO_CHILD_COMM : i32 = 8012;
pub const FRS_ERR_SYSVOL_POPULATE : i32 = 8013;
pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT : i32 = 8014;
pub const FRS_ERR_SYSVOL_IS_BUSY : i32 = 8015;
pub const FRS_ERR_SYSVOL_DEMOTE : i32 = 8016;
pub const FRS_ERR_INVALID_SERVICE_PARAMETER : i32 = 8017;
pub const ERROR_DS_NOT_INSTALLED : i32 = 8200;
pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY : i32 = 8201;
pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE : i32 = 8202;
pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX : i32 = 8203;
pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED : i32 = 8204;
pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS : i32 = 8205;
pub const ERROR_DS_BUSY : i32 = 8206;
pub const ERROR_DS_UNAVAILABLE : i32 = 8207;
pub const ERROR_DS_NO_RIDS_ALLOCATED : i32 = 8208;
pub const ERROR_DS_NO_MORE_RIDS : i32 = 8209;
pub const ERROR_DS_INCORRECT_ROLE_OWNER : i32 = 8210;
pub const ERROR_DS_RIDMGR_INIT_ERROR : i32 = 8211;
pub const ERROR_DS_OBJ_CLASS_VIOLATION : i32 = 8212;
pub const ERROR_DS_CANT_ON_NON_LEAF : i32 = 8213;
pub const ERROR_DS_CANT_ON_RDN : i32 = 8214;
pub const ERROR_DS_CANT_MOD_OBJ_CLASS : i32 = 8215;
pub const ERROR_DS_CROSS_DOM_MOVE_ERROR : i32 = 8216;
pub const ERROR_DS_GC_NOT_AVAILABLE : i32 = 8217;
pub const ERROR_SHARED_POLICY : i32 = 8218;
pub const ERROR_POLICY_OBJECT_NOT_FOUND : i32 = 8219;
pub const ERROR_POLICY_ONLY_IN_DS : i32 = 8220;
pub const ERROR_PROMOTION_ACTIVE : i32 = 8221;
pub const ERROR_NO_PROMOTION_ACTIVE : i32 = 8222;
pub const ERROR_DS_OPERATIONS_ERROR : i32 = 8224;
pub const ERROR_DS_PROTOCOL_ERROR : i32 = 8225;
pub const ERROR_DS_TIMELIMIT_EXCEEDED : i32 = 8226;
pub const ERROR_DS_SIZELIMIT_EXCEEDED : i32 = 8227;
pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED : i32 = 8228;
pub const ERROR_DS_COMPARE_FALSE : i32 = 8229;
pub const ERROR_DS_COMPARE_TRUE : i32 = 8230;
pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED : i32 = 8231;
pub const ERROR_DS_STRONG_AUTH_REQUIRED : i32 = 8232;
pub const ERROR_DS_INAPPROPRIATE_AUTH : i32 = 8233;
pub const ERROR_DS_AUTH_UNKNOWN : i32 = 8234;
pub const ERROR_DS_REFERRAL : i32 = 8235;
pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION : i32 = 8236;
pub const ERROR_DS_CONFIDENTIALITY_REQUIRED : i32 = 8237;
pub const ERROR_DS_INAPPROPRIATE_MATCHING : i32 = 8238;
pub const ERROR_DS_CONSTRAINT_VIOLATION : i32 = 8239;
pub const ERROR_DS_NO_SUCH_OBJECT : i32 = 8240;
pub const ERROR_DS_ALIAS_PROBLEM : i32 = 8241;
pub const ERROR_DS_INVALID_DN_SYNTAX : i32 = 8242;
pub const ERROR_DS_IS_LEAF : i32 = 8243;
pub const ERROR_DS_ALIAS_DEREF_PROBLEM : i32 = 8244;
pub const ERROR_DS_UNWILLING_TO_PERFORM : i32 = 8245;
pub const ERROR_DS_LOOP_DETECT : i32 = 8246;
pub const ERROR_DS_NAMING_VIOLATION : i32 = 8247;
pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE : i32 = 8248;
pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS : i32 = 8249;
pub const ERROR_DS_SERVER_DOWN : i32 = 8250;
pub const ERROR_DS_LOCAL_ERROR : i32 = 8251;
pub const ERROR_DS_ENCODING_ERROR : i32 = 8252;
pub const ERROR_DS_DECODING_ERROR : i32 = 8253;
pub const ERROR_DS_FILTER_UNKNOWN : i32 = 8254;
pub const ERROR_DS_PARAM_ERROR : i32 = 8255;
pub const ERROR_DS_NOT_SUPPORTED : i32 = 8256;
pub const ERROR_DS_NO_RESULTS_RETURNED : i32 = 8257;
pub const ERROR_DS_CONTROL_NOT_FOUND : i32 = 8258;
pub const ERROR_DS_CLIENT_LOOP : i32 = 8259;
pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED : i32 = 8260;
pub const ERROR_DS_SORT_CONTROL_MISSING : i32 = 8261;
pub const ERROR_DS_OFFSET_RANGE_ERROR : i32 = 8262;
pub const ERROR_DS_RIDMGR_DISABLED : i32 = 8263;
pub const ERROR_DS_ROOT_MUST_BE_NC : i32 = 8301;
pub const ERROR_DS_ADD_REPLICA_INHIBITED : i32 = 8302;
pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA : i32 = 8303;
pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED : i32 = 8304;
pub const ERROR_DS_OBJ_STRING_NAME_EXISTS : i32 = 8305;
pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA : i32 = 8306;
pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA : i32 = 8307;
pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND : i32 = 8308;
pub const ERROR_DS_USER_BUFFER_TO_SMALL : i32 = 8309;
pub const ERROR_DS_ATT_IS_NOT_ON_OBJ : i32 = 8310;
pub const ERROR_DS_ILLEGAL_MOD_OPERATION : i32 = 8311;
pub const ERROR_DS_OBJ_TOO_LARGE : i32 = 8312;
pub const ERROR_DS_BAD_INSTANCE_TYPE : i32 = 8313;
pub const ERROR_DS_MASTERDSA_REQUIRED : i32 = 8314;
pub const ERROR_DS_OBJECT_CLASS_REQUIRED : i32 = 8315;
pub const ERROR_DS_MISSING_REQUIRED_ATT : i32 = 8316;
pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS : i32 = 8317;
pub const ERROR_DS_ATT_ALREADY_EXISTS : i32 = 8318;
pub const ERROR_DS_CANT_ADD_ATT_VALUES : i32 = 8320;
pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT : i32 = 8321;
pub const ERROR_DS_RANGE_CONSTRAINT : i32 = 8322;
pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS : i32 = 8323;
pub const ERROR_DS_CANT_REM_MISSING_ATT : i32 = 8324;
pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL : i32 = 8325;
pub const ERROR_DS_ROOT_CANT_BE_SUBREF : i32 = 8326;
pub const ERROR_DS_NO_CHAINING : i32 = 8327;
pub const ERROR_DS_NO_CHAINED_EVAL : i32 = 8328;
pub const ERROR_DS_NO_PARENT_OBJECT : i32 = 8329;
pub const ERROR_DS_PARENT_IS_AN_ALIAS : i32 = 8330;
pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS : i32 = 8331;
pub const ERROR_DS_CHILDREN_EXIST : i32 = 8332;
pub const ERROR_DS_OBJ_NOT_FOUND : i32 = 8333;
pub const ERROR_DS_ALIASED_OBJ_MISSING : i32 = 8334;
pub const ERROR_DS_BAD_NAME_SYNTAX : i32 = 8335;
pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS : i32 = 8336;
pub const ERROR_DS_CANT_DEREF_ALIAS : i32 = 8337;
pub const ERROR_DS_OUT_OF_SCOPE : i32 = 8338;
pub const ERROR_DS_OBJECT_BEING_REMOVED : i32 = 8339;
pub const ERROR_DS_CANT_DELETE_DSA_OBJ : i32 = 8340;
pub const ERROR_DS_GENERIC_ERROR : i32 = 8341;
pub const ERROR_DS_DSA_MUST_BE_INT_MASTER : i32 = 8342;
pub const ERROR_DS_CLASS_NOT_DSA : i32 = 8343;
pub const ERROR_DS_INSUFF_ACCESS_RIGHTS : i32 = 8344;
pub const ERROR_DS_ILLEGAL_SUPERIOR : i32 = 8345;
pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM : i32 = 8346;
pub const ERROR_DS_NAME_TOO_MANY_PARTS : i32 = 8347;
pub const ERROR_DS_NAME_TOO_LONG : i32 = 8348;
pub const ERROR_DS_NAME_VALUE_TOO_LONG : i32 = 8349;
pub const ERROR_DS_NAME_UNPARSEABLE : i32 = 8350;
pub const ERROR_DS_NAME_TYPE_UNKNOWN : i32 = 8351;
pub const ERROR_DS_NOT_AN_OBJECT : i32 = 8352;
pub const ERROR_DS_SEC_DESC_TOO_SHORT : i32 = 8353;
pub const ERROR_DS_SEC_DESC_INVALID : i32 = 8354;
pub const ERROR_DS_NO_DELETED_NAME : i32 = 8355;
pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT : i32 = 8356;
pub const ERROR_DS_NCNAME_MUST_BE_NC : i32 = 8357;
pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY : i32 = 8358;
pub const ERROR_DS_CLASS_MUST_BE_CONCRETE : i32 = 8359;
pub const ERROR_DS_INVALID_DMD : i32 = 8360;
pub const ERROR_DS_OBJ_GUID_EXISTS : i32 = 8361;
pub const ERROR_DS_NOT_ON_BACKLINK : i32 = 8362;
pub const ERROR_DS_NO_CROSSREF_FOR_NC : i32 = 8363;
pub const ERROR_DS_SHUTTING_DOWN : i32 = 8364;
pub const ERROR_DS_UNKNOWN_OPERATION : i32 = 8365;
pub const ERROR_DS_INVALID_ROLE_OWNER : i32 = 8366;
pub const ERROR_DS_COULDNT_CONTACT_FSMO : i32 = 8367;
pub const ERROR_DS_CROSS_NC_DN_RENAME : i32 = 8368;
pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY : i32 = 8369;
pub const ERROR_DS_REPLICATOR_ONLY : i32 = 8370;
pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED : i32 = 8371;
pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS : i32 = 8372;
pub const ERROR_DS_NAME_REFERENCE_INVALID : i32 = 8373;
pub const ERROR_DS_CROSS_REF_EXISTS : i32 = 8374;
pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF : i32 = 8375;
pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD : i32 = 8376;
pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX : i32 = 8377;
pub const ERROR_DS_DUP_RDN : i32 = 8378;
pub const ERROR_DS_DUP_OID : i32 = 8379;
pub const ERROR_DS_DUP_MAPI_ID : i32 = 8380;
pub const ERROR_DS_DUP_SCHEMA_ID_GUID : i32 = 8381;
pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME : i32 = 8382;
pub const ERROR_DS_SEMANTIC_ATT_TEST : i32 = 8383;
pub const ERROR_DS_SYNTAX_MISMATCH : i32 = 8384;
pub const ERROR_DS_EXISTS_IN_MUST_HAVE : i32 = 8385;
pub const ERROR_DS_EXISTS_IN_MAY_HAVE : i32 = 8386;
pub const ERROR_DS_NONEXISTENT_MAY_HAVE : i32 = 8387;
pub const ERROR_DS_NONEXISTENT_MUST_HAVE : i32 = 8388;
pub const ERROR_DS_AUX_CLS_TEST_FAIL : i32 = 8389;
pub const ERROR_DS_NONEXISTENT_POSS_SUP : i32 = 8390;
pub const ERROR_DS_SUB_CLS_TEST_FAIL : i32 = 8391;
pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX : i32 = 8392;
pub const ERROR_DS_EXISTS_IN_AUX_CLS : i32 = 8393;
pub const ERROR_DS_EXISTS_IN_SUB_CLS : i32 = 8394;
pub const ERROR_DS_EXISTS_IN_POSS_SUP : i32 = 8395;
pub const ERROR_DS_RECALCSCHEMA_FAILED : i32 = 8396;
pub const ERROR_DS_TREE_DELETE_NOT_FINISHED : i32 = 8397;
pub const ERROR_DS_CANT_DELETE : i32 = 8398;
pub const ERROR_DS_ATT_SCHEMA_REQ_ID : i32 = 8399;
pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX : i32 = 8400;
pub const ERROR_DS_CANT_CACHE_ATT : i32 = 8401;
pub const ERROR_DS_CANT_CACHE_CLASS : i32 = 8402;
pub const ERROR_DS_CANT_REMOVE_ATT_CACHE : i32 = 8403;
pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE : i32 = 8404;
pub const ERROR_DS_CANT_RETRIEVE_DN : i32 = 8405;
pub const ERROR_DS_MISSING_SUPREF : i32 = 8406;
pub const ERROR_DS_CANT_RETRIEVE_INSTANCE : i32 = 8407;
pub const ERROR_DS_CODE_INCONSISTENCY : i32 = 8408;
pub const ERROR_DS_DATABASE_ERROR : i32 = 8409;
pub const ERROR_DS_GOVERNSID_MISSING : i32 = 8410;
pub const ERROR_DS_MISSING_EXPECTED_ATT : i32 = 8411;
pub const ERROR_DS_NCNAME_MISSING_CR_REF : i32 = 8412;
pub const ERROR_DS_SECURITY_CHECKING_ERROR : i32 = 8413;
pub const ERROR_DS_SCHEMA_NOT_LOADED : i32 = 8414;
pub const ERROR_DS_SCHEMA_ALLOC_FAILED : i32 = 8415;
pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX : i32 = 8416;
pub const ERROR_DS_GCVERIFY_ERROR : i32 = 8417;
pub const ERROR_DS_DRA_SCHEMA_MISMATCH : i32 = 8418;
pub const ERROR_DS_CANT_FIND_DSA_OBJ : i32 = 8419;
pub const ERROR_DS_CANT_FIND_EXPECTED_NC : i32 = 8420;
pub const ERROR_DS_CANT_FIND_NC_IN_CACHE : i32 = 8421;
pub const ERROR_DS_CANT_RETRIEVE_CHILD : i32 = 8422;
pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY : i32 = 8423;
pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC : i32 = 8424;
pub const ERROR_DS_BAD_HIERARCHY_FILE : i32 = 8425;
pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED : i32 = 8426;
pub const ERROR_DS_CONFIG_PARAM_MISSING : i32 = 8427;
pub const ERROR_DS_COUNTING_AB_INDICES_FAILED : i32 = 8428;
pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED : i32 = 8429;
pub const ERROR_DS_INTERNAL_FAILURE : i32 = 8430;
pub const ERROR_DS_UNKNOWN_ERROR : i32 = 8431;
pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP : i32 = 8432;
pub const ERROR_DS_REFUSING_FSMO_ROLES : i32 = 8433;
pub const ERROR_DS_MISSING_FSMO_SETTINGS : i32 = 8434;
pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES : i32 = 8435;
pub const ERROR_DS_DRA_GENERIC : i32 = 8436;
pub const ERROR_DS_DRA_INVALID_PARAMETER : i32 = 8437;
pub const ERROR_DS_DRA_BUSY : i32 = 8438;
pub const ERROR_DS_DRA_BAD_DN : i32 = 8439;
pub const ERROR_DS_DRA_BAD_NC : i32 = 8440;
pub const ERROR_DS_DRA_DN_EXISTS : i32 = 8441;
pub const ERROR_DS_DRA_INTERNAL_ERROR : i32 = 8442;
pub const ERROR_DS_DRA_INCONSISTENT_DIT : i32 = 8443;
pub const ERROR_DS_DRA_CONNECTION_FAILED : i32 = 8444;
pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE : i32 = 8445;
pub const ERROR_DS_DRA_OUT_OF_MEM : i32 = 8446;
pub const ERROR_DS_DRA_MAIL_PROBLEM : i32 = 8447;
pub const ERROR_DS_DRA_REF_ALREADY_EXISTS : i32 = 8448;
pub const ERROR_DS_DRA_REF_NOT_FOUND : i32 = 8449;
pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE : i32 = 8450;
pub const ERROR_DS_DRA_DB_ERROR : i32 = 8451;
pub const ERROR_DS_DRA_NO_REPLICA : i32 = 8452;
pub const ERROR_DS_DRA_ACCESS_DENIED : i32 = 8453;
pub const ERROR_DS_DRA_NOT_SUPPORTED : i32 = 8454;
pub const ERROR_DS_DRA_RPC_CANCELLED : i32 = 8455;
pub const ERROR_DS_DRA_SOURCE_DISABLED : i32 = 8456;
pub const ERROR_DS_DRA_SINK_DISABLED : i32 = 8457;
pub const ERROR_DS_DRA_NAME_COLLISION : i32 = 8458;
pub const ERROR_DS_DRA_SOURCE_REINSTALLED : i32 = 8459;
pub const ERROR_DS_DRA_MISSING_PARENT : i32 = 8460;
pub const ERROR_DS_DRA_PREEMPTED : i32 = 8461;
pub const ERROR_DS_DRA_ABANDON_SYNC : i32 = 8462;
pub const ERROR_DS_DRA_SHUTDOWN : i32 = 8463;
pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET : i32 = 8464;
pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA : i32 = 8465;
pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED : i32 = 8466;
pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH : i32 = 8467;
pub const ERROR_DS_DUP_LINK_ID : i32 = 8468;
pub const ERROR_DS_NAME_ERROR_RESOLVING : i32 = 8469;
pub const ERROR_DS_NAME_ERROR_NOT_FOUND : i32 = 8470;
pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE : i32 = 8471;
pub const ERROR_DS_NAME_ERROR_NO_MAPPING : i32 = 8472;
pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY : i32 = 8473;
pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING : i32 = 8474;
pub const ERROR_DS_CONSTRUCTED_ATT_MOD : i32 = 8475;
pub const ERROR_DS_WRONG_OM_OBJ_CLASS : i32 = 8476;
pub const ERROR_DS_DRA_REPL_PENDING : i32 = 8477;
pub const ERROR_DS_DS_REQUIRED : i32 = 8478;
pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME : i32 = 8479;
pub const ERROR_DS_NON_BASE_SEARCH : i32 = 8480;
pub const ERROR_DS_CANT_RETRIEVE_ATTS : i32 = 8481;
pub const ERROR_DS_BACKLINK_WITHOUT_LINK : i32 = 8482;
pub const ERROR_DS_EPOCH_MISMATCH : i32 = 8483;
pub const ERROR_DS_SRC_NAME_MISMATCH : i32 = 8484;
pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL : i32 = 8485;
pub const ERROR_DS_DST_NC_MISMATCH : i32 = 8486;
pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC : i32 = 8487;
pub const ERROR_DS_SRC_GUID_MISMATCH : i32 = 8488;
pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT : i32 = 8489;
pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS : i32 = 8490;
pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD : i32 = 8491;
pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION : i32 = 8492;
pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS : i32 = 8493;
pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT : i32 = 8494;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE : i32 = 8495;
pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE : i32 = 8496;
pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER : i32 = 8497;
pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP : i32 = 8498;
pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP : i32 = 8499;
pub const ERROR_DS_INVALID_SEARCH_FLAG : i32 = 8500;
pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC : i32 = 8501;
pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE : i32 = 8502;
pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE : i32 = 8503;
pub const ERROR_DS_SAM_INIT_FAILURE : i32 = 8504;
pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION : i32 = 8505;
pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID : i32 = 8506;
pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD : i32 = 8507;
pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE : i32 = 8508;
pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED : i32 = 8509;
pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA : i32 = 8510;
pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION : i32 = 8511;
pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE : i32 = 8512;
pub const ERROR_DS_INVALID_GROUP_TYPE : i32 = 8513;
pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN : i32 = 8514;
pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN : i32 = 8515;
pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER : i32 = 8516;
pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER : i32 = 8517;
pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER : i32 = 8518;
pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER : i32 = 8519;
pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER : i32 = 8520;
pub const ERROR_DS_HAVE_PRIMARY_MEMBERS : i32 = 8521;
pub const ERROR_DS_STRING_SD_CONVERSION_FAILED : i32 = 8522;
pub const ERROR_DS_NAMING_MASTER_GC : i32 = 8523;
pub const ERROR_DS_DNS_LOOKUP_FAILURE : i32 = 8524;
pub const ERROR_DS_COULDNT_UPDATE_SPNS : i32 = 8525;
pub const ERROR_DS_CANT_RETRIEVE_SD : i32 = 8526;
pub const ERROR_DS_KEY_NOT_UNIQUE : i32 = 8527;
pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX : i32 = 8528;
pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD : i32 = 8529;
pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY : i32 = 8530;
pub const ERROR_DS_CANT_START : i32 = 8531;
pub const ERROR_DS_INIT_FAILURE : i32 = 8532;
pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION : i32 = 8533;
pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST : i32 = 8534;
pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST : i32 = 8535;
pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED : i32 = 8536;
pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN : i32 = 8537;
pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER : i32 = 8538;
pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST : i32 = 8539;
pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH : i32 = 8540;
pub const ERROR_SAM_INIT_FAILURE : i32 = 8541;
pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP : i32 = 8542;
pub const ERROR_DS_DRA_SCHEMA_CONFLICT : i32 = 8543;
pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT : i32 = 8544;
pub const ERROR_DS_DRA_OBJ_NC_MISMATCH : i32 = 8545;
pub const ERROR_DS_NC_STILL_HAS_DSAS : i32 = 8546;
pub const ERROR_DS_GC_REQUIRED : i32 = 8547;
pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY : i32 = 8548;
pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS : i32 = 8549;
pub const ERROR_DS_CANT_ADD_TO_GC : i32 = 8550;
pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC : i32 = 8551;
pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED : i32 = 8552;
pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC : i32 = 8553;
pub const ERROR_DS_INVALID_NAME_FOR_SPN : i32 = 8554;
pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS : i32 = 8555;
pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES : i32 = 8556;
pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED : i32 = 8557;
pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC : i32 = 8558;
pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER : i32 = 8559;
pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ : i32 = 8560;
pub const ERROR_DS_INIT_FAILURE_CONSOLE : i32 = 8561;
pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE : i32 = 8562;
pub const ERROR_DS_FOREST_VERSION_TOO_HIGH : i32 = 8563;
pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH : i32 = 8564;
pub const ERROR_DS_FOREST_VERSION_TOO_LOW : i32 = 8565;
pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW : i32 = 8566;
pub const ERROR_DS_INCOMPATIBLE_VERSION : i32 = 8567;
pub const ERROR_DS_LOW_DSA_VERSION : i32 = 8568;
pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN : i32 = 8569;
pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER : i32 = 8570;
pub const ERROR_DS_NAME_NOT_UNIQUE : i32 = 8571;
pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 : i32 = 8572;
pub const ERROR_DS_OUT_OF_VERSION_STORE : i32 = 8573;
pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED : i32 = 8574;
pub const ERROR_DS_NO_REF_DOMAIN : i32 = 8575;
pub const ERROR_DS_RESERVED_LINK_ID : i32 = 8576;
pub const ERROR_DS_LINK_ID_NOT_AVAILABLE : i32 = 8577;
pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER : i32 = 8578;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE : i32 = 8579;
pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC : i32 = 8580;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG : i32 = 8581;
pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT : i32 = 8582;
pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL : i32 = 8583;
pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER : i32 = 8584;
pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD : i32 = 8585;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 : i32 = 8586;
pub const ERROR_DS_THREAD_LIMIT_EXCEEDED : i32 = 8587;
pub const ERROR_DS_NOT_CLOSEST : i32 = 8588;
pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF : i32 = 8589;
pub const ERROR_DS_SINGLE_USER_MODE_FAILED : i32 = 8590;
pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR : i32 = 8591;
pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR : i32 = 8592;
pub const ERROR_DS_DIFFERENT_REPL_EPOCHS : i32 = 8593;
pub const ERROR_DS_DRS_EXTENSIONS_CHANGED : i32 = 8594;
pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR : i32 = 8595;
pub const ERROR_DS_NO_MSDS_INTID : i32 = 8596;
pub const ERROR_DS_DUP_MSDS_INTID : i32 = 8597;
pub const ERROR_DS_EXISTS_IN_RDNATTID : i32 = 8598;
pub const ERROR_DS_AUTHORIZATION_FAILED : i32 = 8599;
pub const ERROR_DS_INVALID_SCRIPT : i32 = 8600;
pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED : i32 = 8601;
pub const ERROR_DS_CROSS_REF_BUSY : i32 = 8602;
pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN : i32 = 8603;
pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC : i32 = 8604;
pub const ERROR_DS_DUPLICATE_ID_FOUND : i32 = 8605;
pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT : i32 = 8606;
pub const ERROR_DS_GROUP_CONVERSION_ERROR : i32 = 8607;
pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP : i32 = 8608;
pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP : i32 = 8609;
pub const ERROR_DS_ROLE_NOT_VERIFIED : i32 = 8610;
pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL : i32 = 8611;
pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS : i32 = 8612;
pub const ERROR_DS_EXISTING_AD_CHILD_NC : i32 = 8613;
pub const ERROR_DS_REPL_LIFETIME_EXCEEDED : i32 = 8614;
pub const ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER : i32 = 8615;
pub const ERROR_DS_LDAP_SEND_QUEUE_FULL : i32 = 8616;
pub const ERROR_DS_DRA_OUT_SCHEDULE_WINDOW : i32 = 8617;
pub const ERROR_DS_POLICY_NOT_KNOWN : i32 = 8618;
pub const ERROR_NO_SITE_SETTINGS_OBJECT : i32 = 8619;
pub const ERROR_NO_SECRETS : i32 = 8620;
pub const ERROR_NO_WRITABLE_DC_FOUND : i32 = 8621;
pub const ERROR_DS_NO_SERVER_OBJECT : i32 = 8622;
pub const ERROR_DS_NO_NTDSA_OBJECT : i32 = 8623;
pub const ERROR_DS_NON_ASQ_SEARCH : i32 = 8624;
pub const ERROR_DS_AUDIT_FAILURE : i32 = 8625;
pub const ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE : i32 = 8626;
pub const ERROR_DS_INVALID_SEARCH_FLAG_TUPLE : i32 = 8627;
pub const ERROR_DS_HIERARCHY_TABLE_TOO_DEEP : i32 = 8628;
pub const ERROR_DS_DRA_CORRUPT_UTD_VECTOR : i32 = 8629;
pub const ERROR_DS_DRA_SECRETS_DENIED : i32 = 8630;
pub const ERROR_DS_RESERVED_MAPI_ID : i32 = 8631;
pub const ERROR_DS_MAPI_ID_NOT_AVAILABLE : i32 = 8632;
pub const ERROR_DS_DRA_MISSING_KRBTGT_SECRET : i32 = 8633;
pub const ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST : i32 = 8634;
pub const ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST : i32 = 8635;
pub const ERROR_INVALID_USER_PRINCIPAL_NAME : i32 = 8636;
pub const ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS : i32 = 8637;
pub const ERROR_DS_OID_NOT_FOUND : i32 = 8638;
pub const ERROR_DS_DRA_RECYCLED_TARGET : i32 = 8639;
pub const ERROR_DS_DISALLOWED_NC_REDIRECT : i32 = 8640;
pub const ERROR_DS_HIGH_ADLDS_FFL : i32 = 8641;
pub const ERROR_DS_HIGH_DSA_VERSION : i32 = 8642;
pub const ERROR_DS_LOW_ADLDS_FFL : i32 = 8643;
pub const ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION : i32 = 8644;
pub const ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED : i32 = 8645;
pub const ERROR_INCORRECT_ACCOUNT_TYPE : i32 = 8646;
pub const ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST : i32 = 8647;
pub const ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST : i32 = 8648;
pub const ERROR_DS_MISSING_FOREST_TRUST : i32 = 8649;
pub const ERROR_DS_VALUE_KEY_NOT_UNIQUE : i32 = 8650;
pub const DNS_ERROR_RESPONSE_CODES_BASE : i32 = 9000;
pub const DNS_ERROR_MASK : i32 = 9000;
pub const DNS_ERROR_RCODE_FORMAT_ERROR : i32 = 9001;
pub const DNS_ERROR_RCODE_SERVER_FAILURE : i32 = 9002;
pub const DNS_ERROR_RCODE_NAME_ERROR : i32 = 9003;
pub const DNS_ERROR_RCODE_NOT_IMPLEMENTED : i32 = 9004;
pub const DNS_ERROR_RCODE_REFUSED : i32 = 9005;
pub const DNS_ERROR_RCODE_YXDOMAIN : i32 = 9006;
pub const DNS_ERROR_RCODE_YXRRSET : i32 = 9007;
pub const DNS_ERROR_RCODE_NXRRSET : i32 = 9008;
pub const DNS_ERROR_RCODE_NOTAUTH : i32 = 9009;
pub const DNS_ERROR_RCODE_NOTZONE : i32 = 9010;
pub const DNS_ERROR_RCODE_BADSIG : i32 = 9016;
pub const DNS_ERROR_RCODE_BADKEY : i32 = 9017;
pub const DNS_ERROR_RCODE_BADTIME : i32 = 9018;
pub const DNS_ERROR_DNSSEC_BASE : i32 = 9100;
pub const DNS_ERROR_KEYMASTER_REQUIRED : i32 = 9101;
pub const DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE : i32 = 9102;
pub const DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1 : i32 = 9103;
pub const DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS : i32 = 9104;
pub const DNS_ERROR_UNSUPPORTED_ALGORITHM : i32 = 9105;
pub const DNS_ERROR_INVALID_KEY_SIZE : i32 = 9106;
pub const DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE : i32 = 9107;
pub const DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION : i32 = 9108;
pub const DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR : i32 = 9109;
pub const DNS_ERROR_UNEXPECTED_CNG_ERROR : i32 = 9110;
pub const DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION : i32 = 9111;
pub const DNS_ERROR_KSP_NOT_ACCESSIBLE : i32 = 9112;
pub const DNS_ERROR_TOO_MANY_SKDS : i32 = 9113;
pub const DNS_ERROR_INVALID_ROLLOVER_PERIOD : i32 = 9114;
pub const DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET : i32 = 9115;
pub const DNS_ERROR_ROLLOVER_IN_PROGRESS : i32 = 9116;
pub const DNS_ERROR_STANDBY_KEY_NOT_PRESENT : i32 = 9117;
pub const DNS_ERROR_NOT_ALLOWED_ON_ZSK : i32 = 9118;
pub const DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD : i32 = 9119;
pub const DNS_ERROR_ROLLOVER_ALREADY_QUEUED : i32 = 9120;
pub const DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE : i32 = 9121;
pub const DNS_ERROR_BAD_KEYMASTER : i32 = 9122;
pub const DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD : i32 = 9123;
pub const DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT : i32 = 9124;
pub const DNS_ERROR_DNSSEC_IS_DISABLED : i32 = 9125;
pub const DNS_ERROR_INVALID_XML : i32 = 9126;
pub const DNS_ERROR_NO_VALID_TRUST_ANCHORS : i32 = 9127;
pub const DNS_ERROR_ROLLOVER_NOT_POKEABLE : i32 = 9128;
pub const DNS_ERROR_NSEC3_NAME_COLLISION : i32 = 9129;
pub const DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1 : i32 = 9130;
pub const DNS_ERROR_PACKET_FMT_BASE : i32 = 9500;
pub const DNS_INFO_NO_RECORDS : i32 = 9501;
pub const DNS_ERROR_BAD_PACKET : i32 = 9502;
pub const DNS_ERROR_NO_PACKET : i32 = 9503;
pub const DNS_ERROR_RCODE : i32 = 9504;
pub const DNS_ERROR_UNSECURE_PACKET : i32 = 9505;
pub const DNS_REQUEST_PENDING : i32 = 9506;
pub const DNS_ERROR_GENERAL_API_BASE : i32 = 9550;
pub const DNS_ERROR_INVALID_TYPE : i32 = 9551;
pub const DNS_ERROR_INVALID_IP_ADDRESS : i32 = 9552;
pub const DNS_ERROR_INVALID_PROPERTY : i32 = 9553;
pub const DNS_ERROR_TRY_AGAIN_LATER : i32 = 9554;
pub const DNS_ERROR_NOT_UNIQUE : i32 = 9555;
pub const DNS_ERROR_NON_RFC_NAME : i32 = 9556;
pub const DNS_STATUS_FQDN : i32 = 9557;
pub const DNS_STATUS_DOTTED_NAME : i32 = 9558;
pub const DNS_STATUS_SINGLE_PART_NAME : i32 = 9559;
pub const DNS_ERROR_INVALID_NAME_CHAR : i32 = 9560;
pub const DNS_ERROR_NUMERIC_NAME : i32 = 9561;
pub const DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER : i32 = 9562;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION : i32 = 9563;
pub const DNS_ERROR_CANNOT_FIND_ROOT_HINTS : i32 = 9564;
pub const DNS_ERROR_INCONSISTENT_ROOT_HINTS : i32 = 9565;
pub const DNS_ERROR_DWORD_VALUE_TOO_SMALL : i32 = 9566;
pub const DNS_ERROR_DWORD_VALUE_TOO_LARGE : i32 = 9567;
pub const DNS_ERROR_BACKGROUND_LOADING : i32 = 9568;
pub const DNS_ERROR_NOT_ALLOWED_ON_RODC : i32 = 9569;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DNAME : i32 = 9570;
pub const DNS_ERROR_DELEGATION_REQUIRED : i32 = 9571;
pub const DNS_ERROR_INVALID_POLICY_TABLE : i32 = 9572;
pub const DNS_ERROR_ADDRESS_REQUIRED : i32 = 9573;
pub const DNS_ERROR_ZONE_BASE : i32 = 9600;
pub const DNS_ERROR_ZONE_DOES_NOT_EXIST : i32 = 9601;
pub const DNS_ERROR_NO_ZONE_INFO : i32 = 9602;
pub const DNS_ERROR_INVALID_ZONE_OPERATION : i32 = 9603;
pub const DNS_ERROR_ZONE_CONFIGURATION_ERROR : i32 = 9604;
pub const DNS_ERROR_ZONE_HAS_NO_SOA_RECORD : i32 = 9605;
pub const DNS_ERROR_ZONE_HAS_NO_NS_RECORDS : i32 = 9606;
pub const DNS_ERROR_ZONE_LOCKED : i32 = 9607;
pub const DNS_ERROR_ZONE_CREATION_FAILED : i32 = 9608;
pub const DNS_ERROR_ZONE_ALREADY_EXISTS : i32 = 9609;
pub const DNS_ERROR_AUTOZONE_ALREADY_EXISTS : i32 = 9610;
pub const DNS_ERROR_INVALID_ZONE_TYPE : i32 = 9611;
pub const DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP : i32 = 9612;
pub const DNS_ERROR_ZONE_NOT_SECONDARY : i32 = 9613;
pub const DNS_ERROR_NEED_SECONDARY_ADDRESSES : i32 = 9614;
pub const DNS_ERROR_WINS_INIT_FAILED : i32 = 9615;
pub const DNS_ERROR_NEED_WINS_SERVERS : i32 = 9616;
pub const DNS_ERROR_NBSTAT_INIT_FAILED : i32 = 9617;
pub const DNS_ERROR_SOA_DELETE_INVALID : i32 = 9618;
pub const DNS_ERROR_FORWARDER_ALREADY_EXISTS : i32 = 9619;
pub const DNS_ERROR_ZONE_REQUIRES_MASTER_IP : i32 = 9620;
pub const DNS_ERROR_ZONE_IS_SHUTDOWN : i32 = 9621;
pub const DNS_ERROR_ZONE_LOCKED_FOR_SIGNING : i32 = 9622;
pub const DNS_ERROR_DATAFILE_BASE : i32 = 9650;
pub const DNS_ERROR_PRIMARY_REQUIRES_DATAFILE : i32 = 9651;
pub const DNS_ERROR_INVALID_DATAFILE_NAME : i32 = 9652;
pub const DNS_ERROR_DATAFILE_OPEN_FAILURE : i32 = 9653;
pub const DNS_ERROR_FILE_WRITEBACK_FAILED : i32 = 9654;
pub const DNS_ERROR_DATAFILE_PARSING : i32 = 9655;
pub const DNS_ERROR_DATABASE_BASE : i32 = 9700;
pub const DNS_ERROR_RECORD_DOES_NOT_EXIST : i32 = 9701;
pub const DNS_ERROR_RECORD_FORMAT : i32 = 9702;
pub const DNS_ERROR_NODE_CREATION_FAILED : i32 = 9703;
pub const DNS_ERROR_UNKNOWN_RECORD_TYPE : i32 = 9704;
pub const DNS_ERROR_RECORD_TIMED_OUT : i32 = 9705;
pub const DNS_ERROR_NAME_NOT_IN_ZONE : i32 = 9706;
pub const DNS_ERROR_CNAME_LOOP : i32 = 9707;
pub const DNS_ERROR_NODE_IS_CNAME : i32 = 9708;
pub const DNS_ERROR_CNAME_COLLISION : i32 = 9709;
pub const DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT : i32 = 9710;
pub const DNS_ERROR_RECORD_ALREADY_EXISTS : i32 = 9711;
pub const DNS_ERROR_SECONDARY_DATA : i32 = 9712;
pub const DNS_ERROR_NO_CREATE_CACHE_DATA : i32 = 9713;
pub const DNS_ERROR_NAME_DOES_NOT_EXIST : i32 = 9714;
pub const DNS_WARNING_PTR_CREATE_FAILED : i32 = 9715;
pub const DNS_WARNING_DOMAIN_UNDELETED : i32 = 9716;
pub const DNS_ERROR_DS_UNAVAILABLE : i32 = 9717;
pub const DNS_ERROR_DS_ZONE_ALREADY_EXISTS : i32 = 9718;
pub const DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE : i32 = 9719;
pub const DNS_ERROR_NODE_IS_DNAME : i32 = 9720;
pub const DNS_ERROR_DNAME_COLLISION : i32 = 9721;
pub const DNS_ERROR_ALIAS_LOOP : i32 = 9722;
pub const DNS_ERROR_OPERATION_BASE : i32 = 9750;
pub const DNS_INFO_AXFR_COMPLETE : i32 = 9751;
pub const DNS_ERROR_AXFR : i32 = 9752;
pub const DNS_INFO_ADDED_LOCAL_WINS : i32 = 9753;
pub const DNS_ERROR_SECURE_BASE : i32 = 9800;
pub const DNS_STATUS_CONTINUE_NEEDED : i32 = 9801;
pub const DNS_ERROR_SETUP_BASE : i32 = 9850;
pub const DNS_ERROR_NO_TCPIP : i32 = 9851;
pub const DNS_ERROR_NO_DNS_SERVERS : i32 = 9852;
pub const DNS_ERROR_DP_BASE : i32 = 9900;
pub const DNS_ERROR_DP_DOES_NOT_EXIST : i32 = 9901;
pub const DNS_ERROR_DP_ALREADY_EXISTS : i32 = 9902;
pub const DNS_ERROR_DP_NOT_ENLISTED : i32 = 9903;
pub const DNS_ERROR_DP_ALREADY_ENLISTED : i32 = 9904;
pub const DNS_ERROR_DP_NOT_AVAILABLE : i32 = 9905;
pub const DNS_ERROR_DP_FSMO_ERROR : i32 = 9906;
pub const DNS_ERROR_RRL_NOT_ENABLED : i32 = 9911;
pub const DNS_ERROR_RRL_INVALID_WINDOW_SIZE : i32 = 9912;
pub const DNS_ERROR_RRL_INVALID_IPV4_PREFIX : i32 = 9913;
pub const DNS_ERROR_RRL_INVALID_IPV6_PREFIX : i32 = 9914;
pub const DNS_ERROR_RRL_INVALID_TC_RATE : i32 = 9915;
pub const DNS_ERROR_RRL_INVALID_LEAK_RATE : i32 = 9916;
pub const DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE : i32 = 9917;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS : i32 = 9921;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST : i32 = 9922;
pub const DNS_ERROR_VIRTUALIZATION_TREE_LOCKED : i32 = 9923;
pub const DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME : i32 = 9924;
pub const DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE : i32 = 9925;
pub const DNS_ERROR_ZONESCOPE_ALREADY_EXISTS : i32 = 9951;
pub const DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST : i32 = 9952;
pub const DNS_ERROR_DEFAULT_ZONESCOPE : i32 = 9953;
pub const DNS_ERROR_INVALID_ZONESCOPE_NAME : i32 = 9954;
pub const DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES : i32 = 9955;
pub const DNS_ERROR_LOAD_ZONESCOPE_FAILED : i32 = 9956;
pub const DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED : i32 = 9957;
pub const DNS_ERROR_INVALID_SCOPE_NAME : i32 = 9958;
pub const DNS_ERROR_SCOPE_DOES_NOT_EXIST : i32 = 9959;
pub const DNS_ERROR_DEFAULT_SCOPE : i32 = 9960;
pub const DNS_ERROR_INVALID_SCOPE_OPERATION : i32 = 9961;
pub const DNS_ERROR_SCOPE_LOCKED : i32 = 9962;
pub const DNS_ERROR_SCOPE_ALREADY_EXISTS : i32 = 9963;
pub const DNS_ERROR_POLICY_ALREADY_EXISTS : i32 = 9971;
pub const DNS_ERROR_POLICY_DOES_NOT_EXIST : i32 = 9972;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA : i32 = 9973;
pub const DNS_ERROR_POLICY_INVALID_SETTINGS : i32 = 9974;
pub const DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED : i32 = 9975;
pub const DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST : i32 = 9976;
pub const DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS : i32 = 9977;
pub const DNS_ERROR_SUBNET_DOES_NOT_EXIST : i32 = 9978;
pub const DNS_ERROR_SUBNET_ALREADY_EXISTS : i32 = 9979;
pub const DNS_ERROR_POLICY_LOCKED : i32 = 9980;
pub const DNS_ERROR_POLICY_INVALID_WEIGHT : i32 = 9981;
pub const DNS_ERROR_POLICY_INVALID_NAME : i32 = 9982;
pub const DNS_ERROR_POLICY_MISSING_CRITERIA : i32 = 9983;
pub const DNS_ERROR_INVALID_CLIENT_SUBNET_NAME : i32 = 9984;
pub const DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID : i32 = 9985;
pub const DNS_ERROR_POLICY_SCOPE_MISSING : i32 = 9986;
pub const DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED : i32 = 9987;
pub const DNS_ERROR_SERVERSCOPE_IS_REFERENCED : i32 = 9988;
pub const DNS_ERROR_ZONESCOPE_IS_REFERENCED : i32 = 9989;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET : i32 = 9990;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL : i32 = 9991;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL : i32 = 9992;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE : i32 = 9993;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN : i32 = 9994;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE : i32 = 9995;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY : i32 = 9996;
pub const WSABASEERR : i32 = 10000;
pub const WSAEINTR : i32 = 10004;
pub const WSAEBADF : i32 = 10009;
pub const WSAEACCES : i32 = 10013;
pub const WSAEFAULT : i32 = 10014;
pub const WSAEINVAL : i32 = 10022;
pub const WSAEMFILE : i32 = 10024;
pub const WSAEWOULDBLOCK : i32 = 10035;
pub const WSAEINPROGRESS : i32 = 10036;
pub const WSAEALREADY : i32 = 10037;
pub const WSAENOTSOCK : i32 = 10038;
pub const WSAEDESTADDRREQ : i32 = 10039;
pub const WSAEMSGSIZE : i32 = 10040;
pub const WSAEPROTOTYPE : i32 = 10041;
pub const WSAENOPROTOOPT : i32 = 10042;
pub const WSAEPROTONOSUPPORT : i32 = 10043;
pub const WSAESOCKTNOSUPPORT : i32 = 10044;
pub const WSAEOPNOTSUPP : i32 = 10045;
pub const WSAEPFNOSUPPORT : i32 = 10046;
pub const WSAEAFNOSUPPORT : i32 = 10047;
pub const WSAEADDRINUSE : i32 = 10048;
pub const WSAEADDRNOTAVAIL : i32 = 10049;
pub const WSAENETDOWN : i32 = 10050;
pub const WSAENETUNREACH : i32 = 10051;
pub const WSAENETRESET : i32 = 10052;
pub const WSAECONNABORTED : i32 = 10053;
pub const WSAECONNRESET : i32 = 10054;
pub const WSAENOBUFS : i32 = 10055;
pub const WSAEISCONN : i32 = 10056;
pub const WSAENOTCONN : i32 = 10057;
pub const WSAESHUTDOWN : i32 = 10058;
pub const WSAETOOMANYREFS : i32 = 10059;
pub const WSAETIMEDOUT : i32 = 10060;
pub const WSAECONNREFUSED : i32 = 10061;
pub const WSAELOOP : i32 = 10062;
pub const WSAENAMETOOLONG : i32 = 10063;
pub const WSAEHOSTDOWN : i32 = 10064;
pub const WSAEHOSTUNREACH : i32 = 10065;
pub const WSAENOTEMPTY : i32 = 10066;
pub const WSAEPROCLIM : i32 = 10067;
pub const WSAEUSERS : i32 = 10068;
pub const WSAEDQUOT : i32 = 10069;
pub const WSAESTALE : i32 = 10070;
pub const WSAEREMOTE : i32 = 10071;
pub const WSASYSNOTREADY : i32 = 10091;
pub const WSAVERNOTSUPPORTED : i32 = 10092;
pub const WSANOTINITIALISED : i32 = 10093;
pub const WSAEDISCON : i32 = 10101;
pub const WSAENOMORE : i32 = 10102;
pub const WSAECANCELLED : i32 = 10103;
pub const WSAEINVALIDPROCTABLE : i32 = 10104;
pub const WSAEINVALIDPROVIDER : i32 = 10105;
pub const WSAEPROVIDERFAILEDINIT : i32 = 10106;
pub const WSASYSCALLFAILURE : i32 = 10107;
pub const WSASERVICE_NOT_FOUND : i32 = 10108;
pub const WSATYPE_NOT_FOUND : i32 = 10109;
pub const WSA_E_NO_MORE : i32 = 10110;
pub const WSA_E_CANCELLED : i32 = 10111;
pub const WSAEREFUSED : i32 = 10112;
pub const WSAHOST_NOT_FOUND : i32 = 11001;
pub const WSATRY_AGAIN : i32 = 11002;
pub const WSANO_RECOVERY : i32 = 11003;
pub const WSANO_DATA : i32 = 11004;
pub const WSA_QOS_RECEIVERS : i32 = 11005;
pub const WSA_QOS_SENDERS : i32 = 11006;
pub const WSA_QOS_NO_SENDERS : i32 = 11007;
pub const WSA_QOS_NO_RECEIVERS : i32 = 11008;
pub const WSA_QOS_REQUEST_CONFIRMED : i32 = 11009;
pub const WSA_QOS_ADMISSION_FAILURE : i32 = 11010;
pub const WSA_QOS_POLICY_FAILURE : i32 = 11011;
pub const WSA_QOS_BAD_STYLE : i32 = 11012;
pub const WSA_QOS_BAD_OBJECT : i32 = 11013;
pub const WSA_QOS_TRAFFIC_CTRL_ERROR : i32 = 11014;
pub const WSA_QOS_GENERIC_ERROR : i32 = 11015;
pub const WSA_QOS_ESERVICETYPE : i32 = 11016;
pub const WSA_QOS_EFLOWSPEC : i32 = 11017;
pub const WSA_QOS_EPROVSPECBUF : i32 = 11018;
pub const WSA_QOS_EFILTERSTYLE : i32 = 11019;
pub const WSA_QOS_EFILTERTYPE : i32 = 11020;
pub const WSA_QOS_EFILTERCOUNT : i32 = 11021;
pub const WSA_QOS_EOBJLENGTH : i32 = 11022;
pub const WSA_QOS_EFLOWCOUNT : i32 = 11023;
pub const WSA_QOS_EUNKOWNPSOBJ : i32 = 11024;
pub const WSA_QOS_EPOLICYOBJ : i32 = 11025;
pub const WSA_QOS_EFLOWDESC : i32 = 11026;
pub const WSA_QOS_EPSFLOWSPEC : i32 = 11027;
pub const WSA_QOS_EPSFILTERSPEC : i32 = 11028;
pub const WSA_QOS_ESDMODEOBJ : i32 = 11029;
pub const WSA_QOS_ESHAPERATEOBJ : i32 = 11030;
pub const WSA_QOS_RESERVED_PETYPE : i32 = 11031;
pub const WSA_SECURE_HOST_NOT_FOUND : i32 = 11032;
pub const WSA_IPSEC_NAME_POLICY_ERROR : i32 = 11033;
pub const ERROR_IPSEC_QM_POLICY_EXISTS : i32 = 13000;
pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND : i32 = 13001;
pub const ERROR_IPSEC_QM_POLICY_IN_USE : i32 = 13002;
pub const ERROR_IPSEC_MM_POLICY_EXISTS : i32 = 13003;
pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND : i32 = 13004;
pub const ERROR_IPSEC_MM_POLICY_IN_USE : i32 = 13005;
pub const ERROR_IPSEC_MM_FILTER_EXISTS : i32 = 13006;
pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND : i32 = 13007;
pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS : i32 = 13008;
pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND : i32 = 13009;
pub const ERROR_IPSEC_MM_AUTH_EXISTS : i32 = 13010;
pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND : i32 = 13011;
pub const ERROR_IPSEC_MM_AUTH_IN_USE : i32 = 13012;
pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND : i32 = 13013;
pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND : i32 = 13014;
pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND : i32 = 13015;
pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS : i32 = 13016;
pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND : i32 = 13017;
pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION : i32 = 13018;
pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION : i32 = 13019;
pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION : i32 = 13020;
pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION : i32 = 13021;
pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION : i32 = 13022;
pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION : i32 = 13023;
pub const WARNING_IPSEC_MM_POLICY_PRUNED : i32 = 13024;
pub const WARNING_IPSEC_QM_POLICY_PRUNED : i32 = 13025;
pub const ERROR_IPSEC_IKE_NEG_STATUS_BEGIN : i32 = 13800;
pub const ERROR_IPSEC_IKE_AUTH_FAIL : i32 = 13801;
pub const ERROR_IPSEC_IKE_ATTRIB_FAIL : i32 = 13802;
pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING : i32 = 13803;
pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR : i32 = 13804;
pub const ERROR_IPSEC_IKE_TIMED_OUT : i32 = 13805;
pub const ERROR_IPSEC_IKE_NO_CERT : i32 = 13806;
pub const ERROR_IPSEC_IKE_SA_DELETED : i32 = 13807;
pub const ERROR_IPSEC_IKE_SA_REAPED : i32 = 13808;
pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP : i32 = 13809;
pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP : i32 = 13810;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM : i32 = 13811;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM : i32 = 13812;
pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE : i32 = 13813;
pub const ERROR_IPSEC_IKE_MM_DELAY_DROP : i32 = 13814;
pub const ERROR_IPSEC_IKE_QM_DELAY_DROP : i32 = 13815;
pub const ERROR_IPSEC_IKE_ERROR : i32 = 13816;
pub const ERROR_IPSEC_IKE_CRL_FAILED : i32 = 13817;
pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE : i32 = 13818;
pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE : i32 = 13819;
pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY : i32 = 13820;
pub const ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY : i32 = 13821;
pub const ERROR_IPSEC_IKE_DH_FAIL : i32 = 13822;
pub const ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED : i32 = 13823;
pub const ERROR_IPSEC_IKE_INVALID_HEADER : i32 = 13824;
pub const ERROR_IPSEC_IKE_NO_POLICY : i32 = 13825;
pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE : i32 = 13826;
pub const ERROR_IPSEC_IKE_KERBEROS_ERROR : i32 = 13827;
pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY : i32 = 13828;
pub const ERROR_IPSEC_IKE_PROCESS_ERR : i32 = 13829;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA : i32 = 13830;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP : i32 = 13831;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS : i32 = 13832;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE : i32 = 13833;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID : i32 = 13834;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT : i32 = 13835;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ : i32 = 13836;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH : i32 = 13837;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG : i32 = 13838;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE : i32 = 13839;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY : i32 = 13840;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE : i32 = 13841;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR : i32 = 13842;
pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD : i32 = 13843;
pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA : i32 = 13844;
pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN : i32 = 13845;
pub const ERROR_IPSEC_IKE_INVALID_COOKIE : i32 = 13846;
pub const ERROR_IPSEC_IKE_NO_PEER_CERT : i32 = 13847;
pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED : i32 = 13848;
pub const ERROR_IPSEC_IKE_POLICY_CHANGE : i32 = 13849;
pub const ERROR_IPSEC_IKE_NO_MM_POLICY : i32 = 13850;
pub const ERROR_IPSEC_IKE_NOTCBPRIV : i32 = 13851;
pub const ERROR_IPSEC_IKE_SECLOADFAIL : i32 = 13852;
pub const ERROR_IPSEC_IKE_FAILSSPINIT : i32 = 13853;
pub const ERROR_IPSEC_IKE_FAILQUERYSSP : i32 = 13854;
pub const ERROR_IPSEC_IKE_SRVACQFAIL : i32 = 13855;
pub const ERROR_IPSEC_IKE_SRVQUERYCRED : i32 = 13856;
pub const ERROR_IPSEC_IKE_GETSPIFAIL : i32 = 13857;
pub const ERROR_IPSEC_IKE_INVALID_FILTER : i32 = 13858;
pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY : i32 = 13859;
pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED : i32 = 13860;
pub const ERROR_IPSEC_IKE_INVALID_POLICY : i32 = 13861;
pub const ERROR_IPSEC_IKE_UNKNOWN_DOI : i32 = 13862;
pub const ERROR_IPSEC_IKE_INVALID_SITUATION : i32 = 13863;
pub const ERROR_IPSEC_IKE_DH_FAILURE : i32 = 13864;
pub const ERROR_IPSEC_IKE_INVALID_GROUP : i32 = 13865;
pub const ERROR_IPSEC_IKE_ENCRYPT : i32 = 13866;
pub const ERROR_IPSEC_IKE_DECRYPT : i32 = 13867;
pub const ERROR_IPSEC_IKE_POLICY_MATCH : i32 = 13868;
pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID : i32 = 13869;
pub const ERROR_IPSEC_IKE_INVALID_HASH : i32 = 13870;
pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG : i32 = 13871;
pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE : i32 = 13872;
pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG : i32 = 13873;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG : i32 = 13874;
pub const ERROR_IPSEC_IKE_INVALID_SIG : i32 = 13875;
pub const ERROR_IPSEC_IKE_LOAD_FAILED : i32 = 13876;
pub const ERROR_IPSEC_IKE_RPC_DELETE : i32 = 13877;
pub const ERROR_IPSEC_IKE_BENIGN_REINIT : i32 = 13878;
pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY : i32 = 13879;
pub const ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION : i32 = 13880;
pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN : i32 = 13881;
pub const ERROR_IPSEC_IKE_MM_LIMIT : i32 = 13882;
pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED : i32 = 13883;
pub const ERROR_IPSEC_IKE_QM_LIMIT : i32 = 13884;
pub const ERROR_IPSEC_IKE_MM_EXPIRED : i32 = 13885;
pub const ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID : i32 = 13886;
pub const ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH : i32 = 13887;
pub const ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID : i32 = 13888;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD : i32 = 13889;
pub const ERROR_IPSEC_IKE_DOS_COOKIE_SENT : i32 = 13890;
pub const ERROR_IPSEC_IKE_SHUTTING_DOWN : i32 = 13891;
pub const ERROR_IPSEC_IKE_CGA_AUTH_FAILED : i32 = 13892;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NATOA : i32 = 13893;
pub const ERROR_IPSEC_IKE_INVALID_MM_FOR_QM : i32 = 13894;
pub const ERROR_IPSEC_IKE_QM_EXPIRED : i32 = 13895;
pub const ERROR_IPSEC_IKE_TOO_MANY_FILTERS : i32 = 13896;
pub const ERROR_IPSEC_IKE_NEG_STATUS_END : i32 = 13897;
pub const ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL : i32 = 13898;
pub const ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE : i32 = 13899;
pub const ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING : i32 = 13900;
pub const ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING : i32 = 13901;
pub const ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS : i32 = 13902;
pub const ERROR_IPSEC_IKE_RATELIMIT_DROP : i32 = 13903;
pub const ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE : i32 = 13904;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE : i32 = 13905;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE : i32 = 13906;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY : i32 = 13907;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE : i32 = 13908;
pub const ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END : i32 = 13909;
pub const ERROR_IPSEC_BAD_SPI : i32 = 13910;
pub const ERROR_IPSEC_SA_LIFETIME_EXPIRED : i32 = 13911;
pub const ERROR_IPSEC_WRONG_SA : i32 = 13912;
pub const ERROR_IPSEC_REPLAY_CHECK_FAILED : i32 = 13913;
pub const ERROR_IPSEC_INVALID_PACKET : i32 = 13914;
pub const ERROR_IPSEC_INTEGRITY_CHECK_FAILED : i32 = 13915;
pub const ERROR_IPSEC_CLEAR_TEXT_DROP : i32 = 13916;
pub const ERROR_IPSEC_AUTH_FIREWALL_DROP : i32 = 13917;
pub const ERROR_IPSEC_THROTTLE_DROP : i32 = 13918;
pub const ERROR_IPSEC_DOSP_BLOCK : i32 = 13925;
pub const ERROR_IPSEC_DOSP_RECEIVED_MULTICAST : i32 = 13926;
pub const ERROR_IPSEC_DOSP_INVALID_PACKET : i32 = 13927;
pub const ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED : i32 = 13928;
pub const ERROR_IPSEC_DOSP_MAX_ENTRIES : i32 = 13929;
pub const ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED : i32 = 13930;
pub const ERROR_IPSEC_DOSP_NOT_INSTALLED : i32 = 13931;
pub const ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES : i32 = 13932;
pub const ERROR_SXS_SECTION_NOT_FOUND : i32 = 14000;
pub const ERROR_SXS_CANT_GEN_ACTCTX : i32 = 14001;
pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT : i32 = 14002;
pub const ERROR_SXS_ASSEMBLY_NOT_FOUND : i32 = 14003;
pub const ERROR_SXS_MANIFEST_FORMAT_ERROR : i32 = 14004;
pub const ERROR_SXS_MANIFEST_PARSE_ERROR : i32 = 14005;
pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED : i32 = 14006;
pub const ERROR_SXS_KEY_NOT_FOUND : i32 = 14007;
pub const ERROR_SXS_VERSION_CONFLICT : i32 = 14008;
pub const ERROR_SXS_WRONG_SECTION_TYPE : i32 = 14009;
pub const ERROR_SXS_THREAD_QUERIES_DISABLED : i32 = 14010;
pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET : i32 = 14011;
pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP : i32 = 14012;
pub const ERROR_SXS_UNKNOWN_ENCODING : i32 = 14013;
pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI : i32 = 14014;
pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED : i32 = 14015;
pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED : i32 = 14016;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE : i32 = 14017;
pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE : i32 = 14018;
pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE : i32 = 14019;
pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT : i32 = 14020;
pub const ERROR_SXS_DUPLICATE_DLL_NAME : i32 = 14021;
pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME : i32 = 14022;
pub const ERROR_SXS_DUPLICATE_CLSID : i32 = 14023;
pub const ERROR_SXS_DUPLICATE_IID : i32 = 14024;
pub const ERROR_SXS_DUPLICATE_TLBID : i32 = 14025;
pub const ERROR_SXS_DUPLICATE_PROGID : i32 = 14026;
pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME : i32 = 14027;
pub const ERROR_SXS_FILE_HASH_MISMATCH : i32 = 14028;
pub const ERROR_SXS_POLICY_PARSE_ERROR : i32 = 14029;
pub const ERROR_SXS_XML_E_MISSINGQUOTE : i32 = 14030;
pub const ERROR_SXS_XML_E_COMMENTSYNTAX : i32 = 14031;
pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR : i32 = 14032;
pub const ERROR_SXS_XML_E_BADNAMECHAR : i32 = 14033;
pub const ERROR_SXS_XML_E_BADCHARINSTRING : i32 = 14034;
pub const ERROR_SXS_XML_E_XMLDECLSYNTAX : i32 = 14035;
pub const ERROR_SXS_XML_E_BADCHARDATA : i32 = 14036;
pub const ERROR_SXS_XML_E_MISSINGWHITESPACE : i32 = 14037;
pub const ERROR_SXS_XML_E_EXPECTINGTAGEND : i32 = 14038;
pub const ERROR_SXS_XML_E_MISSINGSEMICOLON : i32 = 14039;
pub const ERROR_SXS_XML_E_UNBALANCEDPAREN : i32 = 14040;
pub const ERROR_SXS_XML_E_INTERNALERROR : i32 = 14041;
pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE : i32 = 14042;
pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING : i32 = 14043;
pub const ERROR_SXS_XML_E_MISSING_PAREN : i32 = 14044;
pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE : i32 = 14045;
pub const ERROR_SXS_XML_E_MULTIPLE_COLONS : i32 = 14046;
pub const ERROR_SXS_XML_E_INVALID_DECIMAL : i32 = 14047;
pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL : i32 = 14048;
pub const ERROR_SXS_XML_E_INVALID_UNICODE : i32 = 14049;
pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK : i32 = 14050;
pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG : i32 = 14051;
pub const ERROR_SXS_XML_E_UNCLOSEDTAG : i32 = 14052;
pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE : i32 = 14053;
pub const ERROR_SXS_XML_E_MULTIPLEROOTS : i32 = 14054;
pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL : i32 = 14055;
pub const ERROR_SXS_XML_E_BADXMLDECL : i32 = 14056;
pub const ERROR_SXS_XML_E_MISSINGROOT : i32 = 14057;
pub const ERROR_SXS_XML_E_UNEXPECTEDEOF : i32 = 14058;
pub const ERROR_SXS_XML_E_BADPEREFINSUBSET : i32 = 14059;
pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG : i32 = 14060;
pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG : i32 = 14061;
pub const ERROR_SXS_XML_E_UNCLOSEDSTRING : i32 = 14062;
pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT : i32 = 14063;
pub const ERROR_SXS_XML_E_UNCLOSEDDECL : i32 = 14064;
pub const ERROR_SXS_XML_E_UNCLOSEDCDATA : i32 = 14065;
pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE : i32 = 14066;
pub const ERROR_SXS_XML_E_INVALIDENCODING : i32 = 14067;
pub const ERROR_SXS_XML_E_INVALIDSWITCH : i32 = 14068;
pub const ERROR_SXS_XML_E_BADXMLCASE : i32 = 14069;
pub const ERROR_SXS_XML_E_INVALID_STANDALONE : i32 = 14070;
pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE : i32 = 14071;
pub const ERROR_SXS_XML_E_INVALID_VERSION : i32 = 14072;
pub const ERROR_SXS_XML_E_MISSINGEQUALS : i32 = 14073;
pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED : i32 = 14074;
pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT : i32 = 14075;
pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID : i32 = 14076;
pub const ERROR_SXS_UNTRANSLATABLE_HRESULT : i32 = 14077;
pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING : i32 = 14078;
pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE : i32 = 14079;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME : i32 = 14080;
pub const ERROR_SXS_ASSEMBLY_MISSING : i32 = 14081;
pub const ERROR_SXS_CORRUPT_ACTIVATION_STACK : i32 = 14082;
pub const ERROR_SXS_CORRUPTION : i32 = 14083;
pub const ERROR_SXS_EARLY_DEACTIVATION : i32 = 14084;
pub const ERROR_SXS_INVALID_DEACTIVATION : i32 = 14085;
pub const ERROR_SXS_MULTIPLE_DEACTIVATION : i32 = 14086;
pub const ERROR_SXS_PROCESS_TERMINATION_REQUESTED : i32 = 14087;
pub const ERROR_SXS_RELEASE_ACTIVATION_CONTEXT : i32 = 14088;
pub const ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY : i32 = 14089;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE : i32 = 14090;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME : i32 = 14091;
pub const ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE : i32 = 14092;
pub const ERROR_SXS_IDENTITY_PARSE_ERROR : i32 = 14093;
pub const ERROR_MALFORMED_SUBSTITUTION_STRING : i32 = 14094;
pub const ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN : i32 = 14095;
pub const ERROR_UNMAPPED_SUBSTITUTION_STRING : i32 = 14096;
pub const ERROR_SXS_ASSEMBLY_NOT_LOCKED : i32 = 14097;
pub const ERROR_SXS_COMPONENT_STORE_CORRUPT : i32 = 14098;
pub const ERROR_ADVANCED_INSTALLER_FAILED : i32 = 14099;
pub const ERROR_XML_ENCODING_MISMATCH : i32 = 14100;
pub const ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT : i32 = 14101;
pub const ERROR_SXS_IDENTITIES_DIFFERENT : i32 = 14102;
pub const ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT : i32 = 14103;
pub const ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY : i32 = 14104;
pub const ERROR_SXS_MANIFEST_TOO_BIG : i32 = 14105;
pub const ERROR_SXS_SETTING_NOT_REGISTERED : i32 = 14106;
pub const ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE : i32 = 14107;
pub const ERROR_SMI_PRIMITIVE_INSTALLER_FAILED : i32 = 14108;
pub const ERROR_GENERIC_COMMAND_FAILED : i32 = 14109;
pub const ERROR_SXS_FILE_HASH_MISSING : i32 = 14110;
pub const ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS : i32 = 14111;
pub const ERROR_EVT_INVALID_CHANNEL_PATH : i32 = 15000;
pub const ERROR_EVT_INVALID_QUERY : i32 = 15001;
pub const ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND : i32 = 15002;
pub const ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND : i32 = 15003;
pub const ERROR_EVT_INVALID_PUBLISHER_NAME : i32 = 15004;
pub const ERROR_EVT_INVALID_EVENT_DATA : i32 = 15005;
pub const ERROR_EVT_CHANNEL_NOT_FOUND : i32 = 15007;
pub const ERROR_EVT_MALFORMED_XML_TEXT : i32 = 15008;
pub const ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL : i32 = 15009;
pub const ERROR_EVT_CONFIGURATION_ERROR : i32 = 15010;
pub const ERROR_EVT_QUERY_RESULT_STALE : i32 = 15011;
pub const ERROR_EVT_QUERY_RESULT_INVALID_POSITION : i32 = 15012;
pub const ERROR_EVT_NON_VALIDATING_MSXML : i32 = 15013;
pub const ERROR_EVT_FILTER_ALREADYSCOPED : i32 = 15014;
pub const ERROR_EVT_FILTER_NOTELTSET : i32 = 15015;
pub const ERROR_EVT_FILTER_INVARG : i32 = 15016;
pub const ERROR_EVT_FILTER_INVTEST : i32 = 15017;
pub const ERROR_EVT_FILTER_INVTYPE : i32 = 15018;
pub const ERROR_EVT_FILTER_PARSEERR : i32 = 15019;
pub const ERROR_EVT_FILTER_UNSUPPORTEDOP : i32 = 15020;
pub const ERROR_EVT_FILTER_UNEXPECTEDTOKEN : i32 = 15021;
pub const ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL : i32 = 15022;
pub const ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE : i32 = 15023;
pub const ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE : i32 = 15024;
pub const ERROR_EVT_CHANNEL_CANNOT_ACTIVATE : i32 = 15025;
pub const ERROR_EVT_FILTER_TOO_COMPLEX : i32 = 15026;
pub const ERROR_EVT_MESSAGE_NOT_FOUND : i32 = 15027;
pub const ERROR_EVT_MESSAGE_ID_NOT_FOUND : i32 = 15028;
pub const ERROR_EVT_UNRESOLVED_VALUE_INSERT : i32 = 15029;
pub const ERROR_EVT_UNRESOLVED_PARAMETER_INSERT : i32 = 15030;
pub const ERROR_EVT_MAX_INSERTS_REACHED : i32 = 15031;
pub const ERROR_EVT_EVENT_DEFINITION_NOT_FOUND : i32 = 15032;
pub const ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND : i32 = 15033;
pub const ERROR_EVT_VERSION_TOO_OLD : i32 = 15034;
pub const ERROR_EVT_VERSION_TOO_NEW : i32 = 15035;
pub const ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY : i32 = 15036;
pub const ERROR_EVT_PUBLISHER_DISABLED : i32 = 15037;
pub const ERROR_EVT_FILTER_OUT_OF_RANGE : i32 = 15038;
pub const ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE : i32 = 15080;
pub const ERROR_EC_LOG_DISABLED : i32 = 15081;
pub const ERROR_EC_CIRCULAR_FORWARDING : i32 = 15082;
pub const ERROR_EC_CREDSTORE_FULL : i32 = 15083;
pub const ERROR_EC_CRED_NOT_FOUND : i32 = 15084;
pub const ERROR_EC_NO_ACTIVE_CHANNEL : i32 = 15085;
pub const ERROR_MUI_FILE_NOT_FOUND : i32 = 15100;
pub const ERROR_MUI_INVALID_FILE : i32 = 15101;
pub const ERROR_MUI_INVALID_RC_CONFIG : i32 = 15102;
pub const ERROR_MUI_INVALID_LOCALE_NAME : i32 = 15103;
pub const ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME : i32 = 15104;
pub const ERROR_MUI_FILE_NOT_LOADED : i32 = 15105;
pub const ERROR_RESOURCE_ENUM_USER_STOP : i32 = 15106;
pub const ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED : i32 = 15107;
pub const ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME : i32 = 15108;
pub const ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE : i32 = 15110;
pub const ERROR_MRM_INVALID_PRICONFIG : i32 = 15111;
pub const ERROR_MRM_INVALID_FILE_TYPE : i32 = 15112;
pub const ERROR_MRM_UNKNOWN_QUALIFIER : i32 = 15113;
pub const ERROR_MRM_INVALID_QUALIFIER_VALUE : i32 = 15114;
pub const ERROR_MRM_NO_CANDIDATE : i32 = 15115;
pub const ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE : i32 = 15116;
pub const ERROR_MRM_RESOURCE_TYPE_MISMATCH : i32 = 15117;
pub const ERROR_MRM_DUPLICATE_MAP_NAME : i32 = 15118;
pub const ERROR_MRM_DUPLICATE_ENTRY : i32 = 15119;
pub const ERROR_MRM_INVALID_RESOURCE_IDENTIFIER : i32 = 15120;
pub const ERROR_MRM_FILEPATH_TOO_LONG : i32 = 15121;
pub const ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE : i32 = 15122;
pub const ERROR_MRM_INVALID_PRI_FILE : i32 = 15126;
pub const ERROR_MRM_NAMED_RESOURCE_NOT_FOUND : i32 = 15127;
pub const ERROR_MRM_MAP_NOT_FOUND : i32 = 15135;
pub const ERROR_MRM_UNSUPPORTED_PROFILE_TYPE : i32 = 15136;
pub const ERROR_MRM_INVALID_QUALIFIER_OPERATOR : i32 = 15137;
pub const ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE : i32 = 15138;
pub const ERROR_MRM_AUTOMERGE_ENABLED : i32 = 15139;
pub const ERROR_MRM_TOO_MANY_RESOURCES : i32 = 15140;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE : i32 = 15141;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE : i32 = 15142;
pub const ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD : i32 = 15143;
pub const ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST : i32 = 15144;
pub const ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT : i32 = 15145;
pub const ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE : i32 = 15146;
pub const ERROR_MRM_GENERATION_COUNT_MISMATCH : i32 = 15147;
pub const ERROR_PRI_MERGE_VERSION_MISMATCH : i32 = 15148;
pub const ERROR_PRI_MERGE_MISSING_SCHEMA : i32 = 15149;
pub const ERROR_PRI_MERGE_LOAD_FILE_FAILED : i32 = 15150;
pub const ERROR_PRI_MERGE_ADD_FILE_FAILED : i32 = 15151;
pub const ERROR_PRI_MERGE_WRITE_FILE_FAILED : i32 = 15152;
pub const ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED : i32 = 15153;
pub const ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED : i32 = 15154;
pub const ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED : i32 = 15155;
pub const ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED : i32 = 15156;
pub const ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED : i32 = 15157;
pub const ERROR_PRI_MERGE_INVALID_FILE_NAME : i32 = 15158;
pub const ERROR_MRM_PACKAGE_NOT_FOUND : i32 = 15159;
pub const ERROR_MRM_MISSING_DEFAULT_LANGUAGE : i32 = 15160;
pub const ERROR_MCA_INVALID_CAPABILITIES_STRING : i32 = 15200;
pub const ERROR_MCA_INVALID_VCP_VERSION : i32 = 15201;
pub const ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION : i32 = 15202;
pub const ERROR_MCA_MCCS_VERSION_MISMATCH : i32 = 15203;
pub const ERROR_MCA_UNSUPPORTED_MCCS_VERSION : i32 = 15204;
pub const ERROR_MCA_INTERNAL_ERROR : i32 = 15205;
pub const ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED : i32 = 15206;
pub const ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE : i32 = 15207;
pub const ERROR_AMBIGUOUS_SYSTEM_DEVICE : i32 = 15250;
pub const ERROR_SYSTEM_DEVICE_NOT_FOUND : i32 = 15299;
pub const ERROR_HASH_NOT_SUPPORTED : i32 = 15300;
pub const ERROR_HASH_NOT_PRESENT : i32 = 15301;
pub const ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED : i32 = 15321;
pub const ERROR_GPIO_CLIENT_INFORMATION_INVALID : i32 = 15322;
pub const ERROR_GPIO_VERSION_NOT_SUPPORTED : i32 = 15323;
pub const ERROR_GPIO_INVALID_REGISTRATION_PACKET : i32 = 15324;
pub const ERROR_GPIO_OPERATION_DENIED : i32 = 15325;
pub const ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE : i32 = 15326;
pub const ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED : i32 = 15327;
pub const ERROR_CANNOT_SWITCH_RUNLEVEL : i32 = 15400;
pub const ERROR_INVALID_RUNLEVEL_SETTING : i32 = 15401;
pub const ERROR_RUNLEVEL_SWITCH_TIMEOUT : i32 = 15402;
pub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT : i32 = 15403;
pub const ERROR_RUNLEVEL_SWITCH_IN_PROGRESS : i32 = 15404;
pub const ERROR_SERVICES_FAILED_AUTOSTART : i32 = 15405;
pub const ERROR_COM_TASK_STOP_PENDING : i32 = 15501;
pub const ERROR_INSTALL_OPEN_PACKAGE_FAILED : i32 = 15600;
pub const ERROR_INSTALL_PACKAGE_NOT_FOUND : i32 = 15601;
pub const ERROR_INSTALL_INVALID_PACKAGE : i32 = 15602;
pub const ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED : i32 = 15603;
pub const ERROR_INSTALL_OUT_OF_DISK_SPACE : i32 = 15604;
pub const ERROR_INSTALL_NETWORK_FAILURE : i32 = 15605;
pub const ERROR_INSTALL_REGISTRATION_FAILURE : i32 = 15606;
pub const ERROR_INSTALL_DEREGISTRATION_FAILURE : i32 = 15607;
pub const ERROR_INSTALL_CANCEL : i32 = 15608;
pub const ERROR_INSTALL_FAILED : i32 = 15609;
pub const ERROR_REMOVE_FAILED : i32 = 15610;
pub const ERROR_PACKAGE_ALREADY_EXISTS : i32 = 15611;
pub const ERROR_NEEDS_REMEDIATION : i32 = 15612;
pub const ERROR_INSTALL_PREREQUISITE_FAILED : i32 = 15613;
pub const ERROR_PACKAGE_REPOSITORY_CORRUPTED : i32 = 15614;
pub const ERROR_INSTALL_POLICY_FAILURE : i32 = 15615;
pub const ERROR_PACKAGE_UPDATING : i32 = 15616;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_POLICY : i32 = 15617;
pub const ERROR_PACKAGES_IN_USE : i32 = 15618;
pub const ERROR_RECOVERY_FILE_CORRUPT : i32 = 15619;
pub const ERROR_INVALID_STAGED_SIGNATURE : i32 = 15620;
pub const ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED : i32 = 15621;
pub const ERROR_INSTALL_PACKAGE_DOWNGRADE : i32 = 15622;
pub const ERROR_SYSTEM_NEEDS_REMEDIATION : i32 = 15623;
pub const ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN : i32 = 15624;
pub const ERROR_RESILIENCY_FILE_CORRUPT : i32 = 15625;
pub const ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING : i32 = 15626;
pub const ERROR_PACKAGE_MOVE_FAILED : i32 = 15627;
pub const ERROR_INSTALL_VOLUME_NOT_EMPTY : i32 = 15628;
pub const ERROR_INSTALL_VOLUME_OFFLINE : i32 = 15629;
pub const ERROR_INSTALL_VOLUME_CORRUPT : i32 = 15630;
pub const ERROR_NEEDS_REGISTRATION : i32 = 15631;
pub const ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE : i32 = 15632;
pub const ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED : i32 = 15633;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE : i32 = 15634;
pub const ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM : i32 = 15635;
pub const ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING : i32 = 15636;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE : i32 = 15637;
pub const ERROR_PACKAGE_STAGING_ONHOLD : i32 = 15638;
pub const ERROR_INSTALL_INVALID_RELATED_SET_UPDATE : i32 = 15639;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY : i32 = 15640;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF : i32 = 15641;
pub const ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED : i32 = 15642;
pub const ERROR_PACKAGES_REPUTATION_CHECK_FAILED : i32 = 15643;
pub const ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT : i32 = 15644;
pub const ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED : i32 = 15645;
pub const ERROR_APPINSTALLER_ACTIVATION_BLOCKED : i32 = 15646;
pub const ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED : i32 = 15647;
pub const ERROR_APPX_RAW_DATA_WRITE_FAILED : i32 = 15648;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE : i32 = 15649;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE : i32 = 15650;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY : i32 = 15651;
pub const ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY : i32 = 15652;
pub const ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER : i32 = 15653;
pub const ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED : i32 = 15654;
pub const ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE : i32 = 15655;
pub const ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES : i32 = 15656;
pub const ERROR_REDIRECTION_TO_DEFAULT_ACCOUNT_NOT_ALLOWED : i32 = 15657;
pub const ERROR_PACKAGE_LACKS_CAPABILITY_TO_DEPLOY_ON_HOST : i32 = 15658;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_CONTENT : i32 = 15659;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE : i32 = 15660;
pub const ERROR_SIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE : i32 = 15661;
pub const ERROR_PACKAGE_EXTERNAL_LOCATION_NOT_ALLOWED : i32 = 15662;
pub const ERROR_INSTALL_FULLTRUST_HOSTRUNTIME_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY : i32 = 15663;
pub const APPMODEL_ERROR_NO_PACKAGE : i32 = 15700;
pub const APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT : i32 = 15701;
pub const APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT : i32 = 15702;
pub const APPMODEL_ERROR_NO_APPLICATION : i32 = 15703;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED : i32 = 15704;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID : i32 = 15705;
pub const APPMODEL_ERROR_PACKAGE_NOT_AVAILABLE : i32 = 15706;
pub const APPMODEL_ERROR_NO_MUTABLE_DIRECTORY : i32 = 15707;
pub const ERROR_STATE_LOAD_STORE_FAILED : i32 = 15800;
pub const ERROR_STATE_GET_VERSION_FAILED : i32 = 15801;
pub const ERROR_STATE_SET_VERSION_FAILED : i32 = 15802;
pub const ERROR_STATE_STRUCTURED_RESET_FAILED : i32 = 15803;
pub const ERROR_STATE_OPEN_CONTAINER_FAILED : i32 = 15804;
pub const ERROR_STATE_CREATE_CONTAINER_FAILED : i32 = 15805;
pub const ERROR_STATE_DELETE_CONTAINER_FAILED : i32 = 15806;
pub const ERROR_STATE_READ_SETTING_FAILED : i32 = 15807;
pub const ERROR_STATE_WRITE_SETTING_FAILED : i32 = 15808;
pub const ERROR_STATE_DELETE_SETTING_FAILED : i32 = 15809;
pub const ERROR_STATE_QUERY_SETTING_FAILED : i32 = 15810;
pub const ERROR_STATE_READ_COMPOSITE_SETTING_FAILED : i32 = 15811;
pub const ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED : i32 = 15812;
pub const ERROR_STATE_ENUMERATE_CONTAINER_FAILED : i32 = 15813;
pub const ERROR_STATE_ENUMERATE_SETTINGS_FAILED : i32 = 15814;
pub const ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED : i32 = 15815;
pub const ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED : i32 = 15816;
pub const ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED : i32 = 15817;
pub const ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED : i32 = 15818;
pub const ERROR_API_UNAVAILABLE : i32 = 15841;
pub const STORE_ERROR_UNLICENSED : i32 = 15861;
pub const STORE_ERROR_UNLICENSED_USER : i32 = 15862;
pub const STORE_ERROR_PENDING_COM_TRANSACTION : i32 = 15863;
pub const STORE_ERROR_LICENSE_REVOKED : i32 = 15864;
pub const SEVERITY_SUCCESS : i32 = 0;
pub const SEVERITY_ERROR : i32 = 1;
pub const FACILITY_NT_BIT : i32 = 268435456;
pub const NOERROR : i32 = 0;
pub const E_UNEXPECTED : i32 = -2147418113;
pub const E_NOTIMPL : i32 = -2147467263;
pub const E_OUTOFMEMORY : i32 = -2147024882;
pub const E_INVALIDARG : i32 = -2147024809;
pub const E_NOINTERFACE : i32 = -2147467262;
pub const E_POINTER : i32 = -2147467261;
pub const E_HANDLE : i32 = -2147024890;
pub const E_ABORT : i32 = -2147467260;
pub const E_FAIL : i32 = -2147467259;
pub const E_ACCESSDENIED : i32 = -2147024891;
pub const E_PENDING : i32 = -2147483638;
pub const E_BOUNDS : i32 = -2147483637;
pub const E_CHANGED_STATE : i32 = -2147483636;
pub const E_ILLEGAL_STATE_CHANGE : i32 = -2147483635;
pub const E_ILLEGAL_METHOD_CALL : i32 = -2147483634;
pub const RO_E_METADATA_NAME_NOT_FOUND : i32 = -2147483633;
pub const RO_E_METADATA_NAME_IS_NAMESPACE : i32 = -2147483632;
pub const RO_E_METADATA_INVALID_TYPE_FORMAT : i32 = -2147483631;
pub const RO_E_INVALID_METADATA_FILE : i32 = -2147483630;
pub const RO_E_CLOSED : i32 = -2147483629;
pub const RO_E_EXCLUSIVE_WRITE : i32 = -2147483628;
pub const RO_E_CHANGE_NOTIFICATION_IN_PROGRESS : i32 = -2147483627;
pub const RO_E_ERROR_STRING_NOT_FOUND : i32 = -2147483626;
pub const E_STRING_NOT_NULL_TERMINATED : i32 = -2147483625;
pub const E_ILLEGAL_DELEGATE_ASSIGNMENT : i32 = -2147483624;
pub const E_ASYNC_OPERATION_NOT_STARTED : i32 = -2147483623;
pub const E_APPLICATION_EXITING : i32 = -2147483622;
pub const E_APPLICATION_VIEW_EXITING : i32 = -2147483621;
pub const RO_E_MUST_BE_AGILE : i32 = -2147483620;
pub const RO_E_UNSUPPORTED_FROM_MTA : i32 = -2147483619;
pub const RO_E_COMMITTED : i32 = -2147483618;
pub const RO_E_BLOCKED_CROSS_ASTA_CALL : i32 = -2147483617;
pub const RO_E_CANNOT_ACTIVATE_FULL_TRUST_SERVER : i32 = -2147483616;
pub const RO_E_CANNOT_ACTIVATE_UNIVERSAL_APPLICATION_SERVER : i32 = -2147483615;
pub const CO_E_INIT_TLS : i32 = -2147467258;
pub const CO_E_INIT_SHARED_ALLOCATOR : i32 = -2147467257;
pub const CO_E_INIT_MEMORY_ALLOCATOR : i32 = -2147467256;
pub const CO_E_INIT_CLASS_CACHE : i32 = -2147467255;
pub const CO_E_INIT_RPC_CHANNEL : i32 = -2147467254;
pub const CO_E_INIT_TLS_SET_CHANNEL_CONTROL : i32 = -2147467253;
pub const CO_E_INIT_TLS_CHANNEL_CONTROL : i32 = -2147467252;
pub const CO_E_INIT_UNACCEPTED_USER_ALLOCATOR : i32 = -2147467251;
pub const CO_E_INIT_SCM_MUTEX_EXISTS : i32 = -2147467250;
pub const CO_E_INIT_SCM_FILE_MAPPING_EXISTS : i32 = -2147467249;
pub const CO_E_INIT_SCM_MAP_VIEW_OF_FILE : i32 = -2147467248;
pub const CO_E_INIT_SCM_EXEC_FAILURE : i32 = -2147467247;
pub const CO_E_INIT_ONLY_SINGLE_THREADED : i32 = -2147467246;
pub const CO_E_CANT_REMOTE : i32 = -2147467245;
pub const CO_E_BAD_SERVER_NAME : i32 = -2147467244;
pub const CO_E_WRONG_SERVER_IDENTITY : i32 = -2147467243;
pub const CO_E_OLE1DDE_DISABLED : i32 = -2147467242;
pub const CO_E_RUNAS_SYNTAX : i32 = -2147467241;
pub const CO_E_CREATEPROCESS_FAILURE : i32 = -2147467240;
pub const CO_E_RUNAS_CREATEPROCESS_FAILURE : i32 = -2147467239;
pub const CO_E_RUNAS_LOGON_FAILURE : i32 = -2147467238;
pub const CO_E_LAUNCH_PERMSSION_DENIED : i32 = -2147467237;
pub const CO_E_START_SERVICE_FAILURE : i32 = -2147467236;
pub const CO_E_REMOTE_COMMUNICATION_FAILURE : i32 = -2147467235;
pub const CO_E_SERVER_START_TIMEOUT : i32 = -2147467234;
pub const CO_E_CLSREG_INCONSISTENT : i32 = -2147467233;
pub const CO_E_IIDREG_INCONSISTENT : i32 = -2147467232;
pub const CO_E_NOT_SUPPORTED : i32 = -2147467231;
pub const CO_E_RELOAD_DLL : i32 = -2147467230;
pub const CO_E_MSI_ERROR : i32 = -2147467229;
pub const CO_E_ATTEMPT_TO_CREATE_OUTSIDE_CLIENT_CONTEXT : i32 = -2147467228;
pub const CO_E_SERVER_PAUSED : i32 = -2147467227;
pub const CO_E_SERVER_NOT_PAUSED : i32 = -2147467226;
pub const CO_E_CLASS_DISABLED : i32 = -2147467225;
pub const CO_E_CLRNOTAVAILABLE : i32 = -2147467224;
pub const CO_E_ASYNC_WORK_REJECTED : i32 = -2147467223;
pub const CO_E_SERVER_INIT_TIMEOUT : i32 = -2147467222;
pub const CO_E_NO_SECCTX_IN_ACTIVATE : i32 = -2147467221;
pub const CO_E_TRACKER_CONFIG : i32 = -2147467216;
pub const CO_E_THREADPOOL_CONFIG : i32 = -2147467215;
pub const CO_E_SXS_CONFIG : i32 = -2147467214;
pub const CO_E_MALFORMED_SPN : i32 = -2147467213;
pub const CO_E_UNREVOKED_REGISTRATION_ON_APARTMENT_SHUTDOWN : i32 = -2147467212;
pub const CO_E_PREMATURE_STUB_RUNDOWN : i32 = -2147467211;
pub const S_OK : i32 = 0;
pub const S_FALSE : i32 = 1;
pub const OLE_E_FIRST : i32 = -2147221504;
pub const OLE_E_LAST : i32 = -2147221249;
pub const OLE_S_FIRST : i32 = 262144;
pub const OLE_S_LAST : i32 = 262399;
pub const OLE_E_OLEVERB : i32 = -2147221504;
pub const OLE_E_ADVF : i32 = -2147221503;
pub const OLE_E_ENUM_NOMORE : i32 = -2147221502;
pub const OLE_E_ADVISENOTSUPPORTED : i32 = -2147221501;
pub const OLE_E_NOCONNECTION : i32 = -2147221500;
pub const OLE_E_NOTRUNNING : i32 = -2147221499;
pub const OLE_E_NOCACHE : i32 = -2147221498;
pub const OLE_E_BLANK : i32 = -2147221497;
pub const OLE_E_CLASSDIFF : i32 = -2147221496;
pub const OLE_E_CANT_GETMONIKER : i32 = -2147221495;
pub const OLE_E_CANT_BINDTOSOURCE : i32 = -2147221494;
pub const OLE_E_STATIC : i32 = -2147221493;
pub const OLE_E_PROMPTSAVECANCELLED : i32 = -2147221492;
pub const OLE_E_INVALIDRECT : i32 = -2147221491;
pub const OLE_E_WRONGCOMPOBJ : i32 = -2147221490;
pub const OLE_E_INVALIDHWND : i32 = -2147221489;
pub const OLE_E_NOT_INPLACEACTIVE : i32 = -2147221488;
pub const OLE_E_CANTCONVERT : i32 = -2147221487;
pub const OLE_E_NOSTORAGE : i32 = -2147221486;
pub const DV_E_FORMATETC : i32 = -2147221404;
pub const DV_E_DVTARGETDEVICE : i32 = -2147221403;
pub const DV_E_STGMEDIUM : i32 = -2147221402;
pub const DV_E_STATDATA : i32 = -2147221401;
pub const DV_E_LINDEX : i32 = -2147221400;
pub const DV_E_TYMED : i32 = -2147221399;
pub const DV_E_CLIPFORMAT : i32 = -2147221398;
pub const DV_E_DVASPECT : i32 = -2147221397;
pub const DV_E_DVTARGETDEVICE_SIZE : i32 = -2147221396;
pub const DV_E_NOIVIEWOBJECT : i32 = -2147221395;
pub const DRAGDROP_E_FIRST : i32 = -2147221248;
pub const DRAGDROP_E_LAST : i32 = -2147221233;
pub const DRAGDROP_S_FIRST : i32 = 262400;
pub const DRAGDROP_S_LAST : i32 = 262415;
pub const DRAGDROP_E_NOTREGISTERED : i32 = -2147221248;
pub const DRAGDROP_E_ALREADYREGISTERED : i32 = -2147221247;
pub const DRAGDROP_E_INVALIDHWND : i32 = -2147221246;
pub const DRAGDROP_E_CONCURRENT_DRAG_ATTEMPTED : i32 = -2147221245;
pub const CLASSFACTORY_E_FIRST : i32 = -2147221232;
pub const CLASSFACTORY_E_LAST : i32 = -2147221217;
pub const CLASSFACTORY_S_FIRST : i32 = 262416;
pub const CLASSFACTORY_S_LAST : i32 = 262431;
pub const CLASS_E_NOAGGREGATION : i32 = -2147221232;
pub const CLASS_E_CLASSNOTAVAILABLE : i32 = -2147221231;
pub const CLASS_E_NOTLICENSED : i32 = -2147221230;
pub const MARSHAL_E_FIRST : i32 = -2147221216;
pub const MARSHAL_E_LAST : i32 = -2147221201;
pub const MARSHAL_S_FIRST : i32 = 262432;
pub const MARSHAL_S_LAST : i32 = 262447;
pub const DATA_E_FIRST : i32 = -2147221200;
pub const DATA_E_LAST : i32 = -2147221185;
pub const DATA_S_FIRST : i32 = 262448;
pub const DATA_S_LAST : i32 = 262463;
pub const VIEW_E_FIRST : i32 = -2147221184;
pub const VIEW_E_LAST : i32 = -2147221169;
pub const VIEW_S_FIRST : i32 = 262464;
pub const VIEW_S_LAST : i32 = 262479;
pub const VIEW_E_DRAW : i32 = -2147221184;
pub const REGDB_E_FIRST : i32 = -2147221168;
pub const REGDB_E_LAST : i32 = -2147221153;
pub const REGDB_S_FIRST : i32 = 262480;
pub const REGDB_S_LAST : i32 = 262495;
pub const REGDB_E_READREGDB : i32 = -2147221168;
pub const REGDB_E_WRITEREGDB : i32 = -2147221167;
pub const REGDB_E_KEYMISSING : i32 = -2147221166;
pub const REGDB_E_INVALIDVALUE : i32 = -2147221165;
pub const REGDB_E_CLASSNOTREG : i32 = -2147221164;
pub const REGDB_E_IIDNOTREG : i32 = -2147221163;
pub const REGDB_E_BADTHREADINGMODEL : i32 = -2147221162;
pub const REGDB_E_PACKAGEPOLICYVIOLATION : i32 = -2147221161;
pub const CAT_E_FIRST : i32 = -2147221152;
pub const CAT_E_LAST : i32 = -2147221151;
pub const CAT_E_CATIDNOEXIST : i32 = -2147221152;
pub const CAT_E_NODESCRIPTION : i32 = -2147221151;
pub const CS_E_FIRST : i32 = -2147221148;
pub const CS_E_LAST : i32 = -2147221137;
pub const CS_E_PACKAGE_NOTFOUND : i32 = -2147221148;
pub const CS_E_NOT_DELETABLE : i32 = -2147221147;
pub const CS_E_CLASS_NOTFOUND : i32 = -2147221146;
pub const CS_E_INVALID_VERSION : i32 = -2147221145;
pub const CS_E_NO_CLASSSTORE : i32 = -2147221144;
pub const CS_E_OBJECT_NOTFOUND : i32 = -2147221143;
pub const CS_E_OBJECT_ALREADY_EXISTS : i32 = -2147221142;
pub const CS_E_INVALID_PATH : i32 = -2147221141;
pub const CS_E_NETWORK_ERROR : i32 = -2147221140;
pub const CS_E_ADMIN_LIMIT_EXCEEDED : i32 = -2147221139;
pub const CS_E_SCHEMA_MISMATCH : i32 = -2147221138;
pub const CS_E_INTERNAL_ERROR : i32 = -2147221137;
pub const CACHE_E_FIRST : i32 = -2147221136;
pub const CACHE_E_LAST : i32 = -2147221121;
pub const CACHE_S_FIRST : i32 = 262512;
pub const CACHE_S_LAST : i32 = 262527;
pub const CACHE_E_NOCACHE_UPDATED : i32 = -2147221136;
pub const OLEOBJ_E_FIRST : i32 = -2147221120;
pub const OLEOBJ_E_LAST : i32 = -2147221105;
pub const OLEOBJ_S_FIRST : i32 = 262528;
pub const OLEOBJ_S_LAST : i32 = 262543;
pub const OLEOBJ_E_NOVERBS : i32 = -2147221120;
pub const OLEOBJ_E_INVALIDVERB : i32 = -2147221119;
pub const CLIENTSITE_E_FIRST : i32 = -2147221104;
pub const CLIENTSITE_E_LAST : i32 = -2147221089;
pub const CLIENTSITE_S_FIRST : i32 = 262544;
pub const CLIENTSITE_S_LAST : i32 = 262559;
pub const INPLACE_E_NOTUNDOABLE : i32 = -2147221088;
pub const INPLACE_E_NOTOOLSPACE : i32 = -2147221087;
pub const INPLACE_E_FIRST : i32 = -2147221088;
pub const INPLACE_E_LAST : i32 = -2147221073;
pub const INPLACE_S_FIRST : i32 = 262560;
pub const INPLACE_S_LAST : i32 = 262575;
pub const ENUM_E_FIRST : i32 = -2147221072;
pub const ENUM_E_LAST : i32 = -2147221057;
pub const ENUM_S_FIRST : i32 = 262576;
pub const ENUM_S_LAST : i32 = 262591;
pub const CONVERT10_E_FIRST : i32 = -2147221056;
pub const CONVERT10_E_LAST : i32 = -2147221041;
pub const CONVERT10_S_FIRST : i32 = 262592;
pub const CONVERT10_S_LAST : i32 = 262607;
pub const CONVERT10_E_OLESTREAM_GET : i32 = -2147221056;
pub const CONVERT10_E_OLESTREAM_PUT : i32 = -2147221055;
pub const CONVERT10_E_OLESTREAM_FMT : i32 = -2147221054;
pub const CONVERT10_E_OLESTREAM_BITMAP_TO_DIB : i32 = -2147221053;
pub const CONVERT10_E_STG_FMT : i32 = -2147221052;
pub const CONVERT10_E_STG_NO_STD_STREAM : i32 = -2147221051;
pub const CONVERT10_E_STG_DIB_TO_BITMAP : i32 = -2147221050;
pub const CLIPBRD_E_FIRST : i32 = -2147221040;
pub const CLIPBRD_E_LAST : i32 = -2147221025;
pub const CLIPBRD_S_FIRST : i32 = 262608;
pub const CLIPBRD_S_LAST : i32 = 262623;
pub const CLIPBRD_E_CANT_OPEN : i32 = -2147221040;
pub const CLIPBRD_E_CANT_EMPTY : i32 = -2147221039;
pub const CLIPBRD_E_CANT_SET : i32 = -2147221038;
pub const CLIPBRD_E_BAD_DATA : i32 = -2147221037;
pub const CLIPBRD_E_CANT_CLOSE : i32 = -2147221036;
pub const MK_E_FIRST : i32 = -2147221024;
pub const MK_E_LAST : i32 = -2147221009;
pub const MK_S_FIRST : i32 = 262624;
pub const MK_S_LAST : i32 = 262639;
pub const MK_E_CONNECTMANUALLY : i32 = -2147221024;
pub const MK_E_EXCEEDEDDEADLINE : i32 = -2147221023;
pub const MK_E_NEEDGENERIC : i32 = -2147221022;
pub const MK_E_UNAVAILABLE : i32 = -2147221021;
pub const MK_E_SYNTAX : i32 = -2147221020;
pub const MK_E_NOOBJECT : i32 = -2147221019;
pub const MK_E_INVALIDEXTENSION : i32 = -2147221018;
pub const MK_E_INTERMEDIATEINTERFACENOTSUPPORTED : i32 = -2147221017;
pub const MK_E_NOTBINDABLE : i32 = -2147221016;
pub const MK_E_NOTBOUND : i32 = -2147221015;
pub const MK_E_CANTOPENFILE : i32 = -2147221014;
pub const MK_E_MUSTBOTHERUSER : i32 = -2147221013;
pub const MK_E_NOINVERSE : i32 = -2147221012;
pub const MK_E_NOSTORAGE : i32 = -2147221011;
pub const MK_E_NOPREFIX : i32 = -2147221010;
pub const MK_E_ENUMERATION_FAILED : i32 = -2147221009;
pub const CO_E_FIRST : i32 = -2147221008;
pub const CO_E_LAST : i32 = -2147220993;
pub const CO_S_FIRST : i32 = 262640;
pub const CO_S_LAST : i32 = 262655;
pub const CO_E_NOTINITIALIZED : i32 = -2147221008;
pub const CO_E_ALREADYINITIALIZED : i32 = -2147221007;
pub const CO_E_CANTDETERMINECLASS : i32 = -2147221006;
pub const CO_E_CLASSSTRING : i32 = -2147221005;
pub const CO_E_IIDSTRING : i32 = -2147221004;
pub const CO_E_APPNOTFOUND : i32 = -2147221003;
pub const CO_E_APPSINGLEUSE : i32 = -2147221002;
pub const CO_E_ERRORINAPP : i32 = -2147221001;
pub const CO_E_DLLNOTFOUND : i32 = -2147221000;
pub const CO_E_ERRORINDLL : i32 = -2147220999;
pub const CO_E_WRONGOSFORAPP : i32 = -2147220998;
pub const CO_E_OBJNOTREG : i32 = -2147220997;
pub const CO_E_OBJISREG : i32 = -2147220996;
pub const CO_E_OBJNOTCONNECTED : i32 = -2147220995;
pub const CO_E_APPDIDNTREG : i32 = -2147220994;
pub const CO_E_RELEASED : i32 = -2147220993;
pub const EVENT_E_FIRST : i32 = -2147220992;
pub const EVENT_E_LAST : i32 = -2147220961;
pub const EVENT_S_FIRST : i32 = 262656;
pub const EVENT_S_LAST : i32 = 262687;
pub const EVENT_S_SOME_SUBSCRIBERS_FAILED : i32 = 262656;
pub const EVENT_E_ALL_SUBSCRIBERS_FAILED : i32 = -2147220991;
pub const EVENT_S_NOSUBSCRIBERS : i32 = 262658;
pub const EVENT_E_QUERYSYNTAX : i32 = -2147220989;
pub const EVENT_E_QUERYFIELD : i32 = -2147220988;
pub const EVENT_E_INTERNALEXCEPTION : i32 = -2147220987;
pub const EVENT_E_INTERNALERROR : i32 = -2147220986;
pub const EVENT_E_INVALID_PER_USER_SID : i32 = -2147220985;
pub const EVENT_E_USER_EXCEPTION : i32 = -2147220984;
pub const EVENT_E_TOO_MANY_METHODS : i32 = -2147220983;
pub const EVENT_E_MISSING_EVENTCLASS : i32 = -2147220982;
pub const EVENT_E_NOT_ALL_REMOVED : i32 = -2147220981;
pub const EVENT_E_COMPLUS_NOT_INSTALLED : i32 = -2147220980;
pub const EVENT_E_CANT_MODIFY_OR_DELETE_UNCONFIGURED_OBJECT : i32 = -2147220979;
pub const EVENT_E_CANT_MODIFY_OR_DELETE_CONFIGURED_OBJECT : i32 = -2147220978;
pub const EVENT_E_INVALID_EVENT_CLASS_PARTITION : i32 = -2147220977;
pub const EVENT_E_PER_USER_SID_NOT_LOGGED_ON : i32 = -2147220976;
pub const TPC_E_INVALID_PROPERTY : i32 = -2147220927;
pub const TPC_E_NO_DEFAULT_TABLET : i32 = -2147220974;
pub const TPC_E_UNKNOWN_PROPERTY : i32 = -2147220965;
pub const TPC_E_INVALID_INPUT_RECT : i32 = -2147220967;
pub const TPC_E_INVALID_STROKE : i32 = -2147220958;
pub const TPC_E_INITIALIZE_FAIL : i32 = -2147220957;
pub const TPC_E_NOT_RELEVANT : i32 = -2147220942;
pub const TPC_E_INVALID_PACKET_DESCRIPTION : i32 = -2147220941;
pub const TPC_E_RECOGNIZER_NOT_REGISTERED : i32 = -2147220939;
pub const TPC_E_INVALID_RIGHTS : i32 = -2147220938;
pub const TPC_E_OUT_OF_ORDER_CALL : i32 = -2147220937;
pub const TPC_E_QUEUE_FULL : i32 = -2147220936;
pub const TPC_E_INVALID_CONFIGURATION : i32 = -2147220935;
pub const TPC_E_INVALID_DATA_FROM_RECOGNIZER : i32 = -2147220934;
pub const TPC_S_TRUNCATED : i32 = 262738;
pub const TPC_S_INTERRUPTED : i32 = 262739;
pub const TPC_S_NO_DATA_TO_PROCESS : i32 = 262740;
pub const XACT_E_FIRST : u32 = 2147799040;
pub const XACT_E_LAST : u32 = 2147799083;
pub const XACT_S_FIRST : i32 = 315392;
pub const XACT_S_LAST : i32 = 315408;
pub const XACT_E_ALREADYOTHERSINGLEPHASE : i32 = -2147168256;
pub const XACT_E_CANTRETAIN : i32 = -2147168255;
pub const XACT_E_COMMITFAILED : i32 = -2147168254;
pub const XACT_E_COMMITPREVENTED : i32 = -2147168253;
pub const XACT_E_HEURISTICABORT : i32 = -2147168252;
pub const XACT_E_HEURISTICCOMMIT : i32 = -2147168251;
pub const XACT_E_HEURISTICDAMAGE : i32 = -2147168250;
pub const XACT_E_HEURISTICDANGER : i32 = -2147168249;
pub const XACT_E_ISOLATIONLEVEL : i32 = -2147168248;
pub const XACT_E_NOASYNC : i32 = -2147168247;
pub const XACT_E_NOENLIST : i32 = -2147168246;
pub const XACT_E_NOISORETAIN : i32 = -2147168245;
pub const XACT_E_NORESOURCE : i32 = -2147168244;
pub const XACT_E_NOTCURRENT : i32 = -2147168243;
pub const XACT_E_NOTRANSACTION : i32 = -2147168242;
pub const XACT_E_NOTSUPPORTED : i32 = -2147168241;
pub const XACT_E_UNKNOWNRMGRID : i32 = -2147168240;
pub const XACT_E_WRONGSTATE : i32 = -2147168239;
pub const XACT_E_WRONGUOW : i32 = -2147168238;
pub const XACT_E_XTIONEXISTS : i32 = -2147168237;
pub const XACT_E_NOIMPORTOBJECT : i32 = -2147168236;
pub const XACT_E_INVALIDCOOKIE : i32 = -2147168235;
pub const XACT_E_INDOUBT : i32 = -2147168234;
pub const XACT_E_NOTIMEOUT : i32 = -2147168233;
pub const XACT_E_ALREADYINPROGRESS : i32 = -2147168232;
pub const XACT_E_ABORTED : i32 = -2147168231;
pub const XACT_E_LOGFULL : i32 = -2147168230;
pub const XACT_E_TMNOTAVAILABLE : i32 = -2147168229;
pub const XACT_E_CONNECTION_DOWN : i32 = -2147168228;
pub const XACT_E_CONNECTION_DENIED : i32 = -2147168227;
pub const XACT_E_REENLISTTIMEOUT : i32 = -2147168226;
pub const XACT_E_TIP_CONNECT_FAILED : i32 = -2147168225;
pub const XACT_E_TIP_PROTOCOL_ERROR : i32 = -2147168224;
pub const XACT_E_TIP_PULL_FAILED : i32 = -2147168223;
pub const XACT_E_DEST_TMNOTAVAILABLE : i32 = -2147168222;
pub const XACT_E_TIP_DISABLED : i32 = -2147168221;
pub const XACT_E_NETWORK_TX_DISABLED : i32 = -2147168220;
pub const XACT_E_PARTNER_NETWORK_TX_DISABLED : i32 = -2147168219;
pub const XACT_E_XA_TX_DISABLED : i32 = -2147168218;
pub const XACT_E_UNABLE_TO_READ_DTC_CONFIG : i32 = -2147168217;
pub const XACT_E_UNABLE_TO_LOAD_DTC_PROXY : i32 = -2147168216;
pub const XACT_E_ABORTING : i32 = -2147168215;
pub const XACT_E_PUSH_COMM_FAILURE : i32 = -2147168214;
pub const XACT_E_PULL_COMM_FAILURE : i32 = -2147168213;
pub const XACT_E_LU_TX_DISABLED : i32 = -2147168212;
pub const XACT_E_CLERKNOTFOUND : i32 = -2147168128;
pub const XACT_E_CLERKEXISTS : i32 = -2147168127;
pub const XACT_E_RECOVERYINPROGRESS : i32 = -2147168126;
pub const XACT_E_TRANSACTIONCLOSED : i32 = -2147168125;
pub const XACT_E_INVALIDLSN : i32 = -2147168124;
pub const XACT_E_REPLAYREQUEST : i32 = -2147168123;
pub const XACT_S_ASYNC : i32 = 315392;
pub const XACT_S_DEFECT : i32 = 315393;
pub const XACT_S_READONLY : i32 = 315394;
pub const XACT_S_SOMENORETAIN : i32 = 315395;
pub const XACT_S_OKINFORM : i32 = 315396;
pub const XACT_S_MADECHANGESCONTENT : i32 = 315397;
pub const XACT_S_MADECHANGESINFORM : i32 = 315398;
pub const XACT_S_ALLNORETAIN : i32 = 315399;
pub const XACT_S_ABORTING : i32 = 315400;
pub const XACT_S_SINGLEPHASE : i32 = 315401;
pub const XACT_S_LOCALLY_OK : i32 = 315402;
pub const XACT_S_LASTRESOURCEMANAGER : i32 = 315408;
pub const CONTEXT_E_FIRST : i32 = -2147164160;
pub const CONTEXT_E_LAST : i32 = -2147164113;
pub const CONTEXT_S_FIRST : i32 = 319488;
pub const CONTEXT_S_LAST : i32 = 319535;
pub const CONTEXT_E_ABORTED : i32 = -2147164158;
pub const CONTEXT_E_ABORTING : i32 = -2147164157;
pub const CONTEXT_E_NOCONTEXT : i32 = -2147164156;
pub const CONTEXT_E_WOULD_DEADLOCK : i32 = -2147164155;
pub const CONTEXT_E_SYNCH_TIMEOUT : i32 = -2147164154;
pub const CONTEXT_E_OLDREF : i32 = -2147164153;
pub const CONTEXT_E_ROLENOTFOUND : i32 = -2147164148;
pub const CONTEXT_E_TMNOTAVAILABLE : i32 = -2147164145;
pub const CO_E_ACTIVATIONFAILED : i32 = -2147164127;
pub const CO_E_ACTIVATIONFAILED_EVENTLOGGED : i32 = -2147164126;
pub const CO_E_ACTIVATIONFAILED_CATALOGERROR : i32 = -2147164125;
pub const CO_E_ACTIVATIONFAILED_TIMEOUT : i32 = -2147164124;
pub const CO_E_INITIALIZATIONFAILED : i32 = -2147164123;
pub const CONTEXT_E_NOJIT : i32 = -2147164122;
pub const CONTEXT_E_NOTRANSACTION : i32 = -2147164121;
pub const CO_E_THREADINGMODEL_CHANGED : i32 = -2147164120;
pub const CO_E_NOIISINTRINSICS : i32 = -2147164119;
pub const CO_E_NOCOOKIES : i32 = -2147164118;
pub const CO_E_DBERROR : i32 = -2147164117;
pub const CO_E_NOTPOOLED : i32 = -2147164116;
pub const CO_E_NOTCONSTRUCTED : i32 = -2147164115;
pub const CO_E_NOSYNCHRONIZATION : i32 = -2147164114;
pub const CO_E_ISOLEVELMISMATCH : i32 = -2147164113;
pub const CO_E_CALL_OUT_OF_TX_SCOPE_NOT_ALLOWED : i32 = -2147164112;
pub const CO_E_EXIT_TRANSACTION_SCOPE_NOT_CALLED : i32 = -2147164111;
pub const OLE_S_USEREG : i32 = 262144;
pub const OLE_S_STATIC : i32 = 262145;
pub const OLE_S_MAC_CLIPFORMAT : i32 = 262146;
pub const DRAGDROP_S_DROP : i32 = 262400;
pub const DRAGDROP_S_CANCEL : i32 = 262401;
pub const DRAGDROP_S_USEDEFAULTCURSORS : i32 = 262402;
pub const DATA_S_SAMEFORMATETC : i32 = 262448;
pub const VIEW_S_ALREADY_FROZEN : i32 = 262464;
pub const CACHE_S_FORMATETC_NOTSUPPORTED : i32 = 262512;
pub const CACHE_S_SAMECACHE : i32 = 262513;
pub const CACHE_S_SOMECACHES_NOTUPDATED : i32 = 262514;
pub const OLEOBJ_S_INVALIDVERB : i32 = 262528;
pub const OLEOBJ_S_CANNOT_DOVERB_NOW : i32 = 262529;
pub const OLEOBJ_S_INVALIDHWND : i32 = 262530;
pub const INPLACE_S_TRUNCATED : i32 = 262560;
pub const CONVERT10_S_NO_PRESENTATION : i32 = 262592;
pub const MK_S_REDUCED_TO_SELF : i32 = 262626;
pub const MK_S_ME : i32 = 262628;
pub const MK_S_HIM : i32 = 262629;
pub const MK_S_US : i32 = 262630;
pub const MK_S_MONIKERALREADYREGISTERED : i32 = 262631;
pub const SCHED_S_TASK_READY : i32 = 267008;
pub const SCHED_S_TASK_RUNNING : i32 = 267009;
pub const SCHED_S_TASK_DISABLED : i32 = 267010;
pub const SCHED_S_TASK_HAS_NOT_RUN : i32 = 267011;
pub const SCHED_S_TASK_NO_MORE_RUNS : i32 = 267012;
pub const SCHED_S_TASK_NOT_SCHEDULED : i32 = 267013;
pub const SCHED_S_TASK_TERMINATED : i32 = 267014;
pub const SCHED_S_TASK_NO_VALID_TRIGGERS : i32 = 267015;
pub const SCHED_S_EVENT_TRIGGER : i32 = 267016;
pub const SCHED_E_TRIGGER_NOT_FOUND : i32 = -2147216631;
pub const SCHED_E_TASK_NOT_READY : i32 = -2147216630;
pub const SCHED_E_TASK_NOT_RUNNING : i32 = -2147216629;
pub const SCHED_E_SERVICE_NOT_INSTALLED : i32 = -2147216628;
pub const SCHED_E_CANNOT_OPEN_TASK : i32 = -2147216627;
pub const SCHED_E_INVALID_TASK : i32 = -2147216626;
pub const SCHED_E_ACCOUNT_INFORMATION_NOT_SET : i32 = -2147216625;
pub const SCHED_E_ACCOUNT_NAME_NOT_FOUND : i32 = -2147216624;
pub const SCHED_E_ACCOUNT_DBASE_CORRUPT : i32 = -2147216623;
pub const SCHED_E_NO_SECURITY_SERVICES : i32 = -2147216622;
pub const SCHED_E_UNKNOWN_OBJECT_VERSION : i32 = -2147216621;
pub const SCHED_E_UNSUPPORTED_ACCOUNT_OPTION : i32 = -2147216620;
pub const SCHED_E_SERVICE_NOT_RUNNING : i32 = -2147216619;
pub const SCHED_E_UNEXPECTEDNODE : i32 = -2147216618;
pub const SCHED_E_NAMESPACE : i32 = -2147216617;
pub const SCHED_E_INVALIDVALUE : i32 = -2147216616;
pub const SCHED_E_MISSINGNODE : i32 = -2147216615;
pub const SCHED_E_MALFORMEDXML : i32 = -2147216614;
pub const SCHED_S_SOME_TRIGGERS_FAILED : i32 = 267035;
pub const SCHED_S_BATCH_LOGON_PROBLEM : i32 = 267036;
pub const SCHED_E_TOO_MANY_NODES : i32 = -2147216611;
pub const SCHED_E_PAST_END_BOUNDARY : i32 = -2147216610;
pub const SCHED_E_ALREADY_RUNNING : i32 = -2147216609;
pub const SCHED_E_USER_NOT_LOGGED_ON : i32 = -2147216608;
pub const SCHED_E_INVALID_TASK_HASH : i32 = -2147216607;
pub const SCHED_E_SERVICE_NOT_AVAILABLE : i32 = -2147216606;
pub const SCHED_E_SERVICE_TOO_BUSY : i32 = -2147216605;
pub const SCHED_E_TASK_ATTEMPTED : i32 = -2147216604;
pub const SCHED_S_TASK_QUEUED : i32 = 267045;
pub const SCHED_E_TASK_DISABLED : i32 = -2147216602;
pub const SCHED_E_TASK_NOT_V1_COMPAT : i32 = -2147216601;
pub const SCHED_E_START_ON_DEMAND : i32 = -2147216600;
pub const SCHED_E_TASK_NOT_UBPM_COMPAT : i32 = -2147216599;
pub const SCHED_E_DEPRECATED_FEATURE_USED : i32 = -2147216592;
pub const CO_E_CLASS_CREATE_FAILED : i32 = -2146959359;
pub const CO_E_SCM_ERROR : i32 = -2146959358;
pub const CO_E_SCM_RPC_FAILURE : i32 = -2146959357;
pub const CO_E_BAD_PATH : i32 = -2146959356;
pub const CO_E_SERVER_EXEC_FAILURE : i32 = -2146959355;
pub const CO_E_OBJSRV_RPC_FAILURE : i32 = -2146959354;
pub const MK_E_NO_NORMALIZED : i32 = -2146959353;
pub const CO_E_SERVER_STOPPING : i32 = -2146959352;
pub const MEM_E_INVALID_ROOT : i32 = -2146959351;
pub const MEM_E_INVALID_LINK : i32 = -2146959344;
pub const MEM_E_INVALID_SIZE : i32 = -2146959343;
pub const CO_S_NOTALLINTERFACES : i32 = 524306;
pub const CO_S_MACHINENAMENOTFOUND : i32 = 524307;
pub const CO_E_MISSING_DISPLAYNAME : i32 = -2146959339;
pub const CO_E_RUNAS_VALUE_MUST_BE_AAA : i32 = -2146959338;
pub const CO_E_ELEVATION_DISABLED : i32 = -2146959337;
pub const APPX_E_PACKAGING_INTERNAL : i32 = -2146958848;
pub const APPX_E_INTERLEAVING_NOT_ALLOWED : i32 = -2146958847;
pub const APPX_E_RELATIONSHIPS_NOT_ALLOWED : i32 = -2146958846;
pub const APPX_E_MISSING_REQUIRED_FILE : i32 = -2146958845;
pub const APPX_E_INVALID_MANIFEST : i32 = -2146958844;
pub const APPX_E_INVALID_BLOCKMAP : i32 = -2146958843;
pub const APPX_E_CORRUPT_CONTENT : i32 = -2146958842;
pub const APPX_E_BLOCK_HASH_INVALID : i32 = -2146958841;
pub const APPX_E_REQUESTED_RANGE_TOO_LARGE : i32 = -2146958840;
pub const APPX_E_INVALID_SIP_CLIENT_DATA : i32 = -2146958839;
pub const APPX_E_INVALID_KEY_INFO : i32 = -2146958838;
pub const APPX_E_INVALID_CONTENTGROUPMAP : i32 = -2146958837;
pub const APPX_E_INVALID_APPINSTALLER : i32 = -2146958836;
pub const APPX_E_DELTA_BASELINE_VERSION_MISMATCH : i32 = -2146958835;
pub const APPX_E_DELTA_PACKAGE_MISSING_FILE : i32 = -2146958834;
pub const APPX_E_INVALID_DELTA_PACKAGE : i32 = -2146958833;
pub const APPX_E_DELTA_APPENDED_PACKAGE_NOT_ALLOWED : i32 = -2146958832;
pub const APPX_E_INVALID_PACKAGING_LAYOUT : i32 = -2146958831;
pub const APPX_E_INVALID_PACKAGESIGNCONFIG : i32 = -2146958830;
pub const APPX_E_RESOURCESPRI_NOT_ALLOWED : i32 = -2146958829;
pub const APPX_E_FILE_COMPRESSION_MISMATCH : i32 = -2146958828;
pub const APPX_E_INVALID_PAYLOAD_PACKAGE_EXTENSION : i32 = -2146958827;
pub const APPX_E_INVALID_ENCRYPTION_EXCLUSION_FILE_LIST : i32 = -2146958826;
pub const BT_E_SPURIOUS_ACTIVATION : i32 = -2146958592;
pub const DISP_E_UNKNOWNINTERFACE : i32 = -2147352575;
pub const DISP_E_MEMBERNOTFOUND : i32 = -2147352573;
pub const DISP_E_PARAMNOTFOUND : i32 = -2147352572;
pub const DISP_E_TYPEMISMATCH : i32 = -2147352571;
pub const DISP_E_UNKNOWNNAME : i32 = -2147352570;
pub const DISP_E_NONAMEDARGS : i32 = -2147352569;
pub const DISP_E_BADVARTYPE : i32 = -2147352568;
pub const DISP_E_EXCEPTION : i32 = -2147352567;
pub const DISP_E_OVERFLOW : i32 = -2147352566;
pub const DISP_E_BADINDEX : i32 = -2147352565;
pub const DISP_E_UNKNOWNLCID : i32 = -2147352564;
pub const DISP_E_ARRAYISLOCKED : i32 = -2147352563;
pub const DISP_E_BADPARAMCOUNT : i32 = -2147352562;
pub const DISP_E_PARAMNOTOPTIONAL : i32 = -2147352561;
pub const DISP_E_BADCALLEE : i32 = -2147352560;
pub const DISP_E_NOTACOLLECTION : i32 = -2147352559;
pub const DISP_E_DIVBYZERO : i32 = -2147352558;
pub const DISP_E_BUFFERTOOSMALL : i32 = -2147352557;
pub const TYPE_E_BUFFERTOOSMALL : i32 = -2147319786;
pub const TYPE_E_FIELDNOTFOUND : i32 = -2147319785;
pub const TYPE_E_INVDATAREAD : i32 = -2147319784;
pub const TYPE_E_UNSUPFORMAT : i32 = -2147319783;
pub const TYPE_E_REGISTRYACCESS : i32 = -2147319780;
pub const TYPE_E_LIBNOTREGISTERED : i32 = -2147319779;
pub const TYPE_E_UNDEFINEDTYPE : i32 = -2147319769;
pub const TYPE_E_QUALIFIEDNAMEDISALLOWED : i32 = -2147319768;
pub const TYPE_E_INVALIDSTATE : i32 = -2147319767;
pub const TYPE_E_WRONGTYPEKIND : i32 = -2147319766;
pub const TYPE_E_ELEMENTNOTFOUND : i32 = -2147319765;
pub const TYPE_E_AMBIGUOUSNAME : i32 = -2147319764;
pub const TYPE_E_NAMECONFLICT : i32 = -2147319763;
pub const TYPE_E_UNKNOWNLCID : i32 = -2147319762;
pub const TYPE_E_DLLFUNCTIONNOTFOUND : i32 = -2147319761;
pub const TYPE_E_BADMODULEKIND : i32 = -2147317571;
pub const TYPE_E_SIZETOOBIG : i32 = -2147317563;
pub const TYPE_E_DUPLICATEID : i32 = -2147317562;
pub const TYPE_E_INVALIDID : i32 = -2147317553;
pub const TYPE_E_TYPEMISMATCH : i32 = -2147316576;
pub const TYPE_E_OUTOFBOUNDS : i32 = -2147316575;
pub const TYPE_E_IOERROR : i32 = -2147316574;
pub const TYPE_E_CANTCREATETMPFILE : i32 = -2147316573;
pub const TYPE_E_CANTLOADLIBRARY : i32 = -2147312566;
pub const TYPE_E_INCONSISTENTPROPFUNCS : i32 = -2147312509;
pub const TYPE_E_CIRCULARTYPE : i32 = -2147312508;
pub const STG_E_INVALIDFUNCTION : i32 = -2147287039;
pub const STG_E_FILENOTFOUND : i32 = -2147287038;
pub const STG_E_PATHNOTFOUND : i32 = -2147287037;
pub const STG_E_TOOMANYOPENFILES : i32 = -2147287036;
pub const STG_E_ACCESSDENIED : i32 = -2147287035;
pub const STG_E_INVALIDHANDLE : i32 = -2147287034;
pub const STG_E_INSUFFICIENTMEMORY : i32 = -2147287032;
pub const STG_E_INVALIDPOINTER : i32 = -2147287031;
pub const STG_E_NOMOREFILES : i32 = -2147287022;
pub const STG_E_DISKISWRITEPROTECTED : i32 = -2147287021;
pub const STG_E_SEEKERROR : i32 = -2147287015;
pub const STG_E_WRITEFAULT : i32 = -2147287011;
pub const STG_E_READFAULT : i32 = -2147287010;
pub const STG_E_SHAREVIOLATION : i32 = -2147287008;
pub const STG_E_LOCKVIOLATION : i32 = -2147287007;
pub const STG_E_FILEALREADYEXISTS : i32 = -2147286960;
pub const STG_E_INVALIDPARAMETER : i32 = -2147286953;
pub const STG_E_MEDIUMFULL : i32 = -2147286928;
pub const STG_E_PROPSETMISMATCHED : i32 = -2147286800;
pub const STG_E_ABNORMALAPIEXIT : i32 = -2147286790;
pub const STG_E_INVALIDHEADER : i32 = -2147286789;
pub const STG_E_INVALIDNAME : i32 = -2147286788;
pub const STG_E_UNKNOWN : i32 = -2147286787;
pub const STG_E_UNIMPLEMENTEDFUNCTION : i32 = -2147286786;
pub const STG_E_INVALIDFLAG : i32 = -2147286785;
pub const STG_E_INUSE : i32 = -2147286784;
pub const STG_E_NOTCURRENT : i32 = -2147286783;
pub const STG_E_REVERTED : i32 = -2147286782;
pub const STG_E_CANTSAVE : i32 = -2147286781;
pub const STG_E_OLDFORMAT : i32 = -2147286780;
pub const STG_E_OLDDLL : i32 = -2147286779;
pub const STG_E_SHAREREQUIRED : i32 = -2147286778;
pub const STG_E_NOTFILEBASEDSTORAGE : i32 = -2147286777;
pub const STG_E_EXTANTMARSHALLINGS : i32 = -2147286776;
pub const STG_E_DOCFILECORRUPT : i32 = -2147286775;
pub const STG_E_BADBASEADDRESS : i32 = -2147286768;
pub const STG_E_DOCFILETOOLARGE : i32 = -2147286767;
pub const STG_E_NOTSIMPLEFORMAT : i32 = -2147286766;
pub const STG_E_INCOMPLETE : i32 = -2147286527;
pub const STG_E_TERMINATED : i32 = -2147286526;
pub const STG_S_CONVERTED : i32 = 197120;
pub const STG_S_BLOCK : i32 = 197121;
pub const STG_S_RETRYNOW : i32 = 197122;
pub const STG_S_MONITORING : i32 = 197123;
pub const STG_S_MULTIPLEOPENS : i32 = 197124;
pub const STG_S_CONSOLIDATIONFAILED : i32 = 197125;
pub const STG_S_CANNOTCONSOLIDATE : i32 = 197126;
pub const STG_S_POWER_CYCLE_REQUIRED : i32 = 197127;
pub const STG_E_FIRMWARE_SLOT_INVALID : i32 = -2147286520;
pub const STG_E_FIRMWARE_IMAGE_INVALID : i32 = -2147286519;
pub const STG_E_DEVICE_UNRESPONSIVE : i32 = -2147286518;
pub const STG_E_STATUS_COPY_PROTECTION_FAILURE : i32 = -2147286267;
pub const STG_E_CSS_AUTHENTICATION_FAILURE : i32 = -2147286266;
pub const STG_E_CSS_KEY_NOT_PRESENT : i32 = -2147286265;
pub const STG_E_CSS_KEY_NOT_ESTABLISHED : i32 = -2147286264;
pub const STG_E_CSS_SCRAMBLED_SECTOR : i32 = -2147286263;
pub const STG_E_CSS_REGION_MISMATCH : i32 = -2147286262;
pub const STG_E_RESETS_EXHAUSTED : i32 = -2147286261;
pub const RPC_E_CALL_REJECTED : i32 = -2147418111;
pub const RPC_E_CALL_CANCELED : i32 = -2147418110;
pub const RPC_E_CANTPOST_INSENDCALL : i32 = -2147418109;
pub const RPC_E_CANTCALLOUT_INASYNCCALL : i32 = -2147418108;
pub const RPC_E_CANTCALLOUT_INEXTERNALCALL : i32 = -2147418107;
pub const RPC_E_CONNECTION_TERMINATED : i32 = -2147418106;
pub const RPC_E_SERVER_DIED : i32 = -2147418105;
pub const RPC_E_CLIENT_DIED : i32 = -2147418104;
pub const RPC_E_INVALID_DATAPACKET : i32 = -2147418103;
pub const RPC_E_CANTTRANSMIT_CALL : i32 = -2147418102;
pub const RPC_E_CLIENT_CANTMARSHAL_DATA : i32 = -2147418101;
pub const RPC_E_CLIENT_CANTUNMARSHAL_DATA : i32 = -2147418100;
pub const RPC_E_SERVER_CANTMARSHAL_DATA : i32 = -2147418099;
pub const RPC_E_SERVER_CANTUNMARSHAL_DATA : i32 = -2147418098;
pub const RPC_E_INVALID_DATA : i32 = -2147418097;
pub const RPC_E_INVALID_PARAMETER : i32 = -2147418096;
pub const RPC_E_CANTCALLOUT_AGAIN : i32 = -2147418095;
pub const RPC_E_SERVER_DIED_DNE : i32 = -2147418094;
pub const RPC_E_SYS_CALL_FAILED : i32 = -2147417856;
pub const RPC_E_OUT_OF_RESOURCES : i32 = -2147417855;
pub const RPC_E_ATTEMPTED_MULTITHREAD : i32 = -2147417854;
pub const RPC_E_NOT_REGISTERED : i32 = -2147417853;
pub const RPC_E_FAULT : i32 = -2147417852;
pub const RPC_E_SERVERFAULT : i32 = -2147417851;
pub const RPC_E_CHANGED_MODE : i32 = -2147417850;
pub const RPC_E_INVALIDMETHOD : i32 = -2147417849;
pub const RPC_E_DISCONNECTED : i32 = -2147417848;
pub const RPC_E_RETRY : i32 = -2147417847;
pub const RPC_E_SERVERCALL_RETRYLATER : i32 = -2147417846;
pub const RPC_E_SERVERCALL_REJECTED : i32 = -2147417845;
pub const RPC_E_INVALID_CALLDATA : i32 = -2147417844;
pub const RPC_E_CANTCALLOUT_ININPUTSYNCCALL : i32 = -2147417843;
pub const RPC_E_WRONG_THREAD : i32 = -2147417842;
pub const RPC_E_THREAD_NOT_INIT : i32 = -2147417841;
pub const RPC_E_VERSION_MISMATCH : i32 = -2147417840;
pub const RPC_E_INVALID_HEADER : i32 = -2147417839;
pub const RPC_E_INVALID_EXTENSION : i32 = -2147417838;
pub const RPC_E_INVALID_IPID : i32 = -2147417837;
pub const RPC_E_INVALID_OBJECT : i32 = -2147417836;
pub const RPC_S_CALLPENDING : i32 = -2147417835;
pub const RPC_S_WAITONTIMER : i32 = -2147417834;
pub const RPC_E_CALL_COMPLETE : i32 = -2147417833;
pub const RPC_E_UNSECURE_CALL : i32 = -2147417832;
pub const RPC_E_TOO_LATE : i32 = -2147417831;
pub const RPC_E_NO_GOOD_SECURITY_PACKAGES : i32 = -2147417830;
pub const RPC_E_ACCESS_DENIED : i32 = -2147417829;
pub const RPC_E_REMOTE_DISABLED : i32 = -2147417828;
pub const RPC_E_INVALID_OBJREF : i32 = -2147417827;
pub const RPC_E_NO_CONTEXT : i32 = -2147417826;
pub const RPC_E_TIMEOUT : i32 = -2147417825;
pub const RPC_E_NO_SYNC : i32 = -2147417824;
pub const RPC_E_FULLSIC_REQUIRED : i32 = -2147417823;
pub const RPC_E_INVALID_STD_NAME : i32 = -2147417822;
pub const CO_E_FAILEDTOIMPERSONATE : i32 = -2147417821;
pub const CO_E_FAILEDTOGETSECCTX : i32 = -2147417820;
pub const CO_E_FAILEDTOOPENTHREADTOKEN : i32 = -2147417819;
pub const CO_E_FAILEDTOGETTOKENINFO : i32 = -2147417818;
pub const CO_E_TRUSTEEDOESNTMATCHCLIENT : i32 = -2147417817;
pub const CO_E_FAILEDTOQUERYCLIENTBLANKET : i32 = -2147417816;
pub const CO_E_FAILEDTOSETDACL : i32 = -2147417815;
pub const CO_E_ACCESSCHECKFAILED : i32 = -2147417814;
pub const CO_E_NETACCESSAPIFAILED : i32 = -2147417813;
pub const CO_E_WRONGTRUSTEENAMESYNTAX : i32 = -2147417812;
pub const CO_E_INVALIDSID : i32 = -2147417811;
pub const CO_E_CONVERSIONFAILED : i32 = -2147417810;
pub const CO_E_NOMATCHINGSIDFOUND : i32 = -2147417809;
pub const CO_E_LOOKUPACCSIDFAILED : i32 = -2147417808;
pub const CO_E_NOMATCHINGNAMEFOUND : i32 = -2147417807;
pub const CO_E_LOOKUPACCNAMEFAILED : i32 = -2147417806;
pub const CO_E_SETSERLHNDLFAILED : i32 = -2147417805;
pub const CO_E_FAILEDTOGETWINDIR : i32 = -2147417804;
pub const CO_E_PATHTOOLONG : i32 = -2147417803;
pub const CO_E_FAILEDTOGENUUID : i32 = -2147417802;
pub const CO_E_FAILEDTOCREATEFILE : i32 = -2147417801;
pub const CO_E_FAILEDTOCLOSEHANDLE : i32 = -2147417800;
pub const CO_E_EXCEEDSYSACLLIMIT : i32 = -2147417799;
pub const CO_E_ACESINWRONGORDER : i32 = -2147417798;
pub const CO_E_INCOMPATIBLESTREAMVERSION : i32 = -2147417797;
pub const CO_E_FAILEDTOOPENPROCESSTOKEN : i32 = -2147417796;
pub const CO_E_DECODEFAILED : i32 = -2147417795;
pub const CO_E_ACNOTINITIALIZED : i32 = -2147417793;
pub const CO_E_CANCEL_DISABLED : i32 = -2147417792;
pub const RPC_E_UNEXPECTED : i32 = -2147352577;
pub const ERROR_AUDITING_DISABLED : i32 = -1073151999;
pub const ERROR_ALL_SIDS_FILTERED : i32 = -1073151998;
pub const ERROR_BIZRULES_NOT_ENABLED : i32 = -1073151997;
pub const NTE_BAD_UID : i32 = -2146893823;
pub const NTE_BAD_HASH : i32 = -2146893822;
pub const NTE_BAD_KEY : i32 = -2146893821;
pub const NTE_BAD_LEN : i32 = -2146893820;
pub const NTE_BAD_DATA : i32 = -2146893819;
pub const NTE_BAD_SIGNATURE : i32 = -2146893818;
pub const NTE_BAD_VER : i32 = -2146893817;
pub const NTE_BAD_ALGID : i32 = -2146893816;
pub const NTE_BAD_FLAGS : i32 = -2146893815;
pub const NTE_BAD_TYPE : i32 = -2146893814;
pub const NTE_BAD_KEY_STATE : i32 = -2146893813;
pub const NTE_BAD_HASH_STATE : i32 = -2146893812;
pub const NTE_NO_KEY : i32 = -2146893811;
pub const NTE_NO_MEMORY : i32 = -2146893810;
pub const NTE_EXISTS : i32 = -2146893809;
pub const NTE_PERM : i32 = -2146893808;
pub const NTE_NOT_FOUND : i32 = -2146893807;
pub const NTE_DOUBLE_ENCRYPT : i32 = -2146893806;
pub const NTE_BAD_PROVIDER : i32 = -2146893805;
pub const NTE_BAD_PROV_TYPE : i32 = -2146893804;
pub const NTE_BAD_PUBLIC_KEY : i32 = -2146893803;
pub const NTE_BAD_KEYSET : i32 = -2146893802;
pub const NTE_PROV_TYPE_NOT_DEF : i32 = -2146893801;
pub const NTE_PROV_TYPE_ENTRY_BAD : i32 = -2146893800;
pub const NTE_KEYSET_NOT_DEF : i32 = -2146893799;
pub const NTE_KEYSET_ENTRY_BAD : i32 = -2146893798;
pub const NTE_PROV_TYPE_NO_MATCH : i32 = -2146893797;
pub const NTE_SIGNATURE_FILE_BAD : i32 = -2146893796;
pub const NTE_PROVIDER_DLL_FAIL : i32 = -2146893795;
pub const NTE_PROV_DLL_NOT_FOUND : i32 = -2146893794;
pub const NTE_BAD_KEYSET_PARAM : i32 = -2146893793;
pub const NTE_FAIL : i32 = -2146893792;
pub const NTE_SYS_ERR : i32 = -2146893791;
pub const NTE_SILENT_CONTEXT : i32 = -2146893790;
pub const NTE_TOKEN_KEYSET_STORAGE_FULL : i32 = -2146893789;
pub const NTE_TEMPORARY_PROFILE : i32 = -2146893788;
pub const NTE_FIXEDPARAMETER : i32 = -2146893787;
pub const NTE_INVALID_HANDLE : i32 = -2146893786;
pub const NTE_INVALID_PARAMETER : i32 = -2146893785;
pub const NTE_BUFFER_TOO_SMALL : i32 = -2146893784;
pub const NTE_NOT_SUPPORTED : i32 = -2146893783;
pub const NTE_NO_MORE_ITEMS : i32 = -2146893782;
pub const NTE_BUFFERS_OVERLAP : i32 = -2146893781;
pub const NTE_DECRYPTION_FAILURE : i32 = -2146893780;
pub const NTE_INTERNAL_ERROR : i32 = -2146893779;
pub const NTE_UI_REQUIRED : i32 = -2146893778;
pub const NTE_HMAC_NOT_SUPPORTED : i32 = -2146893777;
pub const NTE_DEVICE_NOT_READY : i32 = -2146893776;
pub const NTE_AUTHENTICATION_IGNORED : i32 = -2146893775;
pub const NTE_VALIDATION_FAILED : i32 = -2146893774;
pub const NTE_INCORRECT_PASSWORD : i32 = -2146893773;
pub const NTE_ENCRYPTION_FAILURE : i32 = -2146893772;
pub const NTE_DEVICE_NOT_FOUND : i32 = -2146893771;
pub const NTE_USER_CANCELLED : i32 = -2146893770;
pub const NTE_PASSWORD_CHANGE_REQUIRED : i32 = -2146893769;
pub const NTE_NOT_ACTIVE_CONSOLE : i32 = -2146893768;
pub const SEC_E_INSUFFICIENT_MEMORY : i32 = -2146893056;
pub const SEC_E_INVALID_HANDLE : i32 = -2146893055;
pub const SEC_E_UNSUPPORTED_FUNCTION : i32 = -2146893054;
pub const SEC_E_TARGET_UNKNOWN : i32 = -2146893053;
pub const SEC_E_INTERNAL_ERROR : i32 = -2146893052;
pub const SEC_E_SECPKG_NOT_FOUND : i32 = -2146893051;
pub const SEC_E_NOT_OWNER : i32 = -2146893050;
pub const SEC_E_CANNOT_INSTALL : i32 = -2146893049;
pub const SEC_E_INVALID_TOKEN : i32 = -2146893048;
pub const SEC_E_CANNOT_PACK : i32 = -2146893047;
pub const SEC_E_QOP_NOT_SUPPORTED : i32 = -2146893046;
pub const SEC_E_NO_IMPERSONATION : i32 = -2146893045;
pub const SEC_E_LOGON_DENIED : i32 = -2146893044;
pub const SEC_E_UNKNOWN_CREDENTIALS : i32 = -2146893043;
pub const SEC_E_NO_CREDENTIALS : i32 = -2146893042;
pub const SEC_E_MESSAGE_ALTERED : i32 = -2146893041;
pub const SEC_E_OUT_OF_SEQUENCE : i32 = -2146893040;
pub const SEC_E_NO_AUTHENTICATING_AUTHORITY : i32 = -2146893039;
pub const SEC_I_CONTINUE_NEEDED : i32 = 590610;
pub const SEC_I_COMPLETE_NEEDED : i32 = 590611;
pub const SEC_I_COMPLETE_AND_CONTINUE : i32 = 590612;
pub const SEC_I_LOCAL_LOGON : i32 = 590613;
pub const SEC_I_GENERIC_EXTENSION_RECEIVED : i32 = 590614;
pub const SEC_E_BAD_PKGID : i32 = -2146893034;
pub const SEC_E_CONTEXT_EXPIRED : i32 = -2146893033;
pub const SEC_I_CONTEXT_EXPIRED : i32 = 590615;
pub const SEC_E_INCOMPLETE_MESSAGE : i32 = -2146893032;
pub const SEC_E_INCOMPLETE_CREDENTIALS : i32 = -2146893024;
pub const SEC_E_BUFFER_TOO_SMALL : i32 = -2146893023;
pub const SEC_I_INCOMPLETE_CREDENTIALS : i32 = 590624;
pub const SEC_I_RENEGOTIATE : i32 = 590625;
pub const SEC_E_WRONG_PRINCIPAL : i32 = -2146893022;
pub const SEC_I_NO_LSA_CONTEXT : i32 = 590627;
pub const SEC_E_TIME_SKEW : i32 = -2146893020;
pub const SEC_E_UNTRUSTED_ROOT : i32 = -2146893019;
pub const SEC_E_ILLEGAL_MESSAGE : i32 = -2146893018;
pub const SEC_E_CERT_UNKNOWN : i32 = -2146893017;
pub const SEC_E_CERT_EXPIRED : i32 = -2146893016;
pub const SEC_E_ENCRYPT_FAILURE : i32 = -2146893015;
pub const SEC_E_DECRYPT_FAILURE : i32 = -2146893008;
pub const SEC_E_ALGORITHM_MISMATCH : i32 = -2146893007;
pub const SEC_E_SECURITY_QOS_FAILED : i32 = -2146893006;
pub const SEC_E_UNFINISHED_CONTEXT_DELETED : i32 = -2146893005;
pub const SEC_E_NO_TGT_REPLY : i32 = -2146893004;
pub const SEC_E_NO_IP_ADDRESSES : i32 = -2146893003;
pub const SEC_E_WRONG_CREDENTIAL_HANDLE : i32 = -2146893002;
pub const SEC_E_CRYPTO_SYSTEM_INVALID : i32 = -2146893001;
pub const SEC_E_MAX_REFERRALS_EXCEEDED : i32 = -2146893000;
pub const SEC_E_MUST_BE_KDC : i32 = -2146892999;
pub const SEC_E_STRONG_CRYPTO_NOT_SUPPORTED : i32 = -2146892998;
pub const SEC_E_TOO_MANY_PRINCIPALS : i32 = -2146892997;
pub const SEC_E_NO_PA_DATA : i32 = -2146892996;
pub const SEC_E_PKINIT_NAME_MISMATCH : i32 = -2146892995;
pub const SEC_E_SMARTCARD_LOGON_REQUIRED : i32 = -2146892994;
pub const SEC_E_SHUTDOWN_IN_PROGRESS : i32 = -2146892993;
pub const SEC_E_KDC_INVALID_REQUEST : i32 = -2146892992;
pub const SEC_E_KDC_UNABLE_TO_REFER : i32 = -2146892991;
pub const SEC_E_KDC_UNKNOWN_ETYPE : i32 = -2146892990;
pub const SEC_E_UNSUPPORTED_PREAUTH : i32 = -2146892989;
pub const SEC_E_DELEGATION_REQUIRED : i32 = -2146892987;
pub const SEC_E_BAD_BINDINGS : i32 = -2146892986;
pub const SEC_E_MULTIPLE_ACCOUNTS : i32 = -2146892985;
pub const SEC_E_NO_KERB_KEY : i32 = -2146892984;
pub const SEC_E_CERT_WRONG_USAGE : i32 = -2146892983;
pub const SEC_E_DOWNGRADE_DETECTED : i32 = -2146892976;
pub const SEC_E_SMARTCARD_CERT_REVOKED : i32 = -2146892975;
pub const SEC_E_ISSUING_CA_UNTRUSTED : i32 = -2146892974;
pub const SEC_E_REVOCATION_OFFLINE_C : i32 = -2146892973;
pub const SEC_E_PKINIT_CLIENT_FAILURE : i32 = -2146892972;
pub const SEC_E_SMARTCARD_CERT_EXPIRED : i32 = -2146892971;
pub const SEC_E_NO_S4U_PROT_SUPPORT : i32 = -2146892970;
pub const SEC_E_CROSSREALM_DELEGATION_FAILURE : i32 = -2146892969;
pub const SEC_E_REVOCATION_OFFLINE_KDC : i32 = -2146892968;
pub const SEC_E_ISSUING_CA_UNTRUSTED_KDC : i32 = -2146892967;
pub const SEC_E_KDC_CERT_EXPIRED : i32 = -2146892966;
pub const SEC_E_KDC_CERT_REVOKED : i32 = -2146892965;
pub const SEC_I_SIGNATURE_NEEDED : i32 = 590684;
pub const SEC_E_INVALID_PARAMETER : i32 = -2146892963;
pub const SEC_E_DELEGATION_POLICY : i32 = -2146892962;
pub const SEC_E_POLICY_NLTM_ONLY : i32 = -2146892961;
pub const SEC_I_NO_RENEGOTIATION : i32 = 590688;
pub const SEC_E_NO_CONTEXT : i32 = -2146892959;
pub const SEC_E_PKU2U_CERT_FAILURE : i32 = -2146892958;
pub const SEC_E_MUTUAL_AUTH_FAILED : i32 = -2146892957;
pub const SEC_I_MESSAGE_FRAGMENT : i32 = 590692;
pub const SEC_E_ONLY_HTTPS_ALLOWED : i32 = -2146892955;
pub const SEC_I_CONTINUE_NEEDED_MESSAGE_OK : i32 = 590694;
pub const SEC_E_APPLICATION_PROTOCOL_MISMATCH : i32 = -2146892953;
pub const SEC_I_ASYNC_CALL_PENDING : i32 = 590696;
pub const SEC_E_INVALID_UPN_NAME : i32 = -2146892951;
pub const SEC_E_EXT_BUFFER_TOO_SMALL : i32 = -2146892950;
pub const SEC_E_INSUFFICIENT_BUFFERS : i32 = -2146892949;
pub const CRYPT_E_MSG_ERROR : i32 = -2146889727;
pub const CRYPT_E_UNKNOWN_ALGO : i32 = -2146889726;
pub const CRYPT_E_OID_FORMAT : i32 = -2146889725;
pub const CRYPT_E_INVALID_MSG_TYPE : i32 = -2146889724;
pub const CRYPT_E_UNEXPECTED_ENCODING : i32 = -2146889723;
pub const CRYPT_E_AUTH_ATTR_MISSING : i32 = -2146889722;
pub const CRYPT_E_HASH_VALUE : i32 = -2146889721;
pub const CRYPT_E_INVALID_INDEX : i32 = -2146889720;
pub const CRYPT_E_ALREADY_DECRYPTED : i32 = -2146889719;
pub const CRYPT_E_NOT_DECRYPTED : i32 = -2146889718;
pub const CRYPT_E_RECIPIENT_NOT_FOUND : i32 = -2146889717;
pub const CRYPT_E_CONTROL_TYPE : i32 = -2146889716;
pub const CRYPT_E_ISSUER_SERIALNUMBER : i32 = -2146889715;
pub const CRYPT_E_SIGNER_NOT_FOUND : i32 = -2146889714;
pub const CRYPT_E_ATTRIBUTES_MISSING : i32 = -2146889713;
pub const CRYPT_E_STREAM_MSG_NOT_READY : i32 = -2146889712;
pub const CRYPT_E_STREAM_INSUFFICIENT_DATA : i32 = -2146889711;
pub const CRYPT_I_NEW_PROTECTION_REQUIRED : i32 = 593938;
pub const CRYPT_E_BAD_LEN : i32 = -2146885631;
pub const CRYPT_E_BAD_ENCODE : i32 = -2146885630;
pub const CRYPT_E_FILE_ERROR : i32 = -2146885629;
pub const CRYPT_E_NOT_FOUND : i32 = -2146885628;
pub const CRYPT_E_EXISTS : i32 = -2146885627;
pub const CRYPT_E_NO_PROVIDER : i32 = -2146885626;
pub const CRYPT_E_SELF_SIGNED : i32 = -2146885625;
pub const CRYPT_E_DELETED_PREV : i32 = -2146885624;
pub const CRYPT_E_NO_MATCH : i32 = -2146885623;
pub const CRYPT_E_UNEXPECTED_MSG_TYPE : i32 = -2146885622;
pub const CRYPT_E_NO_KEY_PROPERTY : i32 = -2146885621;
pub const CRYPT_E_NO_DECRYPT_CERT : i32 = -2146885620;
pub const CRYPT_E_BAD_MSG : i32 = -2146885619;
pub const CRYPT_E_NO_SIGNER : i32 = -2146885618;
pub const CRYPT_E_PENDING_CLOSE : i32 = -2146885617;
pub const CRYPT_E_REVOKED : i32 = -2146885616;
pub const CRYPT_E_NO_REVOCATION_DLL : i32 = -2146885615;
pub const CRYPT_E_NO_REVOCATION_CHECK : i32 = -2146885614;
pub const CRYPT_E_REVOCATION_OFFLINE : i32 = -2146885613;
pub const CRYPT_E_NOT_IN_REVOCATION_DATABASE : i32 = -2146885612;
pub const CRYPT_E_INVALID_NUMERIC_STRING : i32 = -2146885600;
pub const CRYPT_E_INVALID_PRINTABLE_STRING : i32 = -2146885599;
pub const CRYPT_E_INVALID_IA5_STRING : i32 = -2146885598;
pub const CRYPT_E_INVALID_X500_STRING : i32 = -2146885597;
pub const CRYPT_E_NOT_CHAR_STRING : i32 = -2146885596;
pub const CRYPT_E_FILERESIZED : i32 = -2146885595;
pub const CRYPT_E_SECURITY_SETTINGS : i32 = -2146885594;
pub const CRYPT_E_NO_VERIFY_USAGE_DLL : i32 = -2146885593;
pub const CRYPT_E_NO_VERIFY_USAGE_CHECK : i32 = -2146885592;
pub const CRYPT_E_VERIFY_USAGE_OFFLINE : i32 = -2146885591;
pub const CRYPT_E_NOT_IN_CTL : i32 = -2146885590;
pub const CRYPT_E_NO_TRUSTED_SIGNER : i32 = -2146885589;
pub const CRYPT_E_MISSING_PUBKEY_PARA : i32 = -2146885588;
pub const CRYPT_E_OBJECT_LOCATOR_OBJECT_NOT_FOUND : i32 = -2146885587;
pub const CRYPT_E_OSS_ERROR : i32 = -2146881536;
pub const OSS_MORE_BUF : i32 = -2146881535;
pub const OSS_NEGATIVE_UINTEGER : i32 = -2146881534;
pub const OSS_PDU_RANGE : i32 = -2146881533;
pub const OSS_MORE_INPUT : i32 = -2146881532;
pub const OSS_DATA_ERROR : i32 = -2146881531;
pub const OSS_BAD_ARG : i32 = -2146881530;
pub const OSS_BAD_VERSION : i32 = -2146881529;
pub const OSS_OUT_MEMORY : i32 = -2146881528;
pub const OSS_PDU_MISMATCH : i32 = -2146881527;
pub const OSS_LIMITED : i32 = -2146881526;
pub const OSS_BAD_PTR : i32 = -2146881525;
pub const OSS_BAD_TIME : i32 = -2146881524;
pub const OSS_INDEFINITE_NOT_SUPPORTED : i32 = -2146881523;
pub const OSS_MEM_ERROR : i32 = -2146881522;
pub const OSS_BAD_TABLE : i32 = -2146881521;
pub const OSS_TOO_LONG : i32 = -2146881520;
pub const OSS_CONSTRAINT_VIOLATED : i32 = -2146881519;
pub const OSS_FATAL_ERROR : i32 = -2146881518;
pub const OSS_ACCESS_SERIALIZATION_ERROR : i32 = -2146881517;
pub const OSS_NULL_TBL : i32 = -2146881516;
pub const OSS_NULL_FCN : i32 = -2146881515;
pub const OSS_BAD_ENCRULES : i32 = -2146881514;
pub const OSS_UNAVAIL_ENCRULES : i32 = -2146881513;
pub const OSS_CANT_OPEN_TRACE_WINDOW : i32 = -2146881512;
pub const OSS_UNIMPLEMENTED : i32 = -2146881511;
pub const OSS_OID_DLL_NOT_LINKED : i32 = -2146881510;
pub const OSS_CANT_OPEN_TRACE_FILE : i32 = -2146881509;
pub const OSS_TRACE_FILE_ALREADY_OPEN : i32 = -2146881508;
pub const OSS_TABLE_MISMATCH : i32 = -2146881507;
pub const OSS_TYPE_NOT_SUPPORTED : i32 = -2146881506;
pub const OSS_REAL_DLL_NOT_LINKED : i32 = -2146881505;
pub const OSS_REAL_CODE_NOT_LINKED : i32 = -2146881504;
pub const OSS_OUT_OF_RANGE : i32 = -2146881503;
pub const OSS_COPIER_DLL_NOT_LINKED : i32 = -2146881502;
pub const OSS_CONSTRAINT_DLL_NOT_LINKED : i32 = -2146881501;
pub const OSS_COMPARATOR_DLL_NOT_LINKED : i32 = -2146881500;
pub const OSS_COMPARATOR_CODE_NOT_LINKED : i32 = -2146881499;
pub const OSS_MEM_MGR_DLL_NOT_LINKED : i32 = -2146881498;
pub const OSS_PDV_DLL_NOT_LINKED : i32 = -2146881497;
pub const OSS_PDV_CODE_NOT_LINKED : i32 = -2146881496;
pub const OSS_API_DLL_NOT_LINKED : i32 = -2146881495;
pub const OSS_BERDER_DLL_NOT_LINKED : i32 = -2146881494;
pub const OSS_PER_DLL_NOT_LINKED : i32 = -2146881493;
pub const OSS_OPEN_TYPE_ERROR : i32 = -2146881492;
pub const OSS_MUTEX_NOT_CREATED : i32 = -2146881491;
pub const OSS_CANT_CLOSE_TRACE_FILE : i32 = -2146881490;
pub const CRYPT_E_ASN1_ERROR : i32 = -2146881280;
pub const CRYPT_E_ASN1_INTERNAL : i32 = -2146881279;
pub const CRYPT_E_ASN1_EOD : i32 = -2146881278;
pub const CRYPT_E_ASN1_CORRUPT : i32 = -2146881277;
pub const CRYPT_E_ASN1_LARGE : i32 = -2146881276;
pub const CRYPT_E_ASN1_CONSTRAINT : i32 = -2146881275;
pub const CRYPT_E_ASN1_MEMORY : i32 = -2146881274;
pub const CRYPT_E_ASN1_OVERFLOW : i32 = -2146881273;
pub const CRYPT_E_ASN1_BADPDU : i32 = -2146881272;
pub const CRYPT_E_ASN1_BADARGS : i32 = -2146881271;
pub const CRYPT_E_ASN1_BADREAL : i32 = -2146881270;
pub const CRYPT_E_ASN1_BADTAG : i32 = -2146881269;
pub const CRYPT_E_ASN1_CHOICE : i32 = -2146881268;
pub const CRYPT_E_ASN1_RULE : i32 = -2146881267;
pub const CRYPT_E_ASN1_UTF8 : i32 = -2146881266;
pub const CRYPT_E_ASN1_PDU_TYPE : i32 = -2146881229;
pub const CRYPT_E_ASN1_NYI : i32 = -2146881228;
pub const CRYPT_E_ASN1_EXTENDED : i32 = -2146881023;
pub const CRYPT_E_ASN1_NOEOD : i32 = -2146881022;
pub const CERTSRV_E_BAD_REQUESTSUBJECT : i32 = -2146877439;
pub const CERTSRV_E_NO_REQUEST : i32 = -2146877438;
pub const CERTSRV_E_BAD_REQUESTSTATUS : i32 = -2146877437;
pub const CERTSRV_E_PROPERTY_EMPTY : i32 = -2146877436;
pub const CERTSRV_E_INVALID_CA_CERTIFICATE : i32 = -2146877435;
pub const CERTSRV_E_SERVER_SUSPENDED : i32 = -2146877434;
pub const CERTSRV_E_ENCODING_LENGTH : i32 = -2146877433;
pub const CERTSRV_E_ROLECONFLICT : i32 = -2146877432;
pub const CERTSRV_E_RESTRICTEDOFFICER : i32 = -2146877431;
pub const CERTSRV_E_KEY_ARCHIVAL_NOT_CONFIGURED : i32 = -2146877430;
pub const CERTSRV_E_NO_VALID_KRA : i32 = -2146877429;
pub const CERTSRV_E_BAD_REQUEST_KEY_ARCHIVAL : i32 = -2146877428;
pub const CERTSRV_E_NO_CAADMIN_DEFINED : i32 = -2146877427;
pub const CERTSRV_E_BAD_RENEWAL_CERT_ATTRIBUTE : i32 = -2146877426;
pub const CERTSRV_E_NO_DB_SESSIONS : i32 = -2146877425;
pub const CERTSRV_E_ALIGNMENT_FAULT : i32 = -2146877424;
pub const CERTSRV_E_ENROLL_DENIED : i32 = -2146877423;
pub const CERTSRV_E_TEMPLATE_DENIED : i32 = -2146877422;
pub const CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE : i32 = -2146877421;
pub const CERTSRV_E_ADMIN_DENIED_REQUEST : i32 = -2146877420;
pub const CERTSRV_E_NO_POLICY_SERVER : i32 = -2146877419;
pub const CERTSRV_E_WEAK_SIGNATURE_OR_KEY : i32 = -2146877418;
pub const CERTSRV_E_KEY_ATTESTATION_NOT_SUPPORTED : i32 = -2146877417;
pub const CERTSRV_E_ENCRYPTION_CERT_REQUIRED : i32 = -2146877416;
pub const CERTSRV_E_UNSUPPORTED_CERT_TYPE : i32 = -2146875392;
pub const CERTSRV_E_NO_CERT_TYPE : i32 = -2146875391;
pub const CERTSRV_E_TEMPLATE_CONFLICT : i32 = -2146875390;
pub const CERTSRV_E_SUBJECT_ALT_NAME_REQUIRED : i32 = -2146875389;
pub const CERTSRV_E_ARCHIVED_KEY_REQUIRED : i32 = -2146875388;
pub const CERTSRV_E_SMIME_REQUIRED : i32 = -2146875387;
pub const CERTSRV_E_BAD_RENEWAL_SUBJECT : i32 = -2146875386;
pub const CERTSRV_E_BAD_TEMPLATE_VERSION : i32 = -2146875385;
pub const CERTSRV_E_TEMPLATE_POLICY_REQUIRED : i32 = -2146875384;
pub const CERTSRV_E_SIGNATURE_POLICY_REQUIRED : i32 = -2146875383;
pub const CERTSRV_E_SIGNATURE_COUNT : i32 = -2146875382;
pub const CERTSRV_E_SIGNATURE_REJECTED : i32 = -2146875381;
pub const CERTSRV_E_ISSUANCE_POLICY_REQUIRED : i32 = -2146875380;
pub const CERTSRV_E_SUBJECT_UPN_REQUIRED : i32 = -2146875379;
pub const CERTSRV_E_SUBJECT_DIRECTORY_GUID_REQUIRED : i32 = -2146875378;
pub const CERTSRV_E_SUBJECT_DNS_REQUIRED : i32 = -2146875377;
pub const CERTSRV_E_ARCHIVED_KEY_UNEXPECTED : i32 = -2146875376;
pub const CERTSRV_E_KEY_LENGTH : i32 = -2146875375;
pub const CERTSRV_E_SUBJECT_EMAIL_REQUIRED : i32 = -2146875374;
pub const CERTSRV_E_UNKNOWN_CERT_TYPE : i32 = -2146875373;
pub const CERTSRV_E_CERT_TYPE_OVERLAP : i32 = -2146875372;
pub const CERTSRV_E_TOO_MANY_SIGNATURES : i32 = -2146875371;
pub const CERTSRV_E_RENEWAL_BAD_PUBLIC_KEY : i32 = -2146875370;
pub const CERTSRV_E_INVALID_EK : i32 = -2146875369;
pub const CERTSRV_E_INVALID_IDBINDING : i32 = -2146875368;
pub const CERTSRV_E_INVALID_ATTESTATION : i32 = -2146875367;
pub const CERTSRV_E_KEY_ATTESTATION : i32 = -2146875366;
pub const CERTSRV_E_CORRUPT_KEY_ATTESTATION : i32 = -2146875365;
pub const CERTSRV_E_EXPIRED_CHALLENGE : i32 = -2146875364;
pub const CERTSRV_E_INVALID_RESPONSE : i32 = -2146875363;
pub const CERTSRV_E_INVALID_REQUESTID : i32 = -2146875362;
pub const CERTSRV_E_REQUEST_PRECERTIFICATE_MISMATCH : i32 = -2146875361;
pub const CERTSRV_E_PENDING_CLIENT_RESPONSE : i32 = -2146875360;
pub const XENROLL_E_KEY_NOT_EXPORTABLE : i32 = -2146873344;
pub const XENROLL_E_CANNOT_ADD_ROOT_CERT : i32 = -2146873343;
pub const XENROLL_E_RESPONSE_KA_HASH_NOT_FOUND : i32 = -2146873342;
pub const XENROLL_E_RESPONSE_UNEXPECTED_KA_HASH : i32 = -2146873341;
pub const XENROLL_E_RESPONSE_KA_HASH_MISMATCH : i32 = -2146873340;
pub const XENROLL_E_KEYSPEC_SMIME_MISMATCH : i32 = -2146873339;
pub const TRUST_E_SYSTEM_ERROR : i32 = -2146869247;
pub const TRUST_E_NO_SIGNER_CERT : i32 = -2146869246;
pub const TRUST_E_COUNTER_SIGNER : i32 = -2146869245;
pub const TRUST_E_CERT_SIGNATURE : i32 = -2146869244;
pub const TRUST_E_TIME_STAMP : i32 = -2146869243;
pub const TRUST_E_BAD_DIGEST : i32 = -2146869232;
pub const TRUST_E_MALFORMED_SIGNATURE : i32 = -2146869231;
pub const TRUST_E_BASIC_CONSTRAINTS : i32 = -2146869223;
pub const TRUST_E_FINANCIAL_CRITERIA : i32 = -2146869218;
pub const MSSIPOTF_E_OUTOFMEMRANGE : i32 = -2146865151;
pub const MSSIPOTF_E_CANTGETOBJECT : i32 = -2146865150;
pub const MSSIPOTF_E_NOHEADTABLE : i32 = -2146865149;
pub const MSSIPOTF_E_BAD_MAGICNUMBER : i32 = -2146865148;
pub const MSSIPOTF_E_BAD_OFFSET_TABLE : i32 = -2146865147;
pub const MSSIPOTF_E_TABLE_TAGORDER : i32 = -2146865146;
pub const MSSIPOTF_E_TABLE_LONGWORD : i32 = -2146865145;
pub const MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT : i32 = -2146865144;
pub const MSSIPOTF_E_TABLES_OVERLAP : i32 = -2146865143;
pub const MSSIPOTF_E_TABLE_PADBYTES : i32 = -2146865142;
pub const MSSIPOTF_E_FILETOOSMALL : i32 = -2146865141;
pub const MSSIPOTF_E_TABLE_CHECKSUM : i32 = -2146865140;
pub const MSSIPOTF_E_FILE_CHECKSUM : i32 = -2146865139;
pub const MSSIPOTF_E_FAILED_POLICY : i32 = -2146865136;
pub const MSSIPOTF_E_FAILED_HINTS_CHECK : i32 = -2146865135;
pub const MSSIPOTF_E_NOT_OPENTYPE : i32 = -2146865134;
pub const MSSIPOTF_E_FILE : i32 = -2146865133;
pub const MSSIPOTF_E_CRYPT : i32 = -2146865132;
pub const MSSIPOTF_E_BADVERSION : i32 = -2146865131;
pub const MSSIPOTF_E_DSIG_STRUCTURE : i32 = -2146865130;
pub const MSSIPOTF_E_PCONST_CHECK : i32 = -2146865129;
pub const MSSIPOTF_E_STRUCTURE : i32 = -2146865128;
pub const ERROR_CRED_REQUIRES_CONFIRMATION : i32 = -2146865127;
pub const NTE_OP_OK : i32 = 0;
pub const TRUST_E_PROVIDER_UNKNOWN : i32 = -2146762751;
pub const TRUST_E_ACTION_UNKNOWN : i32 = -2146762750;
pub const TRUST_E_SUBJECT_FORM_UNKNOWN : i32 = -2146762749;
pub const TRUST_E_SUBJECT_NOT_TRUSTED : i32 = -2146762748;
pub const DIGSIG_E_ENCODE : i32 = -2146762747;
pub const DIGSIG_E_DECODE : i32 = -2146762746;
pub const DIGSIG_E_EXTENSIBILITY : i32 = -2146762745;
pub const DIGSIG_E_CRYPTO : i32 = -2146762744;
pub const PERSIST_E_SIZEDEFINITE : i32 = -2146762743;
pub const PERSIST_E_SIZEINDEFINITE : i32 = -2146762742;
pub const PERSIST_E_NOTSELFSIZING : i32 = -2146762741;
pub const TRUST_E_NOSIGNATURE : i32 = -2146762496;
pub const CERT_E_EXPIRED : i32 = -2146762495;
pub const CERT_E_VALIDITYPERIODNESTING : i32 = -2146762494;
pub const CERT_E_ROLE : i32 = -2146762493;
pub const CERT_E_PATHLENCONST : i32 = -2146762492;
pub const CERT_E_CRITICAL : i32 = -2146762491;
pub const CERT_E_PURPOSE : i32 = -2146762490;
pub const CERT_E_ISSUERCHAINING : i32 = -2146762489;
pub const CERT_E_MALFORMED : i32 = -2146762488;
pub const CERT_E_UNTRUSTEDROOT : i32 = -2146762487;
pub const CERT_E_CHAINING : i32 = -2146762486;
pub const TRUST_E_FAIL : i32 = -2146762485;
pub const CERT_E_REVOKED : i32 = -2146762484;
pub const CERT_E_UNTRUSTEDTESTROOT : i32 = -2146762483;
pub const CERT_E_REVOCATION_FAILURE : i32 = -2146762482;
pub const CERT_E_CN_NO_MATCH : i32 = -2146762481;
pub const CERT_E_WRONG_USAGE : i32 = -2146762480;
pub const TRUST_E_EXPLICIT_DISTRUST : i32 = -2146762479;
pub const CERT_E_UNTRUSTEDCA : i32 = -2146762478;
pub const CERT_E_INVALID_POLICY : i32 = -2146762477;
pub const CERT_E_INVALID_NAME : i32 = -2146762476;
pub const SPAPI_E_EXPECTED_SECTION_NAME : i32 = -2146500608;
pub const SPAPI_E_BAD_SECTION_NAME_LINE : i32 = -2146500607;
pub const SPAPI_E_SECTION_NAME_TOO_LONG : i32 = -2146500606;
pub const SPAPI_E_GENERAL_SYNTAX : i32 = -2146500605;
pub const SPAPI_E_WRONG_INF_STYLE : i32 = -2146500352;
pub const SPAPI_E_SECTION_NOT_FOUND : i32 = -2146500351;
pub const SPAPI_E_LINE_NOT_FOUND : i32 = -2146500350;
pub const SPAPI_E_NO_BACKUP : i32 = -2146500349;
pub const SPAPI_E_NO_ASSOCIATED_CLASS : i32 = -2146500096;
pub const SPAPI_E_CLASS_MISMATCH : i32 = -2146500095;
pub const SPAPI_E_DUPLICATE_FOUND : i32 = -2146500094;
pub const SPAPI_E_NO_DRIVER_SELECTED : i32 = -2146500093;
pub const SPAPI_E_KEY_DOES_NOT_EXIST : i32 = -2146500092;
pub const SPAPI_E_INVALID_DEVINST_NAME : i32 = -2146500091;
pub const SPAPI_E_INVALID_CLASS : i32 = -2146500090;
pub const SPAPI_E_DEVINST_ALREADY_EXISTS : i32 = -2146500089;
pub const SPAPI_E_DEVINFO_NOT_REGISTERED : i32 = -2146500088;
pub const SPAPI_E_INVALID_REG_PROPERTY : i32 = -2146500087;
pub const SPAPI_E_NO_INF : i32 = -2146500086;
pub const SPAPI_E_NO_SUCH_DEVINST : i32 = -2146500085;
pub const SPAPI_E_CANT_LOAD_CLASS_ICON : i32 = -2146500084;
pub const SPAPI_E_INVALID_CLASS_INSTALLER : i32 = -2146500083;
pub const SPAPI_E_DI_DO_DEFAULT : i32 = -2146500082;
pub const SPAPI_E_DI_NOFILECOPY : i32 = -2146500081;
pub const SPAPI_E_INVALID_HWPROFILE : i32 = -2146500080;
pub const SPAPI_E_NO_DEVICE_SELECTED : i32 = -2146500079;
pub const SPAPI_E_DEVINFO_LIST_LOCKED : i32 = -2146500078;
pub const SPAPI_E_DEVINFO_DATA_LOCKED : i32 = -2146500077;
pub const SPAPI_E_DI_BAD_PATH : i32 = -2146500076;
pub const SPAPI_E_NO_CLASSINSTALL_PARAMS : i32 = -2146500075;
pub const SPAPI_E_FILEQUEUE_LOCKED : i32 = -2146500074;
pub const SPAPI_E_BAD_SERVICE_INSTALLSECT : i32 = -2146500073;
pub const SPAPI_E_NO_CLASS_DRIVER_LIST : i32 = -2146500072;
pub const SPAPI_E_NO_ASSOCIATED_SERVICE : i32 = -2146500071;
pub const SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE : i32 = -2146500070;
pub const SPAPI_E_DEVICE_INTERFACE_ACTIVE : i32 = -2146500069;
pub const SPAPI_E_DEVICE_INTERFACE_REMOVED : i32 = -2146500068;
pub const SPAPI_E_BAD_INTERFACE_INSTALLSECT : i32 = -2146500067;
pub const SPAPI_E_NO_SUCH_INTERFACE_CLASS : i32 = -2146500066;
pub const SPAPI_E_INVALID_REFERENCE_STRING : i32 = -2146500065;
pub const SPAPI_E_INVALID_MACHINENAME : i32 = -2146500064;
pub const SPAPI_E_REMOTE_COMM_FAILURE : i32 = -2146500063;
pub const SPAPI_E_MACHINE_UNAVAILABLE : i32 = -2146500062;
pub const SPAPI_E_NO_CONFIGMGR_SERVICES : i32 = -2146500061;
pub const SPAPI_E_INVALID_PROPPAGE_PROVIDER : i32 = -2146500060;
pub const SPAPI_E_NO_SUCH_DEVICE_INTERFACE : i32 = -2146500059;
pub const SPAPI_E_DI_POSTPROCESSING_REQUIRED : i32 = -2146500058;
pub const SPAPI_E_INVALID_COINSTALLER : i32 = -2146500057;
pub const SPAPI_E_NO_COMPAT_DRIVERS : i32 = -2146500056;
pub const SPAPI_E_NO_DEVICE_ICON : i32 = -2146500055;
pub const SPAPI_E_INVALID_INF_LOGCONFIG : i32 = -2146500054;
pub const SPAPI_E_DI_DONT_INSTALL : i32 = -2146500053;
pub const SPAPI_E_INVALID_FILTER_DRIVER : i32 = -2146500052;
pub const SPAPI_E_NON_WINDOWS_NT_DRIVER : i32 = -2146500051;
pub const SPAPI_E_NON_WINDOWS_DRIVER : i32 = -2146500050;
pub const SPAPI_E_NO_CATALOG_FOR_OEM_INF : i32 = -2146500049;
pub const SPAPI_E_DEVINSTALL_QUEUE_NONNATIVE : i32 = -2146500048;
pub const SPAPI_E_NOT_DISABLEABLE : i32 = -2146500047;
pub const SPAPI_E_CANT_REMOVE_DEVINST : i32 = -2146500046;
pub const SPAPI_E_INVALID_TARGET : i32 = -2146500045;
pub const SPAPI_E_DRIVER_NONNATIVE : i32 = -2146500044;
pub const SPAPI_E_IN_WOW64 : i32 = -2146500043;
pub const SPAPI_E_SET_SYSTEM_RESTORE_POINT : i32 = -2146500042;
pub const SPAPI_E_INCORRECTLY_COPIED_INF : i32 = -2146500041;
pub const SPAPI_E_SCE_DISABLED : i32 = -2146500040;
pub const SPAPI_E_UNKNOWN_EXCEPTION : i32 = -2146500039;
pub const SPAPI_E_PNP_REGISTRY_ERROR : i32 = -2146500038;
pub const SPAPI_E_REMOTE_REQUEST_UNSUPPORTED : i32 = -2146500037;
pub const SPAPI_E_NOT_AN_INSTALLED_OEM_INF : i32 = -2146500036;
pub const SPAPI_E_INF_IN_USE_BY_DEVICES : i32 = -2146500035;
pub const SPAPI_E_DI_FUNCTION_OBSOLETE : i32 = -2146500034;
pub const SPAPI_E_NO_AUTHENTICODE_CATALOG : i32 = -2146500033;
pub const SPAPI_E_AUTHENTICODE_DISALLOWED : i32 = -2146500032;
pub const SPAPI_E_AUTHENTICODE_TRUSTED_PUBLISHER : i32 = -2146500031;
pub const SPAPI_E_AUTHENTICODE_TRUST_NOT_ESTABLISHED : i32 = -2146500030;
pub const SPAPI_E_AUTHENTICODE_PUBLISHER_NOT_TRUSTED : i32 = -2146500029;
pub const SPAPI_E_SIGNATURE_OSATTRIBUTE_MISMATCH : i32 = -2146500028;
pub const SPAPI_E_ONLY_VALIDATE_VIA_AUTHENTICODE : i32 = -2146500027;
pub const SPAPI_E_DEVICE_INSTALLER_NOT_READY : i32 = -2146500026;
pub const SPAPI_E_DRIVER_STORE_ADD_FAILED : i32 = -2146500025;
pub const SPAPI_E_DEVICE_INSTALL_BLOCKED : i32 = -2146500024;
pub const SPAPI_E_DRIVER_INSTALL_BLOCKED : i32 = -2146500023;
pub const SPAPI_E_WRONG_INF_TYPE : i32 = -2146500022;
pub const SPAPI_E_FILE_HASH_NOT_IN_CATALOG : i32 = -2146500021;
pub const SPAPI_E_DRIVER_STORE_DELETE_FAILED : i32 = -2146500020;
pub const SPAPI_E_UNRECOVERABLE_STACK_OVERFLOW : i32 = -2146499840;
pub const SPAPI_E_ERROR_NOT_INSTALLED : i32 = -2146496512;
pub const SCARD_F_INTERNAL_ERROR : i32 = -2146435071;
pub const SCARD_E_CANCELLED : i32 = -2146435070;
pub const SCARD_E_INVALID_HANDLE : i32 = -2146435069;
pub const SCARD_E_INVALID_PARAMETER : i32 = -2146435068;
pub const SCARD_E_INVALID_TARGET : i32 = -2146435067;
pub const SCARD_E_NO_MEMORY : i32 = -2146435066;
pub const SCARD_F_WAITED_TOO_LONG : i32 = -2146435065;
pub const SCARD_E_INSUFFICIENT_BUFFER : i32 = -2146435064;
pub const SCARD_E_UNKNOWN_READER : i32 = -2146435063;
pub const SCARD_E_TIMEOUT : i32 = -2146435062;
pub const SCARD_E_SHARING_VIOLATION : i32 = -2146435061;
pub const SCARD_E_NO_SMARTCARD : i32 = -2146435060;
pub const SCARD_E_UNKNOWN_CARD : i32 = -2146435059;
pub const SCARD_E_CANT_DISPOSE : i32 = -2146435058;
pub const SCARD_E_PROTO_MISMATCH : i32 = -2146435057;
pub const SCARD_E_NOT_READY : i32 = -2146435056;
pub const SCARD_E_INVALID_VALUE : i32 = -2146435055;
pub const SCARD_E_SYSTEM_CANCELLED : i32 = -2146435054;
pub const SCARD_F_COMM_ERROR : i32 = -2146435053;
pub const SCARD_F_UNKNOWN_ERROR : i32 = -2146435052;
pub const SCARD_E_INVALID_ATR : i32 = -2146435051;
pub const SCARD_E_NOT_TRANSACTED : i32 = -2146435050;
pub const SCARD_E_READER_UNAVAILABLE : i32 = -2146435049;
pub const SCARD_P_SHUTDOWN : i32 = -2146435048;
pub const SCARD_E_PCI_TOO_SMALL : i32 = -2146435047;
pub const SCARD_E_READER_UNSUPPORTED : i32 = -2146435046;
pub const SCARD_E_DUPLICATE_READER : i32 = -2146435045;
pub const SCARD_E_CARD_UNSUPPORTED : i32 = -2146435044;
pub const SCARD_E_NO_SERVICE : i32 = -2146435043;
pub const SCARD_E_SERVICE_STOPPED : i32 = -2146435042;
pub const SCARD_E_UNEXPECTED : i32 = -2146435041;
pub const SCARD_E_ICC_INSTALLATION : i32 = -2146435040;
pub const SCARD_E_ICC_CREATEORDER : i32 = -2146435039;
pub const SCARD_E_UNSUPPORTED_FEATURE : i32 = -2146435038;
pub const SCARD_E_DIR_NOT_FOUND : i32 = -2146435037;
pub const SCARD_E_FILE_NOT_FOUND : i32 = -2146435036;
pub const SCARD_E_NO_DIR : i32 = -2146435035;
pub const SCARD_E_NO_FILE : i32 = -2146435034;
pub const SCARD_E_NO_ACCESS : i32 = -2146435033;
pub const SCARD_E_WRITE_TOO_MANY : i32 = -2146435032;
pub const SCARD_E_BAD_SEEK : i32 = -2146435031;
pub const SCARD_E_INVALID_CHV : i32 = -2146435030;
pub const SCARD_E_UNKNOWN_RES_MNG : i32 = -2146435029;
pub const SCARD_E_NO_SUCH_CERTIFICATE : i32 = -2146435028;
pub const SCARD_E_CERTIFICATE_UNAVAILABLE : i32 = -2146435027;
pub const SCARD_E_NO_READERS_AVAILABLE : i32 = -2146435026;
pub const SCARD_E_COMM_DATA_LOST : i32 = -2146435025;
pub const SCARD_E_NO_KEY_CONTAINER : i32 = -2146435024;
pub const SCARD_E_SERVER_TOO_BUSY : i32 = -2146435023;
pub const SCARD_E_PIN_CACHE_EXPIRED : i32 = -2146435022;
pub const SCARD_E_NO_PIN_CACHE : i32 = -2146435021;
pub const SCARD_E_READ_ONLY_CARD : i32 = -2146435020;
pub const SCARD_W_UNSUPPORTED_CARD : i32 = -2146434971;
pub const SCARD_W_UNRESPONSIVE_CARD : i32 = -2146434970;
pub const SCARD_W_UNPOWERED_CARD : i32 = -2146434969;
pub const SCARD_W_RESET_CARD : i32 = -2146434968;
pub const SCARD_W_REMOVED_CARD : i32 = -2146434967;
pub const SCARD_W_SECURITY_VIOLATION : i32 = -2146434966;
pub const SCARD_W_WRONG_CHV : i32 = -2146434965;
pub const SCARD_W_CHV_BLOCKED : i32 = -2146434964;
pub const SCARD_W_EOF : i32 = -2146434963;
pub const SCARD_W_CANCELLED_BY_USER : i32 = -2146434962;
pub const SCARD_W_CARD_NOT_AUTHENTICATED : i32 = -2146434961;
pub const SCARD_W_CACHE_ITEM_NOT_FOUND : i32 = -2146434960;
pub const SCARD_W_CACHE_ITEM_STALE : i32 = -2146434959;
pub const SCARD_W_CACHE_ITEM_TOO_BIG : i32 = -2146434958;
pub const COMADMIN_E_OBJECTERRORS : i32 = -2146368511;
pub const COMADMIN_E_OBJECTINVALID : i32 = -2146368510;
pub const COMADMIN_E_KEYMISSING : i32 = -2146368509;
pub const COMADMIN_E_ALREADYINSTALLED : i32 = -2146368508;
pub const COMADMIN_E_APP_FILE_WRITEFAIL : i32 = -2146368505;
pub const COMADMIN_E_APP_FILE_READFAIL : i32 = -2146368504;
pub const COMADMIN_E_APP_FILE_VERSION : i32 = -2146368503;
pub const COMADMIN_E_BADPATH : i32 = -2146368502;
pub const COMADMIN_E_APPLICATIONEXISTS : i32 = -2146368501;
pub const COMADMIN_E_ROLEEXISTS : i32 = -2146368500;
pub const COMADMIN_E_CANTCOPYFILE : i32 = -2146368499;
pub const COMADMIN_E_NOUSER : i32 = -2146368497;
pub const COMADMIN_E_INVALIDUSERIDS : i32 = -2146368496;
pub const COMADMIN_E_NOREGISTRYCLSID : i32 = -2146368495;
pub const COMADMIN_E_BADREGISTRYPROGID : i32 = -2146368494;
pub const COMADMIN_E_AUTHENTICATIONLEVEL : i32 = -2146368493;
pub const COMADMIN_E_USERPASSWDNOTVALID : i32 = -2146368492;
pub const COMADMIN_E_CLSIDORIIDMISMATCH : i32 = -2146368488;
pub const COMADMIN_E_REMOTEINTERFACE : i32 = -2146368487;
pub const COMADMIN_E_DLLREGISTERSERVER : i32 = -2146368486;
pub const COMADMIN_E_NOSERVERSHARE : i32 = -2146368485;
pub const COMADMIN_E_DLLLOADFAILED : i32 = -2146368483;
pub const COMADMIN_E_BADREGISTRYLIBID : i32 = -2146368482;
pub const COMADMIN_E_APPDIRNOTFOUND : i32 = -2146368481;
pub const COMADMIN_E_REGISTRARFAILED : i32 = -2146368477;
pub const COMADMIN_E_COMPFILE_DOESNOTEXIST : i32 = -2146368476;
pub const COMADMIN_E_COMPFILE_LOADDLLFAIL : i32 = -2146368475;
pub const COMADMIN_E_COMPFILE_GETCLASSOBJ : i32 = -2146368474;
pub const COMADMIN_E_COMPFILE_CLASSNOTAVAIL : i32 = -2146368473;
pub const COMADMIN_E_COMPFILE_BADTLB : i32 = -2146368472;
pub const COMADMIN_E_COMPFILE_NOTINSTALLABLE : i32 = -2146368471;
pub const COMADMIN_E_NOTCHANGEABLE : i32 = -2146368470;
pub const COMADMIN_E_NOTDELETEABLE : i32 = -2146368469;
pub const COMADMIN_E_SESSION : i32 = -2146368468;
pub const COMADMIN_E_COMP_MOVE_LOCKED : i32 = -2146368467;
pub const COMADMIN_E_COMP_MOVE_BAD_DEST : i32 = -2146368466;
pub const COMADMIN_E_REGISTERTLB : i32 = -2146368464;
pub const COMADMIN_E_SYSTEMAPP : i32 = -2146368461;
pub const COMADMIN_E_COMPFILE_NOREGISTRAR : i32 = -2146368460;
pub const COMADMIN_E_COREQCOMPINSTALLED : i32 = -2146368459;
pub const COMADMIN_E_SERVICENOTINSTALLED : i32 = -2146368458;
pub const COMADMIN_E_PROPERTYSAVEFAILED : i32 = -2146368457;
pub const COMADMIN_E_OBJECTEXISTS : i32 = -2146368456;
pub const COMADMIN_E_COMPONENTEXISTS : i32 = -2146368455;
pub const COMADMIN_E_REGFILE_CORRUPT : i32 = -2146368453;
pub const COMADMIN_E_PROPERTY_OVERFLOW : i32 = -2146368452;
pub const COMADMIN_E_NOTINREGISTRY : i32 = -2146368450;
pub const COMADMIN_E_OBJECTNOTPOOLABLE : i32 = -2146368449;
pub const COMADMIN_E_APPLID_MATCHES_CLSID : i32 = -2146368442;
pub const COMADMIN_E_ROLE_DOES_NOT_EXIST : i32 = -2146368441;
pub const COMADMIN_E_START_APP_NEEDS_COMPONENTS : i32 = -2146368440;
pub const COMADMIN_E_REQUIRES_DIFFERENT_PLATFORM : i32 = -2146368439;
pub const COMADMIN_E_CAN_NOT_EXPORT_APP_PROXY : i32 = -2146368438;
pub const COMADMIN_E_CAN_NOT_START_APP : i32 = -2146368437;
pub const COMADMIN_E_CAN_NOT_EXPORT_SYS_APP : i32 = -2146368436;
pub const COMADMIN_E_CANT_SUBSCRIBE_TO_COMPONENT : i32 = -2146368435;
pub const COMADMIN_E_EVENTCLASS_CANT_BE_SUBSCRIBER : i32 = -2146368434;
pub const COMADMIN_E_LIB_APP_PROXY_INCOMPATIBLE : i32 = -2146368433;
pub const COMADMIN_E_BASE_PARTITION_ONLY : i32 = -2146368432;
pub const COMADMIN_E_START_APP_DISABLED : i32 = -2146368431;
pub const COMADMIN_E_CAT_DUPLICATE_PARTITION_NAME : i32 = -2146368425;
pub const COMADMIN_E_CAT_INVALID_PARTITION_NAME : i32 = -2146368424;
pub const COMADMIN_E_CAT_PARTITION_IN_USE : i32 = -2146368423;
pub const COMADMIN_E_FILE_PARTITION_DUPLICATE_FILES : i32 = -2146368422;
pub const COMADMIN_E_CAT_IMPORTED_COMPONENTS_NOT_ALLOWED : i32 = -2146368421;
pub const COMADMIN_E_AMBIGUOUS_APPLICATION_NAME : i32 = -2146368420;
pub const COMADMIN_E_AMBIGUOUS_PARTITION_NAME : i32 = -2146368419;
pub const COMADMIN_E_REGDB_NOTINITIALIZED : i32 = -2146368398;
pub const COMADMIN_E_REGDB_NOTOPEN : i32 = -2146368397;
pub const COMADMIN_E_REGDB_SYSTEMERR : i32 = -2146368396;
pub const COMADMIN_E_REGDB_ALREADYRUNNING : i32 = -2146368395;
pub const COMADMIN_E_MIG_VERSIONNOTSUPPORTED : i32 = -2146368384;
pub const COMADMIN_E_MIG_SCHEMANOTFOUND : i32 = -2146368383;
pub const COMADMIN_E_CAT_BITNESSMISMATCH : i32 = -2146368382;
pub const COMADMIN_E_CAT_UNACCEPTABLEBITNESS : i32 = -2146368381;
pub const COMADMIN_E_CAT_WRONGAPPBITNESS : i32 = -2146368380;
pub const COMADMIN_E_CAT_PAUSE_RESUME_NOT_SUPPORTED : i32 = -2146368379;
pub const COMADMIN_E_CAT_SERVERFAULT : i32 = -2146368378;
pub const COMQC_E_APPLICATION_NOT_QUEUED : i32 = -2146368000;
pub const COMQC_E_NO_QUEUEABLE_INTERFACES : i32 = -2146367999;
pub const COMQC_E_QUEUING_SERVICE_NOT_AVAILABLE : i32 = -2146367998;
pub const COMQC_E_NO_IPERSISTSTREAM : i32 = -2146367997;
pub const COMQC_E_BAD_MESSAGE : i32 = -2146367996;
pub const COMQC_E_UNAUTHENTICATED : i32 = -2146367995;
pub const COMQC_E_UNTRUSTED_ENQUEUER : i32 = -2146367994;
pub const MSDTC_E_DUPLICATE_RESOURCE : i32 = -2146367743;
pub const COMADMIN_E_OBJECT_PARENT_MISSING : i32 = -2146367480;
pub const COMADMIN_E_OBJECT_DOES_NOT_EXIST : i32 = -2146367479;
pub const COMADMIN_E_APP_NOT_RUNNING : i32 = -2146367478;
pub const COMADMIN_E_INVALID_PARTITION : i32 = -2146367477;
pub const COMADMIN_E_SVCAPP_NOT_POOLABLE_OR_RECYCLABLE : i32 = -2146367475;
pub const COMADMIN_E_USER_IN_SET : i32 = -2146367474;
pub const COMADMIN_E_CANTRECYCLELIBRARYAPPS : i32 = -2146367473;
pub const COMADMIN_E_CANTRECYCLESERVICEAPPS : i32 = -2146367471;
pub const COMADMIN_E_PROCESSALREADYRECYCLED : i32 = -2146367470;
pub const COMADMIN_E_PAUSEDPROCESSMAYNOTBERECYCLED : i32 = -2146367469;
pub const COMADMIN_E_CANTMAKEINPROCSERVICE : i32 = -2146367468;
pub const COMADMIN_E_PROGIDINUSEBYCLSID : i32 = -2146367467;
pub const COMADMIN_E_DEFAULT_PARTITION_NOT_IN_SET : i32 = -2146367466;
pub const COMADMIN_E_RECYCLEDPROCESSMAYNOTBEPAUSED : i32 = -2146367465;
pub const COMADMIN_E_PARTITION_ACCESSDENIED : i32 = -2146367464;
pub const COMADMIN_E_PARTITION_MSI_ONLY : i32 = -2146367463;
pub const COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_1_0_FORMAT : i32 = -2146367462;
pub const COMADMIN_E_LEGACYCOMPS_NOT_ALLOWED_IN_NONBASE_PARTITIONS : i32 = -2146367461;
pub const COMADMIN_E_COMP_MOVE_SOURCE : i32 = -2146367460;
pub const COMADMIN_E_COMP_MOVE_DEST : i32 = -2146367459;
pub const COMADMIN_E_COMP_MOVE_PRIVATE : i32 = -2146367458;
pub const COMADMIN_E_BASEPARTITION_REQUIRED_IN_SET : i32 = -2146367457;
pub const COMADMIN_E_CANNOT_ALIAS_EVENTCLASS : i32 = -2146367456;
pub const COMADMIN_E_PRIVATE_ACCESSDENIED : i32 = -2146367455;
pub const COMADMIN_E_SAFERINVALID : i32 = -2146367454;
pub const COMADMIN_E_REGISTRY_ACCESSDENIED : i32 = -2146367453;
pub const COMADMIN_E_PARTITIONS_DISABLED : i32 = -2146367452;
pub const WER_S_REPORT_DEBUG : i32 = 1769472;
pub const WER_S_REPORT_UPLOADED : i32 = 1769473;
pub const WER_S_REPORT_QUEUED : i32 = 1769474;
pub const WER_S_DISABLED : i32 = 1769475;
pub const WER_S_SUSPENDED_UPLOAD : i32 = 1769476;
pub const WER_S_DISABLED_QUEUE : i32 = 1769477;
pub const WER_S_DISABLED_ARCHIVE : i32 = 1769478;
pub const WER_S_REPORT_ASYNC : i32 = 1769479;
pub const WER_S_IGNORE_ASSERT_INSTANCE : i32 = 1769480;
pub const WER_S_IGNORE_ALL_ASSERTS : i32 = 1769481;
pub const WER_S_ASSERT_CONTINUE : i32 = 1769482;
pub const WER_S_THROTTLED : i32 = 1769483;
pub const WER_S_REPORT_UPLOADED_CAB : i32 = 1769484;
pub const WER_E_CRASH_FAILURE : i32 = -2145681408;
pub const WER_E_CANCELED : i32 = -2145681407;
pub const WER_E_NETWORK_FAILURE : i32 = -2145681406;
pub const WER_E_NOT_INITIALIZED : i32 = -2145681405;
pub const WER_E_ALREADY_REPORTING : i32 = -2145681404;
pub const WER_E_DUMP_THROTTLED : i32 = -2145681403;
pub const WER_E_INSUFFICIENT_CONSENT : i32 = -2145681402;
pub const WER_E_TOO_HEAVY : i32 = -2145681401;
pub const ERROR_FLT_IO_COMPLETE : i32 = 2031617;
pub const ERROR_FLT_NO_HANDLER_DEFINED : i32 = -2145452031;
pub const ERROR_FLT_CONTEXT_ALREADY_DEFINED : i32 = -2145452030;
pub const ERROR_FLT_INVALID_ASYNCHRONOUS_REQUEST : i32 = -2145452029;
pub const ERROR_FLT_DISALLOW_FAST_IO : i32 = -2145452028;
pub const ERROR_FLT_INVALID_NAME_REQUEST : i32 = -2145452027;
pub const ERROR_FLT_NOT_SAFE_TO_POST_OPERATION : i32 = -2145452026;
pub const ERROR_FLT_NOT_INITIALIZED : i32 = -2145452025;
pub const ERROR_FLT_FILTER_NOT_READY : i32 = -2145452024;
pub const ERROR_FLT_POST_OPERATION_CLEANUP : i32 = -2145452023;
pub const ERROR_FLT_INTERNAL_ERROR : i32 = -2145452022;
pub const ERROR_FLT_DELETING_OBJECT : i32 = -2145452021;
pub const ERROR_FLT_MUST_BE_NONPAGED_POOL : i32 = -2145452020;
pub const ERROR_FLT_DUPLICATE_ENTRY : i32 = -2145452019;
pub const ERROR_FLT_CBDQ_DISABLED : i32 = -2145452018;
pub const ERROR_FLT_DO_NOT_ATTACH : i32 = -2145452017;
pub const ERROR_FLT_DO_NOT_DETACH : i32 = -2145452016;
pub const ERROR_FLT_INSTANCE_ALTITUDE_COLLISION : i32 = -2145452015;
pub const ERROR_FLT_INSTANCE_NAME_COLLISION : i32 = -2145452014;
pub const ERROR_FLT_FILTER_NOT_FOUND : i32 = -2145452013;
pub const ERROR_FLT_VOLUME_NOT_FOUND : i32 = -2145452012;
pub const ERROR_FLT_INSTANCE_NOT_FOUND : i32 = -2145452011;
pub const ERROR_FLT_CONTEXT_ALLOCATION_NOT_FOUND : i32 = -2145452010;
pub const ERROR_FLT_INVALID_CONTEXT_REGISTRATION : i32 = -2145452009;
pub const ERROR_FLT_NAME_CACHE_MISS : i32 = -2145452008;
pub const ERROR_FLT_NO_DEVICE_OBJECT : i32 = -2145452007;
pub const ERROR_FLT_VOLUME_ALREADY_MOUNTED : i32 = -2145452006;
pub const ERROR_FLT_ALREADY_ENLISTED : i32 = -2145452005;
pub const ERROR_FLT_CONTEXT_ALREADY_LINKED : i32 = -2145452004;
pub const ERROR_FLT_NO_WAITER_FOR_REPLY : i32 = -2145452000;
pub const ERROR_FLT_REGISTRATION_BUSY : i32 = -2145451997;
pub const ERROR_HUNG_DISPLAY_DRIVER_THREAD : i32 = -2144993279;
pub const DWM_E_COMPOSITIONDISABLED : i32 = -2144980991;
pub const DWM_E_REMOTING_NOT_SUPPORTED : i32 = -2144980990;
pub const DWM_E_NO_REDIRECTION_SURFACE_AVAILABLE : i32 = -2144980989;
pub const DWM_E_NOT_QUEUING_PRESENTS : i32 = -2144980988;
pub const DWM_E_ADAPTER_NOT_FOUND : i32 = -2144980987;
pub const DWM_S_GDI_REDIRECTION_SURFACE : i32 = 2502661;
pub const DWM_E_TEXTURE_TOO_LARGE : i32 = -2144980985;
pub const DWM_S_GDI_REDIRECTION_SURFACE_BLT_VIA_GDI : i32 = 2502664;
pub const ERROR_MONITOR_NO_DESCRIPTOR : i32 = 2494465;
pub const ERROR_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT : i32 = 2494466;
pub const ERROR_MONITOR_INVALID_DESCRIPTOR_CHECKSUM : i32 = -1071247357;
pub const ERROR_MONITOR_INVALID_STANDARD_TIMING_BLOCK : i32 = -1071247356;
pub const ERROR_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED : i32 = -1071247355;
pub const ERROR_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK : i32 = -1071247354;
pub const ERROR_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK : i32 = -1071247353;
pub const ERROR_MONITOR_NO_MORE_DESCRIPTOR_DATA : i32 = -1071247352;
pub const ERROR_MONITOR_INVALID_DETAILED_TIMING_BLOCK : i32 = -1071247351;
pub const ERROR_MONITOR_INVALID_MANUFACTURE_DATE : i32 = -1071247350;
pub const ERROR_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER : i32 = -1071243264;
pub const ERROR_GRAPHICS_INSUFFICIENT_DMA_BUFFER : i32 = -1071243263;
pub const ERROR_GRAPHICS_INVALID_DISPLAY_ADAPTER : i32 = -1071243262;
pub const ERROR_GRAPHICS_ADAPTER_WAS_RESET : i32 = -1071243261;
pub const ERROR_GRAPHICS_INVALID_DRIVER_MODEL : i32 = -1071243260;
pub const ERROR_GRAPHICS_PRESENT_MODE_CHANGED : i32 = -1071243259;
pub const ERROR_GRAPHICS_PRESENT_OCCLUDED : i32 = -1071243258;
pub const ERROR_GRAPHICS_PRESENT_DENIED : i32 = -1071243257;
pub const ERROR_GRAPHICS_CANNOTCOLORCONVERT : i32 = -1071243256;
pub const ERROR_GRAPHICS_DRIVER_MISMATCH : i32 = -1071243255;
pub const ERROR_GRAPHICS_PARTIAL_DATA_POPULATED : i32 = 1076240394;
pub const ERROR_GRAPHICS_PRESENT_REDIRECTION_DISABLED : i32 = -1071243253;
pub const ERROR_GRAPHICS_PRESENT_UNOCCLUDED : i32 = -1071243252;
pub const ERROR_GRAPHICS_WINDOWDC_NOT_AVAILABLE : i32 = -1071243251;
pub const ERROR_GRAPHICS_WINDOWLESS_PRESENT_DISABLED : i32 = -1071243250;
pub const ERROR_GRAPHICS_PRESENT_INVALID_WINDOW : i32 = -1071243249;
pub const ERROR_GRAPHICS_PRESENT_BUFFER_NOT_BOUND : i32 = -1071243248;
pub const ERROR_GRAPHICS_VAIL_STATE_CHANGED : i32 = -1071243247;
pub const ERROR_GRAPHICS_INDIRECT_DISPLAY_ABANDON_SWAPCHAIN : i32 = -1071243246;
pub const ERROR_GRAPHICS_INDIRECT_DISPLAY_DEVICE_STOPPED : i32 = -1071243245;
pub const ERROR_GRAPHICS_VAIL_FAILED_TO_SEND_CREATE_SUPERWETINK_MESSAGE : i32 = -1071243244;
pub const ERROR_GRAPHICS_VAIL_FAILED_TO_SEND_DESTROY_SUPERWETINK_MESSAGE : i32 = -1071243243;
pub const ERROR_GRAPHICS_NO_VIDEO_MEMORY : i32 = -1071243008;
pub const ERROR_GRAPHICS_CANT_LOCK_MEMORY : i32 = -1071243007;
pub const ERROR_GRAPHICS_ALLOCATION_BUSY : i32 = -1071243006;
pub const ERROR_GRAPHICS_TOO_MANY_REFERENCES : i32 = -1071243005;
pub const ERROR_GRAPHICS_TRY_AGAIN_LATER : i32 = -1071243004;
pub const ERROR_GRAPHICS_TRY_AGAIN_NOW : i32 = -1071243003;
pub const ERROR_GRAPHICS_ALLOCATION_INVALID : i32 = -1071243002;
pub const ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE : i32 = -1071243001;
pub const ERROR_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED : i32 = -1071243000;
pub const ERROR_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION : i32 = -1071242999;
pub const ERROR_GRAPHICS_INVALID_ALLOCATION_USAGE : i32 = -1071242992;
pub const ERROR_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION : i32 = -1071242991;
pub const ERROR_GRAPHICS_ALLOCATION_CLOSED : i32 = -1071242990;
pub const ERROR_GRAPHICS_INVALID_ALLOCATION_INSTANCE : i32 = -1071242989;
pub const ERROR_GRAPHICS_INVALID_ALLOCATION_HANDLE : i32 = -1071242988;
pub const ERROR_GRAPHICS_WRONG_ALLOCATION_DEVICE : i32 = -1071242987;
pub const ERROR_GRAPHICS_ALLOCATION_CONTENT_LOST : i32 = -1071242986;
pub const ERROR_GRAPHICS_GPU_EXCEPTION_ON_DEVICE : i32 = -1071242752;
pub const ERROR_GRAPHICS_SKIP_ALLOCATION_PREPARATION : i32 = 1076240897;
pub const ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY : i32 = -1071242496;
pub const ERROR_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED : i32 = -1071242495;
pub const ERROR_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED : i32 = -1071242494;
pub const ERROR_GRAPHICS_INVALID_VIDPN : i32 = -1071242493;
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE : i32 = -1071242492;
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET : i32 = -1071242491;
pub const ERROR_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED : i32 = -1071242490;
pub const ERROR_GRAPHICS_MODE_NOT_PINNED : i32 = 2499335;
pub const ERROR_GRAPHICS_INVALID_VIDPN_SOURCEMODESET : i32 = -1071242488;
pub const ERROR_GRAPHICS_INVALID_VIDPN_TARGETMODESET : i32 = -1071242487;
pub const ERROR_GRAPHICS_INVALID_FREQUENCY : i32 = -1071242486;
pub const ERROR_GRAPHICS_INVALID_ACTIVE_REGION : i32 = -1071242485;
pub const ERROR_GRAPHICS_INVALID_TOTAL_REGION : i32 = -1071242484;
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE : i32 = -1071242480;
pub const ERROR_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE : i32 = -1071242479;
pub const ERROR_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET : i32 = -1071242478;
pub const ERROR_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY : i32 = -1071242477;
pub const ERROR_GRAPHICS_MODE_ALREADY_IN_MODESET : i32 = -1071242476;
pub const ERROR_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET : i32 = -1071242475;
pub const ERROR_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET : i32 = -1071242474;
pub const ERROR_GRAPHICS_SOURCE_ALREADY_IN_SET : i32 = -1071242473;
pub const ERROR_GRAPHICS_TARGET_ALREADY_IN_SET : i32 = -1071242472;
pub const ERROR_GRAPHICS_INVALID_VIDPN_PRESENT_PATH : i32 = -1071242471;
pub const ERROR_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY : i32 = -1071242470;
pub const ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET : i32 = -1071242469;
pub const ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE : i32 = -1071242468;
pub const ERROR_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET : i32 = -1071242467;
pub const ERROR_GRAPHICS_NO_PREFERRED_MODE : i32 = 2499358;
pub const ERROR_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET : i32 = -1071242465;
pub const ERROR_GRAPHICS_STALE_MODESET : i32 = -1071242464;
pub const ERROR_GRAPHICS_INVALID_MONITOR_SOURCEMODESET : i32 = -1071242463;
pub const ERROR_GRAPHICS_INVALID_MONITOR_SOURCE_MODE : i32 = -1071242462;
pub const ERROR_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN : i32 = -1071242461;
pub const ERROR_GRAPHICS_MODE_ID_MUST_BE_UNIQUE : i32 = -1071242460;
pub const ERROR_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION : i32 = -1071242459;
pub const ERROR_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES : i32 = -1071242458;
pub const ERROR_GRAPHICS_PATH_NOT_IN_TOPOLOGY : i32 = -1071242457;
pub const ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE : i32 = -1071242456;
pub const ERROR_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET : i32 = -1071242455;
pub const ERROR_GRAPHICS_INVALID_MONITORDESCRIPTORSET : i32 = -1071242454;
pub const ERROR_GRAPHICS_INVALID_MONITORDESCRIPTOR : i32 = -1071242453;
pub const ERROR_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET : i32 = -1071242452;
pub const ERROR_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET : i32 = -1071242451;
pub const ERROR_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE : i32 = -1071242450;
pub const ERROR_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE : i32 = -1071242449;
pub const ERROR_GRAPHICS_RESOURCES_NOT_RELATED : i32 = -1071242448;
pub const ERROR_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE : i32 = -1071242447;
pub const ERROR_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE : i32 = -1071242446;
pub const ERROR_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET : i32 = -1071242445;
pub const ERROR_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER : i32 = -1071242444;
pub const ERROR_GRAPHICS_NO_VIDPNMGR : i32 = -1071242443;
pub const ERROR_GRAPHICS_NO_ACTIVE_VIDPN : i32 = -1071242442;
pub const ERROR_GRAPHICS_STALE_VIDPN_TOPOLOGY : i32 = -1071242441;
pub const ERROR_GRAPHICS_MONITOR_NOT_CONNECTED : i32 = -1071242440;
pub const ERROR_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY : i32 = -1071242439;
pub const ERROR_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE : i32 = -1071242438;
pub const ERROR_GRAPHICS_INVALID_VISIBLEREGION_SIZE : i32 = -1071242437;
pub const ERROR_GRAPHICS_INVALID_STRIDE : i32 = -1071242436;
pub const ERROR_GRAPHICS_INVALID_PIXELFORMAT : i32 = -1071242435;
pub const ERROR_GRAPHICS_INVALID_COLORBASIS : i32 = -1071242434;
pub const ERROR_GRAPHICS_INVALID_PIXELVALUEACCESSMODE : i32 = -1071242433;
pub const ERROR_GRAPHICS_TARGET_NOT_IN_TOPOLOGY : i32 = -1071242432;
pub const ERROR_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT : i32 = -1071242431;
pub const ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE : i32 = -1071242430;
pub const ERROR_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN : i32 = -1071242429;
pub const ERROR_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL : i32 = -1071242428;
pub const ERROR_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION : i32 = -1071242427;
pub const ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED : i32 = -1071242426;
pub const ERROR_GRAPHICS_INVALID_GAMMA_RAMP : i32 = -1071242425;
pub const ERROR_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED : i32 = -1071242424;
pub const ERROR_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED : i32 = -1071242423;
pub const ERROR_GRAPHICS_MODE_NOT_IN_MODESET : i32 = -1071242422;
pub const ERROR_GRAPHICS_DATASET_IS_EMPTY : i32 = 2499403;
pub const ERROR_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET : i32 = 2499404;
pub const ERROR_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON : i32 = -1071242419;
pub const ERROR_GRAPHICS_INVALID_PATH_CONTENT_TYPE : i32 = -1071242418;
pub const ERROR_GRAPHICS_INVALID_COPYPROTECTION_TYPE : i32 = -1071242417;
pub const ERROR_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS : i32 = -1071242416;
pub const ERROR_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED : i32 = 2499409;
pub const ERROR_GRAPHICS_INVALID_SCANLINE_ORDERING : i32 = -1071242414;
pub const ERROR_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED : i32 = -1071242413;
pub const ERROR_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS : i32 = -1071242412;
pub const ERROR_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT : i32 = -1071242411;
pub const ERROR_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM : i32 = -1071242410;
pub const ERROR_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN : i32 = -1071242409;
pub const ERROR_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT : i32 = -1071242408;
pub const ERROR_GRAPHICS_MAX_NUM_PATHS_REACHED : i32 = -1071242407;
pub const ERROR_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION : i32 = -1071242406;
pub const ERROR_GRAPHICS_INVALID_CLIENT_TYPE : i32 = -1071242405;
pub const ERROR_GRAPHICS_CLIENTVIDPN_NOT_SET : i32 = -1071242404;
pub const ERROR_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED : i32 = -1071242240;
pub const ERROR_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED : i32 = -1071242239;
pub const ERROR_GRAPHICS_UNKNOWN_CHILD_STATUS : i32 = 1076241455;
pub const ERROR_GRAPHICS_NOT_A_LINKED_ADAPTER : i32 = -1071242192;
pub const ERROR_GRAPHICS_LEADLINK_NOT_ENUMERATED : i32 = -1071242191;
pub const ERROR_GRAPHICS_CHAINLINKS_NOT_ENUMERATED : i32 = -1071242190;
pub const ERROR_GRAPHICS_ADAPTER_CHAIN_NOT_READY : i32 = -1071242189;
pub const ERROR_GRAPHICS_CHAINLINKS_NOT_STARTED : i32 = -1071242188;
pub const ERROR_GRAPHICS_CHAINLINKS_NOT_POWERED_ON : i32 = -1071242187;
pub const ERROR_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE : i32 = -1071242186;
pub const ERROR_GRAPHICS_LEADLINK_START_DEFERRED : i32 = 1076241463;
pub const ERROR_GRAPHICS_NOT_POST_DEVICE_DRIVER : i32 = -1071242184;
pub const ERROR_GRAPHICS_POLLING_TOO_FREQUENTLY : i32 = 1076241465;
pub const ERROR_GRAPHICS_START_DEFERRED : i32 = 1076241466;
pub const ERROR_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED : i32 = -1071242181;
pub const ERROR_GRAPHICS_DEPENDABLE_CHILD_STATUS : i32 = 1076241468;
pub const ERROR_GRAPHICS_OPM_NOT_SUPPORTED : i32 = -1071241984;
pub const ERROR_GRAPHICS_COPP_NOT_SUPPORTED : i32 = -1071241983;
pub const ERROR_GRAPHICS_UAB_NOT_SUPPORTED : i32 = -1071241982;
pub const ERROR_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS : i32 = -1071241981;
pub const ERROR_GRAPHICS_OPM_NO_VIDEO_OUTPUTS_EXIST : i32 = -1071241979;
pub const ERROR_GRAPHICS_OPM_INTERNAL_ERROR : i32 = -1071241973;
pub const ERROR_GRAPHICS_OPM_INVALID_HANDLE : i32 = -1071241972;
pub const ERROR_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH : i32 = -1071241970;
pub const ERROR_GRAPHICS_OPM_SPANNING_MODE_ENABLED : i32 = -1071241969;
pub const ERROR_GRAPHICS_OPM_THEATER_MODE_ENABLED : i32 = -1071241968;
pub const ERROR_GRAPHICS_PVP_HFS_FAILED : i32 = -1071241967;
pub const ERROR_GRAPHICS_OPM_INVALID_SRM : i32 = -1071241966;
pub const ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP : i32 = -1071241965;
pub const ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP : i32 = -1071241964;
pub const ERROR_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA : i32 = -1071241963;
pub const ERROR_GRAPHICS_OPM_HDCP_SRM_NEVER_SET : i32 = -1071241962;
pub const ERROR_GRAPHICS_OPM_RESOLUTION_TOO_HIGH : i32 = -1071241961;
pub const ERROR_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE : i32 = -1071241960;
pub const ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_NO_LONGER_EXISTS : i32 = -1071241958;
pub const ERROR_GRAPHICS_OPM_SESSION_TYPE_CHANGE_IN_PROGRESS : i32 = -1071241957;
pub const ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS : i32 = -1071241956;
pub const ERROR_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST : i32 = -1071241955;
pub const ERROR_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR : i32 = -1071241954;
pub const ERROR_GRAPHICS_OPM_VIDEO_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS : i32 = -1071241953;
pub const ERROR_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED : i32 = -1071241952;
pub const ERROR_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST : i32 = -1071241951;
pub const ERROR_GRAPHICS_I2C_NOT_SUPPORTED : i32 = -1071241856;
pub const ERROR_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST : i32 = -1071241855;
pub const ERROR_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA : i32 = -1071241854;
pub const ERROR_GRAPHICS_I2C_ERROR_RECEIVING_DATA : i32 = -1071241853;
pub const ERROR_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED : i32 = -1071241852;
pub const ERROR_GRAPHICS_DDCCI_INVALID_DATA : i32 = -1071241851;
pub const ERROR_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE : i32 = -1071241850;
pub const ERROR_GRAPHICS_MCA_INVALID_CAPABILITIES_STRING : i32 = -1071241849;
pub const ERROR_GRAPHICS_MCA_INTERNAL_ERROR : i32 = -1071241848;
pub const ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND : i32 = -1071241847;
pub const ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH : i32 = -1071241846;
pub const ERROR_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM : i32 = -1071241845;
pub const ERROR_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE : i32 = -1071241844;
pub const ERROR_GRAPHICS_MONITOR_NO_LONGER_EXISTS : i32 = -1071241843;
pub const ERROR_GRAPHICS_DDCCI_CURRENT_CURRENT_VALUE_GREATER_THAN_MAXIMUM_VALUE : i32 = -1071241768;
pub const ERROR_GRAPHICS_MCA_INVALID_VCP_VERSION : i32 = -1071241767;
pub const ERROR_GRAPHICS_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION : i32 = -1071241766;
pub const ERROR_GRAPHICS_MCA_MCCS_VERSION_MISMATCH : i32 = -1071241765;
pub const ERROR_GRAPHICS_MCA_UNSUPPORTED_MCCS_VERSION : i32 = -1071241764;
pub const ERROR_GRAPHICS_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED : i32 = -1071241762;
pub const ERROR_GRAPHICS_MCA_UNSUPPORTED_COLOR_TEMPERATURE : i32 = -1071241761;
pub const ERROR_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED : i32 = -1071241760;
pub const ERROR_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME : i32 = -1071241759;
pub const ERROR_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP : i32 = -1071241758;
pub const ERROR_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED : i32 = -1071241757;
pub const ERROR_GRAPHICS_INVALID_POINTER : i32 = -1071241756;
pub const ERROR_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE : i32 = -1071241755;
pub const ERROR_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL : i32 = -1071241754;
pub const ERROR_GRAPHICS_INTERNAL_ERROR : i32 = -1071241753;
pub const ERROR_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS : i32 = -1071249944;
pub const NAP_E_INVALID_PACKET : i32 = -2144927743;
pub const NAP_E_MISSING_SOH : i32 = -2144927742;
pub const NAP_E_CONFLICTING_ID : i32 = -2144927741;
pub const NAP_E_NO_CACHED_SOH : i32 = -2144927740;
pub const NAP_E_STILL_BOUND : i32 = -2144927739;
pub const NAP_E_NOT_REGISTERED : i32 = -2144927738;
pub const NAP_E_NOT_INITIALIZED : i32 = -2144927737;
pub const NAP_E_MISMATCHED_ID : i32 = -2144927736;
pub const NAP_E_NOT_PENDING : i32 = -2144927735;
pub const NAP_E_ID_NOT_FOUND : i32 = -2144927734;
pub const NAP_E_MAXSIZE_TOO_SMALL : i32 = -2144927733;
pub const NAP_E_SERVICE_NOT_RUNNING : i32 = -2144927732;
pub const NAP_S_CERT_ALREADY_PRESENT : i32 = 2555917;
pub const NAP_E_ENTITY_DISABLED : i32 = -2144927730;
pub const NAP_E_NETSH_GROUPPOLICY_ERROR : i32 = -2144927729;
pub const NAP_E_TOO_MANY_CALLS : i32 = -2144927728;
pub const NAP_E_SHV_CONFIG_EXISTED : i32 = -2144927727;
pub const NAP_E_SHV_CONFIG_NOT_FOUND : i32 = -2144927726;
pub const NAP_E_SHV_TIMEOUT : i32 = -2144927725;
pub const TPM_E_ERROR_MASK : i32 = -2144862208;
pub const TPM_E_AUTHFAIL : i32 = -2144862207;
pub const TPM_E_BADINDEX : i32 = -2144862206;
pub const TPM_E_BAD_PARAMETER : i32 = -2144862205;
pub const TPM_E_AUDITFAILURE : i32 = -2144862204;
pub const TPM_E_CLEAR_DISABLED : i32 = -2144862203;
pub const TPM_E_DEACTIVATED : i32 = -2144862202;
pub const TPM_E_DISABLED : i32 = -2144862201;
pub const TPM_E_DISABLED_CMD : i32 = -2144862200;
pub const TPM_E_FAIL : i32 = -2144862199;
pub const TPM_E_BAD_ORDINAL : i32 = -2144862198;
pub const TPM_E_INSTALL_DISABLED : i32 = -2144862197;
pub const TPM_E_INVALID_KEYHANDLE : i32 = -2144862196;
pub const TPM_E_KEYNOTFOUND : i32 = -2144862195;
pub const TPM_E_INAPPROPRIATE_ENC : i32 = -2144862194;
pub const TPM_E_MIGRATEFAIL : i32 = -2144862193;
pub const TPM_E_INVALID_PCR_INFO : i32 = -2144862192;
pub const TPM_E_NOSPACE : i32 = -2144862191;
pub const TPM_E_NOSRK : i32 = -2144862190;
pub const TPM_E_NOTSEALED_BLOB : i32 = -2144862189;
pub const TPM_E_OWNER_SET : i32 = -2144862188;
pub const TPM_E_RESOURCES : i32 = -2144862187;
pub const TPM_E_SHORTRANDOM : i32 = -2144862186;
pub const TPM_E_SIZE : i32 = -2144862185;
pub const TPM_E_WRONGPCRVAL : i32 = -2144862184;
pub const TPM_E_BAD_PARAM_SIZE : i32 = -2144862183;
pub const TPM_E_SHA_THREAD : i32 = -2144862182;
pub const TPM_E_SHA_ERROR : i32 = -2144862181;
pub const TPM_E_FAILEDSELFTEST : i32 = -2144862180;
pub const TPM_E_AUTH2FAIL : i32 = -2144862179;
pub const TPM_E_BADTAG : i32 = -2144862178;
pub const TPM_E_IOERROR : i32 = -2144862177;
pub const TPM_E_ENCRYPT_ERROR : i32 = -2144862176;
pub const TPM_E_DECRYPT_ERROR : i32 = -2144862175;
pub const TPM_E_INVALID_AUTHHANDLE : i32 = -2144862174;
pub const TPM_E_NO_ENDORSEMENT : i32 = -2144862173;
pub const TPM_E_INVALID_KEYUSAGE : i32 = -2144862172;
pub const TPM_E_WRONG_ENTITYTYPE : i32 = -2144862171;
pub const TPM_E_INVALID_POSTINIT : i32 = -2144862170;
pub const TPM_E_INAPPROPRIATE_SIG : i32 = -2144862169;
pub const TPM_E_BAD_KEY_PROPERTY : i32 = -2144862168;
pub const TPM_E_BAD_MIGRATION : i32 = -2144862167;
pub const TPM_E_BAD_SCHEME : i32 = -2144862166;
pub const TPM_E_BAD_DATASIZE : i32 = -2144862165;
pub const TPM_E_BAD_MODE : i32 = -2144862164;
pub const TPM_E_BAD_PRESENCE : i32 = -2144862163;
pub const TPM_E_BAD_VERSION : i32 = -2144862162;
pub const TPM_E_NO_WRAP_TRANSPORT : i32 = -2144862161;
pub const TPM_E_AUDITFAIL_UNSUCCESSFUL : i32 = -2144862160;
pub const TPM_E_AUDITFAIL_SUCCESSFUL : i32 = -2144862159;
pub const TPM_E_NOTRESETABLE : i32 = -2144862158;
pub const TPM_E_NOTLOCAL : i32 = -2144862157;
pub const TPM_E_BAD_TYPE : i32 = -2144862156;
pub const TPM_E_INVALID_RESOURCE : i32 = -2144862155;
pub const TPM_E_NOTFIPS : i32 = -2144862154;
pub const TPM_E_INVALID_FAMILY : i32 = -2144862153;
pub const TPM_E_NO_NV_PERMISSION : i32 = -2144862152;
pub const TPM_E_REQUIRES_SIGN : i32 = -2144862151;
pub const TPM_E_KEY_NOTSUPPORTED : i32 = -2144862150;
pub const TPM_E_AUTH_CONFLICT : i32 = -2144862149;
pub const TPM_E_AREA_LOCKED : i32 = -2144862148;
pub const TPM_E_BAD_LOCALITY : i32 = -2144862147;
pub const TPM_E_READ_ONLY : i32 = -2144862146;
pub const TPM_E_PER_NOWRITE : i32 = -2144862145;
pub const TPM_E_FAMILYCOUNT : i32 = -2144862144;
pub const TPM_E_WRITE_LOCKED : i32 = -2144862143;
pub const TPM_E_BAD_ATTRIBUTES : i32 = -2144862142;
pub const TPM_E_INVALID_STRUCTURE : i32 = -2144862141;
pub const TPM_E_KEY_OWNER_CONTROL : i32 = -2144862140;
pub const TPM_E_BAD_COUNTER : i32 = -2144862139;
pub const TPM_E_NOT_FULLWRITE : i32 = -2144862138;
pub const TPM_E_CONTEXT_GAP : i32 = -2144862137;
pub const TPM_E_MAXNVWRITES : i32 = -2144862136;
pub const TPM_E_NOOPERATOR : i32 = -2144862135;
pub const TPM_E_RESOURCEMISSING : i32 = -2144862134;
pub const TPM_E_DELEGATE_LOCK : i32 = -2144862133;
pub const TPM_E_DELEGATE_FAMILY : i32 = -2144862132;
pub const TPM_E_DELEGATE_ADMIN : i32 = -2144862131;
pub const TPM_E_TRANSPORT_NOTEXCLUSIVE : i32 = -2144862130;
pub const TPM_E_OWNER_CONTROL : i32 = -2144862129;
pub const TPM_E_DAA_RESOURCES : i32 = -2144862128;
pub const TPM_E_DAA_INPUT_DATA0 : i32 = -2144862127;
pub const TPM_E_DAA_INPUT_DATA1 : i32 = -2144862126;
pub const TPM_E_DAA_ISSUER_SETTINGS : i32 = -2144862125;
pub const TPM_E_DAA_TPM_SETTINGS : i32 = -2144862124;
pub const TPM_E_DAA_STAGE : i32 = -2144862123;
pub const TPM_E_DAA_ISSUER_VALIDITY : i32 = -2144862122;
pub const TPM_E_DAA_WRONG_W : i32 = -2144862121;
pub const TPM_E_BAD_HANDLE : i32 = -2144862120;
pub const TPM_E_BAD_DELEGATE : i32 = -2144862119;
pub const TPM_E_BADCONTEXT : i32 = -2144862118;
pub const TPM_E_TOOMANYCONTEXTS : i32 = -2144862117;
pub const TPM_E_MA_TICKET_SIGNATURE : i32 = -2144862116;
pub const TPM_E_MA_DESTINATION : i32 = -2144862115;
pub const TPM_E_MA_SOURCE : i32 = -2144862114;
pub const TPM_E_MA_AUTHORITY : i32 = -2144862113;
pub const TPM_E_PERMANENTEK : i32 = -2144862111;
pub const TPM_E_BAD_SIGNATURE : i32 = -2144862110;
pub const TPM_E_NOCONTEXTSPACE : i32 = -2144862109;
pub const TPM_20_E_ASYMMETRIC : i32 = -2144862079;
pub const TPM_20_E_ATTRIBUTES : i32 = -2144862078;
pub const TPM_20_E_HASH : i32 = -2144862077;
pub const TPM_20_E_VALUE : i32 = -2144862076;
pub const TPM_20_E_HIERARCHY : i32 = -2144862075;
pub const TPM_20_E_KEY_SIZE : i32 = -2144862073;
pub const TPM_20_E_MGF : i32 = -2144862072;
pub const TPM_20_E_MODE : i32 = -2144862071;
pub const TPM_20_E_TYPE : i32 = -2144862070;
pub const TPM_20_E_HANDLE : i32 = -2144862069;
pub const TPM_20_E_KDF : i32 = -2144862068;
pub const TPM_20_E_RANGE : i32 = -2144862067;
pub const TPM_20_E_AUTH_FAIL : i32 = -2144862066;
pub const TPM_20_E_NONCE : i32 = -2144862065;
pub const TPM_20_E_PP : i32 = -2144862064;
pub const TPM_20_E_SCHEME : i32 = -2144862062;
pub const TPM_20_E_SIZE : i32 = -2144862059;
pub const TPM_20_E_SYMMETRIC : i32 = -2144862058;
pub const TPM_20_E_TAG : i32 = -2144862057;
pub const TPM_20_E_SELECTOR : i32 = -2144862056;
pub const TPM_20_E_INSUFFICIENT : i32 = -2144862054;
pub const TPM_20_E_SIGNATURE : i32 = -2144862053;
pub const TPM_20_E_KEY : i32 = -2144862052;
pub const TPM_20_E_POLICY_FAIL : i32 = -2144862051;
pub const TPM_20_E_INTEGRITY : i32 = -2144862049;
pub const TPM_20_E_TICKET : i32 = -2144862048;
pub const TPM_20_E_RESERVED_BITS : i32 = -2144862047;
pub const TPM_20_E_BAD_AUTH : i32 = -2144862046;
pub const TPM_20_E_EXPIRED : i32 = -2144862045;
pub const TPM_20_E_POLICY_CC : i32 = -2144862044;
pub const TPM_20_E_BINDING : i32 = -2144862043;
pub const TPM_20_E_CURVE : i32 = -2144862042;
pub const TPM_20_E_ECC_POINT : i32 = -2144862041;
pub const TPM_20_E_INITIALIZE : i32 = -2144861952;
pub const TPM_20_E_FAILURE : i32 = -2144861951;
pub const TPM_20_E_SEQUENCE : i32 = -2144861949;
pub const TPM_20_E_PRIVATE : i32 = -2144861941;
pub const TPM_20_E_HMAC : i32 = -2144861927;
pub const TPM_20_E_DISABLED : i32 = -2144861920;
pub const TPM_20_E_EXCLUSIVE : i32 = -2144861919;
pub const TPM_20_E_ECC_CURVE : i32 = -2144861917;
pub const TPM_20_E_AUTH_TYPE : i32 = -2144861916;
pub const TPM_20_E_AUTH_MISSING : i32 = -2144861915;
pub const TPM_20_E_POLICY : i32 = -2144861914;
pub const TPM_20_E_PCR : i32 = -2144861913;
pub const TPM_20_E_PCR_CHANGED : i32 = -2144861912;
pub const TPM_20_E_UPGRADE : i32 = -2144861907;
pub const TPM_20_E_TOO_MANY_CONTEXTS : i32 = -2144861906;
pub const TPM_20_E_AUTH_UNAVAILABLE : i32 = -2144861905;
pub const TPM_20_E_REBOOT : i32 = -2144861904;
pub const TPM_20_E_UNBALANCED : i32 = -2144861903;
pub const TPM_20_E_COMMAND_SIZE : i32 = -2144861886;
pub const TPM_20_E_COMMAND_CODE : i32 = -2144861885;
pub const TPM_20_E_AUTHSIZE : i32 = -2144861884;
pub const TPM_20_E_AUTH_CONTEXT : i32 = -2144861883;
pub const TPM_20_E_NV_RANGE : i32 = -2144861882;
pub const TPM_20_E_NV_SIZE : i32 = -2144861881;
pub const TPM_20_E_NV_LOCKED : i32 = -2144861880;
pub const TPM_20_E_NV_AUTHORIZATION : i32 = -2144861879;
pub const TPM_20_E_NV_UNINITIALIZED : i32 = -2144861878;
pub const TPM_20_E_NV_SPACE : i32 = -2144861877;
pub const TPM_20_E_NV_DEFINED : i32 = -2144861876;
pub const TPM_20_E_BAD_CONTEXT : i32 = -2144861872;
pub const TPM_20_E_CPHASH : i32 = -2144861871;
pub const TPM_20_E_PARENT : i32 = -2144861870;
pub const TPM_20_E_NEEDS_TEST : i32 = -2144861869;
pub const TPM_20_E_NO_RESULT : i32 = -2144861868;
pub const TPM_20_E_SENSITIVE : i32 = -2144861867;
pub const TPM_E_COMMAND_BLOCKED : i32 = -2144861184;
pub const TPM_E_INVALID_HANDLE : i32 = -2144861183;
pub const TPM_E_DUPLICATE_VHANDLE : i32 = -2144861182;
pub const TPM_E_EMBEDDED_COMMAND_BLOCKED : i32 = -2144861181;
pub const TPM_E_EMBEDDED_COMMAND_UNSUPPORTED : i32 = -2144861180;
pub const TPM_E_RETRY : i32 = -2144860160;
pub const TPM_E_NEEDS_SELFTEST : i32 = -2144860159;
pub const TPM_E_DOING_SELFTEST : i32 = -2144860158;
pub const TPM_E_DEFEND_LOCK_RUNNING : i32 = -2144860157;
pub const TPM_20_E_CONTEXT_GAP : i32 = -2144859903;
pub const TPM_20_E_OBJECT_MEMORY : i32 = -2144859902;
pub const TPM_20_E_SESSION_MEMORY : i32 = -2144859901;
pub const TPM_20_E_MEMORY : i32 = -2144859900;
pub const TPM_20_E_SESSION_HANDLES : i32 = -2144859899;
pub const TPM_20_E_OBJECT_HANDLES : i32 = -2144859898;
pub const TPM_20_E_LOCALITY : i32 = -2144859897;
pub const TPM_20_E_YIELDED : i32 = -2144859896;
pub const TPM_20_E_CANCELED : i32 = -2144859895;
pub const TPM_20_E_TESTING : i32 = -2144859894;
pub const TPM_20_E_NV_RATE : i32 = -2144859872;
pub const TPM_20_E_LOCKOUT : i32 = -2144859871;
pub const TPM_20_E_RETRY : i32 = -2144859870;
pub const TPM_20_E_NV_UNAVAILABLE : i32 = -2144859869;
pub const TBS_E_INTERNAL_ERROR : i32 = -2144845823;
pub const TBS_E_BAD_PARAMETER : i32 = -2144845822;
pub const TBS_E_INVALID_OUTPUT_POINTER : i32 = -2144845821;
pub const TBS_E_INVALID_CONTEXT : i32 = -2144845820;
pub const TBS_E_INSUFFICIENT_BUFFER : i32 = -2144845819;
pub const TBS_E_IOERROR : i32 = -2144845818;
pub const TBS_E_INVALID_CONTEXT_PARAM : i32 = -2144845817;
pub const TBS_E_SERVICE_NOT_RUNNING : i32 = -2144845816;
pub const TBS_E_TOO_MANY_TBS_CONTEXTS : i32 = -2144845815;
pub const TBS_E_TOO_MANY_RESOURCES : i32 = -2144845814;
pub const TBS_E_SERVICE_START_PENDING : i32 = -2144845813;
pub const TBS_E_PPI_NOT_SUPPORTED : i32 = -2144845812;
pub const TBS_E_COMMAND_CANCELED : i32 = -2144845811;
pub const TBS_E_BUFFER_TOO_LARGE : i32 = -2144845810;
pub const TBS_E_TPM_NOT_FOUND : i32 = -2144845809;
pub const TBS_E_SERVICE_DISABLED : i32 = -2144845808;
pub const TBS_E_NO_EVENT_LOG : i32 = -2144845807;
pub const TBS_E_ACCESS_DENIED : i32 = -2144845806;
pub const TBS_E_PROVISIONING_NOT_ALLOWED : i32 = -2144845805;
pub const TBS_E_PPI_FUNCTION_UNSUPPORTED : i32 = -2144845804;
pub const TBS_E_OWNERAUTH_NOT_FOUND : i32 = -2144845803;
pub const TBS_E_PROVISIONING_INCOMPLETE : i32 = -2144845802;
pub const TPMAPI_E_INVALID_STATE : i32 = -2144796416;
pub const TPMAPI_E_NOT_ENOUGH_DATA : i32 = -2144796415;
pub const TPMAPI_E_TOO_MUCH_DATA : i32 = -2144796414;
pub const TPMAPI_E_INVALID_OUTPUT_POINTER : i32 = -2144796413;
pub const TPMAPI_E_INVALID_PARAMETER : i32 = -2144796412;
pub const TPMAPI_E_OUT_OF_MEMORY : i32 = -2144796411;
pub const TPMAPI_E_BUFFER_TOO_SMALL : i32 = -2144796410;
pub const TPMAPI_E_INTERNAL_ERROR : i32 = -2144796409;
pub const TPMAPI_E_ACCESS_DENIED : i32 = -2144796408;
pub const TPMAPI_E_AUTHORIZATION_FAILED : i32 = -2144796407;
pub const TPMAPI_E_INVALID_CONTEXT_HANDLE : i32 = -2144796406;
pub const TPMAPI_E_TBS_COMMUNICATION_ERROR : i32 = -2144796405;
pub const TPMAPI_E_TPM_COMMAND_ERROR : i32 = -2144796404;
pub const TPMAPI_E_MESSAGE_TOO_LARGE : i32 = -2144796403;
pub const TPMAPI_E_INVALID_ENCODING : i32 = -2144796402;
pub const TPMAPI_E_INVALID_KEY_SIZE : i32 = -2144796401;
pub const TPMAPI_E_ENCRYPTION_FAILED : i32 = -2144796400;
pub const TPMAPI_E_INVALID_KEY_PARAMS : i32 = -2144796399;
pub const TPMAPI_E_INVALID_MIGRATION_AUTHORIZATION_BLOB : i32 = -2144796398;
pub const TPMAPI_E_INVALID_PCR_INDEX : i32 = -2144796397;
pub const TPMAPI_E_INVALID_DELEGATE_BLOB : i32 = -2144796396;
pub const TPMAPI_E_INVALID_CONTEXT_PARAMS : i32 = -2144796395;
pub const TPMAPI_E_INVALID_KEY_BLOB : i32 = -2144796394;
pub const TPMAPI_E_INVALID_PCR_DATA : i32 = -2144796393;
pub const TPMAPI_E_INVALID_OWNER_AUTH : i32 = -2144796392;
pub const TPMAPI_E_FIPS_RNG_CHECK_FAILED : i32 = -2144796391;
pub const TPMAPI_E_EMPTY_TCG_LOG : i32 = -2144796390;
pub const TPMAPI_E_INVALID_TCG_LOG_ENTRY : i32 = -2144796389;
pub const TPMAPI_E_TCG_SEPARATOR_ABSENT : i32 = -2144796388;
pub const TPMAPI_E_TCG_INVALID_DIGEST_ENTRY : i32 = -2144796387;
pub const TPMAPI_E_POLICY_DENIES_OPERATION : i32 = -2144796386;
pub const TPMAPI_E_NV_BITS_NOT_DEFINED : i32 = -2144796385;
pub const TPMAPI_E_NV_BITS_NOT_READY : i32 = -2144796384;
pub const TPMAPI_E_SEALING_KEY_NOT_AVAILABLE : i32 = -2144796383;
pub const TPMAPI_E_NO_AUTHORIZATION_CHAIN_FOUND : i32 = -2144796382;
pub const TPMAPI_E_SVN_COUNTER_NOT_AVAILABLE : i32 = -2144796381;
pub const TPMAPI_E_OWNER_AUTH_NOT_NULL : i32 = -2144796380;
pub const TPMAPI_E_ENDORSEMENT_AUTH_NOT_NULL : i32 = -2144796379;
pub const TPMAPI_E_AUTHORIZATION_REVOKED : i32 = -2144796378;
pub const TPMAPI_E_MALFORMED_AUTHORIZATION_KEY : i32 = -2144796377;
pub const TPMAPI_E_AUTHORIZING_KEY_NOT_SUPPORTED : i32 = -2144796376;
pub const TPMAPI_E_INVALID_AUTHORIZATION_SIGNATURE : i32 = -2144796375;
pub const TPMAPI_E_MALFORMED_AUTHORIZATION_POLICY : i32 = -2144796374;
pub const TPMAPI_E_MALFORMED_AUTHORIZATION_OTHER : i32 = -2144796373;
pub const TPMAPI_E_SEALING_KEY_CHANGED : i32 = -2144796372;
pub const TPMAPI_E_INVALID_TPM_VERSION : i32 = -2144796371;
pub const TPMAPI_E_INVALID_POLICYAUTH_BLOB_TYPE : i32 = -2144796370;
pub const TBSIMP_E_BUFFER_TOO_SMALL : i32 = -2144796160;
pub const TBSIMP_E_CLEANUP_FAILED : i32 = -2144796159;
pub const TBSIMP_E_INVALID_CONTEXT_HANDLE : i32 = -2144796158;
pub const TBSIMP_E_INVALID_CONTEXT_PARAM : i32 = -2144796157;
pub const TBSIMP_E_TPM_ERROR : i32 = -2144796156;
pub const TBSIMP_E_HASH_BAD_KEY : i32 = -2144796155;
pub const TBSIMP_E_DUPLICATE_VHANDLE : i32 = -2144796154;
pub const TBSIMP_E_INVALID_OUTPUT_POINTER : i32 = -2144796153;
pub const TBSIMP_E_INVALID_PARAMETER : i32 = -2144796152;
pub const TBSIMP_E_RPC_INIT_FAILED : i32 = -2144796151;
pub const TBSIMP_E_SCHEDULER_NOT_RUNNING : i32 = -2144796150;
pub const TBSIMP_E_COMMAND_CANCELED : i32 = -2144796149;
pub const TBSIMP_E_OUT_OF_MEMORY : i32 = -2144796148;
pub const TBSIMP_E_LIST_NO_MORE_ITEMS : i32 = -2144796147;
pub const TBSIMP_E_LIST_NOT_FOUND : i32 = -2144796146;
pub const TBSIMP_E_NOT_ENOUGH_SPACE : i32 = -2144796145;
pub const TBSIMP_E_NOT_ENOUGH_TPM_CONTEXTS : i32 = -2144796144;
pub const TBSIMP_E_COMMAND_FAILED : i32 = -2144796143;
pub const TBSIMP_E_UNKNOWN_ORDINAL : i32 = -2144796142;
pub const TBSIMP_E_RESOURCE_EXPIRED : i32 = -2144796141;
pub const TBSIMP_E_INVALID_RESOURCE : i32 = -2144796140;
pub const TBSIMP_E_NOTHING_TO_UNLOAD : i32 = -2144796139;
pub const TBSIMP_E_HASH_TABLE_FULL : i32 = -2144796138;
pub const TBSIMP_E_TOO_MANY_TBS_CONTEXTS : i32 = -2144796137;
pub const TBSIMP_E_TOO_MANY_RESOURCES : i32 = -2144796136;
pub const TBSIMP_E_PPI_NOT_SUPPORTED : i32 = -2144796135;
pub const TBSIMP_E_TPM_INCOMPATIBLE : i32 = -2144796134;
pub const TBSIMP_E_NO_EVENT_LOG : i32 = -2144796133;
pub const TPM_E_PPI_ACPI_FAILURE : i32 = -2144795904;
pub const TPM_E_PPI_USER_ABORT : i32 = -2144795903;
pub const TPM_E_PPI_BIOS_FAILURE : i32 = -2144795902;
pub const TPM_E_PPI_NOT_SUPPORTED : i32 = -2144795901;
pub const TPM_E_PPI_BLOCKED_IN_BIOS : i32 = -2144795900;
pub const TPM_E_PCP_ERROR_MASK : i32 = -2144795648;
pub const TPM_E_PCP_DEVICE_NOT_READY : i32 = -2144795647;
pub const TPM_E_PCP_INVALID_HANDLE : i32 = -2144795646;
pub const TPM_E_PCP_INVALID_PARAMETER : i32 = -2144795645;
pub const TPM_E_PCP_FLAG_NOT_SUPPORTED : i32 = -2144795644;
pub const TPM_E_PCP_NOT_SUPPORTED : i32 = -2144795643;
pub const TPM_E_PCP_BUFFER_TOO_SMALL : i32 = -2144795642;
pub const TPM_E_PCP_INTERNAL_ERROR : i32 = -2144795641;
pub const TPM_E_PCP_AUTHENTICATION_FAILED : i32 = -2144795640;
pub const TPM_E_PCP_AUTHENTICATION_IGNORED : i32 = -2144795639;
pub const TPM_E_PCP_POLICY_NOT_FOUND : i32 = -2144795638;
pub const TPM_E_PCP_PROFILE_NOT_FOUND : i32 = -2144795637;
pub const TPM_E_PCP_VALIDATION_FAILED : i32 = -2144795636;
pub const TPM_E_PCP_WRONG_PARENT : i32 = -2144795634;
pub const TPM_E_KEY_NOT_LOADED : i32 = -2144795633;
pub const TPM_E_NO_KEY_CERTIFICATION : i32 = -2144795632;
pub const TPM_E_KEY_NOT_FINALIZED : i32 = -2144795631;
pub const TPM_E_ATTESTATION_CHALLENGE_NOT_SET : i32 = -2144795630;
pub const TPM_E_NOT_PCR_BOUND : i32 = -2144795629;
pub const TPM_E_KEY_ALREADY_FINALIZED : i32 = -2144795628;
pub const TPM_E_KEY_USAGE_POLICY_NOT_SUPPORTED : i32 = -2144795627;
pub const TPM_E_KEY_USAGE_POLICY_INVALID : i32 = -2144795626;
pub const TPM_E_SOFT_KEY_ERROR : i32 = -2144795625;
pub const TPM_E_KEY_NOT_AUTHENTICATED : i32 = -2144795624;
pub const TPM_E_PCP_KEY_NOT_AIK : i32 = -2144795623;
pub const TPM_E_KEY_NOT_SIGNING_KEY : i32 = -2144795622;
pub const TPM_E_LOCKED_OUT : i32 = -2144795621;
pub const TPM_E_CLAIM_TYPE_NOT_SUPPORTED : i32 = -2144795620;
pub const TPM_E_VERSION_NOT_SUPPORTED : i32 = -2144795619;
pub const TPM_E_BUFFER_LENGTH_MISMATCH : i32 = -2144795618;
pub const TPM_E_PCP_IFX_RSA_KEY_CREATION_BLOCKED : i32 = -2144795617;
pub const TPM_E_PCP_TICKET_MISSING : i32 = -2144795616;
pub const TPM_E_PCP_RAW_POLICY_NOT_SUPPORTED : i32 = -2144795615;
pub const TPM_E_PCP_KEY_HANDLE_INVALIDATED : i32 = -2144795614;
pub const TPM_E_PCP_UNSUPPORTED_PSS_SALT : i32 = 1076429859;
pub const TPM_E_PCP_PLATFORM_CLAIM_MAY_BE_OUTDATED : i32 = 1076429860;
pub const TPM_E_PCP_PLATFORM_CLAIM_OUTDATED : i32 = 1076429861;
pub const TPM_E_PCP_PLATFORM_CLAIM_REBOOT : i32 = 1076429862;
pub const TPM_E_ZERO_EXHAUST_ENABLED : i32 = -2144795392;
pub const TPM_E_PROVISIONING_INCOMPLETE : i32 = -2144795136;
pub const TPM_E_INVALID_OWNER_AUTH : i32 = -2144795135;
pub const TPM_E_TOO_MUCH_DATA : i32 = -2144795134;
pub const PLA_E_DCS_NOT_FOUND : i32 = -2144337918;
pub const PLA_E_DCS_IN_USE : i32 = -2144337750;
pub const PLA_E_TOO_MANY_FOLDERS : i32 = -2144337851;
pub const PLA_E_NO_MIN_DISK : i32 = -2144337808;
pub const PLA_E_DCS_ALREADY_EXISTS : i32 = -2144337737;
pub const PLA_S_PROPERTY_IGNORED : i32 = 3145984;
pub const PLA_E_PROPERTY_CONFLICT : i32 = -2144337663;
pub const PLA_E_DCS_SINGLETON_REQUIRED : i32 = -2144337662;
pub const PLA_E_CREDENTIALS_REQUIRED : i32 = -2144337661;
pub const PLA_E_DCS_NOT_RUNNING : i32 = -2144337660;
pub const PLA_E_CONFLICT_INCL_EXCL_API : i32 = -2144337659;
pub const PLA_E_NETWORK_EXE_NOT_VALID : i32 = -2144337658;
pub const PLA_E_EXE_ALREADY_CONFIGURED : i32 = -2144337657;
pub const PLA_E_EXE_PATH_NOT_VALID : i32 = -2144337656;
pub const PLA_E_DC_ALREADY_EXISTS : i32 = -2144337655;
pub const PLA_E_DCS_START_WAIT_TIMEOUT : i32 = -2144337654;
pub const PLA_E_DC_START_WAIT_TIMEOUT : i32 = -2144337653;
pub const PLA_E_REPORT_WAIT_TIMEOUT : i32 = -2144337652;
pub const PLA_E_NO_DUPLICATES : i32 = -2144337651;
pub const PLA_E_EXE_FULL_PATH_REQUIRED : i32 = -2144337650;
pub const PLA_E_INVALID_SESSION_NAME : i32 = -2144337649;
pub const PLA_E_PLA_CHANNEL_NOT_ENABLED : i32 = -2144337648;
pub const PLA_E_TASKSCHED_CHANNEL_NOT_ENABLED : i32 = -2144337647;
pub const PLA_E_RULES_MANAGER_FAILED : i32 = -2144337646;
pub const PLA_E_CABAPI_FAILURE : i32 = -2144337645;
pub const FVE_E_LOCKED_VOLUME : i32 = -2144272384;
pub const FVE_E_NOT_ENCRYPTED : i32 = -2144272383;
pub const FVE_E_NO_TPM_BIOS : i32 = -2144272382;
pub const FVE_E_NO_MBR_METRIC : i32 = -2144272381;
pub const FVE_E_NO_BOOTSECTOR_METRIC : i32 = -2144272380;
pub const FVE_E_NO_BOOTMGR_METRIC : i32 = -2144272379;
pub const FVE_E_WRONG_BOOTMGR : i32 = -2144272378;
pub const FVE_E_SECURE_KEY_REQUIRED : i32 = -2144272377;
pub const FVE_E_NOT_ACTIVATED : i32 = -2144272376;
pub const FVE_E_ACTION_NOT_ALLOWED : i32 = -2144272375;
pub const FVE_E_AD_SCHEMA_NOT_INSTALLED : i32 = -2144272374;
pub const FVE_E_AD_INVALID_DATATYPE : i32 = -2144272373;
pub const FVE_E_AD_INVALID_DATASIZE : i32 = -2144272372;
pub const FVE_E_AD_NO_VALUES : i32 = -2144272371;
pub const FVE_E_AD_ATTR_NOT_SET : i32 = -2144272370;
pub const FVE_E_AD_GUID_NOT_FOUND : i32 = -2144272369;
pub const FVE_E_BAD_INFORMATION : i32 = -2144272368;
pub const FVE_E_TOO_SMALL : i32 = -2144272367;
pub const FVE_E_SYSTEM_VOLUME : i32 = -2144272366;
pub const FVE_E_FAILED_WRONG_FS : i32 = -2144272365;
pub const FVE_E_BAD_PARTITION_SIZE : i32 = -2144272364;
pub const FVE_E_NOT_SUPPORTED : i32 = -2144272363;
pub const FVE_E_BAD_DATA : i32 = -2144272362;
pub const FVE_E_VOLUME_NOT_BOUND : i32 = -2144272361;
pub const FVE_E_TPM_NOT_OWNED : i32 = -2144272360;
pub const FVE_E_NOT_DATA_VOLUME : i32 = -2144272359;
pub const FVE_E_AD_INSUFFICIENT_BUFFER : i32 = -2144272358;
pub const FVE_E_CONV_READ : i32 = -2144272357;
pub const FVE_E_CONV_WRITE : i32 = -2144272356;
pub const FVE_E_KEY_REQUIRED : i32 = -2144272355;
pub const FVE_E_CLUSTERING_NOT_SUPPORTED : i32 = -2144272354;
pub const FVE_E_VOLUME_BOUND_ALREADY : i32 = -2144272353;
pub const FVE_E_OS_NOT_PROTECTED : i32 = -2144272352;
pub const FVE_E_PROTECTION_DISABLED : i32 = -2144272351;
pub const FVE_E_RECOVERY_KEY_REQUIRED : i32 = -2144272350;
pub const FVE_E_FOREIGN_VOLUME : i32 = -2144272349;
pub const FVE_E_OVERLAPPED_UPDATE : i32 = -2144272348;
pub const FVE_E_TPM_SRK_AUTH_NOT_ZERO : i32 = -2144272347;
pub const FVE_E_FAILED_SECTOR_SIZE : i32 = -2144272346;
pub const FVE_E_FAILED_AUTHENTICATION : i32 = -2144272345;
pub const FVE_E_NOT_OS_VOLUME : i32 = -2144272344;
pub const FVE_E_AUTOUNLOCK_ENABLED : i32 = -2144272343;
pub const FVE_E_WRONG_BOOTSECTOR : i32 = -2144272342;
pub const FVE_E_WRONG_SYSTEM_FS : i32 = -2144272341;
pub const FVE_E_POLICY_PASSWORD_REQUIRED : i32 = -2144272340;
pub const FVE_E_CANNOT_SET_FVEK_ENCRYPTED : i32 = -2144272339;
pub const FVE_E_CANNOT_ENCRYPT_NO_KEY : i32 = -2144272338;
pub const FVE_E_BOOTABLE_CDDVD : i32 = -2144272336;
pub const FVE_E_PROTECTOR_EXISTS : i32 = -2144272335;
pub const FVE_E_RELATIVE_PATH : i32 = -2144272334;
pub const FVE_E_PROTECTOR_NOT_FOUND : i32 = -2144272333;
pub const FVE_E_INVALID_KEY_FORMAT : i32 = -2144272332;
pub const FVE_E_INVALID_PASSWORD_FORMAT : i32 = -2144272331;
pub const FVE_E_FIPS_RNG_CHECK_FAILED : i32 = -2144272330;
pub const FVE_E_FIPS_PREVENTS_RECOVERY_PASSWORD : i32 = -2144272329;
pub const FVE_E_FIPS_PREVENTS_EXTERNAL_KEY_EXPORT : i32 = -2144272328;
pub const FVE_E_NOT_DECRYPTED : i32 = -2144272327;
pub const FVE_E_INVALID_PROTECTOR_TYPE : i32 = -2144272326;
pub const FVE_E_NO_PROTECTORS_TO_TEST : i32 = -2144272325;
pub const FVE_E_KEYFILE_NOT_FOUND : i32 = -2144272324;
pub const FVE_E_KEYFILE_INVALID : i32 = -2144272323;
pub const FVE_E_KEYFILE_NO_VMK : i32 = -2144272322;
pub const FVE_E_TPM_DISABLED : i32 = -2144272321;
pub const FVE_E_NOT_ALLOWED_IN_SAFE_MODE : i32 = -2144272320;
pub const FVE_E_TPM_INVALID_PCR : i32 = -2144272319;
pub const FVE_E_TPM_NO_VMK : i32 = -2144272318;
pub const FVE_E_PIN_INVALID : i32 = -2144272317;
pub const FVE_E_AUTH_INVALID_APPLICATION : i32 = -2144272316;
pub const FVE_E_AUTH_INVALID_CONFIG : i32 = -2144272315;
pub const FVE_E_FIPS_DISABLE_PROTECTION_NOT_ALLOWED : i32 = -2144272314;
pub const FVE_E_FS_NOT_EXTENDED : i32 = -2144272313;
pub const FVE_E_FIRMWARE_TYPE_NOT_SUPPORTED : i32 = -2144272312;
pub const FVE_E_NO_LICENSE : i32 = -2144272311;
pub const FVE_E_NOT_ON_STACK : i32 = -2144272310;
pub const FVE_E_FS_MOUNTED : i32 = -2144272309;
pub const FVE_E_TOKEN_NOT_IMPERSONATED : i32 = -2144272308;
pub const FVE_E_DRY_RUN_FAILED : i32 = -2144272307;
pub const FVE_E_REBOOT_REQUIRED : i32 = -2144272306;
pub const FVE_E_DEBUGGER_ENABLED : i32 = -2144272305;
pub const FVE_E_RAW_ACCESS : i32 = -2144272304;
pub const FVE_E_RAW_BLOCKED : i32 = -2144272303;
pub const FVE_E_BCD_APPLICATIONS_PATH_INCORRECT : i32 = -2144272302;
pub const FVE_E_NOT_ALLOWED_IN_VERSION : i32 = -2144272301;
pub const FVE_E_NO_AUTOUNLOCK_MASTER_KEY : i32 = -2144272300;
pub const FVE_E_MOR_FAILED : i32 = -2144272299;
pub const FVE_E_HIDDEN_VOLUME : i32 = -2144272298;
pub const FVE_E_TRANSIENT_STATE : i32 = -2144272297;
pub const FVE_E_PUBKEY_NOT_ALLOWED : i32 = -2144272296;
pub const FVE_E_VOLUME_HANDLE_OPEN : i32 = -2144272295;
pub const FVE_E_NO_FEATURE_LICENSE : i32 = -2144272294;
pub const FVE_E_INVALID_STARTUP_OPTIONS : i32 = -2144272293;
pub const FVE_E_POLICY_RECOVERY_PASSWORD_NOT_ALLOWED : i32 = -2144272292;
pub const FVE_E_POLICY_RECOVERY_PASSWORD_REQUIRED : i32 = -2144272291;
pub const FVE_E_POLICY_RECOVERY_KEY_NOT_ALLOWED : i32 = -2144272290;
pub const FVE_E_POLICY_RECOVERY_KEY_REQUIRED : i32 = -2144272289;
pub const FVE_E_POLICY_STARTUP_PIN_NOT_ALLOWED : i32 = -2144272288;
pub const FVE_E_POLICY_STARTUP_PIN_REQUIRED : i32 = -2144272287;
pub const FVE_E_POLICY_STARTUP_KEY_NOT_ALLOWED : i32 = -2144272286;
pub const FVE_E_POLICY_STARTUP_KEY_REQUIRED : i32 = -2144272285;
pub const FVE_E_POLICY_STARTUP_PIN_KEY_NOT_ALLOWED : i32 = -2144272284;
pub const FVE_E_POLICY_STARTUP_PIN_KEY_REQUIRED : i32 = -2144272283;
pub const FVE_E_POLICY_STARTUP_TPM_NOT_ALLOWED : i32 = -2144272282;
pub const FVE_E_POLICY_STARTUP_TPM_REQUIRED : i32 = -2144272281;
pub const FVE_E_POLICY_INVALID_PIN_LENGTH : i32 = -2144272280;
pub const FVE_E_KEY_PROTECTOR_NOT_SUPPORTED : i32 = -2144272279;
pub const FVE_E_POLICY_PASSPHRASE_NOT_ALLOWED : i32 = -2144272278;
pub const FVE_E_POLICY_PASSPHRASE_REQUIRED : i32 = -2144272277;
pub const FVE_E_FIPS_PREVENTS_PASSPHRASE : i32 = -2144272276;
pub const FVE_E_OS_VOLUME_PASSPHRASE_NOT_ALLOWED : i32 = -2144272275;
pub const FVE_E_INVALID_BITLOCKER_OID : i32 = -2144272274;
pub const FVE_E_VOLUME_TOO_SMALL : i32 = -2144272273;
pub const FVE_E_DV_NOT_SUPPORTED_ON_FS : i32 = -2144272272;
pub const FVE_E_DV_NOT_ALLOWED_BY_GP : i32 = -2144272271;
pub const FVE_E_POLICY_USER_CERTIFICATE_NOT_ALLOWED : i32 = -2144272270;
pub const FVE_E_POLICY_USER_CERTIFICATE_REQUIRED : i32 = -2144272269;
pub const FVE_E_POLICY_USER_CERT_MUST_BE_HW : i32 = -2144272268;
pub const FVE_E_POLICY_USER_CONFIGURE_FDV_AUTOUNLOCK_NOT_ALLOWED : i32 = -2144272267;
pub const FVE_E_POLICY_USER_CONFIGURE_RDV_AUTOUNLOCK_NOT_ALLOWED : i32 = -2144272266;
pub const FVE_E_POLICY_USER_CONFIGURE_RDV_NOT_ALLOWED : i32 = -2144272265;
pub const FVE_E_POLICY_USER_ENABLE_RDV_NOT_ALLOWED : i32 = -2144272264;
pub const FVE_E_POLICY_USER_DISABLE_RDV_NOT_ALLOWED : i32 = -2144272263;
pub const FVE_E_POLICY_INVALID_PASSPHRASE_LENGTH : i32 = -2144272256;
pub const FVE_E_POLICY_PASSPHRASE_TOO_SIMPLE : i32 = -2144272255;
pub const FVE_E_RECOVERY_PARTITION : i32 = -2144272254;
pub const FVE_E_POLICY_CONFLICT_FDV_RK_OFF_AUK_ON : i32 = -2144272253;
pub const FVE_E_POLICY_CONFLICT_RDV_RK_OFF_AUK_ON : i32 = -2144272252;
pub const FVE_E_NON_BITLOCKER_OID : i32 = -2144272251;
pub const FVE_E_POLICY_PROHIBITS_SELFSIGNED : i32 = -2144272250;
pub const FVE_E_POLICY_CONFLICT_RO_AND_STARTUP_KEY_REQUIRED : i32 = -2144272249;
pub const FVE_E_CONV_RECOVERY_FAILED : i32 = -2144272248;
pub const FVE_E_VIRTUALIZED_SPACE_TOO_BIG : i32 = -2144272247;
pub const FVE_E_POLICY_CONFLICT_OSV_RP_OFF_ADB_ON : i32 = -2144272240;
pub const FVE_E_POLICY_CONFLICT_FDV_RP_OFF_ADB_ON : i32 = -2144272239;
pub const FVE_E_POLICY_CONFLICT_RDV_RP_OFF_ADB_ON : i32 = -2144272238;
pub const FVE_E_NON_BITLOCKER_KU : i32 = -2144272237;
pub const FVE_E_PRIVATEKEY_AUTH_FAILED : i32 = -2144272236;
pub const FVE_E_REMOVAL_OF_DRA_FAILED : i32 = -2144272235;
pub const FVE_E_OPERATION_NOT_SUPPORTED_ON_VISTA_VOLUME : i32 = -2144272234;
pub const FVE_E_CANT_LOCK_AUTOUNLOCK_ENABLED_VOLUME : i32 = -2144272233;
pub const FVE_E_FIPS_HASH_KDF_NOT_ALLOWED : i32 = -2144272232;
pub const FVE_E_ENH_PIN_INVALID : i32 = -2144272231;
pub const FVE_E_INVALID_PIN_CHARS : i32 = -2144272230;
pub const FVE_E_INVALID_DATUM_TYPE : i32 = -2144272229;
pub const FVE_E_EFI_ONLY : i32 = -2144272228;
pub const FVE_E_MULTIPLE_NKP_CERTS : i32 = -2144272227;
pub const FVE_E_REMOVAL_OF_NKP_FAILED : i32 = -2144272226;
pub const FVE_E_INVALID_NKP_CERT : i32 = -2144272225;
pub const FVE_E_NO_EXISTING_PIN : i32 = -2144272224;
pub const FVE_E_PROTECTOR_CHANGE_PIN_MISMATCH : i32 = -2144272223;
pub const FVE_E_PIN_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED : i32 = -2144272222;
pub const FVE_E_PROTECTOR_CHANGE_MAX_PIN_CHANGE_ATTEMPTS_REACHED : i32 = -2144272221;
pub const FVE_E_POLICY_PASSPHRASE_REQUIRES_ASCII : i32 = -2144272220;
pub const FVE_E_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE : i32 = -2144272219;
pub const FVE_E_WIPE_NOT_ALLOWED_ON_TP_STORAGE : i32 = -2144272218;
pub const FVE_E_KEY_LENGTH_NOT_SUPPORTED_BY_EDRIVE : i32 = -2144272217;
pub const FVE_E_NO_EXISTING_PASSPHRASE : i32 = -2144272216;
pub const FVE_E_PROTECTOR_CHANGE_PASSPHRASE_MISMATCH : i32 = -2144272215;
pub const FVE_E_PASSPHRASE_TOO_LONG : i32 = -2144272214;
pub const FVE_E_NO_PASSPHRASE_WITH_TPM : i32 = -2144272213;
pub const FVE_E_NO_TPM_WITH_PASSPHRASE : i32 = -2144272212;
pub const FVE_E_NOT_ALLOWED_ON_CSV_STACK : i32 = -2144272211;
pub const FVE_E_NOT_ALLOWED_ON_CLUSTER : i32 = -2144272210;
pub const FVE_E_EDRIVE_NO_FAILOVER_TO_SW : i32 = -2144272209;
pub const FVE_E_EDRIVE_BAND_IN_USE : i32 = -2144272208;
pub const FVE_E_EDRIVE_DISALLOWED_BY_GP : i32 = -2144272207;
pub const FVE_E_EDRIVE_INCOMPATIBLE_VOLUME : i32 = -2144272206;
pub const FVE_E_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING : i32 = -2144272205;
pub const FVE_E_EDRIVE_DV_NOT_SUPPORTED : i32 = -2144272204;
pub const FVE_E_NO_PREBOOT_KEYBOARD_DETECTED : i32 = -2144272203;
pub const FVE_E_NO_PREBOOT_KEYBOARD_OR_WINRE_DETECTED : i32 = -2144272202;
pub const FVE_E_POLICY_REQUIRES_STARTUP_PIN_ON_TOUCH_DEVICE : i32 = -2144272201;
pub const FVE_E_POLICY_REQUIRES_RECOVERY_PASSWORD_ON_TOUCH_DEVICE : i32 = -2144272200;
pub const FVE_E_WIPE_CANCEL_NOT_APPLICABLE : i32 = -2144272199;
pub const FVE_E_SECUREBOOT_DISABLED : i32 = -2144272198;
pub const FVE_E_SECUREBOOT_CONFIGURATION_INVALID : i32 = -2144272197;
pub const FVE_E_EDRIVE_DRY_RUN_FAILED : i32 = -2144272196;
pub const FVE_E_SHADOW_COPY_PRESENT : i32 = -2144272195;
pub const FVE_E_POLICY_INVALID_ENHANCED_BCD_SETTINGS : i32 = -2144272194;
pub const FVE_E_EDRIVE_INCOMPATIBLE_FIRMWARE : i32 = -2144272193;
pub const FVE_E_PROTECTOR_CHANGE_MAX_PASSPHRASE_CHANGE_ATTEMPTS_REACHED : i32 = -2144272192;
pub const FVE_E_PASSPHRASE_PROTECTOR_CHANGE_BY_STD_USER_DISALLOWED : i32 = -2144272191;
pub const FVE_E_LIVEID_ACCOUNT_SUSPENDED : i32 = -2144272190;
pub const FVE_E_LIVEID_ACCOUNT_BLOCKED : i32 = -2144272189;
pub const FVE_E_NOT_PROVISIONED_ON_ALL_VOLUMES : i32 = -2144272188;
pub const FVE_E_DE_FIXED_DATA_NOT_SUPPORTED : i32 = -2144272187;
pub const FVE_E_DE_HARDWARE_NOT_COMPLIANT : i32 = -2144272186;
pub const FVE_E_DE_WINRE_NOT_CONFIGURED : i32 = -2144272185;
pub const FVE_E_DE_PROTECTION_SUSPENDED : i32 = -2144272184;
pub const FVE_E_DE_OS_VOLUME_NOT_PROTECTED : i32 = -2144272183;
pub const FVE_E_DE_DEVICE_LOCKEDOUT : i32 = -2144272182;
pub const FVE_E_DE_PROTECTION_NOT_YET_ENABLED : i32 = -2144272181;
pub const FVE_E_INVALID_PIN_CHARS_DETAILED : i32 = -2144272180;
pub const FVE_E_DEVICE_LOCKOUT_COUNTER_UNAVAILABLE : i32 = -2144272179;
pub const FVE_E_DEVICELOCKOUT_COUNTER_MISMATCH : i32 = -2144272178;
pub const FVE_E_BUFFER_TOO_LARGE : i32 = -2144272177;
pub const FVE_E_NO_SUCH_CAPABILITY_ON_TARGET : i32 = -2144272176;
pub const FVE_E_DE_PREVENTED_FOR_OS : i32 = -2144272175;
pub const FVE_E_DE_VOLUME_OPTED_OUT : i32 = -2144272174;
pub const FVE_E_DE_VOLUME_NOT_SUPPORTED : i32 = -2144272173;
pub const FVE_E_EOW_NOT_SUPPORTED_IN_VERSION : i32 = -2144272172;
pub const FVE_E_ADBACKUP_NOT_ENABLED : i32 = -2144272171;
pub const FVE_E_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT : i32 = -2144272170;
pub const FVE_E_NOT_DE_VOLUME : i32 = -2144272169;
pub const FVE_E_PROTECTION_CANNOT_BE_DISABLED : i32 = -2144272168;
pub const FVE_E_OSV_KSR_NOT_ALLOWED : i32 = -2144272167;
pub const FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_OS_DRIVE : i32 = -2144272166;
pub const FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_FIXED_DRIVE : i32 = -2144272165;
pub const FVE_E_AD_BACKUP_REQUIRED_POLICY_NOT_SET_REMOVABLE_DRIVE : i32 = -2144272164;
pub const FVE_E_KEY_ROTATION_NOT_SUPPORTED : i32 = -2144272163;
pub const FVE_E_EXECUTE_REQUEST_SENT_TOO_SOON : i32 = -2144272162;
pub const FVE_E_KEY_ROTATION_NOT_ENABLED : i32 = -2144272161;
pub const FVE_E_DEVICE_NOT_JOINED : i32 = -2144272160;
pub const FVE_E_AAD_ENDPOINT_BUSY : i32 = -2144272159;
pub const FWP_E_CALLOUT_NOT_FOUND : i32 = -2144206847;
pub const FWP_E_CONDITION_NOT_FOUND : i32 = -2144206846;
pub const FWP_E_FILTER_NOT_FOUND : i32 = -2144206845;
pub const FWP_E_LAYER_NOT_FOUND : i32 = -2144206844;
pub const FWP_E_PROVIDER_NOT_FOUND : i32 = -2144206843;
pub const FWP_E_PROVIDER_CONTEXT_NOT_FOUND : i32 = -2144206842;
pub const FWP_E_SUBLAYER_NOT_FOUND : i32 = -2144206841;
pub const FWP_E_NOT_FOUND : i32 = -2144206840;
pub const FWP_E_ALREADY_EXISTS : i32 = -2144206839;
pub const FWP_E_IN_USE : i32 = -2144206838;
pub const FWP_E_DYNAMIC_SESSION_IN_PROGRESS : i32 = -2144206837;
pub const FWP_E_WRONG_SESSION : i32 = -2144206836;
pub const FWP_E_NO_TXN_IN_PROGRESS : i32 = -2144206835;
pub const FWP_E_TXN_IN_PROGRESS : i32 = -2144206834;
pub const FWP_E_TXN_ABORTED : i32 = -2144206833;
pub const FWP_E_SESSION_ABORTED : i32 = -2144206832;
pub const FWP_E_INCOMPATIBLE_TXN : i32 = -2144206831;
pub const FWP_E_TIMEOUT : i32 = -2144206830;
pub const FWP_E_NET_EVENTS_DISABLED : i32 = -2144206829;
pub const FWP_E_INCOMPATIBLE_LAYER : i32 = -2144206828;
pub const FWP_E_KM_CLIENTS_ONLY : i32 = -2144206827;
pub const FWP_E_LIFETIME_MISMATCH : i32 = -2144206826;
pub const FWP_E_BUILTIN_OBJECT : i32 = -2144206825;
pub const FWP_E_TOO_MANY_CALLOUTS : i32 = -2144206824;
pub const FWP_E_NOTIFICATION_DROPPED : i32 = -2144206823;
pub const FWP_E_TRAFFIC_MISMATCH : i32 = -2144206822;
pub const FWP_E_INCOMPATIBLE_SA_STATE : i32 = -2144206821;
pub const FWP_E_NULL_POINTER : i32 = -2144206820;
pub const FWP_E_INVALID_ENUMERATOR : i32 = -2144206819;
pub const FWP_E_INVALID_FLAGS : i32 = -2144206818;
pub const FWP_E_INVALID_NET_MASK : i32 = -2144206817;
pub const FWP_E_INVALID_RANGE : i32 = -2144206816;
pub const FWP_E_INVALID_INTERVAL : i32 = -2144206815;
pub const FWP_E_ZERO_LENGTH_ARRAY : i32 = -2144206814;
pub const FWP_E_NULL_DISPLAY_NAME : i32 = -2144206813;
pub const FWP_E_INVALID_ACTION_TYPE : i32 = -2144206812;
pub const FWP_E_INVALID_WEIGHT : i32 = -2144206811;
pub const FWP_E_MATCH_TYPE_MISMATCH : i32 = -2144206810;
pub const FWP_E_TYPE_MISMATCH : i32 = -2144206809;
pub const FWP_E_OUT_OF_BOUNDS : i32 = -2144206808;
pub const FWP_E_RESERVED : i32 = -2144206807;
pub const FWP_E_DUPLICATE_CONDITION : i32 = -2144206806;
pub const FWP_E_DUPLICATE_KEYMOD : i32 = -2144206805;
pub const FWP_E_ACTION_INCOMPATIBLE_WITH_LAYER : i32 = -2144206804;
pub const FWP_E_ACTION_INCOMPATIBLE_WITH_SUBLAYER : i32 = -2144206803;
pub const FWP_E_CONTEXT_INCOMPATIBLE_WITH_LAYER : i32 = -2144206802;
pub const FWP_E_CONTEXT_INCOMPATIBLE_WITH_CALLOUT : i32 = -2144206801;
pub const FWP_E_INCOMPATIBLE_AUTH_METHOD : i32 = -2144206800;
pub const FWP_E_INCOMPATIBLE_DH_GROUP : i32 = -2144206799;
pub const FWP_E_EM_NOT_SUPPORTED : i32 = -2144206798;
pub const FWP_E_NEVER_MATCH : i32 = -2144206797;
pub const FWP_E_PROVIDER_CONTEXT_MISMATCH : i32 = -2144206796;
pub const FWP_E_INVALID_PARAMETER : i32 = -2144206795;
pub const FWP_E_TOO_MANY_SUBLAYERS : i32 = -2144206794;
pub const FWP_E_CALLOUT_NOTIFICATION_FAILED : i32 = -2144206793;
pub const FWP_E_INVALID_AUTH_TRANSFORM : i32 = -2144206792;
pub const FWP_E_INVALID_CIPHER_TRANSFORM : i32 = -2144206791;
pub const FWP_E_INCOMPATIBLE_CIPHER_TRANSFORM : i32 = -2144206790;
pub const FWP_E_INVALID_TRANSFORM_COMBINATION : i32 = -2144206789;
pub const FWP_E_DUPLICATE_AUTH_METHOD : i32 = -2144206788;
pub const FWP_E_INVALID_TUNNEL_ENDPOINT : i32 = -2144206787;
pub const FWP_E_L2_DRIVER_NOT_READY : i32 = -2144206786;
pub const FWP_E_KEY_DICTATOR_ALREADY_REGISTERED : i32 = -2144206785;
pub const FWP_E_KEY_DICTATION_INVALID_KEYING_MATERIAL : i32 = -2144206784;
pub const FWP_E_CONNECTIONS_DISABLED : i32 = -2144206783;
pub const FWP_E_INVALID_DNS_NAME : i32 = -2144206782;
pub const FWP_E_STILL_ON : i32 = -2144206781;
pub const FWP_E_IKEEXT_NOT_RUNNING : i32 = -2144206780;
pub const FWP_E_DROP_NOICMP : i32 = -2144206588;
pub const WS_S_ASYNC : i32 = 3997696;
pub const WS_S_END : i32 = 3997697;
pub const WS_E_INVALID_FORMAT : i32 = -2143485952;
pub const WS_E_OBJECT_FAULTED : i32 = -2143485951;
pub const WS_E_NUMERIC_OVERFLOW : i32 = -2143485950;
pub const WS_E_INVALID_OPERATION : i32 = -2143485949;
pub const WS_E_OPERATION_ABORTED : i32 = -2143485948;
pub const WS_E_ENDPOINT_ACCESS_DENIED : i32 = -2143485947;
pub const WS_E_OPERATION_TIMED_OUT : i32 = -2143485946;
pub const WS_E_OPERATION_ABANDONED : i32 = -2143485945;
pub const WS_E_QUOTA_EXCEEDED : i32 = -2143485944;
pub const WS_E_NO_TRANSLATION_AVAILABLE : i32 = -2143485943;
pub const WS_E_SECURITY_VERIFICATION_FAILURE : i32 = -2143485942;
pub const WS_E_ADDRESS_IN_USE : i32 = -2143485941;
pub const WS_E_ADDRESS_NOT_AVAILABLE : i32 = -2143485940;
pub const WS_E_ENDPOINT_NOT_FOUND : i32 = -2143485939;
pub const WS_E_ENDPOINT_NOT_AVAILABLE : i32 = -2143485938;
pub const WS_E_ENDPOINT_FAILURE : i32 = -2143485937;
pub const WS_E_ENDPOINT_UNREACHABLE : i32 = -2143485936;
pub const WS_E_ENDPOINT_ACTION_NOT_SUPPORTED : i32 = -2143485935;
pub const WS_E_ENDPOINT_TOO_BUSY : i32 = -2143485934;
pub const WS_E_ENDPOINT_FAULT_RECEIVED : i32 = -2143485933;
pub const WS_E_ENDPOINT_DISCONNECTED : i32 = -2143485932;
pub const WS_E_PROXY_FAILURE : i32 = -2143485931;
pub const WS_E_PROXY_ACCESS_DENIED : i32 = -2143485930;
pub const WS_E_NOT_SUPPORTED : i32 = -2143485929;
pub const WS_E_PROXY_REQUIRES_BASIC_AUTH : i32 = -2143485928;
pub const WS_E_PROXY_REQUIRES_DIGEST_AUTH : i32 = -2143485927;
pub const WS_E_PROXY_REQUIRES_NTLM_AUTH : i32 = -2143485926;
pub const WS_E_PROXY_REQUIRES_NEGOTIATE_AUTH : i32 = -2143485925;
pub const WS_E_SERVER_REQUIRES_BASIC_AUTH : i32 = -2143485924;
pub const WS_E_SERVER_REQUIRES_DIGEST_AUTH : i32 = -2143485923;
pub const WS_E_SERVER_REQUIRES_NTLM_AUTH : i32 = -2143485922;
pub const WS_E_SERVER_REQUIRES_NEGOTIATE_AUTH : i32 = -2143485921;
pub const WS_E_INVALID_ENDPOINT_URL : i32 = -2143485920;
pub const WS_E_OTHER : i32 = -2143485919;
pub const WS_E_SECURITY_TOKEN_EXPIRED : i32 = -2143485918;
pub const WS_E_SECURITY_SYSTEM_FAILURE : i32 = -2143485917;
pub const ERROR_NDIS_INTERFACE_CLOSING : u32 = 2150891522;
pub const ERROR_NDIS_BAD_VERSION : u32 = 2150891524;
pub const ERROR_NDIS_BAD_CHARACTERISTICS : u32 = 2150891525;
pub const ERROR_NDIS_ADAPTER_NOT_FOUND : u32 = 2150891526;
pub const ERROR_NDIS_OPEN_FAILED : u32 = 2150891527;
pub const ERROR_NDIS_DEVICE_FAILED : u32 = 2150891528;
pub const ERROR_NDIS_MULTICAST_FULL : u32 = 2150891529;
pub const ERROR_NDIS_MULTICAST_EXISTS : u32 = 2150891530;
pub const ERROR_NDIS_MULTICAST_NOT_FOUND : u32 = 2150891531;
pub const ERROR_NDIS_REQUEST_ABORTED : u32 = 2150891532;
pub const ERROR_NDIS_RESET_IN_PROGRESS : u32 = 2150891533;
pub const ERROR_NDIS_NOT_SUPPORTED : u32 = 2150891707;
pub const ERROR_NDIS_INVALID_PACKET : u32 = 2150891535;
pub const ERROR_NDIS_ADAPTER_NOT_READY : u32 = 2150891537;
pub const ERROR_NDIS_INVALID_LENGTH : u32 = 2150891540;
pub const ERROR_NDIS_INVALID_DATA : u32 = 2150891541;
pub const ERROR_NDIS_BUFFER_TOO_SHORT : u32 = 2150891542;
pub const ERROR_NDIS_INVALID_OID : u32 = 2150891543;
pub const ERROR_NDIS_ADAPTER_REMOVED : u32 = 2150891544;
pub const ERROR_NDIS_UNSUPPORTED_MEDIA : u32 = 2150891545;
pub const ERROR_NDIS_GROUP_ADDRESS_IN_USE : u32 = 2150891546;
pub const ERROR_NDIS_FILE_NOT_FOUND : u32 = 2150891547;
pub const ERROR_NDIS_ERROR_READING_FILE : u32 = 2150891548;
pub const ERROR_NDIS_ALREADY_MAPPED : u32 = 2150891549;
pub const ERROR_NDIS_RESOURCE_CONFLICT : u32 = 2150891550;
pub const ERROR_NDIS_MEDIA_DISCONNECTED : u32 = 2150891551;
pub const ERROR_NDIS_INVALID_ADDRESS : u32 = 2150891554;
pub const ERROR_NDIS_INVALID_DEVICE_REQUEST : u32 = 2150891536;
pub const ERROR_NDIS_PAUSED : u32 = 2150891562;
pub const ERROR_NDIS_INTERFACE_NOT_FOUND : u32 = 2150891563;
pub const ERROR_NDIS_UNSUPPORTED_REVISION : u32 = 2150891564;
pub const ERROR_NDIS_INVALID_PORT : u32 = 2150891565;
pub const ERROR_NDIS_INVALID_PORT_STATE : u32 = 2150891566;
pub const ERROR_NDIS_LOW_POWER_STATE : u32 = 2150891567;
pub const ERROR_NDIS_REINIT_REQUIRED : u32 = 2150891568;
pub const ERROR_NDIS_NO_QUEUES : u32 = 2150891569;
pub const ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED : u32 = 2150899712;
pub const ERROR_NDIS_DOT11_MEDIA_IN_USE : u32 = 2150899713;
pub const ERROR_NDIS_DOT11_POWER_STATE_INVALID : u32 = 2150899714;
pub const ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL : u32 = 2150899715;
pub const ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL : u32 = 2150899716;
pub const ERROR_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE : u32 = 2150899717;
pub const ERROR_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE : u32 = 2150899718;
pub const ERROR_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED : u32 = 2150899719;
pub const ERROR_NDIS_DOT11_AP_BAND_NOT_ALLOWED : u32 = 2150899720;
pub const ERROR_NDIS_INDICATION_REQUIRED : u32 = 3407873;
pub const ERROR_NDIS_OFFLOAD_POLICY : u32 = 3224637455;
pub const ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED : u32 = 3224637458;
pub const ERROR_NDIS_OFFLOAD_PATH_REJECTED : u32 = 3224637459;
pub const ERROR_HV_INVALID_HYPERCALL_CODE : u32 = 3224698882;
pub const ERROR_HV_INVALID_HYPERCALL_INPUT : u32 = 3224698883;
pub const ERROR_HV_INVALID_ALIGNMENT : u32 = 3224698884;
pub const ERROR_HV_INVALID_PARAMETER : u32 = 3224698885;
pub const ERROR_HV_ACCESS_DENIED : u32 = 3224698886;
pub const ERROR_HV_INVALID_PARTITION_STATE : u32 = 3224698887;
pub const ERROR_HV_OPERATION_DENIED : u32 = 3224698888;
pub const ERROR_HV_UNKNOWN_PROPERTY : u32 = 3224698889;
pub const ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE : u32 = 3224698890;
pub const ERROR_HV_INSUFFICIENT_MEMORY : u32 = 3224698891;
pub const ERROR_HV_PARTITION_TOO_DEEP : u32 = 3224698892;
pub const ERROR_HV_INVALID_PARTITION_ID : u32 = 3224698893;
pub const ERROR_HV_INVALID_VP_INDEX : u32 = 3224698894;
pub const ERROR_HV_INVALID_PORT_ID : u32 = 3224698897;
pub const ERROR_HV_INVALID_CONNECTION_ID : u32 = 3224698898;
pub const ERROR_HV_INSUFFICIENT_BUFFERS : u32 = 3224698899;
pub const ERROR_HV_NOT_ACKNOWLEDGED : u32 = 3224698900;
pub const ERROR_HV_INVALID_VP_STATE : u32 = 3224698901;
pub const ERROR_HV_ACKNOWLEDGED : u32 = 3224698902;
pub const ERROR_HV_INVALID_SAVE_RESTORE_STATE : u32 = 3224698903;
pub const ERROR_HV_INVALID_SYNIC_STATE : u32 = 3224698904;
pub const ERROR_HV_OBJECT_IN_USE : u32 = 3224698905;
pub const ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO : u32 = 3224698906;
pub const ERROR_HV_NO_DATA : u32 = 3224698907;
pub const ERROR_HV_INACTIVE : u32 = 3224698908;
pub const ERROR_HV_NO_RESOURCES : u32 = 3224698909;
pub const ERROR_HV_FEATURE_UNAVAILABLE : u32 = 3224698910;
pub const ERROR_HV_INSUFFICIENT_BUFFER : u32 = 3224698931;
pub const ERROR_HV_INSUFFICIENT_DEVICE_DOMAINS : u32 = 3224698936;
pub const ERROR_HV_CPUID_FEATURE_VALIDATION : u32 = 3224698940;
pub const ERROR_HV_CPUID_XSAVE_FEATURE_VALIDATION : u32 = 3224698941;
pub const ERROR_HV_PROCESSOR_STARTUP_TIMEOUT : u32 = 3224698942;
pub const ERROR_HV_SMX_ENABLED : u32 = 3224698943;
pub const ERROR_HV_INVALID_LP_INDEX : u32 = 3224698945;
pub const ERROR_HV_INVALID_REGISTER_VALUE : u32 = 3224698960;
pub const ERROR_HV_INVALID_VTL_STATE : u32 = 3224698961;
pub const ERROR_HV_NX_NOT_DETECTED : u32 = 3224698965;
pub const ERROR_HV_INVALID_DEVICE_ID : u32 = 3224698967;
pub const ERROR_HV_INVALID_DEVICE_STATE : u32 = 3224698968;
pub const ERROR_HV_PENDING_PAGE_REQUESTS : u32 = 3473497;
pub const ERROR_HV_PAGE_REQUEST_INVALID : u32 = 3224698976;
pub const ERROR_HV_INVALID_CPU_GROUP_ID : u32 = 3224698991;
pub const ERROR_HV_INVALID_CPU_GROUP_STATE : u32 = 3224698992;
pub const ERROR_HV_OPERATION_FAILED : u32 = 3224698993;
pub const ERROR_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE : u32 = 3224698994;
pub const ERROR_HV_INSUFFICIENT_ROOT_MEMORY : u32 = 3224698995;
pub const ERROR_HV_EVENT_BUFFER_ALREADY_FREED : u32 = 3224698996;
pub const ERROR_HV_INSUFFICIENT_CONTIGUOUS_MEMORY : u32 = 3224698997;
pub const ERROR_HV_NOT_PRESENT : u32 = 3224702976;
pub const ERROR_VID_DUPLICATE_HANDLER : u32 = 3224829953;
pub const ERROR_VID_TOO_MANY_HANDLERS : u32 = 3224829954;
pub const ERROR_VID_QUEUE_FULL : u32 = 3224829955;
pub const ERROR_VID_HANDLER_NOT_PRESENT : u32 = 3224829956;
pub const ERROR_VID_INVALID_OBJECT_NAME : u32 = 3224829957;
pub const ERROR_VID_PARTITION_NAME_TOO_LONG : u32 = 3224829958;
pub const ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG : u32 = 3224829959;
pub const ERROR_VID_PARTITION_ALREADY_EXISTS : u32 = 3224829960;
pub const ERROR_VID_PARTITION_DOES_NOT_EXIST : u32 = 3224829961;
pub const ERROR_VID_PARTITION_NAME_NOT_FOUND : u32 = 3224829962;
pub const ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS : u32 = 3224829963;
pub const ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT : u32 = 3224829964;
pub const ERROR_VID_MB_STILL_REFERENCED : u32 = 3224829965;
pub const ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED : u32 = 3224829966;
pub const ERROR_VID_INVALID_NUMA_SETTINGS : u32 = 3224829967;
pub const ERROR_VID_INVALID_NUMA_NODE_INDEX : u32 = 3224829968;
pub const ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED : u32 = 3224829969;
pub const ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE : u32 = 3224829970;
pub const ERROR_VID_PAGE_RANGE_OVERFLOW : u32 = 3224829971;
pub const ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE : u32 = 3224829972;
pub const ERROR_VID_INVALID_GPA_RANGE_HANDLE : u32 = 3224829973;
pub const ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE : u32 = 3224829974;
pub const ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED : u32 = 3224829975;
pub const ERROR_VID_INVALID_PPM_HANDLE : u32 = 3224829976;
pub const ERROR_VID_MBPS_ARE_LOCKED : u32 = 3224829977;
pub const ERROR_VID_MESSAGE_QUEUE_CLOSED : u32 = 3224829978;
pub const ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED : u32 = 3224829979;
pub const ERROR_VID_STOP_PENDING : u32 = 3224829980;
pub const ERROR_VID_INVALID_PROCESSOR_STATE : u32 = 3224829981;
pub const ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT : u32 = 3224829982;
pub const ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED : u32 = 3224829983;
pub const ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET : u32 = 3224829984;
pub const ERROR_VID_MMIO_RANGE_DESTROYED : u32 = 3224829985;
pub const ERROR_VID_INVALID_CHILD_GPA_PAGE_SET : u32 = 3224829986;
pub const ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED : u32 = 3224829987;
pub const ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL : u32 = 3224829988;
pub const ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE : u32 = 3224829989;
pub const ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT : u32 = 3224829990;
pub const ERROR_VID_SAVED_STATE_CORRUPT : u32 = 3224829991;
pub const ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM : u32 = 3224829992;
pub const ERROR_VID_SAVED_STATE_INCOMPATIBLE : u32 = 3224829993;
pub const ERROR_VID_VTL_ACCESS_DENIED : u32 = 3224829994;
pub const ERROR_VMCOMPUTE_TERMINATED_DURING_START : u32 = 3224830208;
pub const ERROR_VMCOMPUTE_IMAGE_MISMATCH : u32 = 3224830209;
pub const ERROR_VMCOMPUTE_HYPERV_NOT_INSTALLED : u32 = 3224830210;
pub const ERROR_VMCOMPUTE_OPERATION_PENDING : u32 = 3224830211;
pub const ERROR_VMCOMPUTE_TOO_MANY_NOTIFICATIONS : u32 = 3224830212;
pub const ERROR_VMCOMPUTE_INVALID_STATE : u32 = 3224830213;
pub const ERROR_VMCOMPUTE_UNEXPECTED_EXIT : u32 = 3224830214;
pub const ERROR_VMCOMPUTE_TERMINATED : u32 = 3224830215;
pub const ERROR_VMCOMPUTE_CONNECT_FAILED : u32 = 3224830216;
pub const ERROR_VMCOMPUTE_TIMEOUT : u32 = 3224830217;
pub const ERROR_VMCOMPUTE_CONNECTION_CLOSED : u32 = 3224830218;
pub const ERROR_VMCOMPUTE_UNKNOWN_MESSAGE : u32 = 3224830219;
pub const ERROR_VMCOMPUTE_UNSUPPORTED_PROTOCOL_VERSION : u32 = 3224830220;
pub const ERROR_VMCOMPUTE_INVALID_JSON : u32 = 3224830221;
pub const ERROR_VMCOMPUTE_SYSTEM_NOT_FOUND : u32 = 3224830222;
pub const ERROR_VMCOMPUTE_SYSTEM_ALREADY_EXISTS : u32 = 3224830223;
pub const ERROR_VMCOMPUTE_SYSTEM_ALREADY_STOPPED : u32 = 3224830224;
pub const ERROR_VMCOMPUTE_PROTOCOL_ERROR : u32 = 3224830225;
pub const ERROR_VMCOMPUTE_INVALID_LAYER : u32 = 3224830226;
pub const ERROR_VMCOMPUTE_WINDOWS_INSIDER_REQUIRED : u32 = 3224830227;
pub const HCS_E_TERMINATED_DURING_START : i32 = -2143878912;
pub const HCS_E_IMAGE_MISMATCH : i32 = -2143878911;
pub const HCS_E_HYPERV_NOT_INSTALLED : i32 = -2143878910;
pub const HCS_E_INVALID_STATE : i32 = -2143878907;
pub const HCS_E_UNEXPECTED_EXIT : i32 = -2143878906;
pub const HCS_E_TERMINATED : i32 = -2143878905;
pub const HCS_E_CONNECT_FAILED : i32 = -2143878904;
pub const HCS_E_CONNECTION_TIMEOUT : i32 = -2143878903;
pub const HCS_E_CONNECTION_CLOSED : i32 = -2143878902;
pub const HCS_E_UNKNOWN_MESSAGE : i32 = -2143878901;
pub const HCS_E_UNSUPPORTED_PROTOCOL_VERSION : i32 = -2143878900;
pub const HCS_E_INVALID_JSON : i32 = -2143878899;
pub const HCS_E_SYSTEM_NOT_FOUND : i32 = -2143878898;
pub const HCS_E_SYSTEM_ALREADY_EXISTS : i32 = -2143878897;
pub const HCS_E_SYSTEM_ALREADY_STOPPED : i32 = -2143878896;
pub const HCS_E_PROTOCOL_ERROR : i32 = -2143878895;
pub const HCS_E_INVALID_LAYER : i32 = -2143878894;
pub const HCS_E_WINDOWS_INSIDER_REQUIRED : i32 = -2143878893;
pub const HCS_E_SERVICE_NOT_AVAILABLE : i32 = -2143878892;
pub const HCS_E_OPERATION_NOT_STARTED : i32 = -2143878891;
pub const HCS_E_OPERATION_ALREADY_STARTED : i32 = -2143878890;
pub const HCS_E_OPERATION_PENDING : i32 = -2143878889;
pub const HCS_E_OPERATION_TIMEOUT : i32 = -2143878888;
pub const HCS_E_OPERATION_SYSTEM_CALLBACK_ALREADY_SET : i32 = -2143878887;
pub const HCS_E_OPERATION_RESULT_ALLOCATION_FAILED : i32 = -2143878886;
pub const HCS_E_ACCESS_DENIED : i32 = -2143878885;
pub const HCS_E_GUEST_CRITICAL_ERROR : i32 = -2143878884;
pub const HCS_E_PROCESS_INFO_NOT_AVAILABLE : i32 = -2143878883;
pub const HCS_E_SERVICE_DISCONNECT : i32 = -2143878882;
pub const HCS_E_PROCESS_ALREADY_STOPPED : i32 = -2143878881;
pub const ERROR_VNET_VIRTUAL_SWITCH_NAME_NOT_FOUND : u32 = 3224830464;
pub const ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED : u32 = 2151088129;
pub const WHV_E_UNKNOWN_CAPABILITY : i32 = -2143878400;
pub const WHV_E_INSUFFICIENT_BUFFER : i32 = -2143878399;
pub const WHV_E_UNKNOWN_PROPERTY : i32 = -2143878398;
pub const WHV_E_UNSUPPORTED_HYPERVISOR_CONFIG : i32 = -2143878397;
pub const WHV_E_INVALID_PARTITION_CONFIG : i32 = -2143878396;
pub const WHV_E_GPA_RANGE_NOT_FOUND : i32 = -2143878395;
pub const WHV_E_VP_ALREADY_EXISTS : i32 = -2143878394;
pub const WHV_E_VP_DOES_NOT_EXIST : i32 = -2143878393;
pub const WHV_E_INVALID_VP_STATE : i32 = -2143878392;
pub const WHV_E_INVALID_VP_REGISTER_NAME : i32 = -2143878391;
pub const WHV_E_UNSUPPORTED_PROCESSOR_CONFIG : i32 = -2143878384;
pub const ERROR_VSMB_SAVED_STATE_FILE_NOT_FOUND : u32 = 3224830976;
pub const ERROR_VSMB_SAVED_STATE_CORRUPT : u32 = 3224830977;
pub const VM_SAVED_STATE_DUMP_E_PARTITION_STATE_NOT_FOUND : i32 = -1070136064;
pub const VM_SAVED_STATE_DUMP_E_GUEST_MEMORY_NOT_FOUND : i32 = -1070136063;
pub const VM_SAVED_STATE_DUMP_E_NO_VP_FOUND_IN_PARTITION_STATE : i32 = -1070136062;
pub const VM_SAVED_STATE_DUMP_E_NESTED_VIRTUALIZATION_NOT_SUPPORTED : i32 = -1070136061;
pub const VM_SAVED_STATE_DUMP_E_WINDOWS_KERNEL_IMAGE_NOT_FOUND : i32 = -1070136060;
pub const VM_SAVED_STATE_DUMP_E_PXE_NOT_PRESENT : i32 = -1070136059;
pub const VM_SAVED_STATE_DUMP_E_PDPTE_NOT_PRESENT : i32 = -1070136058;
pub const VM_SAVED_STATE_DUMP_E_PDE_NOT_PRESENT : i32 = -1070136057;
pub const VM_SAVED_STATE_DUMP_E_PTE_NOT_PRESENT : i32 = -1070136056;
pub const ERROR_VOLMGR_INCOMPLETE_REGENERATION : u32 = 2151153665;
pub const ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION : u32 = 2151153666;
pub const ERROR_VOLMGR_DATABASE_FULL : u32 = 3224895489;
pub const ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED : u32 = 3224895490;
pub const ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC : u32 = 3224895491;
pub const ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED : u32 = 3224895492;
pub const ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME : u32 = 3224895493;
pub const ERROR_VOLMGR_DISK_DUPLICATE : u32 = 3224895494;
pub const ERROR_VOLMGR_DISK_DYNAMIC : u32 = 3224895495;
pub const ERROR_VOLMGR_DISK_ID_INVALID : u32 = 3224895496;
pub const ERROR_VOLMGR_DISK_INVALID : u32 = 3224895497;
pub const ERROR_VOLMGR_DISK_LAST_VOTER : u32 = 3224895498;
pub const ERROR_VOLMGR_DISK_LAYOUT_INVALID : u32 = 3224895499;
pub const ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS : u32 = 3224895500;
pub const ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED : u32 = 3224895501;
pub const ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL : u32 = 3224895502;
pub const ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS : u32 = 3224895503;
pub const ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS : u32 = 3224895504;
pub const ERROR_VOLMGR_DISK_MISSING : u32 = 3224895505;
pub const ERROR_VOLMGR_DISK_NOT_EMPTY : u32 = 3224895506;
pub const ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE : u32 = 3224895507;
pub const ERROR_VOLMGR_DISK_REVECTORING_FAILED : u32 = 3224895508;
pub const ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID : u32 = 3224895509;
pub const ERROR_VOLMGR_DISK_SET_NOT_CONTAINED : u32 = 3224895510;
pub const ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS : u32 = 3224895511;
pub const ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES : u32 = 3224895512;
pub const ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED : u32 = 3224895513;
pub const ERROR_VOLMGR_EXTENT_ALREADY_USED : u32 = 3224895514;
pub const ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS : u32 = 3224895515;
pub const ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION : u32 = 3224895516;
pub const ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED : u32 = 3224895517;
pub const ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION : u32 = 3224895518;
pub const ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH : u32 = 3224895519;
pub const ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED : u32 = 3224895520;
pub const ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID : u32 = 3224895521;
pub const ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS : u32 = 3224895522;
pub const ERROR_VOLMGR_MEMBER_IN_SYNC : u32 = 3224895523;
pub const ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE : u32 = 3224895524;
pub const ERROR_VOLMGR_MEMBER_INDEX_INVALID : u32 = 3224895525;
pub const ERROR_VOLMGR_MEMBER_MISSING : u32 = 3224895526;
pub const ERROR_VOLMGR_MEMBER_NOT_DETACHED : u32 = 3224895527;
pub const ERROR_VOLMGR_MEMBER_REGENERATING : u32 = 3224895528;
pub const ERROR_VOLMGR_ALL_DISKS_FAILED : u32 = 3224895529;
pub const ERROR_VOLMGR_NO_REGISTERED_USERS : u32 = 3224895530;
pub const ERROR_VOLMGR_NO_SUCH_USER : u32 = 3224895531;
pub const ERROR_VOLMGR_NOTIFICATION_RESET : u32 = 3224895532;
pub const ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID : u32 = 3224895533;
pub const ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID : u32 = 3224895534;
pub const ERROR_VOLMGR_PACK_DUPLICATE : u32 = 3224895535;
pub const ERROR_VOLMGR_PACK_ID_INVALID : u32 = 3224895536;
pub const ERROR_VOLMGR_PACK_INVALID : u32 = 3224895537;
pub const ERROR_VOLMGR_PACK_NAME_INVALID : u32 = 3224895538;
pub const ERROR_VOLMGR_PACK_OFFLINE : u32 = 3224895539;
pub const ERROR_VOLMGR_PACK_HAS_QUORUM : u32 = 3224895540;
pub const ERROR_VOLMGR_PACK_WITHOUT_QUORUM : u32 = 3224895541;
pub const ERROR_VOLMGR_PARTITION_STYLE_INVALID : u32 = 3224895542;
pub const ERROR_VOLMGR_PARTITION_UPDATE_FAILED : u32 = 3224895543;
pub const ERROR_VOLMGR_PLEX_IN_SYNC : u32 = 3224895544;
pub const ERROR_VOLMGR_PLEX_INDEX_DUPLICATE : u32 = 3224895545;
pub const ERROR_VOLMGR_PLEX_INDEX_INVALID : u32 = 3224895546;
pub const ERROR_VOLMGR_PLEX_LAST_ACTIVE : u32 = 3224895547;
pub const ERROR_VOLMGR_PLEX_MISSING : u32 = 3224895548;
pub const ERROR_VOLMGR_PLEX_REGENERATING : u32 = 3224895549;
pub const ERROR_VOLMGR_PLEX_TYPE_INVALID : u32 = 3224895550;
pub const ERROR_VOLMGR_PLEX_NOT_RAID5 : u32 = 3224895551;
pub const ERROR_VOLMGR_PLEX_NOT_SIMPLE : u32 = 3224895552;
pub const ERROR_VOLMGR_STRUCTURE_SIZE_INVALID : u32 = 3224895553;
pub const ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS : u32 = 3224895554;
pub const ERROR_VOLMGR_TRANSACTION_IN_PROGRESS : u32 = 3224895555;
pub const ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE : u32 = 3224895556;
pub const ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK : u32 = 3224895557;
pub const ERROR_VOLMGR_VOLUME_ID_INVALID : u32 = 3224895558;
pub const ERROR_VOLMGR_VOLUME_LENGTH_INVALID : u32 = 3224895559;
pub const ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE : u32 = 3224895560;
pub const ERROR_VOLMGR_VOLUME_NOT_MIRRORED : u32 = 3224895561;
pub const ERROR_VOLMGR_VOLUME_NOT_RETAINED : u32 = 3224895562;
pub const ERROR_VOLMGR_VOLUME_OFFLINE : u32 = 3224895563;
pub const ERROR_VOLMGR_VOLUME_RETAINED : u32 = 3224895564;
pub const ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID : u32 = 3224895565;
pub const ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE : u32 = 3224895566;
pub const ERROR_VOLMGR_BAD_BOOT_DISK : u32 = 3224895567;
pub const ERROR_VOLMGR_PACK_CONFIG_OFFLINE : u32 = 3224895568;
pub const ERROR_VOLMGR_PACK_CONFIG_ONLINE : u32 = 3224895569;
pub const ERROR_VOLMGR_NOT_PRIMARY_PACK : u32 = 3224895570;
pub const ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED : u32 = 3224895571;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID : u32 = 3224895572;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID : u32 = 3224895573;
pub const ERROR_VOLMGR_VOLUME_MIRRORED : u32 = 3224895574;
pub const ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED : u32 = 3224895575;
pub const ERROR_VOLMGR_NO_VALID_LOG_COPIES : u32 = 3224895576;
pub const ERROR_VOLMGR_PRIMARY_PACK_PRESENT : u32 = 3224895577;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID : u32 = 3224895578;
pub const ERROR_VOLMGR_MIRROR_NOT_SUPPORTED : u32 = 3224895579;
pub const ERROR_VOLMGR_RAID5_NOT_SUPPORTED : u32 = 3224895580;
pub const ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED : u32 = 2151219201;
pub const ERROR_BCD_TOO_MANY_ELEMENTS : u32 = 3224961026;
pub const ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED : u32 = 2151219203;
pub const ERROR_VHD_DRIVE_FOOTER_MISSING : u32 = 3225026561;
pub const ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH : u32 = 3225026562;
pub const ERROR_VHD_DRIVE_FOOTER_CORRUPT : u32 = 3225026563;
pub const ERROR_VHD_FORMAT_UNKNOWN : u32 = 3225026564;
pub const ERROR_VHD_FORMAT_UNSUPPORTED_VERSION : u32 = 3225026565;
pub const ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH : u32 = 3225026566;
pub const ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION : u32 = 3225026567;
pub const ERROR_VHD_SPARSE_HEADER_CORRUPT : u32 = 3225026568;
pub const ERROR_VHD_BLOCK_ALLOCATION_FAILURE : u32 = 3225026569;
pub const ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT : u32 = 3225026570;
pub const ERROR_VHD_INVALID_BLOCK_SIZE : u32 = 3225026571;
pub const ERROR_VHD_BITMAP_MISMATCH : u32 = 3225026572;
pub const ERROR_VHD_PARENT_VHD_NOT_FOUND : u32 = 3225026573;
pub const ERROR_VHD_CHILD_PARENT_ID_MISMATCH : u32 = 3225026574;
pub const ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH : u32 = 3225026575;
pub const ERROR_VHD_METADATA_READ_FAILURE : u32 = 3225026576;
pub const ERROR_VHD_METADATA_WRITE_FAILURE : u32 = 3225026577;
pub const ERROR_VHD_INVALID_SIZE : u32 = 3225026578;
pub const ERROR_VHD_INVALID_FILE_SIZE : u32 = 3225026579;
pub const ERROR_VIRTDISK_PROVIDER_NOT_FOUND : u32 = 3225026580;
pub const ERROR_VIRTDISK_NOT_VIRTUAL_DISK : u32 = 3225026581;
pub const ERROR_VHD_PARENT_VHD_ACCESS_DENIED : u32 = 3225026582;
pub const ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH : u32 = 3225026583;
pub const ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED : u32 = 3225026584;
pub const ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT : u32 = 3225026585;
pub const ERROR_VIRTUAL_DISK_LIMITATION : u32 = 3225026586;
pub const ERROR_VHD_INVALID_TYPE : u32 = 3225026587;
pub const ERROR_VHD_INVALID_STATE : u32 = 3225026588;
pub const ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE : u32 = 3225026589;
pub const ERROR_VIRTDISK_DISK_ALREADY_OWNED : u32 = 3225026590;
pub const ERROR_VIRTDISK_DISK_ONLINE_AND_WRITABLE : u32 = 3225026591;
pub const ERROR_CTLOG_TRACKING_NOT_INITIALIZED : u32 = 3225026592;
pub const ERROR_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE : u32 = 3225026593;
pub const ERROR_CTLOG_VHD_CHANGED_OFFLINE : u32 = 3225026594;
pub const ERROR_CTLOG_INVALID_TRACKING_STATE : u32 = 3225026595;
pub const ERROR_CTLOG_INCONSISTENT_TRACKING_FILE : u32 = 3225026596;
pub const ERROR_VHD_RESIZE_WOULD_TRUNCATE_DATA : u32 = 3225026597;
pub const ERROR_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE : u32 = 3225026598;
pub const ERROR_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE : u32 = 3225026599;
pub const ERROR_VHD_METADATA_FULL : u32 = 3225026600;
pub const ERROR_VHD_INVALID_CHANGE_TRACKING_ID : u32 = 3225026601;
pub const ERROR_VHD_CHANGE_TRACKING_DISABLED : u32 = 3225026602;
pub const ERROR_VHD_MISSING_CHANGE_TRACKING_INFORMATION : u32 = 3225026608;
pub const ERROR_QUERY_STORAGE_ERROR : u32 = 2151284737;
pub const HCN_E_NETWORK_NOT_FOUND : i32 = -2143617023;
pub const HCN_E_ENDPOINT_NOT_FOUND : i32 = -2143617022;
pub const HCN_E_LAYER_NOT_FOUND : i32 = -2143617021;
pub const HCN_E_SWITCH_NOT_FOUND : i32 = -2143617020;
pub const HCN_E_SUBNET_NOT_FOUND : i32 = -2143617019;
pub const HCN_E_ADAPTER_NOT_FOUND : i32 = -2143617018;
pub const HCN_E_PORT_NOT_FOUND : i32 = -2143617017;
pub const HCN_E_POLICY_NOT_FOUND : i32 = -2143617016;
pub const HCN_E_VFP_PORTSETTING_NOT_FOUND : i32 = -2143617015;
pub const HCN_E_INVALID_NETWORK : i32 = -2143617014;
pub const HCN_E_INVALID_NETWORK_TYPE : i32 = -2143617013;
pub const HCN_E_INVALID_ENDPOINT : i32 = -2143617012;
pub const HCN_E_INVALID_POLICY : i32 = -2143617011;
pub const HCN_E_INVALID_POLICY_TYPE : i32 = -2143617010;
pub const HCN_E_INVALID_REMOTE_ENDPOINT_OPERATION : i32 = -2143617009;
pub const HCN_E_NETWORK_ALREADY_EXISTS : i32 = -2143617008;
pub const HCN_E_LAYER_ALREADY_EXISTS : i32 = -2143617007;
pub const HCN_E_POLICY_ALREADY_EXISTS : i32 = -2143617006;
pub const HCN_E_PORT_ALREADY_EXISTS : i32 = -2143617005;
pub const HCN_E_ENDPOINT_ALREADY_ATTACHED : i32 = -2143617004;
pub const HCN_E_REQUEST_UNSUPPORTED : i32 = -2143617003;
pub const HCN_E_MAPPING_NOT_SUPPORTED : i32 = -2143617002;
pub const HCN_E_DEGRADED_OPERATION : i32 = -2143617001;
pub const HCN_E_SHARED_SWITCH_MODIFICATION : i32 = -2143617000;
pub const HCN_E_GUID_CONVERSION_FAILURE : i32 = -2143616999;
pub const HCN_E_REGKEY_FAILURE : i32 = -2143616998;
pub const HCN_E_INVALID_JSON : i32 = -2143616997;
pub const HCN_E_INVALID_JSON_REFERENCE : i32 = -2143616996;
pub const HCN_E_ENDPOINT_SHARING_DISABLED : i32 = -2143616995;
pub const HCN_E_INVALID_IP : i32 = -2143616994;
pub const HCN_E_SWITCH_EXTENSION_NOT_FOUND : i32 = -2143616993;
pub const HCN_E_MANAGER_STOPPED : i32 = -2143616992;
pub const GCN_E_MODULE_NOT_FOUND : i32 = -2143616991;
pub const GCN_E_NO_REQUEST_HANDLERS : i32 = -2143616990;
pub const GCN_E_REQUEST_UNSUPPORTED : i32 = -2143616989;
pub const GCN_E_RUNTIMEKEYS_FAILED : i32 = -2143616988;
pub const GCN_E_NETADAPTER_TIMEOUT : i32 = -2143616987;
pub const GCN_E_NETADAPTER_NOT_FOUND : i32 = -2143616986;
pub const GCN_E_NETCOMPARTMENT_NOT_FOUND : i32 = -2143616985;
pub const GCN_E_NETINTERFACE_NOT_FOUND : i32 = -2143616984;
pub const GCN_E_DEFAULTNAMESPACE_EXISTS : i32 = -2143616983;
pub const HCN_E_ICS_DISABLED : i32 = -2143616982;
pub const HCN_E_ENDPOINT_NAMESPACE_ALREADY_EXISTS : i32 = -2143616981;
pub const HCN_E_ENTITY_HAS_REFERENCES : i32 = -2143616980;
pub const HCN_E_INVALID_INTERNAL_PORT : i32 = -2143616979;
pub const HCN_E_NAMESPACE_ATTACH_FAILED : i32 = -2143616978;
pub const HCN_E_ADDR_INVALID_OR_RESERVED : i32 = -2143616977;
pub const HCN_E_INVALID_PREFIX : i32 = -2143616976;
pub const HCN_E_OBJECT_USED_AFTER_UNLOAD : i32 = -2143616975;
pub const HCN_E_INVALID_SUBNET : i32 = -2143616974;
pub const HCN_E_INVALID_IP_SUBNET : i32 = -2143616973;
pub const HCN_E_ENDPOINT_NOT_ATTACHED : i32 = -2143616972;
pub const HCN_E_ENDPOINT_NOT_LOCAL : i32 = -2143616971;
pub const HCN_INTERFACEPARAMETERS_ALREADY_APPLIED : i32 = -2143616970;
pub const SDIAG_E_CANCELLED : u32 = 2151416064;
pub const SDIAG_E_SCRIPT : u32 = 2151416065;
pub const SDIAG_E_POWERSHELL : u32 = 2151416066;
pub const SDIAG_E_MANAGEDHOST : u32 = 2151416067;
pub const SDIAG_E_NOVERIFIER : u32 = 2151416068;
pub const SDIAG_S_CANNOTRUN : u32 = 3932421;
pub const SDIAG_E_DISABLED : u32 = 2151416070;
pub const SDIAG_E_TRUST : u32 = 2151416071;
pub const SDIAG_E_CANNOTRUN : u32 = 2151416072;
pub const SDIAG_E_VERSION : u32 = 2151416073;
pub const SDIAG_E_RESOURCE : u32 = 2151416074;
pub const SDIAG_E_ROOTCAUSE : u32 = 2151416075;
pub const WPN_E_CHANNEL_CLOSED : i32 = -2143420160;
pub const WPN_E_CHANNEL_REQUEST_NOT_COMPLETE : i32 = -2143420159;
pub const WPN_E_INVALID_APP : i32 = -2143420158;
pub const WPN_E_OUTSTANDING_CHANNEL_REQUEST : i32 = -2143420157;
pub const WPN_E_DUPLICATE_CHANNEL : i32 = -2143420156;
pub const WPN_E_PLATFORM_UNAVAILABLE : i32 = -2143420155;
pub const WPN_E_NOTIFICATION_POSTED : i32 = -2143420154;
pub const WPN_E_NOTIFICATION_HIDDEN : i32 = -2143420153;
pub const WPN_E_NOTIFICATION_NOT_POSTED : i32 = -2143420152;
pub const WPN_E_CLOUD_DISABLED : i32 = -2143420151;
pub const WPN_E_CLOUD_INCAPABLE : i32 = -2143420144;
pub const WPN_E_CLOUD_AUTH_UNAVAILABLE : i32 = -2143420134;
pub const WPN_E_CLOUD_SERVICE_UNAVAILABLE : i32 = -2143420133;
pub const WPN_E_FAILED_LOCK_SCREEN_UPDATE_INTIALIZATION : i32 = -2143420132;
pub const WPN_E_NOTIFICATION_DISABLED : i32 = -2143420143;
pub const WPN_E_NOTIFICATION_INCAPABLE : i32 = -2143420142;
pub const WPN_E_INTERNET_INCAPABLE : i32 = -2143420141;
pub const WPN_E_NOTIFICATION_TYPE_DISABLED : i32 = -2143420140;
pub const WPN_E_NOTIFICATION_SIZE : i32 = -2143420139;
pub const WPN_E_TAG_SIZE : i32 = -2143420138;
pub const WPN_E_ACCESS_DENIED : i32 = -2143420137;
pub const WPN_E_DUPLICATE_REGISTRATION : i32 = -2143420136;
pub const WPN_E_PUSH_NOTIFICATION_INCAPABLE : i32 = -2143420135;
pub const WPN_E_DEV_ID_SIZE : i32 = -2143420128;
pub const WPN_E_TAG_ALPHANUMERIC : i32 = -2143420118;
pub const WPN_E_INVALID_HTTP_STATUS_CODE : i32 = -2143420117;
pub const WPN_E_OUT_OF_SESSION : i32 = -2143419904;
pub const WPN_E_POWER_SAVE : i32 = -2143419903;
pub const WPN_E_IMAGE_NOT_FOUND_IN_CACHE : i32 = -2143419902;
pub const WPN_E_ALL_URL_NOT_COMPLETED : i32 = -2143419901;
pub const WPN_E_INVALID_CLOUD_IMAGE : i32 = -2143419900;
pub const WPN_E_NOTIFICATION_ID_MATCHED : i32 = -2143419899;
pub const WPN_E_CALLBACK_ALREADY_REGISTERED : i32 = -2143419898;
pub const WPN_E_TOAST_NOTIFICATION_DROPPED : i32 = -2143419897;
pub const WPN_E_STORAGE_LOCKED : i32 = -2143419896;
pub const WPN_E_GROUP_SIZE : i32 = -2143419895;
pub const WPN_E_GROUP_ALPHANUMERIC : i32 = -2143419894;
pub const WPN_E_CLOUD_DISABLED_FOR_APP : i32 = -2143419893;
pub const E_MBN_CONTEXT_NOT_ACTIVATED : i32 = -2141945343;
pub const E_MBN_BAD_SIM : i32 = -2141945342;
pub const E_MBN_DATA_CLASS_NOT_AVAILABLE : i32 = -2141945341;
pub const E_MBN_INVALID_ACCESS_STRING : i32 = -2141945340;
pub const E_MBN_MAX_ACTIVATED_CONTEXTS : i32 = -2141945339;
pub const E_MBN_PACKET_SVC_DETACHED : i32 = -2141945338;
pub const E_MBN_PROVIDER_NOT_VISIBLE : i32 = -2141945337;
pub const E_MBN_RADIO_POWER_OFF : i32 = -2141945336;
pub const E_MBN_SERVICE_NOT_ACTIVATED : i32 = -2141945335;
pub const E_MBN_SIM_NOT_INSERTED : i32 = -2141945334;
pub const E_MBN_VOICE_CALL_IN_PROGRESS : i32 = -2141945333;
pub const E_MBN_INVALID_CACHE : i32 = -2141945332;
pub const E_MBN_NOT_REGISTERED : i32 = -2141945331;
pub const E_MBN_PROVIDERS_NOT_FOUND : i32 = -2141945330;
pub const E_MBN_PIN_NOT_SUPPORTED : i32 = -2141945329;
pub const E_MBN_PIN_REQUIRED : i32 = -2141945328;
pub const E_MBN_PIN_DISABLED : i32 = -2141945327;
pub const E_MBN_FAILURE : i32 = -2141945326;
pub const E_MBN_INVALID_PROFILE : i32 = -2141945320;
pub const E_MBN_DEFAULT_PROFILE_EXIST : i32 = -2141945319;
pub const E_MBN_SMS_ENCODING_NOT_SUPPORTED : i32 = -2141945312;
pub const E_MBN_SMS_FILTER_NOT_SUPPORTED : i32 = -2141945311;
pub const E_MBN_SMS_INVALID_MEMORY_INDEX : i32 = -2141945310;
pub const E_MBN_SMS_LANG_NOT_SUPPORTED : i32 = -2141945309;
pub const E_MBN_SMS_MEMORY_FAILURE : i32 = -2141945308;
pub const E_MBN_SMS_NETWORK_TIMEOUT : i32 = -2141945307;
pub const E_MBN_SMS_UNKNOWN_SMSC_ADDRESS : i32 = -2141945306;
pub const E_MBN_SMS_FORMAT_NOT_SUPPORTED : i32 = -2141945305;
pub const E_MBN_SMS_OPERATION_NOT_ALLOWED : i32 = -2141945304;
pub const E_MBN_SMS_MEMORY_FULL : i32 = -2141945303;
pub const PEER_E_IPV6_NOT_INSTALLED : i32 = -2140995583;
pub const PEER_E_NOT_INITIALIZED : i32 = -2140995582;
pub const PEER_E_CANNOT_START_SERVICE : i32 = -2140995581;
pub const PEER_E_NOT_LICENSED : i32 = -2140995580;
pub const PEER_E_INVALID_GRAPH : i32 = -2140995568;
pub const PEER_E_DBNAME_CHANGED : i32 = -2140995567;
pub const PEER_E_DUPLICATE_GRAPH : i32 = -2140995566;
pub const PEER_E_GRAPH_NOT_READY : i32 = -2140995565;
pub const PEER_E_GRAPH_SHUTTING_DOWN : i32 = -2140995564;
pub const PEER_E_GRAPH_IN_USE : i32 = -2140995563;
pub const PEER_E_INVALID_DATABASE : i32 = -2140995562;
pub const PEER_E_TOO_MANY_ATTRIBUTES : i32 = -2140995561;
pub const PEER_E_CONNECTION_NOT_FOUND : i32 = -2140995325;
pub const PEER_E_CONNECT_SELF : i32 = -2140995322;
pub const PEER_E_ALREADY_LISTENING : i32 = -2140995321;
pub const PEER_E_NODE_NOT_FOUND : i32 = -2140995320;
pub const PEER_E_CONNECTION_FAILED : i32 = -2140995319;
pub const PEER_E_CONNECTION_NOT_AUTHENTICATED : i32 = -2140995318;
pub const PEER_E_CONNECTION_REFUSED : i32 = -2140995317;
pub const PEER_E_CLASSIFIER_TOO_LONG : i32 = -2140995071;
pub const PEER_E_TOO_MANY_IDENTITIES : i32 = -2140995070;
pub const PEER_E_NO_KEY_ACCESS : i32 = -2140995069;
pub const PEER_E_GROUPS_EXIST : i32 = -2140995068;
pub const PEER_E_RECORD_NOT_FOUND : i32 = -2140994815;
pub const PEER_E_DATABASE_ACCESSDENIED : i32 = -2140994814;
pub const PEER_E_DBINITIALIZATION_FAILED : i32 = -2140994813;
pub const PEER_E_MAX_RECORD_SIZE_EXCEEDED : i32 = -2140994812;
pub const PEER_E_DATABASE_ALREADY_PRESENT : i32 = -2140994811;
pub const PEER_E_DATABASE_NOT_PRESENT : i32 = -2140994810;
pub const PEER_E_IDENTITY_NOT_FOUND : i32 = -2140994559;
pub const PEER_E_EVENT_HANDLE_NOT_FOUND : i32 = -2140994303;
pub const PEER_E_INVALID_SEARCH : i32 = -2140994047;
pub const PEER_E_INVALID_ATTRIBUTES : i32 = -2140994046;
pub const PEER_E_INVITATION_NOT_TRUSTED : i32 = -2140993791;
pub const PEER_E_CHAIN_TOO_LONG : i32 = -2140993789;
pub const PEER_E_INVALID_TIME_PERIOD : i32 = -2140993787;
pub const PEER_E_CIRCULAR_CHAIN_DETECTED : i32 = -2140993786;
pub const PEER_E_CERT_STORE_CORRUPTED : i32 = -2140993535;
pub const PEER_E_NO_CLOUD : i32 = -2140991487;
pub const PEER_E_CLOUD_NAME_AMBIGUOUS : i32 = -2140991483;
pub const PEER_E_INVALID_RECORD : i32 = -2140987376;
pub const PEER_E_NOT_AUTHORIZED : i32 = -2140987360;
pub const PEER_E_PASSWORD_DOES_NOT_MEET_POLICY : i32 = -2140987359;
pub const PEER_E_DEFERRED_VALIDATION : i32 = -2140987344;
pub const PEER_E_INVALID_GROUP_PROPERTIES : i32 = -2140987328;
pub const PEER_E_INVALID_PEER_NAME : i32 = -2140987312;
pub const PEER_E_INVALID_CLASSIFIER : i32 = -2140987296;
pub const PEER_E_INVALID_FRIENDLY_NAME : i32 = -2140987280;
pub const PEER_E_INVALID_ROLE_PROPERTY : i32 = -2140987279;
pub const PEER_E_INVALID_CLASSIFIER_PROPERTY : i32 = -2140987278;
pub const PEER_E_INVALID_RECORD_EXPIRATION : i32 = -2140987264;
pub const PEER_E_INVALID_CREDENTIAL_INFO : i32 = -2140987263;
pub const PEER_E_INVALID_CREDENTIAL : i32 = -2140987262;
pub const PEER_E_INVALID_RECORD_SIZE : i32 = -2140987261;
pub const PEER_E_UNSUPPORTED_VERSION : i32 = -2140987248;
pub const PEER_E_GROUP_NOT_READY : i32 = -2140987247;
pub const PEER_E_GROUP_IN_USE : i32 = -2140987246;
pub const PEER_E_INVALID_GROUP : i32 = -2140987245;
pub const PEER_E_NO_MEMBERS_FOUND : i32 = -2140987244;
pub const PEER_E_NO_MEMBER_CONNECTIONS : i32 = -2140987243;
pub const PEER_E_UNABLE_TO_LISTEN : i32 = -2140987242;
pub const PEER_E_IDENTITY_DELETED : i32 = -2140987232;
pub const PEER_E_SERVICE_NOT_AVAILABLE : i32 = -2140987231;
pub const PEER_E_CONTACT_NOT_FOUND : i32 = -2140971007;
pub const PEER_S_GRAPH_DATA_CREATED : i32 = 6488065;
pub const PEER_S_NO_EVENT_DATA : i32 = 6488066;
pub const PEER_S_ALREADY_CONNECTED : i32 = 6496256;
pub const PEER_S_SUBSCRIPTION_EXISTS : i32 = 6512640;
pub const PEER_S_NO_CONNECTIVITY : i32 = 6488069;
pub const PEER_S_ALREADY_A_MEMBER : i32 = 6488070;
pub const PEER_E_CANNOT_CONVERT_PEER_NAME : i32 = -2140979199;
pub const PEER_E_INVALID_PEER_HOST_NAME : i32 = -2140979198;
pub const PEER_E_NO_MORE : i32 = -2140979197;
pub const PEER_E_PNRP_DUPLICATE_PEER_NAME : i32 = -2140979195;
pub const PEER_E_INVITE_CANCELLED : i32 = -2140966912;
pub const PEER_E_INVITE_RESPONSE_NOT_AVAILABLE : i32 = -2140966911;
pub const PEER_E_NOT_SIGNED_IN : i32 = -2140966909;
pub const PEER_E_PRIVACY_DECLINED : i32 = -2140966908;
pub const PEER_E_TIMEOUT : i32 = -2140966907;
pub const PEER_E_INVALID_ADDRESS : i32 = -2140966905;
pub const PEER_E_FW_EXCEPTION_DISABLED : i32 = -2140966904;
pub const PEER_E_FW_BLOCKED_BY_POLICY : i32 = -2140966903;
pub const PEER_E_FW_BLOCKED_BY_SHIELDS_UP : i32 = -2140966902;
pub const PEER_E_FW_DECLINED : i32 = -2140966901;
pub const UI_E_CREATE_FAILED : i32 = -2144731135;
pub const UI_E_SHUTDOWN_CALLED : i32 = -2144731134;
pub const UI_E_ILLEGAL_REENTRANCY : i32 = -2144731133;
pub const UI_E_OBJECT_SEALED : i32 = -2144731132;
pub const UI_E_VALUE_NOT_SET : i32 = -2144731131;
pub const UI_E_VALUE_NOT_DETERMINED : i32 = -2144731130;
pub const UI_E_INVALID_OUTPUT : i32 = -2144731129;
pub const UI_E_BOOLEAN_EXPECTED : i32 = -2144731128;
pub const UI_E_DIFFERENT_OWNER : i32 = -2144731127;
pub const UI_E_AMBIGUOUS_MATCH : i32 = -2144731126;
pub const UI_E_FP_OVERFLOW : i32 = -2144731125;
pub const UI_E_WRONG_THREAD : i32 = -2144731124;
pub const UI_E_STORYBOARD_ACTIVE : i32 = -2144730879;
pub const UI_E_STORYBOARD_NOT_PLAYING : i32 = -2144730878;
pub const UI_E_START_KEYFRAME_AFTER_END : i32 = -2144730877;
pub const UI_E_END_KEYFRAME_NOT_DETERMINED : i32 = -2144730876;
pub const UI_E_LOOPS_OVERLAP : i32 = -2144730875;
pub const UI_E_TRANSITION_ALREADY_USED : i32 = -2144730874;
pub const UI_E_TRANSITION_NOT_IN_STORYBOARD : i32 = -2144730873;
pub const UI_E_TRANSITION_ECLIPSED : i32 = -2144730872;
pub const UI_E_TIME_BEFORE_LAST_UPDATE : i32 = -2144730871;
pub const UI_E_TIMER_CLIENT_ALREADY_CONNECTED : i32 = -2144730870;
pub const UI_E_INVALID_DIMENSION : i32 = -2144730869;
pub const UI_E_PRIMITIVE_OUT_OF_BOUNDS : i32 = -2144730868;
pub const UI_E_WINDOW_CLOSED : i32 = -2144730623;
pub const E_BLUETOOTH_ATT_INVALID_HANDLE : i32 = -2140864511;
pub const E_BLUETOOTH_ATT_READ_NOT_PERMITTED : i32 = -2140864510;
pub const E_BLUETOOTH_ATT_WRITE_NOT_PERMITTED : i32 = -2140864509;
pub const E_BLUETOOTH_ATT_INVALID_PDU : i32 = -2140864508;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_AUTHENTICATION : i32 = -2140864507;
pub const E_BLUETOOTH_ATT_REQUEST_NOT_SUPPORTED : i32 = -2140864506;
pub const E_BLUETOOTH_ATT_INVALID_OFFSET : i32 = -2140864505;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_AUTHORIZATION : i32 = -2140864504;
pub const E_BLUETOOTH_ATT_PREPARE_QUEUE_FULL : i32 = -2140864503;
pub const E_BLUETOOTH_ATT_ATTRIBUTE_NOT_FOUND : i32 = -2140864502;
pub const E_BLUETOOTH_ATT_ATTRIBUTE_NOT_LONG : i32 = -2140864501;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE : i32 = -2140864500;
pub const E_BLUETOOTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH : i32 = -2140864499;
pub const E_BLUETOOTH_ATT_UNLIKELY : i32 = -2140864498;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_ENCRYPTION : i32 = -2140864497;
pub const E_BLUETOOTH_ATT_UNSUPPORTED_GROUP_TYPE : i32 = -2140864496;
pub const E_BLUETOOTH_ATT_INSUFFICIENT_RESOURCES : i32 = -2140864495;
pub const E_BLUETOOTH_ATT_UNKNOWN_ERROR : i32 = -2140860416;
pub const E_AUDIO_ENGINE_NODE_NOT_FOUND : i32 = -2140798975;
pub const E_HDAUDIO_EMPTY_CONNECTION_LIST : i32 = -2140798974;
pub const E_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED : i32 = -2140798973;
pub const E_HDAUDIO_NO_LOGICAL_DEVICES_CREATED : i32 = -2140798972;
pub const E_HDAUDIO_NULL_LINKED_LIST_ENTRY : i32 = -2140798971;
pub const STATEREPOSITORY_E_CONCURRENCY_LOCKING_FAILURE : i32 = -2140733439;
pub const STATEREPOSITORY_E_STATEMENT_INPROGRESS : i32 = -2140733438;
pub const STATEREPOSITORY_E_CONFIGURATION_INVALID : i32 = -2140733437;
pub const STATEREPOSITORY_E_UNKNOWN_SCHEMA_VERSION : i32 = -2140733436;
pub const STATEREPOSITORY_ERROR_DICTIONARY_CORRUPTED : i32 = -2140733435;
pub const STATEREPOSITORY_E_BLOCKED : i32 = -2140733434;
pub const STATEREPOSITORY_E_BUSY_RETRY : i32 = -2140733433;
pub const STATEREPOSITORY_E_BUSY_RECOVERY_RETRY : i32 = -2140733432;
pub const STATEREPOSITORY_E_LOCKED_RETRY : i32 = -2140733431;
pub const STATEREPOSITORY_E_LOCKED_SHAREDCACHE_RETRY : i32 = -2140733430;
pub const STATEREPOSITORY_E_TRANSACTION_REQUIRED : i32 = -2140733429;
pub const STATEREPOSITORY_E_BUSY_TIMEOUT_EXCEEDED : i32 = -2140733428;
pub const STATEREPOSITORY_E_BUSY_RECOVERY_TIMEOUT_EXCEEDED : i32 = -2140733427;
pub const STATEREPOSITORY_E_LOCKED_TIMEOUT_EXCEEDED : i32 = -2140733426;
pub const STATEREPOSITORY_E_LOCKED_SHAREDCACHE_TIMEOUT_EXCEEDED : i32 = -2140733425;
pub const STATEREPOSITORY_E_SERVICE_STOP_IN_PROGRESS : i32 = -2140733424;
pub const STATEREPOSTORY_E_NESTED_TRANSACTION_NOT_SUPPORTED : i32 = -2140733423;
pub const STATEREPOSITORY_ERROR_CACHE_CORRUPTED : i32 = -2140733422;
pub const STATEREPOSITORY_TRANSACTION_CALLER_ID_CHANGED : i32 = 6750227;
pub const STATEREPOSITORY_TRANSACTION_IN_PROGRESS : i32 = 6750228;
pub const ERROR_SPACES_POOL_WAS_DELETED : i32 = 15138817;
pub const ERROR_SPACES_FAULT_DOMAIN_TYPE_INVALID : i32 = -2132344831;
pub const ERROR_SPACES_INTERNAL_ERROR : i32 = -2132344830;
pub const ERROR_SPACES_RESILIENCY_TYPE_INVALID : i32 = -2132344829;
pub const ERROR_SPACES_DRIVE_SECTOR_SIZE_INVALID : i32 = -2132344828;
pub const ERROR_SPACES_DRIVE_REDUNDANCY_INVALID : i32 = -2132344826;
pub const ERROR_SPACES_NUMBER_OF_DATA_COPIES_INVALID : i32 = -2132344825;
pub const ERROR_SPACES_PARITY_LAYOUT_INVALID : i32 = -2132344824;
pub const ERROR_SPACES_INTERLEAVE_LENGTH_INVALID : i32 = -2132344823;
pub const ERROR_SPACES_NUMBER_OF_COLUMNS_INVALID : i32 = -2132344822;
pub const ERROR_SPACES_NOT_ENOUGH_DRIVES : i32 = -2132344821;
pub const ERROR_SPACES_EXTENDED_ERROR : i32 = -2132344820;
pub const ERROR_SPACES_PROVISIONING_TYPE_INVALID : i32 = -2132344819;
pub const ERROR_SPACES_ALLOCATION_SIZE_INVALID : i32 = -2132344818;
pub const ERROR_SPACES_ENCLOSURE_AWARE_INVALID : i32 = -2132344817;
pub const ERROR_SPACES_WRITE_CACHE_SIZE_INVALID : i32 = -2132344816;
pub const ERROR_SPACES_NUMBER_OF_GROUPS_INVALID : i32 = -2132344815;
pub const ERROR_SPACES_DRIVE_OPERATIONAL_STATE_INVALID : i32 = -2132344814;
pub const ERROR_SPACES_ENTRY_INCOMPLETE : i32 = -2132344813;
pub const ERROR_SPACES_ENTRY_INVALID : i32 = -2132344812;
pub const ERROR_VOLSNAP_BOOTFILE_NOT_VALID : i32 = -2138963967;
pub const ERROR_VOLSNAP_ACTIVATION_TIMEOUT : i32 = -2138963966;
pub const ERROR_TIERING_NOT_SUPPORTED_ON_VOLUME : i32 = -2138898431;
pub const ERROR_TIERING_VOLUME_DISMOUNT_IN_PROGRESS : i32 = -2138898430;
pub const ERROR_TIERING_STORAGE_TIER_NOT_FOUND : i32 = -2138898429;
pub const ERROR_TIERING_INVALID_FILE_ID : i32 = -2138898428;
pub const ERROR_TIERING_WRONG_CLUSTER_NODE : i32 = -2138898427;
pub const ERROR_TIERING_ALREADY_PROCESSING : i32 = -2138898426;
pub const ERROR_TIERING_CANNOT_PIN_OBJECT : i32 = -2138898425;
pub const ERROR_TIERING_FILE_IS_NOT_PINNED : i32 = -2138898424;
pub const ERROR_NOT_A_TIERED_VOLUME : i32 = -2138898423;
pub const ERROR_ATTRIBUTE_NOT_PRESENT : i32 = -2138898422;
pub const ERROR_SECCORE_INVALID_COMMAND : i32 = -1058537472;
pub const ERROR_NO_APPLICABLE_APP_LICENSES_FOUND : i32 = -1058406399;
pub const ERROR_CLIP_LICENSE_NOT_FOUND : i32 = -1058406398;
pub const ERROR_CLIP_DEVICE_LICENSE_MISSING : i32 = -1058406397;
pub const ERROR_CLIP_LICENSE_INVALID_SIGNATURE : i32 = -1058406396;
pub const ERROR_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID : i32 = -1058406395;
pub const ERROR_CLIP_LICENSE_EXPIRED : i32 = -1058406394;
pub const ERROR_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE : i32 = -1058406393;
pub const ERROR_CLIP_LICENSE_NOT_SIGNED : i32 = -1058406392;
pub const ERROR_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE : i32 = -1058406391;
pub const ERROR_CLIP_LICENSE_DEVICE_ID_MISMATCH : i32 = -1058406390;
pub const DXGI_STATUS_OCCLUDED : i32 = 142213121;
pub const DXGI_STATUS_CLIPPED : i32 = 142213122;
pub const DXGI_STATUS_NO_REDIRECTION : i32 = 142213124;
pub const DXGI_STATUS_NO_DESKTOP_ACCESS : i32 = 142213125;
pub const DXGI_STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE : i32 = 142213126;
pub const DXGI_STATUS_MODE_CHANGED : i32 = 142213127;
pub const DXGI_STATUS_MODE_CHANGE_IN_PROGRESS : i32 = 142213128;
pub const DXGI_ERROR_INVALID_CALL : i32 = -2005270527;
pub const DXGI_ERROR_NOT_FOUND : i32 = -2005270526;
pub const DXGI_ERROR_MORE_DATA : i32 = -2005270525;
pub const DXGI_ERROR_UNSUPPORTED : i32 = -2005270524;
pub const DXGI_ERROR_DEVICE_REMOVED : i32 = -2005270523;
pub const DXGI_ERROR_DEVICE_HUNG : i32 = -2005270522;
pub const DXGI_ERROR_DEVICE_RESET : i32 = -2005270521;
pub const DXGI_ERROR_WAS_STILL_DRAWING : i32 = -2005270518;
pub const DXGI_ERROR_FRAME_STATISTICS_DISJOINT : i32 = -2005270517;
pub const DXGI_ERROR_GRAPHICS_VIDPN_SOURCE_IN_USE : i32 = -2005270516;
pub const DXGI_ERROR_DRIVER_INTERNAL_ERROR : i32 = -2005270496;
pub const DXGI_ERROR_NONEXCLUSIVE : i32 = -2005270495;
pub const DXGI_ERROR_NOT_CURRENTLY_AVAILABLE : i32 = -2005270494;
pub const DXGI_ERROR_REMOTE_CLIENT_DISCONNECTED : i32 = -2005270493;
pub const DXGI_ERROR_REMOTE_OUTOFMEMORY : i32 = -2005270492;
pub const DXGI_ERROR_ACCESS_LOST : i32 = -2005270490;
pub const DXGI_ERROR_WAIT_TIMEOUT : i32 = -2005270489;
pub const DXGI_ERROR_SESSION_DISCONNECTED : i32 = -2005270488;
pub const DXGI_ERROR_RESTRICT_TO_OUTPUT_STALE : i32 = -2005270487;
pub const DXGI_ERROR_CANNOT_PROTECT_CONTENT : i32 = -2005270486;
pub const DXGI_ERROR_ACCESS_DENIED : i32 = -2005270485;
pub const DXGI_ERROR_NAME_ALREADY_EXISTS : i32 = -2005270484;
pub const DXGI_ERROR_SDK_COMPONENT_MISSING : i32 = -2005270483;
pub const DXGI_ERROR_NOT_CURRENT : i32 = -2005270482;
pub const DXGI_ERROR_HW_PROTECTION_OUTOFMEMORY : i32 = -2005270480;
pub const DXGI_ERROR_DYNAMIC_CODE_POLICY_VIOLATION : i32 = -2005270479;
pub const DXGI_ERROR_NON_COMPOSITED_UI : i32 = -2005270478;
pub const DXCORE_ERROR_EVENT_NOT_UNREGISTERED : i32 = -2004877311;
pub const DXGI_STATUS_UNOCCLUDED : i32 = 142213129;
pub const DXGI_STATUS_DDA_WAS_STILL_DRAWING : i32 = 142213130;
pub const DXGI_ERROR_MODE_CHANGE_IN_PROGRESS : i32 = -2005270491;
pub const DXGI_STATUS_PRESENT_REQUIRED : i32 = 142213167;
pub const DXGI_ERROR_CACHE_CORRUPT : i32 = -2005270477;
pub const DXGI_ERROR_CACHE_FULL : i32 = -2005270476;
pub const DXGI_ERROR_CACHE_HASH_COLLISION : i32 = -2005270475;
pub const DXGI_ERROR_ALREADY_EXISTS : i32 = -2005270474;
pub const DXGI_DDI_ERR_WASSTILLDRAWING : i32 = -2005204991;
pub const DXGI_DDI_ERR_UNSUPPORTED : i32 = -2005204990;
pub const DXGI_DDI_ERR_NONEXCLUSIVE : i32 = -2005204989;
pub const D3D10_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS : i32 = -2005336063;
pub const D3D10_ERROR_FILE_NOT_FOUND : i32 = -2005336062;
pub const D3D11_ERROR_TOO_MANY_UNIQUE_STATE_OBJECTS : i32 = -2005139455;
pub const D3D11_ERROR_FILE_NOT_FOUND : i32 = -2005139454;
pub const D3D11_ERROR_TOO_MANY_UNIQUE_VIEW_OBJECTS : i32 = -2005139453;
pub const D3D11_ERROR_DEFERRED_CONTEXT_MAP_WITHOUT_INITIAL_DISCARD : i32 = -2005139452;
pub const D3D12_ERROR_ADAPTER_NOT_FOUND : i32 = -2005008383;
pub const D3D12_ERROR_DRIVER_VERSION_MISMATCH : i32 = -2005008382;
pub const D2DERR_WRONG_STATE : i32 = -2003238911;
pub const D2DERR_NOT_INITIALIZED : i32 = -2003238910;
pub const D2DERR_UNSUPPORTED_OPERATION : i32 = -2003238909;
pub const D2DERR_SCANNER_FAILED : i32 = -2003238908;
pub const D2DERR_SCREEN_ACCESS_DENIED : i32 = -2003238907;
pub const D2DERR_DISPLAY_STATE_INVALID : i32 = -2003238906;
pub const D2DERR_ZERO_VECTOR : i32 = -2003238905;
pub const D2DERR_INTERNAL_ERROR : i32 = -2003238904;
pub const D2DERR_DISPLAY_FORMAT_NOT_SUPPORTED : i32 = -2003238903;
pub const D2DERR_INVALID_CALL : i32 = -2003238902;
pub const D2DERR_NO_HARDWARE_DEVICE : i32 = -2003238901;
pub const D2DERR_RECREATE_TARGET : i32 = -2003238900;
pub const D2DERR_TOO_MANY_SHADER_ELEMENTS : i32 = -2003238899;
pub const D2DERR_SHADER_COMPILE_FAILED : i32 = -2003238898;
pub const D2DERR_MAX_TEXTURE_SIZE_EXCEEDED : i32 = -2003238897;
pub const D2DERR_UNSUPPORTED_VERSION : i32 = -2003238896;
pub const D2DERR_BAD_NUMBER : i32 = -2003238895;
pub const D2DERR_WRONG_FACTORY : i32 = -2003238894;
pub const D2DERR_LAYER_ALREADY_IN_USE : i32 = -2003238893;
pub const D2DERR_POP_CALL_DID_NOT_MATCH_PUSH : i32 = -2003238892;
pub const D2DERR_WRONG_RESOURCE_DOMAIN : i32 = -2003238891;
pub const D2DERR_PUSH_POP_UNBALANCED : i32 = -2003238890;
pub const D2DERR_RENDER_TARGET_HAS_LAYER_OR_CLIPRECT : i32 = -2003238889;
pub const D2DERR_INCOMPATIBLE_BRUSH_TYPES : i32 = -2003238888;
pub const D2DERR_WIN32_ERROR : i32 = -2003238887;
pub const D2DERR_TARGET_NOT_GDI_COMPATIBLE : i32 = -2003238886;
pub const D2DERR_TEXT_EFFECT_IS_WRONG_TYPE : i32 = -2003238885;
pub const D2DERR_TEXT_RENDERER_NOT_RELEASED : i32 = -2003238884;
pub const D2DERR_EXCEEDS_MAX_BITMAP_SIZE : i32 = -2003238883;
pub const D2DERR_INVALID_GRAPH_CONFIGURATION : i32 = -2003238882;
pub const D2DERR_INVALID_INTERNAL_GRAPH_CONFIGURATION : i32 = -2003238881;
pub const D2DERR_CYCLIC_GRAPH : i32 = -2003238880;
pub const D2DERR_BITMAP_CANNOT_DRAW : i32 = -2003238879;
pub const D2DERR_OUTSTANDING_BITMAP_REFERENCES : i32 = -2003238878;
pub const D2DERR_ORIGINAL_TARGET_NOT_BOUND : i32 = -2003238877;
pub const D2DERR_INVALID_TARGET : i32 = -2003238876;
pub const D2DERR_BITMAP_BOUND_AS_TARGET : i32 = -2003238875;
pub const D2DERR_INSUFFICIENT_DEVICE_CAPABILITIES : i32 = -2003238874;
pub const D2DERR_INTERMEDIATE_TOO_LARGE : i32 = -2003238873;
pub const D2DERR_EFFECT_IS_NOT_REGISTERED : i32 = -2003238872;
pub const D2DERR_INVALID_PROPERTY : i32 = -2003238871;
pub const D2DERR_NO_SUBPROPERTIES : i32 = -2003238870;
pub const D2DERR_PRINT_JOB_CLOSED : i32 = -2003238869;
pub const D2DERR_PRINT_FORMAT_NOT_SUPPORTED : i32 = -2003238868;
pub const D2DERR_TOO_MANY_TRANSFORM_INPUTS : i32 = -2003238867;
pub const D2DERR_INVALID_GLYPH_IMAGE : i32 = -2003238866;
pub const DWRITE_E_FILEFORMAT : i32 = -2003283968;
pub const DWRITE_E_UNEXPECTED : i32 = -2003283967;
pub const DWRITE_E_NOFONT : i32 = -2003283966;
pub const DWRITE_E_FILENOTFOUND : i32 = -2003283965;
pub const DWRITE_E_FILEACCESS : i32 = -2003283964;
pub const DWRITE_E_FONTCOLLECTIONOBSOLETE : i32 = -2003283963;
pub const DWRITE_E_ALREADYREGISTERED : i32 = -2003283962;
pub const DWRITE_E_CACHEFORMAT : i32 = -2003283961;
pub const DWRITE_E_CACHEVERSION : i32 = -2003283960;
pub const DWRITE_E_UNSUPPORTEDOPERATION : i32 = -2003283959;
pub const DWRITE_E_TEXTRENDERERINCOMPATIBLE : i32 = -2003283958;
pub const DWRITE_E_FLOWDIRECTIONCONFLICTS : i32 = -2003283957;
pub const DWRITE_E_NOCOLOR : i32 = -2003283956;
pub const DWRITE_E_REMOTEFONT : i32 = -2003283955;
pub const DWRITE_E_DOWNLOADCANCELLED : i32 = -2003283954;
pub const DWRITE_E_DOWNLOADFAILED : i32 = -2003283953;
pub const DWRITE_E_TOOMANYDOWNLOADS : i32 = -2003283952;
pub const WINCODEC_ERR_WRONGSTATE : i32 = -2003292412;
pub const WINCODEC_ERR_VALUEOUTOFRANGE : i32 = -2003292411;
pub const WINCODEC_ERR_UNKNOWNIMAGEFORMAT : i32 = -2003292409;
pub const WINCODEC_ERR_UNSUPPORTEDVERSION : i32 = -2003292405;
pub const WINCODEC_ERR_NOTINITIALIZED : i32 = -2003292404;
pub const WINCODEC_ERR_ALREADYLOCKED : i32 = -2003292403;
pub const WINCODEC_ERR_PROPERTYNOTFOUND : i32 = -2003292352;
pub const WINCODEC_ERR_PROPERTYNOTSUPPORTED : i32 = -2003292351;
pub const WINCODEC_ERR_PROPERTYSIZE : i32 = -2003292350;
pub const WINCODEC_ERR_CODECPRESENT : i32 = -2003292349;
pub const WINCODEC_ERR_CODECNOTHUMBNAIL : i32 = -2003292348;
pub const WINCODEC_ERR_PALETTEUNAVAILABLE : i32 = -2003292347;
pub const WINCODEC_ERR_CODECTOOMANYSCANLINES : i32 = -2003292346;
pub const WINCODEC_ERR_INTERNALERROR : i32 = -2003292344;
pub const WINCODEC_ERR_SOURCERECTDOESNOTMATCHDIMENSIONS : i32 = -2003292343;
pub const WINCODEC_ERR_COMPONENTNOTFOUND : i32 = -2003292336;
pub const WINCODEC_ERR_IMAGESIZEOUTOFRANGE : i32 = -2003292335;
pub const WINCODEC_ERR_TOOMUCHMETADATA : i32 = -2003292334;
pub const WINCODEC_ERR_BADIMAGE : i32 = -2003292320;
pub const WINCODEC_ERR_BADHEADER : i32 = -2003292319;
pub const WINCODEC_ERR_FRAMEMISSING : i32 = -2003292318;
pub const WINCODEC_ERR_BADMETADATAHEADER : i32 = -2003292317;
pub const WINCODEC_ERR_BADSTREAMDATA : i32 = -2003292304;
pub const WINCODEC_ERR_STREAMWRITE : i32 = -2003292303;
pub const WINCODEC_ERR_STREAMREAD : i32 = -2003292302;
pub const WINCODEC_ERR_STREAMNOTAVAILABLE : i32 = -2003292301;
pub const WINCODEC_ERR_UNSUPPORTEDPIXELFORMAT : i32 = -2003292288;
pub const WINCODEC_ERR_UNSUPPORTEDOPERATION : i32 = -2003292287;
pub const WINCODEC_ERR_INVALIDREGISTRATION : i32 = -2003292278;
pub const WINCODEC_ERR_COMPONENTINITIALIZEFAILURE : i32 = -2003292277;
pub const WINCODEC_ERR_INSUFFICIENTBUFFER : i32 = -2003292276;
pub const WINCODEC_ERR_DUPLICATEMETADATAPRESENT : i32 = -2003292275;
pub const WINCODEC_ERR_PROPERTYUNEXPECTEDTYPE : i32 = -2003292274;
pub const WINCODEC_ERR_UNEXPECTEDSIZE : i32 = -2003292273;
pub const WINCODEC_ERR_INVALIDQUERYREQUEST : i32 = -2003292272;
pub const WINCODEC_ERR_UNEXPECTEDMETADATATYPE : i32 = -2003292271;
pub const WINCODEC_ERR_REQUESTONLYVALIDATMETADATAROOT : i32 = -2003292270;
pub const WINCODEC_ERR_INVALIDQUERYCHARACTER : i32 = -2003292269;
pub const WINCODEC_ERR_WIN32ERROR : i32 = -2003292268;
pub const WINCODEC_ERR_INVALIDPROGRESSIVELEVEL : i32 = -2003292267;
pub const WINCODEC_ERR_INVALIDJPEGSCANINDEX : i32 = -2003292266;
pub const MILERR_OBJECTBUSY : i32 = -2003304447;
pub const MILERR_INSUFFICIENTBUFFER : i32 = -2003304446;
pub const MILERR_WIN32ERROR : i32 = -2003304445;
pub const MILERR_SCANNER_FAILED : i32 = -2003304444;
pub const MILERR_SCREENACCESSDENIED : i32 = -2003304443;
pub const MILERR_DISPLAYSTATEINVALID : i32 = -2003304442;
pub const MILERR_NONINVERTIBLEMATRIX : i32 = -2003304441;
pub const MILERR_ZEROVECTOR : i32 = -2003304440;
pub const MILERR_TERMINATED : i32 = -2003304439;
pub const MILERR_BADNUMBER : i32 = -2003304438;
pub const MILERR_INTERNALERROR : i32 = -2003304320;
pub const MILERR_DISPLAYFORMATNOTSUPPORTED : i32 = -2003304316;
pub const MILERR_INVALIDCALL : i32 = -2003304315;
pub const MILERR_ALREADYLOCKED : i32 = -2003304314;
pub const MILERR_NOTLOCKED : i32 = -2003304313;
pub const MILERR_DEVICECANNOTRENDERTEXT : i32 = -2003304312;
pub const MILERR_GLYPHBITMAPMISSED : i32 = -2003304311;
pub const MILERR_MALFORMEDGLYPHCACHE : i32 = -2003304310;
pub const MILERR_GENERIC_IGNORE : i32 = -2003304309;
pub const MILERR_MALFORMED_GUIDELINE_DATA : i32 = -2003304308;
pub const MILERR_NO_HARDWARE_DEVICE : i32 = -2003304307;
pub const MILERR_NEED_RECREATE_AND_PRESENT : i32 = -2003304306;
pub const MILERR_ALREADY_INITIALIZED : i32 = -2003304305;
pub const MILERR_MISMATCHED_SIZE : i32 = -2003304304;
pub const MILERR_NO_REDIRECTION_SURFACE_AVAILABLE : i32 = -2003304303;
pub const MILERR_REMOTING_NOT_SUPPORTED : i32 = -2003304302;
pub const MILERR_QUEUED_PRESENT_NOT_SUPPORTED : i32 = -2003304301;
pub const MILERR_NOT_QUEUING_PRESENTS : i32 = -2003304300;
pub const MILERR_NO_REDIRECTION_SURFACE_RETRY_LATER : i32 = -2003304299;
pub const MILERR_TOOMANYSHADERELEMNTS : i32 = -2003304298;
pub const MILERR_MROW_READLOCK_FAILED : i32 = -2003304297;
pub const MILERR_MROW_UPDATE_FAILED : i32 = -2003304296;
pub const MILERR_SHADER_COMPILE_FAILED : i32 = -2003304295;
pub const MILERR_MAX_TEXTURE_SIZE_EXCEEDED : i32 = -2003304294;
pub const MILERR_QPC_TIME_WENT_BACKWARD : i32 = -2003304293;
pub const MILERR_DXGI_ENUMERATION_OUT_OF_SYNC : i32 = -2003304291;
pub const MILERR_ADAPTER_NOT_FOUND : i32 = -2003304290;
pub const MILERR_COLORSPACE_NOT_SUPPORTED : i32 = -2003304289;
pub const MILERR_PREFILTER_NOT_SUPPORTED : i32 = -2003304288;
pub const MILERR_DISPLAYID_ACCESS_DENIED : i32 = -2003304287;
pub const UCEERR_INVALIDPACKETHEADER : i32 = -2003303424;
pub const UCEERR_UNKNOWNPACKET : i32 = -2003303423;
pub const UCEERR_ILLEGALPACKET : i32 = -2003303422;
pub const UCEERR_MALFORMEDPACKET : i32 = -2003303421;
pub const UCEERR_ILLEGALHANDLE : i32 = -2003303420;
pub const UCEERR_HANDLELOOKUPFAILED : i32 = -2003303419;
pub const UCEERR_RENDERTHREADFAILURE : i32 = -2003303418;
pub const UCEERR_CTXSTACKFRSTTARGETNULL : i32 = -2003303417;
pub const UCEERR_CONNECTIONIDLOOKUPFAILED : i32 = -2003303416;
pub const UCEERR_BLOCKSFULL : i32 = -2003303415;
pub const UCEERR_MEMORYFAILURE : i32 = -2003303414;
pub const UCEERR_PACKETRECORDOUTOFRANGE : i32 = -2003303413;
pub const UCEERR_ILLEGALRECORDTYPE : i32 = -2003303412;
pub const UCEERR_OUTOFHANDLES : i32 = -2003303411;
pub const UCEERR_UNCHANGABLE_UPDATE_ATTEMPTED : i32 = -2003303410;
pub const UCEERR_NO_MULTIPLE_WORKER_THREADS : i32 = -2003303409;
pub const UCEERR_REMOTINGNOTSUPPORTED : i32 = -2003303408;
pub const UCEERR_MISSINGENDCOMMAND : i32 = -2003303407;
pub const UCEERR_MISSINGBEGINCOMMAND : i32 = -2003303406;
pub const UCEERR_CHANNELSYNCTIMEDOUT : i32 = -2003303405;
pub const UCEERR_CHANNELSYNCABANDONED : i32 = -2003303404;
pub const UCEERR_UNSUPPORTEDTRANSPORTVERSION : i32 = -2003303403;
pub const UCEERR_TRANSPORTUNAVAILABLE : i32 = -2003303402;
pub const UCEERR_FEEDBACK_UNSUPPORTED : i32 = -2003303401;
pub const UCEERR_COMMANDTRANSPORTDENIED : i32 = -2003303400;
pub const UCEERR_GRAPHICSSTREAMUNAVAILABLE : i32 = -2003303399;
pub const UCEERR_GRAPHICSSTREAMALREADYOPEN : i32 = -2003303392;
pub const UCEERR_TRANSPORTDISCONNECTED : i32 = -2003303391;
pub const UCEERR_TRANSPORTOVERLOADED : i32 = -2003303390;
pub const UCEERR_PARTITION_ZOMBIED : i32 = -2003303389;
pub const MILAVERR_NOCLOCK : i32 = -2003303168;
pub const MILAVERR_NOMEDIATYPE : i32 = -2003303167;
pub const MILAVERR_NOVIDEOMIXER : i32 = -2003303166;
pub const MILAVERR_NOVIDEOPRESENTER : i32 = -2003303165;
pub const MILAVERR_NOREADYFRAMES : i32 = -2003303164;
pub const MILAVERR_MODULENOTLOADED : i32 = -2003303163;
pub const MILAVERR_WMPFACTORYNOTREGISTERED : i32 = -2003303162;
pub const MILAVERR_INVALIDWMPVERSION : i32 = -2003303161;
pub const MILAVERR_INSUFFICIENTVIDEORESOURCES : i32 = -2003303160;
pub const MILAVERR_VIDEOACCELERATIONNOTAVAILABLE : i32 = -2003303159;
pub const MILAVERR_REQUESTEDTEXTURETOOBIG : i32 = -2003303158;
pub const MILAVERR_SEEKFAILED : i32 = -2003303157;
pub const MILAVERR_UNEXPECTEDWMPFAILURE : i32 = -2003303156;
pub const MILAVERR_MEDIAPLAYERCLOSED : i32 = -2003303155;
pub const MILAVERR_UNKNOWNHARDWAREERROR : i32 = -2003303154;
pub const MILEFFECTSERR_UNKNOWNPROPERTY : i32 = -2003302898;
pub const MILEFFECTSERR_EFFECTNOTPARTOFGROUP : i32 = -2003302897;
pub const MILEFFECTSERR_NOINPUTSOURCEATTACHED : i32 = -2003302896;
pub const MILEFFECTSERR_CONNECTORNOTCONNECTED : i32 = -2003302895;
pub const MILEFFECTSERR_CONNECTORNOTASSOCIATEDWITHEFFECT : i32 = -2003302894;
pub const MILEFFECTSERR_RESERVED : i32 = -2003302893;
pub const MILEFFECTSERR_CYCLEDETECTED : i32 = -2003302892;
pub const MILEFFECTSERR_EFFECTINMORETHANONEGRAPH : i32 = -2003302891;
pub const MILEFFECTSERR_EFFECTALREADYINAGRAPH : i32 = -2003302890;
pub const MILEFFECTSERR_EFFECTHASNOCHILDREN : i32 = -2003302889;
pub const MILEFFECTSERR_ALREADYATTACHEDTOLISTENER : i32 = -2003302888;
pub const MILEFFECTSERR_NOTAFFINETRANSFORM : i32 = -2003302887;
pub const MILEFFECTSERR_EMPTYBOUNDS : i32 = -2003302886;
pub const MILEFFECTSERR_OUTPUTSIZETOOLARGE : i32 = -2003302885;
pub const DWMERR_STATE_TRANSITION_FAILED : i32 = -2003302656;
pub const DWMERR_THEME_FAILED : i32 = -2003302655;
pub const DWMERR_CATASTROPHIC_FAILURE : i32 = -2003302654;
pub const DCOMPOSITION_ERROR_WINDOW_ALREADY_COMPOSED : i32 = -2003302400;
pub const DCOMPOSITION_ERROR_SURFACE_BEING_RENDERED : i32 = -2003302399;
pub const DCOMPOSITION_ERROR_SURFACE_NOT_BEING_RENDERED : i32 = -2003302398;
pub const ONL_E_INVALID_AUTHENTICATION_TARGET : i32 = -2138701823;
pub const ONL_E_ACCESS_DENIED_BY_TOU : i32 = -2138701822;
pub const ONL_E_INVALID_APPLICATION : i32 = -2138701821;
pub const ONL_E_PASSWORD_UPDATE_REQUIRED : i32 = -2138701820;
pub const ONL_E_ACCOUNT_UPDATE_REQUIRED : i32 = -2138701819;
pub const ONL_E_FORCESIGNIN : i32 = -2138701818;
pub const ONL_E_ACCOUNT_LOCKED : i32 = -2138701817;
pub const ONL_E_PARENTAL_CONSENT_REQUIRED : i32 = -2138701816;
pub const ONL_E_EMAIL_VERIFICATION_REQUIRED : i32 = -2138701815;
pub const ONL_E_ACCOUNT_SUSPENDED_COMPROIMISE : i32 = -2138701814;
pub const ONL_E_ACCOUNT_SUSPENDED_ABUSE : i32 = -2138701813;
pub const ONL_E_ACTION_REQUIRED : i32 = -2138701812;
pub const ONL_CONNECTION_COUNT_LIMIT : i32 = -2138701811;
pub const ONL_E_CONNECTED_ACCOUNT_CAN_NOT_SIGNOUT : i32 = -2138701810;
pub const ONL_E_USER_AUTHENTICATION_REQUIRED : i32 = -2138701809;
pub const ONL_E_REQUEST_THROTTLED : i32 = -2138701808;
pub const FA_E_MAX_PERSISTED_ITEMS_REACHED : i32 = -2144927200;
pub const FA_E_HOMEGROUP_NOT_AVAILABLE : i32 = -2144927198;
pub const E_MONITOR_RESOLUTION_TOO_LOW : i32 = -2144927152;
pub const E_ELEVATED_ACTIVATION_NOT_SUPPORTED : i32 = -2144927151;
pub const E_UAC_DISABLED : i32 = -2144927150;
pub const E_FULL_ADMIN_NOT_SUPPORTED : i32 = -2144927149;
pub const E_APPLICATION_NOT_REGISTERED : i32 = -2144927148;
pub const E_MULTIPLE_EXTENSIONS_FOR_APPLICATION : i32 = -2144927147;
pub const E_MULTIPLE_PACKAGES_FOR_FAMILY : i32 = -2144927146;
pub const E_APPLICATION_MANAGER_NOT_RUNNING : i32 = -2144927145;
pub const S_STORE_LAUNCHED_FOR_REMEDIATION : i32 = 2556504;
pub const S_APPLICATION_ACTIVATION_ERROR_HANDLED_BY_DIALOG : i32 = 2556505;
pub const E_APPLICATION_ACTIVATION_TIMED_OUT : i32 = -2144927142;
pub const E_APPLICATION_ACTIVATION_EXEC_FAILURE : i32 = -2144927141;
pub const E_APPLICATION_TEMPORARY_LICENSE_ERROR : i32 = -2144927140;
pub const E_APPLICATION_TRIAL_LICENSE_EXPIRED : i32 = -2144927139;
pub const E_SKYDRIVE_ROOT_TARGET_FILE_SYSTEM_NOT_SUPPORTED : i32 = -2144927136;
pub const E_SKYDRIVE_ROOT_TARGET_OVERLAP : i32 = -2144927135;
pub const E_SKYDRIVE_ROOT_TARGET_CANNOT_INDEX : i32 = -2144927134;
pub const E_SKYDRIVE_FILE_NOT_UPLOADED : i32 = -2144927133;
pub const E_SKYDRIVE_UPDATE_AVAILABILITY_FAIL : i32 = -2144927132;
pub const E_SKYDRIVE_ROOT_TARGET_VOLUME_ROOT_NOT_SUPPORTED : i32 = -2144927131;
pub const E_SYNCENGINE_FILE_SIZE_OVER_LIMIT : i32 = -2013089791;
pub const E_SYNCENGINE_FILE_SIZE_EXCEEDS_REMAINING_QUOTA : i32 = -2013089790;
pub const E_SYNCENGINE_UNSUPPORTED_FILE_NAME : i32 = -2013089789;
pub const E_SYNCENGINE_FOLDER_ITEM_COUNT_LIMIT_EXCEEDED : i32 = -2013089788;
pub const E_SYNCENGINE_FILE_SYNC_PARTNER_ERROR : i32 = -2013089787;
pub const E_SYNCENGINE_SYNC_PAUSED_BY_SERVICE : i32 = -2013089786;
pub const E_SYNCENGINE_FILE_IDENTIFIER_UNKNOWN : i32 = -2013085694;
pub const E_SYNCENGINE_SERVICE_AUTHENTICATION_FAILED : i32 = -2013085693;
pub const E_SYNCENGINE_UNKNOWN_SERVICE_ERROR : i32 = -2013085692;
pub const E_SYNCENGINE_SERVICE_RETURNED_UNEXPECTED_SIZE : i32 = -2013085691;
pub const E_SYNCENGINE_REQUEST_BLOCKED_BY_SERVICE : i32 = -2013085690;
pub const E_SYNCENGINE_REQUEST_BLOCKED_DUE_TO_CLIENT_ERROR : i32 = -2013085689;
pub const E_SYNCENGINE_FOLDER_INACCESSIBLE : i32 = -2013081599;
pub const E_SYNCENGINE_UNSUPPORTED_FOLDER_NAME : i32 = -2013081598;
pub const E_SYNCENGINE_UNSUPPORTED_MARKET : i32 = -2013081597;
pub const E_SYNCENGINE_PATH_LENGTH_LIMIT_EXCEEDED : i32 = -2013081596;
pub const E_SYNCENGINE_REMOTE_PATH_LENGTH_LIMIT_EXCEEDED : i32 = -2013081595;
pub const E_SYNCENGINE_CLIENT_UPDATE_NEEDED : i32 = -2013081594;
pub const E_SYNCENGINE_PROXY_AUTHENTICATION_REQUIRED : i32 = -2013081593;
pub const E_SYNCENGINE_STORAGE_SERVICE_PROVISIONING_FAILED : i32 = -2013081592;
pub const E_SYNCENGINE_UNSUPPORTED_REPARSE_POINT : i32 = -2013081591;
pub const E_SYNCENGINE_STORAGE_SERVICE_BLOCKED : i32 = -2013081590;
pub const E_SYNCENGINE_FOLDER_IN_REDIRECTION : i32 = -2013081589;
pub const EAS_E_POLICY_NOT_MANAGED_BY_OS : i32 = -2141913087;
pub const EAS_E_POLICY_COMPLIANT_WITH_ACTIONS : i32 = -2141913086;
pub const EAS_E_REQUESTED_POLICY_NOT_ENFORCEABLE : i32 = -2141913085;
pub const EAS_E_CURRENT_USER_HAS_BLANK_PASSWORD : i32 = -2141913084;
pub const EAS_E_REQUESTED_POLICY_PASSWORD_EXPIRATION_INCOMPATIBLE : i32 = -2141913083;
pub const EAS_E_USER_CANNOT_CHANGE_PASSWORD : i32 = -2141913082;
pub const EAS_E_ADMINS_HAVE_BLANK_PASSWORD : i32 = -2141913081;
pub const EAS_E_ADMINS_CANNOT_CHANGE_PASSWORD : i32 = -2141913080;
pub const EAS_E_LOCAL_CONTROLLED_USERS_CANNOT_CHANGE_PASSWORD : i32 = -2141913079;
pub const EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CONNECTED_ADMINS : i32 = -2141913078;
pub const EAS_E_CONNECTED_ADMINS_NEED_TO_CHANGE_PASSWORD : i32 = -2141913077;
pub const EAS_E_PASSWORD_POLICY_NOT_ENFORCEABLE_FOR_CURRENT_CONNECTED_USER : i32 = -2141913076;
pub const EAS_E_CURRENT_CONNECTED_USER_NEED_TO_CHANGE_PASSWORD : i32 = -2141913075;
pub const WEB_E_UNSUPPORTED_FORMAT : i32 = -2089484287;
pub const WEB_E_INVALID_XML : i32 = -2089484286;
pub const WEB_E_MISSING_REQUIRED_ELEMENT : i32 = -2089484285;
pub const WEB_E_MISSING_REQUIRED_ATTRIBUTE : i32 = -2089484284;
pub const WEB_E_UNEXPECTED_CONTENT : i32 = -2089484283;
pub const WEB_E_RESOURCE_TOO_LARGE : i32 = -2089484282;
pub const WEB_E_INVALID_JSON_STRING : i32 = -2089484281;
pub const WEB_E_INVALID_JSON_NUMBER : i32 = -2089484280;
pub const WEB_E_JSON_VALUE_NOT_FOUND : i32 = -2089484279;
pub const HTTP_E_STATUS_UNEXPECTED : i32 = -2145845247;
pub const HTTP_E_STATUS_UNEXPECTED_REDIRECTION : i32 = -2145845245;
pub const HTTP_E_STATUS_UNEXPECTED_CLIENT_ERROR : i32 = -2145845244;
pub const HTTP_E_STATUS_UNEXPECTED_SERVER_ERROR : i32 = -2145845243;
pub const HTTP_E_STATUS_AMBIGUOUS : i32 = -2145844948;
pub const HTTP_E_STATUS_MOVED : i32 = -2145844947;
pub const HTTP_E_STATUS_REDIRECT : i32 = -2145844946;
pub const HTTP_E_STATUS_REDIRECT_METHOD : i32 = -2145844945;
pub const HTTP_E_STATUS_NOT_MODIFIED : i32 = -2145844944;
pub const HTTP_E_STATUS_USE_PROXY : i32 = -2145844943;
pub const HTTP_E_STATUS_REDIRECT_KEEP_VERB : i32 = -2145844941;
pub const HTTP_E_STATUS_BAD_REQUEST : i32 = -2145844848;
pub const HTTP_E_STATUS_DENIED : i32 = -2145844847;
pub const HTTP_E_STATUS_PAYMENT_REQ : i32 = -2145844846;
pub const HTTP_E_STATUS_FORBIDDEN : i32 = -2145844845;
pub const HTTP_E_STATUS_NOT_FOUND : i32 = -2145844844;
pub const HTTP_E_STATUS_BAD_METHOD : i32 = -2145844843;
pub const HTTP_E_STATUS_NONE_ACCEPTABLE : i32 = -2145844842;
pub const HTTP_E_STATUS_PROXY_AUTH_REQ : i32 = -2145844841;
pub const HTTP_E_STATUS_REQUEST_TIMEOUT : i32 = -2145844840;
pub const HTTP_E_STATUS_CONFLICT : i32 = -2145844839;
pub const HTTP_E_STATUS_GONE : i32 = -2145844838;
pub const HTTP_E_STATUS_LENGTH_REQUIRED : i32 = -2145844837;
pub const HTTP_E_STATUS_PRECOND_FAILED : i32 = -2145844836;
pub const HTTP_E_STATUS_REQUEST_TOO_LARGE : i32 = -2145844835;
pub const HTTP_E_STATUS_URI_TOO_LONG : i32 = -2145844834;
pub const HTTP_E_STATUS_UNSUPPORTED_MEDIA : i32 = -2145844833;
pub const HTTP_E_STATUS_RANGE_NOT_SATISFIABLE : i32 = -2145844832;
pub const HTTP_E_STATUS_EXPECTATION_FAILED : i32 = -2145844831;
pub const HTTP_E_STATUS_SERVER_ERROR : i32 = -2145844748;
pub const HTTP_E_STATUS_NOT_SUPPORTED : i32 = -2145844747;
pub const HTTP_E_STATUS_BAD_GATEWAY : i32 = -2145844746;
pub const HTTP_E_STATUS_SERVICE_UNAVAIL : i32 = -2145844745;
pub const HTTP_E_STATUS_GATEWAY_TIMEOUT : i32 = -2145844744;
pub const HTTP_E_STATUS_VERSION_NOT_SUP : i32 = -2145844743;
pub const E_INVALID_PROTOCOL_OPERATION : i32 = -2089418751;
pub const E_INVALID_PROTOCOL_FORMAT : i32 = -2089418750;
pub const E_PROTOCOL_EXTENSIONS_NOT_SUPPORTED : i32 = -2089418749;
pub const E_SUBPROTOCOL_NOT_SUPPORTED : i32 = -2089418748;
pub const E_PROTOCOL_VERSION_NOT_SUPPORTED : i32 = -2089418747;
pub const INPUT_E_OUT_OF_ORDER : i32 = -2143289344;
pub const INPUT_E_REENTRANCY : i32 = -2143289343;
pub const INPUT_E_MULTIMODAL : i32 = -2143289342;
pub const INPUT_E_PACKET : i32 = -2143289341;
pub const INPUT_E_FRAME : i32 = -2143289340;
pub const INPUT_E_HISTORY : i32 = -2143289339;
pub const INPUT_E_DEVICE_INFO : i32 = -2143289338;
pub const INPUT_E_TRANSFORM : i32 = -2143289337;
pub const INPUT_E_DEVICE_PROPERTY : i32 = -2143289336;
pub const INET_E_INVALID_URL : i32 = -2146697214;
pub const INET_E_NO_SESSION : i32 = -2146697213;
pub const INET_E_CANNOT_CONNECT : i32 = -2146697212;
pub const INET_E_RESOURCE_NOT_FOUND : i32 = -2146697211;
pub const INET_E_OBJECT_NOT_FOUND : i32 = -2146697210;
pub const INET_E_DATA_NOT_AVAILABLE : i32 = -2146697209;
pub const INET_E_DOWNLOAD_FAILURE : i32 = -2146697208;
pub const INET_E_AUTHENTICATION_REQUIRED : i32 = -2146697207;
pub const INET_E_NO_VALID_MEDIA : i32 = -2146697206;
pub const INET_E_CONNECTION_TIMEOUT : i32 = -2146697205;
pub const INET_E_INVALID_REQUEST : i32 = -2146697204;
pub const INET_E_UNKNOWN_PROTOCOL : i32 = -2146697203;
pub const INET_E_SECURITY_PROBLEM : i32 = -2146697202;
pub const INET_E_CANNOT_LOAD_DATA : i32 = -2146697201;
pub const INET_E_CANNOT_INSTANTIATE_OBJECT : i32 = -2146697200;
pub const INET_E_INVALID_CERTIFICATE : i32 = -2146697191;
pub const INET_E_REDIRECT_FAILED : i32 = -2146697196;
pub const INET_E_REDIRECT_TO_DIR : i32 = -2146697195;
pub const ERROR_DBG_CREATE_PROCESS_FAILURE_LOCKDOWN : i32 = -2135949311;
pub const ERROR_DBG_ATTACH_PROCESS_FAILURE_LOCKDOWN : i32 = -2135949310;
pub const ERROR_DBG_CONNECT_SERVER_FAILURE_LOCKDOWN : i32 = -2135949309;
pub const ERROR_DBG_START_SERVER_FAILURE_LOCKDOWN : i32 = -2135949308;
pub const ERROR_IO_PREEMPTED : i32 = -1996423167;
pub const JSCRIPT_E_CANTEXECUTE : i32 = -1996357631;
pub const WEP_E_NOT_PROVISIONED_ON_ALL_VOLUMES : i32 = -2013200383;
pub const WEP_E_FIXED_DATA_NOT_SUPPORTED : i32 = -2013200382;
pub const WEP_E_HARDWARE_NOT_COMPLIANT : i32 = -2013200381;
pub const WEP_E_LOCK_NOT_CONFIGURED : i32 = -2013200380;
pub const WEP_E_PROTECTION_SUSPENDED : i32 = -2013200379;
pub const WEP_E_NO_LICENSE : i32 = -2013200378;
pub const WEP_E_OS_NOT_PROTECTED : i32 = -2013200377;
pub const WEP_E_UNEXPECTED_FAIL : i32 = -2013200376;
pub const WEP_E_BUFFER_TOO_LARGE : i32 = -2013200375;
pub const ERROR_SVHDX_ERROR_STORED : i32 = -1067712512;
pub const ERROR_SVHDX_ERROR_NOT_AVAILABLE : i32 = -1067647232;
pub const ERROR_SVHDX_UNIT_ATTENTION_AVAILABLE : i32 = -1067647231;
pub const ERROR_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED : i32 = -1067647230;
pub const ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED : i32 = -1067647229;
pub const ERROR_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED : i32 = -1067647228;
pub const ERROR_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED : i32 = -1067647227;
pub const ERROR_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED : i32 = -1067647226;
pub const ERROR_SVHDX_RESERVATION_CONFLICT : i32 = -1067647225;
pub const ERROR_SVHDX_WRONG_FILE_TYPE : i32 = -1067647224;
pub const ERROR_SVHDX_VERSION_MISMATCH : i32 = -1067647223;
pub const ERROR_VHD_SHARED : i32 = -1067647222;
pub const ERROR_SVHDX_NO_INITIATOR : i32 = -1067647221;
pub const ERROR_VHDSET_BACKING_STORAGE_NOT_FOUND : i32 = -1067647220;
pub const ERROR_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP : i32 = -1067646976;
pub const ERROR_SMB_BAD_CLUSTER_DIALECT : i32 = -1067646975;
pub const WININET_E_OUT_OF_HANDLES : i32 = -2147012895;
pub const WININET_E_TIMEOUT : i32 = -2147012894;
pub const WININET_E_EXTENDED_ERROR : i32 = -2147012893;
pub const WININET_E_INTERNAL_ERROR : i32 = -2147012892;
pub const WININET_E_INVALID_URL : i32 = -2147012891;
pub const WININET_E_UNRECOGNIZED_SCHEME : i32 = -2147012890;
pub const WININET_E_NAME_NOT_RESOLVED : i32 = -2147012889;
pub const WININET_E_PROTOCOL_NOT_FOUND : i32 = -2147012888;
pub const WININET_E_INVALID_OPTION : i32 = -2147012887;
pub const WININET_E_BAD_OPTION_LENGTH : i32 = -2147012886;
pub const WININET_E_OPTION_NOT_SETTABLE : i32 = -2147012885;
pub const WININET_E_SHUTDOWN : i32 = -2147012884;
pub const WININET_E_INCORRECT_USER_NAME : i32 = -2147012883;
pub const WININET_E_INCORRECT_PASSWORD : i32 = -2147012882;
pub const WININET_E_LOGIN_FAILURE : i32 = -2147012881;
pub const WININET_E_INVALID_OPERATION : i32 = -2147012880;
pub const WININET_E_OPERATION_CANCELLED : i32 = -2147012879;
pub const WININET_E_INCORRECT_HANDLE_TYPE : i32 = -2147012878;
pub const WININET_E_INCORRECT_HANDLE_STATE : i32 = -2147012877;
pub const WININET_E_NOT_PROXY_REQUEST : i32 = -2147012876;
pub const WININET_E_REGISTRY_VALUE_NOT_FOUND : i32 = -2147012875;
pub const WININET_E_BAD_REGISTRY_PARAMETER : i32 = -2147012874;
pub const WININET_E_NO_DIRECT_ACCESS : i32 = -2147012873;
pub const WININET_E_NO_CONTEXT : i32 = -2147012872;
pub const WININET_E_NO_CALLBACK : i32 = -2147012871;
pub const WININET_E_REQUEST_PENDING : i32 = -2147012870;
pub const WININET_E_INCORRECT_FORMAT : i32 = -2147012869;
pub const WININET_E_ITEM_NOT_FOUND : i32 = -2147012868;
pub const WININET_E_CANNOT_CONNECT : i32 = -2147012867;
pub const WININET_E_CONNECTION_ABORTED : i32 = -2147012866;
pub const WININET_E_CONNECTION_RESET : i32 = -2147012865;
pub const WININET_E_FORCE_RETRY : i32 = -2147012864;
pub const WININET_E_INVALID_PROXY_REQUEST : i32 = -2147012863;
pub const WININET_E_NEED_UI : i32 = -2147012862;
pub const WININET_E_HANDLE_EXISTS : i32 = -2147012860;
pub const WININET_E_SEC_CERT_DATE_INVALID : i32 = -2147012859;
pub const WININET_E_SEC_CERT_CN_INVALID : i32 = -2147012858;
pub const WININET_E_HTTP_TO_HTTPS_ON_REDIR : i32 = -2147012857;
pub const WININET_E_HTTPS_TO_HTTP_ON_REDIR : i32 = -2147012856;
pub const WININET_E_MIXED_SECURITY : i32 = -2147012855;
pub const WININET_E_CHG_POST_IS_NON_SECURE : i32 = -2147012854;
pub const WININET_E_POST_IS_NON_SECURE : i32 = -2147012853;
pub const WININET_E_CLIENT_AUTH_CERT_NEEDED : i32 = -2147012852;
pub const WININET_E_INVALID_CA : i32 = -2147012851;
pub const WININET_E_CLIENT_AUTH_NOT_SETUP : i32 = -2147012850;
pub const WININET_E_ASYNC_THREAD_FAILED : i32 = -2147012849;
pub const WININET_E_REDIRECT_SCHEME_CHANGE : i32 = -2147012848;
pub const WININET_E_DIALOG_PENDING : i32 = -2147012847;
pub const WININET_E_RETRY_DIALOG : i32 = -2147012846;
pub const WININET_E_NO_NEW_CONTAINERS : i32 = -2147012845;
pub const WININET_E_HTTPS_HTTP_SUBMIT_REDIR : i32 = -2147012844;
pub const WININET_E_SEC_CERT_ERRORS : i32 = -2147012841;
pub const WININET_E_SEC_CERT_REV_FAILED : i32 = -2147012839;
pub const WININET_E_HEADER_NOT_FOUND : i32 = -2147012746;
pub const WININET_E_DOWNLEVEL_SERVER : i32 = -2147012745;
pub const WININET_E_INVALID_SERVER_RESPONSE : i32 = -2147012744;
pub const WININET_E_INVALID_HEADER : i32 = -2147012743;
pub const WININET_E_INVALID_QUERY_REQUEST : i32 = -2147012742;
pub const WININET_E_HEADER_ALREADY_EXISTS : i32 = -2147012741;
pub const WININET_E_REDIRECT_FAILED : i32 = -2147012740;
pub const WININET_E_SECURITY_CHANNEL_ERROR : i32 = -2147012739;
pub const WININET_E_UNABLE_TO_CACHE_FILE : i32 = -2147012738;
pub const WININET_E_TCPIP_NOT_INSTALLED : i32 = -2147012737;
pub const WININET_E_DISCONNECTED : i32 = -2147012733;
pub const WININET_E_SERVER_UNREACHABLE : i32 = -2147012732;
pub const WININET_E_PROXY_SERVER_UNREACHABLE : i32 = -2147012731;
pub const WININET_E_BAD_AUTO_PROXY_SCRIPT : i32 = -2147012730;
pub const WININET_E_UNABLE_TO_DOWNLOAD_SCRIPT : i32 = -2147012729;
pub const WININET_E_SEC_INVALID_CERT : i32 = -2147012727;
pub const WININET_E_SEC_CERT_REVOKED : i32 = -2147012726;
pub const WININET_E_FAILED_DUETOSECURITYCHECK : i32 = -2147012725;
pub const WININET_E_NOT_INITIALIZED : i32 = -2147012724;
pub const WININET_E_LOGIN_FAILURE_DISPLAY_ENTITY_BODY : i32 = -2147012722;
pub const WININET_E_DECODING_FAILED : i32 = -2147012721;
pub const WININET_E_NOT_REDIRECTED : i32 = -2147012736;
pub const WININET_E_COOKIE_NEEDS_CONFIRMATION : i32 = -2147012735;
pub const WININET_E_COOKIE_DECLINED : i32 = -2147012734;
pub const WININET_E_REDIRECT_NEEDS_CONFIRMATION : i32 = -2147012728;
pub const SQLITE_E_ERROR : i32 = -2018574335;
pub const SQLITE_E_INTERNAL : i32 = -2018574334;
pub const SQLITE_E_PERM : i32 = -2018574333;
pub const SQLITE_E_ABORT : i32 = -2018574332;
pub const SQLITE_E_BUSY : i32 = -2018574331;
pub const SQLITE_E_LOCKED : i32 = -2018574330;
pub const SQLITE_E_NOMEM : i32 = -2018574329;
pub const SQLITE_E_READONLY : i32 = -2018574328;
pub const SQLITE_E_INTERRUPT : i32 = -2018574327;
pub const SQLITE_E_IOERR : i32 = -2018574326;
pub const SQLITE_E_CORRUPT : i32 = -2018574325;
pub const SQLITE_E_NOTFOUND : i32 = -2018574324;
pub const SQLITE_E_FULL : i32 = -2018574323;
pub const SQLITE_E_CANTOPEN : i32 = -2018574322;
pub const SQLITE_E_PROTOCOL : i32 = -2018574321;
pub const SQLITE_E_EMPTY : i32 = -2018574320;
pub const SQLITE_E_SCHEMA : i32 = -2018574319;
pub const SQLITE_E_TOOBIG : i32 = -2018574318;
pub const SQLITE_E_CONSTRAINT : i32 = -2018574317;
pub const SQLITE_E_MISMATCH : i32 = -2018574316;
pub const SQLITE_E_MISUSE : i32 = -2018574315;
pub const SQLITE_E_NOLFS : i32 = -2018574314;
pub const SQLITE_E_AUTH : i32 = -2018574313;
pub const SQLITE_E_FORMAT : i32 = -2018574312;
pub const SQLITE_E_RANGE : i32 = -2018574311;
pub const SQLITE_E_NOTADB : i32 = -2018574310;
pub const SQLITE_E_NOTICE : i32 = -2018574309;
pub const SQLITE_E_WARNING : i32 = -2018574308;
pub const SQLITE_E_ROW : i32 = -2018574236;
pub const SQLITE_E_DONE : i32 = -2018574235;
pub const SQLITE_E_IOERR_READ : i32 = -2018574070;
pub const SQLITE_E_IOERR_SHORT_READ : i32 = -2018573814;
pub const SQLITE_E_IOERR_WRITE : i32 = -2018573558;
pub const SQLITE_E_IOERR_FSYNC : i32 = -2018573302;
pub const SQLITE_E_IOERR_DIR_FSYNC : i32 = -2018573046;
pub const SQLITE_E_IOERR_TRUNCATE : i32 = -2018572790;
pub const SQLITE_E_IOERR_FSTAT : i32 = -2018572534;
pub const SQLITE_E_IOERR_UNLOCK : i32 = -2018572278;
pub const SQLITE_E_IOERR_RDLOCK : i32 = -2018572022;
pub const SQLITE_E_IOERR_DELETE : i32 = -2018571766;
pub const SQLITE_E_IOERR_BLOCKED : i32 = -2018571510;
pub const SQLITE_E_IOERR_NOMEM : i32 = -2018571254;
pub const SQLITE_E_IOERR_ACCESS : i32 = -2018570998;
pub const SQLITE_E_IOERR_CHECKRESERVEDLOCK : i32 = -2018570742;
pub const SQLITE_E_IOERR_LOCK : i32 = -2018570486;
pub const SQLITE_E_IOERR_CLOSE : i32 = -2018570230;
pub const SQLITE_E_IOERR_DIR_CLOSE : i32 = -2018569974;
pub const SQLITE_E_IOERR_SHMOPEN : i32 = -2018569718;
pub const SQLITE_E_IOERR_SHMSIZE : i32 = -2018569462;
pub const SQLITE_E_IOERR_SHMLOCK : i32 = -2018569206;
pub const SQLITE_E_IOERR_SHMMAP : i32 = -2018568950;
pub const SQLITE_E_IOERR_SEEK : i32 = -2018568694;
pub const SQLITE_E_IOERR_DELETE_NOENT : i32 = -2018568438;
pub const SQLITE_E_IOERR_MMAP : i32 = -2018568182;
pub const SQLITE_E_IOERR_GETTEMPPATH : i32 = -2018567926;
pub const SQLITE_E_IOERR_CONVPATH : i32 = -2018567670;
pub const SQLITE_E_IOERR_VNODE : i32 = -2018567678;
pub const SQLITE_E_IOERR_AUTH : i32 = -2018567677;
pub const SQLITE_E_LOCKED_SHAREDCACHE : i32 = -2018574074;
pub const SQLITE_E_BUSY_RECOVERY : i32 = -2018574075;
pub const SQLITE_E_BUSY_SNAPSHOT : i32 = -2018573819;
pub const SQLITE_E_CANTOPEN_NOTEMPDIR : i32 = -2018574066;
pub const SQLITE_E_CANTOPEN_ISDIR : i32 = -2018573810;
pub const SQLITE_E_CANTOPEN_FULLPATH : i32 = -2018573554;
pub const SQLITE_E_CANTOPEN_CONVPATH : i32 = -2018573298;
pub const SQLITE_E_CORRUPT_VTAB : i32 = -2018574069;
pub const SQLITE_E_READONLY_RECOVERY : i32 = -2018574072;
pub const SQLITE_E_READONLY_CANTLOCK : i32 = -2018573816;
pub const SQLITE_E_READONLY_ROLLBACK : i32 = -2018573560;
pub const SQLITE_E_READONLY_DBMOVED : i32 = -2018573304;
pub const SQLITE_E_ABORT_ROLLBACK : i32 = -2018573820;
pub const SQLITE_E_CONSTRAINT_CHECK : i32 = -2018574061;
pub const SQLITE_E_CONSTRAINT_COMMITHOOK : i32 = -2018573805;
pub const SQLITE_E_CONSTRAINT_FOREIGNKEY : i32 = -2018573549;
pub const SQLITE_E_CONSTRAINT_FUNCTION : i32 = -2018573293;
pub const SQLITE_E_CONSTRAINT_NOTNULL : i32 = -2018573037;
pub const SQLITE_E_CONSTRAINT_PRIMARYKEY : i32 = -2018572781;
pub const SQLITE_E_CONSTRAINT_TRIGGER : i32 = -2018572525;
pub const SQLITE_E_CONSTRAINT_UNIQUE : i32 = -2018572269;
pub const SQLITE_E_CONSTRAINT_VTAB : i32 = -2018572013;
pub const SQLITE_E_CONSTRAINT_ROWID : i32 = -2018571757;
pub const SQLITE_E_NOTICE_RECOVER_WAL : i32 = -2018574053;
pub const SQLITE_E_NOTICE_RECOVER_ROLLBACK : i32 = -2018573797;
pub const SQLITE_E_WARNING_AUTOINDEX : i32 = -2018574052;
pub const UTC_E_TOGGLE_TRACE_STARTED : i32 = -2017128447;
pub const UTC_E_ALTERNATIVE_TRACE_CANNOT_PREEMPT : i32 = -2017128446;
pub const UTC_E_AOT_NOT_RUNNING : i32 = -2017128445;
pub const UTC_E_SCRIPT_TYPE_INVALID : i32 = -2017128444;
pub const UTC_E_SCENARIODEF_NOT_FOUND : i32 = -2017128443;
pub const UTC_E_TRACEPROFILE_NOT_FOUND : i32 = -2017128442;
pub const UTC_E_FORWARDER_ALREADY_ENABLED : i32 = -2017128441;
pub const UTC_E_FORWARDER_ALREADY_DISABLED : i32 = -2017128440;
pub const UTC_E_EVENTLOG_ENTRY_MALFORMED : i32 = -2017128439;
pub const UTC_E_DIAGRULES_SCHEMAVERSION_MISMATCH : i32 = -2017128438;
pub const UTC_E_SCRIPT_TERMINATED : i32 = -2017128437;
pub const UTC_E_INVALID_CUSTOM_FILTER : i32 = -2017128436;
pub const UTC_E_TRACE_NOT_RUNNING : i32 = -2017128435;
pub const UTC_E_REESCALATED_TOO_QUICKLY : i32 = -2017128434;
pub const UTC_E_ESCALATION_ALREADY_RUNNING : i32 = -2017128433;
pub const UTC_E_PERFTRACK_ALREADY_TRACING : i32 = -2017128432;
pub const UTC_E_REACHED_MAX_ESCALATIONS : i32 = -2017128431;
pub const UTC_E_FORWARDER_PRODUCER_MISMATCH : i32 = -2017128430;
pub const UTC_E_INTENTIONAL_SCRIPT_FAILURE : i32 = -2017128429;
pub const UTC_E_SQM_INIT_FAILED : i32 = -2017128428;
pub const UTC_E_NO_WER_LOGGER_SUPPORTED : i32 = -2017128427;
pub const UTC_E_TRACERS_DONT_EXIST : i32 = -2017128426;
pub const UTC_E_WINRT_INIT_FAILED : i32 = -2017128425;
pub const UTC_E_SCENARIODEF_SCHEMAVERSION_MISMATCH : i32 = -2017128424;
pub const UTC_E_INVALID_FILTER : i32 = -2017128423;
pub const UTC_E_EXE_TERMINATED : i32 = -2017128422;
pub const UTC_E_ESCALATION_NOT_AUTHORIZED : i32 = -2017128421;
pub const UTC_E_SETUP_NOT_AUTHORIZED : i32 = -2017128420;
pub const UTC_E_CHILD_PROCESS_FAILED : i32 = -2017128419;
pub const UTC_E_COMMAND_LINE_NOT_AUTHORIZED : i32 = -2017128418;
pub const UTC_E_CANNOT_LOAD_SCENARIO_EDITOR_XML : i32 = -2017128417;
pub const UTC_E_ESCALATION_TIMED_OUT : i32 = -2017128416;
pub const UTC_E_SETUP_TIMED_OUT : i32 = -2017128415;
pub const UTC_E_TRIGGER_MISMATCH : i32 = -2017128414;
pub const UTC_E_TRIGGER_NOT_FOUND : i32 = -2017128413;
pub const UTC_E_SIF_NOT_SUPPORTED : i32 = -2017128412;
pub const UTC_E_DELAY_TERMINATED : i32 = -2017128411;
pub const UTC_E_DEVICE_TICKET_ERROR : i32 = -2017128410;
pub const UTC_E_TRACE_BUFFER_LIMIT_EXCEEDED : i32 = -2017128409;
pub const UTC_E_API_RESULT_UNAVAILABLE : i32 = -2017128408;
pub const UTC_E_RPC_TIMEOUT : i32 = -2017128407;
pub const UTC_E_RPC_WAIT_FAILED : i32 = -2017128406;
pub const UTC_E_API_BUSY : i32 = -2017128405;
pub const UTC_E_TRACE_MIN_DURATION_REQUIREMENT_NOT_MET : i32 = -2017128404;
pub const UTC_E_EXCLUSIVITY_NOT_AVAILABLE : i32 = -2017128403;
pub const UTC_E_GETFILE_FILE_PATH_NOT_APPROVED : i32 = -2017128402;
pub const UTC_E_ESCALATION_DIRECTORY_ALREADY_EXISTS : i32 = -2017128401;
pub const UTC_E_TIME_TRIGGER_ON_START_INVALID : i32 = -2017128400;
pub const UTC_E_TIME_TRIGGER_ONLY_VALID_ON_SINGLE_TRANSITION : i32 = -2017128399;
pub const UTC_E_TIME_TRIGGER_INVALID_TIME_RANGE : i32 = -2017128398;
pub const UTC_E_MULTIPLE_TIME_TRIGGER_ON_SINGLE_STATE : i32 = -2017128397;
pub const UTC_E_BINARY_MISSING : i32 = -2017128396;
pub const UTC_E_FAILED_TO_RESOLVE_CONTAINER_ID : i32 = -2017128394;
pub const UTC_E_UNABLE_TO_RESOLVE_SESSION : i32 = -2017128393;
pub const UTC_E_THROTTLED : i32 = -2017128392;
pub const UTC_E_UNAPPROVED_SCRIPT : i32 = -2017128391;
pub const UTC_E_SCRIPT_MISSING : i32 = -2017128390;
pub const UTC_E_SCENARIO_THROTTLED : i32 = -2017128389;
pub const UTC_E_API_NOT_SUPPORTED : i32 = -2017128388;
pub const UTC_E_GETFILE_EXTERNAL_PATH_NOT_APPROVED : i32 = -2017128387;
pub const UTC_E_TRY_GET_SCENARIO_TIMEOUT_EXCEEDED : i32 = -2017128386;
pub const UTC_E_CERT_REV_FAILED : i32 = -2017128385;
pub const UTC_E_FAILED_TO_START_NDISCAP : i32 = -2017128384;
pub const UTC_E_KERNELDUMP_LIMIT_REACHED : i32 = -2017128383;
pub const UTC_E_MISSING_AGGREGATE_EVENT_TAG : i32 = -2017128382;
pub const UTC_E_INVALID_AGGREGATION_STRUCT : i32 = -2017128381;
pub const UTC_E_ACTION_NOT_SUPPORTED_IN_DESTINATION : i32 = -2017128380;
pub const UTC_E_FILTER_MISSING_ATTRIBUTE : i32 = -2017128379;
pub const UTC_E_FILTER_INVALID_TYPE : i32 = -2017128378;
pub const UTC_E_FILTER_VARIABLE_NOT_FOUND : i32 = -2017128377;
pub const UTC_E_FILTER_FUNCTION_RESTRICTED : i32 = -2017128376;
pub const UTC_E_FILTER_VERSION_MISMATCH : i32 = -2017128375;
pub const UTC_E_FILTER_INVALID_FUNCTION : i32 = -2017128368;
pub const UTC_E_FILTER_INVALID_FUNCTION_PARAMS : i32 = -2017128367;
pub const UTC_E_FILTER_INVALID_COMMAND : i32 = -2017128366;
pub const UTC_E_FILTER_ILLEGAL_EVAL : i32 = -2017128365;
pub const UTC_E_TTTRACER_RETURNED_ERROR : i32 = -2017128364;
pub const UTC_E_AGENT_DIAGNOSTICS_TOO_LARGE : i32 = -2017128363;
pub const UTC_E_FAILED_TO_RECEIVE_AGENT_DIAGNOSTICS : i32 = -2017128362;
pub const UTC_E_SCENARIO_HAS_NO_ACTIONS : i32 = -2017128361;
pub const UTC_E_TTTRACER_STORAGE_FULL : i32 = -2017128360;
pub const UTC_E_INSUFFICIENT_SPACE_TO_START_TRACE : i32 = -2017128359;
pub const UTC_E_ESCALATION_CANCELLED_AT_SHUTDOWN : i32 = -2017128358;
pub const UTC_E_GETFILEINFOACTION_FILE_NOT_APPROVED : i32 = -2017128357;
pub const UTC_E_SETREGKEYACTION_TYPE_NOT_APPROVED : i32 = -2017128356;
pub const WINML_ERR_INVALID_DEVICE : i32 = -2003828735;
pub const WINML_ERR_INVALID_BINDING : i32 = -2003828734;
pub const WINML_ERR_VALUE_NOTFOUND : i32 = -2003828733;
pub const WINML_ERR_SIZE_MISMATCH : i32 = -2003828732;
pub const ERROR_QUIC_HANDSHAKE_FAILURE : i32 = -2143223808;
pub const ERROR_QUIC_VER_NEG_FAILURE : i32 = -2143223807;
pub const DS_S_SUCCESS : i32 = 0;
pub const DNS_ERROR_RCODE_NO_ERROR : i32 = 0;
pub const DNS_ERROR_RCODE_LAST : i32 = 9018;
pub const DNS_STATUS_PACKET_UNSECURE : i32 = 9505;
pub const DNS_ERROR_NO_MEMORY : i32 = 14;
pub const DNS_ERROR_INVALID_NAME : i32 = 123;
pub const DNS_ERROR_INVALID_DATA : i32 = 13;
pub const SEC_E_NO_SPM : i32 = -2146893052;
pub const SEC_E_NOT_SUPPORTED : i32 = -2146893054;
pub const SCARD_S_SUCCESS : i32 = 0;
pub const PWM_IOCTL_ID_CONTROLLER_GET_INFO : i32 = 0;
pub const PWM_IOCTL_ID_CONTROLLER_GET_ACTUAL_PERIOD : i32 = 1;
pub const PWM_IOCTL_ID_CONTROLLER_SET_DESIRED_PERIOD : i32 = 2;
pub const PWM_IOCTL_ID_PIN_GET_ACTIVE_DUTY_CYCLE_PERCENTAGE : i32 = 100;
pub const PWM_IOCTL_ID_PIN_SET_ACTIVE_DUTY_CYCLE_PERCENTAGE : i32 = 101;
pub const PWM_IOCTL_ID_PIN_GET_POLARITY : i32 = 102;
pub const PWM_IOCTL_ID_PIN_SET_POLARITY : i32 = 103;
pub const PWM_IOCTL_ID_PIN_START : i32 = 104;
pub const PWM_IOCTL_ID_PIN_STOP : i32 = 105;
pub const PWM_IOCTL_ID_PIN_IS_STARTED : i32 = 106;

//--------------------------------------------------------------------------------
// Section: Types (1583)
//--------------------------------------------------------------------------------
// TODO: This Enum is marked as [Flags], what do I do with this?
pub const ConsoleMode = extern enum(i32) {
    ENABLE_ECHO_INPUT = 4,
    ENABLE_INSERT_MODE = 32,
    ENABLE_LINE_INPUT = 2,
    ENABLE_MOUSE_INPUT = 16,
    ENABLE_PROCESSED_INPUT = 1,
    ENABLE_QUICK_EDIT_MODE = 64,
    ENABLE_WINDOW_INPUT = 8,
    ENABLE_VIRTUAL_TERMINAL_INPUT = 512,
    ENABLE_PROCESSED_OUTPUT = 1,
    ENABLE_WRAP_AT_EOL_OUTPUT = 2,
    ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4,
    DISABLE_NEWLINE_AUTO_RETURN = 8,
    ENABLE_LVB_GRID_WORLDWIDE = 16,
};
pub const ENABLE_ECHO_INPUT = ConsoleMode.ENABLE_ECHO_INPUT;
pub const ENABLE_INSERT_MODE = ConsoleMode.ENABLE_INSERT_MODE;
pub const ENABLE_LINE_INPUT = ConsoleMode.ENABLE_LINE_INPUT;
pub const ENABLE_MOUSE_INPUT = ConsoleMode.ENABLE_MOUSE_INPUT;
pub const ENABLE_PROCESSED_INPUT = ConsoleMode.ENABLE_PROCESSED_INPUT;
pub const ENABLE_QUICK_EDIT_MODE = ConsoleMode.ENABLE_QUICK_EDIT_MODE;
pub const ENABLE_WINDOW_INPUT = ConsoleMode.ENABLE_WINDOW_INPUT;
pub const ENABLE_VIRTUAL_TERMINAL_INPUT = ConsoleMode.ENABLE_VIRTUAL_TERMINAL_INPUT;
pub const ENABLE_PROCESSED_OUTPUT = ConsoleMode.ENABLE_PROCESSED_OUTPUT;
pub const ENABLE_WRAP_AT_EOL_OUTPUT = ConsoleMode.ENABLE_WRAP_AT_EOL_OUTPUT;
pub const ENABLE_VIRTUAL_TERMINAL_PROCESSING = ConsoleMode.ENABLE_VIRTUAL_TERMINAL_PROCESSING;
pub const DISABLE_NEWLINE_AUTO_RETURN = ConsoleMode.DISABLE_NEWLINE_AUTO_RETURN;
pub const ENABLE_LVB_GRID_WORLDWIDE = ConsoleMode.ENABLE_LVB_GRID_WORLDWIDE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PAGE_TYPE = extern enum(u32) {
    PAGE_NOACCESS = 1,
    PAGE_READONLY = 2,
    PAGE_READWRITE = 4,
    PAGE_WRITECOPY = 8,
    PAGE_EXECUTE = 16,
    PAGE_EXECUTE_READ = 32,
    PAGE_EXECUTE_READWRITE = 64,
    PAGE_EXECUTE_WRITECOPY = 128,
    PAGE_GUARD = 256,
    PAGE_NOCACHE = 512,
    PAGE_WRITECOMBINE = 1024,
    PAGE_TARGETS_INVALID = 1073741824,
    PAGE_TARGETS_NO_UPDATE = 1073741824,
};
pub const PAGE_NOACCESS = PAGE_TYPE.PAGE_NOACCESS;
pub const PAGE_READONLY = PAGE_TYPE.PAGE_READONLY;
pub const PAGE_READWRITE = PAGE_TYPE.PAGE_READWRITE;
pub const PAGE_WRITECOPY = PAGE_TYPE.PAGE_WRITECOPY;
pub const PAGE_EXECUTE = PAGE_TYPE.PAGE_EXECUTE;
pub const PAGE_EXECUTE_READ = PAGE_TYPE.PAGE_EXECUTE_READ;
pub const PAGE_EXECUTE_READWRITE = PAGE_TYPE.PAGE_EXECUTE_READWRITE;
pub const PAGE_EXECUTE_WRITECOPY = PAGE_TYPE.PAGE_EXECUTE_WRITECOPY;
pub const PAGE_GUARD = PAGE_TYPE.PAGE_GUARD;
pub const PAGE_NOCACHE = PAGE_TYPE.PAGE_NOCACHE;
pub const PAGE_WRITECOMBINE = PAGE_TYPE.PAGE_WRITECOMBINE;
pub const PAGE_TARGETS_INVALID = PAGE_TYPE.PAGE_TARGETS_INVALID;
pub const PAGE_TARGETS_NO_UPDATE = PAGE_TYPE.PAGE_TARGETS_NO_UPDATE;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const PROCESS_ACCESS_RIGHTS = extern enum(u32) {
    PROCESS_TERMINATE = 1,
    PROCESS_CREATE_THREAD = 2,
    PROCESS_SET_SESSIONID = 4,
    PROCESS_VM_OPERATION = 8,
    PROCESS_VM_READ = 16,
    PROCESS_VM_WRITE = 32,
    PROCESS_DUP_HANDLE = 64,
    PROCESS_CREATE_PROCESS = 128,
    PROCESS_SET_QUOTA = 256,
    PROCESS_SET_INFORMATION = 512,
    PROCESS_QUERY_INFORMATION = 1024,
    PROCESS_SUSPEND_RESUME = 2048,
    PROCESS_QUERY_LIMITED_INFORMATION = 4096,
    PROCESS_SET_LIMITED_INFORMATION = 8192,
    PROCESS_ALL_ACCESS = 2097151,
    DELETE = 65536,
    READ_CONTROL = 131072,
    WRITE_DAC = 262144,
    WRITE_OWNER = 524288,
    SYNCHRONIZE = 1048576,
    STANDARD_RIGHTS_REQUIRED = 983040,
};
pub const PROCESS_TERMINATE = PROCESS_ACCESS_RIGHTS.PROCESS_TERMINATE;
pub const PROCESS_CREATE_THREAD = PROCESS_ACCESS_RIGHTS.PROCESS_CREATE_THREAD;
pub const PROCESS_SET_SESSIONID = PROCESS_ACCESS_RIGHTS.PROCESS_SET_SESSIONID;
pub const PROCESS_VM_OPERATION = PROCESS_ACCESS_RIGHTS.PROCESS_VM_OPERATION;
pub const PROCESS_VM_READ = PROCESS_ACCESS_RIGHTS.PROCESS_VM_READ;
pub const PROCESS_VM_WRITE = PROCESS_ACCESS_RIGHTS.PROCESS_VM_WRITE;
pub const PROCESS_DUP_HANDLE = PROCESS_ACCESS_RIGHTS.PROCESS_DUP_HANDLE;
pub const PROCESS_CREATE_PROCESS = PROCESS_ACCESS_RIGHTS.PROCESS_CREATE_PROCESS;
pub const PROCESS_SET_QUOTA = PROCESS_ACCESS_RIGHTS.PROCESS_SET_QUOTA;
pub const PROCESS_SET_INFORMATION = PROCESS_ACCESS_RIGHTS.PROCESS_SET_INFORMATION;
pub const PROCESS_QUERY_INFORMATION = PROCESS_ACCESS_RIGHTS.PROCESS_QUERY_INFORMATION;
pub const PROCESS_SUSPEND_RESUME = PROCESS_ACCESS_RIGHTS.PROCESS_SUSPEND_RESUME;
pub const PROCESS_QUERY_LIMITED_INFORMATION = PROCESS_ACCESS_RIGHTS.PROCESS_QUERY_LIMITED_INFORMATION;
pub const PROCESS_SET_LIMITED_INFORMATION = PROCESS_ACCESS_RIGHTS.PROCESS_SET_LIMITED_INFORMATION;
pub const PROCESS_ALL_ACCESS = PROCESS_ACCESS_RIGHTS.PROCESS_ALL_ACCESS;
pub const DELETE = PROCESS_ACCESS_RIGHTS.DELETE;
pub const READ_CONTROL = PROCESS_ACCESS_RIGHTS.READ_CONTROL;
pub const WRITE_DAC = PROCESS_ACCESS_RIGHTS.WRITE_DAC;
pub const WRITE_OWNER = PROCESS_ACCESS_RIGHTS.WRITE_OWNER;
pub const SYNCHRONIZE = PROCESS_ACCESS_RIGHTS.SYNCHRONIZE;
pub const STANDARD_RIGHTS_REQUIRED = PROCESS_ACCESS_RIGHTS.STANDARD_RIGHTS_REQUIRED;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const JOB_OBJECT_LIMIT = extern enum(u32) {
    WORKINGSET = 1,
    PROCESS_TIME = 2,
    JOB_TIME = 4,
    ACTIVE_PROCESS = 8,
    AFFINITY = 16,
    PRIORITY_CLASS = 32,
    PRESERVE_JOB_TIME = 64,
    SCHEDULING_CLASS = 128,
    PROCESS_MEMORY = 256,
    JOB_MEMORY = 512,
    JOB_MEMORY_HIGH = 512,
    DIE_ON_UNHANDLED_EXCEPTION = 1024,
    BREAKAWAY_OK = 2048,
    SILENT_BREAKAWAY_OK = 4096,
    KILL_ON_JOB_CLOSE = 8192,
    SUBSET_AFFINITY = 16384,
    JOB_MEMORY_LOW = 32768,
    JOB_READ_BYTES = 65536,
    JOB_WRITE_BYTES = 131072,
    RATE_CONTROL = 262144,
    CPU_RATE_CONTROL = 262144,
    IO_RATE_CONTROL = 524288,
    NET_RATE_CONTROL = 1048576,
    VALID_FLAGS = 524287,
    JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS = 255,
    JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS = 32767,
    JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS = 2064900,
};
pub const JOB_OBJECT_LIMIT_WORKINGSET = JOB_OBJECT_LIMIT.WORKINGSET;
pub const JOB_OBJECT_LIMIT_PROCESS_TIME = JOB_OBJECT_LIMIT.PROCESS_TIME;
pub const JOB_OBJECT_LIMIT_JOB_TIME = JOB_OBJECT_LIMIT.JOB_TIME;
pub const JOB_OBJECT_LIMIT_ACTIVE_PROCESS = JOB_OBJECT_LIMIT.ACTIVE_PROCESS;
pub const JOB_OBJECT_LIMIT_AFFINITY = JOB_OBJECT_LIMIT.AFFINITY;
pub const JOB_OBJECT_LIMIT_PRIORITY_CLASS = JOB_OBJECT_LIMIT.PRIORITY_CLASS;
pub const JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = JOB_OBJECT_LIMIT.PRESERVE_JOB_TIME;
pub const JOB_OBJECT_LIMIT_SCHEDULING_CLASS = JOB_OBJECT_LIMIT.SCHEDULING_CLASS;
pub const JOB_OBJECT_LIMIT_PROCESS_MEMORY = JOB_OBJECT_LIMIT.PROCESS_MEMORY;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY = JOB_OBJECT_LIMIT.JOB_MEMORY;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH = JOB_OBJECT_LIMIT.JOB_MEMORY_HIGH;
pub const JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = JOB_OBJECT_LIMIT.DIE_ON_UNHANDLED_EXCEPTION;
pub const JOB_OBJECT_LIMIT_BREAKAWAY_OK = JOB_OBJECT_LIMIT.BREAKAWAY_OK;
pub const JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = JOB_OBJECT_LIMIT.SILENT_BREAKAWAY_OK;
pub const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = JOB_OBJECT_LIMIT.KILL_ON_JOB_CLOSE;
pub const JOB_OBJECT_LIMIT_SUBSET_AFFINITY = JOB_OBJECT_LIMIT.SUBSET_AFFINITY;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_LOW = JOB_OBJECT_LIMIT.JOB_MEMORY_LOW;
pub const JOB_OBJECT_LIMIT_JOB_READ_BYTES = JOB_OBJECT_LIMIT.JOB_READ_BYTES;
pub const JOB_OBJECT_LIMIT_JOB_WRITE_BYTES = JOB_OBJECT_LIMIT.JOB_WRITE_BYTES;
pub const JOB_OBJECT_LIMIT_RATE_CONTROL = JOB_OBJECT_LIMIT.RATE_CONTROL;
pub const JOB_OBJECT_LIMIT_CPU_RATE_CONTROL = JOB_OBJECT_LIMIT.CPU_RATE_CONTROL;
pub const JOB_OBJECT_LIMIT_IO_RATE_CONTROL = JOB_OBJECT_LIMIT.IO_RATE_CONTROL;
pub const JOB_OBJECT_LIMIT_NET_RATE_CONTROL = JOB_OBJECT_LIMIT.NET_RATE_CONTROL;
pub const JOB_OBJECT_LIMIT_VALID_FLAGS = JOB_OBJECT_LIMIT.VALID_FLAGS;
pub const JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS = JOB_OBJECT_LIMIT.JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS;
pub const JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS = JOB_OBJECT_LIMIT.JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS;
pub const JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS = JOB_OBJECT_LIMIT.JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const JOB_OBJECT_UILIMIT = extern enum(u32) {
    NONE = 0,
    HANDLES = 1,
    READCLIPBOARD = 2,
    WRITECLIPBOARD = 4,
    SYSTEMPARAMETERS = 8,
    DISPLAYSETTINGS = 16,
    GLOBALATOMS = 32,
    DESKTOP = 64,
    EXITWINDOWS = 128,
};
pub const JOB_OBJECT_UILIMIT_NONE = JOB_OBJECT_UILIMIT.NONE;
pub const JOB_OBJECT_UILIMIT_HANDLES = JOB_OBJECT_UILIMIT.HANDLES;
pub const JOB_OBJECT_UILIMIT_READCLIPBOARD = JOB_OBJECT_UILIMIT.READCLIPBOARD;
pub const JOB_OBJECT_UILIMIT_WRITECLIPBOARD = JOB_OBJECT_UILIMIT.WRITECLIPBOARD;
pub const JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = JOB_OBJECT_UILIMIT.SYSTEMPARAMETERS;
pub const JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = JOB_OBJECT_UILIMIT.DISPLAYSETTINGS;
pub const JOB_OBJECT_UILIMIT_GLOBALATOMS = JOB_OBJECT_UILIMIT.GLOBALATOMS;
pub const JOB_OBJECT_UILIMIT_DESKTOP = JOB_OBJECT_UILIMIT.DESKTOP;
pub const JOB_OBJECT_UILIMIT_EXITWINDOWS = JOB_OBJECT_UILIMIT.EXITWINDOWS;

// TODO: This Enum is marked as [Flags], what do I do with this?
pub const JOB_OBJECT_SECURITY = extern enum(u32) {
    NO_ADMIN = 1,
    RESTRICTED_TOKEN = 2,
    ONLY_TOKEN = 4,
    FILTER_TOKENS = 8,
    VALID_FLAGS = 15,
};
pub const JOB_OBJECT_SECURITY_NO_ADMIN = JOB_OBJECT_SECURITY.NO_ADMIN;
pub const JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = JOB_OBJECT_SECURITY.RESTRICTED_TOKEN;
pub const JOB_OBJECT_SECURITY_ONLY_TOKEN = JOB_OBJECT_SECURITY.ONLY_TOKEN;
pub const JOB_OBJECT_SECURITY_FILTER_TOKENS = JOB_OBJECT_SECURITY.FILTER_TOKENS;
pub const JOB_OBJECT_SECURITY_VALID_FLAGS = JOB_OBJECT_SECURITY.VALID_FLAGS;

pub const PROCESSOR_NUMBER = extern struct {
    Group: u16,
    Number: u8,
    Reserved: u8,
};

pub const GROUP_AFFINITY = extern struct {
    Mask: ?*c_void,
    Group: u16,
    Reserved: [3]u16,
};

pub const POWERBROADCAST_SETTING = extern struct {
    PowerSetting: Guid,
    DataLength: u32,
    Data: [1]u8,
};

pub const AR_STATE = extern enum(i32) {
    AR_ENABLED = 0,
    AR_DISABLED = 1,
    AR_SUPPRESSED = 2,
    AR_REMOTESESSION = 4,
    AR_MULTIMON = 8,
    AR_NOSENSOR = 16,
    AR_NOT_SUPPORTED = 32,
    AR_DOCKED = 64,
    AR_LAPTOP = 128,
};
pub const AR_ENABLED = AR_STATE.AR_ENABLED;
pub const AR_DISABLED = AR_STATE.AR_DISABLED;
pub const AR_SUPPRESSED = AR_STATE.AR_SUPPRESSED;
pub const AR_REMOTESESSION = AR_STATE.AR_REMOTESESSION;
pub const AR_MULTIMON = AR_STATE.AR_MULTIMON;
pub const AR_NOSENSOR = AR_STATE.AR_NOSENSOR;
pub const AR_NOT_SUPPORTED = AR_STATE.AR_NOT_SUPPORTED;
pub const AR_DOCKED = AR_STATE.AR_DOCKED;
pub const AR_LAPTOP = AR_STATE.AR_LAPTOP;

pub const ORIENTATION_PREFERENCE = extern enum(i32) {
    NONE = 0,
    LANDSCAPE = 1,
    PORTRAIT = 2,
    LANDSCAPE_FLIPPED = 4,
    PORTRAIT_FLIPPED = 8,
};
pub const ORIENTATION_PREFERENCE_NONE = ORIENTATION_PREFERENCE.NONE;
pub const ORIENTATION_PREFERENCE_LANDSCAPE = ORIENTATION_PREFERENCE.LANDSCAPE;
pub const ORIENTATION_PREFERENCE_PORTRAIT = ORIENTATION_PREFERENCE.PORTRAIT;
pub const ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = ORIENTATION_PREFERENCE.LANDSCAPE_FLIPPED;
pub const ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = ORIENTATION_PREFERENCE.PORTRAIT_FLIPPED;

pub const BOOL = i32;

// TODO: this type has a FreeFunc 'DeleteBoundaryDescriptor', what can Zig do with this information?
pub const BoundaryDescriptorHandle = ?*c_void;

// TODO: this type has a FreeFunc 'CloseEventLog', what can Zig do with this information?
pub const EventLogHandle = ?*c_void;

// TODO: this type has a FreeFunc 'DeregisterEventSource', what can Zig do with this information?
pub const EventSourceHandle = ?*c_void;

// TODO: this type has a FreeFunc 'CloseHandle', what can Zig do with this information?
pub const HANDLE = ?*c_void;

// TODO: this type has a FreeFunc 'HeapDestroy', what can Zig do with this information?
pub const HeapHandle = ?*c_void;

// TODO: this type has a FreeFunc 'FreeLibrary', what can Zig do with this information?
pub const HINSTANCE = ?*c_void;

pub const HRSRC = ?*c_void;

pub const HSURF = ?*c_void;

pub const LRESULT = i32;

pub const LSTATUS = i32;

// TODO: this type has a FreeFunc 'ClosePrivateNamespace', what can Zig do with this information?
pub const NamespaceHandle = ?*c_void;

pub const NTSTATUS = i32;

pub const PSTR = [*:0]u8;

// TODO: this type has a FreeFunc 'CloseThreadpool', what can Zig do with this information?
pub const PTP_POOL = ?*c_void;

pub const PWSTR = [*:0]u16;

// TODO: this type has a FreeFunc 'DeleteTimerQueueEx', what can Zig do with this information?
pub const TimerQueueHandle = ?*c_void;

pub const FLOAT128 = extern struct {
    LowPart: i64,
    HighPart: i64,
};

pub const LARGE_INTEGER = u32; // TODO: implement StructOrUnion types?

pub const ULARGE_INTEGER = u32; // TODO: implement StructOrUnion types?

pub const M128A = extern struct {
    Low: u64,
    High: i64,
};

pub const XSAVE_FORMAT = extern struct {
    ControlWord: u16,
    StatusWord: u16,
    TagWord: u8,
    Reserved1: u8,
    ErrorOpcode: u16,
    ErrorOffset: u32,
    ErrorSelector: u16,
    Reserved2: u16,
    DataOffset: u32,
    DataSelector: u16,
    Reserved3: u16,
    MxCsr: u32,
    MxCsr_Mask: u32,
    FloatRegisters: [8]M128A,
    XmmRegisters: [8]M128A,
    Reserved4: [224]u8,
};

pub const XSAVE_CET_U_FORMAT = extern struct {
    Ia32CetUMsr: u64,
    Ia32Pl3SspMsr: u64,
};

pub const XSAVE_AREA_HEADER = extern struct {
    Mask: u64,
    CompactionMask: u64,
    Reserved2: [6]u64,
};

pub const XSAVE_AREA = extern struct {
    LegacyState: XSAVE_FORMAT,
    Header: XSAVE_AREA_HEADER,
};

pub const XSTATE_CONTEXT = extern struct {
    Mask: u64,
    Length: u32,
    Reserved1: u32,
    Area: *XSAVE_AREA,
    Reserved2: u32,
    Buffer: *c_void,
    Reserved3: u32,
};

pub const SCOPE_TABLE_AMD64 = extern struct {
    Count: u32,
    ScopeRecord: [1]SCOPE_TABLE_AMD64._Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const SCOPE_TABLE_ARM = extern struct {
    Count: u32,
    ScopeRecord: [1]SCOPE_TABLE_ARM._Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const SCOPE_TABLE_ARM64 = extern struct {
    Count: u32,
    ScopeRecord: [1]SCOPE_TABLE_ARM64._Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const KNONVOLATILE_CONTEXT_POINTERS_ARM64 = extern struct {
    X19: *u64,
    X20: *u64,
    X21: *u64,
    X22: *u64,
    X23: *u64,
    X24: *u64,
    X25: *u64,
    X26: *u64,
    X27: *u64,
    X28: *u64,
    Fp: *u64,
    Lr: *u64,
    D8: *u64,
    D9: *u64,
    D10: *u64,
    D11: *u64,
    D12: *u64,
    D13: *u64,
    D14: *u64,
    D15: *u64,
};

pub const FLOATING_SAVE_AREA = extern struct {
    ControlWord: u32,
    StatusWord: u32,
    TagWord: u32,
    ErrorOffset: u32,
    ErrorSelector: u32,
    DataOffset: u32,
    DataSelector: u32,
    RegisterArea: [80]u8,
    Spare0: u32,
};

pub const KNONVOLATILE_CONTEXT_POINTERS = extern struct {
    Dummy: u32,
};

pub const WOW64_DESCRIPTOR_TABLE_ENTRY = extern struct {
    Selector: u32,
    Descriptor: WOW64_LDT_ENTRY,
};

pub const EXCEPTION_RECORD32 = extern struct {
    ExceptionCode: u32,
    ExceptionFlags: u32,
    ExceptionRecord: u32,
    ExceptionAddress: u32,
    NumberParameters: u32,
    ExceptionInformation: [15]u32,
};

pub const SE_SID = u32; // TODO: implement StructOrUnion types?

pub const SYSTEM_PROCESS_TRUST_LABEL_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_ACCESS_FILTER_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SECURITY_DESCRIPTOR_RELATIVE = extern struct {
    Revision: u8,
    Sbz1: u8,
    Control: u16,
    Owner: u32,
    Group: u32,
    Sacl: u32,
    Dacl: u32,
};

pub const SECURITY_OBJECT_AI_PARAMS = extern struct {
    Size: u32,
    ConstraintMask: u32,
};

pub const ACCESS_REASON_TYPE = extern enum(i32) {
    AccessReasonNone = 0,
    AccessReasonAllowedAce = 65536,
    AccessReasonDeniedAce = 131072,
    AccessReasonAllowedParentAce = 196608,
    AccessReasonDeniedParentAce = 262144,
    AccessReasonNotGrantedByCape = 327680,
    AccessReasonNotGrantedByParentCape = 393216,
    AccessReasonNotGrantedToAppContainer = 458752,
    AccessReasonMissingPrivilege = 1048576,
    AccessReasonFromPrivilege = 2097152,
    AccessReasonIntegrityLevel = 3145728,
    AccessReasonOwnership = 4194304,
    AccessReasonNullDacl = 5242880,
    AccessReasonEmptyDacl = 6291456,
    AccessReasonNoSD = 7340032,
    AccessReasonNoGrant = 8388608,
    AccessReasonTrustLabel = 9437184,
    AccessReasonFilterAce = 10485760,
};
pub const AccessReasonNone = ACCESS_REASON_TYPE.AccessReasonNone;
pub const AccessReasonAllowedAce = ACCESS_REASON_TYPE.AccessReasonAllowedAce;
pub const AccessReasonDeniedAce = ACCESS_REASON_TYPE.AccessReasonDeniedAce;
pub const AccessReasonAllowedParentAce = ACCESS_REASON_TYPE.AccessReasonAllowedParentAce;
pub const AccessReasonDeniedParentAce = ACCESS_REASON_TYPE.AccessReasonDeniedParentAce;
pub const AccessReasonNotGrantedByCape = ACCESS_REASON_TYPE.AccessReasonNotGrantedByCape;
pub const AccessReasonNotGrantedByParentCape = ACCESS_REASON_TYPE.AccessReasonNotGrantedByParentCape;
pub const AccessReasonNotGrantedToAppContainer = ACCESS_REASON_TYPE.AccessReasonNotGrantedToAppContainer;
pub const AccessReasonMissingPrivilege = ACCESS_REASON_TYPE.AccessReasonMissingPrivilege;
pub const AccessReasonFromPrivilege = ACCESS_REASON_TYPE.AccessReasonFromPrivilege;
pub const AccessReasonIntegrityLevel = ACCESS_REASON_TYPE.AccessReasonIntegrityLevel;
pub const AccessReasonOwnership = ACCESS_REASON_TYPE.AccessReasonOwnership;
pub const AccessReasonNullDacl = ACCESS_REASON_TYPE.AccessReasonNullDacl;
pub const AccessReasonEmptyDacl = ACCESS_REASON_TYPE.AccessReasonEmptyDacl;
pub const AccessReasonNoSD = ACCESS_REASON_TYPE.AccessReasonNoSD;
pub const AccessReasonNoGrant = ACCESS_REASON_TYPE.AccessReasonNoGrant;
pub const AccessReasonTrustLabel = ACCESS_REASON_TYPE.AccessReasonTrustLabel;
pub const AccessReasonFilterAce = ACCESS_REASON_TYPE.AccessReasonFilterAce;

pub const ACCESS_REASONS = extern struct {
    Data: [32]u32,
};

pub const SE_SECURITY_DESCRIPTOR = extern struct {
    Size: u32,
    Flags: u32,
    SecurityDescriptor: *c_void,
};

pub const SE_ACCESS_REQUEST = extern struct {
    Size: u32,
    SeSecurityDescriptor: *SE_SECURITY_DESCRIPTOR,
    DesiredAccess: u32,
    PreviouslyGrantedAccess: u32,
    PrincipalSelfSid: *c_void,
    GenericMapping: *GENERIC_MAPPING,
    ObjectTypeListCount: u32,
    ObjectTypeList: *OBJECT_TYPE_LIST,
};

pub const SE_ACCESS_REPLY = extern struct {
    Size: u32,
    ResultListCount: u32,
    GrantedAccess: *u32,
    AccessStatus: *u32,
    AccessReason: *ACCESS_REASONS,
    Privileges: **PRIVILEGE_SET,
};

pub const SE_TOKEN_USER = extern struct {
    Anonymous1: SE_TOKEN_USER._Anonymous1_e__Union,
    Anonymous2: SE_TOKEN_USER._Anonymous2_e__Union,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const TOKEN_SID_INFORMATION = extern struct {
    Sid: *c_void,
};

pub const TOKEN_BNO_ISOLATION_INFORMATION = extern struct {
    IsolationPrefix: PWSTR,
    IsolationEnabled: u8,
};

pub const SE_IMPERSONATION_STATE = extern struct {
    Token: *c_void,
    CopyOnOpen: u8,
    EffectiveOnly: u8,
    Level: SECURITY_IMPERSONATION_LEVEL,
};

pub const SE_IMAGE_SIGNATURE_TYPE = extern enum(i32) {
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded = 1,
    SeImageSignatureCache = 2,
    SeImageSignatureCatalogCached = 3,
    SeImageSignatureCatalogNotCached = 4,
    SeImageSignatureCatalogHint = 5,
    SeImageSignaturePackageCatalog = 6,
};
pub const SeImageSignatureNone = SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureNone;
pub const SeImageSignatureEmbedded = SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureEmbedded;
pub const SeImageSignatureCache = SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCache;
pub const SeImageSignatureCatalogCached = SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCatalogCached;
pub const SeImageSignatureCatalogNotCached = SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCatalogNotCached;
pub const SeImageSignatureCatalogHint = SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCatalogHint;
pub const SeImageSignaturePackageCatalog = SE_IMAGE_SIGNATURE_TYPE.SeImageSignaturePackageCatalog;

pub const SE_LEARNING_MODE_DATA_TYPE = extern enum(i32) {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings = 1,
    SeLearningModeMax = 2,
};
pub const SeLearningModeInvalidType = SE_LEARNING_MODE_DATA_TYPE.SeLearningModeInvalidType;
pub const SeLearningModeSettings = SE_LEARNING_MODE_DATA_TYPE.SeLearningModeSettings;
pub const SeLearningModeMax = SE_LEARNING_MODE_DATA_TYPE.SeLearningModeMax;

pub const JOB_SET_ARRAY = extern struct {
    JobHandle: HANDLE,
    MemberLevel: u32,
    Flags: u32,
};

pub const EXCEPTION_REGISTRATION_RECORD = extern struct {
    Next: *EXCEPTION_REGISTRATION_RECORD,
    Handler: EXCEPTION_ROUTINE,
};

pub const NT_TIB = extern struct {
    ExceptionList: *EXCEPTION_REGISTRATION_RECORD,
    StackBase: *c_void,
    StackLimit: *c_void,
    SubSystemTib: *c_void,
    Anonymous: NT_TIB._Anonymous_e__Union,
    ArbitraryUserPointer: *c_void,
    Self: *NT_TIB,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const NT_TIB32 = extern struct {
    ExceptionList: u32,
    StackBase: u32,
    StackLimit: u32,
    SubSystemTib: u32,
    Anonymous: NT_TIB32._Anonymous_e__Union,
    ArbitraryUserPointer: u32,
    Self: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const NT_TIB64 = extern struct {
    ExceptionList: u64,
    StackBase: u64,
    StackLimit: u64,
    SubSystemTib: u64,
    Anonymous: NT_TIB64._Anonymous_e__Union,
    ArbitraryUserPointer: u64,
    Self: u64,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const UMS_CREATE_THREAD_ATTRIBUTES = extern struct {
    UmsVersion: u32,
    UmsContext: *c_void,
    UmsCompletionList: *c_void,
};

pub const WOW64_ARCHITECTURE_INFORMATION = extern struct {
    _bitfield: u32,
};

pub const PROCESS_DYNAMIC_EH_CONTINUATION_TARGET = extern struct {
    TargetAddress: ?*c_void,
    Flags: ?*c_void,
};

pub const PROCESS_DYNAMIC_EH_CONTINUATION_TARGETS_INFORMATION = extern struct {
    NumberOfTargets: u16,
    Reserved: u16,
    Reserved2: u32,
    Targets: *PROCESS_DYNAMIC_EH_CONTINUATION_TARGET,
};

pub const RATE_QUOTA_LIMIT = u32; // TODO: implement StructOrUnion types?

pub const QUOTA_LIMITS_EX = extern struct {
    PagedPoolLimit: ?*c_void,
    NonPagedPoolLimit: ?*c_void,
    MinimumWorkingSetSize: ?*c_void,
    MaximumWorkingSetSize: ?*c_void,
    PagefileLimit: ?*c_void,
    TimeLimit: LARGE_INTEGER,
    WorkingSetLimit: ?*c_void,
    Reserved2: ?*c_void,
    Reserved3: ?*c_void,
    Reserved4: ?*c_void,
    Flags: u32,
    CpuRateLimit: RATE_QUOTA_LIMIT,
};

pub const IO_COUNTERS = extern struct {
    ReadOperationCount: u64,
    WriteOperationCount: u64,
    OtherOperationCount: u64,
    ReadTransferCount: u64,
    WriteTransferCount: u64,
    OtherTransferCount: u64,
};

pub const PROCESS_MITIGATION_POLICY = extern enum(i32) {
    ProcessDEPPolicy = 0,
    ProcessASLRPolicy = 1,
    ProcessDynamicCodePolicy = 2,
    ProcessStrictHandleCheckPolicy = 3,
    ProcessSystemCallDisablePolicy = 4,
    ProcessMitigationOptionsMask = 5,
    ProcessExtensionPointDisablePolicy = 6,
    ProcessControlFlowGuardPolicy = 7,
    ProcessSignaturePolicy = 8,
    ProcessFontDisablePolicy = 9,
    ProcessImageLoadPolicy = 10,
    ProcessSystemCallFilterPolicy = 11,
    ProcessPayloadRestrictionPolicy = 12,
    ProcessChildProcessPolicy = 13,
    ProcessSideChannelIsolationPolicy = 14,
    ProcessUserShadowStackPolicy = 15,
    MaxProcessMitigationPolicy = 16,
};
pub const ProcessDEPPolicy = PROCESS_MITIGATION_POLICY.ProcessDEPPolicy;
pub const ProcessASLRPolicy = PROCESS_MITIGATION_POLICY.ProcessASLRPolicy;
pub const ProcessDynamicCodePolicy = PROCESS_MITIGATION_POLICY.ProcessDynamicCodePolicy;
pub const ProcessStrictHandleCheckPolicy = PROCESS_MITIGATION_POLICY.ProcessStrictHandleCheckPolicy;
pub const ProcessSystemCallDisablePolicy = PROCESS_MITIGATION_POLICY.ProcessSystemCallDisablePolicy;
pub const ProcessMitigationOptionsMask = PROCESS_MITIGATION_POLICY.ProcessMitigationOptionsMask;
pub const ProcessExtensionPointDisablePolicy = PROCESS_MITIGATION_POLICY.ProcessExtensionPointDisablePolicy;
pub const ProcessControlFlowGuardPolicy = PROCESS_MITIGATION_POLICY.ProcessControlFlowGuardPolicy;
pub const ProcessSignaturePolicy = PROCESS_MITIGATION_POLICY.ProcessSignaturePolicy;
pub const ProcessFontDisablePolicy = PROCESS_MITIGATION_POLICY.ProcessFontDisablePolicy;
pub const ProcessImageLoadPolicy = PROCESS_MITIGATION_POLICY.ProcessImageLoadPolicy;
pub const ProcessSystemCallFilterPolicy = PROCESS_MITIGATION_POLICY.ProcessSystemCallFilterPolicy;
pub const ProcessPayloadRestrictionPolicy = PROCESS_MITIGATION_POLICY.ProcessPayloadRestrictionPolicy;
pub const ProcessChildProcessPolicy = PROCESS_MITIGATION_POLICY.ProcessChildProcessPolicy;
pub const ProcessSideChannelIsolationPolicy = PROCESS_MITIGATION_POLICY.ProcessSideChannelIsolationPolicy;
pub const ProcessUserShadowStackPolicy = PROCESS_MITIGATION_POLICY.ProcessUserShadowStackPolicy;
pub const MaxProcessMitigationPolicy = PROCESS_MITIGATION_POLICY.MaxProcessMitigationPolicy;

pub const PROCESS_MITIGATION_ASLR_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_ASLR_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_DEP_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_DEP_POLICY._Anonymous_e__Union,
    Permanent: u8,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_DYNAMIC_CODE_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_FONT_DISABLE_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_FONT_DISABLE_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_IMAGE_LOAD_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_IMAGE_LOAD_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_CHILD_PROCESS_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_CHILD_PROCESS_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY = extern struct {
    Anonymous: PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = extern struct {
    TotalUserTime: LARGE_INTEGER,
    TotalKernelTime: LARGE_INTEGER,
    ThisPeriodTotalUserTime: LARGE_INTEGER,
    ThisPeriodTotalKernelTime: LARGE_INTEGER,
    TotalPageFaultCount: u32,
    TotalProcesses: u32,
    ActiveProcesses: u32,
    TotalTerminatedProcesses: u32,
};

pub const JOBOBJECT_BASIC_LIMIT_INFORMATION = extern struct {
    PerProcessUserTimeLimit: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    LimitFlags: JOB_OBJECT_LIMIT,
    MinimumWorkingSetSize: ?*c_void,
    MaximumWorkingSetSize: ?*c_void,
    ActiveProcessLimit: u32,
    Affinity: ?*c_void,
    PriorityClass: u32,
    SchedulingClass: u32,
};

pub const JOBOBJECT_EXTENDED_LIMIT_INFORMATION = extern struct {
    BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
    IoInfo: IO_COUNTERS,
    ProcessMemoryLimit: ?*c_void,
    JobMemoryLimit: ?*c_void,
    PeakProcessMemoryUsed: ?*c_void,
    PeakJobMemoryUsed: ?*c_void,
};

pub const JOBOBJECT_BASIC_PROCESS_ID_LIST = extern struct {
    NumberOfAssignedProcesses: u32,
    NumberOfProcessIdsInList: u32,
    ProcessIdList: [1]?*c_void,
};

pub const JOBOBJECT_BASIC_UI_RESTRICTIONS = extern struct {
    UIRestrictionsClass: JOB_OBJECT_UILIMIT,
};

pub const JOBOBJECT_SECURITY_LIMIT_INFORMATION = extern struct {
    SecurityLimitFlags: JOB_OBJECT_SECURITY,
    JobToken: HANDLE,
    SidsToDisable: *TOKEN_GROUPS,
    PrivilegesToDelete: *TOKEN_PRIVILEGES,
    RestrictedSids: *TOKEN_GROUPS,
};

pub const JOBOBJECT_END_OF_JOB_TIME_INFORMATION = extern struct {
    EndOfJobTimeAction: u32,
};

pub const JOBOBJECT_ASSOCIATE_COMPLETION_PORT = extern struct {
    CompletionKey: *c_void,
    CompletionPort: HANDLE,
};

pub const JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = extern struct {
    BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
    IoInfo: IO_COUNTERS,
};

pub const JOBOBJECT_JOBSET_INFORMATION = extern struct {
    MemberLevel: u32,
};

pub const JOBOBJECT_RATE_CONTROL_TOLERANCE = extern enum(i32) {
    ToleranceLow = 1,
    ToleranceMedium = 2,
    ToleranceHigh = 3,
};
pub const ToleranceLow = JOBOBJECT_RATE_CONTROL_TOLERANCE.ToleranceLow;
pub const ToleranceMedium = JOBOBJECT_RATE_CONTROL_TOLERANCE.ToleranceMedium;
pub const ToleranceHigh = JOBOBJECT_RATE_CONTROL_TOLERANCE.ToleranceHigh;

pub const JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = extern enum(i32) {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium = 2,
    ToleranceIntervalLong = 3,
};
pub const ToleranceIntervalShort = JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL.ToleranceIntervalShort;
pub const ToleranceIntervalMedium = JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL.ToleranceIntervalMedium;
pub const ToleranceIntervalLong = JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL.ToleranceIntervalLong;

pub const JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = extern struct {
    IoReadBytesLimit: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemoryLimit: u64,
    RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    LimitFlags: JOB_OBJECT_LIMIT,
};

pub const JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 = extern struct {
    IoReadBytesLimit: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTimeLimit: LARGE_INTEGER,
    Anonymous1: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2._Anonymous1_e__Union,
    Anonymous2: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2._Anonymous2_e__Union,
    Anonymous3: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2._Anonymous3_e__Union,
    LimitFlags: JOB_OBJECT_LIMIT,
    IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    JobLowMemoryLimit: u64,
    IoRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const JOBOBJECT_LIMIT_VIOLATION_INFORMATION = extern struct {
    LimitFlags: JOB_OBJECT_LIMIT,
    ViolationLimitFlags: JOB_OBJECT_LIMIT,
    IoReadBytes: u64,
    IoReadBytesLimit: u64,
    IoWriteBytes: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTime: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemory: u64,
    JobMemoryLimit: u64,
    RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
};

pub const JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 = extern struct {
    LimitFlags: JOB_OBJECT_LIMIT,
    ViolationLimitFlags: JOB_OBJECT_LIMIT,
    IoReadBytes: u64,
    IoReadBytesLimit: u64,
    IoWriteBytes: u64,
    IoWriteBytesLimit: u64,
    PerJobUserTime: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemory: u64,
    Anonymous1: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2._Anonymous1_e__Union,
    Anonymous2: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2._Anonymous2_e__Union,
    Anonymous3: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2._Anonymous3_e__Union,
    JobLowMemoryLimit: u64,
    IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    IoRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = extern struct {
    ControlFlags: u32,
    Anonymous: JOBOBJECT_CPU_RATE_CONTROL_INFORMATION._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS = extern enum(i32) {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 7,
};
pub const JOB_OBJECT_NET_RATE_CONTROL_ENABLE = JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_ENABLE;
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH;
pub const JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG;
pub const JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS;

pub const JOBOBJECT_NET_RATE_CONTROL_INFORMATION = extern struct {
    MaxBandwidth: u64,
    ControlFlags: JOB_OBJECT_NET_RATE_CONTROL_FLAGS,
    DscpTag: u8,
};

pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS = extern enum(i32) {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 2,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 4,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 8,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = 15,
};
pub const JOB_OBJECT_IO_RATE_CONTROL_ENABLE = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_ENABLE;
pub const JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME;
pub const JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL;
pub const JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP;
pub const JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS;

pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: PWSTR,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: u16,
};

pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: PWSTR,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: u16,
    CriticalReservationIops: i64,
    ReservationBandwidth: i64,
    CriticalReservationBandwidth: i64,
    MaxTimePercent: i64,
    ReservationTimePercent: i64,
    CriticalReservationTimePercent: i64,
};

pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: PWSTR,
    BaseIoSize: u32,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: u16,
    CriticalReservationIops: i64,
    ReservationBandwidth: i64,
    CriticalReservationBandwidth: i64,
    MaxTimePercent: i64,
    ReservationTimePercent: i64,
    CriticalReservationTimePercent: i64,
    SoftMaxIops: i64,
    SoftMaxBandwidth: i64,
    SoftMaxTimePercent: i64,
    LimitExcessNotifyIops: i64,
    LimitExcessNotifyBandwidth: i64,
    LimitExcessNotifyTimePercent: i64,
};

pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = extern enum(i32) {
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 1,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 2,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 3,
};
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS;

pub const JOBOBJECT_IO_ATTRIBUTION_STATS = extern struct {
    IoCount: ?*c_void,
    TotalNonOverlappedQueueTime: u64,
    TotalNonOverlappedServiceTime: u64,
    TotalSize: u64,
};

pub const JOBOBJECT_IO_ATTRIBUTION_INFORMATION = extern struct {
    ControlFlags: u32,
    ReadStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
    WriteStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
};

pub const JOBOBJECTINFOCLASS = extern enum(i32) {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation = 2,
    JobObjectBasicProcessIdList = 3,
    JobObjectBasicUIRestrictions = 4,
    JobObjectSecurityLimitInformation = 5,
    JobObjectEndOfJobTimeInformation = 6,
    JobObjectAssociateCompletionPortInformation = 7,
    JobObjectBasicAndIoAccountingInformation = 8,
    JobObjectExtendedLimitInformation = 9,
    JobObjectJobSetInformation = 10,
    JobObjectGroupInformation = 11,
    JobObjectNotificationLimitInformation = 12,
    JobObjectLimitViolationInformation = 13,
    JobObjectGroupInformationEx = 14,
    JobObjectCpuRateControlInformation = 15,
    JobObjectCompletionFilter = 16,
    JobObjectCompletionCounter = 17,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information = 19,
    JobObjectReserved3Information = 20,
    JobObjectReserved4Information = 21,
    JobObjectReserved5Information = 22,
    JobObjectReserved6Information = 23,
    JobObjectReserved7Information = 24,
    JobObjectReserved8Information = 25,
    JobObjectReserved9Information = 26,
    JobObjectReserved10Information = 27,
    JobObjectReserved11Information = 28,
    JobObjectReserved12Information = 29,
    JobObjectReserved13Information = 30,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation = 32,
    JobObjectNotificationLimitInformation2 = 33,
    JobObjectLimitViolationInformation2 = 34,
    JobObjectCreateSilo = 35,
    JobObjectSiloBasicInformation = 36,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    MaxJobObjectInfoClass = 48,
};
pub const JobObjectBasicAccountingInformation = JOBOBJECTINFOCLASS.JobObjectBasicAccountingInformation;
pub const JobObjectBasicLimitInformation = JOBOBJECTINFOCLASS.JobObjectBasicLimitInformation;
pub const JobObjectBasicProcessIdList = JOBOBJECTINFOCLASS.JobObjectBasicProcessIdList;
pub const JobObjectBasicUIRestrictions = JOBOBJECTINFOCLASS.JobObjectBasicUIRestrictions;
pub const JobObjectSecurityLimitInformation = JOBOBJECTINFOCLASS.JobObjectSecurityLimitInformation;
pub const JobObjectEndOfJobTimeInformation = JOBOBJECTINFOCLASS.JobObjectEndOfJobTimeInformation;
pub const JobObjectAssociateCompletionPortInformation = JOBOBJECTINFOCLASS.JobObjectAssociateCompletionPortInformation;
pub const JobObjectBasicAndIoAccountingInformation = JOBOBJECTINFOCLASS.JobObjectBasicAndIoAccountingInformation;
pub const JobObjectExtendedLimitInformation = JOBOBJECTINFOCLASS.JobObjectExtendedLimitInformation;
pub const JobObjectJobSetInformation = JOBOBJECTINFOCLASS.JobObjectJobSetInformation;
pub const JobObjectGroupInformation = JOBOBJECTINFOCLASS.JobObjectGroupInformation;
pub const JobObjectNotificationLimitInformation = JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation;
pub const JobObjectLimitViolationInformation = JOBOBJECTINFOCLASS.JobObjectLimitViolationInformation;
pub const JobObjectGroupInformationEx = JOBOBJECTINFOCLASS.JobObjectGroupInformationEx;
pub const JobObjectCpuRateControlInformation = JOBOBJECTINFOCLASS.JobObjectCpuRateControlInformation;
pub const JobObjectCompletionFilter = JOBOBJECTINFOCLASS.JobObjectCompletionFilter;
pub const JobObjectCompletionCounter = JOBOBJECTINFOCLASS.JobObjectCompletionCounter;
pub const JobObjectReserved1Information = JOBOBJECTINFOCLASS.JobObjectReserved1Information;
pub const JobObjectReserved2Information = JOBOBJECTINFOCLASS.JobObjectReserved2Information;
pub const JobObjectReserved3Information = JOBOBJECTINFOCLASS.JobObjectReserved3Information;
pub const JobObjectReserved4Information = JOBOBJECTINFOCLASS.JobObjectReserved4Information;
pub const JobObjectReserved5Information = JOBOBJECTINFOCLASS.JobObjectReserved5Information;
pub const JobObjectReserved6Information = JOBOBJECTINFOCLASS.JobObjectReserved6Information;
pub const JobObjectReserved7Information = JOBOBJECTINFOCLASS.JobObjectReserved7Information;
pub const JobObjectReserved8Information = JOBOBJECTINFOCLASS.JobObjectReserved8Information;
pub const JobObjectReserved9Information = JOBOBJECTINFOCLASS.JobObjectReserved9Information;
pub const JobObjectReserved10Information = JOBOBJECTINFOCLASS.JobObjectReserved10Information;
pub const JobObjectReserved11Information = JOBOBJECTINFOCLASS.JobObjectReserved11Information;
pub const JobObjectReserved12Information = JOBOBJECTINFOCLASS.JobObjectReserved12Information;
pub const JobObjectReserved13Information = JOBOBJECTINFOCLASS.JobObjectReserved13Information;
pub const JobObjectReserved14Information = JOBOBJECTINFOCLASS.JobObjectReserved14Information;
pub const JobObjectNetRateControlInformation = JOBOBJECTINFOCLASS.JobObjectNetRateControlInformation;
pub const JobObjectNotificationLimitInformation2 = JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation2;
pub const JobObjectLimitViolationInformation2 = JOBOBJECTINFOCLASS.JobObjectLimitViolationInformation2;
pub const JobObjectCreateSilo = JOBOBJECTINFOCLASS.JobObjectCreateSilo;
pub const JobObjectSiloBasicInformation = JOBOBJECTINFOCLASS.JobObjectSiloBasicInformation;
pub const JobObjectReserved15Information = JOBOBJECTINFOCLASS.JobObjectReserved15Information;
pub const JobObjectReserved16Information = JOBOBJECTINFOCLASS.JobObjectReserved16Information;
pub const JobObjectReserved17Information = JOBOBJECTINFOCLASS.JobObjectReserved17Information;
pub const JobObjectReserved18Information = JOBOBJECTINFOCLASS.JobObjectReserved18Information;
pub const JobObjectReserved19Information = JOBOBJECTINFOCLASS.JobObjectReserved19Information;
pub const JobObjectReserved20Information = JOBOBJECTINFOCLASS.JobObjectReserved20Information;
pub const JobObjectReserved21Information = JOBOBJECTINFOCLASS.JobObjectReserved21Information;
pub const JobObjectReserved22Information = JOBOBJECTINFOCLASS.JobObjectReserved22Information;
pub const JobObjectReserved23Information = JOBOBJECTINFOCLASS.JobObjectReserved23Information;
pub const JobObjectReserved24Information = JOBOBJECTINFOCLASS.JobObjectReserved24Information;
pub const JobObjectReserved25Information = JOBOBJECTINFOCLASS.JobObjectReserved25Information;
pub const MaxJobObjectInfoClass = JOBOBJECTINFOCLASS.MaxJobObjectInfoClass;

pub const SILOOBJECT_BASIC_INFORMATION = extern struct {
    SiloId: u32,
    SiloParentId: u32,
    NumberOfProcesses: u32,
    IsInServerSilo: u8,
    Reserved: [3]u8,
};

pub const SERVERSILO_STATE = extern enum(i32) {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED = 1,
    SERVERSILO_SHUTTING_DOWN = 2,
    SERVERSILO_TERMINATING = 3,
    SERVERSILO_TERMINATED = 4,
};
pub const SERVERSILO_INITING = SERVERSILO_STATE.SERVERSILO_INITING;
pub const SERVERSILO_STARTED = SERVERSILO_STATE.SERVERSILO_STARTED;
pub const SERVERSILO_SHUTTING_DOWN = SERVERSILO_STATE.SERVERSILO_SHUTTING_DOWN;
pub const SERVERSILO_TERMINATING = SERVERSILO_STATE.SERVERSILO_TERMINATING;
pub const SERVERSILO_TERMINATED = SERVERSILO_STATE.SERVERSILO_TERMINATED;

pub const SERVERSILO_BASIC_INFORMATION = extern struct {
    ServiceSessionId: u32,
    State: SERVERSILO_STATE,
    ExitStatus: u32,
    IsDownlevelContainer: u8,
    ApiSetSchema: *c_void,
    HostApiSetSchema: *c_void,
};

pub const LOGICAL_PROCESSOR_RELATIONSHIP = extern enum(i32) {
    RelationProcessorCore = 0,
    RelationNumaNode = 1,
    RelationCache = 2,
    RelationProcessorPackage = 3,
    RelationGroup = 4,
    RelationAll = 65535,
};
pub const RelationProcessorCore = LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore;
pub const RelationNumaNode = LOGICAL_PROCESSOR_RELATIONSHIP.RelationNumaNode;
pub const RelationCache = LOGICAL_PROCESSOR_RELATIONSHIP.RelationCache;
pub const RelationProcessorPackage = LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorPackage;
pub const RelationGroup = LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup;
pub const RelationAll = LOGICAL_PROCESSOR_RELATIONSHIP.RelationAll;

pub const PROCESSOR_CACHE_TYPE = extern enum(i32) {
    CacheUnified = 0,
    CacheInstruction = 1,
    CacheData = 2,
    CacheTrace = 3,
};
pub const CacheUnified = PROCESSOR_CACHE_TYPE.CacheUnified;
pub const CacheInstruction = PROCESSOR_CACHE_TYPE.CacheInstruction;
pub const CacheData = PROCESSOR_CACHE_TYPE.CacheData;
pub const CacheTrace = PROCESSOR_CACHE_TYPE.CacheTrace;

pub const CACHE_DESCRIPTOR = extern struct {
    Level: u8,
    Associativity: u8,
    LineSize: u16,
    Size: u32,
    Type: PROCESSOR_CACHE_TYPE,
};

pub const SYSTEM_LOGICAL_PROCESSOR_INFORMATION = extern struct {
    ProcessorMask: ?*c_void,
    Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    Anonymous: SYSTEM_LOGICAL_PROCESSOR_INFORMATION._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESSOR_RELATIONSHIP = extern struct {
    Flags: u8,
    EfficiencyClass: u8,
    Reserved: [20]u8,
    GroupCount: u16,
    GroupMask: [1]GROUP_AFFINITY,
};

pub const NUMA_NODE_RELATIONSHIP = extern struct {
    NodeNumber: u32,
    Reserved: [20]u8,
    GroupMask: GROUP_AFFINITY,
};

pub const CACHE_RELATIONSHIP = extern struct {
    Level: u8,
    Associativity: u8,
    LineSize: u16,
    CacheSize: u32,
    Type: PROCESSOR_CACHE_TYPE,
    Reserved: [20]u8,
    GroupMask: GROUP_AFFINITY,
};

pub const PROCESSOR_GROUP_INFO = extern struct {
    MaximumProcessorCount: u8,
    ActiveProcessorCount: u8,
    Reserved: [38]u8,
    ActiveProcessorMask: ?*c_void,
};

pub const GROUP_RELATIONSHIP = extern struct {
    MaximumGroupCount: u16,
    ActiveGroupCount: u16,
    Reserved: [20]u8,
    GroupInfo: [1]PROCESSOR_GROUP_INFO,
};

pub const SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = extern struct {
    Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    Size: u32,
    Anonymous: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CPU_SET_INFORMATION_TYPE = extern enum(i32) {
    CpuSetInformation = 0,
};
pub const CpuSetInformation = CPU_SET_INFORMATION_TYPE.CpuSetInformation;

pub const SYSTEM_CPU_SET_INFORMATION = extern struct {
    Size: u32,
    Type: CPU_SET_INFORMATION_TYPE,
    Anonymous: SYSTEM_CPU_SET_INFORMATION._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = extern struct {
    CycleTime: u64,
};

pub const XSTATE_FEATURE = extern struct {
    Offset: u32,
    Size: u32,
};

pub const XSTATE_CONFIGURATION = extern struct {
    EnabledFeatures: u64,
    EnabledVolatileFeatures: u64,
    Size: u32,
    Anonymous: XSTATE_CONFIGURATION._Anonymous_e__Union,
    Features: [64]XSTATE_FEATURE,
    EnabledSupervisorFeatures: u64,
    AlignedFeatures: u64,
    AllFeatureSize: u32,
    AllFeatures: [64]u32,
    EnabledUserVisibleSupervisorFeatures: u64,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MEMORY_BASIC_INFORMATION = extern struct {
    BaseAddress: *c_void,
    AllocationBase: *c_void,
    AllocationProtect: u32,
    RegionSize: ?*c_void,
    State: u32,
    Protect: u32,
    Type: u32,
};

pub const MEMORY_BASIC_INFORMATION32 = extern struct {
    BaseAddress: u32,
    AllocationBase: u32,
    AllocationProtect: u32,
    RegionSize: u32,
    State: u32,
    Protect: u32,
    Type: u32,
};

pub const MEMORY_BASIC_INFORMATION64 = extern struct {
    BaseAddress: u64,
    AllocationBase: u64,
    AllocationProtect: u32,
    __alignment1: u32,
    RegionSize: u64,
    State: u32,
    Protect: u32,
    Type: u32,
    __alignment2: u32,
};

pub const CFG_CALL_TARGET_INFO = extern struct {
    Offset: ?*c_void,
    Flags: ?*c_void,
};

pub const MEM_ADDRESS_REQUIREMENTS = extern struct {
    LowestStartingAddress: *c_void,
    HighestEndingAddress: *c_void,
    Alignment: ?*c_void,
};

pub const MEM_EXTENDED_PARAMETER_TYPE = extern enum(i32) {
    MemExtendedParameterInvalidType = 0,
    MemExtendedParameterAddressRequirements = 1,
    MemExtendedParameterNumaNode = 2,
    MemExtendedParameterPartitionHandle = 3,
    MemExtendedParameterUserPhysicalHandle = 4,
    MemExtendedParameterAttributeFlags = 5,
    MemExtendedParameterMax = 6,
};
pub const MemExtendedParameterInvalidType = MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterInvalidType;
pub const MemExtendedParameterAddressRequirements = MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterAddressRequirements;
pub const MemExtendedParameterNumaNode = MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterNumaNode;
pub const MemExtendedParameterPartitionHandle = MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterPartitionHandle;
pub const MemExtendedParameterUserPhysicalHandle = MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterUserPhysicalHandle;
pub const MemExtendedParameterAttributeFlags = MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterAttributeFlags;
pub const MemExtendedParameterMax = MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterMax;

pub const MEM_EXTENDED_PARAMETER = extern struct {
    Anonymous1: MEM_EXTENDED_PARAMETER._Anonymous1_e__Struct,
    Anonymous2: MEM_EXTENDED_PARAMETER._Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Struct = u32; // TODO: generate this nested type!
};

pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE = extern enum(i32) {
    MemSectionExtendedParameterInvalidType = 0,
    MemSectionExtendedParameterUserPhysicalFlags = 1,
    MemSectionExtendedParameterNumaNode = 2,
    MemSectionExtendedParameterMax = 3,
};
pub const MemSectionExtendedParameterInvalidType = MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterInvalidType;
pub const MemSectionExtendedParameterUserPhysicalFlags = MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterUserPhysicalFlags;
pub const MemSectionExtendedParameterNumaNode = MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterNumaNode;
pub const MemSectionExtendedParameterMax = MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterMax;

pub const ENCLAVE_CREATE_INFO_SGX = extern struct {
    Secs: [4096]u8,
};

pub const ENCLAVE_INIT_INFO_SGX = extern struct {
    SigStruct: [1808]u8,
    Reserved1: [240]u8,
    EInitToken: [304]u8,
    Reserved2: [1744]u8,
};

pub const ENCLAVE_CREATE_INFO_VBS = extern struct {
    Flags: u32,
    OwnerID: [32]u8,
};

pub const ENCLAVE_CREATE_INFO_VBS_BASIC = extern struct {
    Flags: u32,
    OwnerID: [32]u8,
};

pub const ENCLAVE_LOAD_DATA_VBS_BASIC = extern struct {
    PageType: u32,
};

pub const ENCLAVE_INIT_INFO_VBS_BASIC = extern struct {
    FamilyId: [16]u8,
    ImageId: [16]u8,
    EnclaveSize: u64,
    EnclaveSvn: u32,
    Reserved: u32,
    Anonymous: ENCLAVE_INIT_INFO_VBS_BASIC._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ENCLAVE_INIT_INFO_VBS = extern struct {
    Length: u32,
    ThreadCount: u32,
};

pub const ENCLAVE_TARGET_FUNCTION = fn(
    param0: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PENCLAVE_TARGET_FUNCTION = fn(
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const LPENCLAVE_TARGET_FUNCTION = fn(
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const FILE_SEGMENT_ELEMENT = u32; // TODO: implement StructOrUnion types?

pub const SCRUB_DATA_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    MaximumIos: u32,
    ObjectId: [4]u32,
    Reserved: [25]u32,
    ResumeContext: [816]u8,
};

pub const SCRUB_PARITY_EXTENT = extern struct {
    Offset: i64,
    Length: u64,
};

pub const SCRUB_PARITY_EXTENT_DATA = extern struct {
    Size: u16,
    Flags: u16,
    NumberOfParityExtents: u16,
    MaximumNumberOfParityExtents: u16,
    ParityExtents: [1]SCRUB_PARITY_EXTENT,
};

pub const SCRUB_DATA_OUTPUT = extern struct {
    Size: u32,
    Flags: u32,
    Status: u32,
    ErrorFileOffset: u64,
    ErrorLength: u64,
    NumberOfBytesRepaired: u64,
    NumberOfBytesFailed: u64,
    InternalFileReference: u64,
    ResumeContextLength: u16,
    ParityExtentDataOffset: u16,
    Reserved: [9]u32,
    NumberOfMetadataBytesProcessed: u64,
    NumberOfDataBytesProcessed: u64,
    TotalNumberOfMetadataBytesInUse: u64,
    TotalNumberOfDataBytesInUse: u64,
    ResumeContext: [816]u8,
};

pub const SharedVirtualDiskSupportType = extern enum(i32) {
    SharedVirtualDisksUnsupported = 0,
    SharedVirtualDisksSupported = 1,
    SharedVirtualDiskSnapshotsSupported = 3,
    SharedVirtualDiskCDPSnapshotsSupported = 7,
};
pub const SharedVirtualDisksUnsupported = SharedVirtualDiskSupportType.SharedVirtualDisksUnsupported;
pub const SharedVirtualDisksSupported = SharedVirtualDiskSupportType.SharedVirtualDisksSupported;
pub const SharedVirtualDiskSnapshotsSupported = SharedVirtualDiskSupportType.SharedVirtualDiskSnapshotsSupported;
pub const SharedVirtualDiskCDPSnapshotsSupported = SharedVirtualDiskSupportType.SharedVirtualDiskCDPSnapshotsSupported;

pub const SharedVirtualDiskHandleState = extern enum(i32) {
    SharedVirtualDiskHandleStateNone = 0,
    SharedVirtualDiskHandleStateFileShared = 1,
    SharedVirtualDiskHandleStateHandleShared = 3,
};
pub const SharedVirtualDiskHandleStateNone = SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateNone;
pub const SharedVirtualDiskHandleStateFileShared = SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateFileShared;
pub const SharedVirtualDiskHandleStateHandleShared = SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateHandleShared;

pub const SHARED_VIRTUAL_DISK_SUPPORT = extern struct {
    SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
    HandleState: SharedVirtualDiskHandleState,
};

pub const REARRANGE_FILE_DATA = extern struct {
    SourceStartingOffset: u64,
    TargetOffset: u64,
    SourceFileHandle: HANDLE,
    Length: u32,
    Flags: u32,
};

pub const SHUFFLE_FILE_DATA = extern struct {
    StartingOffset: i64,
    Length: i64,
    Flags: u32,
};

pub const NETWORK_APP_INSTANCE_EA = extern struct {
    AppInstanceID: Guid,
    CsvFlags: u32,
};

pub const SYSTEM_POWER_STATE = extern enum(i32) {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7,
};
pub const PowerSystemUnspecified = SYSTEM_POWER_STATE.PowerSystemUnspecified;
pub const PowerSystemWorking = SYSTEM_POWER_STATE.PowerSystemWorking;
pub const PowerSystemSleeping1 = SYSTEM_POWER_STATE.PowerSystemSleeping1;
pub const PowerSystemSleeping2 = SYSTEM_POWER_STATE.PowerSystemSleeping2;
pub const PowerSystemSleeping3 = SYSTEM_POWER_STATE.PowerSystemSleeping3;
pub const PowerSystemHibernate = SYSTEM_POWER_STATE.PowerSystemHibernate;
pub const PowerSystemShutdown = SYSTEM_POWER_STATE.PowerSystemShutdown;
pub const PowerSystemMaximum = SYSTEM_POWER_STATE.PowerSystemMaximum;

pub const POWER_ACTION = extern enum(i32) {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7,
    PowerActionDisplayOff = 8,
};
pub const PowerActionNone = POWER_ACTION.PowerActionNone;
pub const PowerActionReserved = POWER_ACTION.PowerActionReserved;
pub const PowerActionSleep = POWER_ACTION.PowerActionSleep;
pub const PowerActionHibernate = POWER_ACTION.PowerActionHibernate;
pub const PowerActionShutdown = POWER_ACTION.PowerActionShutdown;
pub const PowerActionShutdownReset = POWER_ACTION.PowerActionShutdownReset;
pub const PowerActionShutdownOff = POWER_ACTION.PowerActionShutdownOff;
pub const PowerActionWarmEject = POWER_ACTION.PowerActionWarmEject;
pub const PowerActionDisplayOff = POWER_ACTION.PowerActionDisplayOff;

pub const DEVICE_POWER_STATE = extern enum(i32) {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5,
};
pub const PowerDeviceUnspecified = DEVICE_POWER_STATE.PowerDeviceUnspecified;
pub const PowerDeviceD0 = DEVICE_POWER_STATE.PowerDeviceD0;
pub const PowerDeviceD1 = DEVICE_POWER_STATE.PowerDeviceD1;
pub const PowerDeviceD2 = DEVICE_POWER_STATE.PowerDeviceD2;
pub const PowerDeviceD3 = DEVICE_POWER_STATE.PowerDeviceD3;
pub const PowerDeviceMaximum = DEVICE_POWER_STATE.PowerDeviceMaximum;

pub const MONITOR_DISPLAY_STATE = extern enum(i32) {
    PowerMonitorOff = 0,
    PowerMonitorOn = 1,
    PowerMonitorDim = 2,
};
pub const PowerMonitorOff = MONITOR_DISPLAY_STATE.PowerMonitorOff;
pub const PowerMonitorOn = MONITOR_DISPLAY_STATE.PowerMonitorOn;
pub const PowerMonitorDim = MONITOR_DISPLAY_STATE.PowerMonitorDim;

pub const USER_ACTIVITY_PRESENCE = extern enum(i32) {
    PowerUserPresent = 0,
    PowerUserNotPresent = 1,
    PowerUserInactive = 2,
    PowerUserMaximum = 3,
    PowerUserInvalid = 3,
};
pub const PowerUserPresent = USER_ACTIVITY_PRESENCE.PowerUserPresent;
pub const PowerUserNotPresent = USER_ACTIVITY_PRESENCE.PowerUserNotPresent;
pub const PowerUserInactive = USER_ACTIVITY_PRESENCE.PowerUserInactive;
pub const PowerUserMaximum = USER_ACTIVITY_PRESENCE.PowerUserMaximum;
pub const PowerUserInvalid = USER_ACTIVITY_PRESENCE.PowerUserInvalid;

pub const LATENCY_TIME = extern enum(i32) {
    LT_DONT_CARE = 0,
    LT_LOWEST_LATENCY = 1,
};
pub const LT_DONT_CARE = LATENCY_TIME.LT_DONT_CARE;
pub const LT_LOWEST_LATENCY = LATENCY_TIME.LT_LOWEST_LATENCY;

pub const POWER_REQUEST_TYPE = extern enum(i32) {
    PowerRequestDisplayRequired = 0,
    PowerRequestSystemRequired = 1,
    PowerRequestAwayModeRequired = 2,
    PowerRequestExecutionRequired = 3,
};
pub const PowerRequestDisplayRequired = POWER_REQUEST_TYPE.PowerRequestDisplayRequired;
pub const PowerRequestSystemRequired = POWER_REQUEST_TYPE.PowerRequestSystemRequired;
pub const PowerRequestAwayModeRequired = POWER_REQUEST_TYPE.PowerRequestAwayModeRequired;
pub const PowerRequestExecutionRequired = POWER_REQUEST_TYPE.PowerRequestExecutionRequired;

pub const CM_Power_Data_s = extern struct {
    PD_Size: u32,
    PD_MostRecentPowerState: DEVICE_POWER_STATE,
    PD_Capabilities: u32,
    PD_D1Latency: u32,
    PD_D2Latency: u32,
    PD_D3Latency: u32,
    PD_PowerStateMapping: [7]DEVICE_POWER_STATE,
    PD_DeepestSystemWake: SYSTEM_POWER_STATE,
};

pub const POWER_INFORMATION_LEVEL = extern enum(i32) {
    SystemPowerPolicyAc = 0,
    SystemPowerPolicyDc = 1,
    VerifySystemPolicyAc = 2,
    VerifySystemPolicyDc = 3,
    SystemPowerCapabilities = 4,
    SystemBatteryState = 5,
    SystemPowerStateHandler = 6,
    ProcessorStateHandler = 7,
    SystemPowerPolicyCurrent = 8,
    AdministratorPowerPolicy = 9,
    SystemReserveHiberFile = 10,
    ProcessorInformation = 11,
    SystemPowerInformation = 12,
    ProcessorStateHandler2 = 13,
    LastWakeTime = 14,
    LastSleepTime = 15,
    SystemExecutionState = 16,
    SystemPowerStateNotifyHandler = 17,
    ProcessorPowerPolicyAc = 18,
    ProcessorPowerPolicyDc = 19,
    VerifyProcessorPowerPolicyAc = 20,
    VerifyProcessorPowerPolicyDc = 21,
    ProcessorPowerPolicyCurrent = 22,
    SystemPowerStateLogging = 23,
    SystemPowerLoggingEntry = 24,
    SetPowerSettingValue = 25,
    NotifyUserPowerSetting = 26,
    PowerInformationLevelUnused0 = 27,
    SystemMonitorHiberBootPowerOff = 28,
    SystemVideoState = 29,
    TraceApplicationPowerMessage = 30,
    TraceApplicationPowerMessageEnd = 31,
    ProcessorPerfStates = 32,
    ProcessorIdleStates = 33,
    ProcessorCap = 34,
    SystemWakeSource = 35,
    SystemHiberFileInformation = 36,
    TraceServicePowerMessage = 37,
    ProcessorLoad = 38,
    PowerShutdownNotification = 39,
    MonitorCapabilities = 40,
    SessionPowerInit = 41,
    SessionDisplayState = 42,
    PowerRequestCreate = 43,
    PowerRequestAction = 44,
    GetPowerRequestList = 45,
    ProcessorInformationEx = 46,
    NotifyUserModeLegacyPowerEvent = 47,
    GroupPark = 48,
    ProcessorIdleDomains = 49,
    WakeTimerList = 50,
    SystemHiberFileSize = 51,
    ProcessorIdleStatesHv = 52,
    ProcessorPerfStatesHv = 53,
    ProcessorPerfCapHv = 54,
    ProcessorSetIdle = 55,
    LogicalProcessorIdling = 56,
    UserPresence = 57,
    PowerSettingNotificationName = 58,
    GetPowerSettingValue = 59,
    IdleResiliency = 60,
    SessionRITState = 61,
    SessionConnectNotification = 62,
    SessionPowerCleanup = 63,
    SessionLockState = 64,
    SystemHiberbootState = 65,
    PlatformInformation = 66,
    PdcInvocation = 67,
    MonitorInvocation = 68,
    FirmwareTableInformationRegistered = 69,
    SetShutdownSelectedTime = 70,
    SuspendResumeInvocation = 71,
    PlmPowerRequestCreate = 72,
    ScreenOff = 73,
    CsDeviceNotification = 74,
    PlatformRole = 75,
    LastResumePerformance = 76,
    DisplayBurst = 77,
    ExitLatencySamplingPercentage = 78,
    RegisterSpmPowerSettings = 79,
    PlatformIdleStates = 80,
    ProcessorIdleVeto = 81,
    PlatformIdleVeto = 82,
    SystemBatteryStatePrecise = 83,
    ThermalEvent = 84,
    PowerRequestActionInternal = 85,
    BatteryDeviceState = 86,
    PowerInformationInternal = 87,
    ThermalStandby = 88,
    SystemHiberFileType = 89,
    PhysicalPowerButtonPress = 90,
    QueryPotentialDripsConstraint = 91,
    EnergyTrackerCreate = 92,
    EnergyTrackerQuery = 93,
    UpdateBlackBoxRecorder = 94,
    SessionAllowExternalDmaDevices = 95,
    PowerInformationLevelMaximum = 96,
};
pub const SystemPowerPolicyAc = POWER_INFORMATION_LEVEL.SystemPowerPolicyAc;
pub const SystemPowerPolicyDc = POWER_INFORMATION_LEVEL.SystemPowerPolicyDc;
pub const VerifySystemPolicyAc = POWER_INFORMATION_LEVEL.VerifySystemPolicyAc;
pub const VerifySystemPolicyDc = POWER_INFORMATION_LEVEL.VerifySystemPolicyDc;
pub const SystemPowerCapabilities = POWER_INFORMATION_LEVEL.SystemPowerCapabilities;
pub const SystemBatteryState = POWER_INFORMATION_LEVEL.SystemBatteryState;
pub const SystemPowerStateHandler = POWER_INFORMATION_LEVEL.SystemPowerStateHandler;
pub const ProcessorStateHandler = POWER_INFORMATION_LEVEL.ProcessorStateHandler;
pub const SystemPowerPolicyCurrent = POWER_INFORMATION_LEVEL.SystemPowerPolicyCurrent;
pub const AdministratorPowerPolicy = POWER_INFORMATION_LEVEL.AdministratorPowerPolicy;
pub const SystemReserveHiberFile = POWER_INFORMATION_LEVEL.SystemReserveHiberFile;
pub const ProcessorInformation = POWER_INFORMATION_LEVEL.ProcessorInformation;
pub const SystemPowerInformation = POWER_INFORMATION_LEVEL.SystemPowerInformation;
pub const ProcessorStateHandler2 = POWER_INFORMATION_LEVEL.ProcessorStateHandler2;
pub const LastWakeTime = POWER_INFORMATION_LEVEL.LastWakeTime;
pub const LastSleepTime = POWER_INFORMATION_LEVEL.LastSleepTime;
pub const SystemExecutionState = POWER_INFORMATION_LEVEL.SystemExecutionState;
pub const SystemPowerStateNotifyHandler = POWER_INFORMATION_LEVEL.SystemPowerStateNotifyHandler;
pub const ProcessorPowerPolicyAc = POWER_INFORMATION_LEVEL.ProcessorPowerPolicyAc;
pub const ProcessorPowerPolicyDc = POWER_INFORMATION_LEVEL.ProcessorPowerPolicyDc;
pub const VerifyProcessorPowerPolicyAc = POWER_INFORMATION_LEVEL.VerifyProcessorPowerPolicyAc;
pub const VerifyProcessorPowerPolicyDc = POWER_INFORMATION_LEVEL.VerifyProcessorPowerPolicyDc;
pub const ProcessorPowerPolicyCurrent = POWER_INFORMATION_LEVEL.ProcessorPowerPolicyCurrent;
pub const SystemPowerStateLogging = POWER_INFORMATION_LEVEL.SystemPowerStateLogging;
pub const SystemPowerLoggingEntry = POWER_INFORMATION_LEVEL.SystemPowerLoggingEntry;
pub const SetPowerSettingValue = POWER_INFORMATION_LEVEL.SetPowerSettingValue;
pub const NotifyUserPowerSetting = POWER_INFORMATION_LEVEL.NotifyUserPowerSetting;
pub const PowerInformationLevelUnused0 = POWER_INFORMATION_LEVEL.PowerInformationLevelUnused0;
pub const SystemMonitorHiberBootPowerOff = POWER_INFORMATION_LEVEL.SystemMonitorHiberBootPowerOff;
pub const SystemVideoState = POWER_INFORMATION_LEVEL.SystemVideoState;
pub const TraceApplicationPowerMessage = POWER_INFORMATION_LEVEL.TraceApplicationPowerMessage;
pub const TraceApplicationPowerMessageEnd = POWER_INFORMATION_LEVEL.TraceApplicationPowerMessageEnd;
pub const ProcessorPerfStates = POWER_INFORMATION_LEVEL.ProcessorPerfStates;
pub const ProcessorIdleStates = POWER_INFORMATION_LEVEL.ProcessorIdleStates;
pub const ProcessorCap = POWER_INFORMATION_LEVEL.ProcessorCap;
pub const SystemWakeSource = POWER_INFORMATION_LEVEL.SystemWakeSource;
pub const SystemHiberFileInformation = POWER_INFORMATION_LEVEL.SystemHiberFileInformation;
pub const TraceServicePowerMessage = POWER_INFORMATION_LEVEL.TraceServicePowerMessage;
pub const ProcessorLoad = POWER_INFORMATION_LEVEL.ProcessorLoad;
pub const PowerShutdownNotification = POWER_INFORMATION_LEVEL.PowerShutdownNotification;
pub const MonitorCapabilities = POWER_INFORMATION_LEVEL.MonitorCapabilities;
pub const SessionPowerInit = POWER_INFORMATION_LEVEL.SessionPowerInit;
pub const SessionDisplayState = POWER_INFORMATION_LEVEL.SessionDisplayState;
pub const PowerRequestCreate = POWER_INFORMATION_LEVEL.PowerRequestCreate;
pub const PowerRequestAction = POWER_INFORMATION_LEVEL.PowerRequestAction;
pub const GetPowerRequestList = POWER_INFORMATION_LEVEL.GetPowerRequestList;
pub const ProcessorInformationEx = POWER_INFORMATION_LEVEL.ProcessorInformationEx;
pub const NotifyUserModeLegacyPowerEvent = POWER_INFORMATION_LEVEL.NotifyUserModeLegacyPowerEvent;
pub const GroupPark = POWER_INFORMATION_LEVEL.GroupPark;
pub const ProcessorIdleDomains = POWER_INFORMATION_LEVEL.ProcessorIdleDomains;
pub const WakeTimerList = POWER_INFORMATION_LEVEL.WakeTimerList;
pub const SystemHiberFileSize = POWER_INFORMATION_LEVEL.SystemHiberFileSize;
pub const ProcessorIdleStatesHv = POWER_INFORMATION_LEVEL.ProcessorIdleStatesHv;
pub const ProcessorPerfStatesHv = POWER_INFORMATION_LEVEL.ProcessorPerfStatesHv;
pub const ProcessorPerfCapHv = POWER_INFORMATION_LEVEL.ProcessorPerfCapHv;
pub const ProcessorSetIdle = POWER_INFORMATION_LEVEL.ProcessorSetIdle;
pub const LogicalProcessorIdling = POWER_INFORMATION_LEVEL.LogicalProcessorIdling;
pub const UserPresence = POWER_INFORMATION_LEVEL.UserPresence;
pub const PowerSettingNotificationName = POWER_INFORMATION_LEVEL.PowerSettingNotificationName;
pub const GetPowerSettingValue = POWER_INFORMATION_LEVEL.GetPowerSettingValue;
pub const IdleResiliency = POWER_INFORMATION_LEVEL.IdleResiliency;
pub const SessionRITState = POWER_INFORMATION_LEVEL.SessionRITState;
pub const SessionConnectNotification = POWER_INFORMATION_LEVEL.SessionConnectNotification;
pub const SessionPowerCleanup = POWER_INFORMATION_LEVEL.SessionPowerCleanup;
pub const SessionLockState = POWER_INFORMATION_LEVEL.SessionLockState;
pub const SystemHiberbootState = POWER_INFORMATION_LEVEL.SystemHiberbootState;
pub const PlatformInformation = POWER_INFORMATION_LEVEL.PlatformInformation;
pub const PdcInvocation = POWER_INFORMATION_LEVEL.PdcInvocation;
pub const MonitorInvocation = POWER_INFORMATION_LEVEL.MonitorInvocation;
pub const FirmwareTableInformationRegistered = POWER_INFORMATION_LEVEL.FirmwareTableInformationRegistered;
pub const SetShutdownSelectedTime = POWER_INFORMATION_LEVEL.SetShutdownSelectedTime;
pub const SuspendResumeInvocation = POWER_INFORMATION_LEVEL.SuspendResumeInvocation;
pub const PlmPowerRequestCreate = POWER_INFORMATION_LEVEL.PlmPowerRequestCreate;
pub const ScreenOff = POWER_INFORMATION_LEVEL.ScreenOff;
pub const CsDeviceNotification = POWER_INFORMATION_LEVEL.CsDeviceNotification;
pub const PlatformRole = POWER_INFORMATION_LEVEL.PlatformRole;
pub const LastResumePerformance = POWER_INFORMATION_LEVEL.LastResumePerformance;
pub const DisplayBurst = POWER_INFORMATION_LEVEL.DisplayBurst;
pub const ExitLatencySamplingPercentage = POWER_INFORMATION_LEVEL.ExitLatencySamplingPercentage;
pub const RegisterSpmPowerSettings = POWER_INFORMATION_LEVEL.RegisterSpmPowerSettings;
pub const PlatformIdleStates = POWER_INFORMATION_LEVEL.PlatformIdleStates;
pub const ProcessorIdleVeto = POWER_INFORMATION_LEVEL.ProcessorIdleVeto;
pub const PlatformIdleVeto = POWER_INFORMATION_LEVEL.PlatformIdleVeto;
pub const SystemBatteryStatePrecise = POWER_INFORMATION_LEVEL.SystemBatteryStatePrecise;
pub const ThermalEvent = POWER_INFORMATION_LEVEL.ThermalEvent;
pub const PowerRequestActionInternal = POWER_INFORMATION_LEVEL.PowerRequestActionInternal;
pub const BatteryDeviceState = POWER_INFORMATION_LEVEL.BatteryDeviceState;
pub const PowerInformationInternal = POWER_INFORMATION_LEVEL.PowerInformationInternal;
pub const ThermalStandby = POWER_INFORMATION_LEVEL.ThermalStandby;
pub const SystemHiberFileType = POWER_INFORMATION_LEVEL.SystemHiberFileType;
pub const PhysicalPowerButtonPress = POWER_INFORMATION_LEVEL.PhysicalPowerButtonPress;
pub const QueryPotentialDripsConstraint = POWER_INFORMATION_LEVEL.QueryPotentialDripsConstraint;
pub const EnergyTrackerCreate = POWER_INFORMATION_LEVEL.EnergyTrackerCreate;
pub const EnergyTrackerQuery = POWER_INFORMATION_LEVEL.EnergyTrackerQuery;
pub const UpdateBlackBoxRecorder = POWER_INFORMATION_LEVEL.UpdateBlackBoxRecorder;
pub const SessionAllowExternalDmaDevices = POWER_INFORMATION_LEVEL.SessionAllowExternalDmaDevices;
pub const PowerInformationLevelMaximum = POWER_INFORMATION_LEVEL.PowerInformationLevelMaximum;

pub const POWER_USER_PRESENCE_TYPE = extern enum(i32) {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 255,
};
pub const UserNotPresent = POWER_USER_PRESENCE_TYPE.UserNotPresent;
pub const UserPresent = POWER_USER_PRESENCE_TYPE.UserPresent;
pub const UserUnknown = POWER_USER_PRESENCE_TYPE.UserUnknown;

pub const POWER_USER_PRESENCE = extern struct {
    UserPresence: POWER_USER_PRESENCE_TYPE,
};

pub const POWER_SESSION_CONNECT = extern struct {
    Connected: u8,
    Console: u8,
};

pub const POWER_SESSION_TIMEOUTS = extern struct {
    InputTimeout: u32,
    DisplayTimeout: u32,
};

pub const POWER_SESSION_RIT_STATE = extern struct {
    Active: u8,
    LastInputTime: u32,
};

pub const POWER_SESSION_WINLOGON = extern struct {
    SessionId: u32,
    Console: u8,
    Locked: u8,
};

pub const POWER_SESSION_ALLOW_EXTERNAL_DMA_DEVICES = extern struct {
    IsAllowed: u8,
};

pub const POWER_IDLE_RESILIENCY = extern struct {
    CoalescingTimeout: u32,
    IdleResiliencyPeriod: u32,
};

pub const POWER_MONITOR_REQUEST_REASON = extern enum(i32) {
    MonitorRequestReasonUnknown = 0,
    MonitorRequestReasonPowerButton = 1,
    MonitorRequestReasonRemoteConnection = 2,
    MonitorRequestReasonScMonitorpower = 3,
    MonitorRequestReasonUserInput = 4,
    MonitorRequestReasonAcDcDisplayBurst = 5,
    MonitorRequestReasonUserDisplayBurst = 6,
    MonitorRequestReasonPoSetSystemState = 7,
    MonitorRequestReasonSetThreadExecutionState = 8,
    MonitorRequestReasonFullWake = 9,
    MonitorRequestReasonSessionUnlock = 10,
    MonitorRequestReasonScreenOffRequest = 11,
    MonitorRequestReasonIdleTimeout = 12,
    MonitorRequestReasonPolicyChange = 13,
    MonitorRequestReasonSleepButton = 14,
    MonitorRequestReasonLid = 15,
    MonitorRequestReasonBatteryCountChange = 16,
    MonitorRequestReasonGracePeriod = 17,
    MonitorRequestReasonPnP = 18,
    MonitorRequestReasonDP = 19,
    MonitorRequestReasonSxTransition = 20,
    MonitorRequestReasonSystemIdle = 21,
    MonitorRequestReasonNearProximity = 22,
    MonitorRequestReasonThermalStandby = 23,
    MonitorRequestReasonResumePdc = 24,
    MonitorRequestReasonResumeS4 = 25,
    MonitorRequestReasonTerminal = 26,
    MonitorRequestReasonPdcSignal = 27,
    MonitorRequestReasonAcDcDisplayBurstSuppressed = 28,
    MonitorRequestReasonSystemStateEntered = 29,
    MonitorRequestReasonWinrt = 30,
    MonitorRequestReasonUserInputKeyboard = 31,
    MonitorRequestReasonUserInputMouse = 32,
    MonitorRequestReasonUserInputTouch = 33,
    MonitorRequestReasonUserInputPen = 34,
    MonitorRequestReasonUserInputAccelerometer = 35,
    MonitorRequestReasonUserInputHid = 36,
    MonitorRequestReasonUserInputPoUserPresent = 37,
    MonitorRequestReasonUserInputSessionSwitch = 38,
    MonitorRequestReasonUserInputInitialization = 39,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = 40,
    MonitorRequestReasonPdcSignalWindowsMobileShell = 41,
    MonitorRequestReasonPdcSignalHeyCortana = 42,
    MonitorRequestReasonPdcSignalHolographicShell = 43,
    MonitorRequestReasonPdcSignalFingerprint = 44,
    MonitorRequestReasonDirectedDrips = 45,
    MonitorRequestReasonDim = 46,
    MonitorRequestReasonBuiltinPanel = 47,
    MonitorRequestReasonDisplayRequiredUnDim = 48,
    MonitorRequestReasonBatteryCountChangeSuppressed = 49,
    MonitorRequestReasonResumeModernStandby = 50,
    MonitorRequestReasonMax = 51,
};
pub const MonitorRequestReasonUnknown = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUnknown;
pub const MonitorRequestReasonPowerButton = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPowerButton;
pub const MonitorRequestReasonRemoteConnection = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonRemoteConnection;
pub const MonitorRequestReasonScMonitorpower = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonScMonitorpower;
pub const MonitorRequestReasonUserInput = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInput;
pub const MonitorRequestReasonAcDcDisplayBurst = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonAcDcDisplayBurst;
pub const MonitorRequestReasonUserDisplayBurst = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserDisplayBurst;
pub const MonitorRequestReasonPoSetSystemState = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPoSetSystemState;
pub const MonitorRequestReasonSetThreadExecutionState = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSetThreadExecutionState;
pub const MonitorRequestReasonFullWake = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonFullWake;
pub const MonitorRequestReasonSessionUnlock = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSessionUnlock;
pub const MonitorRequestReasonScreenOffRequest = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonScreenOffRequest;
pub const MonitorRequestReasonIdleTimeout = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonIdleTimeout;
pub const MonitorRequestReasonPolicyChange = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPolicyChange;
pub const MonitorRequestReasonSleepButton = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSleepButton;
pub const MonitorRequestReasonLid = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonLid;
pub const MonitorRequestReasonBatteryCountChange = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonBatteryCountChange;
pub const MonitorRequestReasonGracePeriod = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonGracePeriod;
pub const MonitorRequestReasonPnP = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPnP;
pub const MonitorRequestReasonDP = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonDP;
pub const MonitorRequestReasonSxTransition = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSxTransition;
pub const MonitorRequestReasonSystemIdle = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSystemIdle;
pub const MonitorRequestReasonNearProximity = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonNearProximity;
pub const MonitorRequestReasonThermalStandby = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonThermalStandby;
pub const MonitorRequestReasonResumePdc = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonResumePdc;
pub const MonitorRequestReasonResumeS4 = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonResumeS4;
pub const MonitorRequestReasonTerminal = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonTerminal;
pub const MonitorRequestReasonPdcSignal = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignal;
pub const MonitorRequestReasonAcDcDisplayBurstSuppressed = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonAcDcDisplayBurstSuppressed;
pub const MonitorRequestReasonSystemStateEntered = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonSystemStateEntered;
pub const MonitorRequestReasonWinrt = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonWinrt;
pub const MonitorRequestReasonUserInputKeyboard = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputKeyboard;
pub const MonitorRequestReasonUserInputMouse = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputMouse;
pub const MonitorRequestReasonUserInputTouch = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputTouch;
pub const MonitorRequestReasonUserInputPen = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputPen;
pub const MonitorRequestReasonUserInputAccelerometer = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputAccelerometer;
pub const MonitorRequestReasonUserInputHid = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputHid;
pub const MonitorRequestReasonUserInputPoUserPresent = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputPoUserPresent;
pub const MonitorRequestReasonUserInputSessionSwitch = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputSessionSwitch;
pub const MonitorRequestReasonUserInputInitialization = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonUserInputInitialization;
pub const MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalWindowsMobilePwrNotif;
pub const MonitorRequestReasonPdcSignalWindowsMobileShell = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalWindowsMobileShell;
pub const MonitorRequestReasonPdcSignalHeyCortana = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalHeyCortana;
pub const MonitorRequestReasonPdcSignalHolographicShell = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalHolographicShell;
pub const MonitorRequestReasonPdcSignalFingerprint = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonPdcSignalFingerprint;
pub const MonitorRequestReasonDirectedDrips = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonDirectedDrips;
pub const MonitorRequestReasonDim = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonDim;
pub const MonitorRequestReasonBuiltinPanel = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonBuiltinPanel;
pub const MonitorRequestReasonDisplayRequiredUnDim = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonDisplayRequiredUnDim;
pub const MonitorRequestReasonBatteryCountChangeSuppressed = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonBatteryCountChangeSuppressed;
pub const MonitorRequestReasonResumeModernStandby = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonResumeModernStandby;
pub const MonitorRequestReasonMax = POWER_MONITOR_REQUEST_REASON.MonitorRequestReasonMax;

pub const POWER_MONITOR_REQUEST_TYPE = extern enum(i32) {
    MonitorRequestTypeOff = 0,
    MonitorRequestTypeOnAndPresent = 1,
    MonitorRequestTypeToggleOn = 2,
};
pub const MonitorRequestTypeOff = POWER_MONITOR_REQUEST_TYPE.MonitorRequestTypeOff;
pub const MonitorRequestTypeOnAndPresent = POWER_MONITOR_REQUEST_TYPE.MonitorRequestTypeOnAndPresent;
pub const MonitorRequestTypeToggleOn = POWER_MONITOR_REQUEST_TYPE.MonitorRequestTypeToggleOn;

pub const POWER_MONITOR_INVOCATION = extern struct {
    Console: u8,
    RequestReason: POWER_MONITOR_REQUEST_REASON,
};

pub const RESUME_PERFORMANCE = extern struct {
    PostTimeMs: u32,
    TotalResumeTimeMs: u64,
    ResumeCompleteTimestamp: u64,
};

pub const SYSTEM_POWER_CONDITION = extern enum(i32) {
    PoAc = 0,
    PoDc = 1,
    PoHot = 2,
    PoConditionMaximum = 3,
};
pub const PoAc = SYSTEM_POWER_CONDITION.PoAc;
pub const PoDc = SYSTEM_POWER_CONDITION.PoDc;
pub const PoHot = SYSTEM_POWER_CONDITION.PoHot;
pub const PoConditionMaximum = SYSTEM_POWER_CONDITION.PoConditionMaximum;

pub const SET_POWER_SETTING_VALUE = extern struct {
    Version: u32,
    Guid: Guid,
    PowerCondition: SYSTEM_POWER_CONDITION,
    DataLength: u32,
    Data: [1]u8,
};

pub const NOTIFY_USER_POWER_SETTING = extern struct {
    Guid: Guid,
};

pub const APPLICATIONLAUNCH_SETTING_VALUE = extern struct {
    ActivationTime: LARGE_INTEGER,
    Flags: u32,
    ButtonInstanceID: u32,
};

pub const POWER_PLATFORM_ROLE = extern enum(i32) {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop = 1,
    PlatformRoleMobile = 2,
    PlatformRoleWorkstation = 3,
    PlatformRoleEnterpriseServer = 4,
    PlatformRoleSOHOServer = 5,
    PlatformRoleAppliancePC = 6,
    PlatformRolePerformanceServer = 7,
    PlatformRoleSlate = 8,
    PlatformRoleMaximum = 9,
};
pub const PlatformRoleUnspecified = POWER_PLATFORM_ROLE.PlatformRoleUnspecified;
pub const PlatformRoleDesktop = POWER_PLATFORM_ROLE.PlatformRoleDesktop;
pub const PlatformRoleMobile = POWER_PLATFORM_ROLE.PlatformRoleMobile;
pub const PlatformRoleWorkstation = POWER_PLATFORM_ROLE.PlatformRoleWorkstation;
pub const PlatformRoleEnterpriseServer = POWER_PLATFORM_ROLE.PlatformRoleEnterpriseServer;
pub const PlatformRoleSOHOServer = POWER_PLATFORM_ROLE.PlatformRoleSOHOServer;
pub const PlatformRoleAppliancePC = POWER_PLATFORM_ROLE.PlatformRoleAppliancePC;
pub const PlatformRolePerformanceServer = POWER_PLATFORM_ROLE.PlatformRolePerformanceServer;
pub const PlatformRoleSlate = POWER_PLATFORM_ROLE.PlatformRoleSlate;
pub const PlatformRoleMaximum = POWER_PLATFORM_ROLE.PlatformRoleMaximum;

pub const POWER_PLATFORM_INFORMATION = extern struct {
    AoAc: u8,
};

pub const BATTERY_REPORTING_SCALE = extern struct {
    Granularity: u32,
    Capacity: u32,
};

pub const PPM_WMI_LEGACY_PERFSTATE = extern struct {
    Frequency: u32,
    Flags: u32,
    PercentFrequency: u32,
};

pub const PPM_WMI_IDLE_STATE = extern struct {
    Latency: u32,
    Power: u32,
    TimeCheck: u32,
    PromotePercent: u8,
    DemotePercent: u8,
    StateType: u8,
    Reserved: u8,
    StateFlags: u32,
    Context: u32,
    IdleHandler: u32,
    Reserved1: u32,
};

pub const PPM_WMI_IDLE_STATES = extern struct {
    Type: u32,
    Count: u32,
    TargetState: u32,
    OldState: u32,
    TargetProcessors: u64,
    State: [1]PPM_WMI_IDLE_STATE,
};

pub const PPM_WMI_IDLE_STATES_EX = extern struct {
    Type: u32,
    Count: u32,
    TargetState: u32,
    OldState: u32,
    TargetProcessors: *c_void,
    State: [1]PPM_WMI_IDLE_STATE,
};

pub const PPM_WMI_PERF_STATE = extern struct {
    Frequency: u32,
    Power: u32,
    PercentFrequency: u8,
    IncreaseLevel: u8,
    DecreaseLevel: u8,
    Type: u8,
    IncreaseTime: u32,
    DecreaseTime: u32,
    Control: u64,
    Status: u64,
    HitCount: u32,
    Reserved1: u32,
    Reserved2: u64,
    Reserved3: u64,
};

pub const PPM_WMI_PERF_STATES = extern struct {
    Count: u32,
    MaxFrequency: u32,
    CurrentState: u32,
    MaxPerfState: u32,
    MinPerfState: u32,
    LowestPerfState: u32,
    ThermalConstraint: u32,
    BusyAdjThreshold: u8,
    PolicyType: u8,
    Type: u8,
    Reserved: u8,
    TimerInterval: u32,
    TargetProcessors: u64,
    PStateHandler: u32,
    PStateContext: u32,
    TStateHandler: u32,
    TStateContext: u32,
    FeedbackHandler: u32,
    Reserved1: u32,
    Reserved2: u64,
    State: [1]PPM_WMI_PERF_STATE,
};

pub const PPM_WMI_PERF_STATES_EX = extern struct {
    Count: u32,
    MaxFrequency: u32,
    CurrentState: u32,
    MaxPerfState: u32,
    MinPerfState: u32,
    LowestPerfState: u32,
    ThermalConstraint: u32,
    BusyAdjThreshold: u8,
    PolicyType: u8,
    Type: u8,
    Reserved: u8,
    TimerInterval: u32,
    TargetProcessors: *c_void,
    PStateHandler: u32,
    PStateContext: u32,
    TStateHandler: u32,
    TStateContext: u32,
    FeedbackHandler: u32,
    Reserved1: u32,
    Reserved2: u64,
    State: [1]PPM_WMI_PERF_STATE,
};

pub const PPM_IDLE_STATE_ACCOUNTING = extern struct {
    IdleTransitions: u32,
    FailedTransitions: u32,
    InvalidBucketIndex: u32,
    TotalTime: u64,
    IdleTimeBuckets: [6]u32,
};

pub const PPM_IDLE_ACCOUNTING = extern struct {
    StateCount: u32,
    TotalTransitions: u32,
    ResetCount: u32,
    StartTime: u64,
    State: [1]PPM_IDLE_STATE_ACCOUNTING,
};

pub const PPM_IDLE_STATE_BUCKET_EX = extern struct {
    TotalTimeUs: u64,
    MinTimeUs: u32,
    MaxTimeUs: u32,
    Count: u32,
};

pub const PPM_IDLE_STATE_ACCOUNTING_EX = extern struct {
    TotalTime: u64,
    IdleTransitions: u32,
    FailedTransitions: u32,
    InvalidBucketIndex: u32,
    MinTimeUs: u32,
    MaxTimeUs: u32,
    CancelledTransitions: u32,
    IdleTimeBuckets: [16]PPM_IDLE_STATE_BUCKET_EX,
};

pub const PPM_IDLE_ACCOUNTING_EX = extern struct {
    StateCount: u32,
    TotalTransitions: u32,
    ResetCount: u32,
    AbortCount: u32,
    StartTime: u64,
    State: [1]PPM_IDLE_STATE_ACCOUNTING_EX,
};

pub const PPM_PERFSTATE_EVENT = extern struct {
    State: u32,
    Status: u32,
    Latency: u32,
    Speed: u32,
    Processor: u32,
};

pub const PPM_PERFSTATE_DOMAIN_EVENT = extern struct {
    State: u32,
    Latency: u32,
    Speed: u32,
    Processors: u64,
};

pub const PPM_IDLESTATE_EVENT = extern struct {
    NewState: u32,
    OldState: u32,
    Processors: u64,
};

pub const PPM_THERMALCHANGE_EVENT = extern struct {
    ThermalConstraint: u32,
    Processors: u64,
};

pub const PPM_THERMAL_POLICY_EVENT = extern struct {
    Mode: u8,
    Processors: u64,
};

pub const POWER_ACTION_POLICY = extern struct {
    Action: POWER_ACTION,
    Flags: u32,
    EventCode: u32,
};

pub const SYSTEM_POWER_LEVEL = extern struct {
    Enable: u8,
    Spare: [3]u8,
    BatteryLevel: u32,
    PowerPolicy: POWER_ACTION_POLICY,
    MinSystemState: SYSTEM_POWER_STATE,
};

pub const SYSTEM_POWER_POLICY = extern struct {
    Revision: u32,
    PowerButton: POWER_ACTION_POLICY,
    SleepButton: POWER_ACTION_POLICY,
    LidClose: POWER_ACTION_POLICY,
    LidOpenWake: SYSTEM_POWER_STATE,
    Reserved: u32,
    Idle: POWER_ACTION_POLICY,
    IdleTimeout: u32,
    IdleSensitivity: u8,
    DynamicThrottle: u8,
    Spare2: [2]u8,
    MinSleep: SYSTEM_POWER_STATE,
    MaxSleep: SYSTEM_POWER_STATE,
    ReducedLatencySleep: SYSTEM_POWER_STATE,
    WinLogonFlags: u32,
    Spare3: u32,
    DozeS4Timeout: u32,
    BroadcastCapacityResolution: u32,
    DischargePolicy: [4]SYSTEM_POWER_LEVEL,
    VideoTimeout: u32,
    VideoDimDisplay: u8,
    VideoReserved: [3]u32,
    SpindownTimeout: u32,
    OptimizeForPower: u8,
    FanThrottleTolerance: u8,
    ForcedThrottle: u8,
    MinThrottle: u8,
    OverThrottled: POWER_ACTION_POLICY,
};

pub const PROCESSOR_IDLESTATE_INFO = extern struct {
    TimeCheck: u32,
    DemotePercent: u8,
    PromotePercent: u8,
    Spare: [2]u8,
};

pub const PROCESSOR_IDLESTATE_POLICY = extern struct {
    Revision: u16,
    Flags: PROCESSOR_IDLESTATE_POLICY._Flags_e__Union,
    PolicyCount: u32,
    Policy: [3]PROCESSOR_IDLESTATE_INFO,
    const _Flags_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESSOR_POWER_POLICY_INFO = extern struct {
    TimeCheck: u32,
    DemoteLimit: u32,
    PromoteLimit: u32,
    DemotePercent: u8,
    PromotePercent: u8,
    Spare: [2]u8,
    _bitfield: u32,
};

pub const PROCESSOR_POWER_POLICY = extern struct {
    Revision: u32,
    DynamicThrottle: u8,
    Spare: [3]u8,
    _bitfield: u32,
    PolicyCount: u32,
    Policy: [3]PROCESSOR_POWER_POLICY_INFO,
};

pub const PROCESSOR_PERFSTATE_POLICY = extern struct {
    Revision: u32,
    MaxThrottle: u8,
    MinThrottle: u8,
    BusyAdjThreshold: u8,
    Anonymous: PROCESSOR_PERFSTATE_POLICY._Anonymous_e__Union,
    TimeCheck: u32,
    IncreaseTime: u32,
    DecreaseTime: u32,
    IncreasePercent: u32,
    DecreasePercent: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ADMINISTRATOR_POWER_POLICY = extern struct {
    MinSleep: SYSTEM_POWER_STATE,
    MaxSleep: SYSTEM_POWER_STATE,
    MinVideoTimeout: u32,
    MaxVideoTimeout: u32,
    MinSpindownTimeout: u32,
    MaxSpindownTimeout: u32,
};

pub const HIBERFILE_BUCKET_SIZE = extern enum(i32) {
    HiberFileBucket1GB = 0,
    HiberFileBucket2GB = 1,
    HiberFileBucket4GB = 2,
    HiberFileBucket8GB = 3,
    HiberFileBucket16GB = 4,
    HiberFileBucket32GB = 5,
    HiberFileBucketUnlimited = 6,
    HiberFileBucketMax = 7,
};
pub const HiberFileBucket1GB = HIBERFILE_BUCKET_SIZE.HiberFileBucket1GB;
pub const HiberFileBucket2GB = HIBERFILE_BUCKET_SIZE.HiberFileBucket2GB;
pub const HiberFileBucket4GB = HIBERFILE_BUCKET_SIZE.HiberFileBucket4GB;
pub const HiberFileBucket8GB = HIBERFILE_BUCKET_SIZE.HiberFileBucket8GB;
pub const HiberFileBucket16GB = HIBERFILE_BUCKET_SIZE.HiberFileBucket16GB;
pub const HiberFileBucket32GB = HIBERFILE_BUCKET_SIZE.HiberFileBucket32GB;
pub const HiberFileBucketUnlimited = HIBERFILE_BUCKET_SIZE.HiberFileBucketUnlimited;
pub const HiberFileBucketMax = HIBERFILE_BUCKET_SIZE.HiberFileBucketMax;

pub const HIBERFILE_BUCKET = extern struct {
    MaxPhysicalMemory: u64,
    PhysicalMemoryPercent: [3]u32,
};

pub const SYSTEM_POWER_CAPABILITIES = extern struct {
    PowerButtonPresent: u8,
    SleepButtonPresent: u8,
    LidPresent: u8,
    SystemS1: u8,
    SystemS2: u8,
    SystemS3: u8,
    SystemS4: u8,
    SystemS5: u8,
    HiberFilePresent: u8,
    FullWake: u8,
    VideoDimPresent: u8,
    ApmPresent: u8,
    UpsPresent: u8,
    ThermalControl: u8,
    ProcessorThrottle: u8,
    ProcessorMinThrottle: u8,
    ProcessorMaxThrottle: u8,
    FastSystemS4: u8,
    Hiberboot: u8,
    WakeAlarmPresent: u8,
    AoAc: u8,
    DiskSpinDown: u8,
    HiberFileType: u8,
    AoAcConnectivitySupported: u8,
    spare3: [6]u8,
    SystemBatteriesPresent: u8,
    BatteriesAreShortTerm: u8,
    BatteryScale: [3]BATTERY_REPORTING_SCALE,
    AcOnLineWake: SYSTEM_POWER_STATE,
    SoftLidWake: SYSTEM_POWER_STATE,
    RtcWake: SYSTEM_POWER_STATE,
    MinDeviceWakeState: SYSTEM_POWER_STATE,
    DefaultLowLatencyWake: SYSTEM_POWER_STATE,
};

pub const SYSTEM_BATTERY_STATE = extern struct {
    AcOnLine: u8,
    BatteryPresent: u8,
    Charging: u8,
    Discharging: u8,
    Spare1: [3]u8,
    Tag: u8,
    MaxCapacity: u32,
    RemainingCapacity: u32,
    Rate: u32,
    EstimatedTime: u32,
    DefaultAlert1: u32,
    DefaultAlert2: u32,
};

pub const IMAGE_DOS_HEADER = extern struct {
    e_magic: u16,
    e_cblp: u16,
    e_cp: u16,
    e_crlc: u16,
    e_cparhdr: u16,
    e_minalloc: u16,
    e_maxalloc: u16,
    e_ss: u16,
    e_sp: u16,
    e_csum: u16,
    e_ip: u16,
    e_cs: u16,
    e_lfarlc: u16,
    e_ovno: u16,
    e_res: [4]u16,
    e_oemid: u16,
    e_oeminfo: u16,
    e_res2: [10]u16,
    e_lfanew: i32,
};

pub const IMAGE_OS2_HEADER = extern struct {
    ne_magic: u16,
    ne_ver: i8,
    ne_rev: i8,
    ne_enttab: u16,
    ne_cbenttab: u16,
    ne_crc: i32,
    ne_flags: u16,
    ne_autodata: u16,
    ne_heap: u16,
    ne_stack: u16,
    ne_csip: i32,
    ne_sssp: i32,
    ne_cseg: u16,
    ne_cmod: u16,
    ne_cbnrestab: u16,
    ne_segtab: u16,
    ne_rsrctab: u16,
    ne_restab: u16,
    ne_modtab: u16,
    ne_imptab: u16,
    ne_nrestab: i32,
    ne_cmovent: u16,
    ne_align: u16,
    ne_cres: u16,
    ne_exetyp: u8,
    ne_flagsothers: u8,
    ne_pretthunks: u16,
    ne_psegrefbytes: u16,
    ne_swaparea: u16,
    ne_expver: u16,
};

pub const IMAGE_VXD_HEADER = extern struct {
    e32_magic: u16,
    e32_border: u8,
    e32_worder: u8,
    e32_level: u32,
    e32_cpu: u16,
    e32_os: u16,
    e32_ver: u32,
    e32_mflags: u32,
    e32_mpages: u32,
    e32_startobj: u32,
    e32_eip: u32,
    e32_stackobj: u32,
    e32_esp: u32,
    e32_pagesize: u32,
    e32_lastpagesize: u32,
    e32_fixupsize: u32,
    e32_fixupsum: u32,
    e32_ldrsize: u32,
    e32_ldrsum: u32,
    e32_objtab: u32,
    e32_objcnt: u32,
    e32_objmap: u32,
    e32_itermap: u32,
    e32_rsrctab: u32,
    e32_rsrccnt: u32,
    e32_restab: u32,
    e32_enttab: u32,
    e32_dirtab: u32,
    e32_dircnt: u32,
    e32_fpagetab: u32,
    e32_frectab: u32,
    e32_impmod: u32,
    e32_impmodcnt: u32,
    e32_impproc: u32,
    e32_pagesum: u32,
    e32_datapage: u32,
    e32_preload: u32,
    e32_nrestab: u32,
    e32_cbnrestab: u32,
    e32_nressum: u32,
    e32_autodata: u32,
    e32_debuginfo: u32,
    e32_debuglen: u32,
    e32_instpreload: u32,
    e32_instdemand: u32,
    e32_heapsize: u32,
    e32_res3: [12]u8,
    e32_winresoff: u32,
    e32_winreslen: u32,
    e32_devid: u16,
    e32_ddkver: u16,
};

pub const IMAGE_OPTIONAL_HEADER = extern struct {
    Magic: u16,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    ImageBase: u32,
    SectionAlignment: u32,
    FileAlignment: u32,
    MajorOperatingSystemVersion: u16,
    MinorOperatingSystemVersion: u16,
    MajorImageVersion: u16,
    MinorImageVersion: u16,
    MajorSubsystemVersion: u16,
    MinorSubsystemVersion: u16,
    Win32VersionValue: u32,
    SizeOfImage: u32,
    SizeOfHeaders: u32,
    CheckSum: u32,
    Subsystem: u16,
    DllCharacteristics: u16,
    SizeOfStackReserve: u32,
    SizeOfStackCommit: u32,
    SizeOfHeapReserve: u32,
    SizeOfHeapCommit: u32,
    LoaderFlags: u32,
    NumberOfRvaAndSizes: u32,
    DataDirectory: [16]IMAGE_DATA_DIRECTORY,
};

pub const IMAGE_ROM_OPTIONAL_HEADER = extern struct {
    Magic: u16,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    BaseOfBss: u32,
    GprMask: u32,
    CprMask: [4]u32,
    GpValue: u32,
};

pub const IMAGE_NT_HEADERS = extern struct {
    Signature: u32,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER,
};

pub const IMAGE_ROM_HEADERS = extern struct {
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
};

pub const ANON_OBJECT_HEADER = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    ClassID: Guid,
    SizeOfData: u32,
};

pub const ANON_OBJECT_HEADER_V2 = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    ClassID: Guid,
    SizeOfData: u32,
    Flags: u32,
    MetaDataSize: u32,
    MetaDataOffset: u32,
};

pub const ANON_OBJECT_HEADER_BIGOBJ = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    ClassID: Guid,
    SizeOfData: u32,
    Flags: u32,
    MetaDataSize: u32,
    MetaDataOffset: u32,
    NumberOfSections: u32,
    PointerToSymbolTable: u32,
    NumberOfSymbols: u32,
};

pub const IMAGE_SYMBOL = extern struct {
    N: IMAGE_SYMBOL._N_e__Union,
    Value: u32,
    SectionNumber: i16,
    Type: u16,
    StorageClass: u8,
    NumberOfAuxSymbols: u8,
    const _N_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_SYMBOL_EX = extern struct {
    N: IMAGE_SYMBOL_EX._N_e__Union,
    Value: u32,
    SectionNumber: i32,
    Type: u16,
    StorageClass: u8,
    NumberOfAuxSymbols: u8,
    const _N_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_AUX_SYMBOL_TOKEN_DEF = extern struct {
    bAuxType: u8,
    bReserved: u8,
    SymbolTableIndex: u32,
    rgbReserved: [12]u8,
};

pub const IMAGE_AUX_SYMBOL = u32; // TODO: implement StructOrUnion types?

pub const IMAGE_AUX_SYMBOL_EX = u32; // TODO: implement StructOrUnion types?

pub const IMAGE_AUX_SYMBOL_TYPE = extern enum(i32) {
    TOKEN_DEF = 1,
};
pub const IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = IMAGE_AUX_SYMBOL_TYPE.TOKEN_DEF;

pub const IMAGE_RELOCATION = extern struct {
    Anonymous: IMAGE_RELOCATION._Anonymous_e__Union,
    SymbolTableIndex: u32,
    Type: u16,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_LINENUMBER = extern struct {
    Type: IMAGE_LINENUMBER._Type_e__Union,
    Linenumber: u16,
    const _Type_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_BASE_RELOCATION = extern struct {
    VirtualAddress: u32,
    SizeOfBlock: u32,
};

pub const IMAGE_ARCHIVE_MEMBER_HEADER = extern struct {
    Name: [16]u8,
    Date: [12]u8,
    UserID: [6]u8,
    GroupID: [6]u8,
    Mode: [8]u8,
    Size: [10]u8,
    EndHeader: [2]u8,
};

pub const IMAGE_EXPORT_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    Name: u32,
    Base: u32,
    NumberOfFunctions: u32,
    NumberOfNames: u32,
    AddressOfFunctions: u32,
    AddressOfNames: u32,
    AddressOfNameOrdinals: u32,
};

pub const IMAGE_IMPORT_BY_NAME = extern struct {
    Hint: u16,
    Name: [1]i8,
};

pub const IMAGE_THUNK_DATA64 = extern struct {
    u1: IMAGE_THUNK_DATA64._u1_e__Union,
    const _u1_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_THUNK_DATA32 = extern struct {
    u1: IMAGE_THUNK_DATA32._u1_e__Union,
    const _u1_e__Union = u32; // TODO: generate this nested type!
};

pub const PIMAGE_TLS_CALLBACK = fn(
    DllHandle: *c_void,
    Reason: u32,
    Reserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const IMAGE_TLS_DIRECTORY64 = extern struct {
    StartAddressOfRawData: u64,
    EndAddressOfRawData: u64,
    AddressOfIndex: u64,
    AddressOfCallBacks: u64,
    SizeOfZeroFill: u32,
    Anonymous: IMAGE_TLS_DIRECTORY64._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_TLS_DIRECTORY32 = extern struct {
    StartAddressOfRawData: u32,
    EndAddressOfRawData: u32,
    AddressOfIndex: u32,
    AddressOfCallBacks: u32,
    SizeOfZeroFill: u32,
    Anonymous: IMAGE_TLS_DIRECTORY32._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_IMPORT_DESCRIPTOR = extern struct {
    Anonymous: IMAGE_IMPORT_DESCRIPTOR._Anonymous_e__Union,
    TimeDateStamp: u32,
    ForwarderChain: u32,
    Name: u32,
    FirstThunk: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_BOUND_IMPORT_DESCRIPTOR = extern struct {
    TimeDateStamp: u32,
    OffsetModuleName: u16,
    NumberOfModuleForwarderRefs: u16,
};

pub const IMAGE_BOUND_FORWARDER_REF = extern struct {
    TimeDateStamp: u32,
    OffsetModuleName: u16,
    Reserved: u16,
};

pub const IMAGE_DELAYLOAD_DESCRIPTOR = extern struct {
    Attributes: IMAGE_DELAYLOAD_DESCRIPTOR._Attributes_e__Union,
    DllNameRVA: u32,
    ModuleHandleRVA: u32,
    ImportAddressTableRVA: u32,
    ImportNameTableRVA: u32,
    BoundImportAddressTableRVA: u32,
    UnloadInformationTableRVA: u32,
    TimeDateStamp: u32,
    const _Attributes_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_RESOURCE_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    NumberOfNamedEntries: u16,
    NumberOfIdEntries: u16,
};

pub const IMAGE_RESOURCE_DIRECTORY_ENTRY = extern struct {
    Anonymous1: IMAGE_RESOURCE_DIRECTORY_ENTRY._Anonymous1_e__Union,
    Anonymous2: IMAGE_RESOURCE_DIRECTORY_ENTRY._Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_RESOURCE_DIRECTORY_STRING = extern struct {
    Length: u16,
    NameString: [1]i8,
};

pub const IMAGE_RESOURCE_DIR_STRING_U = extern struct {
    Length: u16,
    NameString: [1]u16,
};

pub const IMAGE_RESOURCE_DATA_ENTRY = extern struct {
    OffsetToData: u32,
    Size: u32,
    CodePage: u32,
    Reserved: u32,
};

pub const IMAGE_LOAD_CONFIG_CODE_INTEGRITY = extern struct {
    Flags: u16,
    Catalog: u16,
    CatalogOffset: u32,
    Reserved: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION_TABLE = extern struct {
    Version: u32,
    Size: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION32 = extern struct {
    Symbol: u32,
    BaseRelocSize: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION64 = extern struct {
    Symbol: u64,
    BaseRelocSize: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION32_V2 = extern struct {
    HeaderSize: u32,
    FixupInfoSize: u32,
    Symbol: u32,
    SymbolGroup: u32,
    Flags: u32,
};

pub const IMAGE_DYNAMIC_RELOCATION64_V2 = extern struct {
    HeaderSize: u32,
    FixupInfoSize: u32,
    Symbol: u64,
    SymbolGroup: u32,
    Flags: u32,
};

pub const IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = extern struct {
    PrologueByteCount: u8,
};

pub const IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = extern struct {
    EpilogueCount: u32,
    EpilogueByteCount: u8,
    BranchDescriptorElementSize: u8,
    BranchDescriptorCount: u16,
};

pub const IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION = extern struct {
    _bitfield: u32,
};

pub const IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION = extern struct {
    _bitfield: u16,
};

pub const IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = extern struct {
    _bitfield: u16,
};

pub const IMAGE_HOT_PATCH_INFO = extern struct {
    Version: u32,
    Size: u32,
    SequenceNumber: u32,
    BaseImageList: u32,
    BaseImageCount: u32,
    BufferOffset: u32,
    ExtraPatchSize: u32,
};

pub const IMAGE_HOT_PATCH_BASE = extern struct {
    SequenceNumber: u32,
    Flags: u32,
    OriginalTimeDateStamp: u32,
    OriginalCheckSum: u32,
    CodeIntegrityInfo: u32,
    CodeIntegritySize: u32,
    PatchTable: u32,
    BufferOffset: u32,
};

pub const IMAGE_HOT_PATCH_HASHES = extern struct {
    SHA256: [32]u8,
    SHA1: [20]u8,
};

pub const IMAGE_CE_RUNTIME_FUNCTION_ENTRY = extern struct {
    FuncStart: u32,
    _bitfield: u32,
};

pub const IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    Anonymous: IMAGE_ARM_RUNTIME_FUNCTION_ENTRY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ARM64_FNPDATA_FLAGS = extern enum(i32) {
    PdataRefToFullXdata = 0,
    PdataPackedUnwindFunction = 1,
    PdataPackedUnwindFragment = 2,
};
pub const PdataRefToFullXdata = ARM64_FNPDATA_FLAGS.PdataRefToFullXdata;
pub const PdataPackedUnwindFunction = ARM64_FNPDATA_FLAGS.PdataPackedUnwindFunction;
pub const PdataPackedUnwindFragment = ARM64_FNPDATA_FLAGS.PdataPackedUnwindFragment;

pub const ARM64_FNPDATA_CR = extern enum(i32) {
    PdataCrUnchained = 0,
    PdataCrUnchainedSavedLr = 1,
    PdataCrChained = 3,
};
pub const PdataCrUnchained = ARM64_FNPDATA_CR.PdataCrUnchained;
pub const PdataCrUnchainedSavedLr = ARM64_FNPDATA_CR.PdataCrUnchainedSavedLr;
pub const PdataCrChained = ARM64_FNPDATA_CR.PdataCrChained;

pub const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    Anonymous: IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY_XDATA = u32; // TODO: implement StructOrUnion types?

pub const IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u64,
    EndAddress: u64,
    ExceptionHandler: u64,
    HandlerData: u64,
    PrologEndAddress: u64,
};

pub const IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    EndAddress: u32,
    ExceptionHandler: u32,
    HandlerData: u32,
    PrologEndAddress: u32,
};

pub const IMAGE_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: u32,
    EndAddress: u32,
    Anonymous: IMAGE_RUNTIME_FUNCTION_ENTRY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_ENCLAVE_CONFIG32 = extern struct {
    Size: u32,
    MinimumRequiredConfigSize: u32,
    PolicyFlags: u32,
    NumberOfImports: u32,
    ImportList: u32,
    ImportEntrySize: u32,
    FamilyID: [16]u8,
    ImageID: [16]u8,
    ImageVersion: u32,
    SecurityVersion: u32,
    EnclaveSize: u32,
    NumberOfThreads: u32,
    EnclaveFlags: u32,
};

pub const IMAGE_ENCLAVE_CONFIG64 = extern struct {
    Size: u32,
    MinimumRequiredConfigSize: u32,
    PolicyFlags: u32,
    NumberOfImports: u32,
    ImportList: u32,
    ImportEntrySize: u32,
    FamilyID: [16]u8,
    ImageID: [16]u8,
    ImageVersion: u32,
    SecurityVersion: u32,
    EnclaveSize: u64,
    NumberOfThreads: u32,
    EnclaveFlags: u32,
};

pub const IMAGE_ENCLAVE_IMPORT = extern struct {
    MatchType: u32,
    MinimumSecurityVersion: u32,
    UniqueOrAuthorID: [32]u8,
    FamilyID: [16]u8,
    ImageID: [16]u8,
    ImportName: u32,
    Reserved: u32,
};

pub const IMAGE_DEBUG_MISC = extern struct {
    DataType: u32,
    Length: u32,
    Unicode: u8,
    Reserved: [3]u8,
    Data: [1]u8,
};

pub const IMAGE_SEPARATE_DEBUG_HEADER = extern struct {
    Signature: u16,
    Flags: u16,
    Machine: u16,
    Characteristics: u16,
    TimeDateStamp: u32,
    CheckSum: u32,
    ImageBase: u32,
    SizeOfImage: u32,
    NumberOfSections: u32,
    ExportedNamesSize: u32,
    DebugDirectorySize: u32,
    SectionAlignment: u32,
    Reserved: [2]u32,
};

pub const NON_PAGED_DEBUG_INFO = extern struct {
    Signature: u16,
    Flags: u16,
    Size: u32,
    Machine: u16,
    Characteristics: u16,
    TimeDateStamp: u32,
    CheckSum: u32,
    SizeOfImage: u32,
    ImageBase: u64,
};

pub const IMAGE_ARCHITECTURE_HEADER = extern struct {
    _bitfield: u32,
    FirstEntryRVA: u32,
};

pub const IMAGE_ARCHITECTURE_ENTRY = extern struct {
    FixupInstRVA: u32,
    NewInst: u32,
};

pub const IMPORT_OBJECT_HEADER = extern struct {
    Sig1: u16,
    Sig2: u16,
    Version: u16,
    Machine: u16,
    TimeDateStamp: u32,
    SizeOfData: u32,
    Anonymous: IMPORT_OBJECT_HEADER._Anonymous_e__Union,
    _bitfield: u16,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IMPORT_OBJECT_TYPE = extern enum(i32) {
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
};
pub const IMPORT_OBJECT_CODE = IMPORT_OBJECT_TYPE.IMPORT_OBJECT_CODE;
pub const IMPORT_OBJECT_DATA = IMPORT_OBJECT_TYPE.IMPORT_OBJECT_DATA;
pub const IMPORT_OBJECT_CONST = IMPORT_OBJECT_TYPE.IMPORT_OBJECT_CONST;

pub const IMPORT_OBJECT_NAME_TYPE = extern enum(i32) {
    IMPORT_OBJECT_ORDINAL = 0,
    IMPORT_OBJECT_NAME = 1,
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,
    IMPORT_OBJECT_NAME_UNDECORATE = 3,
    IMPORT_OBJECT_NAME_EXPORTAS = 4,
};
pub const IMPORT_OBJECT_ORDINAL = IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_ORDINAL;
pub const IMPORT_OBJECT_NAME = IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME;
pub const IMPORT_OBJECT_NAME_NO_PREFIX = IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME_NO_PREFIX;
pub const IMPORT_OBJECT_NAME_UNDECORATE = IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME_UNDECORATE;
pub const IMPORT_OBJECT_NAME_EXPORTAS = IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME_EXPORTAS;

pub const ReplacesCorHdrNumericDefines = extern enum(i32) {
    COMIMAGE_FLAGS_ILONLY = 1,
    COMIMAGE_FLAGS_32BITREQUIRED = 2,
    COMIMAGE_FLAGS_IL_LIBRARY = 4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536,
    COMIMAGE_FLAGS_32BITPREFERRED = 131072,
    COR_VERSION_MAJOR_V2 = 2,
    COR_VERSION_MAJOR = 2,
    COR_VERSION_MINOR = 5,
    COR_DELETED_NAME_LENGTH = 8,
    COR_VTABLEGAP_NAME_LENGTH = 8,
    NATIVE_TYPE_MAX_CB = 1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255,
    IMAGE_COR_MIH_METHODRVA = 1,
    IMAGE_COR_MIH_EHRVA = 2,
    IMAGE_COR_MIH_BASICBLOCK = 8,
    COR_VTABLE_32BIT = 1,
    COR_VTABLE_64BIT = 2,
    COR_VTABLE_FROM_UNMANAGED = 4,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8,
    COR_VTABLE_CALL_MOST_DERIVED = 16,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
    MAX_PACKAGE_NAME = 1024,
};
pub const COMIMAGE_FLAGS_ILONLY = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY;
pub const COMIMAGE_FLAGS_32BITREQUIRED = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED;
pub const COMIMAGE_FLAGS_IL_LIBRARY = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY;
pub const COMIMAGE_FLAGS_STRONGNAMESIGNED = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED;
pub const COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT;
pub const COMIMAGE_FLAGS_TRACKDEBUGDATA = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA;
pub const COMIMAGE_FLAGS_32BITPREFERRED = ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITPREFERRED;
pub const COR_VERSION_MAJOR_V2 = ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2;
pub const COR_VERSION_MAJOR = ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR;
pub const COR_VERSION_MINOR = ReplacesCorHdrNumericDefines.COR_VERSION_MINOR;
pub const COR_DELETED_NAME_LENGTH = ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH;
pub const COR_VTABLEGAP_NAME_LENGTH = ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH;
pub const NATIVE_TYPE_MAX_CB = ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB;
pub const COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE;
pub const IMAGE_COR_MIH_METHODRVA = ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA;
pub const IMAGE_COR_MIH_EHRVA = ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA;
pub const IMAGE_COR_MIH_BASICBLOCK = ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK;
pub const COR_VTABLE_32BIT = ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT;
pub const COR_VTABLE_64BIT = ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT;
pub const COR_VTABLE_FROM_UNMANAGED = ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED;
pub const COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN;
pub const COR_VTABLE_CALL_MOST_DERIVED = ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED;
pub const IMAGE_COR_EATJ_THUNK_SIZE = ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE;
pub const MAX_CLASS_NAME = ReplacesCorHdrNumericDefines.MAX_CLASS_NAME;
pub const MAX_PACKAGE_NAME = ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME;

pub const IMAGE_COR20_HEADER = extern struct {
    cb: u32,
    MajorRuntimeVersion: u16,
    MinorRuntimeVersion: u16,
    MetaData: IMAGE_DATA_DIRECTORY,
    Flags: u32,
    Anonymous: IMAGE_COR20_HEADER._Anonymous_e__Union,
    Resources: IMAGE_DATA_DIRECTORY,
    StrongNameSignature: IMAGE_DATA_DIRECTORY,
    CodeManagerTable: IMAGE_DATA_DIRECTORY,
    VTableFixups: IMAGE_DATA_DIRECTORY,
    ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
    ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SLIST_HEADER = u32; // TODO: implement StructOrUnion types?

pub const RTL_RUN_ONCE = u32; // TODO: implement StructOrUnion types?

pub const RTL_BARRIER = extern struct {
    Reserved1: u32,
    Reserved2: u32,
    Reserved3: [2]?*c_void,
    Reserved4: u32,
    Reserved5: u32,
};

pub const RTL_UMS_THREAD_INFO_CLASS = extern enum(i32) {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext = 1,
    UmsThreadPriority = 2,
    UmsThreadAffinity = 3,
    UmsThreadTeb = 4,
    UmsThreadIsSuspended = 5,
    UmsThreadIsTerminated = 6,
    UmsThreadMaxInfoClass = 7,
};
pub const UmsThreadInvalidInfoClass = RTL_UMS_THREAD_INFO_CLASS.UmsThreadInvalidInfoClass;
pub const UmsThreadUserContext = RTL_UMS_THREAD_INFO_CLASS.UmsThreadUserContext;
pub const UmsThreadPriority = RTL_UMS_THREAD_INFO_CLASS.UmsThreadPriority;
pub const UmsThreadAffinity = RTL_UMS_THREAD_INFO_CLASS.UmsThreadAffinity;
pub const UmsThreadTeb = RTL_UMS_THREAD_INFO_CLASS.UmsThreadTeb;
pub const UmsThreadIsSuspended = RTL_UMS_THREAD_INFO_CLASS.UmsThreadIsSuspended;
pub const UmsThreadIsTerminated = RTL_UMS_THREAD_INFO_CLASS.UmsThreadIsTerminated;
pub const UmsThreadMaxInfoClass = RTL_UMS_THREAD_INFO_CLASS.UmsThreadMaxInfoClass;

pub const RTL_UMS_SCHEDULER_REASON = extern enum(i32) {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked = 1,
    UmsSchedulerThreadYield = 2,
};
pub const UmsSchedulerStartup = RTL_UMS_SCHEDULER_REASON.UmsSchedulerStartup;
pub const UmsSchedulerThreadBlocked = RTL_UMS_SCHEDULER_REASON.UmsSchedulerThreadBlocked;
pub const UmsSchedulerThreadYield = RTL_UMS_SCHEDULER_REASON.UmsSchedulerThreadYield;

pub const RTL_UMS_SCHEDULER_ENTRY_POINT = fn(
    Reason: RTL_UMS_SCHEDULER_REASON,
    ActivationPayload: ?*c_void,
    SchedulerParam: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PRTL_UMS_SCHEDULER_ENTRY_POINT = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const OS_DEPLOYEMENT_STATE_VALUES = extern enum(i32) {
    OS_DEPLOYMENT_STANDARD = 1,
    OS_DEPLOYMENT_COMPACT = 2,
};
pub const OS_DEPLOYMENT_STANDARD = OS_DEPLOYEMENT_STATE_VALUES.OS_DEPLOYMENT_STANDARD;
pub const OS_DEPLOYMENT_COMPACT = OS_DEPLOYEMENT_STATE_VALUES.OS_DEPLOYMENT_COMPACT;

pub const NV_MEMORY_RANGE = extern struct {
    BaseAddress: *c_void,
    Length: ?*c_void,
};

pub const CORRELATION_VECTOR = extern struct {
    Version: i8,
    Vector: [129]i8,
};

pub const CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = extern struct {
    Size: u32,
    TriggerId: [*:0]const u16,
};

pub const IMAGE_POLICY_ENTRY_TYPE = extern enum(i32) {
    ImagePolicyEntryTypeNone = 0,
    ImagePolicyEntryTypeBool = 1,
    ImagePolicyEntryTypeInt8 = 2,
    ImagePolicyEntryTypeUInt8 = 3,
    ImagePolicyEntryTypeInt16 = 4,
    ImagePolicyEntryTypeUInt16 = 5,
    ImagePolicyEntryTypeInt32 = 6,
    ImagePolicyEntryTypeUInt32 = 7,
    ImagePolicyEntryTypeInt64 = 8,
    ImagePolicyEntryTypeUInt64 = 9,
    ImagePolicyEntryTypeAnsiString = 10,
    ImagePolicyEntryTypeUnicodeString = 11,
    ImagePolicyEntryTypeOverride = 12,
    ImagePolicyEntryTypeMaximum = 13,
};
pub const ImagePolicyEntryTypeNone = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeNone;
pub const ImagePolicyEntryTypeBool = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeBool;
pub const ImagePolicyEntryTypeInt8 = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt8;
pub const ImagePolicyEntryTypeUInt8 = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt8;
pub const ImagePolicyEntryTypeInt16 = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt16;
pub const ImagePolicyEntryTypeUInt16 = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt16;
pub const ImagePolicyEntryTypeInt32 = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt32;
pub const ImagePolicyEntryTypeUInt32 = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt32;
pub const ImagePolicyEntryTypeInt64 = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt64;
pub const ImagePolicyEntryTypeUInt64 = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt64;
pub const ImagePolicyEntryTypeAnsiString = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeAnsiString;
pub const ImagePolicyEntryTypeUnicodeString = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUnicodeString;
pub const ImagePolicyEntryTypeOverride = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeOverride;
pub const ImagePolicyEntryTypeMaximum = IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeMaximum;

pub const IMAGE_POLICY_ID = extern enum(i32) {
    ImagePolicyIdNone = 0,
    ImagePolicyIdEtw = 1,
    ImagePolicyIdDebug = 2,
    ImagePolicyIdCrashDump = 3,
    ImagePolicyIdCrashDumpKey = 4,
    ImagePolicyIdCrashDumpKeyGuid = 5,
    ImagePolicyIdParentSd = 6,
    ImagePolicyIdParentSdRev = 7,
    ImagePolicyIdSvn = 8,
    ImagePolicyIdDeviceId = 9,
    ImagePolicyIdCapability = 10,
    ImagePolicyIdScenarioId = 11,
    ImagePolicyIdMaximum = 12,
};
pub const ImagePolicyIdNone = IMAGE_POLICY_ID.ImagePolicyIdNone;
pub const ImagePolicyIdEtw = IMAGE_POLICY_ID.ImagePolicyIdEtw;
pub const ImagePolicyIdDebug = IMAGE_POLICY_ID.ImagePolicyIdDebug;
pub const ImagePolicyIdCrashDump = IMAGE_POLICY_ID.ImagePolicyIdCrashDump;
pub const ImagePolicyIdCrashDumpKey = IMAGE_POLICY_ID.ImagePolicyIdCrashDumpKey;
pub const ImagePolicyIdCrashDumpKeyGuid = IMAGE_POLICY_ID.ImagePolicyIdCrashDumpKeyGuid;
pub const ImagePolicyIdParentSd = IMAGE_POLICY_ID.ImagePolicyIdParentSd;
pub const ImagePolicyIdParentSdRev = IMAGE_POLICY_ID.ImagePolicyIdParentSdRev;
pub const ImagePolicyIdSvn = IMAGE_POLICY_ID.ImagePolicyIdSvn;
pub const ImagePolicyIdDeviceId = IMAGE_POLICY_ID.ImagePolicyIdDeviceId;
pub const ImagePolicyIdCapability = IMAGE_POLICY_ID.ImagePolicyIdCapability;
pub const ImagePolicyIdScenarioId = IMAGE_POLICY_ID.ImagePolicyIdScenarioId;
pub const ImagePolicyIdMaximum = IMAGE_POLICY_ID.ImagePolicyIdMaximum;

pub const IMAGE_POLICY_ENTRY = extern struct {
    Type: IMAGE_POLICY_ENTRY_TYPE,
    PolicyId: IMAGE_POLICY_ID,
    u: IMAGE_POLICY_ENTRY._u_e__Union,
    const _u_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_POLICY_METADATA = extern struct {
    Version: u8,
    Reserved0: [7]u8,
    ApplicationId: u64,
    Policies: IMAGE_POLICY_ENTRY,
};

pub const RTL_CRITICAL_SECTION_DEBUG = extern struct {
    Type: u16,
    CreatorBackTraceIndex: u16,
    CriticalSection: *RTL_CRITICAL_SECTION,
    ProcessLocksList: LIST_ENTRY,
    EntryCount: u32,
    ContentionCount: u32,
    Flags: u32,
    CreatorBackTraceIndexHigh: u16,
    SpareWORD: u16,
};

pub const RTL_CRITICAL_SECTION = extern struct {
    DebugInfo: *RTL_CRITICAL_SECTION_DEBUG,
    LockCount: i32,
    RecursionCount: i32,
    OwningThread: HANDLE,
    LockSemaphore: HANDLE,
    SpinCount: ?*c_void,
};

pub const RTL_SRWLOCK = extern struct {
    Ptr: *c_void,
};

pub const RTL_CONDITION_VARIABLE = extern struct {
    Ptr: *c_void,
};

pub const PAPCFUNC = fn(
    Parameter: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const HEAP_INFORMATION_CLASS = extern enum(i32) {
    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1,
    HeapOptimizeResources = 3,
};
pub const HeapCompatibilityInformation = HEAP_INFORMATION_CLASS.HeapCompatibilityInformation;
pub const HeapEnableTerminationOnCorruption = HEAP_INFORMATION_CLASS.HeapEnableTerminationOnCorruption;
pub const HeapOptimizeResources = HEAP_INFORMATION_CLASS.HeapOptimizeResources;

pub const HEAP_OPTIMIZE_RESOURCES_INFORMATION = extern struct {
    Version: u32,
    Flags: u32,
};

pub const WAITORTIMERCALLBACKFUNC = fn(
    param0: *c_void,
    param1: u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WORKERCALLBACKFUNC = fn(
    param0: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const APC_CALLBACK_FUNCTION = fn(
    param0: u32,
    param1: *c_void,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WAITORTIMERCALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFLS_CALLBACK_FUNCTION = fn(
    lpFlsData: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PSECURE_MEMORY_CACHE_CALLBACK = fn(
    Addr: [*]u8,
    Range: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const ACTIVATION_CONTEXT_INFO_CLASS = extern enum(i32) {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass = 8,
    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4,
};
pub const ActivationContextBasicInformation = ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextBasicInformation;
pub const ActivationContextDetailedInformation = ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextDetailedInformation;
pub const AssemblyDetailedInformationInActivationContext = ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContext;
pub const FileInformationInAssemblyOfAssemblyInActivationContext = ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContext;
pub const RunlevelInformationInActivationContext = ACTIVATION_CONTEXT_INFO_CLASS.RunlevelInformationInActivationContext;
pub const CompatibilityInformationInActivationContext = ACTIVATION_CONTEXT_INFO_CLASS.CompatibilityInformationInActivationContext;
pub const ActivationContextManifestResourceName = ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextManifestResourceName;
pub const MaxActivationContextInfoClass = ACTIVATION_CONTEXT_INFO_CLASS.MaxActivationContextInfoClass;
pub const AssemblyDetailedInformationInActivationContxt = ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContxt;
pub const FileInformationInAssemblyOfAssemblyInActivationContxt = ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContxt;

pub const SUPPORTED_OS_INFO = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
};

pub const MAXVERSIONTESTED_INFO = extern struct {
    MaxVersionTested: u64,
};

pub const EVENTLOGRECORD = extern struct {
    Length: u32,
    Reserved: u32,
    RecordNumber: u32,
    TimeGenerated: u32,
    TimeWritten: u32,
    EventID: u32,
    EventType: u16,
    NumStrings: u16,
    EventCategory: u16,
    ReservedFlags: u16,
    ClosingRecordNumber: u32,
    StringOffset: u32,
    UserSidLength: u32,
    UserSidOffset: u32,
    DataLength: u32,
    DataOffset: u32,
};

pub const EVENTSFORLOGFILE = extern struct {
    ulSize: u32,
    szLogicalLogFile: [256]u16,
    ulNumRecords: u32,
    pEventLogRecords: EVENTLOGRECORD,
};

pub const PACKEDEVENTINFO = extern struct {
    ulSize: u32,
    ulNumEventsForLogFile: u32,
    ulOffsets: u32,
};

pub const CM_SERVICE_NODE_TYPE = extern enum(i32) {
    DriverType = 1,
    FileSystemType = 2,
    Win32ServiceOwnProcess = 16,
    Win32ServiceShareProcess = 32,
    AdapterType = 4,
    RecognizerType = 8,
};
pub const DriverType = CM_SERVICE_NODE_TYPE.DriverType;
pub const FileSystemType = CM_SERVICE_NODE_TYPE.FileSystemType;
pub const Win32ServiceOwnProcess = CM_SERVICE_NODE_TYPE.Win32ServiceOwnProcess;
pub const Win32ServiceShareProcess = CM_SERVICE_NODE_TYPE.Win32ServiceShareProcess;
pub const AdapterType = CM_SERVICE_NODE_TYPE.AdapterType;
pub const RecognizerType = CM_SERVICE_NODE_TYPE.RecognizerType;

pub const CM_SERVICE_LOAD_TYPE = extern enum(i32) {
    BootLoad = 0,
    SystemLoad = 1,
    AutoLoad = 2,
    DemandLoad = 3,
    DisableLoad = 4,
};
pub const BootLoad = CM_SERVICE_LOAD_TYPE.BootLoad;
pub const SystemLoad = CM_SERVICE_LOAD_TYPE.SystemLoad;
pub const AutoLoad = CM_SERVICE_LOAD_TYPE.AutoLoad;
pub const DemandLoad = CM_SERVICE_LOAD_TYPE.DemandLoad;
pub const DisableLoad = CM_SERVICE_LOAD_TYPE.DisableLoad;

pub const CM_ERROR_CONTROL_TYPE = extern enum(i32) {
    IgnoreError = 0,
    NormalError = 1,
    SevereError = 2,
    CriticalError = 3,
};
pub const IgnoreError = CM_ERROR_CONTROL_TYPE.IgnoreError;
pub const NormalError = CM_ERROR_CONTROL_TYPE.NormalError;
pub const SevereError = CM_ERROR_CONTROL_TYPE.SevereError;
pub const CriticalError = CM_ERROR_CONTROL_TYPE.CriticalError;

pub const TAPE_ERASE = extern struct {
    Type: u32,
    Immediate: u8,
};

pub const TAPE_PREPARE = extern struct {
    Operation: u32,
    Immediate: u8,
};

pub const TAPE_WRITE_MARKS = extern struct {
    Type: u32,
    Count: u32,
    Immediate: u8,
};

pub const TAPE_GET_POSITION = extern struct {
    Type: u32,
    Partition: u32,
    Offset: LARGE_INTEGER,
};

pub const TAPE_SET_POSITION = extern struct {
    Method: u32,
    Partition: u32,
    Offset: LARGE_INTEGER,
    Immediate: u8,
};

pub const TAPE_GET_DRIVE_PARAMETERS = extern struct {
    ECC: u8,
    Compression: u8,
    DataPadding: u8,
    ReportSetmarks: u8,
    DefaultBlockSize: u32,
    MaximumBlockSize: u32,
    MinimumBlockSize: u32,
    MaximumPartitionCount: u32,
    FeaturesLow: u32,
    FeaturesHigh: u32,
    EOTWarningZoneSize: u32,
};

pub const TAPE_SET_DRIVE_PARAMETERS = extern struct {
    ECC: u8,
    Compression: u8,
    DataPadding: u8,
    ReportSetmarks: u8,
    EOTWarningZoneSize: u32,
};

pub const TAPE_GET_MEDIA_PARAMETERS = extern struct {
    Capacity: LARGE_INTEGER,
    Remaining: LARGE_INTEGER,
    BlockSize: u32,
    PartitionCount: u32,
    WriteProtected: u8,
};

pub const TAPE_SET_MEDIA_PARAMETERS = extern struct {
    BlockSize: u32,
};

pub const TAPE_CREATE_PARTITION = extern struct {
    Method: u32,
    Count: u32,
    Size: u32,
};

pub const TAPE_WMI_OPERATIONS = extern struct {
    Method: u32,
    DataBufferSize: u32,
    DataBuffer: *c_void,
};

pub const TAPE_DRIVE_PROBLEM_TYPE = extern enum(i32) {
    TapeDriveProblemNone = 0,
    TapeDriveReadWriteWarning = 1,
    TapeDriveReadWriteError = 2,
    TapeDriveReadWarning = 3,
    TapeDriveWriteWarning = 4,
    TapeDriveReadError = 5,
    TapeDriveWriteError = 6,
    TapeDriveHardwareError = 7,
    TapeDriveUnsupportedMedia = 8,
    TapeDriveScsiConnectionError = 9,
    TapeDriveTimetoClean = 10,
    TapeDriveCleanDriveNow = 11,
    TapeDriveMediaLifeExpired = 12,
    TapeDriveSnappedTape = 13,
};
pub const TapeDriveProblemNone = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveProblemNone;
pub const TapeDriveReadWriteWarning = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWriteWarning;
pub const TapeDriveReadWriteError = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWriteError;
pub const TapeDriveReadWarning = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWarning;
pub const TapeDriveWriteWarning = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveWriteWarning;
pub const TapeDriveReadError = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadError;
pub const TapeDriveWriteError = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveWriteError;
pub const TapeDriveHardwareError = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveHardwareError;
pub const TapeDriveUnsupportedMedia = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveUnsupportedMedia;
pub const TapeDriveScsiConnectionError = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveScsiConnectionError;
pub const TapeDriveTimetoClean = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveTimetoClean;
pub const TapeDriveCleanDriveNow = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveCleanDriveNow;
pub const TapeDriveMediaLifeExpired = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveMediaLifeExpired;
pub const TapeDriveSnappedTape = TAPE_DRIVE_PROBLEM_TYPE.TapeDriveSnappedTape;

pub const TRANSACTION_STATE = extern enum(i32) {
    TransactionStateNormal = 1,
    TransactionStateIndoubt = 2,
    TransactionStateCommittedNotify = 3,
};
pub const TransactionStateNormal = TRANSACTION_STATE.TransactionStateNormal;
pub const TransactionStateIndoubt = TRANSACTION_STATE.TransactionStateIndoubt;
pub const TransactionStateCommittedNotify = TRANSACTION_STATE.TransactionStateCommittedNotify;

pub const TRANSACTION_BASIC_INFORMATION = extern struct {
    TransactionId: Guid,
    State: u32,
    Outcome: u32,
};

pub const TRANSACTIONMANAGER_BASIC_INFORMATION = extern struct {
    TmIdentity: Guid,
    VirtualClock: LARGE_INTEGER,
};

pub const TRANSACTIONMANAGER_LOG_INFORMATION = extern struct {
    LogIdentity: Guid,
};

pub const TRANSACTIONMANAGER_LOGPATH_INFORMATION = extern struct {
    LogPathLength: u32,
    LogPath: [1]u16,
};

pub const TRANSACTIONMANAGER_RECOVERY_INFORMATION = extern struct {
    LastRecoveredLsn: u64,
};

pub const TRANSACTIONMANAGER_OLDEST_INFORMATION = extern struct {
    OldestTransactionGuid: Guid,
};

pub const TRANSACTION_PROPERTIES_INFORMATION = extern struct {
    IsolationLevel: u32,
    IsolationFlags: u32,
    Timeout: LARGE_INTEGER,
    Outcome: u32,
    DescriptionLength: u32,
    Description: [1]u16,
};

pub const TRANSACTION_BIND_INFORMATION = extern struct {
    TmHandle: HANDLE,
};

pub const TRANSACTION_ENLISTMENT_PAIR = extern struct {
    EnlistmentId: Guid,
    ResourceManagerId: Guid,
};

pub const TRANSACTION_ENLISTMENTS_INFORMATION = extern struct {
    NumberOfEnlistments: u32,
    EnlistmentPair: [1]TRANSACTION_ENLISTMENT_PAIR,
};

pub const TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = extern struct {
    SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
};

pub const RESOURCEMANAGER_BASIC_INFORMATION = extern struct {
    ResourceManagerId: Guid,
    DescriptionLength: u32,
    Description: [1]u16,
};

pub const RESOURCEMANAGER_COMPLETION_INFORMATION = extern struct {
    IoCompletionPortHandle: HANDLE,
    CompletionKey: ?*c_void,
};

pub const TRANSACTION_INFORMATION_CLASS = extern enum(i32) {
    TransactionBasicInformation = 0,
    TransactionPropertiesInformation = 1,
    TransactionEnlistmentInformation = 2,
    TransactionSuperiorEnlistmentInformation = 3,
    TransactionBindInformation = 4,
    TransactionDTCPrivateInformation = 5,
};
pub const TransactionBasicInformation = TRANSACTION_INFORMATION_CLASS.TransactionBasicInformation;
pub const TransactionPropertiesInformation = TRANSACTION_INFORMATION_CLASS.TransactionPropertiesInformation;
pub const TransactionEnlistmentInformation = TRANSACTION_INFORMATION_CLASS.TransactionEnlistmentInformation;
pub const TransactionSuperiorEnlistmentInformation = TRANSACTION_INFORMATION_CLASS.TransactionSuperiorEnlistmentInformation;
pub const TransactionBindInformation = TRANSACTION_INFORMATION_CLASS.TransactionBindInformation;
pub const TransactionDTCPrivateInformation = TRANSACTION_INFORMATION_CLASS.TransactionDTCPrivateInformation;

pub const TRANSACTIONMANAGER_INFORMATION_CLASS = extern enum(i32) {
    TransactionManagerBasicInformation = 0,
    TransactionManagerLogInformation = 1,
    TransactionManagerLogPathInformation = 2,
    TransactionManagerRecoveryInformation = 4,
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5,
};
pub const TransactionManagerBasicInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerBasicInformation;
pub const TransactionManagerLogInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogInformation;
pub const TransactionManagerLogPathInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogPathInformation;
pub const TransactionManagerRecoveryInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerRecoveryInformation;
pub const TransactionManagerOnlineProbeInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOnlineProbeInformation;
pub const TransactionManagerOldestTransactionInformation = TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOldestTransactionInformation;

pub const RESOURCEMANAGER_INFORMATION_CLASS = extern enum(i32) {
    ResourceManagerBasicInformation = 0,
    ResourceManagerCompletionInformation = 1,
};
pub const ResourceManagerBasicInformation = RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerBasicInformation;
pub const ResourceManagerCompletionInformation = RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerCompletionInformation;

pub const ENLISTMENT_BASIC_INFORMATION = extern struct {
    EnlistmentId: Guid,
    TransactionId: Guid,
    ResourceManagerId: Guid,
};

pub const ENLISTMENT_CRM_INFORMATION = extern struct {
    CrmTransactionManagerId: Guid,
    CrmResourceManagerId: Guid,
    CrmEnlistmentId: Guid,
};

pub const ENLISTMENT_INFORMATION_CLASS = extern enum(i32) {
    EnlistmentBasicInformation = 0,
    EnlistmentRecoveryInformation = 1,
    EnlistmentCrmInformation = 2,
};
pub const EnlistmentBasicInformation = ENLISTMENT_INFORMATION_CLASS.EnlistmentBasicInformation;
pub const EnlistmentRecoveryInformation = ENLISTMENT_INFORMATION_CLASS.EnlistmentRecoveryInformation;
pub const EnlistmentCrmInformation = ENLISTMENT_INFORMATION_CLASS.EnlistmentCrmInformation;

pub const TRANSACTION_LIST_ENTRY = extern struct {
    UOW: Guid,
};

pub const TRANSACTION_LIST_INFORMATION = extern struct {
    NumberOfTransactions: u32,
    TransactionInformation: [1]TRANSACTION_LIST_ENTRY,
};

pub const KTMOBJECT_TYPE = extern enum(i32) {
    KTMOBJECT_TRANSACTION = 0,
    KTMOBJECT_TRANSACTION_MANAGER = 1,
    KTMOBJECT_RESOURCE_MANAGER = 2,
    KTMOBJECT_ENLISTMENT = 3,
    KTMOBJECT_INVALID = 4,
};
pub const KTMOBJECT_TRANSACTION = KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION;
pub const KTMOBJECT_TRANSACTION_MANAGER = KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION_MANAGER;
pub const KTMOBJECT_RESOURCE_MANAGER = KTMOBJECT_TYPE.KTMOBJECT_RESOURCE_MANAGER;
pub const KTMOBJECT_ENLISTMENT = KTMOBJECT_TYPE.KTMOBJECT_ENLISTMENT;
pub const KTMOBJECT_INVALID = KTMOBJECT_TYPE.KTMOBJECT_INVALID;

pub const KTMOBJECT_CURSOR = extern struct {
    LastQuery: Guid,
    ObjectIdCount: u32,
    ObjectIds: [1]Guid,
};

pub const TP_CALLBACK_INSTANCE = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const PTP_SIMPLE_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TP_POOL = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const TP_CALLBACK_PRIORITY = extern enum(i32) {
    HIGH = 0,
    NORMAL = 1,
    LOW = 2,
    INVALID = 3,
    COUNT = 3,
};
pub const TP_CALLBACK_PRIORITY_HIGH = TP_CALLBACK_PRIORITY.HIGH;
pub const TP_CALLBACK_PRIORITY_NORMAL = TP_CALLBACK_PRIORITY.NORMAL;
pub const TP_CALLBACK_PRIORITY_LOW = TP_CALLBACK_PRIORITY.LOW;
pub const TP_CALLBACK_PRIORITY_INVALID = TP_CALLBACK_PRIORITY.INVALID;
pub const TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY.COUNT;

pub const TP_POOL_STACK_INFORMATION = extern struct {
    StackReserve: ?*c_void,
    StackCommit: ?*c_void,
};

pub const TP_CLEANUP_GROUP = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const PTP_CLEANUP_GROUP_CANCEL_CALLBACK = fn(
    ObjectContext: ?*c_void,
    CleanupContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TP_CALLBACK_ENVIRON_V3 = extern struct {
    Version: u32,
    Pool: PTP_POOL,
    CleanupGroup: ?*c_void,
    CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
    RaceDll: *c_void,
    ActivationContext: ?*c_void,
    FinalizationCallback: PTP_SIMPLE_CALLBACK,
    u: TP_CALLBACK_ENVIRON_V3._u_e__Union,
    CallbackPriority: TP_CALLBACK_PRIORITY,
    Size: u32,
    const _u_e__Union = u32; // TODO: generate this nested type!
    const _ACTIVATION_CONTEXT = u32; // TODO: generate this nested type!
};

pub const TP_WORK = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const PTP_WORK_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
    Work: *TP_WORK,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TP_TIMER = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const PTP_TIMER_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
    Timer: *TP_TIMER,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TP_WAIT = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const PTP_WAIT_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
    Wait: *TP_WAIT,
    WaitResult: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const TP_IO = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const TEB = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const FARPROC = fn(
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NEARPROC = fn(
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PROC = fn(
) callconv(@import("std").os.windows.WINAPI) i32;

pub const APP_LOCAL_DEVICE_ID = extern struct {
    value: [32]u8,
};

pub const DPI_AWARENESS_CONTEXT__ = extern struct {
    unused: i32,
};

pub const PINIT_ONCE_FN = fn(
    InitOnce: *RTL_RUN_ONCE,
    Parameter: ?*c_void,
    Context: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PTIMERAPCROUTINE = fn(
    lpArgToCompletionRoutine: ?*c_void,
    dwTimerLowValue: u32,
    dwTimerHighValue: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PTP_WIN32_IO_CALLBACK = fn(
    Instance: *TP_CALLBACK_INSTANCE,
    Context: ?*c_void,
    Overlapped: ?*c_void,
    IoResult: u32,
    NumberOfBytesTransferred: ?*c_void,
    Io: *TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION = extern struct {
    MaxIops: i64,
    MaxBandwidth: i64,
    ReservationIops: i64,
    VolumeName: [*:0]const u16,
    BaseIoSize: u32,
    ControlFlags: u32,
};

pub const SECURITY_ATTRIBUTES = extern struct {
    nLength: u32,
    lpSecurityDescriptor: *c_void,
    bInheritHandle: BOOL,
};

pub const OVERLAPPED = extern struct {
    Internal: ?*c_void,
    InternalHigh: ?*c_void,
    Anonymous: OVERLAPPED._Anonymous_e__Union,
    hEvent: HANDLE,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_HEAP_ENTRY = extern struct {
    lpData: *c_void,
    cbData: u32,
    cbOverhead: u8,
    iRegionIndex: u8,
    wFlags: u16,
    Anonymous: PROCESS_HEAP_ENTRY._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const REASON_CONTEXT = extern struct {
    Version: u32,
    Flags: u32,
    Reason: REASON_CONTEXT._Reason_e__Union,
    const _Reason_e__Union = u32; // TODO: generate this nested type!
};

pub const PTHREAD_START_ROUTINE = fn(
    lpThreadParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPTHREAD_START_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PENCLAVE_ROUTINE = fn(
    lpThreadParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const LPENCLAVE_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const HEAP_SUMMARY = extern struct {
    cb: u32,
    cbAllocated: ?*c_void,
    cbCommitted: ?*c_void,
    cbReserved: ?*c_void,
    cbMaxReserve: ?*c_void,
};

pub const MEMORY_RESOURCE_NOTIFICATION_TYPE = extern enum(i32) {
    LowMemoryResourceNotification = 0,
    HighMemoryResourceNotification = 1,
};
pub const LowMemoryResourceNotification = MEMORY_RESOURCE_NOTIFICATION_TYPE.LowMemoryResourceNotification;
pub const HighMemoryResourceNotification = MEMORY_RESOURCE_NOTIFICATION_TYPE.HighMemoryResourceNotification;

pub const WIN32_MEMORY_RANGE_ENTRY = extern struct {
    VirtualAddress: *c_void,
    NumberOfBytes: ?*c_void,
};

pub const BAD_MEMORY_CALLBACK_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const PBAD_MEMORY_CALLBACK_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const OFFER_PRIORITY = extern enum(i32) {
    VmOfferPriorityVeryLow = 1,
    VmOfferPriorityLow = 2,
    VmOfferPriorityBelowNormal = 3,
    VmOfferPriorityNormal = 4,
};
pub const VmOfferPriorityVeryLow = OFFER_PRIORITY.VmOfferPriorityVeryLow;
pub const VmOfferPriorityLow = OFFER_PRIORITY.VmOfferPriorityLow;
pub const VmOfferPriorityBelowNormal = OFFER_PRIORITY.VmOfferPriorityBelowNormal;
pub const VmOfferPriorityNormal = OFFER_PRIORITY.VmOfferPriorityNormal;

pub const WIN32_MEMORY_INFORMATION_CLASS = extern enum(i32) {
    MemoryRegionInfo = 0,
};
pub const MemoryRegionInfo = WIN32_MEMORY_INFORMATION_CLASS.MemoryRegionInfo;

pub const WIN32_MEMORY_REGION_INFORMATION = extern struct {
    AllocationBase: *c_void,
    AllocationProtect: u32,
    Anonymous: WIN32_MEMORY_REGION_INFORMATION._Anonymous_e__Union,
    RegionSize: ?*c_void,
    CommitSize: ?*c_void,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const ENUMUILANG = extern struct {
    NumOfEnumUILang: u32,
    SizeOfEnumUIBuffer: u32,
    pEnumUIBuffer: *u16,
};

pub const ENUMRESLANGPROCA = fn(
    hModule: ?*c_void,
    lpType: [*:0]const u8,
    lpName: [*:0]const u8,
    wLanguage: u16,
    lParam: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const ENUMRESLANGPROCW = fn(
    hModule: ?*c_void,
    lpType: [*:0]const u16,
    lpName: [*:0]const u16,
    wLanguage: u16,
    lParam: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PGET_MODULE_HANDLE_EXA = fn(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u8,
    phModule: *?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PGET_MODULE_HANDLE_EXW = fn(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u16,
    phModule: *?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const REDIRECTION_FUNCTION_DESCRIPTOR = extern struct {
    DllName: [*:0]const u8,
    FunctionName: [*:0]const u8,
    RedirectionTarget: *c_void,
};

pub const REDIRECTION_DESCRIPTOR = extern struct {
    Version: u32,
    FunctionCount: u32,
    Redirections: *REDIRECTION_FUNCTION_DESCRIPTOR,
};

pub const COORD = extern struct {
    X: i16,
    Y: i16,
};

pub const SMALL_RECT = extern struct {
    Left: i16,
    Top: i16,
    Right: i16,
    Bottom: i16,
};

pub const KEY_EVENT_RECORD = extern struct {
    bKeyDown: BOOL,
    wRepeatCount: u16,
    wVirtualKeyCode: u16,
    wVirtualScanCode: u16,
    uChar: KEY_EVENT_RECORD._uChar_e__Union,
    dwControlKeyState: u32,
    const _uChar_e__Union = u32; // TODO: generate this nested type!
};

pub const MOUSE_EVENT_RECORD = extern struct {
    dwMousePosition: COORD,
    dwButtonState: u32,
    dwControlKeyState: u32,
    dwEventFlags: u32,
};

pub const WINDOW_BUFFER_SIZE_RECORD = extern struct {
    dwSize: COORD,
};

pub const MENU_EVENT_RECORD = extern struct {
    dwCommandId: u32,
};

pub const FOCUS_EVENT_RECORD = extern struct {
    bSetFocus: BOOL,
};

pub const INPUT_RECORD = extern struct {
    EventType: u16,
    Event: INPUT_RECORD._Event_e__Union,
    const _Event_e__Union = u32; // TODO: generate this nested type!
};

pub const CHAR_INFO = extern struct {
    Char: CHAR_INFO._Char_e__Union,
    Attributes: u16,
    const _Char_e__Union = u32; // TODO: generate this nested type!
};

pub const CONSOLE_FONT_INFO = extern struct {
    nFont: u32,
    dwFontSize: COORD,
};

pub const CONSOLE_READCONSOLE_CONTROL = extern struct {
    nLength: u32,
    nInitialChars: u32,
    dwCtrlWakeupMask: u32,
    dwControlKeyState: u32,
};

pub const PHANDLER_ROUTINE = fn(
    CtrlType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CONSOLE_CURSOR_INFO = extern struct {
    dwSize: u32,
    bVisible: BOOL,
};

pub const CONSOLE_SCREEN_BUFFER_INFO = extern struct {
    dwSize: COORD,
    dwCursorPosition: COORD,
    wAttributes: u16,
    srWindow: SMALL_RECT,
    dwMaximumWindowSize: COORD,
};

pub const CONSOLE_SCREEN_BUFFER_INFOEX = extern struct {
    cbSize: u32,
    dwSize: COORD,
    dwCursorPosition: COORD,
    wAttributes: u16,
    srWindow: SMALL_RECT,
    dwMaximumWindowSize: COORD,
    wPopupAttributes: u16,
    bFullscreenSupported: BOOL,
    ColorTable: [16]u32,
};

pub const CONSOLE_FONT_INFOEX = extern struct {
    cbSize: u32,
    nFont: u32,
    dwFontSize: COORD,
    FontFamily: u32,
    FontWeight: u32,
    FaceName: [32]u16,
};

pub const CONSOLE_SELECTION_INFO = extern struct {
    dwFlags: u32,
    dwSelectionAnchor: COORD,
    srSelection: SMALL_RECT,
};

pub const CONSOLE_HISTORY_INFO = extern struct {
    cbSize: u32,
    HistoryBufferSize: u32,
    NumberOfHistoryBuffers: u32,
    dwFlags: u32,
};

pub const TIMECALLBACK = fn(
    uTimerID: u32,
    uMsg: u32,
    dwUser: ?*c_void,
    dw1: ?*c_void,
    dw2: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const LPTIMECALLBACK = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const PM_OPEN_PROC = fn(
    param0: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PM_QUERY_PROC = fn(
    param0: *u32,
    param1: **c_void,
    param2: *u32,
    param3: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const RPC_IMPORT_CONTEXT_P = extern struct {
    LookupContext: *c_void,
    ProposedHandle: *c_void,
    Bindings: *RPC_BINDING_VECTOR,
};

pub const RemHGLOBAL = extern struct {
    fNullHGlobal: i32,
    cbData: u32,
    data: [1]u8,
};

pub const RemHMETAFILEPICT = extern struct {
    mm: i32,
    xExt: i32,
    yExt: i32,
    cbData: u32,
    data: [1]u8,
};

pub const RemHENHMETAFILE = extern struct {
    cbData: u32,
    data: [1]u8,
};

pub const RemHBITMAP = extern struct {
    cbData: u32,
    data: [1]u8,
};

pub const RemHPALETTE = extern struct {
    cbData: u32,
    data: [1]u8,
};

pub const RemBRUSH = extern struct {
    cbData: u32,
    data: [1]u8,
};

pub const userCLIPFORMAT = extern struct {
    fContext: i32,
    u: userCLIPFORMAT._u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const GDI_NONREMOTE = extern struct {
    fContext: i32,
    u: GDI_NONREMOTE._u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userHGLOBAL = extern struct {
    fContext: i32,
    u: userHGLOBAL._u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userHMETAFILE = extern struct {
    fContext: i32,
    u: userHMETAFILE._u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const remoteMETAFILEPICT = extern struct {
    mm: i32,
    xExt: i32,
    yExt: i32,
    hMF: *userHMETAFILE,
};

pub const userHMETAFILEPICT = extern struct {
    fContext: i32,
    u: userHMETAFILEPICT._u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userHENHMETAFILE = extern struct {
    fContext: i32,
    u: userHENHMETAFILE._u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userBITMAP = extern struct {
    bmType: i32,
    bmWidth: i32,
    bmHeight: i32,
    bmWidthBytes: i32,
    bmPlanes: u16,
    bmBitsPixel: u16,
    cbSize: u32,
    pBuffer: [1]u8,
};

pub const userHBITMAP = extern struct {
    fContext: i32,
    u: userHBITMAP._u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const userHPALETTE = extern struct {
    fContext: i32,
    u: userHPALETTE._u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const RemotableHandle = extern struct {
    fContext: i32,
    u: RemotableHandle._u_e__Struct,
    const _u_e__Struct = u32; // TODO: generate this nested type!
};

pub const CY = u32; // TODO: implement StructOrUnion types?

pub const DECIMAL = extern struct {
    wReserved: u16,
    Anonymous1: DECIMAL._Anonymous1_e__Union,
    Hi32: u32,
    Anonymous2: DECIMAL._Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const BSTRBLOB = extern struct {
    cbSize: u32,
    pData: *u8,
};

pub const CLIPDATA = extern struct {
    cbSize: u32,
    ulClipFmt: i32,
    pClipData: *u8,
};

pub const uCLSSPEC = extern struct {
    tyspec: u32,
    tagged_union: uCLSSPEC._tagged_union_e__Struct,
    const _tagged_union_e__Struct = u32; // TODO: generate this nested type!
};

pub const STORAGE_HOTPLUG_INFO = extern struct {
    Size: u32,
    MediaRemovable: u8,
    MediaHotplug: u8,
    DeviceHotplug: u8,
    WriteCacheEnableOverride: u8,
};

pub const STORAGE_DEVICE_NUMBER = extern struct {
    DeviceType: u32,
    DeviceNumber: u32,
    PartitionNumber: u32,
};

pub const STORAGE_DEVICE_NUMBERS = extern struct {
    Version: u32,
    Size: u32,
    NumberOfDevices: u32,
    Devices: [1]STORAGE_DEVICE_NUMBER,
};

pub const STORAGE_DEVICE_NUMBER_EX = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    DeviceType: u32,
    DeviceNumber: u32,
    DeviceGuid: Guid,
    PartitionNumber: u32,
};

pub const STORAGE_BUS_RESET_REQUEST = extern struct {
    PathId: u8,
};

pub const STORAGE_BREAK_RESERVATION_REQUEST = extern struct {
    Length: u32,
    _unused: u8,
    PathId: u8,
    TargetId: u8,
    Lun: u8,
};

pub const PREVENT_MEDIA_REMOVAL = extern struct {
    PreventMediaRemoval: u8,
};

pub const CLASS_MEDIA_CHANGE_CONTEXT = extern struct {
    MediaChangeCount: u32,
    NewState: u32,
};

pub const TAPE_STATISTICS = extern struct {
    Version: u32,
    Flags: u32,
    RecoveredWrites: LARGE_INTEGER,
    UnrecoveredWrites: LARGE_INTEGER,
    RecoveredReads: LARGE_INTEGER,
    UnrecoveredReads: LARGE_INTEGER,
    CompressionRatioReads: u8,
    CompressionRatioWrites: u8,
};

pub const TAPE_GET_STATISTICS = extern struct {
    Operation: u32,
};

pub const STORAGE_MEDIA_TYPE = extern enum(i32) {
    DDS_4mm = 32,
    MiniQic = 33,
    Travan = 34,
    QIC = 35,
    MP_8mm = 36,
    AME_8mm = 37,
    AIT1_8mm = 38,
    DLT = 39,
    NCTP = 40,
    IBM_3480 = 41,
    IBM_3490E = 42,
    IBM_Magstar_3590 = 43,
    IBM_Magstar_MP = 44,
    STK_DATA_D3 = 45,
    SONY_DTF = 46,
    DV_6mm = 47,
    DMI = 48,
    SONY_D2 = 49,
    CLEANER_CARTRIDGE = 50,
    CD_ROM = 51,
    CD_R = 52,
    CD_RW = 53,
    DVD_ROM = 54,
    DVD_R = 55,
    DVD_RW = 56,
    MO_3_RW = 57,
    MO_5_WO = 58,
    MO_5_RW = 59,
    MO_5_LIMDOW = 60,
    PC_5_WO = 61,
    PC_5_RW = 62,
    PD_5_RW = 63,
    ABL_5_WO = 64,
    PINNACLE_APEX_5_RW = 65,
    SONY_12_WO = 66,
    PHILIPS_12_WO = 67,
    HITACHI_12_WO = 68,
    CYGNET_12_WO = 69,
    KODAK_14_WO = 70,
    MO_NFR_525 = 71,
    NIKON_12_RW = 72,
    IOMEGA_ZIP = 73,
    IOMEGA_JAZ = 74,
    SYQUEST_EZ135 = 75,
    SYQUEST_EZFLYER = 76,
    SYQUEST_SYJET = 77,
    AVATAR_F2 = 78,
    MP2_8mm = 79,
    DST_S = 80,
    DST_M = 81,
    DST_L = 82,
    VXATape_1 = 83,
    VXATape_2 = 84,
    STK_9840 = 85,
    LTO_Ultrium = 86,
    LTO_Accelis = 87,
    DVD_RAM = 88,
    AIT_8mm = 89,
    ADR_1 = 90,
    ADR_2 = 91,
    STK_9940 = 92,
    SAIT = 93,
    VXATape = 94,
};
pub const DDS_4mm = STORAGE_MEDIA_TYPE.DDS_4mm;
pub const MiniQic = STORAGE_MEDIA_TYPE.MiniQic;
pub const Travan = STORAGE_MEDIA_TYPE.Travan;
pub const QIC = STORAGE_MEDIA_TYPE.QIC;
pub const MP_8mm = STORAGE_MEDIA_TYPE.MP_8mm;
pub const AME_8mm = STORAGE_MEDIA_TYPE.AME_8mm;
pub const AIT1_8mm = STORAGE_MEDIA_TYPE.AIT1_8mm;
pub const DLT = STORAGE_MEDIA_TYPE.DLT;
pub const NCTP = STORAGE_MEDIA_TYPE.NCTP;
pub const IBM_3480 = STORAGE_MEDIA_TYPE.IBM_3480;
pub const IBM_3490E = STORAGE_MEDIA_TYPE.IBM_3490E;
pub const IBM_Magstar_3590 = STORAGE_MEDIA_TYPE.IBM_Magstar_3590;
pub const IBM_Magstar_MP = STORAGE_MEDIA_TYPE.IBM_Magstar_MP;
pub const STK_DATA_D3 = STORAGE_MEDIA_TYPE.STK_DATA_D3;
pub const SONY_DTF = STORAGE_MEDIA_TYPE.SONY_DTF;
pub const DV_6mm = STORAGE_MEDIA_TYPE.DV_6mm;
pub const DMI = STORAGE_MEDIA_TYPE.DMI;
pub const SONY_D2 = STORAGE_MEDIA_TYPE.SONY_D2;
pub const CLEANER_CARTRIDGE = STORAGE_MEDIA_TYPE.CLEANER_CARTRIDGE;
pub const CD_ROM = STORAGE_MEDIA_TYPE.CD_ROM;
pub const CD_R = STORAGE_MEDIA_TYPE.CD_R;
pub const CD_RW = STORAGE_MEDIA_TYPE.CD_RW;
pub const DVD_ROM = STORAGE_MEDIA_TYPE.DVD_ROM;
pub const DVD_R = STORAGE_MEDIA_TYPE.DVD_R;
pub const DVD_RW = STORAGE_MEDIA_TYPE.DVD_RW;
pub const MO_3_RW = STORAGE_MEDIA_TYPE.MO_3_RW;
pub const MO_5_WO = STORAGE_MEDIA_TYPE.MO_5_WO;
pub const MO_5_RW = STORAGE_MEDIA_TYPE.MO_5_RW;
pub const MO_5_LIMDOW = STORAGE_MEDIA_TYPE.MO_5_LIMDOW;
pub const PC_5_WO = STORAGE_MEDIA_TYPE.PC_5_WO;
pub const PC_5_RW = STORAGE_MEDIA_TYPE.PC_5_RW;
pub const PD_5_RW = STORAGE_MEDIA_TYPE.PD_5_RW;
pub const ABL_5_WO = STORAGE_MEDIA_TYPE.ABL_5_WO;
pub const PINNACLE_APEX_5_RW = STORAGE_MEDIA_TYPE.PINNACLE_APEX_5_RW;
pub const SONY_12_WO = STORAGE_MEDIA_TYPE.SONY_12_WO;
pub const PHILIPS_12_WO = STORAGE_MEDIA_TYPE.PHILIPS_12_WO;
pub const HITACHI_12_WO = STORAGE_MEDIA_TYPE.HITACHI_12_WO;
pub const CYGNET_12_WO = STORAGE_MEDIA_TYPE.CYGNET_12_WO;
pub const KODAK_14_WO = STORAGE_MEDIA_TYPE.KODAK_14_WO;
pub const MO_NFR_525 = STORAGE_MEDIA_TYPE.MO_NFR_525;
pub const NIKON_12_RW = STORAGE_MEDIA_TYPE.NIKON_12_RW;
pub const IOMEGA_ZIP = STORAGE_MEDIA_TYPE.IOMEGA_ZIP;
pub const IOMEGA_JAZ = STORAGE_MEDIA_TYPE.IOMEGA_JAZ;
pub const SYQUEST_EZ135 = STORAGE_MEDIA_TYPE.SYQUEST_EZ135;
pub const SYQUEST_EZFLYER = STORAGE_MEDIA_TYPE.SYQUEST_EZFLYER;
pub const SYQUEST_SYJET = STORAGE_MEDIA_TYPE.SYQUEST_SYJET;
pub const AVATAR_F2 = STORAGE_MEDIA_TYPE.AVATAR_F2;
pub const MP2_8mm = STORAGE_MEDIA_TYPE.MP2_8mm;
pub const DST_S = STORAGE_MEDIA_TYPE.DST_S;
pub const DST_M = STORAGE_MEDIA_TYPE.DST_M;
pub const DST_L = STORAGE_MEDIA_TYPE.DST_L;
pub const VXATape_1 = STORAGE_MEDIA_TYPE.VXATape_1;
pub const VXATape_2 = STORAGE_MEDIA_TYPE.VXATape_2;
pub const STK_9840 = STORAGE_MEDIA_TYPE.STK_9840;
pub const LTO_Ultrium = STORAGE_MEDIA_TYPE.LTO_Ultrium;
pub const LTO_Accelis = STORAGE_MEDIA_TYPE.LTO_Accelis;
pub const DVD_RAM = STORAGE_MEDIA_TYPE.DVD_RAM;
pub const AIT_8mm = STORAGE_MEDIA_TYPE.AIT_8mm;
pub const ADR_1 = STORAGE_MEDIA_TYPE.ADR_1;
pub const ADR_2 = STORAGE_MEDIA_TYPE.ADR_2;
pub const STK_9940 = STORAGE_MEDIA_TYPE.STK_9940;
pub const SAIT = STORAGE_MEDIA_TYPE.SAIT;
pub const VXATape = STORAGE_MEDIA_TYPE.VXATape;

pub const STORAGE_BUS_TYPE = extern enum(i32) {
    BusTypeUnknown = 0,
    BusTypeScsi = 1,
    BusTypeAtapi = 2,
    BusTypeAta = 3,
    BusType1394 = 4,
    BusTypeSsa = 5,
    BusTypeFibre = 6,
    BusTypeUsb = 7,
    BusTypeRAID = 8,
    BusTypeiScsi = 9,
    BusTypeSas = 10,
    BusTypeSata = 11,
    BusTypeSd = 12,
    BusTypeMmc = 13,
    BusTypeVirtual = 14,
    BusTypeFileBackedVirtual = 15,
    BusTypeSpaces = 16,
    BusTypeNvme = 17,
    BusTypeSCM = 18,
    BusTypeUfs = 19,
    BusTypeMax = 20,
    BusTypeMaxReserved = 127,
};
pub const BusTypeUnknown = STORAGE_BUS_TYPE.BusTypeUnknown;
pub const BusTypeScsi = STORAGE_BUS_TYPE.BusTypeScsi;
pub const BusTypeAtapi = STORAGE_BUS_TYPE.BusTypeAtapi;
pub const BusTypeAta = STORAGE_BUS_TYPE.BusTypeAta;
pub const BusType1394 = STORAGE_BUS_TYPE.BusType1394;
pub const BusTypeSsa = STORAGE_BUS_TYPE.BusTypeSsa;
pub const BusTypeFibre = STORAGE_BUS_TYPE.BusTypeFibre;
pub const BusTypeUsb = STORAGE_BUS_TYPE.BusTypeUsb;
pub const BusTypeRAID = STORAGE_BUS_TYPE.BusTypeRAID;
pub const BusTypeiScsi = STORAGE_BUS_TYPE.BusTypeiScsi;
pub const BusTypeSas = STORAGE_BUS_TYPE.BusTypeSas;
pub const BusTypeSata = STORAGE_BUS_TYPE.BusTypeSata;
pub const BusTypeSd = STORAGE_BUS_TYPE.BusTypeSd;
pub const BusTypeMmc = STORAGE_BUS_TYPE.BusTypeMmc;
pub const BusTypeVirtual = STORAGE_BUS_TYPE.BusTypeVirtual;
pub const BusTypeFileBackedVirtual = STORAGE_BUS_TYPE.BusTypeFileBackedVirtual;
pub const BusTypeSpaces = STORAGE_BUS_TYPE.BusTypeSpaces;
pub const BusTypeNvme = STORAGE_BUS_TYPE.BusTypeNvme;
pub const BusTypeSCM = STORAGE_BUS_TYPE.BusTypeSCM;
pub const BusTypeUfs = STORAGE_BUS_TYPE.BusTypeUfs;
pub const BusTypeMax = STORAGE_BUS_TYPE.BusTypeMax;
pub const BusTypeMaxReserved = STORAGE_BUS_TYPE.BusTypeMaxReserved;

pub const DEVICE_MEDIA_INFO = extern struct {
    DeviceSpecific: DEVICE_MEDIA_INFO._DeviceSpecific_e__Union,
    const _DeviceSpecific_e__Union = u32; // TODO: generate this nested type!
};

pub const GET_MEDIA_TYPES = extern struct {
    DeviceType: u32,
    MediaInfoCount: u32,
    MediaInfo: [1]DEVICE_MEDIA_INFO,
};

pub const STORAGE_PREDICT_FAILURE = extern struct {
    PredictFailure: u32,
    VendorSpecific: [512]u8,
};

pub const STORAGE_FAILURE_PREDICTION_CONFIG = extern struct {
    Version: u32,
    Size: u32,
    Set: u8,
    Enabled: u8,
    Reserved: u16,
};

pub const STORAGE_SET_TYPE = extern enum(i32) {
    PropertyStandardSet = 0,
    PropertyExistsSet = 1,
    PropertySetMaxDefined = 2,
};
pub const PropertyStandardSet = STORAGE_SET_TYPE.PropertyStandardSet;
pub const PropertyExistsSet = STORAGE_SET_TYPE.PropertyExistsSet;
pub const PropertySetMaxDefined = STORAGE_SET_TYPE.PropertySetMaxDefined;

pub const STORAGE_PROPERTY_SET = extern struct {
    PropertyId: STORAGE_PROPERTY_ID,
    SetType: STORAGE_SET_TYPE,
    AdditionalParameters: [1]u8,
};

pub const STORAGE_IDENTIFIER_CODE_SET = extern enum(i32) {
    StorageIdCodeSetReserved = 0,
    StorageIdCodeSetBinary = 1,
    StorageIdCodeSetAscii = 2,
    StorageIdCodeSetUtf8 = 3,
};
pub const StorageIdCodeSetReserved = STORAGE_IDENTIFIER_CODE_SET.StorageIdCodeSetReserved;
pub const StorageIdCodeSetBinary = STORAGE_IDENTIFIER_CODE_SET.StorageIdCodeSetBinary;
pub const StorageIdCodeSetAscii = STORAGE_IDENTIFIER_CODE_SET.StorageIdCodeSetAscii;
pub const StorageIdCodeSetUtf8 = STORAGE_IDENTIFIER_CODE_SET.StorageIdCodeSetUtf8;

pub const STORAGE_IDENTIFIER_TYPE = extern enum(i32) {
    StorageIdTypeVendorSpecific = 0,
    StorageIdTypeVendorId = 1,
    StorageIdTypeEUI64 = 2,
    StorageIdTypeFCPHName = 3,
    StorageIdTypePortRelative = 4,
    StorageIdTypeTargetPortGroup = 5,
    StorageIdTypeLogicalUnitGroup = 6,
    StorageIdTypeMD5LogicalUnitIdentifier = 7,
    StorageIdTypeScsiNameString = 8,
};
pub const StorageIdTypeVendorSpecific = STORAGE_IDENTIFIER_TYPE.StorageIdTypeVendorSpecific;
pub const StorageIdTypeVendorId = STORAGE_IDENTIFIER_TYPE.StorageIdTypeVendorId;
pub const StorageIdTypeEUI64 = STORAGE_IDENTIFIER_TYPE.StorageIdTypeEUI64;
pub const StorageIdTypeFCPHName = STORAGE_IDENTIFIER_TYPE.StorageIdTypeFCPHName;
pub const StorageIdTypePortRelative = STORAGE_IDENTIFIER_TYPE.StorageIdTypePortRelative;
pub const StorageIdTypeTargetPortGroup = STORAGE_IDENTIFIER_TYPE.StorageIdTypeTargetPortGroup;
pub const StorageIdTypeLogicalUnitGroup = STORAGE_IDENTIFIER_TYPE.StorageIdTypeLogicalUnitGroup;
pub const StorageIdTypeMD5LogicalUnitIdentifier = STORAGE_IDENTIFIER_TYPE.StorageIdTypeMD5LogicalUnitIdentifier;
pub const StorageIdTypeScsiNameString = STORAGE_IDENTIFIER_TYPE.StorageIdTypeScsiNameString;

pub const STORAGE_ID_NAA_FORMAT = extern enum(i32) {
    StorageIdNAAFormatIEEEExtended = 2,
    StorageIdNAAFormatIEEERegistered = 3,
    StorageIdNAAFormatIEEEERegisteredExtended = 5,
};
pub const StorageIdNAAFormatIEEEExtended = STORAGE_ID_NAA_FORMAT.StorageIdNAAFormatIEEEExtended;
pub const StorageIdNAAFormatIEEERegistered = STORAGE_ID_NAA_FORMAT.StorageIdNAAFormatIEEERegistered;
pub const StorageIdNAAFormatIEEEERegisteredExtended = STORAGE_ID_NAA_FORMAT.StorageIdNAAFormatIEEEERegisteredExtended;

pub const STORAGE_ASSOCIATION_TYPE = extern enum(i32) {
    StorageIdAssocDevice = 0,
    StorageIdAssocPort = 1,
    StorageIdAssocTarget = 2,
};
pub const StorageIdAssocDevice = STORAGE_ASSOCIATION_TYPE.StorageIdAssocDevice;
pub const StorageIdAssocPort = STORAGE_ASSOCIATION_TYPE.StorageIdAssocPort;
pub const StorageIdAssocTarget = STORAGE_ASSOCIATION_TYPE.StorageIdAssocTarget;

pub const STORAGE_IDENTIFIER = extern struct {
    CodeSet: STORAGE_IDENTIFIER_CODE_SET,
    Type: STORAGE_IDENTIFIER_TYPE,
    IdentifierSize: u16,
    NextOffset: u16,
    Association: STORAGE_ASSOCIATION_TYPE,
    Identifier: [1]u8,
};

pub const STORAGE_LB_PROVISIONING_MAP_RESOURCES = extern struct {
    Size: u32,
    Version: u32,
    _bitfield1: u8,
    Reserved1: [3]u8,
    _bitfield2: u8,
    Reserved3: [3]u8,
    AvailableMappingResources: u64,
    UsedMappingResources: u64,
};

pub const STORAGE_RPMB_FRAME_TYPE = extern enum(i32) {
    StorageRpmbFrameTypeUnknown = 0,
    StorageRpmbFrameTypeStandard = 1,
    StorageRpmbFrameTypeMax = 2,
};
pub const StorageRpmbFrameTypeUnknown = STORAGE_RPMB_FRAME_TYPE.StorageRpmbFrameTypeUnknown;
pub const StorageRpmbFrameTypeStandard = STORAGE_RPMB_FRAME_TYPE.StorageRpmbFrameTypeStandard;
pub const StorageRpmbFrameTypeMax = STORAGE_RPMB_FRAME_TYPE.StorageRpmbFrameTypeMax;

pub const STORAGE_RPMB_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    SizeInBytes: u32,
    MaxReliableWriteSizeInBytes: u32,
    FrameFormat: STORAGE_RPMB_FRAME_TYPE,
};

pub const STORAGE_CRYPTO_ALGORITHM_ID = extern enum(i32) {
    StorageCryptoAlgorithmUnknown = 0,
    StorageCryptoAlgorithmXTSAES = 1,
    StorageCryptoAlgorithmBitlockerAESCBC = 2,
    StorageCryptoAlgorithmAESECB = 3,
    StorageCryptoAlgorithmESSIVAESCBC = 4,
    StorageCryptoAlgorithmMax = 5,
};
pub const StorageCryptoAlgorithmUnknown = STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmUnknown;
pub const StorageCryptoAlgorithmXTSAES = STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmXTSAES;
pub const StorageCryptoAlgorithmBitlockerAESCBC = STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmBitlockerAESCBC;
pub const StorageCryptoAlgorithmAESECB = STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmAESECB;
pub const StorageCryptoAlgorithmESSIVAESCBC = STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmESSIVAESCBC;
pub const StorageCryptoAlgorithmMax = STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmMax;

pub const STORAGE_CRYPTO_KEY_SIZE = extern enum(i32) {
    StorageCryptoKeySizeUnknown = 0,
    StorageCryptoKeySize128Bits = 1,
    StorageCryptoKeySize192Bits = 2,
    StorageCryptoKeySize256Bits = 3,
    StorageCryptoKeySize512Bits = 4,
};
pub const StorageCryptoKeySizeUnknown = STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySizeUnknown;
pub const StorageCryptoKeySize128Bits = STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySize128Bits;
pub const StorageCryptoKeySize192Bits = STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySize192Bits;
pub const StorageCryptoKeySize256Bits = STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySize256Bits;
pub const StorageCryptoKeySize512Bits = STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySize512Bits;

pub const STORAGE_CRYPTO_CAPABILITY = extern struct {
    Version: u32,
    Size: u32,
    CryptoCapabilityIndex: u32,
    AlgorithmId: STORAGE_CRYPTO_ALGORITHM_ID,
    KeySize: STORAGE_CRYPTO_KEY_SIZE,
    DataUnitSizeBitmask: u32,
};

pub const STORAGE_CRYPTO_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NumKeysSupported: u32,
    NumCryptoCapabilities: u32,
    CryptoCapabilities: [1]STORAGE_CRYPTO_CAPABILITY,
};

pub const STORAGE_TIER_MEDIA_TYPE = extern enum(i32) {
    StorageTierMediaTypeUnspecified = 0,
    StorageTierMediaTypeDisk = 1,
    StorageTierMediaTypeSsd = 2,
    StorageTierMediaTypeScm = 4,
    StorageTierMediaTypeMax = 5,
};
pub const StorageTierMediaTypeUnspecified = STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeUnspecified;
pub const StorageTierMediaTypeDisk = STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeDisk;
pub const StorageTierMediaTypeSsd = STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeSsd;
pub const StorageTierMediaTypeScm = STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeScm;
pub const StorageTierMediaTypeMax = STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeMax;

pub const STORAGE_TIER_CLASS = extern enum(i32) {
    StorageTierClassUnspecified = 0,
    StorageTierClassCapacity = 1,
    StorageTierClassPerformance = 2,
    StorageTierClassMax = 3,
};
pub const StorageTierClassUnspecified = STORAGE_TIER_CLASS.StorageTierClassUnspecified;
pub const StorageTierClassCapacity = STORAGE_TIER_CLASS.StorageTierClassCapacity;
pub const StorageTierClassPerformance = STORAGE_TIER_CLASS.StorageTierClassPerformance;
pub const StorageTierClassMax = STORAGE_TIER_CLASS.StorageTierClassMax;

pub const STORAGE_TIER = extern struct {
    Id: Guid,
    Name: [256]u16,
    Description: [256]u16,
    Flags: u64,
    ProvisionedCapacity: u64,
    MediaType: STORAGE_TIER_MEDIA_TYPE,
    Class: STORAGE_TIER_CLASS,
};

pub const STORAGE_DEVICE_TIERING_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    TotalNumberOfTiers: u32,
    NumberOfTiersReturned: u32,
    Tiers: [1]STORAGE_TIER,
};

pub const STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    NumberOfFaultDomains: u32,
    FaultDomainIds: [1]Guid,
};

pub const STORAGE_PROTOCOL_UFS_DATA_TYPE = extern enum(i32) {
    UfsDataTypeUnknown = 0,
    UfsDataTypeQueryDescriptor = 1,
    UfsDataTypeMax = 2,
};
pub const UfsDataTypeUnknown = STORAGE_PROTOCOL_UFS_DATA_TYPE.UfsDataTypeUnknown;
pub const UfsDataTypeQueryDescriptor = STORAGE_PROTOCOL_UFS_DATA_TYPE.UfsDataTypeQueryDescriptor;
pub const UfsDataTypeMax = STORAGE_PROTOCOL_UFS_DATA_TYPE.UfsDataTypeMax;

pub const STORAGE_PROTOCOL_SPECIFIC_DATA_EXT = extern struct {
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    DataType: u32,
    ProtocolDataValue: u32,
    ProtocolDataSubValue: u32,
    ProtocolDataOffset: u32,
    ProtocolDataLength: u32,
    FixedProtocolReturnData: u32,
    ProtocolDataSubValue2: u32,
    ProtocolDataSubValue3: u32,
    ProtocolDataSubValue4: u32,
    ProtocolDataSubValue5: u32,
    Reserved: [5]u32,
};

pub const STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = extern struct {
    Version: u32,
    Size: u32,
    ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA_EXT,
};

pub const STORAGE_DISK_HEALTH_STATUS = extern enum(i32) {
    DiskHealthUnknown = 0,
    DiskHealthUnhealthy = 1,
    DiskHealthWarning = 2,
    DiskHealthHealthy = 3,
    DiskHealthMax = 4,
};
pub const DiskHealthUnknown = STORAGE_DISK_HEALTH_STATUS.DiskHealthUnknown;
pub const DiskHealthUnhealthy = STORAGE_DISK_HEALTH_STATUS.DiskHealthUnhealthy;
pub const DiskHealthWarning = STORAGE_DISK_HEALTH_STATUS.DiskHealthWarning;
pub const DiskHealthHealthy = STORAGE_DISK_HEALTH_STATUS.DiskHealthHealthy;
pub const DiskHealthMax = STORAGE_DISK_HEALTH_STATUS.DiskHealthMax;

pub const STORAGE_DISK_OPERATIONAL_STATUS = extern enum(i32) {
    DiskOpStatusNone = 0,
    DiskOpStatusUnknown = 1,
    DiskOpStatusOk = 2,
    DiskOpStatusPredictingFailure = 3,
    DiskOpStatusInService = 4,
    DiskOpStatusHardwareError = 5,
    DiskOpStatusNotUsable = 6,
    DiskOpStatusTransientError = 7,
    DiskOpStatusMissing = 8,
};
pub const DiskOpStatusNone = STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusNone;
pub const DiskOpStatusUnknown = STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusUnknown;
pub const DiskOpStatusOk = STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusOk;
pub const DiskOpStatusPredictingFailure = STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusPredictingFailure;
pub const DiskOpStatusInService = STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusInService;
pub const DiskOpStatusHardwareError = STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusHardwareError;
pub const DiskOpStatusNotUsable = STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusNotUsable;
pub const DiskOpStatusTransientError = STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusTransientError;
pub const DiskOpStatusMissing = STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusMissing;

pub const STORAGE_OPERATIONAL_STATUS_REASON = extern enum(i32) {
    DiskOpReasonUnknown = 0,
    DiskOpReasonScsiSenseCode = 1,
    DiskOpReasonMedia = 2,
    DiskOpReasonIo = 3,
    DiskOpReasonThresholdExceeded = 4,
    DiskOpReasonLostData = 5,
    DiskOpReasonEnergySource = 6,
    DiskOpReasonConfiguration = 7,
    DiskOpReasonDeviceController = 8,
    DiskOpReasonMediaController = 9,
    DiskOpReasonComponent = 10,
    DiskOpReasonNVDIMM_N = 11,
    DiskOpReasonBackgroundOperation = 12,
    DiskOpReasonInvalidFirmware = 13,
    DiskOpReasonHealthCheck = 14,
    DiskOpReasonLostDataPersistence = 15,
    DiskOpReasonDisabledByPlatform = 16,
    DiskOpReasonLostWritePersistence = 17,
    DiskOpReasonDataPersistenceLossImminent = 18,
    DiskOpReasonWritePersistenceLossImminent = 19,
    DiskOpReasonMax = 20,
};
pub const DiskOpReasonUnknown = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonUnknown;
pub const DiskOpReasonScsiSenseCode = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonScsiSenseCode;
pub const DiskOpReasonMedia = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonMedia;
pub const DiskOpReasonIo = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonIo;
pub const DiskOpReasonThresholdExceeded = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonThresholdExceeded;
pub const DiskOpReasonLostData = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonLostData;
pub const DiskOpReasonEnergySource = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonEnergySource;
pub const DiskOpReasonConfiguration = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonConfiguration;
pub const DiskOpReasonDeviceController = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonDeviceController;
pub const DiskOpReasonMediaController = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonMediaController;
pub const DiskOpReasonComponent = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonComponent;
pub const DiskOpReasonNVDIMM_N = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonNVDIMM_N;
pub const DiskOpReasonBackgroundOperation = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonBackgroundOperation;
pub const DiskOpReasonInvalidFirmware = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonInvalidFirmware;
pub const DiskOpReasonHealthCheck = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonHealthCheck;
pub const DiskOpReasonLostDataPersistence = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonLostDataPersistence;
pub const DiskOpReasonDisabledByPlatform = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonDisabledByPlatform;
pub const DiskOpReasonLostWritePersistence = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonLostWritePersistence;
pub const DiskOpReasonDataPersistenceLossImminent = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonDataPersistenceLossImminent;
pub const DiskOpReasonWritePersistenceLossImminent = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonWritePersistenceLossImminent;
pub const DiskOpReasonMax = STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonMax;

pub const STORAGE_OPERATIONAL_REASON = extern struct {
    Version: u32,
    Size: u32,
    Reason: STORAGE_OPERATIONAL_STATUS_REASON,
    RawBytes: STORAGE_OPERATIONAL_REASON._RawBytes_e__Union,
    const _RawBytes_e__Union = u32; // TODO: generate this nested type!
};

pub const STORAGE_DEVICE_MANAGEMENT_STATUS = extern struct {
    Version: u32,
    Size: u32,
    Health: STORAGE_DISK_HEALTH_STATUS,
    NumberOfOperationalStatus: u32,
    NumberOfAdditionalReasons: u32,
    OperationalStatus: [16]STORAGE_DISK_OPERATIONAL_STATUS,
    AdditionalReasons: [1]STORAGE_OPERATIONAL_REASON,
};

pub const STORAGE_ZONED_DEVICE_TYPES = extern enum(i32) {
    ZonedDeviceTypeUnknown = 0,
    ZonedDeviceTypeHostManaged = 1,
    ZonedDeviceTypeHostAware = 2,
    ZonedDeviceTypeDeviceManaged = 3,
};
pub const ZonedDeviceTypeUnknown = STORAGE_ZONED_DEVICE_TYPES.ZonedDeviceTypeUnknown;
pub const ZonedDeviceTypeHostManaged = STORAGE_ZONED_DEVICE_TYPES.ZonedDeviceTypeHostManaged;
pub const ZonedDeviceTypeHostAware = STORAGE_ZONED_DEVICE_TYPES.ZonedDeviceTypeHostAware;
pub const ZonedDeviceTypeDeviceManaged = STORAGE_ZONED_DEVICE_TYPES.ZonedDeviceTypeDeviceManaged;

pub const STORAGE_ZONE_TYPES = extern enum(i32) {
    ZoneTypeUnknown = 0,
    ZoneTypeConventional = 1,
    ZoneTypeSequentialWriteRequired = 2,
    ZoneTypeSequentialWritePreferred = 3,
    ZoneTypeMax = 4,
};
pub const ZoneTypeUnknown = STORAGE_ZONE_TYPES.ZoneTypeUnknown;
pub const ZoneTypeConventional = STORAGE_ZONE_TYPES.ZoneTypeConventional;
pub const ZoneTypeSequentialWriteRequired = STORAGE_ZONE_TYPES.ZoneTypeSequentialWriteRequired;
pub const ZoneTypeSequentialWritePreferred = STORAGE_ZONE_TYPES.ZoneTypeSequentialWritePreferred;
pub const ZoneTypeMax = STORAGE_ZONE_TYPES.ZoneTypeMax;

pub const STORAGE_ZONE_GROUP = extern struct {
    ZoneCount: u32,
    ZoneType: STORAGE_ZONE_TYPES,
    ZoneSize: u64,
};

pub const STORAGE_ZONED_DEVICE_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    DeviceType: STORAGE_ZONED_DEVICE_TYPES,
    ZoneCount: u32,
    ZoneAttributes: STORAGE_ZONED_DEVICE_DESCRIPTOR._ZoneAttributes_e__Union,
    ZoneGroupCount: u32,
    ZoneGroup: [1]STORAGE_ZONE_GROUP,
    const _ZoneAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const DEVICE_LOCATION = extern struct {
    Socket: u32,
    Slot: u32,
    Adapter: u32,
    Port: u32,
    Anonymous: DEVICE_LOCATION._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const STORAGE_DEVICE_LOCATION_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    Location: DEVICE_LOCATION,
    StringOffset: u32,
};

pub const STORAGE_DEVICE_NUMA_PROPERTY = extern struct {
    Version: u32,
    Size: u32,
    NumaNode: u32,
};

pub const STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = extern struct {
    Version: u32,
    Size: u32,
    UnsafeShutdownCount: u32,
};

pub const STORAGE_HW_ENDURANCE_INFO = extern struct {
    ValidFields: u32,
    GroupId: u32,
    Flags: STORAGE_HW_ENDURANCE_INFO._Flags_e__Struct,
    LifePercentage: u32,
    BytesReadCount: [16]u8,
    ByteWriteCount: [16]u8,
    const _Flags_e__Struct = u32; // TODO: generate this nested type!
};

pub const STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    EnduranceInfo: STORAGE_HW_ENDURANCE_INFO,
};

pub const DEVICE_DATA_SET_RANGE = extern struct {
    StartingOffset: i64,
    LengthInBytes: u64,
};

pub const DEVICE_MANAGE_DATA_SET_ATTRIBUTES = extern struct {
    Size: u32,
    Action: u32,
    Flags: u32,
    ParameterBlockOffset: u32,
    ParameterBlockLength: u32,
    DataSetRangesOffset: u32,
    DataSetRangesLength: u32,
};

pub const DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = extern struct {
    Size: u32,
    Action: u32,
    Flags: u32,
    OperationStatus: u32,
    ExtendedError: u32,
    TargetDetailedError: u32,
    ReservedStatus: u32,
    OutputBlockOffset: u32,
    OutputBlockLength: u32,
};

pub const DEVICE_DSM_DEFINITION = extern struct {
    Action: u32,
    SingleRange: u8,
    ParameterBlockAlignment: u32,
    ParameterBlockLength: u32,
    HasOutput: u8,
    OutputBlockAlignment: u32,
    OutputBlockLength: u32,
};

pub const DEVICE_DSM_NOTIFICATION_PARAMETERS = extern struct {
    Size: u32,
    Flags: u32,
    NumFileTypeIDs: u32,
    FileTypeID: [1]Guid,
};

pub const STORAGE_OFFLOAD_TOKEN = extern struct {
    TokenType: [4]u8,
    Reserved: [2]u8,
    TokenIdLength: [2]u8,
    Anonymous: STORAGE_OFFLOAD_TOKEN._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DEVICE_DSM_OFFLOAD_READ_PARAMETERS = extern struct {
    Flags: u32,
    TimeToLive: u32,
    Reserved: [2]u32,
};

pub const STORAGE_OFFLOAD_READ_OUTPUT = extern struct {
    OffloadReadFlags: u32,
    Reserved: u32,
    LengthProtected: u64,
    TokenLength: u32,
    Token: STORAGE_OFFLOAD_TOKEN,
};

pub const DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = extern struct {
    Flags: u32,
    Reserved: u32,
    TokenOffset: u64,
    Token: STORAGE_OFFLOAD_TOKEN,
};

pub const STORAGE_OFFLOAD_WRITE_OUTPUT = extern struct {
    OffloadWriteFlags: u32,
    Reserved: u32,
    LengthCopied: u64,
};

pub const DEVICE_DATA_SET_LBP_STATE_PARAMETERS = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    OutputVersion: u32,
};

pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE = extern struct {
    Size: u32,
    Version: u32,
    SlabSizeInBytes: u64,
    SlabOffsetDeltaInBytes: u32,
    SlabAllocationBitMapBitCount: u32,
    SlabAllocationBitMapLength: u32,
    SlabAllocationBitMap: [1]u32,
};

pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = extern struct {
    Size: u32,
    Version: u32,
    SlabSizeInBytes: u64,
    SlabOffsetDeltaInBytes: u64,
    SlabAllocationBitMapBitCount: u32,
    SlabAllocationBitMapLength: u32,
    SlabAllocationBitMap: [1]u32,
};

pub const DEVICE_DATA_SET_REPAIR_PARAMETERS = extern struct {
    NumberOfRepairCopies: u32,
    SourceCopy: u32,
    RepairCopies: [1]u32,
};

pub const DEVICE_DATA_SET_REPAIR_OUTPUT = extern struct {
    ParityExtent: DEVICE_DATA_SET_RANGE,
};

pub const DEVICE_DATA_SET_SCRUB_OUTPUT = extern struct {
    BytesProcessed: u64,
    BytesRepaired: u64,
    BytesFailed: u64,
};

pub const DEVICE_DATA_SET_SCRUB_EX_OUTPUT = extern struct {
    BytesProcessed: u64,
    BytesRepaired: u64,
    BytesFailed: u64,
    ParityExtent: DEVICE_DATA_SET_RANGE,
};

pub const DEVICE_DSM_TIERING_QUERY_INPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    NumberOfTierIds: u32,
    TierIds: [1]Guid,
};

pub const STORAGE_TIER_REGION = extern struct {
    TierId: Guid,
    Offset: u64,
    Length: u64,
};

pub const DEVICE_DSM_TIERING_QUERY_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Reserved: u32,
    Alignment: u64,
    TotalNumberOfRegions: u32,
    NumberOfRegionsReturned: u32,
    Regions: [1]STORAGE_TIER_REGION,
};

pub const DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = extern struct {
    Size: u32,
    TargetPriority: u8,
    Reserved: [3]u8,
};

pub const DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = extern struct {
    TopologyRangeBytes: u64,
    TopologyId: [16]u8,
};

pub const DEVICE_STORAGE_ADDRESS_RANGE = extern struct {
    StartAddress: i64,
    LengthInBytes: u64,
};

pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = extern struct {
    Version: u32,
    Flags: u32,
    TotalNumberOfRanges: u32,
    NumberOfRangesReturned: u32,
    Ranges: [1]DEVICE_STORAGE_ADDRESS_RANGE,
};

pub const DEVICE_DSM_REPORT_ZONES_PARAMETERS = extern struct {
    Size: u32,
    ReportOption: u8,
    Partial: u8,
    Reserved: [2]u8,
};

pub const STORAGE_ZONES_ATTRIBUTES = extern enum(i32) {
    ZonesAttributeTypeAndLengthMayDifferent = 0,
    ZonesAttributeTypeSameLengthSame = 1,
    ZonesAttributeTypeSameLastZoneLengthDifferent = 2,
    ZonesAttributeTypeMayDifferentLengthSame = 3,
};
pub const ZonesAttributeTypeAndLengthMayDifferent = STORAGE_ZONES_ATTRIBUTES.ZonesAttributeTypeAndLengthMayDifferent;
pub const ZonesAttributeTypeSameLengthSame = STORAGE_ZONES_ATTRIBUTES.ZonesAttributeTypeSameLengthSame;
pub const ZonesAttributeTypeSameLastZoneLengthDifferent = STORAGE_ZONES_ATTRIBUTES.ZonesAttributeTypeSameLastZoneLengthDifferent;
pub const ZonesAttributeTypeMayDifferentLengthSame = STORAGE_ZONES_ATTRIBUTES.ZonesAttributeTypeMayDifferentLengthSame;

pub const STORAGE_ZONE_CONDITION = extern enum(i32) {
    ZoneConditionConventional = 0,
    ZoneConditionEmpty = 1,
    ZoneConditionImplicitlyOpened = 2,
    ZoneConditionExplicitlyOpened = 3,
    ZoneConditionClosed = 4,
    ZoneConditionReadOnly = 13,
    ZoneConditionFull = 14,
    ZoneConditionOffline = 15,
};
pub const ZoneConditionConventional = STORAGE_ZONE_CONDITION.ZoneConditionConventional;
pub const ZoneConditionEmpty = STORAGE_ZONE_CONDITION.ZoneConditionEmpty;
pub const ZoneConditionImplicitlyOpened = STORAGE_ZONE_CONDITION.ZoneConditionImplicitlyOpened;
pub const ZoneConditionExplicitlyOpened = STORAGE_ZONE_CONDITION.ZoneConditionExplicitlyOpened;
pub const ZoneConditionClosed = STORAGE_ZONE_CONDITION.ZoneConditionClosed;
pub const ZoneConditionReadOnly = STORAGE_ZONE_CONDITION.ZoneConditionReadOnly;
pub const ZoneConditionFull = STORAGE_ZONE_CONDITION.ZoneConditionFull;
pub const ZoneConditionOffline = STORAGE_ZONE_CONDITION.ZoneConditionOffline;

pub const STORAGE_ZONE_DESCRIPTOR = extern struct {
    Size: u32,
    ZoneType: STORAGE_ZONE_TYPES,
    ZoneCondition: STORAGE_ZONE_CONDITION,
    ResetWritePointerRecommend: u8,
    Reserved0: [3]u8,
    ZoneSize: u64,
    WritePointerOffset: u64,
};

pub const DEVICE_DSM_REPORT_ZONES_DATA = extern struct {
    Size: u32,
    ZoneCount: u32,
    Attributes: STORAGE_ZONES_ATTRIBUTES,
    Reserved0: u32,
    ZoneDescriptors: [1]STORAGE_ZONE_DESCRIPTOR,
};

pub const DEVICE_STORAGE_RANGE_ATTRIBUTES = extern struct {
    LengthInBytes: u64,
    Anonymous: DEVICE_STORAGE_RANGE_ATTRIBUTES._Anonymous_e__Union,
    Reserved: u32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DEVICE_DSM_RANGE_ERROR_INFO = extern struct {
    Version: u32,
    Flags: u32,
    TotalNumberOfRanges: u32,
    NumberOfRangesReturned: u32,
    Ranges: [1]DEVICE_STORAGE_RANGE_ATTRIBUTES,
};

pub const DEVICE_DSM_LOST_QUERY_PARAMETERS = extern struct {
    Version: u32,
    Granularity: u64,
};

pub const DEVICE_DSM_LOST_QUERY_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Alignment: u64,
    NumberOfBits: u32,
    BitMap: [1]u32,
};

pub const DEVICE_DSM_FREE_SPACE_OUTPUT = extern struct {
    Version: u32,
    FreeSpace: u64,
};

pub const DEVICE_DSM_CONVERSION_OUTPUT = extern struct {
    Version: u32,
    Source: Guid,
};

pub const STORAGE_GET_BC_PROPERTIES_OUTPUT = extern struct {
    MaximumRequestsPerPeriod: u32,
    MinimumPeriod: u32,
    MaximumRequestSize: u64,
    EstimatedTimePerRequest: u32,
    NumOutStandingRequests: u32,
    RequestSize: u64,
};

pub const STORAGE_ALLOCATE_BC_STREAM_INPUT = extern struct {
    Version: u32,
    RequestsPerPeriod: u32,
    Period: u32,
    RetryFailures: u8,
    Discardable: u8,
    Reserved1: [2]u8,
    AccessType: u32,
    AccessMode: u32,
};

pub const STORAGE_ALLOCATE_BC_STREAM_OUTPUT = extern struct {
    RequestSize: u64,
    NumOutStandingRequests: u32,
};

pub const STORAGE_PRIORITY_HINT_SUPPORT = extern struct {
    SupportFlags: u32,
};

pub const STORAGE_DIAGNOSTIC_LEVEL = extern enum(i32) {
    StorageDiagnosticLevelDefault = 0,
    StorageDiagnosticLevelMax = 1,
};
pub const StorageDiagnosticLevelDefault = STORAGE_DIAGNOSTIC_LEVEL.StorageDiagnosticLevelDefault;
pub const StorageDiagnosticLevelMax = STORAGE_DIAGNOSTIC_LEVEL.StorageDiagnosticLevelMax;

pub const STORAGE_DIAGNOSTIC_TARGET_TYPE = extern enum(i32) {
    StorageDiagnosticTargetTypeUndefined = 0,
    StorageDiagnosticTargetTypePort = 1,
    StorageDiagnosticTargetTypeMiniport = 2,
    StorageDiagnosticTargetTypeHbaFirmware = 3,
    StorageDiagnosticTargetTypeMax = 4,
};
pub const StorageDiagnosticTargetTypeUndefined = STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypeUndefined;
pub const StorageDiagnosticTargetTypePort = STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypePort;
pub const StorageDiagnosticTargetTypeMiniport = STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypeMiniport;
pub const StorageDiagnosticTargetTypeHbaFirmware = STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypeHbaFirmware;
pub const StorageDiagnosticTargetTypeMax = STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypeMax;

pub const STORAGE_DIAGNOSTIC_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    Reserved: u32,
    TargetType: STORAGE_DIAGNOSTIC_TARGET_TYPE,
    Level: STORAGE_DIAGNOSTIC_LEVEL,
};

pub const STORAGE_DIAGNOSTIC_DATA = extern struct {
    Version: u32,
    Size: u32,
    ProviderId: Guid,
    BufferSize: u32,
    Reserved: u32,
    DiagnosticDataBuffer: [1]u8,
};

pub const PHYSICAL_ELEMENT_STATUS_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    StartingElement: u32,
    Filter: u8,
    ReportType: u8,
    Reserved: [2]u8,
};

pub const PHYSICAL_ELEMENT_STATUS_DESCRIPTOR = extern struct {
    Version: u32,
    Size: u32,
    ElementIdentifier: u32,
    PhysicalElementType: u8,
    PhysicalElementHealth: u8,
    Reserved1: [2]u8,
    AssociatedCapacity: u64,
    Reserved2: [4]u32,
};

pub const PHYSICAL_ELEMENT_STATUS = extern struct {
    Version: u32,
    Size: u32,
    DescriptorCount: u32,
    ReturnedDescriptorCount: u32,
    ElementIdentifierBeingDepoped: u32,
    Reserved: u32,
    Descriptors: [1]PHYSICAL_ELEMENT_STATUS_DESCRIPTOR,
};

pub const REMOVE_ELEMENT_AND_TRUNCATE_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    RequestCapacity: u64,
    ElementIdentifier: u32,
    Reserved: u32,
};

pub const DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE = extern enum(i32) {
    DeviceInternalStatusDataRequestTypeUndefined = 0,
    DeviceCurrentInternalStatusDataHeader = 1,
    DeviceCurrentInternalStatusData = 2,
};
pub const DeviceInternalStatusDataRequestTypeUndefined = DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE.DeviceInternalStatusDataRequestTypeUndefined;
pub const DeviceCurrentInternalStatusDataHeader = DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE.DeviceCurrentInternalStatusDataHeader;
pub const DeviceCurrentInternalStatusData = DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE.DeviceCurrentInternalStatusData;

pub const DEVICE_INTERNAL_STATUS_DATA_SET = extern enum(i32) {
    DeviceStatusDataSetUndefined = 0,
    DeviceStatusDataSet1 = 1,
    DeviceStatusDataSet2 = 2,
    DeviceStatusDataSet3 = 3,
    DeviceStatusDataSet4 = 4,
    DeviceStatusDataSetMax = 5,
};
pub const DeviceStatusDataSetUndefined = DEVICE_INTERNAL_STATUS_DATA_SET.DeviceStatusDataSetUndefined;
pub const DeviceStatusDataSet1 = DEVICE_INTERNAL_STATUS_DATA_SET.DeviceStatusDataSet1;
pub const DeviceStatusDataSet2 = DEVICE_INTERNAL_STATUS_DATA_SET.DeviceStatusDataSet2;
pub const DeviceStatusDataSet3 = DEVICE_INTERNAL_STATUS_DATA_SET.DeviceStatusDataSet3;
pub const DeviceStatusDataSet4 = DEVICE_INTERNAL_STATUS_DATA_SET.DeviceStatusDataSet4;
pub const DeviceStatusDataSetMax = DEVICE_INTERNAL_STATUS_DATA_SET.DeviceStatusDataSetMax;

pub const GET_DEVICE_INTERNAL_STATUS_DATA_REQUEST = extern struct {
    Version: u32,
    Size: u32,
    RequestDataType: DEVICE_INTERNAL_STATUS_DATA_REQUEST_TYPE,
    RequestDataSet: DEVICE_INTERNAL_STATUS_DATA_SET,
};

pub const DEVICE_INTERNAL_STATUS_DATA = extern struct {
    Version: u32,
    Size: u32,
    T10VendorId: u64,
    DataSet1Length: u32,
    DataSet2Length: u32,
    DataSet3Length: u32,
    DataSet4Length: u32,
    StatusDataVersion: u8,
    Reserved: [3]u8,
    ReasonIdentifier: [128]u8,
    StatusDataLength: u32,
    StatusData: [1]u8,
};

pub const STORAGE_MEDIA_SERIAL_NUMBER_DATA = extern struct {
    Reserved: u16,
    SerialNumberLength: u16,
    SerialNumber: [1]u8,
};

pub const STORAGE_READ_CAPACITY = extern struct {
    Version: u32,
    Size: u32,
    BlockLength: u32,
    NumberOfBlocks: LARGE_INTEGER,
    DiskLength: LARGE_INTEGER,
};

pub const PERSISTENT_RESERVE_COMMAND = extern struct {
    Version: u32,
    Size: u32,
    Anonymous: PERSISTENT_RESERVE_COMMAND._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const _DEVICEDUMP_COLLECTION_TYPE = extern enum(i32) {
    TCCollectionBugCheck = 1,
    TCCollectionApplicationRequested = 2,
    TCCollectionDeviceRequested = 3,
};
pub const TCCollectionBugCheck = _DEVICEDUMP_COLLECTION_TYPE.TCCollectionBugCheck;
pub const TCCollectionApplicationRequested = _DEVICEDUMP_COLLECTION_TYPE.TCCollectionApplicationRequested;
pub const TCCollectionDeviceRequested = _DEVICEDUMP_COLLECTION_TYPE.TCCollectionDeviceRequested;

pub const DEVICEDUMP_SUBSECTION_POINTER = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwOffset: u32,
};

pub const DEVICEDUMP_STRUCTURE_VERSION = extern struct {
    dwSignature: u32,
    dwVersion: u32,
    dwSize: u32,
};

pub const DEVICEDUMP_SECTION_HEADER = extern struct {
    guidDeviceDataId: Guid,
    sOrganizationID: [16]u8,
    dwFirmwareRevision: u32,
    sModelNumber: [32]u8,
    szDeviceManufacturingID: [32]u8,
    dwFlags: u32,
    bRestrictedPrivateDataVersion: u32,
    dwFirmwareIssueId: u32,
    szIssueDescriptionString: [132]u8,
};

pub const GP_LOG_PAGE_DESCRIPTOR = extern struct {
    LogAddress: u16,
    LogSectors: u16,
};

pub const DEVICEDUMP_PUBLIC_SUBSECTION = extern struct {
    dwFlags: u32,
    GPLogTable: [16]GP_LOG_PAGE_DESCRIPTOR,
    szDescription: [16]i8,
    bData: [1]u8,
};

pub const DEVICEDUMP_RESTRICTED_SUBSECTION = extern struct {
    bData: [1]u8,
};

pub const DEVICEDUMP_PRIVATE_SUBSECTION = extern struct {
    dwFlags: u32,
    GPLogId: GP_LOG_PAGE_DESCRIPTOR,
    bData: [1]u8,
};

pub const DEVICEDUMP_STORAGEDEVICE_DATA = extern struct {
    Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    SectionHeader: DEVICEDUMP_SECTION_HEADER,
    dwBufferSize: u32,
    dwReasonForCollection: u32,
    PublicData: DEVICEDUMP_SUBSECTION_POINTER,
    RestrictedData: DEVICEDUMP_SUBSECTION_POINTER,
    PrivateData: DEVICEDUMP_SUBSECTION_POINTER,
};

pub const DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = extern struct {
    Cdb: [16]u8,
    Command: [16]u8,
    StartTime: u64,
    EndTime: u64,
    OperationStatus: u32,
    OperationError: u32,
    StackSpecific: DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD._StackSpecific_e__Union,
    const _StackSpecific_e__Union = u32; // TODO: generate this nested type!
};

pub const DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP = extern struct {
    Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    dwReasonForCollection: u32,
    cDriverName: [16]u8,
    uiNumRecords: u32,
    RecordArray: [1]DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD,
};

pub const STORAGE_IDLE_POWER = extern struct {
    Version: u32,
    Size: u32,
    _bitfield: u32,
    D3IdleTimeout: u32,
};

pub const STORAGE_POWERUP_REASON_TYPE = extern enum(i32) {
    StoragePowerupUnknown = 0,
    StoragePowerupIO = 1,
    StoragePowerupDeviceAttention = 2,
};
pub const StoragePowerupUnknown = STORAGE_POWERUP_REASON_TYPE.StoragePowerupUnknown;
pub const StoragePowerupIO = STORAGE_POWERUP_REASON_TYPE.StoragePowerupIO;
pub const StoragePowerupDeviceAttention = STORAGE_POWERUP_REASON_TYPE.StoragePowerupDeviceAttention;

pub const STORAGE_IDLE_POWERUP_REASON = extern struct {
    Version: u32,
    Size: u32,
    PowerupReason: STORAGE_POWERUP_REASON_TYPE,
};

pub const STORAGE_RPMB_DATA_FRAME = extern struct {
    Stuff: [196]u8,
    KeyOrMAC: [32]u8,
    Data: [256]u8,
    Nonce: [16]u8,
    WriteCounter: [4]u8,
    Address: [2]u8,
    BlockCount: [2]u8,
    OperationResult: [2]u8,
    RequestOrResponseType: [2]u8,
};

pub const STORAGE_RPMB_COMMAND_TYPE = extern enum(i32) {
    StorRpmbProgramAuthKey = 1,
    StorRpmbQueryWriteCounter = 2,
    StorRpmbAuthenticatedWrite = 3,
    StorRpmbAuthenticatedRead = 4,
    StorRpmbReadResultRequest = 5,
    StorRpmbAuthenticatedDeviceConfigWrite = 6,
    StorRpmbAuthenticatedDeviceConfigRead = 7,
};
pub const StorRpmbProgramAuthKey = STORAGE_RPMB_COMMAND_TYPE.StorRpmbProgramAuthKey;
pub const StorRpmbQueryWriteCounter = STORAGE_RPMB_COMMAND_TYPE.StorRpmbQueryWriteCounter;
pub const StorRpmbAuthenticatedWrite = STORAGE_RPMB_COMMAND_TYPE.StorRpmbAuthenticatedWrite;
pub const StorRpmbAuthenticatedRead = STORAGE_RPMB_COMMAND_TYPE.StorRpmbAuthenticatedRead;
pub const StorRpmbReadResultRequest = STORAGE_RPMB_COMMAND_TYPE.StorRpmbReadResultRequest;
pub const StorRpmbAuthenticatedDeviceConfigWrite = STORAGE_RPMB_COMMAND_TYPE.StorRpmbAuthenticatedDeviceConfigWrite;
pub const StorRpmbAuthenticatedDeviceConfigRead = STORAGE_RPMB_COMMAND_TYPE.StorRpmbAuthenticatedDeviceConfigRead;

pub const STORAGE_EVENT_NOTIFICATION = extern struct {
    Version: u32,
    Size: u32,
    Events: u64,
};

pub const STORAGE_COUNTER_TYPE = extern enum(i32) {
    StorageCounterTypeUnknown = 0,
    StorageCounterTypeTemperatureCelsius = 1,
    StorageCounterTypeTemperatureCelsiusMax = 2,
    StorageCounterTypeReadErrorsTotal = 3,
    StorageCounterTypeReadErrorsCorrected = 4,
    StorageCounterTypeReadErrorsUncorrected = 5,
    StorageCounterTypeWriteErrorsTotal = 6,
    StorageCounterTypeWriteErrorsCorrected = 7,
    StorageCounterTypeWriteErrorsUncorrected = 8,
    StorageCounterTypeManufactureDate = 9,
    StorageCounterTypeStartStopCycleCount = 10,
    StorageCounterTypeStartStopCycleCountMax = 11,
    StorageCounterTypeLoadUnloadCycleCount = 12,
    StorageCounterTypeLoadUnloadCycleCountMax = 13,
    StorageCounterTypeWearPercentage = 14,
    StorageCounterTypeWearPercentageWarning = 15,
    StorageCounterTypeWearPercentageMax = 16,
    StorageCounterTypePowerOnHours = 17,
    StorageCounterTypeReadLatency100NSMax = 18,
    StorageCounterTypeWriteLatency100NSMax = 19,
    StorageCounterTypeFlushLatency100NSMax = 20,
    StorageCounterTypeMax = 21,
};
pub const StorageCounterTypeUnknown = STORAGE_COUNTER_TYPE.StorageCounterTypeUnknown;
pub const StorageCounterTypeTemperatureCelsius = STORAGE_COUNTER_TYPE.StorageCounterTypeTemperatureCelsius;
pub const StorageCounterTypeTemperatureCelsiusMax = STORAGE_COUNTER_TYPE.StorageCounterTypeTemperatureCelsiusMax;
pub const StorageCounterTypeReadErrorsTotal = STORAGE_COUNTER_TYPE.StorageCounterTypeReadErrorsTotal;
pub const StorageCounterTypeReadErrorsCorrected = STORAGE_COUNTER_TYPE.StorageCounterTypeReadErrorsCorrected;
pub const StorageCounterTypeReadErrorsUncorrected = STORAGE_COUNTER_TYPE.StorageCounterTypeReadErrorsUncorrected;
pub const StorageCounterTypeWriteErrorsTotal = STORAGE_COUNTER_TYPE.StorageCounterTypeWriteErrorsTotal;
pub const StorageCounterTypeWriteErrorsCorrected = STORAGE_COUNTER_TYPE.StorageCounterTypeWriteErrorsCorrected;
pub const StorageCounterTypeWriteErrorsUncorrected = STORAGE_COUNTER_TYPE.StorageCounterTypeWriteErrorsUncorrected;
pub const StorageCounterTypeManufactureDate = STORAGE_COUNTER_TYPE.StorageCounterTypeManufactureDate;
pub const StorageCounterTypeStartStopCycleCount = STORAGE_COUNTER_TYPE.StorageCounterTypeStartStopCycleCount;
pub const StorageCounterTypeStartStopCycleCountMax = STORAGE_COUNTER_TYPE.StorageCounterTypeStartStopCycleCountMax;
pub const StorageCounterTypeLoadUnloadCycleCount = STORAGE_COUNTER_TYPE.StorageCounterTypeLoadUnloadCycleCount;
pub const StorageCounterTypeLoadUnloadCycleCountMax = STORAGE_COUNTER_TYPE.StorageCounterTypeLoadUnloadCycleCountMax;
pub const StorageCounterTypeWearPercentage = STORAGE_COUNTER_TYPE.StorageCounterTypeWearPercentage;
pub const StorageCounterTypeWearPercentageWarning = STORAGE_COUNTER_TYPE.StorageCounterTypeWearPercentageWarning;
pub const StorageCounterTypeWearPercentageMax = STORAGE_COUNTER_TYPE.StorageCounterTypeWearPercentageMax;
pub const StorageCounterTypePowerOnHours = STORAGE_COUNTER_TYPE.StorageCounterTypePowerOnHours;
pub const StorageCounterTypeReadLatency100NSMax = STORAGE_COUNTER_TYPE.StorageCounterTypeReadLatency100NSMax;
pub const StorageCounterTypeWriteLatency100NSMax = STORAGE_COUNTER_TYPE.StorageCounterTypeWriteLatency100NSMax;
pub const StorageCounterTypeFlushLatency100NSMax = STORAGE_COUNTER_TYPE.StorageCounterTypeFlushLatency100NSMax;
pub const StorageCounterTypeMax = STORAGE_COUNTER_TYPE.StorageCounterTypeMax;

pub const STORAGE_COUNTER = extern struct {
    Type: STORAGE_COUNTER_TYPE,
    Value: STORAGE_COUNTER._Value_e__Union,
    const _Value_e__Union = u32; // TODO: generate this nested type!
};

pub const STORAGE_COUNTERS = extern struct {
    Version: u32,
    Size: u32,
    NumberOfCounters: u32,
    Counters: [1]STORAGE_COUNTER,
};

pub const STORAGE_HW_FIRMWARE_INFO_QUERY = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Reserved: u32,
};

pub const STORAGE_HW_FIRMWARE_SLOT_INFO = extern struct {
    Version: u32,
    Size: u32,
    SlotNumber: u8,
    _bitfield: u8,
    Reserved1: [6]u8,
    Revision: [16]u8,
};

pub const STORAGE_HW_FIRMWARE_INFO = extern struct {
    Version: u32,
    Size: u32,
    _bitfield: u8,
    SlotCount: u8,
    ActiveSlot: u8,
    PendingActivateSlot: u8,
    FirmwareShared: u8,
    Reserved: [3]u8,
    ImagePayloadAlignment: u32,
    ImagePayloadMaxSize: u32,
    Slot: [1]STORAGE_HW_FIRMWARE_SLOT_INFO,
};

pub const STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved: [3]u8,
    Offset: u64,
    BufferSize: u64,
    ImageSize: u32,
    Reserved2: u32,
    ImageBuffer: [1]u8,
};

pub const STORAGE_ATTRIBUTE_MGMT_ACTION = extern enum(i32) {
    StorAttributeMgmt_ClearAttribute = 0,
    StorAttributeMgmt_SetAttribute = 1,
    StorAttributeMgmt_ResetAttribute = 2,
};
pub const StorAttributeMgmt_ClearAttribute = STORAGE_ATTRIBUTE_MGMT_ACTION.StorAttributeMgmt_ClearAttribute;
pub const StorAttributeMgmt_SetAttribute = STORAGE_ATTRIBUTE_MGMT_ACTION.StorAttributeMgmt_SetAttribute;
pub const StorAttributeMgmt_ResetAttribute = STORAGE_ATTRIBUTE_MGMT_ACTION.StorAttributeMgmt_ResetAttribute;

pub const STORAGE_ATTRIBUTE_MGMT = extern struct {
    Version: u32,
    Size: u32,
    Action: STORAGE_ATTRIBUTE_MGMT_ACTION,
    Attribute: u32,
};

pub const SCM_PD_HEALTH_NOTIFICATION_DATA = extern struct {
    DeviceGuid: Guid,
};

pub const SCM_LOGICAL_DEVICE_INSTANCE = extern struct {
    Version: u32,
    Size: u32,
    DeviceGuid: Guid,
    SymbolicLink: [256]u16,
};

pub const SCM_LOGICAL_DEVICES = extern struct {
    Version: u32,
    Size: u32,
    DeviceCount: u32,
    Devices: [1]SCM_LOGICAL_DEVICE_INSTANCE,
};

pub const SCM_PHYSICAL_DEVICE_INSTANCE = extern struct {
    Version: u32,
    Size: u32,
    NfitHandle: u32,
    SymbolicLink: [256]u16,
};

pub const SCM_PHYSICAL_DEVICES = extern struct {
    Version: u32,
    Size: u32,
    DeviceCount: u32,
    Devices: [1]SCM_PHYSICAL_DEVICE_INSTANCE,
};

pub const SCM_REGION_FLAG = extern enum(i32) {
    ScmRegionFlagNone = 0,
    ScmRegionFlagLabel = 1,
};
pub const ScmRegionFlagNone = SCM_REGION_FLAG.ScmRegionFlagNone;
pub const ScmRegionFlagLabel = SCM_REGION_FLAG.ScmRegionFlagLabel;

pub const SCM_REGION = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    NfitHandle: u32,
    LogicalDeviceGuid: Guid,
    AddressRangeType: Guid,
    AssociatedId: u32,
    Length: u64,
    StartingDPA: u64,
    BaseSPA: u64,
    SPAOffset: u64,
    RegionOffset: u64,
};

pub const SCM_REGIONS = extern struct {
    Version: u32,
    Size: u32,
    RegionCount: u32,
    Regions: [1]SCM_REGION,
};

pub const SCM_INTERLEAVED_PD_INFO = extern struct {
    DeviceHandle: u32,
    DeviceGuid: Guid,
};

pub const SCM_LD_INTERLEAVE_SET_INFO = extern struct {
    Version: u32,
    Size: u32,
    InterleaveSetSize: u32,
    InterleaveSet: [1]SCM_INTERLEAVED_PD_INFO,
};

pub const SCM_PD_QUERY_TYPE = extern enum(i32) {
    ScmPhysicalDeviceQuery_Descriptor = 0,
    ScmPhysicalDeviceQuery_IsSupported = 1,
    ScmPhysicalDeviceQuery_Max = 2,
};
pub const ScmPhysicalDeviceQuery_Descriptor = SCM_PD_QUERY_TYPE.ScmPhysicalDeviceQuery_Descriptor;
pub const ScmPhysicalDeviceQuery_IsSupported = SCM_PD_QUERY_TYPE.ScmPhysicalDeviceQuery_IsSupported;
pub const ScmPhysicalDeviceQuery_Max = SCM_PD_QUERY_TYPE.ScmPhysicalDeviceQuery_Max;

pub const SCM_PD_PROPERTY_ID = extern enum(i32) {
    ScmPhysicalDeviceProperty_DeviceInfo = 0,
    ScmPhysicalDeviceProperty_ManagementStatus = 1,
    ScmPhysicalDeviceProperty_FirmwareInfo = 2,
    ScmPhysicalDeviceProperty_LocationString = 3,
    ScmPhysicalDeviceProperty_DeviceSpecificInfo = 4,
    ScmPhysicalDeviceProperty_DeviceHandle = 5,
    ScmPhysicalDeviceProperty_Max = 6,
};
pub const ScmPhysicalDeviceProperty_DeviceInfo = SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_DeviceInfo;
pub const ScmPhysicalDeviceProperty_ManagementStatus = SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_ManagementStatus;
pub const ScmPhysicalDeviceProperty_FirmwareInfo = SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_FirmwareInfo;
pub const ScmPhysicalDeviceProperty_LocationString = SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_LocationString;
pub const ScmPhysicalDeviceProperty_DeviceSpecificInfo = SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_DeviceSpecificInfo;
pub const ScmPhysicalDeviceProperty_DeviceHandle = SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_DeviceHandle;
pub const ScmPhysicalDeviceProperty_Max = SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_Max;

pub const SCM_PD_PROPERTY_QUERY = extern struct {
    Version: u32,
    Size: u32,
    PropertyId: SCM_PD_PROPERTY_ID,
    QueryType: SCM_PD_QUERY_TYPE,
    AdditionalParameters: [1]u8,
};

pub const SCM_PD_DESCRIPTOR_HEADER = extern struct {
    Version: u32,
    Size: u32,
};

pub const SCM_PD_DEVICE_HANDLE = extern struct {
    Version: u32,
    Size: u32,
    DeviceGuid: Guid,
    DeviceHandle: u32,
};

pub const SCM_PD_DEVICE_INFO = extern struct {
    Version: u32,
    Size: u32,
    DeviceGuid: Guid,
    UnsafeShutdownCount: u32,
    PersistentMemorySizeInBytes: u64,
    VolatileMemorySizeInBytes: u64,
    TotalMemorySizeInBytes: u64,
    SlotNumber: u32,
    DeviceHandle: u32,
    PhysicalId: u16,
    NumberOfFormatInterfaceCodes: u8,
    FormatInterfaceCodes: [8]u16,
    VendorId: u32,
    ProductId: u32,
    SubsystemDeviceId: u32,
    SubsystemVendorId: u32,
    ManufacturingLocation: u8,
    ManufacturingWeek: u8,
    ManufacturingYear: u8,
    SerialNumber4Byte: u32,
    SerialNumberLengthInChars: u32,
    SerialNumber: [1]i8,
};

pub const SCM_PD_DEVICE_SPECIFIC_PROPERTY = extern struct {
    Name: [128]u16,
    Value: i64,
};

pub const SCM_PD_DEVICE_SPECIFIC_INFO = extern struct {
    Version: u32,
    Size: u32,
    NumberOfProperties: u32,
    DeviceSpecificProperties: [1]SCM_PD_DEVICE_SPECIFIC_PROPERTY,
};

pub const SCM_PD_FIRMWARE_SLOT_INFO = extern struct {
    Version: u32,
    Size: u32,
    SlotNumber: u8,
    _bitfield: u8,
    Reserved1: [6]u8,
    Revision: [32]u8,
};

pub const SCM_PD_FIRMWARE_INFO = extern struct {
    Version: u32,
    Size: u32,
    ActiveSlot: u8,
    NextActiveSlot: u8,
    SlotCount: u8,
    Slots: [1]SCM_PD_FIRMWARE_SLOT_INFO,
};

pub const SCM_PD_HEALTH_STATUS = extern enum(i32) {
    ScmPhysicalDeviceHealth_Unknown = 0,
    ScmPhysicalDeviceHealth_Unhealthy = 1,
    ScmPhysicalDeviceHealth_Warning = 2,
    ScmPhysicalDeviceHealth_Healthy = 3,
    ScmPhysicalDeviceHealth_Max = 4,
};
pub const ScmPhysicalDeviceHealth_Unknown = SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Unknown;
pub const ScmPhysicalDeviceHealth_Unhealthy = SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Unhealthy;
pub const ScmPhysicalDeviceHealth_Warning = SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Warning;
pub const ScmPhysicalDeviceHealth_Healthy = SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Healthy;
pub const ScmPhysicalDeviceHealth_Max = SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Max;

pub const SCM_PD_OPERATIONAL_STATUS = extern enum(i32) {
    ScmPhysicalDeviceOpStatus_Unknown = 0,
    ScmPhysicalDeviceOpStatus_Ok = 1,
    ScmPhysicalDeviceOpStatus_PredictingFailure = 2,
    ScmPhysicalDeviceOpStatus_InService = 3,
    ScmPhysicalDeviceOpStatus_HardwareError = 4,
    ScmPhysicalDeviceOpStatus_NotUsable = 5,
    ScmPhysicalDeviceOpStatus_TransientError = 6,
    ScmPhysicalDeviceOpStatus_Missing = 7,
    ScmPhysicalDeviceOpStatus_Max = 8,
};
pub const ScmPhysicalDeviceOpStatus_Unknown = SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_Unknown;
pub const ScmPhysicalDeviceOpStatus_Ok = SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_Ok;
pub const ScmPhysicalDeviceOpStatus_PredictingFailure = SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_PredictingFailure;
pub const ScmPhysicalDeviceOpStatus_InService = SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_InService;
pub const ScmPhysicalDeviceOpStatus_HardwareError = SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_HardwareError;
pub const ScmPhysicalDeviceOpStatus_NotUsable = SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_NotUsable;
pub const ScmPhysicalDeviceOpStatus_TransientError = SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_TransientError;
pub const ScmPhysicalDeviceOpStatus_Missing = SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_Missing;
pub const ScmPhysicalDeviceOpStatus_Max = SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_Max;

pub const SCM_PD_OPERATIONAL_STATUS_REASON = extern enum(i32) {
    ScmPhysicalDeviceOpReason_Unknown = 0,
    ScmPhysicalDeviceOpReason_Media = 1,
    ScmPhysicalDeviceOpReason_ThresholdExceeded = 2,
    ScmPhysicalDeviceOpReason_LostData = 3,
    ScmPhysicalDeviceOpReason_EnergySource = 4,
    ScmPhysicalDeviceOpReason_Configuration = 5,
    ScmPhysicalDeviceOpReason_DeviceController = 6,
    ScmPhysicalDeviceOpReason_MediaController = 7,
    ScmPhysicalDeviceOpReason_Component = 8,
    ScmPhysicalDeviceOpReason_BackgroundOperation = 9,
    ScmPhysicalDeviceOpReason_InvalidFirmware = 10,
    ScmPhysicalDeviceOpReason_HealthCheck = 11,
    ScmPhysicalDeviceOpReason_LostDataPersistence = 12,
    ScmPhysicalDeviceOpReason_DisabledByPlatform = 13,
    ScmPhysicalDeviceOpReason_PermanentError = 14,
    ScmPhysicalDeviceOpReason_LostWritePersistence = 15,
    ScmPhysicalDeviceOpReason_FatalError = 16,
    ScmPhysicalDeviceOpReason_DataPersistenceLossImminent = 17,
    ScmPhysicalDeviceOpReason_WritePersistenceLossImminent = 18,
    ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock = 19,
    ScmPhysicalDeviceOpReason_PerformanceDegradation = 20,
    ScmPhysicalDeviceOpReason_ExcessiveTemperature = 21,
    ScmPhysicalDeviceOpReason_Max = 22,
};
pub const ScmPhysicalDeviceOpReason_Unknown = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Unknown;
pub const ScmPhysicalDeviceOpReason_Media = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Media;
pub const ScmPhysicalDeviceOpReason_ThresholdExceeded = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_ThresholdExceeded;
pub const ScmPhysicalDeviceOpReason_LostData = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_LostData;
pub const ScmPhysicalDeviceOpReason_EnergySource = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_EnergySource;
pub const ScmPhysicalDeviceOpReason_Configuration = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Configuration;
pub const ScmPhysicalDeviceOpReason_DeviceController = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_DeviceController;
pub const ScmPhysicalDeviceOpReason_MediaController = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_MediaController;
pub const ScmPhysicalDeviceOpReason_Component = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Component;
pub const ScmPhysicalDeviceOpReason_BackgroundOperation = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_BackgroundOperation;
pub const ScmPhysicalDeviceOpReason_InvalidFirmware = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_InvalidFirmware;
pub const ScmPhysicalDeviceOpReason_HealthCheck = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_HealthCheck;
pub const ScmPhysicalDeviceOpReason_LostDataPersistence = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_LostDataPersistence;
pub const ScmPhysicalDeviceOpReason_DisabledByPlatform = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_DisabledByPlatform;
pub const ScmPhysicalDeviceOpReason_PermanentError = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_PermanentError;
pub const ScmPhysicalDeviceOpReason_LostWritePersistence = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_LostWritePersistence;
pub const ScmPhysicalDeviceOpReason_FatalError = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_FatalError;
pub const ScmPhysicalDeviceOpReason_DataPersistenceLossImminent = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_DataPersistenceLossImminent;
pub const ScmPhysicalDeviceOpReason_WritePersistenceLossImminent = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_WritePersistenceLossImminent;
pub const ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock;
pub const ScmPhysicalDeviceOpReason_PerformanceDegradation = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_PerformanceDegradation;
pub const ScmPhysicalDeviceOpReason_ExcessiveTemperature = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_ExcessiveTemperature;
pub const ScmPhysicalDeviceOpReason_Max = SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Max;

pub const SCM_PD_MANAGEMENT_STATUS = extern struct {
    Version: u32,
    Size: u32,
    Health: SCM_PD_HEALTH_STATUS,
    NumberOfOperationalStatus: u32,
    NumberOfAdditionalReasons: u32,
    OperationalStatus: [16]SCM_PD_OPERATIONAL_STATUS,
    AdditionalReasons: [1]SCM_PD_OPERATIONAL_STATUS_REASON,
};

pub const SCM_PD_LOCATION_STRING = extern struct {
    Version: u32,
    Size: u32,
    Location: [1]u16,
};

pub const SCM_PD_FIRMWARE_DOWNLOAD = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
    Reserved: [3]u8,
    Offset: u64,
    FirmwareImageSizeInBytes: u32,
    FirmwareImage: [1]u8,
};

pub const SCM_PD_FIRMWARE_ACTIVATE = extern struct {
    Version: u32,
    Size: u32,
    Flags: u32,
    Slot: u8,
};

pub const SCM_PD_PASSTHROUGH_INPUT = extern struct {
    Version: u32,
    Size: u32,
    ProtocolGuid: Guid,
    DataSize: u32,
    Data: [1]u8,
};

pub const SCM_PD_PASSTHROUGH_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    ProtocolGuid: Guid,
    DataSize: u32,
    Data: [1]u8,
};

pub const SCM_PD_PASSTHROUGH_INVDIMM_INPUT = extern struct {
    Opcode: u32,
    OpcodeParametersLength: u32,
    OpcodeParameters: [1]u8,
};

pub const SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = extern struct {
    GeneralStatus: u16,
    ExtendedStatus: u16,
    OutputDataLength: u32,
    OutputData: [1]u8,
};

pub const SCM_PD_REINITIALIZE_MEDIA_INPUT = extern struct {
    Version: u32,
    Size: u32,
    Options: SCM_PD_REINITIALIZE_MEDIA_INPUT._Options_e__Struct,
    const _Options_e__Struct = u32; // TODO: generate this nested type!
};

pub const SCM_PD_MEDIA_REINITIALIZATION_STATUS = extern enum(i32) {
    ScmPhysicalDeviceReinit_Success = 0,
    ScmPhysicalDeviceReinit_RebootNeeded = 1,
    ScmPhysicalDeviceReinit_ColdBootNeeded = 2,
    ScmPhysicalDeviceReinit_Max = 3,
};
pub const ScmPhysicalDeviceReinit_Success = SCM_PD_MEDIA_REINITIALIZATION_STATUS.ScmPhysicalDeviceReinit_Success;
pub const ScmPhysicalDeviceReinit_RebootNeeded = SCM_PD_MEDIA_REINITIALIZATION_STATUS.ScmPhysicalDeviceReinit_RebootNeeded;
pub const ScmPhysicalDeviceReinit_ColdBootNeeded = SCM_PD_MEDIA_REINITIALIZATION_STATUS.ScmPhysicalDeviceReinit_ColdBootNeeded;
pub const ScmPhysicalDeviceReinit_Max = SCM_PD_MEDIA_REINITIALIZATION_STATUS.ScmPhysicalDeviceReinit_Max;

pub const SCM_PD_REINITIALIZE_MEDIA_OUTPUT = extern struct {
    Version: u32,
    Size: u32,
    Status: SCM_PD_MEDIA_REINITIALIZATION_STATUS,
};

pub const SET_PARTITION_INFORMATION_EX = extern struct {
    PartitionStyle: PARTITION_STYLE,
    Anonymous: SET_PARTITION_INFORMATION_EX._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const DETECTION_TYPE = extern enum(i32) {
    DetectNone = 0,
    DetectInt13 = 1,
    DetectExInt13 = 2,
};
pub const DetectNone = DETECTION_TYPE.DetectNone;
pub const DetectInt13 = DETECTION_TYPE.DetectInt13;
pub const DetectExInt13 = DETECTION_TYPE.DetectExInt13;

pub const DISK_CONTROLLER_NUMBER = extern struct {
    ControllerNumber: u32,
    DiskNumber: u32,
};

pub const DISK_CACHE_RETENTION_PRIORITY = extern enum(i32) {
    EqualPriority = 0,
    KeepPrefetchedData = 1,
    KeepReadData = 2,
};
pub const EqualPriority = DISK_CACHE_RETENTION_PRIORITY.EqualPriority;
pub const KeepPrefetchedData = DISK_CACHE_RETENTION_PRIORITY.KeepPrefetchedData;
pub const KeepReadData = DISK_CACHE_RETENTION_PRIORITY.KeepReadData;

pub const HISTOGRAM_BUCKET = extern struct {
    Reads: u32,
    Writes: u32,
};

pub const DISK_HISTOGRAM = extern struct {
    DiskSize: LARGE_INTEGER,
    Start: LARGE_INTEGER,
    End: LARGE_INTEGER,
    Average: LARGE_INTEGER,
    AverageRead: LARGE_INTEGER,
    AverageWrite: LARGE_INTEGER,
    Granularity: u32,
    Size: u32,
    ReadCount: u32,
    WriteCount: u32,
    Histogram: *HISTOGRAM_BUCKET,
};

pub const DISK_RECORD = extern struct {
    ByteOffset: LARGE_INTEGER,
    StartTime: LARGE_INTEGER,
    EndTime: LARGE_INTEGER,
    VirtualAddress: *c_void,
    NumberOfBytes: u32,
    DeviceNumber: u8,
    ReadRequest: u8,
};

pub const DISK_LOGGING = extern struct {
    Function: u8,
    BufferAddress: *c_void,
    BufferSize: u32,
};

pub const BIN_TYPES = extern enum(i32) {
    RequestSize = 0,
    RequestLocation = 1,
};
pub const RequestSize = BIN_TYPES.RequestSize;
pub const RequestLocation = BIN_TYPES.RequestLocation;

pub const BIN_RANGE = extern struct {
    StartValue: LARGE_INTEGER,
    Length: LARGE_INTEGER,
};

pub const PERF_BIN = extern struct {
    NumberOfBins: u32,
    TypeOfBin: u32,
    BinsRanges: [1]BIN_RANGE,
};

pub const BIN_COUNT = extern struct {
    BinRange: BIN_RANGE,
    BinCount: u32,
};

pub const BIN_RESULTS = extern struct {
    NumberOfBins: u32,
    BinCounts: [1]BIN_COUNT,
};

pub const GETVERSIONINPARAMS = extern struct {
    bVersion: u8,
    bRevision: u8,
    bReserved: u8,
    bIDEDeviceMap: u8,
    fCapabilities: u32,
    dwReserved: [4]u32,
};

pub const IDEREGS = extern struct {
    bFeaturesReg: u8,
    bSectorCountReg: u8,
    bSectorNumberReg: u8,
    bCylLowReg: u8,
    bCylHighReg: u8,
    bDriveHeadReg: u8,
    bCommandReg: u8,
    bReserved: u8,
};

pub const SENDCMDINPARAMS = extern struct {
    cBufferSize: u32,
    irDriveRegs: IDEREGS,
    bDriveNumber: u8,
    bReserved: [3]u8,
    dwReserved: [4]u32,
    bBuffer: [1]u8,
};

pub const DRIVERSTATUS = extern struct {
    bDriverError: u8,
    bIDEError: u8,
    bReserved: [2]u8,
    dwReserved: [2]u32,
};

pub const SENDCMDOUTPARAMS = extern struct {
    cBufferSize: u32,
    DriverStatus: DRIVERSTATUS,
    bBuffer: [1]u8,
};

pub const ELEMENT_TYPE = extern enum(i32) {
    AllElements = 0,
    ChangerTransport = 1,
    ChangerSlot = 2,
    ChangerIEPort = 3,
    ChangerDrive = 4,
    ChangerDoor = 5,
    ChangerKeypad = 6,
    ChangerMaxElement = 7,
};
pub const AllElements = ELEMENT_TYPE.AllElements;
pub const ChangerTransport = ELEMENT_TYPE.ChangerTransport;
pub const ChangerSlot = ELEMENT_TYPE.ChangerSlot;
pub const ChangerIEPort = ELEMENT_TYPE.ChangerIEPort;
pub const ChangerDrive = ELEMENT_TYPE.ChangerDrive;
pub const ChangerDoor = ELEMENT_TYPE.ChangerDoor;
pub const ChangerKeypad = ELEMENT_TYPE.ChangerKeypad;
pub const ChangerMaxElement = ELEMENT_TYPE.ChangerMaxElement;

pub const CHANGER_ELEMENT = extern struct {
    ElementType: ELEMENT_TYPE,
    ElementAddress: u32,
};

pub const CHANGER_ELEMENT_LIST = extern struct {
    Element: CHANGER_ELEMENT,
    NumberOfElements: u32,
};

pub const GET_CHANGER_PARAMETERS = extern struct {
    Size: u32,
    NumberTransportElements: u16,
    NumberStorageElements: u16,
    NumberCleanerSlots: u16,
    NumberIEElements: u16,
    NumberDataTransferElements: u16,
    NumberOfDoors: u16,
    FirstSlotNumber: u16,
    FirstDriveNumber: u16,
    FirstTransportNumber: u16,
    FirstIEPortNumber: u16,
    FirstCleanerSlotAddress: u16,
    MagazineSize: u16,
    DriveCleanTimeout: u32,
    Features0: u32,
    Features1: u32,
    MoveFromTransport: u8,
    MoveFromSlot: u8,
    MoveFromIePort: u8,
    MoveFromDrive: u8,
    ExchangeFromTransport: u8,
    ExchangeFromSlot: u8,
    ExchangeFromIePort: u8,
    ExchangeFromDrive: u8,
    LockUnlockCapabilities: u8,
    PositionCapabilities: u8,
    Reserved1: [2]u8,
    Reserved2: [2]u32,
};

pub const CHANGER_PRODUCT_DATA = extern struct {
    VendorId: [8]u8,
    ProductId: [16]u8,
    Revision: [4]u8,
    SerialNumber: [32]u8,
    DeviceType: u8,
};

pub const CHANGER_SET_ACCESS = extern struct {
    Element: CHANGER_ELEMENT,
    Control: u32,
};

pub const CHANGER_READ_ELEMENT_STATUS = extern struct {
    ElementList: CHANGER_ELEMENT_LIST,
    VolumeTagInfo: u8,
};

pub const CHANGER_ELEMENT_STATUS = extern struct {
    Element: CHANGER_ELEMENT,
    SrcElementAddress: CHANGER_ELEMENT,
    Flags: u32,
    ExceptionCode: u32,
    TargetId: u8,
    Lun: u8,
    Reserved: u16,
    PrimaryVolumeID: [36]u8,
    AlternateVolumeID: [36]u8,
};

pub const CHANGER_ELEMENT_STATUS_EX = extern struct {
    Element: CHANGER_ELEMENT,
    SrcElementAddress: CHANGER_ELEMENT,
    Flags: u32,
    ExceptionCode: u32,
    TargetId: u8,
    Lun: u8,
    Reserved: u16,
    PrimaryVolumeID: [36]u8,
    AlternateVolumeID: [36]u8,
    VendorIdentification: [8]u8,
    ProductIdentification: [16]u8,
    SerialNumber: [32]u8,
};

pub const CHANGER_INITIALIZE_ELEMENT_STATUS = extern struct {
    ElementList: CHANGER_ELEMENT_LIST,
    BarCodeScan: u8,
};

pub const CHANGER_SET_POSITION = extern struct {
    Transport: CHANGER_ELEMENT,
    Destination: CHANGER_ELEMENT,
    Flip: u8,
};

pub const CHANGER_EXCHANGE_MEDIUM = extern struct {
    Transport: CHANGER_ELEMENT,
    Source: CHANGER_ELEMENT,
    Destination1: CHANGER_ELEMENT,
    Destination2: CHANGER_ELEMENT,
    Flip1: u8,
    Flip2: u8,
};

pub const CHANGER_MOVE_MEDIUM = extern struct {
    Transport: CHANGER_ELEMENT,
    Source: CHANGER_ELEMENT,
    Destination: CHANGER_ELEMENT,
    Flip: u8,
};

pub const CHANGER_SEND_VOLUME_TAG_INFORMATION = extern struct {
    StartingElement: CHANGER_ELEMENT,
    ActionCode: u32,
    VolumeIDTemplate: [40]u8,
};

pub const READ_ELEMENT_ADDRESS_INFO = extern struct {
    NumberOfElements: u32,
    ElementStatus: [1]CHANGER_ELEMENT_STATUS,
};

pub const CHANGER_DEVICE_PROBLEM_TYPE = extern enum(i32) {
    DeviceProblemNone = 0,
    DeviceProblemHardware = 1,
    DeviceProblemCHMError = 2,
    DeviceProblemDoorOpen = 3,
    DeviceProblemCalibrationError = 4,
    DeviceProblemTargetFailure = 5,
    DeviceProblemCHMMoveError = 6,
    DeviceProblemCHMZeroError = 7,
    DeviceProblemCartridgeInsertError = 8,
    DeviceProblemPositionError = 9,
    DeviceProblemSensorError = 10,
    DeviceProblemCartridgeEjectError = 11,
    DeviceProblemGripperError = 12,
    DeviceProblemDriveError = 13,
};
pub const DeviceProblemNone = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemNone;
pub const DeviceProblemHardware = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemHardware;
pub const DeviceProblemCHMError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCHMError;
pub const DeviceProblemDoorOpen = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemDoorOpen;
pub const DeviceProblemCalibrationError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCalibrationError;
pub const DeviceProblemTargetFailure = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemTargetFailure;
pub const DeviceProblemCHMMoveError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCHMMoveError;
pub const DeviceProblemCHMZeroError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCHMZeroError;
pub const DeviceProblemCartridgeInsertError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCartridgeInsertError;
pub const DeviceProblemPositionError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemPositionError;
pub const DeviceProblemSensorError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemSensorError;
pub const DeviceProblemCartridgeEjectError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCartridgeEjectError;
pub const DeviceProblemGripperError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemGripperError;
pub const DeviceProblemDriveError = CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemDriveError;

pub const PATHNAME_BUFFER = extern struct {
    PathNameLength: u32,
    Name: [1]u16,
};

pub const FSCTL_QUERY_FAT_BPB_BUFFER = extern struct {
    First0x24BytesOfBootSector: [36]u8,
};

pub const REFS_VOLUME_DATA_BUFFER = extern struct {
    ByteCount: u32,
    MajorVersion: u32,
    MinorVersion: u32,
    BytesPerPhysicalSector: u32,
    VolumeSerialNumber: LARGE_INTEGER,
    NumberSectors: LARGE_INTEGER,
    TotalClusters: LARGE_INTEGER,
    FreeClusters: LARGE_INTEGER,
    TotalReserved: LARGE_INTEGER,
    BytesPerSector: u32,
    BytesPerCluster: u32,
    MaximumSizeOfResidentFile: LARGE_INTEGER,
    FastTierDataFillRatio: u16,
    SlowTierDataFillRatio: u16,
    DestagesFastTierToSlowTierRate: u32,
    Reserved: [9]LARGE_INTEGER,
};

pub const STARTING_LCN_INPUT_BUFFER_EX = extern struct {
    StartingLcn: LARGE_INTEGER,
    Flags: u32,
};

pub const RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER = extern struct {
    ExtentCount: u32,
    StartingVcn: LARGE_INTEGER,
    Extents: [1]RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER._Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const RETRIEVAL_POINTER_COUNT = extern struct {
    ExtentCount: u32,
};

pub const MOVE_FILE_RECORD_DATA = extern struct {
    FileHandle: HANDLE,
    SourceFileRecord: LARGE_INTEGER,
    TargetFileRecord: LARGE_INTEGER,
};

pub const USN_RECORD_UNION = u32; // TODO: implement StructOrUnion types?

pub const BULK_SECURITY_TEST_DATA = extern struct {
    DesiredAccess: u32,
    SecurityIds: [1]u32,
};

pub const FILE_PREFETCH = extern struct {
    Type: u32,
    Count: u32,
    Prefetch: [1]u64,
};

pub const FILE_PREFETCH_EX = extern struct {
    Type: u32,
    Count: u32,
    Context: *c_void,
    Prefetch: [1]u64,
};

pub const FILE_ZERO_DATA_INFORMATION_EX = extern struct {
    FileOffset: LARGE_INTEGER,
    BeyondFinalZero: LARGE_INTEGER,
    Flags: u32,
};

pub const ENCRYPTION_BUFFER = extern struct {
    EncryptionOperation: u32,
    Private: [1]u8,
};

pub const DECRYPTION_STATUS_BUFFER = extern struct {
    NoEncryptedStreams: u8,
};

pub const REQUEST_RAW_ENCRYPTED_DATA = extern struct {
    FileOffset: i64,
    Length: u32,
};

pub const ENCRYPTED_DATA_INFO = extern struct {
    StartingFileOffset: u64,
    OutputBufferOffset: u32,
    BytesWithinFileSize: u32,
    BytesWithinValidDataLength: u32,
    CompressionFormat: u16,
    DataUnitShift: u8,
    ChunkShift: u8,
    ClusterShift: u8,
    EncryptionFormat: u8,
    NumberOfDataBlocks: u16,
    DataBlockSize: [1]u32,
};

pub const EXTENDED_ENCRYPTED_DATA_INFO = extern struct {
    ExtendedCode: u32,
    Length: u32,
    Flags: u32,
    Reserved: u32,
};

pub const SI_COPYFILE = extern struct {
    SourceFileNameLength: u32,
    DestinationFileNameLength: u32,
    Flags: u32,
    FileNameBuffer: [1]u16,
};

pub const FILE_INITIATE_REPAIR_OUTPUT_BUFFER = extern struct {
    Hint1: u64,
    Hint2: u64,
    Clsn: u64,
    Status: u32,
};

pub const SHRINK_VOLUME_REQUEST_TYPES = extern enum(i32) {
    ShrinkPrepare = 1,
    ShrinkCommit = 2,
    ShrinkAbort = 3,
};
pub const ShrinkPrepare = SHRINK_VOLUME_REQUEST_TYPES.ShrinkPrepare;
pub const ShrinkCommit = SHRINK_VOLUME_REQUEST_TYPES.ShrinkCommit;
pub const ShrinkAbort = SHRINK_VOLUME_REQUEST_TYPES.ShrinkAbort;

pub const TXFS_ROLLFORWARD_REDO_INFORMATION = extern struct {
    LastVirtualClock: LARGE_INTEGER,
    LastRedoLsn: u64,
    HighestRecoveryLsn: u64,
    Flags: u32,
};

pub const TXFS_START_RM_INFORMATION = extern struct {
    Flags: u32,
    LogContainerSize: u64,
    LogContainerCountMin: u32,
    LogContainerCountMax: u32,
    LogGrowthIncrement: u32,
    LogAutoShrinkPercentage: u32,
    TmLogPathOffset: u32,
    TmLogPathLength: u16,
    LoggingMode: u16,
    LogPathLength: u16,
    Reserved: u16,
    LogPath: [1]u16,
};

pub const FILE_FS_PERSISTENT_VOLUME_INFORMATION = extern struct {
    VolumeFlags: u32,
    FlagMask: u32,
    Version: u32,
    Reserved: u32,
};

pub const STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = extern struct {
    RequestLevel: u32,
    RequestFlags: u32,
};

pub const STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = extern struct {
    EntryLength: u32,
    DependencyTypeFlags: u32,
    ProviderSpecificFlags: u32,
    VirtualStorageType: VIRTUAL_STORAGE_TYPE,
};

pub const STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = extern struct {
    EntryLength: u32,
    DependencyTypeFlags: u32,
    ProviderSpecificFlags: u32,
    VirtualStorageType: VIRTUAL_STORAGE_TYPE,
    AncestorLevel: u32,
    HostVolumeNameOffset: u32,
    HostVolumeNameSize: u32,
    DependentVolumeNameOffset: u32,
    DependentVolumeNameSize: u32,
    RelativePathOffset: u32,
    RelativePathSize: u32,
    DependentDeviceNameOffset: u32,
    DependentDeviceNameSize: u32,
};

pub const STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = extern struct {
    ResponseLevel: u32,
    NumberEntries: u32,
    Anonymous: STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SD_CHANGE_MACHINE_SID_INPUT = extern struct {
    CurrentMachineSIDOffset: u16,
    CurrentMachineSIDLength: u16,
    NewMachineSIDOffset: u16,
    NewMachineSIDLength: u16,
};

pub const SD_CHANGE_MACHINE_SID_OUTPUT = extern struct {
    NumSDChangedSuccess: u64,
    NumSDChangedFail: u64,
    NumSDUnused: u64,
    NumSDTotal: u64,
    NumMftSDChangedSuccess: u64,
    NumMftSDChangedFail: u64,
    NumMftSDTotal: u64,
};

pub const SD_QUERY_STATS_INPUT = extern struct {
    Reserved: u32,
};

pub const SD_QUERY_STATS_OUTPUT = extern struct {
    SdsStreamSize: u64,
    SdsAllocationSize: u64,
    SiiStreamSize: u64,
    SiiAllocationSize: u64,
    SdhStreamSize: u64,
    SdhAllocationSize: u64,
    NumSDTotal: u64,
    NumSDUnused: u64,
};

pub const SD_ENUM_SDS_INPUT = extern struct {
    StartingOffset: u64,
    MaxSDEntriesToReturn: u64,
};

pub const SD_ENUM_SDS_ENTRY = extern struct {
    Hash: u32,
    SecurityId: u32,
    Offset: u64,
    Length: u32,
    Descriptor: [1]u8,
};

pub const SD_ENUM_SDS_OUTPUT = extern struct {
    NextOffset: u64,
    NumSDEntriesReturned: u64,
    NumSDBytesReturned: u64,
    SDEntry: [1]SD_ENUM_SDS_ENTRY,
};

pub const SD_GLOBAL_CHANGE_INPUT = extern struct {
    Flags: u32,
    ChangeType: u32,
    Anonymous: SD_GLOBAL_CHANGE_INPUT._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SD_GLOBAL_CHANGE_OUTPUT = extern struct {
    Flags: u32,
    ChangeType: u32,
    Anonymous: SD_GLOBAL_CHANGE_OUTPUT._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const FILE_TYPE_NOTIFICATION_INPUT = extern struct {
    Flags: u32,
    NumFileTypeIDs: u32,
    FileTypeID: [1]Guid,
};

pub const CSV_MGMT_LOCK = extern struct {
    Flags: u32,
};

pub const CSV_QUERY_FILE_REVISION_FILE_ID_128 = extern struct {
    FileId: FILE_ID_128,
    FileRevision: [3]i64,
};

pub const CSVFS_DISK_CONNECTIVITY = extern enum(i32) {
    CsvFsDiskConnectivityNone = 0,
    CsvFsDiskConnectivityMdsNodeOnly = 1,
    CsvFsDiskConnectivitySubsetOfNodes = 2,
    CsvFsDiskConnectivityAllNodes = 3,
};
pub const CsvFsDiskConnectivityNone = CSVFS_DISK_CONNECTIVITY.CsvFsDiskConnectivityNone;
pub const CsvFsDiskConnectivityMdsNodeOnly = CSVFS_DISK_CONNECTIVITY.CsvFsDiskConnectivityMdsNodeOnly;
pub const CsvFsDiskConnectivitySubsetOfNodes = CSVFS_DISK_CONNECTIVITY.CsvFsDiskConnectivitySubsetOfNodes;
pub const CsvFsDiskConnectivityAllNodes = CSVFS_DISK_CONNECTIVITY.CsvFsDiskConnectivityAllNodes;

pub const CSV_QUERY_VOLUME_REDIRECT_STATE = extern struct {
    MdsNodeId: u32,
    DsNodeId: u32,
    IsDiskConnected: u8,
    ClusterEnableDirectIo: u8,
    DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
};

pub const CSV_QUERY_MDS_PATH_V2 = extern struct {
    Version: i64,
    RequiredSize: u32,
    MdsNodeId: u32,
    DsNodeId: u32,
    Flags: u32,
    DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
    VolumeId: Guid,
    IpAddressOffset: u32,
    IpAddressLength: u32,
    PathOffset: u32,
    PathLength: u32,
};

pub const STORAGE_RESERVE_ID = extern enum(i32) {
    StorageReserveIdNone = 0,
    StorageReserveIdHard = 1,
    StorageReserveIdSoft = 2,
    StorageReserveIdUpdateScratch = 3,
    StorageReserveIdMax = 4,
};
pub const StorageReserveIdNone = STORAGE_RESERVE_ID.StorageReserveIdNone;
pub const StorageReserveIdHard = STORAGE_RESERVE_ID.StorageReserveIdHard;
pub const StorageReserveIdSoft = STORAGE_RESERVE_ID.StorageReserveIdSoft;
pub const StorageReserveIdUpdateScratch = STORAGE_RESERVE_ID.StorageReserveIdUpdateScratch;
pub const StorageReserveIdMax = STORAGE_RESERVE_ID.StorageReserveIdMax;

pub const QUERY_FILE_LAYOUT_FILTER_TYPE = extern enum(i32) {
    NONE = 0,
    CLUSTERS = 1,
    FILEID = 2,
    STORAGE_RESERVE_ID = 3,
    QUERY_FILE_LAYOUT_NUM_FILTER_TYPES = 4,
};
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_NONE = QUERY_FILE_LAYOUT_FILTER_TYPE.NONE;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS = QUERY_FILE_LAYOUT_FILTER_TYPE.CLUSTERS;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID = QUERY_FILE_LAYOUT_FILTER_TYPE.FILEID;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID = QUERY_FILE_LAYOUT_FILTER_TYPE.STORAGE_RESERVE_ID;
pub const QUERY_FILE_LAYOUT_NUM_FILTER_TYPES = QUERY_FILE_LAYOUT_FILTER_TYPE.QUERY_FILE_LAYOUT_NUM_FILTER_TYPES;

pub const CLUSTER_RANGE = extern struct {
    StartingCluster: LARGE_INTEGER,
    ClusterCount: LARGE_INTEGER,
};

pub const FILE_REFERENCE_RANGE = extern struct {
    StartingFileReferenceNumber: u64,
    EndingFileReferenceNumber: u64,
};

pub const QUERY_FILE_LAYOUT_INPUT = extern struct {
    Anonymous: QUERY_FILE_LAYOUT_INPUT._Anonymous_e__Union,
    Flags: u32,
    FilterType: QUERY_FILE_LAYOUT_FILTER_TYPE,
    Reserved: u32,
    Filter: QUERY_FILE_LAYOUT_INPUT._Filter_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
    const _Filter_e__Union = u32; // TODO: generate this nested type!
};

pub const QUERY_FILE_LAYOUT_OUTPUT = extern struct {
    FileEntryCount: u32,
    FirstFileOffset: u32,
    Flags: u32,
    Reserved: u32,
};

pub const FILE_LAYOUT_ENTRY = extern struct {
    Version: u32,
    NextFileOffset: u32,
    Flags: u32,
    FileAttributes: u32,
    FileReferenceNumber: u64,
    FirstNameOffset: u32,
    FirstStreamOffset: u32,
    ExtraInfoOffset: u32,
    ExtraInfoLength: u32,
};

pub const FILE_LAYOUT_NAME_ENTRY = extern struct {
    NextNameOffset: u32,
    Flags: u32,
    ParentFileReferenceNumber: u64,
    FileNameLength: u32,
    Reserved: u32,
    FileName: [1]u16,
};

pub const FILE_LAYOUT_INFO_ENTRY = extern struct {
    BasicInformation: FILE_LAYOUT_INFO_ENTRY._BasicInformation_e__Struct,
    OwnerId: u32,
    SecurityId: u32,
    Usn: i64,
    StorageReserveId: STORAGE_RESERVE_ID,
    const _BasicInformation_e__Struct = u32; // TODO: generate this nested type!
};

pub const STREAM_LAYOUT_ENTRY = extern struct {
    Version: u32,
    NextStreamOffset: u32,
    Flags: u32,
    ExtentInformationOffset: u32,
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    StreamInformationOffset: u32,
    AttributeTypeCode: u32,
    AttributeFlags: u32,
    StreamIdentifierLength: u32,
    StreamIdentifier: [1]u16,
};

pub const STREAM_EXTENT_ENTRY = extern struct {
    Flags: u32,
    ExtentInformation: STREAM_EXTENT_ENTRY._ExtentInformation_e__Union,
    const _ExtentInformation_e__Union = u32; // TODO: generate this nested type!
};

pub const FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = extern struct {
    EnableIntegrity: u8,
    KeepIntegrityStateUnchanged: u8,
    Reserved: u16,
    Flags: u32,
    Version: u8,
    Reserved2: [7]u8,
};

pub const FSCTL_OFFLOAD_READ_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    TokenTimeToLive: u32,
    Reserved: u32,
    FileOffset: u64,
    CopyLength: u64,
};

pub const FSCTL_OFFLOAD_READ_OUTPUT = extern struct {
    Size: u32,
    Flags: u32,
    TransferLength: u64,
    Token: [512]u8,
};

pub const FSCTL_OFFLOAD_WRITE_INPUT = extern struct {
    Size: u32,
    Flags: u32,
    FileOffset: u64,
    CopyLength: u64,
    TransferOffset: u64,
    Token: [512]u8,
};

pub const FSCTL_OFFLOAD_WRITE_OUTPUT = extern struct {
    Size: u32,
    Flags: u32,
    LengthWritten: u64,
};

pub const SET_PURGE_FAILURE_MODE_INPUT = extern struct {
    Flags: u32,
};

pub const FILE_REGION_INFO = extern struct {
    FileOffset: i64,
    Length: i64,
    Usage: u32,
    Reserved: u32,
};

pub const FILE_REGION_OUTPUT = extern struct {
    Flags: u32,
    TotalRegionEntryCount: u32,
    RegionEntryCount: u32,
    Reserved: u32,
    Region: [1]FILE_REGION_INFO,
};

pub const FILE_REGION_INPUT = extern struct {
    FileOffset: i64,
    Length: i64,
    DesiredUsage: u32,
};

pub const WRITE_USN_REASON_INPUT = extern struct {
    Flags: u32,
    UsnReasonToWrite: u32,
};

pub const FILE_STORAGE_TIER_CLASS = extern enum(i32) {
    FileStorageTierClassUnspecified = 0,
    FileStorageTierClassCapacity = 1,
    FileStorageTierClassPerformance = 2,
    FileStorageTierClassMax = 3,
};
pub const FileStorageTierClassUnspecified = FILE_STORAGE_TIER_CLASS.FileStorageTierClassUnspecified;
pub const FileStorageTierClassCapacity = FILE_STORAGE_TIER_CLASS.FileStorageTierClassCapacity;
pub const FileStorageTierClassPerformance = FILE_STORAGE_TIER_CLASS.FileStorageTierClassPerformance;
pub const FileStorageTierClassMax = FILE_STORAGE_TIER_CLASS.FileStorageTierClassMax;

pub const STREAM_INFORMATION_ENTRY = extern struct {
    Version: u32,
    Flags: u32,
    StreamInformation: STREAM_INFORMATION_ENTRY._StreamInformation,
    const _StreamInformation = u32; // TODO: generate this nested type!
};

pub const FILE_DESIRED_STORAGE_CLASS_INFORMATION = extern struct {
    Class: FILE_STORAGE_TIER_CLASS,
    Flags: u32,
};

pub const DUPLICATE_EXTENTS_DATA_EX = extern struct {
    Size: ?*c_void,
    FileHandle: HANDLE,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
    Flags: u32,
};

pub const REFS_SMR_VOLUME_GC_STATE = extern enum(i32) {
    SmrGcStateInactive = 0,
    SmrGcStatePaused = 1,
    SmrGcStateActive = 2,
    SmrGcStateActiveFullSpeed = 3,
};
pub const SmrGcStateInactive = REFS_SMR_VOLUME_GC_STATE.SmrGcStateInactive;
pub const SmrGcStatePaused = REFS_SMR_VOLUME_GC_STATE.SmrGcStatePaused;
pub const SmrGcStateActive = REFS_SMR_VOLUME_GC_STATE.SmrGcStateActive;
pub const SmrGcStateActiveFullSpeed = REFS_SMR_VOLUME_GC_STATE.SmrGcStateActiveFullSpeed;

pub const REFS_SMR_VOLUME_INFO_OUTPUT = extern struct {
    Version: u32,
    Flags: u32,
    SizeOfRandomlyWritableTier: LARGE_INTEGER,
    FreeSpaceInRandomlyWritableTier: LARGE_INTEGER,
    SizeofSMRTier: LARGE_INTEGER,
    FreeSpaceInSMRTier: LARGE_INTEGER,
    UsableFreeSpaceInSMRTier: LARGE_INTEGER,
    VolumeGcState: REFS_SMR_VOLUME_GC_STATE,
    VolumeGcLastStatus: u32,
    Unused: [7]u64,
};

pub const REFS_SMR_VOLUME_GC_ACTION = extern enum(i32) {
    SmrGcActionStart = 1,
    SmrGcActionStartFullSpeed = 2,
    SmrGcActionPause = 3,
    SmrGcActionStop = 4,
};
pub const SmrGcActionStart = REFS_SMR_VOLUME_GC_ACTION.SmrGcActionStart;
pub const SmrGcActionStartFullSpeed = REFS_SMR_VOLUME_GC_ACTION.SmrGcActionStartFullSpeed;
pub const SmrGcActionPause = REFS_SMR_VOLUME_GC_ACTION.SmrGcActionPause;
pub const SmrGcActionStop = REFS_SMR_VOLUME_GC_ACTION.SmrGcActionStop;

pub const REFS_SMR_VOLUME_GC_METHOD = extern enum(i32) {
    SmrGcMethodCompaction = 1,
    SmrGcMethodCompression = 2,
    SmrGcMethodRotation = 3,
};
pub const SmrGcMethodCompaction = REFS_SMR_VOLUME_GC_METHOD.SmrGcMethodCompaction;
pub const SmrGcMethodCompression = REFS_SMR_VOLUME_GC_METHOD.SmrGcMethodCompression;
pub const SmrGcMethodRotation = REFS_SMR_VOLUME_GC_METHOD.SmrGcMethodRotation;

pub const REFS_SMR_VOLUME_GC_PARAMETERS = extern struct {
    Version: u32,
    Flags: u32,
    Action: REFS_SMR_VOLUME_GC_ACTION,
    Method: REFS_SMR_VOLUME_GC_METHOD,
    IoGranularity: u32,
    CompressionFormat: u32,
    Unused: [8]u64,
};

pub const STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = extern struct {
    OptimalWriteSize: u32,
    StreamGranularitySize: u32,
    StreamIdMin: u32,
    StreamIdMax: u32,
};

pub const STREAMS_ASSOCIATE_ID_INPUT_BUFFER = extern struct {
    Flags: u32,
    StreamId: u32,
};

pub const STREAMS_QUERY_ID_OUTPUT_BUFFER = extern struct {
    StreamId: u32,
};

pub const QUERY_BAD_RANGES_INPUT_RANGE = extern struct {
    StartOffset: u64,
    LengthInBytes: u64,
};

pub const QUERY_BAD_RANGES_INPUT = extern struct {
    Flags: u32,
    NumRanges: u32,
    Ranges: [1]QUERY_BAD_RANGES_INPUT_RANGE,
};

pub const QUERY_BAD_RANGES_OUTPUT_RANGE = extern struct {
    Flags: u32,
    Reserved: u32,
    StartOffset: u64,
    LengthInBytes: u64,
};

pub const QUERY_BAD_RANGES_OUTPUT = extern struct {
    Flags: u32,
    NumBadRanges: u32,
    NextOffsetToLookUp: u64,
    BadRanges: [1]QUERY_BAD_RANGES_OUTPUT_RANGE,
};

pub const SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = extern struct {
    Flags: u32,
    AlignmentShift: u32,
    FileOffsetToAlign: u64,
    FallbackAlignmentShift: u32,
};

pub const VIRTUAL_STORAGE_BEHAVIOR_CODE = extern enum(i32) {
    VirtualStorageBehaviorUndefined = 0,
    VirtualStorageBehaviorCacheWriteThrough = 1,
    VirtualStorageBehaviorCacheWriteBack = 2,
};
pub const VirtualStorageBehaviorUndefined = VIRTUAL_STORAGE_BEHAVIOR_CODE.VirtualStorageBehaviorUndefined;
pub const VirtualStorageBehaviorCacheWriteThrough = VIRTUAL_STORAGE_BEHAVIOR_CODE.VirtualStorageBehaviorCacheWriteThrough;
pub const VirtualStorageBehaviorCacheWriteBack = VIRTUAL_STORAGE_BEHAVIOR_CODE.VirtualStorageBehaviorCacheWriteBack;

pub const VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = extern struct {
    Size: u32,
    BehaviorCode: VIRTUAL_STORAGE_BEHAVIOR_CODE,
};

pub const ENCRYPTION_KEY_CTRL_INPUT = extern struct {
    HeaderSize: u32,
    StructureSize: u32,
    KeyOffset: u16,
    KeySize: u16,
    DplLock: u32,
    DplUserId: u64,
    DplCredentialId: u64,
};

pub const WOF_EXTERNAL_INFO = extern struct {
    Version: u32,
    Provider: u32,
};

pub const WOF_EXTERNAL_FILE_ID = extern struct {
    FileId: FILE_ID_128,
};

pub const WOF_VERSION_INFO = extern struct {
    WofVersion: u32,
};

pub const WIM_PROVIDER_EXTERNAL_INFO = extern struct {
    Version: u32,
    Flags: u32,
    DataSourceId: LARGE_INTEGER,
    ResourceHash: [20]u8,
};

pub const WIM_PROVIDER_ADD_OVERLAY_INPUT = extern struct {
    WimType: u32,
    WimIndex: u32,
    WimFileNameOffset: u32,
    WimFileNameLength: u32,
};

pub const WIM_PROVIDER_UPDATE_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
    WimFileNameOffset: u32,
    WimFileNameLength: u32,
};

pub const WIM_PROVIDER_REMOVE_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
};

pub const WIM_PROVIDER_SUSPEND_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
};

pub const WIM_PROVIDER_OVERLAY_ENTRY = extern struct {
    NextEntryOffset: u32,
    DataSourceId: LARGE_INTEGER,
    WimGuid: Guid,
    WimFileNameOffset: u32,
    WimType: u32,
    WimIndex: u32,
    Flags: u32,
};

pub const FILE_PROVIDER_EXTERNAL_INFO_V0 = extern struct {
    Version: u32,
    Algorithm: u32,
};

pub const FILE_PROVIDER_EXTERNAL_INFO_V1 = extern struct {
    Version: u32,
    Algorithm: u32,
    Flags: u32,
};

pub const CONTAINER_VOLUME_STATE = extern struct {
    Flags: u32,
};

pub const CONTAINER_ROOT_INFO_INPUT = extern struct {
    Flags: u32,
};

pub const CONTAINER_ROOT_INFO_OUTPUT = extern struct {
    ContainerRootIdLength: u16,
    ContainerRootId: [1]u8,
};

pub const VIRTUALIZATION_INSTANCE_INFO_INPUT = extern struct {
    NumberOfWorkerThreads: u32,
    Flags: u32,
};

pub const VIRTUALIZATION_INSTANCE_INFO_INPUT_EX = extern struct {
    HeaderSize: u16,
    Flags: u32,
    NotificationInfoSize: u32,
    NotificationInfoOffset: u16,
    ProviderMajorVersion: u16,
};

pub const VIRTUALIZATION_INSTANCE_INFO_OUTPUT = extern struct {
    VirtualizationInstanceID: Guid,
};

pub const GET_FILTER_FILE_IDENTIFIER_INPUT = extern struct {
    AltitudeLength: u16,
    Altitude: [1]u16,
};

pub const GET_FILTER_FILE_IDENTIFIER_OUTPUT = extern struct {
    FilterFileIdentifierLength: u16,
    FilterFileIdentifier: [1]u8,
};

pub const PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = fn(
    SourceContext: *IO_IRP_EXT_TRACK_OFFSET_HEADER,
    TargetContext: *IO_IRP_EXT_TRACK_OFFSET_HEADER,
    RelativeOffset: i64,
) callconv(@import("std").os.windows.WINAPI) void;

pub const IO_IRP_EXT_TRACK_OFFSET_HEADER = extern struct {
    Validation: u16,
    Flags: u16,
    TrackedOffsetCallback: PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK,
};

pub const SCARD_IO_REQUEST = extern struct {
    dwProtocol: u32,
    cbPciLength: u32,
};

pub const SCARD_T0_COMMAND = extern struct {
    bCla: u8,
    bIns: u8,
    bP1: u8,
    bP2: u8,
    bP3: u8,
};

pub const SCARD_T0_REQUEST = extern struct {
    ioRequest: SCARD_IO_REQUEST,
    bSw1: u8,
    bSw2: u8,
    Anonymous: SCARD_T0_REQUEST._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const SCARD_T1_REQUEST = extern struct {
    ioRequest: SCARD_IO_REQUEST,
};

pub const PRINTER_INFO_1A = extern struct {
    Flags: u32,
    pDescription: PSTR,
    pName: PSTR,
    pComment: PSTR,
};

pub const PRINTER_INFO_1W = extern struct {
    Flags: u32,
    pDescription: PWSTR,
    pName: PWSTR,
    pComment: PWSTR,
};

pub const PRINTER_INFO_2A = extern struct {
    pServerName: PSTR,
    pPrinterName: PSTR,
    pShareName: PSTR,
    pPortName: PSTR,
    pDriverName: PSTR,
    pComment: PSTR,
    pLocation: PSTR,
    pDevMode: *DEVMODEA,
    pSepFile: PSTR,
    pPrintProcessor: PSTR,
    pDatatype: PSTR,
    pParameters: PSTR,
    pSecurityDescriptor: *c_void,
    Attributes: u32,
    Priority: u32,
    DefaultPriority: u32,
    StartTime: u32,
    UntilTime: u32,
    Status: u32,
    cJobs: u32,
    AveragePPM: u32,
};

pub const PRINTER_INFO_2W = extern struct {
    pServerName: PWSTR,
    pPrinterName: PWSTR,
    pShareName: PWSTR,
    pPortName: PWSTR,
    pDriverName: PWSTR,
    pComment: PWSTR,
    pLocation: PWSTR,
    pDevMode: *DEVMODEW,
    pSepFile: PWSTR,
    pPrintProcessor: PWSTR,
    pDatatype: PWSTR,
    pParameters: PWSTR,
    pSecurityDescriptor: *c_void,
    Attributes: u32,
    Priority: u32,
    DefaultPriority: u32,
    StartTime: u32,
    UntilTime: u32,
    Status: u32,
    cJobs: u32,
    AveragePPM: u32,
};

pub const PRINTER_INFO_3 = extern struct {
    pSecurityDescriptor: *c_void,
};

pub const PRINTER_INFO_4A = extern struct {
    pPrinterName: PSTR,
    pServerName: PSTR,
    Attributes: u32,
};

pub const PRINTER_INFO_4W = extern struct {
    pPrinterName: PWSTR,
    pServerName: PWSTR,
    Attributes: u32,
};

pub const PRINTER_INFO_5A = extern struct {
    pPrinterName: PSTR,
    pPortName: PSTR,
    Attributes: u32,
    DeviceNotSelectedTimeout: u32,
    TransmissionRetryTimeout: u32,
};

pub const PRINTER_INFO_5W = extern struct {
    pPrinterName: PWSTR,
    pPortName: PWSTR,
    Attributes: u32,
    DeviceNotSelectedTimeout: u32,
    TransmissionRetryTimeout: u32,
};

pub const PRINTER_INFO_6 = extern struct {
    dwStatus: u32,
};

pub const PRINTER_INFO_7A = extern struct {
    pszObjectGUID: PSTR,
    dwAction: u32,
};

pub const PRINTER_INFO_7W = extern struct {
    pszObjectGUID: PWSTR,
    dwAction: u32,
};

pub const PRINTER_INFO_8A = extern struct {
    pDevMode: *DEVMODEA,
};

pub const PRINTER_INFO_8W = extern struct {
    pDevMode: *DEVMODEW,
};

pub const PRINTER_INFO_9A = extern struct {
    pDevMode: *DEVMODEA,
};

pub const PRINTER_INFO_9W = extern struct {
    pDevMode: *DEVMODEW,
};

pub const JOB_INFO_1A = extern struct {
    JobId: u32,
    pPrinterName: PSTR,
    pMachineName: PSTR,
    pUserName: PSTR,
    pDocument: PSTR,
    pDatatype: PSTR,
    pStatus: PSTR,
    Status: u32,
    Priority: u32,
    Position: u32,
    TotalPages: u32,
    PagesPrinted: u32,
    Submitted: SYSTEMTIME,
};

pub const JOB_INFO_1W = extern struct {
    JobId: u32,
    pPrinterName: PWSTR,
    pMachineName: PWSTR,
    pUserName: PWSTR,
    pDocument: PWSTR,
    pDatatype: PWSTR,
    pStatus: PWSTR,
    Status: u32,
    Priority: u32,
    Position: u32,
    TotalPages: u32,
    PagesPrinted: u32,
    Submitted: SYSTEMTIME,
};

pub const JOB_INFO_2A = extern struct {
    JobId: u32,
    pPrinterName: PSTR,
    pMachineName: PSTR,
    pUserName: PSTR,
    pDocument: PSTR,
    pNotifyName: PSTR,
    pDatatype: PSTR,
    pPrintProcessor: PSTR,
    pParameters: PSTR,
    pDriverName: PSTR,
    pDevMode: *DEVMODEA,
    pStatus: PSTR,
    pSecurityDescriptor: *c_void,
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
};

pub const JOB_INFO_2W = extern struct {
    JobId: u32,
    pPrinterName: PWSTR,
    pMachineName: PWSTR,
    pUserName: PWSTR,
    pDocument: PWSTR,
    pNotifyName: PWSTR,
    pDatatype: PWSTR,
    pPrintProcessor: PWSTR,
    pParameters: PWSTR,
    pDriverName: PWSTR,
    pDevMode: *DEVMODEW,
    pStatus: PWSTR,
    pSecurityDescriptor: *c_void,
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
};

pub const JOB_INFO_3 = extern struct {
    JobId: u32,
    NextJobId: u32,
    Reserved: u32,
};

pub const JOB_INFO_4A = extern struct {
    JobId: u32,
    pPrinterName: PSTR,
    pMachineName: PSTR,
    pUserName: PSTR,
    pDocument: PSTR,
    pNotifyName: PSTR,
    pDatatype: PSTR,
    pPrintProcessor: PSTR,
    pParameters: PSTR,
    pDriverName: PSTR,
    pDevMode: *DEVMODEA,
    pStatus: PSTR,
    pSecurityDescriptor: *c_void,
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
    SizeHigh: i32,
};

pub const JOB_INFO_4W = extern struct {
    JobId: u32,
    pPrinterName: PWSTR,
    pMachineName: PWSTR,
    pUserName: PWSTR,
    pDocument: PWSTR,
    pNotifyName: PWSTR,
    pDatatype: PWSTR,
    pPrintProcessor: PWSTR,
    pParameters: PWSTR,
    pDriverName: PWSTR,
    pDevMode: *DEVMODEW,
    pStatus: PWSTR,
    pSecurityDescriptor: *c_void,
    Status: u32,
    Priority: u32,
    Position: u32,
    StartTime: u32,
    UntilTime: u32,
    TotalPages: u32,
    Size: u32,
    Submitted: SYSTEMTIME,
    Time: u32,
    PagesPrinted: u32,
    SizeHigh: i32,
};

pub const ADDJOB_INFO_1A = extern struct {
    Path: PSTR,
    JobId: u32,
};

pub const ADDJOB_INFO_1W = extern struct {
    Path: PWSTR,
    JobId: u32,
};

pub const DRIVER_INFO_1A = extern struct {
    pName: PSTR,
};

pub const DRIVER_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const DRIVER_INFO_2A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
};

pub const DRIVER_INFO_2W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
};

pub const DRIVER_INFO_3A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    pHelpFile: PSTR,
    pDependentFiles: PSTR,
    pMonitorName: PSTR,
    pDefaultDataType: PSTR,
};

pub const DRIVER_INFO_3W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    pHelpFile: PWSTR,
    pDependentFiles: PWSTR,
    pMonitorName: PWSTR,
    pDefaultDataType: PWSTR,
};

pub const DRIVER_INFO_4A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    pHelpFile: PSTR,
    pDependentFiles: PSTR,
    pMonitorName: PSTR,
    pDefaultDataType: PSTR,
    pszzPreviousNames: PSTR,
};

pub const DRIVER_INFO_4W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    pHelpFile: PWSTR,
    pDependentFiles: PWSTR,
    pMonitorName: PWSTR,
    pDefaultDataType: PWSTR,
    pszzPreviousNames: PWSTR,
};

pub const DRIVER_INFO_5A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    dwDriverAttributes: u32,
    dwConfigVersion: u32,
    dwDriverVersion: u32,
};

pub const DRIVER_INFO_5W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    dwDriverAttributes: u32,
    dwConfigVersion: u32,
    dwDriverVersion: u32,
};

pub const DRIVER_INFO_6A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    pHelpFile: PSTR,
    pDependentFiles: PSTR,
    pMonitorName: PSTR,
    pDefaultDataType: PSTR,
    pszzPreviousNames: PSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: PSTR,
    pszOEMUrl: PSTR,
    pszHardwareID: PSTR,
    pszProvider: PSTR,
};

pub const DRIVER_INFO_6W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    pHelpFile: PWSTR,
    pDependentFiles: PWSTR,
    pMonitorName: PWSTR,
    pDefaultDataType: PWSTR,
    pszzPreviousNames: PWSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: PWSTR,
    pszOEMUrl: PWSTR,
    pszHardwareID: PWSTR,
    pszProvider: PWSTR,
};

pub const DRIVER_INFO_8A = extern struct {
    cVersion: u32,
    pName: PSTR,
    pEnvironment: PSTR,
    pDriverPath: PSTR,
    pDataFile: PSTR,
    pConfigFile: PSTR,
    pHelpFile: PSTR,
    pDependentFiles: PSTR,
    pMonitorName: PSTR,
    pDefaultDataType: PSTR,
    pszzPreviousNames: PSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: PSTR,
    pszOEMUrl: PSTR,
    pszHardwareID: PSTR,
    pszProvider: PSTR,
    pszPrintProcessor: PSTR,
    pszVendorSetup: PSTR,
    pszzColorProfiles: PSTR,
    pszInfPath: PSTR,
    dwPrinterDriverAttributes: u32,
    pszzCoreDriverDependencies: PSTR,
    ftMinInboxDriverVerDate: FILETIME,
    dwlMinInboxDriverVerVersion: u64,
};

pub const DRIVER_INFO_8W = extern struct {
    cVersion: u32,
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDriverPath: PWSTR,
    pDataFile: PWSTR,
    pConfigFile: PWSTR,
    pHelpFile: PWSTR,
    pDependentFiles: PWSTR,
    pMonitorName: PWSTR,
    pDefaultDataType: PWSTR,
    pszzPreviousNames: PWSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    pszMfgName: PWSTR,
    pszOEMUrl: PWSTR,
    pszHardwareID: PWSTR,
    pszProvider: PWSTR,
    pszPrintProcessor: PWSTR,
    pszVendorSetup: PWSTR,
    pszzColorProfiles: PWSTR,
    pszInfPath: PWSTR,
    dwPrinterDriverAttributes: u32,
    pszzCoreDriverDependencies: PWSTR,
    ftMinInboxDriverVerDate: FILETIME,
    dwlMinInboxDriverVerVersion: u64,
};

pub const DOC_INFO_1A = extern struct {
    pDocName: PSTR,
    pOutputFile: PSTR,
    pDatatype: PSTR,
};

pub const DOC_INFO_1W = extern struct {
    pDocName: PWSTR,
    pOutputFile: PWSTR,
    pDatatype: PWSTR,
};

pub const FORM_INFO_1A = extern struct {
    Flags: u32,
    pName: PSTR,
    Size: SIZE,
    ImageableArea: RECTL,
};

pub const FORM_INFO_1W = extern struct {
    Flags: u32,
    pName: PWSTR,
    Size: SIZE,
    ImageableArea: RECTL,
};

pub const FORM_INFO_2A = extern struct {
    Flags: u32,
    pName: [*:0]const u8,
    Size: SIZE,
    ImageableArea: RECTL,
    pKeyword: [*:0]const u8,
    StringType: u32,
    pMuiDll: [*:0]const u8,
    dwResourceId: u32,
    pDisplayName: [*:0]const u8,
    wLangId: u16,
};

pub const FORM_INFO_2W = extern struct {
    Flags: u32,
    pName: [*:0]const u16,
    Size: SIZE,
    ImageableArea: RECTL,
    pKeyword: [*:0]const u8,
    StringType: u32,
    pMuiDll: [*:0]const u16,
    dwResourceId: u32,
    pDisplayName: [*:0]const u16,
    wLangId: u16,
};

pub const DOC_INFO_2A = extern struct {
    pDocName: PSTR,
    pOutputFile: PSTR,
    pDatatype: PSTR,
    dwMode: u32,
    JobId: u32,
};

pub const DOC_INFO_2W = extern struct {
    pDocName: PWSTR,
    pOutputFile: PWSTR,
    pDatatype: PWSTR,
    dwMode: u32,
    JobId: u32,
};

pub const DOC_INFO_3A = extern struct {
    pDocName: PSTR,
    pOutputFile: PSTR,
    pDatatype: PSTR,
    dwFlags: u32,
};

pub const DOC_INFO_3W = extern struct {
    pDocName: PWSTR,
    pOutputFile: PWSTR,
    pDatatype: PWSTR,
    dwFlags: u32,
};

pub const PRINTPROCESSOR_INFO_1A = extern struct {
    pName: PSTR,
};

pub const PRINTPROCESSOR_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const PRINTPROCESSOR_CAPS_1 = extern struct {
    dwLevel: u32,
    dwNupOptions: u32,
    dwPageOrderFlags: u32,
    dwNumberOfCopies: u32,
};

pub const PRINTPROCESSOR_CAPS_2 = extern struct {
    dwLevel: u32,
    dwNupOptions: u32,
    dwPageOrderFlags: u32,
    dwNumberOfCopies: u32,
    dwDuplexHandlingCaps: u32,
    dwNupDirectionCaps: u32,
    dwNupBorderCaps: u32,
    dwBookletHandlingCaps: u32,
    dwScalingCaps: u32,
};

pub const PORT_INFO_1A = extern struct {
    pName: PSTR,
};

pub const PORT_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const PORT_INFO_2A = extern struct {
    pPortName: PSTR,
    pMonitorName: PSTR,
    pDescription: PSTR,
    fPortType: u32,
    Reserved: u32,
};

pub const PORT_INFO_2W = extern struct {
    pPortName: PWSTR,
    pMonitorName: PWSTR,
    pDescription: PWSTR,
    fPortType: u32,
    Reserved: u32,
};

pub const PORT_INFO_3A = extern struct {
    dwStatus: u32,
    pszStatus: PSTR,
    dwSeverity: u32,
};

pub const PORT_INFO_3W = extern struct {
    dwStatus: u32,
    pszStatus: PWSTR,
    dwSeverity: u32,
};

pub const MONITOR_INFO_1A = extern struct {
    pName: PSTR,
};

pub const MONITOR_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const MONITOR_INFO_2A = extern struct {
    pName: PSTR,
    pEnvironment: PSTR,
    pDLLName: PSTR,
};

pub const MONITOR_INFO_2W = extern struct {
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDLLName: PWSTR,
};

pub const DATATYPES_INFO_1A = extern struct {
    pName: PSTR,
};

pub const DATATYPES_INFO_1W = extern struct {
    pName: PWSTR,
};

pub const PRINTER_DEFAULTSA = extern struct {
    pDatatype: PSTR,
    pDevMode: *DEVMODEA,
    DesiredAccess: u32,
};

pub const PRINTER_DEFAULTSW = extern struct {
    pDatatype: PWSTR,
    pDevMode: *DEVMODEW,
    DesiredAccess: u32,
};

pub const PRINTER_ENUM_VALUESA = extern struct {
    pValueName: PSTR,
    cbValueName: u32,
    dwType: u32,
    pData: *u8,
    cbData: u32,
};

pub const PRINTER_ENUM_VALUESW = extern struct {
    pValueName: PWSTR,
    cbValueName: u32,
    dwType: u32,
    pData: *u8,
    cbData: u32,
};

pub const PRINTER_NOTIFY_OPTIONS_TYPE = extern struct {
    Type: u16,
    Reserved0: u16,
    Reserved1: u32,
    Reserved2: u32,
    Count: u32,
    pFields: *u16,
};

pub const PRINTER_NOTIFY_OPTIONS = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    pTypes: *PRINTER_NOTIFY_OPTIONS_TYPE,
};

pub const PRINTER_NOTIFY_INFO_DATA = extern struct {
    Type: u16,
    Field: u16,
    Reserved: u32,
    Id: u32,
    NotifyData: PRINTER_NOTIFY_INFO_DATA._NotifyData_e__Union,
    const _NotifyData_e__Union = u32; // TODO: generate this nested type!
};

pub const PRINTER_NOTIFY_INFO = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    aData: [1]PRINTER_NOTIFY_INFO_DATA,
};

pub const BINARY_CONTAINER = extern struct {
    cbBuf: u32,
    pData: *u8,
};

pub const BIDI_DATA = extern struct {
    dwBidiType: u32,
    u: BIDI_DATA._u_e__Union,
    const _u_e__Union = u32; // TODO: generate this nested type!
};

pub const BIDI_REQUEST_DATA = extern struct {
    dwReqNumber: u32,
    pSchema: PWSTR,
    data: BIDI_DATA,
};

pub const BIDI_REQUEST_CONTAINER = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    aData: [1]BIDI_REQUEST_DATA,
};

pub const BIDI_RESPONSE_DATA = extern struct {
    dwResult: u32,
    dwReqNumber: u32,
    pSchema: PWSTR,
    data: BIDI_DATA,
};

pub const BIDI_RESPONSE_CONTAINER = extern struct {
    Version: u32,
    Flags: u32,
    Count: u32,
    aData: [1]BIDI_RESPONSE_DATA,
};

pub const BIDI_TYPE = extern enum(i32) {
    BIDI_NULL = 0,
    BIDI_INT = 1,
    BIDI_FLOAT = 2,
    BIDI_BOOL = 3,
    BIDI_STRING = 4,
    BIDI_TEXT = 5,
    BIDI_ENUM = 6,
    BIDI_BLOB = 7,
};
pub const BIDI_NULL = BIDI_TYPE.BIDI_NULL;
pub const BIDI_INT = BIDI_TYPE.BIDI_INT;
pub const BIDI_FLOAT = BIDI_TYPE.BIDI_FLOAT;
pub const BIDI_BOOL = BIDI_TYPE.BIDI_BOOL;
pub const BIDI_STRING = BIDI_TYPE.BIDI_STRING;
pub const BIDI_TEXT = BIDI_TYPE.BIDI_TEXT;
pub const BIDI_ENUM = BIDI_TYPE.BIDI_ENUM;
pub const BIDI_BLOB = BIDI_TYPE.BIDI_BLOB;

pub const PROVIDOR_INFO_1A = extern struct {
    pName: PSTR,
    pEnvironment: PSTR,
    pDLLName: PSTR,
};

pub const PROVIDOR_INFO_1W = extern struct {
    pName: PWSTR,
    pEnvironment: PWSTR,
    pDLLName: PWSTR,
};

pub const PROVIDOR_INFO_2A = extern struct {
    pOrder: PSTR,
};

pub const PROVIDOR_INFO_2W = extern struct {
    pOrder: PWSTR,
};

pub const PRINTER_OPTION_FLAGS = extern enum(i32) {
    PRINTER_OPTION_NO_CACHE = 1,
    PRINTER_OPTION_CACHE = 2,
    PRINTER_OPTION_CLIENT_CHANGE = 4,
    PRINTER_OPTION_NO_CLIENT_DATA = 8,
};
pub const PRINTER_OPTION_NO_CACHE = PRINTER_OPTION_FLAGS.PRINTER_OPTION_NO_CACHE;
pub const PRINTER_OPTION_CACHE = PRINTER_OPTION_FLAGS.PRINTER_OPTION_CACHE;
pub const PRINTER_OPTION_CLIENT_CHANGE = PRINTER_OPTION_FLAGS.PRINTER_OPTION_CLIENT_CHANGE;
pub const PRINTER_OPTION_NO_CLIENT_DATA = PRINTER_OPTION_FLAGS.PRINTER_OPTION_NO_CLIENT_DATA;

pub const PRINTER_OPTIONSA = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const PRINTER_OPTIONSW = extern struct {
    cbSize: u32,
    dwFlags: u32,
};

pub const PRINTER_CONNECTION_INFO_1A = extern struct {
    dwFlags: u32,
    pszDriverName: PSTR,
};

pub const PRINTER_CONNECTION_INFO_1W = extern struct {
    dwFlags: u32,
    pszDriverName: PWSTR,
};

pub const CORE_PRINTER_DRIVERA = extern struct {
    CoreDriverGUID: Guid,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    szPackageID: [260]i8,
};

pub const CORE_PRINTER_DRIVERW = extern struct {
    CoreDriverGUID: Guid,
    ftDriverDate: FILETIME,
    dwlDriverVersion: u64,
    szPackageID: [260]u16,
};

pub const EPrintPropertyType = extern enum(i32) {
    kPropertyTypeString = 1,
    kPropertyTypeInt32 = 2,
    kPropertyTypeInt64 = 3,
    kPropertyTypeByte = 4,
    kPropertyTypeTime = 5,
    kPropertyTypeDevMode = 6,
    kPropertyTypeSD = 7,
    kPropertyTypeNotificationReply = 8,
    kPropertyTypeNotificationOptions = 9,
    kPropertyTypeBuffer = 10,
};
pub const kPropertyTypeString = EPrintPropertyType.kPropertyTypeString;
pub const kPropertyTypeInt32 = EPrintPropertyType.kPropertyTypeInt32;
pub const kPropertyTypeInt64 = EPrintPropertyType.kPropertyTypeInt64;
pub const kPropertyTypeByte = EPrintPropertyType.kPropertyTypeByte;
pub const kPropertyTypeTime = EPrintPropertyType.kPropertyTypeTime;
pub const kPropertyTypeDevMode = EPrintPropertyType.kPropertyTypeDevMode;
pub const kPropertyTypeSD = EPrintPropertyType.kPropertyTypeSD;
pub const kPropertyTypeNotificationReply = EPrintPropertyType.kPropertyTypeNotificationReply;
pub const kPropertyTypeNotificationOptions = EPrintPropertyType.kPropertyTypeNotificationOptions;
pub const kPropertyTypeBuffer = EPrintPropertyType.kPropertyTypeBuffer;

pub const EPrintXPSJobProgress = extern enum(i32) {
    kAddingDocumentSequence = 0,
    kDocumentSequenceAdded = 1,
    kAddingFixedDocument = 2,
    kFixedDocumentAdded = 3,
    kAddingFixedPage = 4,
    kFixedPageAdded = 5,
    kResourceAdded = 6,
    kFontAdded = 7,
    kImageAdded = 8,
    kXpsDocumentCommitted = 9,
};
pub const kAddingDocumentSequence = EPrintXPSJobProgress.kAddingDocumentSequence;
pub const kDocumentSequenceAdded = EPrintXPSJobProgress.kDocumentSequenceAdded;
pub const kAddingFixedDocument = EPrintXPSJobProgress.kAddingFixedDocument;
pub const kFixedDocumentAdded = EPrintXPSJobProgress.kFixedDocumentAdded;
pub const kAddingFixedPage = EPrintXPSJobProgress.kAddingFixedPage;
pub const kFixedPageAdded = EPrintXPSJobProgress.kFixedPageAdded;
pub const kResourceAdded = EPrintXPSJobProgress.kResourceAdded;
pub const kFontAdded = EPrintXPSJobProgress.kFontAdded;
pub const kImageAdded = EPrintXPSJobProgress.kImageAdded;
pub const kXpsDocumentCommitted = EPrintXPSJobProgress.kXpsDocumentCommitted;

pub const EPrintXPSJobOperation = extern enum(i32) {
    kJobProduction = 1,
    kJobConsumption = 2,
};
pub const kJobProduction = EPrintXPSJobOperation.kJobProduction;
pub const kJobConsumption = EPrintXPSJobOperation.kJobConsumption;

pub const PrintPropertyValue = extern struct {
    ePropertyType: EPrintPropertyType,
    value: PrintPropertyValue._value_e__Union,
    const _value_e__Union = u32; // TODO: generate this nested type!
};

pub const PrintNamedProperty = extern struct {
    propertyName: PWSTR,
    propertyValue: PrintPropertyValue,
};

pub const PrintPropertiesCollection = extern struct {
    numberOfProperties: u32,
    propertiesCollection: *PrintNamedProperty,
};

pub const PRINT_EXECUTION_CONTEXT = extern enum(i32) {
    APPLICATION = 0,
    SPOOLER_SERVICE = 1,
    SPOOLER_ISOLATION_HOST = 2,
    FILTER_PIPELINE = 3,
    WOW64 = 4,
};
pub const PRINT_EXECUTION_CONTEXT_APPLICATION = PRINT_EXECUTION_CONTEXT.APPLICATION;
pub const PRINT_EXECUTION_CONTEXT_SPOOLER_SERVICE = PRINT_EXECUTION_CONTEXT.SPOOLER_SERVICE;
pub const PRINT_EXECUTION_CONTEXT_SPOOLER_ISOLATION_HOST = PRINT_EXECUTION_CONTEXT.SPOOLER_ISOLATION_HOST;
pub const PRINT_EXECUTION_CONTEXT_FILTER_PIPELINE = PRINT_EXECUTION_CONTEXT.FILTER_PIPELINE;
pub const PRINT_EXECUTION_CONTEXT_WOW64 = PRINT_EXECUTION_CONTEXT.WOW64;

pub const PRINT_EXECUTION_DATA = extern struct {
    context: PRINT_EXECUTION_CONTEXT,
    clientAppPID: u32,
};

const IID_IServiceProvider_Value = @import("../zig.zig").Guid.initString("6d5140c1-7436-11ce-8034-00aa006009fa");
pub const IID_IServiceProvider = &IID_IServiceProvider_Value;
pub const IServiceProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryService: fn(
            self: *const IServiceProvider,
            guidService: *const Guid,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IServiceProvider_QueryService(self: *const T, guidService: *const Guid, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IServiceProvider.VTable, self.vtable).QueryService(@ptrCast(*const IServiceProvider, self), guidService, riid, ppvObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MODEMDEVCAPS = extern struct {
    dwActualSize: u32,
    dwRequiredSize: u32,
    dwDevSpecificOffset: u32,
    dwDevSpecificSize: u32,
    dwModemProviderVersion: u32,
    dwModemManufacturerOffset: u32,
    dwModemManufacturerSize: u32,
    dwModemModelOffset: u32,
    dwModemModelSize: u32,
    dwModemVersionOffset: u32,
    dwModemVersionSize: u32,
    dwDialOptions: u32,
    dwCallSetupFailTimer: u32,
    dwInactivityTimeout: u32,
    dwSpeakerVolume: u32,
    dwSpeakerMode: u32,
    dwModemOptions: u32,
    dwMaxDTERate: u32,
    dwMaxDCERate: u32,
    abVariablePortion: [1]u8,
};

pub const MODEMSETTINGS = extern struct {
    dwActualSize: u32,
    dwRequiredSize: u32,
    dwDevSpecificOffset: u32,
    dwDevSpecificSize: u32,
    dwCallSetupFailTimer: u32,
    dwInactivityTimeout: u32,
    dwSpeakerVolume: u32,
    dwSpeakerMode: u32,
    dwPreferredModemOptions: u32,
    dwNegotiatedModemOptions: u32,
    dwNegotiatedDCERate: u32,
    abVariablePortion: [1]u8,
};

pub const DISPATCHERQUEUE_THREAD_APARTMENTTYPE = extern enum(i32) {
    DQTAT_COM_NONE = 0,
    DQTAT_COM_ASTA = 1,
    DQTAT_COM_STA = 2,
};
pub const DQTAT_COM_NONE = DISPATCHERQUEUE_THREAD_APARTMENTTYPE.DQTAT_COM_NONE;
pub const DQTAT_COM_ASTA = DISPATCHERQUEUE_THREAD_APARTMENTTYPE.DQTAT_COM_ASTA;
pub const DQTAT_COM_STA = DISPATCHERQUEUE_THREAD_APARTMENTTYPE.DQTAT_COM_STA;

pub const DISPATCHERQUEUE_THREAD_TYPE = extern enum(i32) {
    DQTYPE_THREAD_DEDICATED = 1,
    DQTYPE_THREAD_CURRENT = 2,
};
pub const DQTYPE_THREAD_DEDICATED = DISPATCHERQUEUE_THREAD_TYPE.DQTYPE_THREAD_DEDICATED;
pub const DQTYPE_THREAD_CURRENT = DISPATCHERQUEUE_THREAD_TYPE.DQTYPE_THREAD_CURRENT;

pub const DispatcherQueueOptions = extern struct {
    dwSize: u32,
    threadType: DISPATCHERQUEUE_THREAD_TYPE,
    apartmentType: DISPATCHERQUEUE_THREAD_APARTMENTTYPE,
};

pub const VDS_STORAGE_IDENTIFIER_CODE_SET = extern enum(i32) {
    VDSStorageIdCodeSetReserved = 0,
    VDSStorageIdCodeSetBinary = 1,
    VDSStorageIdCodeSetAscii = 2,
    VDSStorageIdCodeSetUtf8 = 3,
};
pub const VDSStorageIdCodeSetReserved = VDS_STORAGE_IDENTIFIER_CODE_SET.VDSStorageIdCodeSetReserved;
pub const VDSStorageIdCodeSetBinary = VDS_STORAGE_IDENTIFIER_CODE_SET.VDSStorageIdCodeSetBinary;
pub const VDSStorageIdCodeSetAscii = VDS_STORAGE_IDENTIFIER_CODE_SET.VDSStorageIdCodeSetAscii;
pub const VDSStorageIdCodeSetUtf8 = VDS_STORAGE_IDENTIFIER_CODE_SET.VDSStorageIdCodeSetUtf8;

pub const VDS_STORAGE_IDENTIFIER_TYPE = extern enum(i32) {
    VDSStorageIdTypeVendorSpecific = 0,
    VDSStorageIdTypeVendorId = 1,
    VDSStorageIdTypeEUI64 = 2,
    VDSStorageIdTypeFCPHName = 3,
    VDSStorageIdTypePortRelative = 4,
    VDSStorageIdTypeTargetPortGroup = 5,
    VDSStorageIdTypeLogicalUnitGroup = 6,
    VDSStorageIdTypeMD5LogicalUnitIdentifier = 7,
    VDSStorageIdTypeScsiNameString = 8,
};
pub const VDSStorageIdTypeVendorSpecific = VDS_STORAGE_IDENTIFIER_TYPE.VDSStorageIdTypeVendorSpecific;
pub const VDSStorageIdTypeVendorId = VDS_STORAGE_IDENTIFIER_TYPE.VDSStorageIdTypeVendorId;
pub const VDSStorageIdTypeEUI64 = VDS_STORAGE_IDENTIFIER_TYPE.VDSStorageIdTypeEUI64;
pub const VDSStorageIdTypeFCPHName = VDS_STORAGE_IDENTIFIER_TYPE.VDSStorageIdTypeFCPHName;
pub const VDSStorageIdTypePortRelative = VDS_STORAGE_IDENTIFIER_TYPE.VDSStorageIdTypePortRelative;
pub const VDSStorageIdTypeTargetPortGroup = VDS_STORAGE_IDENTIFIER_TYPE.VDSStorageIdTypeTargetPortGroup;
pub const VDSStorageIdTypeLogicalUnitGroup = VDS_STORAGE_IDENTIFIER_TYPE.VDSStorageIdTypeLogicalUnitGroup;
pub const VDSStorageIdTypeMD5LogicalUnitIdentifier = VDS_STORAGE_IDENTIFIER_TYPE.VDSStorageIdTypeMD5LogicalUnitIdentifier;
pub const VDSStorageIdTypeScsiNameString = VDS_STORAGE_IDENTIFIER_TYPE.VDSStorageIdTypeScsiNameString;

pub const VDS_STORAGE_BUS_TYPE = extern enum(i32) {
    VDSBusTypeUnknown = 0,
    VDSBusTypeScsi = 1,
    VDSBusTypeAtapi = 2,
    VDSBusTypeAta = 3,
    VDSBusType1394 = 4,
    VDSBusTypeSsa = 5,
    VDSBusTypeFibre = 6,
    VDSBusTypeUsb = 7,
    VDSBusTypeRAID = 8,
    VDSBusTypeiScsi = 9,
    VDSBusTypeSas = 10,
    VDSBusTypeSata = 11,
    VDSBusTypeSd = 12,
    VDSBusTypeMmc = 13,
    VDSBusTypeMax = 14,
    VDSBusTypeVirtual = 14,
    VDSBusTypeFileBackedVirtual = 15,
    VDSBusTypeSpaces = 16,
    VDSBusTypeNVMe = 17,
    VDSBusTypeScm = 18,
    VDSBusTypeUfs = 19,
    VDSBusTypeMaxReserved = 127,
};
pub const VDSBusTypeUnknown = VDS_STORAGE_BUS_TYPE.VDSBusTypeUnknown;
pub const VDSBusTypeScsi = VDS_STORAGE_BUS_TYPE.VDSBusTypeScsi;
pub const VDSBusTypeAtapi = VDS_STORAGE_BUS_TYPE.VDSBusTypeAtapi;
pub const VDSBusTypeAta = VDS_STORAGE_BUS_TYPE.VDSBusTypeAta;
pub const VDSBusType1394 = VDS_STORAGE_BUS_TYPE.VDSBusType1394;
pub const VDSBusTypeSsa = VDS_STORAGE_BUS_TYPE.VDSBusTypeSsa;
pub const VDSBusTypeFibre = VDS_STORAGE_BUS_TYPE.VDSBusTypeFibre;
pub const VDSBusTypeUsb = VDS_STORAGE_BUS_TYPE.VDSBusTypeUsb;
pub const VDSBusTypeRAID = VDS_STORAGE_BUS_TYPE.VDSBusTypeRAID;
pub const VDSBusTypeiScsi = VDS_STORAGE_BUS_TYPE.VDSBusTypeiScsi;
pub const VDSBusTypeSas = VDS_STORAGE_BUS_TYPE.VDSBusTypeSas;
pub const VDSBusTypeSata = VDS_STORAGE_BUS_TYPE.VDSBusTypeSata;
pub const VDSBusTypeSd = VDS_STORAGE_BUS_TYPE.VDSBusTypeSd;
pub const VDSBusTypeMmc = VDS_STORAGE_BUS_TYPE.VDSBusTypeMmc;
pub const VDSBusTypeMax = VDS_STORAGE_BUS_TYPE.VDSBusTypeMax;
pub const VDSBusTypeVirtual = VDS_STORAGE_BUS_TYPE.VDSBusTypeVirtual;
pub const VDSBusTypeFileBackedVirtual = VDS_STORAGE_BUS_TYPE.VDSBusTypeFileBackedVirtual;
pub const VDSBusTypeSpaces = VDS_STORAGE_BUS_TYPE.VDSBusTypeSpaces;
pub const VDSBusTypeNVMe = VDS_STORAGE_BUS_TYPE.VDSBusTypeNVMe;
pub const VDSBusTypeScm = VDS_STORAGE_BUS_TYPE.VDSBusTypeScm;
pub const VDSBusTypeUfs = VDS_STORAGE_BUS_TYPE.VDSBusTypeUfs;
pub const VDSBusTypeMaxReserved = VDS_STORAGE_BUS_TYPE.VDSBusTypeMaxReserved;

pub const VDS_STORAGE_IDENTIFIER = extern struct {
    m_CodeSet: VDS_STORAGE_IDENTIFIER_CODE_SET,
    m_Type: VDS_STORAGE_IDENTIFIER_TYPE,
    m_cbIdentifier: u32,
    m_rgbIdentifier: *u8,
};

pub const VDS_STORAGE_DEVICE_ID_DESCRIPTOR = extern struct {
    m_version: u32,
    m_cIdentifiers: u32,
    m_rgIdentifiers: *VDS_STORAGE_IDENTIFIER,
};

pub const VDS_INTERCONNECT_ADDRESS_TYPE = extern enum(i32) {
    VDS_IA_UNKNOWN = 0,
    VDS_IA_FCFS = 1,
    VDS_IA_FCPH = 2,
    VDS_IA_FCPH3 = 3,
    VDS_IA_MAC = 4,
    VDS_IA_SCSI = 5,
};
pub const VDS_IA_UNKNOWN = VDS_INTERCONNECT_ADDRESS_TYPE.VDS_IA_UNKNOWN;
pub const VDS_IA_FCFS = VDS_INTERCONNECT_ADDRESS_TYPE.VDS_IA_FCFS;
pub const VDS_IA_FCPH = VDS_INTERCONNECT_ADDRESS_TYPE.VDS_IA_FCPH;
pub const VDS_IA_FCPH3 = VDS_INTERCONNECT_ADDRESS_TYPE.VDS_IA_FCPH3;
pub const VDS_IA_MAC = VDS_INTERCONNECT_ADDRESS_TYPE.VDS_IA_MAC;
pub const VDS_IA_SCSI = VDS_INTERCONNECT_ADDRESS_TYPE.VDS_IA_SCSI;

pub const VDS_INTERCONNECT = extern struct {
    m_addressType: VDS_INTERCONNECT_ADDRESS_TYPE,
    m_cbPort: u32,
    m_pbPort: *u8,
    m_cbAddress: u32,
    m_pbAddress: *u8,
};

pub const VDS_LUN_INFORMATION = extern struct {
    m_version: u32,
    m_DeviceType: u8,
    m_DeviceTypeModifier: u8,
    m_bCommandQueueing: BOOL,
    m_BusType: VDS_STORAGE_BUS_TYPE,
    m_szVendorId: *u8,
    m_szProductId: *u8,
    m_szProductRevision: *u8,
    m_szSerialNumber: *u8,
    m_diskSignature: Guid,
    m_deviceIdDescriptor: VDS_STORAGE_DEVICE_ID_DESCRIPTOR,
    m_cInterconnects: u32,
    m_rgInterconnects: *VDS_INTERCONNECT,
};

pub const VDS_OBJECT_TYPE = extern enum(i32) {
    VDS_OT_UNKNOWN = 0,
    VDS_OT_PROVIDER = 1,
    VDS_OT_PACK = 10,
    VDS_OT_VOLUME = 11,
    VDS_OT_VOLUME_PLEX = 12,
    VDS_OT_DISK = 13,
    VDS_OT_SUB_SYSTEM = 30,
    VDS_OT_CONTROLLER = 31,
    VDS_OT_DRIVE = 32,
    VDS_OT_LUN = 33,
    VDS_OT_LUN_PLEX = 34,
    VDS_OT_PORT = 35,
    VDS_OT_PORTAL = 36,
    VDS_OT_TARGET = 37,
    VDS_OT_PORTAL_GROUP = 38,
    VDS_OT_STORAGE_POOL = 39,
    VDS_OT_HBAPORT = 90,
    VDS_OT_INIT_ADAPTER = 91,
    VDS_OT_INIT_PORTAL = 92,
    VDS_OT_ASYNC = 100,
    VDS_OT_ENUM = 101,
    VDS_OT_VDISK = 200,
    VDS_OT_OPEN_VDISK = 201,
};
pub const VDS_OT_UNKNOWN = VDS_OBJECT_TYPE.VDS_OT_UNKNOWN;
pub const VDS_OT_PROVIDER = VDS_OBJECT_TYPE.VDS_OT_PROVIDER;
pub const VDS_OT_PACK = VDS_OBJECT_TYPE.VDS_OT_PACK;
pub const VDS_OT_VOLUME = VDS_OBJECT_TYPE.VDS_OT_VOLUME;
pub const VDS_OT_VOLUME_PLEX = VDS_OBJECT_TYPE.VDS_OT_VOLUME_PLEX;
pub const VDS_OT_DISK = VDS_OBJECT_TYPE.VDS_OT_DISK;
pub const VDS_OT_SUB_SYSTEM = VDS_OBJECT_TYPE.VDS_OT_SUB_SYSTEM;
pub const VDS_OT_CONTROLLER = VDS_OBJECT_TYPE.VDS_OT_CONTROLLER;
pub const VDS_OT_DRIVE = VDS_OBJECT_TYPE.VDS_OT_DRIVE;
pub const VDS_OT_LUN = VDS_OBJECT_TYPE.VDS_OT_LUN;
pub const VDS_OT_LUN_PLEX = VDS_OBJECT_TYPE.VDS_OT_LUN_PLEX;
pub const VDS_OT_PORT = VDS_OBJECT_TYPE.VDS_OT_PORT;
pub const VDS_OT_PORTAL = VDS_OBJECT_TYPE.VDS_OT_PORTAL;
pub const VDS_OT_TARGET = VDS_OBJECT_TYPE.VDS_OT_TARGET;
pub const VDS_OT_PORTAL_GROUP = VDS_OBJECT_TYPE.VDS_OT_PORTAL_GROUP;
pub const VDS_OT_STORAGE_POOL = VDS_OBJECT_TYPE.VDS_OT_STORAGE_POOL;
pub const VDS_OT_HBAPORT = VDS_OBJECT_TYPE.VDS_OT_HBAPORT;
pub const VDS_OT_INIT_ADAPTER = VDS_OBJECT_TYPE.VDS_OT_INIT_ADAPTER;
pub const VDS_OT_INIT_PORTAL = VDS_OBJECT_TYPE.VDS_OT_INIT_PORTAL;
pub const VDS_OT_ASYNC = VDS_OBJECT_TYPE.VDS_OT_ASYNC;
pub const VDS_OT_ENUM = VDS_OBJECT_TYPE.VDS_OT_ENUM;
pub const VDS_OT_VDISK = VDS_OBJECT_TYPE.VDS_OT_VDISK;
pub const VDS_OT_OPEN_VDISK = VDS_OBJECT_TYPE.VDS_OT_OPEN_VDISK;

pub const VDS_PROVIDER_TYPE = extern enum(i32) {
    VDS_PT_UNKNOWN = 0,
    VDS_PT_SOFTWARE = 1,
    VDS_PT_HARDWARE = 2,
    VDS_PT_VIRTUALDISK = 3,
    VDS_PT_MAX = 4,
};
pub const VDS_PT_UNKNOWN = VDS_PROVIDER_TYPE.VDS_PT_UNKNOWN;
pub const VDS_PT_SOFTWARE = VDS_PROVIDER_TYPE.VDS_PT_SOFTWARE;
pub const VDS_PT_HARDWARE = VDS_PROVIDER_TYPE.VDS_PT_HARDWARE;
pub const VDS_PT_VIRTUALDISK = VDS_PROVIDER_TYPE.VDS_PT_VIRTUALDISK;
pub const VDS_PT_MAX = VDS_PROVIDER_TYPE.VDS_PT_MAX;

pub const VDS_PROVIDER_FLAG = extern enum(i32) {
    VDS_PF_DYNAMIC = 1,
    VDS_PF_INTERNAL_HARDWARE_PROVIDER = 2,
    VDS_PF_ONE_DISK_ONLY_PER_PACK = 4,
    VDS_PF_ONE_PACK_ONLINE_ONLY = 8,
    VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS = 16,
    VDS_PF_SUPPORT_DYNAMIC = -2147483648,
    VDS_PF_SUPPORT_FAULT_TOLERANT = 1073741824,
    VDS_PF_SUPPORT_DYNAMIC_1394 = 536870912,
    VDS_PF_SUPPORT_MIRROR = 32,
    VDS_PF_SUPPORT_RAID5 = 64,
};
pub const VDS_PF_DYNAMIC = VDS_PROVIDER_FLAG.VDS_PF_DYNAMIC;
pub const VDS_PF_INTERNAL_HARDWARE_PROVIDER = VDS_PROVIDER_FLAG.VDS_PF_INTERNAL_HARDWARE_PROVIDER;
pub const VDS_PF_ONE_DISK_ONLY_PER_PACK = VDS_PROVIDER_FLAG.VDS_PF_ONE_DISK_ONLY_PER_PACK;
pub const VDS_PF_ONE_PACK_ONLINE_ONLY = VDS_PROVIDER_FLAG.VDS_PF_ONE_PACK_ONLINE_ONLY;
pub const VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS = VDS_PROVIDER_FLAG.VDS_PF_VOLUME_SPACE_MUST_BE_CONTIGUOUS;
pub const VDS_PF_SUPPORT_DYNAMIC = VDS_PROVIDER_FLAG.VDS_PF_SUPPORT_DYNAMIC;
pub const VDS_PF_SUPPORT_FAULT_TOLERANT = VDS_PROVIDER_FLAG.VDS_PF_SUPPORT_FAULT_TOLERANT;
pub const VDS_PF_SUPPORT_DYNAMIC_1394 = VDS_PROVIDER_FLAG.VDS_PF_SUPPORT_DYNAMIC_1394;
pub const VDS_PF_SUPPORT_MIRROR = VDS_PROVIDER_FLAG.VDS_PF_SUPPORT_MIRROR;
pub const VDS_PF_SUPPORT_RAID5 = VDS_PROVIDER_FLAG.VDS_PF_SUPPORT_RAID5;

pub const VDS_RECOVER_ACTION = extern enum(i32) {
    VDS_RA_UNKNOWN = 0,
    VDS_RA_REFRESH = 1,
    VDS_RA_RESTART = 2,
};
pub const VDS_RA_UNKNOWN = VDS_RECOVER_ACTION.VDS_RA_UNKNOWN;
pub const VDS_RA_REFRESH = VDS_RECOVER_ACTION.VDS_RA_REFRESH;
pub const VDS_RA_RESTART = VDS_RECOVER_ACTION.VDS_RA_RESTART;

pub const VDS_NOTIFICATION_TARGET_TYPE = extern enum(i32) {
    VDS_NTT_UNKNOWN = 0,
    VDS_NTT_PACK = 10,
    VDS_NTT_VOLUME = 11,
    VDS_NTT_DISK = 13,
    VDS_NTT_PARTITION = 60,
    VDS_NTT_DRIVE_LETTER = 61,
    VDS_NTT_FILE_SYSTEM = 62,
    VDS_NTT_MOUNT_POINT = 63,
    VDS_NTT_SUB_SYSTEM = 30,
    VDS_NTT_CONTROLLER = 31,
    VDS_NTT_DRIVE = 32,
    VDS_NTT_LUN = 33,
    VDS_NTT_PORT = 35,
    VDS_NTT_PORTAL = 36,
    VDS_NTT_TARGET = 37,
    VDS_NTT_PORTAL_GROUP = 38,
    VDS_NTT_SERVICE = 200,
};
pub const VDS_NTT_UNKNOWN = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_UNKNOWN;
pub const VDS_NTT_PACK = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_PACK;
pub const VDS_NTT_VOLUME = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_VOLUME;
pub const VDS_NTT_DISK = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_DISK;
pub const VDS_NTT_PARTITION = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_PARTITION;
pub const VDS_NTT_DRIVE_LETTER = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_DRIVE_LETTER;
pub const VDS_NTT_FILE_SYSTEM = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_FILE_SYSTEM;
pub const VDS_NTT_MOUNT_POINT = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_MOUNT_POINT;
pub const VDS_NTT_SUB_SYSTEM = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_SUB_SYSTEM;
pub const VDS_NTT_CONTROLLER = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_CONTROLLER;
pub const VDS_NTT_DRIVE = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_DRIVE;
pub const VDS_NTT_LUN = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_LUN;
pub const VDS_NTT_PORT = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_PORT;
pub const VDS_NTT_PORTAL = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_PORTAL;
pub const VDS_NTT_TARGET = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_TARGET;
pub const VDS_NTT_PORTAL_GROUP = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_PORTAL_GROUP;
pub const VDS_NTT_SERVICE = VDS_NOTIFICATION_TARGET_TYPE.VDS_NTT_SERVICE;

pub const VDS_PACK_NOTIFICATION = extern struct {
    ulEvent: u32,
    packId: Guid,
};

pub const VDS_DISK_NOTIFICATION = extern struct {
    ulEvent: u32,
    diskId: Guid,
};

pub const VDS_VOLUME_NOTIFICATION = extern struct {
    ulEvent: u32,
    volumeId: Guid,
    plexId: Guid,
    ulPercentCompleted: u32,
};

pub const VDS_PARTITION_NOTIFICATION = extern struct {
    ulEvent: u32,
    diskId: Guid,
    ullOffset: u64,
};

pub const VDS_SERVICE_NOTIFICATION = extern struct {
    ulEvent: u32,
    action: VDS_RECOVER_ACTION,
};

pub const VDS_DRIVE_LETTER_NOTIFICATION = extern struct {
    ulEvent: u32,
    wcLetter: u16,
    volumeId: Guid,
};

pub const VDS_FILE_SYSTEM_NOTIFICATION = extern struct {
    ulEvent: u32,
    volumeId: Guid,
    dwPercentCompleted: u32,
};

pub const VDS_MOUNT_POINT_NOTIFICATION = extern struct {
    ulEvent: u32,
    volumeId: Guid,
};

pub const VDS_SUB_SYSTEM_NOTIFICATION = extern struct {
    ulEvent: u32,
    subSystemId: Guid,
};

pub const VDS_CONTROLLER_NOTIFICATION = extern struct {
    ulEvent: u32,
    controllerId: Guid,
};

pub const VDS_DRIVE_NOTIFICATION = extern struct {
    ulEvent: u32,
    driveId: Guid,
};

pub const VDS_LUN_NOTIFICATION = extern struct {
    ulEvent: u32,
    LunId: Guid,
};

pub const VDS_PORT_NOTIFICATION = extern struct {
    ulEvent: u32,
    portId: Guid,
};

pub const VDS_PORTAL_NOTIFICATION = extern struct {
    ulEvent: u32,
    portalId: Guid,
};

pub const VDS_TARGET_NOTIFICATION = extern struct {
    ulEvent: u32,
    targetId: Guid,
};

pub const VDS_PORTAL_GROUP_NOTIFICATION = extern struct {
    ulEvent: u32,
    portalGroupId: Guid,
};

pub const VDS_NOTIFICATION = extern struct {
    objectType: VDS_NOTIFICATION_TARGET_TYPE,
    Anonymous: VDS_NOTIFICATION._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const VDS_ASYNC_OUTPUT_TYPE = extern enum(i32) {
    VDS_ASYNCOUT_UNKNOWN = 0,
    VDS_ASYNCOUT_CREATEVOLUME = 1,
    VDS_ASYNCOUT_EXTENDVOLUME = 2,
    VDS_ASYNCOUT_SHRINKVOLUME = 3,
    VDS_ASYNCOUT_ADDVOLUMEPLEX = 4,
    VDS_ASYNCOUT_BREAKVOLUMEPLEX = 5,
    VDS_ASYNCOUT_REMOVEVOLUMEPLEX = 6,
    VDS_ASYNCOUT_REPAIRVOLUMEPLEX = 7,
    VDS_ASYNCOUT_RECOVERPACK = 8,
    VDS_ASYNCOUT_REPLACEDISK = 9,
    VDS_ASYNCOUT_CREATEPARTITION = 10,
    VDS_ASYNCOUT_CLEAN = 11,
    VDS_ASYNCOUT_CREATELUN = 50,
    VDS_ASYNCOUT_ADDLUNPLEX = 52,
    VDS_ASYNCOUT_REMOVELUNPLEX = 53,
    VDS_ASYNCOUT_EXTENDLUN = 54,
    VDS_ASYNCOUT_SHRINKLUN = 55,
    VDS_ASYNCOUT_RECOVERLUN = 56,
    VDS_ASYNCOUT_LOGINTOTARGET = 60,
    VDS_ASYNCOUT_LOGOUTFROMTARGET = 61,
    VDS_ASYNCOUT_CREATETARGET = 62,
    VDS_ASYNCOUT_CREATEPORTALGROUP = 63,
    VDS_ASYNCOUT_DELETETARGET = 64,
    VDS_ASYNCOUT_ADDPORTAL = 65,
    VDS_ASYNCOUT_REMOVEPORTAL = 66,
    VDS_ASYNCOUT_DELETEPORTALGROUP = 67,
    VDS_ASYNCOUT_FORMAT = 101,
    VDS_ASYNCOUT_CREATE_VDISK = 200,
    VDS_ASYNCOUT_ATTACH_VDISK = 201,
    VDS_ASYNCOUT_COMPACT_VDISK = 202,
    VDS_ASYNCOUT_MERGE_VDISK = 203,
    VDS_ASYNCOUT_EXPAND_VDISK = 204,
};
pub const VDS_ASYNCOUT_UNKNOWN = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_UNKNOWN;
pub const VDS_ASYNCOUT_CREATEVOLUME = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_CREATEVOLUME;
pub const VDS_ASYNCOUT_EXTENDVOLUME = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_EXTENDVOLUME;
pub const VDS_ASYNCOUT_SHRINKVOLUME = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_SHRINKVOLUME;
pub const VDS_ASYNCOUT_ADDVOLUMEPLEX = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_ADDVOLUMEPLEX;
pub const VDS_ASYNCOUT_BREAKVOLUMEPLEX = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_BREAKVOLUMEPLEX;
pub const VDS_ASYNCOUT_REMOVEVOLUMEPLEX = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_REMOVEVOLUMEPLEX;
pub const VDS_ASYNCOUT_REPAIRVOLUMEPLEX = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_REPAIRVOLUMEPLEX;
pub const VDS_ASYNCOUT_RECOVERPACK = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_RECOVERPACK;
pub const VDS_ASYNCOUT_REPLACEDISK = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_REPLACEDISK;
pub const VDS_ASYNCOUT_CREATEPARTITION = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_CREATEPARTITION;
pub const VDS_ASYNCOUT_CLEAN = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_CLEAN;
pub const VDS_ASYNCOUT_CREATELUN = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_CREATELUN;
pub const VDS_ASYNCOUT_ADDLUNPLEX = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_ADDLUNPLEX;
pub const VDS_ASYNCOUT_REMOVELUNPLEX = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_REMOVELUNPLEX;
pub const VDS_ASYNCOUT_EXTENDLUN = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_EXTENDLUN;
pub const VDS_ASYNCOUT_SHRINKLUN = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_SHRINKLUN;
pub const VDS_ASYNCOUT_RECOVERLUN = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_RECOVERLUN;
pub const VDS_ASYNCOUT_LOGINTOTARGET = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_LOGINTOTARGET;
pub const VDS_ASYNCOUT_LOGOUTFROMTARGET = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_LOGOUTFROMTARGET;
pub const VDS_ASYNCOUT_CREATETARGET = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_CREATETARGET;
pub const VDS_ASYNCOUT_CREATEPORTALGROUP = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_CREATEPORTALGROUP;
pub const VDS_ASYNCOUT_DELETETARGET = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_DELETETARGET;
pub const VDS_ASYNCOUT_ADDPORTAL = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_ADDPORTAL;
pub const VDS_ASYNCOUT_REMOVEPORTAL = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_REMOVEPORTAL;
pub const VDS_ASYNCOUT_DELETEPORTALGROUP = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_DELETEPORTALGROUP;
pub const VDS_ASYNCOUT_FORMAT = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_FORMAT;
pub const VDS_ASYNCOUT_CREATE_VDISK = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_CREATE_VDISK;
pub const VDS_ASYNCOUT_ATTACH_VDISK = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_ATTACH_VDISK;
pub const VDS_ASYNCOUT_COMPACT_VDISK = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_COMPACT_VDISK;
pub const VDS_ASYNCOUT_MERGE_VDISK = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_MERGE_VDISK;
pub const VDS_ASYNCOUT_EXPAND_VDISK = VDS_ASYNC_OUTPUT_TYPE.VDS_ASYNCOUT_EXPAND_VDISK;

pub const VDS_ASYNC_OUTPUT = extern struct {
    type: VDS_ASYNC_OUTPUT_TYPE,
    Anonymous: VDS_ASYNC_OUTPUT._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const VDS_IPADDRESS_TYPE = extern enum(i32) {
    VDS_IPT_TEXT = 0,
    VDS_IPT_IPV4 = 1,
    VDS_IPT_IPV6 = 2,
    VDS_IPT_EMPTY = 3,
};
pub const VDS_IPT_TEXT = VDS_IPADDRESS_TYPE.VDS_IPT_TEXT;
pub const VDS_IPT_IPV4 = VDS_IPADDRESS_TYPE.VDS_IPT_IPV4;
pub const VDS_IPT_IPV6 = VDS_IPADDRESS_TYPE.VDS_IPT_IPV6;
pub const VDS_IPT_EMPTY = VDS_IPADDRESS_TYPE.VDS_IPT_EMPTY;

pub const VDS_HEALTH = extern enum(i32) {
    VDS_H_UNKNOWN = 0,
    VDS_H_HEALTHY = 1,
    VDS_H_REBUILDING = 2,
    VDS_H_STALE = 3,
    VDS_H_FAILING = 4,
    VDS_H_FAILING_REDUNDANCY = 5,
    VDS_H_FAILED_REDUNDANCY = 6,
    VDS_H_FAILED_REDUNDANCY_FAILING = 7,
    VDS_H_FAILED = 8,
    VDS_H_REPLACED = 9,
    VDS_H_PENDING_FAILURE = 10,
    VDS_H_DEGRADED = 11,
};
pub const VDS_H_UNKNOWN = VDS_HEALTH.VDS_H_UNKNOWN;
pub const VDS_H_HEALTHY = VDS_HEALTH.VDS_H_HEALTHY;
pub const VDS_H_REBUILDING = VDS_HEALTH.VDS_H_REBUILDING;
pub const VDS_H_STALE = VDS_HEALTH.VDS_H_STALE;
pub const VDS_H_FAILING = VDS_HEALTH.VDS_H_FAILING;
pub const VDS_H_FAILING_REDUNDANCY = VDS_HEALTH.VDS_H_FAILING_REDUNDANCY;
pub const VDS_H_FAILED_REDUNDANCY = VDS_HEALTH.VDS_H_FAILED_REDUNDANCY;
pub const VDS_H_FAILED_REDUNDANCY_FAILING = VDS_HEALTH.VDS_H_FAILED_REDUNDANCY_FAILING;
pub const VDS_H_FAILED = VDS_HEALTH.VDS_H_FAILED;
pub const VDS_H_REPLACED = VDS_HEALTH.VDS_H_REPLACED;
pub const VDS_H_PENDING_FAILURE = VDS_HEALTH.VDS_H_PENDING_FAILURE;
pub const VDS_H_DEGRADED = VDS_HEALTH.VDS_H_DEGRADED;

pub const VDS_TRANSITION_STATE = extern enum(i32) {
    VDS_TS_UNKNOWN = 0,
    VDS_TS_STABLE = 1,
    VDS_TS_EXTENDING = 2,
    VDS_TS_SHRINKING = 3,
    VDS_TS_RECONFIGING = 4,
    VDS_TS_RESTRIPING = 5,
};
pub const VDS_TS_UNKNOWN = VDS_TRANSITION_STATE.VDS_TS_UNKNOWN;
pub const VDS_TS_STABLE = VDS_TRANSITION_STATE.VDS_TS_STABLE;
pub const VDS_TS_EXTENDING = VDS_TRANSITION_STATE.VDS_TS_EXTENDING;
pub const VDS_TS_SHRINKING = VDS_TRANSITION_STATE.VDS_TS_SHRINKING;
pub const VDS_TS_RECONFIGING = VDS_TRANSITION_STATE.VDS_TS_RECONFIGING;
pub const VDS_TS_RESTRIPING = VDS_TRANSITION_STATE.VDS_TS_RESTRIPING;

pub const VDS_FILE_SYSTEM_TYPE = extern enum(i32) {
    VDS_FST_UNKNOWN = 0,
    VDS_FST_RAW = 1,
    VDS_FST_FAT = 2,
    VDS_FST_FAT32 = 3,
    VDS_FST_NTFS = 4,
    VDS_FST_CDFS = 5,
    VDS_FST_UDF = 6,
    VDS_FST_EXFAT = 7,
    VDS_FST_CSVFS = 8,
    VDS_FST_REFS = 9,
};
pub const VDS_FST_UNKNOWN = VDS_FILE_SYSTEM_TYPE.VDS_FST_UNKNOWN;
pub const VDS_FST_RAW = VDS_FILE_SYSTEM_TYPE.VDS_FST_RAW;
pub const VDS_FST_FAT = VDS_FILE_SYSTEM_TYPE.VDS_FST_FAT;
pub const VDS_FST_FAT32 = VDS_FILE_SYSTEM_TYPE.VDS_FST_FAT32;
pub const VDS_FST_NTFS = VDS_FILE_SYSTEM_TYPE.VDS_FST_NTFS;
pub const VDS_FST_CDFS = VDS_FILE_SYSTEM_TYPE.VDS_FST_CDFS;
pub const VDS_FST_UDF = VDS_FILE_SYSTEM_TYPE.VDS_FST_UDF;
pub const VDS_FST_EXFAT = VDS_FILE_SYSTEM_TYPE.VDS_FST_EXFAT;
pub const VDS_FST_CSVFS = VDS_FILE_SYSTEM_TYPE.VDS_FST_CSVFS;
pub const VDS_FST_REFS = VDS_FILE_SYSTEM_TYPE.VDS_FST_REFS;

pub const VDS_HBAPORT_TYPE = extern enum(i32) {
    VDS_HPT_UNKNOWN = 1,
    VDS_HPT_OTHER = 2,
    VDS_HPT_NOTPRESENT = 3,
    VDS_HPT_NPORT = 5,
    VDS_HPT_NLPORT = 6,
    VDS_HPT_FLPORT = 7,
    VDS_HPT_FPORT = 8,
    VDS_HPT_EPORT = 9,
    VDS_HPT_GPORT = 10,
    VDS_HPT_LPORT = 20,
    VDS_HPT_PTP = 21,
};
pub const VDS_HPT_UNKNOWN = VDS_HBAPORT_TYPE.VDS_HPT_UNKNOWN;
pub const VDS_HPT_OTHER = VDS_HBAPORT_TYPE.VDS_HPT_OTHER;
pub const VDS_HPT_NOTPRESENT = VDS_HBAPORT_TYPE.VDS_HPT_NOTPRESENT;
pub const VDS_HPT_NPORT = VDS_HBAPORT_TYPE.VDS_HPT_NPORT;
pub const VDS_HPT_NLPORT = VDS_HBAPORT_TYPE.VDS_HPT_NLPORT;
pub const VDS_HPT_FLPORT = VDS_HBAPORT_TYPE.VDS_HPT_FLPORT;
pub const VDS_HPT_FPORT = VDS_HBAPORT_TYPE.VDS_HPT_FPORT;
pub const VDS_HPT_EPORT = VDS_HBAPORT_TYPE.VDS_HPT_EPORT;
pub const VDS_HPT_GPORT = VDS_HBAPORT_TYPE.VDS_HPT_GPORT;
pub const VDS_HPT_LPORT = VDS_HBAPORT_TYPE.VDS_HPT_LPORT;
pub const VDS_HPT_PTP = VDS_HBAPORT_TYPE.VDS_HPT_PTP;

pub const VDS_HBAPORT_STATUS = extern enum(i32) {
    VDS_HPS_UNKNOWN = 1,
    VDS_HPS_ONLINE = 2,
    VDS_HPS_OFFLINE = 3,
    VDS_HPS_BYPASSED = 4,
    VDS_HPS_DIAGNOSTICS = 5,
    VDS_HPS_LINKDOWN = 6,
    VDS_HPS_ERROR = 7,
    VDS_HPS_LOOPBACK = 8,
};
pub const VDS_HPS_UNKNOWN = VDS_HBAPORT_STATUS.VDS_HPS_UNKNOWN;
pub const VDS_HPS_ONLINE = VDS_HBAPORT_STATUS.VDS_HPS_ONLINE;
pub const VDS_HPS_OFFLINE = VDS_HBAPORT_STATUS.VDS_HPS_OFFLINE;
pub const VDS_HPS_BYPASSED = VDS_HBAPORT_STATUS.VDS_HPS_BYPASSED;
pub const VDS_HPS_DIAGNOSTICS = VDS_HBAPORT_STATUS.VDS_HPS_DIAGNOSTICS;
pub const VDS_HPS_LINKDOWN = VDS_HBAPORT_STATUS.VDS_HPS_LINKDOWN;
pub const VDS_HPS_ERROR = VDS_HBAPORT_STATUS.VDS_HPS_ERROR;
pub const VDS_HPS_LOOPBACK = VDS_HBAPORT_STATUS.VDS_HPS_LOOPBACK;

pub const VDS_HBAPORT_SPEED_FLAG = extern enum(i32) {
    VDS_HSF_UNKNOWN = 0,
    VDS_HSF_1GBIT = 1,
    VDS_HSF_2GBIT = 2,
    VDS_HSF_10GBIT = 4,
    VDS_HSF_4GBIT = 8,
    VDS_HSF_NOT_NEGOTIATED = 32768,
};
pub const VDS_HSF_UNKNOWN = VDS_HBAPORT_SPEED_FLAG.VDS_HSF_UNKNOWN;
pub const VDS_HSF_1GBIT = VDS_HBAPORT_SPEED_FLAG.VDS_HSF_1GBIT;
pub const VDS_HSF_2GBIT = VDS_HBAPORT_SPEED_FLAG.VDS_HSF_2GBIT;
pub const VDS_HSF_10GBIT = VDS_HBAPORT_SPEED_FLAG.VDS_HSF_10GBIT;
pub const VDS_HSF_4GBIT = VDS_HBAPORT_SPEED_FLAG.VDS_HSF_4GBIT;
pub const VDS_HSF_NOT_NEGOTIATED = VDS_HBAPORT_SPEED_FLAG.VDS_HSF_NOT_NEGOTIATED;

pub const VDS_PATH_STATUS = extern enum(i32) {
    VDS_MPS_UNKNOWN = 0,
    VDS_MPS_ONLINE = 1,
    VDS_MPS_FAILED = 5,
    VDS_MPS_STANDBY = 7,
};
pub const VDS_MPS_UNKNOWN = VDS_PATH_STATUS.VDS_MPS_UNKNOWN;
pub const VDS_MPS_ONLINE = VDS_PATH_STATUS.VDS_MPS_ONLINE;
pub const VDS_MPS_FAILED = VDS_PATH_STATUS.VDS_MPS_FAILED;
pub const VDS_MPS_STANDBY = VDS_PATH_STATUS.VDS_MPS_STANDBY;

pub const VDS_LOADBALANCE_POLICY_ENUM = extern enum(i32) {
    VDS_LBP_UNKNOWN = 0,
    VDS_LBP_FAILOVER = 1,
    VDS_LBP_ROUND_ROBIN = 2,
    VDS_LBP_ROUND_ROBIN_WITH_SUBSET = 3,
    VDS_LBP_DYN_LEAST_QUEUE_DEPTH = 4,
    VDS_LBP_WEIGHTED_PATHS = 5,
    VDS_LBP_LEAST_BLOCKS = 6,
    VDS_LBP_VENDOR_SPECIFIC = 7,
};
pub const VDS_LBP_UNKNOWN = VDS_LOADBALANCE_POLICY_ENUM.VDS_LBP_UNKNOWN;
pub const VDS_LBP_FAILOVER = VDS_LOADBALANCE_POLICY_ENUM.VDS_LBP_FAILOVER;
pub const VDS_LBP_ROUND_ROBIN = VDS_LOADBALANCE_POLICY_ENUM.VDS_LBP_ROUND_ROBIN;
pub const VDS_LBP_ROUND_ROBIN_WITH_SUBSET = VDS_LOADBALANCE_POLICY_ENUM.VDS_LBP_ROUND_ROBIN_WITH_SUBSET;
pub const VDS_LBP_DYN_LEAST_QUEUE_DEPTH = VDS_LOADBALANCE_POLICY_ENUM.VDS_LBP_DYN_LEAST_QUEUE_DEPTH;
pub const VDS_LBP_WEIGHTED_PATHS = VDS_LOADBALANCE_POLICY_ENUM.VDS_LBP_WEIGHTED_PATHS;
pub const VDS_LBP_LEAST_BLOCKS = VDS_LOADBALANCE_POLICY_ENUM.VDS_LBP_LEAST_BLOCKS;
pub const VDS_LBP_VENDOR_SPECIFIC = VDS_LOADBALANCE_POLICY_ENUM.VDS_LBP_VENDOR_SPECIFIC;

pub const VDS_PROVIDER_LBSUPPORT_FLAG = extern enum(i32) {
    VDS_LBF_FAILOVER = 1,
    VDS_LBF_ROUND_ROBIN = 2,
    VDS_LBF_ROUND_ROBIN_WITH_SUBSET = 4,
    VDS_LBF_DYN_LEAST_QUEUE_DEPTH = 8,
    VDS_LBF_WEIGHTED_PATHS = 16,
    VDS_LBF_LEAST_BLOCKS = 32,
    VDS_LBF_VENDOR_SPECIFIC = 64,
};
pub const VDS_LBF_FAILOVER = VDS_PROVIDER_LBSUPPORT_FLAG.VDS_LBF_FAILOVER;
pub const VDS_LBF_ROUND_ROBIN = VDS_PROVIDER_LBSUPPORT_FLAG.VDS_LBF_ROUND_ROBIN;
pub const VDS_LBF_ROUND_ROBIN_WITH_SUBSET = VDS_PROVIDER_LBSUPPORT_FLAG.VDS_LBF_ROUND_ROBIN_WITH_SUBSET;
pub const VDS_LBF_DYN_LEAST_QUEUE_DEPTH = VDS_PROVIDER_LBSUPPORT_FLAG.VDS_LBF_DYN_LEAST_QUEUE_DEPTH;
pub const VDS_LBF_WEIGHTED_PATHS = VDS_PROVIDER_LBSUPPORT_FLAG.VDS_LBF_WEIGHTED_PATHS;
pub const VDS_LBF_LEAST_BLOCKS = VDS_PROVIDER_LBSUPPORT_FLAG.VDS_LBF_LEAST_BLOCKS;
pub const VDS_LBF_VENDOR_SPECIFIC = VDS_PROVIDER_LBSUPPORT_FLAG.VDS_LBF_VENDOR_SPECIFIC;

pub const VDS_VERSION_SUPPORT_FLAG = extern enum(i32) {
    VDS_VSF_1_0 = 1,
    VDS_VSF_1_1 = 2,
    VDS_VSF_2_0 = 4,
    VDS_VSF_2_1 = 8,
    VDS_VSF_3_0 = 16,
};
pub const VDS_VSF_1_0 = VDS_VERSION_SUPPORT_FLAG.VDS_VSF_1_0;
pub const VDS_VSF_1_1 = VDS_VERSION_SUPPORT_FLAG.VDS_VSF_1_1;
pub const VDS_VSF_2_0 = VDS_VERSION_SUPPORT_FLAG.VDS_VSF_2_0;
pub const VDS_VSF_2_1 = VDS_VERSION_SUPPORT_FLAG.VDS_VSF_2_1;
pub const VDS_VSF_3_0 = VDS_VERSION_SUPPORT_FLAG.VDS_VSF_3_0;

pub const VDS_HWPROVIDER_TYPE = extern enum(i32) {
    VDS_HWT_UNKNOWN = 0,
    VDS_HWT_PCI_RAID = 1,
    VDS_HWT_FIBRE_CHANNEL = 2,
    VDS_HWT_ISCSI = 3,
    VDS_HWT_SAS = 4,
    VDS_HWT_HYBRID = 5,
};
pub const VDS_HWT_UNKNOWN = VDS_HWPROVIDER_TYPE.VDS_HWT_UNKNOWN;
pub const VDS_HWT_PCI_RAID = VDS_HWPROVIDER_TYPE.VDS_HWT_PCI_RAID;
pub const VDS_HWT_FIBRE_CHANNEL = VDS_HWPROVIDER_TYPE.VDS_HWT_FIBRE_CHANNEL;
pub const VDS_HWT_ISCSI = VDS_HWPROVIDER_TYPE.VDS_HWT_ISCSI;
pub const VDS_HWT_SAS = VDS_HWPROVIDER_TYPE.VDS_HWT_SAS;
pub const VDS_HWT_HYBRID = VDS_HWPROVIDER_TYPE.VDS_HWT_HYBRID;

pub const VDS_ISCSI_LOGIN_TYPE = extern enum(i32) {
    VDS_ILT_MANUAL = 0,
    VDS_ILT_PERSISTENT = 1,
    VDS_ILT_BOOT = 2,
};
pub const VDS_ILT_MANUAL = VDS_ISCSI_LOGIN_TYPE.VDS_ILT_MANUAL;
pub const VDS_ILT_PERSISTENT = VDS_ISCSI_LOGIN_TYPE.VDS_ILT_PERSISTENT;
pub const VDS_ILT_BOOT = VDS_ISCSI_LOGIN_TYPE.VDS_ILT_BOOT;

pub const VDS_ISCSI_AUTH_TYPE = extern enum(i32) {
    VDS_IAT_NONE = 0,
    VDS_IAT_CHAP = 1,
    VDS_IAT_MUTUAL_CHAP = 2,
};
pub const VDS_IAT_NONE = VDS_ISCSI_AUTH_TYPE.VDS_IAT_NONE;
pub const VDS_IAT_CHAP = VDS_ISCSI_AUTH_TYPE.VDS_IAT_CHAP;
pub const VDS_IAT_MUTUAL_CHAP = VDS_ISCSI_AUTH_TYPE.VDS_IAT_MUTUAL_CHAP;

pub const VDS_ISCSI_IPSEC_FLAG = extern enum(i32) {
    VDS_IIF_VALID = 1,
    VDS_IIF_IKE = 2,
    VDS_IIF_MAIN_MODE = 4,
    VDS_IIF_AGGRESSIVE_MODE = 8,
    VDS_IIF_PFS_ENABLE = 16,
    VDS_IIF_TRANSPORT_MODE_PREFERRED = 32,
    VDS_IIF_TUNNEL_MODE_PREFERRED = 64,
};
pub const VDS_IIF_VALID = VDS_ISCSI_IPSEC_FLAG.VDS_IIF_VALID;
pub const VDS_IIF_IKE = VDS_ISCSI_IPSEC_FLAG.VDS_IIF_IKE;
pub const VDS_IIF_MAIN_MODE = VDS_ISCSI_IPSEC_FLAG.VDS_IIF_MAIN_MODE;
pub const VDS_IIF_AGGRESSIVE_MODE = VDS_ISCSI_IPSEC_FLAG.VDS_IIF_AGGRESSIVE_MODE;
pub const VDS_IIF_PFS_ENABLE = VDS_ISCSI_IPSEC_FLAG.VDS_IIF_PFS_ENABLE;
pub const VDS_IIF_TRANSPORT_MODE_PREFERRED = VDS_ISCSI_IPSEC_FLAG.VDS_IIF_TRANSPORT_MODE_PREFERRED;
pub const VDS_IIF_TUNNEL_MODE_PREFERRED = VDS_ISCSI_IPSEC_FLAG.VDS_IIF_TUNNEL_MODE_PREFERRED;

pub const VDS_ISCSI_LOGIN_FLAG = extern enum(i32) {
    VDS_ILF_REQUIRE_IPSEC = 1,
    VDS_ILF_MULTIPATH_ENABLED = 2,
};
pub const VDS_ILF_REQUIRE_IPSEC = VDS_ISCSI_LOGIN_FLAG.VDS_ILF_REQUIRE_IPSEC;
pub const VDS_ILF_MULTIPATH_ENABLED = VDS_ISCSI_LOGIN_FLAG.VDS_ILF_MULTIPATH_ENABLED;

pub const VDS_PATH_ID = extern struct {
    ullSourceId: u64,
    ullPathId: u64,
};

pub const VDS_WWN = extern struct {
    rguchWwn: [8]u8,
};

pub const VDS_IPADDRESS = extern struct {
    type: VDS_IPADDRESS_TYPE,
    ipv4Address: u32,
    ipv6Address: [16]u8,
    ulIpv6FlowInfo: u32,
    ulIpv6ScopeId: u32,
    wszTextAddress: [257]u16,
    ulPort: u32,
};

pub const VDS_ISCSI_IPSEC_KEY = extern struct {
    pKey: *u8,
    ulKeySize: u32,
};

pub const VDS_ISCSI_SHARED_SECRET = extern struct {
    pSharedSecret: *u8,
    ulSharedSecretSize: u32,
};

pub const VDS_HBAPORT_PROP = extern struct {
    id: Guid,
    wwnNode: VDS_WWN,
    wwnPort: VDS_WWN,
    type: VDS_HBAPORT_TYPE,
    status: VDS_HBAPORT_STATUS,
    ulPortSpeed: u32,
    ulSupportedPortSpeed: u32,
};

pub const VDS_ISCSI_INITIATOR_ADAPTER_PROP = extern struct {
    id: Guid,
    pwszName: PWSTR,
};

pub const VDS_ISCSI_INITIATOR_PORTAL_PROP = extern struct {
    id: Guid,
    address: VDS_IPADDRESS,
    ulPortIndex: u32,
};

pub const VDS_PROVIDER_PROP = extern struct {
    id: Guid,
    pwszName: PWSTR,
    guidVersionId: Guid,
    pwszVersion: PWSTR,
    type: VDS_PROVIDER_TYPE,
    ulFlags: u32,
    ulStripeSizeFlags: u32,
    sRebuildPriority: i16,
};

pub const VDS_PATH_INFO = extern struct {
    pathId: VDS_PATH_ID,
    type: VDS_HWPROVIDER_TYPE,
    status: VDS_PATH_STATUS,
    Anonymous1: VDS_PATH_INFO._Anonymous1_e__Union,
    Anonymous2: VDS_PATH_INFO._Anonymous2_e__Union,
    Anonymous3: VDS_PATH_INFO._Anonymous3_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const VDS_PATH_POLICY = extern struct {
    pathId: VDS_PATH_ID,
    bPrimaryPath: BOOL,
    ulWeight: u32,
};

const IID_IEnumVdsObject_Value = @import("../zig.zig").Guid.initString("118610b7-8d94-4030-b5b8-500889788e4e");
pub const IID_IEnumVdsObject = &IID_IEnumVdsObject_Value;
pub const IEnumVdsObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumVdsObject,
            celt: u32,
            ppObjectArray: [*]*IUnknown,
            pcFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumVdsObject,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumVdsObject,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVdsObject_Next(self: *const T, celt: u32, ppObjectArray: [*]*IUnknown, pcFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVdsObject.VTable, self.vtable).Next(@ptrCast(*const IEnumVdsObject, self), celt, ppObjectArray, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVdsObject_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVdsObject.VTable, self.vtable).Skip(@ptrCast(*const IEnumVdsObject, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVdsObject_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVdsObject.VTable, self.vtable).Reset(@ptrCast(*const IEnumVdsObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumVdsObject_Clone(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumVdsObject.VTable, self.vtable).Clone(@ptrCast(*const IEnumVdsObject, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsAsync_Value = @import("../zig.zig").Guid.initString("d5d23b6d-5a55-4492-9889-397a3c2d2dbc");
pub const IID_IVdsAsync = &IID_IVdsAsync_Value;
pub const IVdsAsync = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: fn(
            self: *const IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Wait: fn(
            self: *const IVdsAsync,
            pHrResult: *HRESULT,
            pAsyncOut: *VDS_ASYNC_OUTPUT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryStatus: fn(
            self: *const IVdsAsync,
            pHrResult: *HRESULT,
            pulPercentCompleted: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAsync_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAsync.VTable, self.vtable).Cancel(@ptrCast(*const IVdsAsync, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAsync_Wait(self: *const T, pHrResult: *HRESULT, pAsyncOut: *VDS_ASYNC_OUTPUT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAsync.VTable, self.vtable).Wait(@ptrCast(*const IVdsAsync, self), pHrResult, pAsyncOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAsync_QueryStatus(self: *const T, pHrResult: *HRESULT, pulPercentCompleted: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAsync.VTable, self.vtable).QueryStatus(@ptrCast(*const IVdsAsync, self), pHrResult, pulPercentCompleted);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsAdviseSink_Value = @import("../zig.zig").Guid.initString("8326cd1d-cf59-4936-b786-5efc08798e25");
pub const IID_IVdsAdviseSink = &IID_IVdsAdviseSink_Value;
pub const IVdsAdviseSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnNotify: fn(
            self: *const IVdsAdviseSink,
            lNumberOfNotifications: i32,
            pNotificationArray: [*]VDS_NOTIFICATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAdviseSink_OnNotify(self: *const T, lNumberOfNotifications: i32, pNotificationArray: [*]VDS_NOTIFICATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAdviseSink.VTable, self.vtable).OnNotify(@ptrCast(*const IVdsAdviseSink, self), lNumberOfNotifications, pNotificationArray);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsProvider_Value = @import("../zig.zig").Guid.initString("10c5e575-7984-4e81-a56b-431f5f92ae42");
pub const IID_IVdsProvider = &IID_IVdsProvider_Value;
pub const IVdsProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsProvider,
            pProviderProp: *VDS_PROVIDER_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProvider_GetProperties(self: *const T, pProviderProp: *VDS_PROVIDER_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProvider.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsProvider, self), pProviderProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsProviderSupport_Value = @import("../zig.zig").Guid.initString("1732be13-e8f9-4a03-bfbc-5f616aa66ce1");
pub const IID_IVdsProviderSupport = &IID_IVdsProviderSupport_Value;
pub const IVdsProviderSupport = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetVersionSupport: fn(
            self: *const IVdsProviderSupport,
            ulVersionSupport: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProviderSupport_GetVersionSupport(self: *const T, ulVersionSupport: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProviderSupport.VTable, self.vtable).GetVersionSupport(@ptrCast(*const IVdsProviderSupport, self), ulVersionSupport);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsProviderPrivate_Value = @import("../zig.zig").Guid.initString("11f3cd41-b7e8-48ff-9472-9dff018aa292");
pub const IID_IVdsProviderPrivate = &IID_IVdsProviderPrivate_Value;
pub const IVdsProviderPrivate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetObject: fn(
            self: *const IVdsProviderPrivate,
            ObjectId: Guid,
            type: VDS_OBJECT_TYPE,
            ppObjectUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLoad: fn(
            self: *const IVdsProviderPrivate,
            pwszMachineName: PWSTR,
            pCallbackObject: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUnload: fn(
            self: *const IVdsProviderPrivate,
            bForceUnload: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProviderPrivate_GetObject(self: *const T, ObjectId: Guid, type: VDS_OBJECT_TYPE, ppObjectUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProviderPrivate.VTable, self.vtable).GetObject(@ptrCast(*const IVdsProviderPrivate, self), ObjectId, type, ppObjectUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProviderPrivate_OnLoad(self: *const T, pwszMachineName: PWSTR, pCallbackObject: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProviderPrivate.VTable, self.vtable).OnLoad(@ptrCast(*const IVdsProviderPrivate, self), pwszMachineName, pCallbackObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsProviderPrivate_OnUnload(self: *const T, bForceUnload: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsProviderPrivate.VTable, self.vtable).OnUnload(@ptrCast(*const IVdsProviderPrivate, self), bForceUnload);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VDS_SUB_SYSTEM_STATUS = extern enum(i32) {
    VDS_SSS_UNKNOWN = 0,
    VDS_SSS_ONLINE = 1,
    VDS_SSS_NOT_READY = 2,
    VDS_SSS_OFFLINE = 4,
    VDS_SSS_FAILED = 5,
    VDS_SSS_PARTIALLY_MANAGED = 9,
};
pub const VDS_SSS_UNKNOWN = VDS_SUB_SYSTEM_STATUS.VDS_SSS_UNKNOWN;
pub const VDS_SSS_ONLINE = VDS_SUB_SYSTEM_STATUS.VDS_SSS_ONLINE;
pub const VDS_SSS_NOT_READY = VDS_SUB_SYSTEM_STATUS.VDS_SSS_NOT_READY;
pub const VDS_SSS_OFFLINE = VDS_SUB_SYSTEM_STATUS.VDS_SSS_OFFLINE;
pub const VDS_SSS_FAILED = VDS_SUB_SYSTEM_STATUS.VDS_SSS_FAILED;
pub const VDS_SSS_PARTIALLY_MANAGED = VDS_SUB_SYSTEM_STATUS.VDS_SSS_PARTIALLY_MANAGED;

pub const VDS_SUB_SYSTEM_FLAG = extern enum(i32) {
    VDS_SF_LUN_MASKING_CAPABLE = 1,
    VDS_SF_LUN_PLEXING_CAPABLE = 2,
    VDS_SF_LUN_REMAPPING_CAPABLE = 4,
    VDS_SF_DRIVE_EXTENT_CAPABLE = 8,
    VDS_SF_HARDWARE_CHECKSUM_CAPABLE = 16,
    VDS_SF_RADIUS_CAPABLE = 32,
    VDS_SF_READ_BACK_VERIFY_CAPABLE = 64,
    VDS_SF_WRITE_THROUGH_CACHING_CAPABLE = 128,
    VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS = 512,
    VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS = 1024,
    VDS_SF_SUPPORTS_SIMPLE_LUNS = 2048,
    VDS_SF_SUPPORTS_SPAN_LUNS = 4096,
    VDS_SF_SUPPORTS_STRIPE_LUNS = 8192,
    VDS_SF_SUPPORTS_MIRROR_LUNS = 16384,
    VDS_SF_SUPPORTS_PARITY_LUNS = 32768,
    VDS_SF_SUPPORTS_AUTH_CHAP = 65536,
    VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP = 131072,
    VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG = 262144,
    VDS_SF_SUPPORTS_LUN_NUMBER = 524288,
    VDS_SF_SUPPORTS_MIRRORED_CACHE = 1048576,
    VDS_SF_READ_CACHING_CAPABLE = 2097152,
    VDS_SF_WRITE_CACHING_CAPABLE = 4194304,
    VDS_SF_MEDIA_SCAN_CAPABLE = 8388608,
    VDS_SF_CONSISTENCY_CHECK_CAPABLE = 16777216,
};
pub const VDS_SF_LUN_MASKING_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_LUN_MASKING_CAPABLE;
pub const VDS_SF_LUN_PLEXING_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_LUN_PLEXING_CAPABLE;
pub const VDS_SF_LUN_REMAPPING_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_LUN_REMAPPING_CAPABLE;
pub const VDS_SF_DRIVE_EXTENT_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_DRIVE_EXTENT_CAPABLE;
pub const VDS_SF_HARDWARE_CHECKSUM_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_HARDWARE_CHECKSUM_CAPABLE;
pub const VDS_SF_RADIUS_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_RADIUS_CAPABLE;
pub const VDS_SF_READ_BACK_VERIFY_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_READ_BACK_VERIFY_CAPABLE;
pub const VDS_SF_WRITE_THROUGH_CACHING_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_WRITE_THROUGH_CACHING_CAPABLE;
pub const VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_FAULT_TOLERANT_LUNS;
pub const VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_NON_FAULT_TOLERANT_LUNS;
pub const VDS_SF_SUPPORTS_SIMPLE_LUNS = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_SIMPLE_LUNS;
pub const VDS_SF_SUPPORTS_SPAN_LUNS = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_SPAN_LUNS;
pub const VDS_SF_SUPPORTS_STRIPE_LUNS = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_STRIPE_LUNS;
pub const VDS_SF_SUPPORTS_MIRROR_LUNS = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_MIRROR_LUNS;
pub const VDS_SF_SUPPORTS_PARITY_LUNS = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_PARITY_LUNS;
pub const VDS_SF_SUPPORTS_AUTH_CHAP = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_AUTH_CHAP;
pub const VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_AUTH_MUTUAL_CHAP;
pub const VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_SIMPLE_TARGET_CONFIG;
pub const VDS_SF_SUPPORTS_LUN_NUMBER = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_LUN_NUMBER;
pub const VDS_SF_SUPPORTS_MIRRORED_CACHE = VDS_SUB_SYSTEM_FLAG.VDS_SF_SUPPORTS_MIRRORED_CACHE;
pub const VDS_SF_READ_CACHING_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_READ_CACHING_CAPABLE;
pub const VDS_SF_WRITE_CACHING_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_WRITE_CACHING_CAPABLE;
pub const VDS_SF_MEDIA_SCAN_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_MEDIA_SCAN_CAPABLE;
pub const VDS_SF_CONSISTENCY_CHECK_CAPABLE = VDS_SUB_SYSTEM_FLAG.VDS_SF_CONSISTENCY_CHECK_CAPABLE;

pub const VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG = extern enum(i32) {
    VDS_SF_SUPPORTS_RAID2_LUNS = 1,
    VDS_SF_SUPPORTS_RAID3_LUNS = 2,
    VDS_SF_SUPPORTS_RAID4_LUNS = 4,
    VDS_SF_SUPPORTS_RAID5_LUNS = 8,
    VDS_SF_SUPPORTS_RAID6_LUNS = 16,
    VDS_SF_SUPPORTS_RAID01_LUNS = 32,
    VDS_SF_SUPPORTS_RAID03_LUNS = 64,
    VDS_SF_SUPPORTS_RAID05_LUNS = 128,
    VDS_SF_SUPPORTS_RAID10_LUNS = 256,
    VDS_SF_SUPPORTS_RAID15_LUNS = 512,
    VDS_SF_SUPPORTS_RAID30_LUNS = 1024,
    VDS_SF_SUPPORTS_RAID50_LUNS = 2048,
    VDS_SF_SUPPORTS_RAID51_LUNS = 4096,
    VDS_SF_SUPPORTS_RAID53_LUNS = 8192,
    VDS_SF_SUPPORTS_RAID60_LUNS = 16384,
    VDS_SF_SUPPORTS_RAID61_LUNS = 32768,
};
pub const VDS_SF_SUPPORTS_RAID2_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID2_LUNS;
pub const VDS_SF_SUPPORTS_RAID3_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID3_LUNS;
pub const VDS_SF_SUPPORTS_RAID4_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID4_LUNS;
pub const VDS_SF_SUPPORTS_RAID5_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID5_LUNS;
pub const VDS_SF_SUPPORTS_RAID6_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID6_LUNS;
pub const VDS_SF_SUPPORTS_RAID01_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID01_LUNS;
pub const VDS_SF_SUPPORTS_RAID03_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID03_LUNS;
pub const VDS_SF_SUPPORTS_RAID05_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID05_LUNS;
pub const VDS_SF_SUPPORTS_RAID10_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID10_LUNS;
pub const VDS_SF_SUPPORTS_RAID15_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID15_LUNS;
pub const VDS_SF_SUPPORTS_RAID30_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID30_LUNS;
pub const VDS_SF_SUPPORTS_RAID50_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID50_LUNS;
pub const VDS_SF_SUPPORTS_RAID51_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID51_LUNS;
pub const VDS_SF_SUPPORTS_RAID53_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID53_LUNS;
pub const VDS_SF_SUPPORTS_RAID60_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID60_LUNS;
pub const VDS_SF_SUPPORTS_RAID61_LUNS = VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG.VDS_SF_SUPPORTS_RAID61_LUNS;

pub const VDS_INTERCONNECT_FLAG = extern enum(i32) {
    VDS_ITF_PCI_RAID = 1,
    VDS_ITF_FIBRE_CHANNEL = 2,
    VDS_ITF_ISCSI = 4,
    VDS_ITF_SAS = 8,
};
pub const VDS_ITF_PCI_RAID = VDS_INTERCONNECT_FLAG.VDS_ITF_PCI_RAID;
pub const VDS_ITF_FIBRE_CHANNEL = VDS_INTERCONNECT_FLAG.VDS_ITF_FIBRE_CHANNEL;
pub const VDS_ITF_ISCSI = VDS_INTERCONNECT_FLAG.VDS_ITF_ISCSI;
pub const VDS_ITF_SAS = VDS_INTERCONNECT_FLAG.VDS_ITF_SAS;

pub const VDS_CONTROLLER_STATUS = extern enum(i32) {
    VDS_CS_UNKNOWN = 0,
    VDS_CS_ONLINE = 1,
    VDS_CS_NOT_READY = 2,
    VDS_CS_OFFLINE = 4,
    VDS_CS_FAILED = 5,
    VDS_CS_REMOVED = 8,
};
pub const VDS_CS_UNKNOWN = VDS_CONTROLLER_STATUS.VDS_CS_UNKNOWN;
pub const VDS_CS_ONLINE = VDS_CONTROLLER_STATUS.VDS_CS_ONLINE;
pub const VDS_CS_NOT_READY = VDS_CONTROLLER_STATUS.VDS_CS_NOT_READY;
pub const VDS_CS_OFFLINE = VDS_CONTROLLER_STATUS.VDS_CS_OFFLINE;
pub const VDS_CS_FAILED = VDS_CONTROLLER_STATUS.VDS_CS_FAILED;
pub const VDS_CS_REMOVED = VDS_CONTROLLER_STATUS.VDS_CS_REMOVED;

pub const VDS_PORT_STATUS = extern enum(i32) {
    VDS_PRS_UNKNOWN = 0,
    VDS_PRS_ONLINE = 1,
    VDS_PRS_NOT_READY = 2,
    VDS_PRS_OFFLINE = 4,
    VDS_PRS_FAILED = 5,
    VDS_PRS_REMOVED = 8,
};
pub const VDS_PRS_UNKNOWN = VDS_PORT_STATUS.VDS_PRS_UNKNOWN;
pub const VDS_PRS_ONLINE = VDS_PORT_STATUS.VDS_PRS_ONLINE;
pub const VDS_PRS_NOT_READY = VDS_PORT_STATUS.VDS_PRS_NOT_READY;
pub const VDS_PRS_OFFLINE = VDS_PORT_STATUS.VDS_PRS_OFFLINE;
pub const VDS_PRS_FAILED = VDS_PORT_STATUS.VDS_PRS_FAILED;
pub const VDS_PRS_REMOVED = VDS_PORT_STATUS.VDS_PRS_REMOVED;

pub const VDS_DRIVE_STATUS = extern enum(i32) {
    VDS_DRS_UNKNOWN = 0,
    VDS_DRS_ONLINE = 1,
    VDS_DRS_NOT_READY = 2,
    VDS_DRS_OFFLINE = 4,
    VDS_DRS_FAILED = 5,
    VDS_DRS_REMOVED = 8,
};
pub const VDS_DRS_UNKNOWN = VDS_DRIVE_STATUS.VDS_DRS_UNKNOWN;
pub const VDS_DRS_ONLINE = VDS_DRIVE_STATUS.VDS_DRS_ONLINE;
pub const VDS_DRS_NOT_READY = VDS_DRIVE_STATUS.VDS_DRS_NOT_READY;
pub const VDS_DRS_OFFLINE = VDS_DRIVE_STATUS.VDS_DRS_OFFLINE;
pub const VDS_DRS_FAILED = VDS_DRIVE_STATUS.VDS_DRS_FAILED;
pub const VDS_DRS_REMOVED = VDS_DRIVE_STATUS.VDS_DRS_REMOVED;

pub const VDS_DRIVE_FLAG = extern enum(i32) {
    VDS_DRF_HOTSPARE = 1,
    VDS_DRF_ASSIGNED = 2,
    VDS_DRF_UNASSIGNED = 4,
    VDS_DRF_HOTSPARE_IN_USE = 8,
    VDS_DRF_HOTSPARE_STANDBY = 16,
};
pub const VDS_DRF_HOTSPARE = VDS_DRIVE_FLAG.VDS_DRF_HOTSPARE;
pub const VDS_DRF_ASSIGNED = VDS_DRIVE_FLAG.VDS_DRF_ASSIGNED;
pub const VDS_DRF_UNASSIGNED = VDS_DRIVE_FLAG.VDS_DRF_UNASSIGNED;
pub const VDS_DRF_HOTSPARE_IN_USE = VDS_DRIVE_FLAG.VDS_DRF_HOTSPARE_IN_USE;
pub const VDS_DRF_HOTSPARE_STANDBY = VDS_DRIVE_FLAG.VDS_DRF_HOTSPARE_STANDBY;

pub const VDS_LUN_TYPE = extern enum(i32) {
    VDS_LT_UNKNOWN = 0,
    VDS_LT_DEFAULT = 1,
    VDS_LT_FAULT_TOLERANT = 2,
    VDS_LT_NON_FAULT_TOLERANT = 3,
    VDS_LT_SIMPLE = 10,
    VDS_LT_SPAN = 11,
    VDS_LT_STRIPE = 12,
    VDS_LT_MIRROR = 13,
    VDS_LT_PARITY = 14,
    VDS_LT_RAID2 = 15,
    VDS_LT_RAID3 = 16,
    VDS_LT_RAID4 = 17,
    VDS_LT_RAID5 = 18,
    VDS_LT_RAID6 = 19,
    VDS_LT_RAID01 = 20,
    VDS_LT_RAID03 = 21,
    VDS_LT_RAID05 = 22,
    VDS_LT_RAID10 = 23,
    VDS_LT_RAID15 = 24,
    VDS_LT_RAID30 = 25,
    VDS_LT_RAID50 = 26,
    VDS_LT_RAID51 = 27,
    VDS_LT_RAID53 = 28,
    VDS_LT_RAID60 = 29,
    VDS_LT_RAID61 = 30,
};
pub const VDS_LT_UNKNOWN = VDS_LUN_TYPE.VDS_LT_UNKNOWN;
pub const VDS_LT_DEFAULT = VDS_LUN_TYPE.VDS_LT_DEFAULT;
pub const VDS_LT_FAULT_TOLERANT = VDS_LUN_TYPE.VDS_LT_FAULT_TOLERANT;
pub const VDS_LT_NON_FAULT_TOLERANT = VDS_LUN_TYPE.VDS_LT_NON_FAULT_TOLERANT;
pub const VDS_LT_SIMPLE = VDS_LUN_TYPE.VDS_LT_SIMPLE;
pub const VDS_LT_SPAN = VDS_LUN_TYPE.VDS_LT_SPAN;
pub const VDS_LT_STRIPE = VDS_LUN_TYPE.VDS_LT_STRIPE;
pub const VDS_LT_MIRROR = VDS_LUN_TYPE.VDS_LT_MIRROR;
pub const VDS_LT_PARITY = VDS_LUN_TYPE.VDS_LT_PARITY;
pub const VDS_LT_RAID2 = VDS_LUN_TYPE.VDS_LT_RAID2;
pub const VDS_LT_RAID3 = VDS_LUN_TYPE.VDS_LT_RAID3;
pub const VDS_LT_RAID4 = VDS_LUN_TYPE.VDS_LT_RAID4;
pub const VDS_LT_RAID5 = VDS_LUN_TYPE.VDS_LT_RAID5;
pub const VDS_LT_RAID6 = VDS_LUN_TYPE.VDS_LT_RAID6;
pub const VDS_LT_RAID01 = VDS_LUN_TYPE.VDS_LT_RAID01;
pub const VDS_LT_RAID03 = VDS_LUN_TYPE.VDS_LT_RAID03;
pub const VDS_LT_RAID05 = VDS_LUN_TYPE.VDS_LT_RAID05;
pub const VDS_LT_RAID10 = VDS_LUN_TYPE.VDS_LT_RAID10;
pub const VDS_LT_RAID15 = VDS_LUN_TYPE.VDS_LT_RAID15;
pub const VDS_LT_RAID30 = VDS_LUN_TYPE.VDS_LT_RAID30;
pub const VDS_LT_RAID50 = VDS_LUN_TYPE.VDS_LT_RAID50;
pub const VDS_LT_RAID51 = VDS_LUN_TYPE.VDS_LT_RAID51;
pub const VDS_LT_RAID53 = VDS_LUN_TYPE.VDS_LT_RAID53;
pub const VDS_LT_RAID60 = VDS_LUN_TYPE.VDS_LT_RAID60;
pub const VDS_LT_RAID61 = VDS_LUN_TYPE.VDS_LT_RAID61;

pub const VDS_LUN_STATUS = extern enum(i32) {
    VDS_LS_UNKNOWN = 0,
    VDS_LS_ONLINE = 1,
    VDS_LS_NOT_READY = 2,
    VDS_LS_OFFLINE = 4,
    VDS_LS_FAILED = 5,
};
pub const VDS_LS_UNKNOWN = VDS_LUN_STATUS.VDS_LS_UNKNOWN;
pub const VDS_LS_ONLINE = VDS_LUN_STATUS.VDS_LS_ONLINE;
pub const VDS_LS_NOT_READY = VDS_LUN_STATUS.VDS_LS_NOT_READY;
pub const VDS_LS_OFFLINE = VDS_LUN_STATUS.VDS_LS_OFFLINE;
pub const VDS_LS_FAILED = VDS_LUN_STATUS.VDS_LS_FAILED;

pub const VDS_LUN_FLAG = extern enum(i32) {
    VDS_LF_LBN_REMAP_ENABLED = 1,
    VDS_LF_READ_BACK_VERIFY_ENABLED = 2,
    VDS_LF_WRITE_THROUGH_CACHING_ENABLED = 4,
    VDS_LF_HARDWARE_CHECKSUM_ENABLED = 8,
    VDS_LF_READ_CACHE_ENABLED = 16,
    VDS_LF_WRITE_CACHE_ENABLED = 32,
    VDS_LF_MEDIA_SCAN_ENABLED = 64,
    VDS_LF_CONSISTENCY_CHECK_ENABLED = 128,
    VDS_LF_SNAPSHOT = 256,
};
pub const VDS_LF_LBN_REMAP_ENABLED = VDS_LUN_FLAG.VDS_LF_LBN_REMAP_ENABLED;
pub const VDS_LF_READ_BACK_VERIFY_ENABLED = VDS_LUN_FLAG.VDS_LF_READ_BACK_VERIFY_ENABLED;
pub const VDS_LF_WRITE_THROUGH_CACHING_ENABLED = VDS_LUN_FLAG.VDS_LF_WRITE_THROUGH_CACHING_ENABLED;
pub const VDS_LF_HARDWARE_CHECKSUM_ENABLED = VDS_LUN_FLAG.VDS_LF_HARDWARE_CHECKSUM_ENABLED;
pub const VDS_LF_READ_CACHE_ENABLED = VDS_LUN_FLAG.VDS_LF_READ_CACHE_ENABLED;
pub const VDS_LF_WRITE_CACHE_ENABLED = VDS_LUN_FLAG.VDS_LF_WRITE_CACHE_ENABLED;
pub const VDS_LF_MEDIA_SCAN_ENABLED = VDS_LUN_FLAG.VDS_LF_MEDIA_SCAN_ENABLED;
pub const VDS_LF_CONSISTENCY_CHECK_ENABLED = VDS_LUN_FLAG.VDS_LF_CONSISTENCY_CHECK_ENABLED;
pub const VDS_LF_SNAPSHOT = VDS_LUN_FLAG.VDS_LF_SNAPSHOT;

pub const VDS_LUN_PLEX_TYPE = extern enum(i32) {
    VDS_LPT_UNKNOWN = 0,
    VDS_LPT_SIMPLE = 10,
    VDS_LPT_SPAN = 11,
    VDS_LPT_STRIPE = 12,
    VDS_LPT_PARITY = 14,
    VDS_LPT_RAID2 = 15,
    VDS_LPT_RAID3 = 16,
    VDS_LPT_RAID4 = 17,
    VDS_LPT_RAID5 = 18,
    VDS_LPT_RAID6 = 19,
    VDS_LPT_RAID03 = 21,
    VDS_LPT_RAID05 = 22,
    VDS_LPT_RAID10 = 23,
    VDS_LPT_RAID15 = 24,
    VDS_LPT_RAID30 = 25,
    VDS_LPT_RAID50 = 26,
    VDS_LPT_RAID53 = 28,
    VDS_LPT_RAID60 = 29,
};
pub const VDS_LPT_UNKNOWN = VDS_LUN_PLEX_TYPE.VDS_LPT_UNKNOWN;
pub const VDS_LPT_SIMPLE = VDS_LUN_PLEX_TYPE.VDS_LPT_SIMPLE;
pub const VDS_LPT_SPAN = VDS_LUN_PLEX_TYPE.VDS_LPT_SPAN;
pub const VDS_LPT_STRIPE = VDS_LUN_PLEX_TYPE.VDS_LPT_STRIPE;
pub const VDS_LPT_PARITY = VDS_LUN_PLEX_TYPE.VDS_LPT_PARITY;
pub const VDS_LPT_RAID2 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID2;
pub const VDS_LPT_RAID3 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID3;
pub const VDS_LPT_RAID4 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID4;
pub const VDS_LPT_RAID5 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID5;
pub const VDS_LPT_RAID6 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID6;
pub const VDS_LPT_RAID03 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID03;
pub const VDS_LPT_RAID05 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID05;
pub const VDS_LPT_RAID10 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID10;
pub const VDS_LPT_RAID15 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID15;
pub const VDS_LPT_RAID30 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID30;
pub const VDS_LPT_RAID50 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID50;
pub const VDS_LPT_RAID53 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID53;
pub const VDS_LPT_RAID60 = VDS_LUN_PLEX_TYPE.VDS_LPT_RAID60;

pub const VDS_LUN_PLEX_STATUS = extern enum(i32) {
    VDS_LPS_UNKNOWN = 0,
    VDS_LPS_ONLINE = 1,
    VDS_LPS_NOT_READY = 2,
    VDS_LPS_OFFLINE = 4,
    VDS_LPS_FAILED = 5,
};
pub const VDS_LPS_UNKNOWN = VDS_LUN_PLEX_STATUS.VDS_LPS_UNKNOWN;
pub const VDS_LPS_ONLINE = VDS_LUN_PLEX_STATUS.VDS_LPS_ONLINE;
pub const VDS_LPS_NOT_READY = VDS_LUN_PLEX_STATUS.VDS_LPS_NOT_READY;
pub const VDS_LPS_OFFLINE = VDS_LUN_PLEX_STATUS.VDS_LPS_OFFLINE;
pub const VDS_LPS_FAILED = VDS_LUN_PLEX_STATUS.VDS_LPS_FAILED;

pub const VDS_LUN_PLEX_FLAG = extern enum(i32) {
    VDS_LPF_LBN_REMAP_ENABLED = 1,
};
pub const VDS_LPF_LBN_REMAP_ENABLED = VDS_LUN_PLEX_FLAG.VDS_LPF_LBN_REMAP_ENABLED;

pub const VDS_ISCSI_PORTAL_STATUS = extern enum(i32) {
    VDS_IPS_UNKNOWN = 0,
    VDS_IPS_ONLINE = 1,
    VDS_IPS_NOT_READY = 2,
    VDS_IPS_OFFLINE = 4,
    VDS_IPS_FAILED = 5,
};
pub const VDS_IPS_UNKNOWN = VDS_ISCSI_PORTAL_STATUS.VDS_IPS_UNKNOWN;
pub const VDS_IPS_ONLINE = VDS_ISCSI_PORTAL_STATUS.VDS_IPS_ONLINE;
pub const VDS_IPS_NOT_READY = VDS_ISCSI_PORTAL_STATUS.VDS_IPS_NOT_READY;
pub const VDS_IPS_OFFLINE = VDS_ISCSI_PORTAL_STATUS.VDS_IPS_OFFLINE;
pub const VDS_IPS_FAILED = VDS_ISCSI_PORTAL_STATUS.VDS_IPS_FAILED;

pub const VDS_STORAGE_POOL_STATUS = extern enum(i32) {
    VDS_SPS_UNKNOWN = 0,
    VDS_SPS_ONLINE = 1,
    VDS_SPS_NOT_READY = 2,
    VDS_SPS_OFFLINE = 4,
};
pub const VDS_SPS_UNKNOWN = VDS_STORAGE_POOL_STATUS.VDS_SPS_UNKNOWN;
pub const VDS_SPS_ONLINE = VDS_STORAGE_POOL_STATUS.VDS_SPS_ONLINE;
pub const VDS_SPS_NOT_READY = VDS_STORAGE_POOL_STATUS.VDS_SPS_NOT_READY;
pub const VDS_SPS_OFFLINE = VDS_STORAGE_POOL_STATUS.VDS_SPS_OFFLINE;

pub const VDS_STORAGE_POOL_TYPE = extern enum(i32) {
    VDS_SPT_UNKNOWN = 0,
    VDS_SPT_PRIMORDIAL = 1,
    VDS_SPT_CONCRETE = 2,
};
pub const VDS_SPT_UNKNOWN = VDS_STORAGE_POOL_TYPE.VDS_SPT_UNKNOWN;
pub const VDS_SPT_PRIMORDIAL = VDS_STORAGE_POOL_TYPE.VDS_SPT_PRIMORDIAL;
pub const VDS_SPT_CONCRETE = VDS_STORAGE_POOL_TYPE.VDS_SPT_CONCRETE;

pub const VDS_MAINTENANCE_OPERATION = extern enum(i32) {
    BlinkLight = 1,
    BeepAlarm = 2,
    SpinDown = 3,
    SpinUp = 4,
    Ping = 5,
};
pub const BlinkLight = VDS_MAINTENANCE_OPERATION.BlinkLight;
pub const BeepAlarm = VDS_MAINTENANCE_OPERATION.BeepAlarm;
pub const SpinDown = VDS_MAINTENANCE_OPERATION.SpinDown;
pub const SpinUp = VDS_MAINTENANCE_OPERATION.SpinUp;
pub const Ping = VDS_MAINTENANCE_OPERATION.Ping;

pub const VDS_HINTS = extern struct {
    ullHintMask: u64,
    ullExpectedMaximumSize: u64,
    ulOptimalReadSize: u32,
    ulOptimalReadAlignment: u32,
    ulOptimalWriteSize: u32,
    ulOptimalWriteAlignment: u32,
    ulMaximumDriveCount: u32,
    ulStripeSize: u32,
    bFastCrashRecoveryRequired: BOOL,
    bMostlyReads: BOOL,
    bOptimizeForSequentialReads: BOOL,
    bOptimizeForSequentialWrites: BOOL,
    bRemapEnabled: BOOL,
    bReadBackVerifyEnabled: BOOL,
    bWriteThroughCachingEnabled: BOOL,
    bHardwareChecksumEnabled: BOOL,
    bIsYankable: BOOL,
    sRebuildPriority: i16,
};

pub const VDS_HINTS2 = extern struct {
    ullHintMask: u64,
    ullExpectedMaximumSize: u64,
    ulOptimalReadSize: u32,
    ulOptimalReadAlignment: u32,
    ulOptimalWriteSize: u32,
    ulOptimalWriteAlignment: u32,
    ulMaximumDriveCount: u32,
    ulStripeSize: u32,
    ulReserved1: u32,
    ulReserved2: u32,
    ulReserved3: u32,
    bFastCrashRecoveryRequired: BOOL,
    bMostlyReads: BOOL,
    bOptimizeForSequentialReads: BOOL,
    bOptimizeForSequentialWrites: BOOL,
    bRemapEnabled: BOOL,
    bReadBackVerifyEnabled: BOOL,
    bWriteThroughCachingEnabled: BOOL,
    bHardwareChecksumEnabled: BOOL,
    bIsYankable: BOOL,
    bAllocateHotSpare: BOOL,
    bUseMirroredCache: BOOL,
    bReadCachingEnabled: BOOL,
    bWriteCachingEnabled: BOOL,
    bMediaScanEnabled: BOOL,
    bConsistencyCheckEnabled: BOOL,
    BusType: VDS_STORAGE_BUS_TYPE,
    bReserved1: BOOL,
    bReserved2: BOOL,
    bReserved3: BOOL,
    sRebuildPriority: i16,
};

pub const VDS_SUB_SYSTEM_PROP = extern struct {
    id: Guid,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    ulFlags: u32,
    ulStripeSizeFlags: u32,
    status: VDS_SUB_SYSTEM_STATUS,
    health: VDS_HEALTH,
    sNumberOfInternalBuses: i16,
    sMaxNumberOfSlotsEachBus: i16,
    sMaxNumberOfControllers: i16,
    sRebuildPriority: i16,
};

pub const VDS_SUB_SYSTEM_PROP2 = extern struct {
    id: Guid,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    ulFlags: u32,
    ulStripeSizeFlags: u32,
    ulSupportedRaidTypeFlags: u32,
    status: VDS_SUB_SYSTEM_STATUS,
    health: VDS_HEALTH,
    sNumberOfInternalBuses: i16,
    sMaxNumberOfSlotsEachBus: i16,
    sMaxNumberOfControllers: i16,
    sRebuildPriority: i16,
    ulNumberOfEnclosures: u32,
};

pub const VDS_CONTROLLER_PROP = extern struct {
    id: Guid,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    status: VDS_CONTROLLER_STATUS,
    health: VDS_HEALTH,
    sNumberOfPorts: i16,
};

pub const VDS_DRIVE_PROP = extern struct {
    id: Guid,
    ullSize: u64,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    ulFlags: u32,
    status: VDS_DRIVE_STATUS,
    health: VDS_HEALTH,
    sInternalBusNumber: i16,
    sSlotNumber: i16,
};

pub const VDS_DRIVE_PROP2 = extern struct {
    id: Guid,
    ullSize: u64,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    ulFlags: u32,
    status: VDS_DRIVE_STATUS,
    health: VDS_HEALTH,
    sInternalBusNumber: i16,
    sSlotNumber: i16,
    ulEnclosureNumber: u32,
    busType: VDS_STORAGE_BUS_TYPE,
    ulSpindleSpeed: u32,
};

pub const VDS_DRIVE_EXTENT = extern struct {
    id: Guid,
    LunId: Guid,
    ullSize: u64,
    bUsed: BOOL,
};

pub const VDS_LUN_PROP = extern struct {
    id: Guid,
    ullSize: u64,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    pwszUnmaskingList: PWSTR,
    ulFlags: u32,
    type: VDS_LUN_TYPE,
    status: VDS_LUN_STATUS,
    health: VDS_HEALTH,
    TransitionState: VDS_TRANSITION_STATE,
    sRebuildPriority: i16,
};

pub const VDS_LUN_PLEX_PROP = extern struct {
    id: Guid,
    ullSize: u64,
    type: VDS_LUN_PLEX_TYPE,
    status: VDS_LUN_PLEX_STATUS,
    health: VDS_HEALTH,
    TransitionState: VDS_TRANSITION_STATE,
    ulFlags: u32,
    ulStripeSize: u32,
    sRebuildPriority: i16,
};

pub const VDS_PORT_PROP = extern struct {
    id: Guid,
    pwszFriendlyName: PWSTR,
    pwszIdentification: PWSTR,
    status: VDS_PORT_STATUS,
};

pub const VDS_ISCSI_PORTAL_PROP = extern struct {
    id: Guid,
    address: VDS_IPADDRESS,
    status: VDS_ISCSI_PORTAL_STATUS,
};

pub const VDS_ISCSI_TARGET_PROP = extern struct {
    id: Guid,
    pwszIscsiName: PWSTR,
    pwszFriendlyName: PWSTR,
    bChapEnabled: BOOL,
};

pub const VDS_ISCSI_PORTALGROUP_PROP = extern struct {
    id: Guid,
    tag: u16,
};

pub const VDS_RAID_TYPE = extern enum(i32) {
    VDS_RT_UNKNOWN = 0,
    VDS_RT_RAID0 = 10,
    VDS_RT_RAID1 = 11,
    VDS_RT_RAID2 = 12,
    VDS_RT_RAID3 = 13,
    VDS_RT_RAID4 = 14,
    VDS_RT_RAID5 = 15,
    VDS_RT_RAID6 = 16,
    VDS_RT_RAID01 = 17,
    VDS_RT_RAID03 = 18,
    VDS_RT_RAID05 = 19,
    VDS_RT_RAID10 = 20,
    VDS_RT_RAID15 = 21,
    VDS_RT_RAID30 = 22,
    VDS_RT_RAID50 = 23,
    VDS_RT_RAID51 = 24,
    VDS_RT_RAID53 = 25,
    VDS_RT_RAID60 = 26,
    VDS_RT_RAID61 = 27,
};
pub const VDS_RT_UNKNOWN = VDS_RAID_TYPE.VDS_RT_UNKNOWN;
pub const VDS_RT_RAID0 = VDS_RAID_TYPE.VDS_RT_RAID0;
pub const VDS_RT_RAID1 = VDS_RAID_TYPE.VDS_RT_RAID1;
pub const VDS_RT_RAID2 = VDS_RAID_TYPE.VDS_RT_RAID2;
pub const VDS_RT_RAID3 = VDS_RAID_TYPE.VDS_RT_RAID3;
pub const VDS_RT_RAID4 = VDS_RAID_TYPE.VDS_RT_RAID4;
pub const VDS_RT_RAID5 = VDS_RAID_TYPE.VDS_RT_RAID5;
pub const VDS_RT_RAID6 = VDS_RAID_TYPE.VDS_RT_RAID6;
pub const VDS_RT_RAID01 = VDS_RAID_TYPE.VDS_RT_RAID01;
pub const VDS_RT_RAID03 = VDS_RAID_TYPE.VDS_RT_RAID03;
pub const VDS_RT_RAID05 = VDS_RAID_TYPE.VDS_RT_RAID05;
pub const VDS_RT_RAID10 = VDS_RAID_TYPE.VDS_RT_RAID10;
pub const VDS_RT_RAID15 = VDS_RAID_TYPE.VDS_RT_RAID15;
pub const VDS_RT_RAID30 = VDS_RAID_TYPE.VDS_RT_RAID30;
pub const VDS_RT_RAID50 = VDS_RAID_TYPE.VDS_RT_RAID50;
pub const VDS_RT_RAID51 = VDS_RAID_TYPE.VDS_RT_RAID51;
pub const VDS_RT_RAID53 = VDS_RAID_TYPE.VDS_RT_RAID53;
pub const VDS_RT_RAID60 = VDS_RAID_TYPE.VDS_RT_RAID60;
pub const VDS_RT_RAID61 = VDS_RAID_TYPE.VDS_RT_RAID61;

pub const VDS_POOL_CUSTOM_ATTRIBUTES = extern struct {
    pwszName: PWSTR,
    pwszValue: PWSTR,
};

pub const VDS_POOL_ATTRIBUTES = extern struct {
    ullAttributeMask: u64,
    raidType: VDS_RAID_TYPE,
    busType: VDS_STORAGE_BUS_TYPE,
    pwszIntendedUsage: PWSTR,
    bSpinDown: BOOL,
    bIsThinProvisioned: BOOL,
    ullProvisionedSpace: u64,
    bNoSinglePointOfFailure: BOOL,
    ulDataRedundancyMax: u32,
    ulDataRedundancyMin: u32,
    ulDataRedundancyDefault: u32,
    ulPackageRedundancyMax: u32,
    ulPackageRedundancyMin: u32,
    ulPackageRedundancyDefault: u32,
    ulStripeSize: u32,
    ulStripeSizeMax: u32,
    ulStripeSizeMin: u32,
    ulDefaultStripeSize: u32,
    ulNumberOfColumns: u32,
    ulNumberOfColumnsMax: u32,
    ulNumberOfColumnsMin: u32,
    ulDefaultNumberofColumns: u32,
    ulDataAvailabilityHint: u32,
    ulAccessRandomnessHint: u32,
    ulAccessDirectionHint: u32,
    ulAccessSizeHint: u32,
    ulAccessLatencyHint: u32,
    ulAccessBandwidthWeightHint: u32,
    ulStorageCostHint: u32,
    ulStorageEfficiencyHint: u32,
    ulNumOfCustomAttributes: u32,
    pPoolCustomAttributes: *VDS_POOL_CUSTOM_ATTRIBUTES,
    bReserved1: BOOL,
    bReserved2: BOOL,
    ulReserved1: u32,
    ulReserved2: u32,
    ullReserved1: u64,
    ullReserved2: u64,
};

pub const VDS_STORAGE_POOL_PROP = extern struct {
    id: Guid,
    status: VDS_STORAGE_POOL_STATUS,
    health: VDS_HEALTH,
    type: VDS_STORAGE_POOL_TYPE,
    pwszName: PWSTR,
    pwszDescription: PWSTR,
    ullTotalConsumedSpace: u64,
    ullTotalManagedSpace: u64,
    ullRemainingFreeSpace: u64,
};

pub const VDS_STORAGE_POOL_DRIVE_EXTENT = extern struct {
    id: Guid,
    ullSize: u64,
    bUsed: BOOL,
};

const IID_IVdsHwProvider_Value = @import("../zig.zig").Guid.initString("d99bdaae-b13a-4178-9fdb-e27f16b4603e");
pub const IID_IVdsHwProvider = &IID_IVdsHwProvider_Value;
pub const IVdsHwProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QuerySubSystems: fn(
            self: *const IVdsHwProvider,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reenumerate: fn(
            self: *const IVdsHwProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IVdsHwProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProvider_QuerySubSystems(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProvider.VTable, self.vtable).QuerySubSystems(@ptrCast(*const IVdsHwProvider, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProvider_Reenumerate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProvider.VTable, self.vtable).Reenumerate(@ptrCast(*const IVdsHwProvider, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProvider_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProvider.VTable, self.vtable).Refresh(@ptrCast(*const IVdsHwProvider, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsHwProviderType_Value = @import("../zig.zig").Guid.initString("3e0f5166-542d-4fc6-947a-012174240b7e");
pub const IID_IVdsHwProviderType = &IID_IVdsHwProviderType_Value;
pub const IVdsHwProviderType = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProviderType: fn(
            self: *const IVdsHwProviderType,
            pType: *VDS_HWPROVIDER_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderType_GetProviderType(self: *const T, pType: *VDS_HWPROVIDER_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderType.VTable, self.vtable).GetProviderType(@ptrCast(*const IVdsHwProviderType, self), pType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsHwProviderType2_Value = @import("../zig.zig").Guid.initString("8190236f-c4d0-4e81-8011-d69512fcc984");
pub const IID_IVdsHwProviderType2 = &IID_IVdsHwProviderType2_Value;
pub const IVdsHwProviderType2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProviderType2: fn(
            self: *const IVdsHwProviderType2,
            pType: *VDS_HWPROVIDER_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderType2_GetProviderType2(self: *const T, pType: *VDS_HWPROVIDER_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderType2.VTable, self.vtable).GetProviderType2(@ptrCast(*const IVdsHwProviderType2, self), pType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsHwProviderStoragePools_Value = @import("../zig.zig").Guid.initString("d5b5937a-f188-4c79-b86c-11c920ad11b8");
pub const IID_IVdsHwProviderStoragePools = &IID_IVdsHwProviderStoragePools_Value;
pub const IVdsHwProviderStoragePools = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryStoragePools: fn(
            self: *const IVdsHwProviderStoragePools,
            ulFlags: u32,
            ullRemainingFreeSpace: u64,
            pPoolAttributes: ?*VDS_POOL_ATTRIBUTES,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateLunInStoragePool: fn(
            self: *const IVdsHwProviderStoragePools,
            type: VDS_LUN_TYPE,
            ullSizeInBytes: u64,
            StoragePoolId: Guid,
            pwszUnmaskingList: PWSTR,
            pHints2: ?*VDS_HINTS2,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMaxLunCreateSizeInStoragePool: fn(
            self: *const IVdsHwProviderStoragePools,
            type: VDS_LUN_TYPE,
            StoragePoolId: Guid,
            pHints2: ?*VDS_HINTS2,
            pullMaxLunSize: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderStoragePools_QueryStoragePools(self: *const T, ulFlags: u32, ullRemainingFreeSpace: u64, pPoolAttributes: ?*VDS_POOL_ATTRIBUTES, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderStoragePools.VTable, self.vtable).QueryStoragePools(@ptrCast(*const IVdsHwProviderStoragePools, self), ulFlags, ullRemainingFreeSpace, pPoolAttributes, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderStoragePools_CreateLunInStoragePool(self: *const T, type: VDS_LUN_TYPE, ullSizeInBytes: u64, StoragePoolId: Guid, pwszUnmaskingList: PWSTR, pHints2: ?*VDS_HINTS2, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderStoragePools.VTable, self.vtable).CreateLunInStoragePool(@ptrCast(*const IVdsHwProviderStoragePools, self), type, ullSizeInBytes, StoragePoolId, pwszUnmaskingList, pHints2, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderStoragePools_QueryMaxLunCreateSizeInStoragePool(self: *const T, type: VDS_LUN_TYPE, StoragePoolId: Guid, pHints2: ?*VDS_HINTS2, pullMaxLunSize: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderStoragePools.VTable, self.vtable).QueryMaxLunCreateSizeInStoragePool(@ptrCast(*const IVdsHwProviderStoragePools, self), type, StoragePoolId, pHints2, pullMaxLunSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsSubSystem_Value = @import("../zig.zig").Guid.initString("6fcee2d3-6d90-4f91-80e2-a5c7caaca9d8");
pub const IID_IVdsSubSystem = &IID_IVdsSubSystem_Value;
pub const IVdsSubSystem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsSubSystem,
            pSubSystemProp: *VDS_SUB_SYSTEM_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProvider: fn(
            self: *const IVdsSubSystem,
            ppProvider: ?*?*IVdsProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryControllers: fn(
            self: *const IVdsSubSystem,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryLuns: fn(
            self: *const IVdsSubSystem,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDrives: fn(
            self: *const IVdsSubSystem,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrive: fn(
            self: *const IVdsSubSystem,
            sBusNumber: i16,
            sSlotNumber: i16,
            ppDrive: ?*?*IVdsDrive,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reenumerate: fn(
            self: *const IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControllerStatus: fn(
            self: *const IVdsSubSystem,
            pOnlineControllerIdArray: [*]Guid,
            lNumberOfOnlineControllers: i32,
            pOfflineControllerIdArray: [*]Guid,
            lNumberOfOfflineControllers: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateLun: fn(
            self: *const IVdsSubSystem,
            type: VDS_LUN_TYPE,
            ullSizeInBytes: u64,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pwszUnmaskingList: PWSTR,
            pHints: ?*VDS_HINTS,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceDrive: fn(
            self: *const IVdsSubSystem,
            DriveToBeReplaced: Guid,
            ReplacementDrive: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsSubSystem,
            status: VDS_SUB_SYSTEM_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMaxLunCreateSize: fn(
            self: *const IVdsSubSystem,
            type: VDS_LUN_TYPE,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pHints: ?*VDS_HINTS,
            pullMaxLunSize: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_GetProperties(self: *const T, pSubSystemProp: *VDS_SUB_SYSTEM_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsSubSystem, self), pSubSystemProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_GetProvider(self: *const T, ppProvider: ?*?*IVdsProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).GetProvider(@ptrCast(*const IVdsSubSystem, self), ppProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_QueryControllers(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).QueryControllers(@ptrCast(*const IVdsSubSystem, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_QueryLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).QueryLuns(@ptrCast(*const IVdsSubSystem, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_QueryDrives(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).QueryDrives(@ptrCast(*const IVdsSubSystem, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_GetDrive(self: *const T, sBusNumber: i16, sSlotNumber: i16, ppDrive: ?*?*IVdsDrive) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).GetDrive(@ptrCast(*const IVdsSubSystem, self), sBusNumber, sSlotNumber, ppDrive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_Reenumerate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).Reenumerate(@ptrCast(*const IVdsSubSystem, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_SetControllerStatus(self: *const T, pOnlineControllerIdArray: [*]Guid, lNumberOfOnlineControllers: i32, pOfflineControllerIdArray: [*]Guid, lNumberOfOfflineControllers: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).SetControllerStatus(@ptrCast(*const IVdsSubSystem, self), pOnlineControllerIdArray, lNumberOfOnlineControllers, pOfflineControllerIdArray, lNumberOfOfflineControllers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_CreateLun(self: *const T, type: VDS_LUN_TYPE, ullSizeInBytes: u64, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pwszUnmaskingList: PWSTR, pHints: ?*VDS_HINTS, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).CreateLun(@ptrCast(*const IVdsSubSystem, self), type, ullSizeInBytes, pDriveIdArray, lNumberOfDrives, pwszUnmaskingList, pHints, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_ReplaceDrive(self: *const T, DriveToBeReplaced: Guid, ReplacementDrive: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).ReplaceDrive(@ptrCast(*const IVdsSubSystem, self), DriveToBeReplaced, ReplacementDrive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_SetStatus(self: *const T, status: VDS_SUB_SYSTEM_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsSubSystem, self), status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem_QueryMaxLunCreateSize(self: *const T, type: VDS_LUN_TYPE, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pHints: ?*VDS_HINTS, pullMaxLunSize: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem.VTable, self.vtable).QueryMaxLunCreateSize(@ptrCast(*const IVdsSubSystem, self), type, pDriveIdArray, lNumberOfDrives, pHints, pullMaxLunSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsSubSystem2_Value = @import("../zig.zig").Guid.initString("be666735-7800-4a77-9d9c-40f85b87e292");
pub const IID_IVdsSubSystem2 = &IID_IVdsSubSystem2_Value;
pub const IVdsSubSystem2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties2: fn(
            self: *const IVdsSubSystem2,
            pSubSystemProp2: *VDS_SUB_SYSTEM_PROP2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrive2: fn(
            self: *const IVdsSubSystem2,
            sBusNumber: i16,
            sSlotNumber: i16,
            ulEnclosureNumber: u32,
            ppDrive: ?*?*IVdsDrive,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateLun2: fn(
            self: *const IVdsSubSystem2,
            type: VDS_LUN_TYPE,
            ullSizeInBytes: u64,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pwszUnmaskingList: PWSTR,
            pHints2: ?*VDS_HINTS2,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMaxLunCreateSize2: fn(
            self: *const IVdsSubSystem2,
            type: VDS_LUN_TYPE,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pHints2: ?*VDS_HINTS2,
            pullMaxLunSize: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem2_GetProperties2(self: *const T, pSubSystemProp2: *VDS_SUB_SYSTEM_PROP2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem2.VTable, self.vtable).GetProperties2(@ptrCast(*const IVdsSubSystem2, self), pSubSystemProp2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem2_GetDrive2(self: *const T, sBusNumber: i16, sSlotNumber: i16, ulEnclosureNumber: u32, ppDrive: ?*?*IVdsDrive) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem2.VTable, self.vtable).GetDrive2(@ptrCast(*const IVdsSubSystem2, self), sBusNumber, sSlotNumber, ulEnclosureNumber, ppDrive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem2_CreateLun2(self: *const T, type: VDS_LUN_TYPE, ullSizeInBytes: u64, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pwszUnmaskingList: PWSTR, pHints2: ?*VDS_HINTS2, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem2.VTable, self.vtable).CreateLun2(@ptrCast(*const IVdsSubSystem2, self), type, ullSizeInBytes, pDriveIdArray, lNumberOfDrives, pwszUnmaskingList, pHints2, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystem2_QueryMaxLunCreateSize2(self: *const T, type: VDS_LUN_TYPE, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pHints2: ?*VDS_HINTS2, pullMaxLunSize: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystem2.VTable, self.vtable).QueryMaxLunCreateSize2(@ptrCast(*const IVdsSubSystem2, self), type, pDriveIdArray, lNumberOfDrives, pHints2, pullMaxLunSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsSubSystemNaming_Value = @import("../zig.zig").Guid.initString("0d70faa3-9cd4-4900-aa20-6981b6aafc75");
pub const IID_IVdsSubSystemNaming = &IID_IVdsSubSystemNaming_Value;
pub const IVdsSubSystemNaming = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFriendlyName: fn(
            self: *const IVdsSubSystemNaming,
            pwszFriendlyName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemNaming_SetFriendlyName(self: *const T, pwszFriendlyName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemNaming.VTable, self.vtable).SetFriendlyName(@ptrCast(*const IVdsSubSystemNaming, self), pwszFriendlyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsSubSystemIscsi_Value = @import("../zig.zig").Guid.initString("0027346f-40d0-4b45-8cec-5906dc0380c8");
pub const IID_IVdsSubSystemIscsi = &IID_IVdsSubSystemIscsi_Value;
pub const IVdsSubSystemIscsi = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryTargets: fn(
            self: *const IVdsSubSystemIscsi,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPortals: fn(
            self: *const IVdsSubSystemIscsi,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTarget: fn(
            self: *const IVdsSubSystemIscsi,
            pwszIscsiName: ?PWSTR,
            pwszFriendlyName: PWSTR,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIpsecGroupPresharedKey: fn(
            self: *const IVdsSubSystemIscsi,
            pIpsecKey: ?*VDS_ISCSI_IPSEC_KEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemIscsi_QueryTargets(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemIscsi.VTable, self.vtable).QueryTargets(@ptrCast(*const IVdsSubSystemIscsi, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemIscsi_QueryPortals(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemIscsi.VTable, self.vtable).QueryPortals(@ptrCast(*const IVdsSubSystemIscsi, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemIscsi_CreateTarget(self: *const T, pwszIscsiName: ?PWSTR, pwszFriendlyName: PWSTR, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemIscsi.VTable, self.vtable).CreateTarget(@ptrCast(*const IVdsSubSystemIscsi, self), pwszIscsiName, pwszFriendlyName, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemIscsi_SetIpsecGroupPresharedKey(self: *const T, pIpsecKey: ?*VDS_ISCSI_IPSEC_KEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemIscsi.VTable, self.vtable).SetIpsecGroupPresharedKey(@ptrCast(*const IVdsSubSystemIscsi, self), pIpsecKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsSubSystemInterconnect_Value = @import("../zig.zig").Guid.initString("9e6fa560-c141-477b-83ba-0b6c38f7febf");
pub const IID_IVdsSubSystemInterconnect = &IID_IVdsSubSystemInterconnect_Value;
pub const IVdsSubSystemInterconnect = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSupportedInterconnects: fn(
            self: *const IVdsSubSystemInterconnect,
            pulSupportedInterconnectsFlag: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsSubSystemInterconnect_GetSupportedInterconnects(self: *const T, pulSupportedInterconnectsFlag: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsSubSystemInterconnect.VTable, self.vtable).GetSupportedInterconnects(@ptrCast(*const IVdsSubSystemInterconnect, self), pulSupportedInterconnectsFlag);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsControllerPort_Value = @import("../zig.zig").Guid.initString("18691d0d-4e7f-43e8-92e4-cf44beeed11c");
pub const IID_IVdsControllerPort = &IID_IVdsControllerPort_Value;
pub const IVdsControllerPort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsControllerPort,
            pPortProp: *VDS_PORT_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetController: fn(
            self: *const IVdsControllerPort,
            ppController: ?*?*IVdsController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedLuns: fn(
            self: *const IVdsControllerPort,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IVdsControllerPort,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsControllerPort,
            status: VDS_PORT_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_GetProperties(self: *const T, pPortProp: *VDS_PORT_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsControllerPort, self), pPortProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_GetController(self: *const T, ppController: ?*?*IVdsController) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).GetController(@ptrCast(*const IVdsControllerPort, self), ppController);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_QueryAssociatedLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).QueryAssociatedLuns(@ptrCast(*const IVdsControllerPort, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).Reset(@ptrCast(*const IVdsControllerPort, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerPort_SetStatus(self: *const T, status: VDS_PORT_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerPort.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsControllerPort, self), status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsController_Value = @import("../zig.zig").Guid.initString("cb53d96e-dffb-474a-a078-790d1e2bc082");
pub const IID_IVdsController = &IID_IVdsController_Value;
pub const IVdsController = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsController,
            pControllerProp: *VDS_CONTROLLER_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsController,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPortProperties: fn(
            self: *const IVdsController,
            sPortNumber: i16,
            pPortProp: *VDS_PORT_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushCache: fn(
            self: *const IVdsController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateCache: fn(
            self: *const IVdsController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IVdsController,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedLuns: fn(
            self: *const IVdsController,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsController,
            status: VDS_CONTROLLER_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_GetProperties(self: *const T, pControllerProp: *VDS_CONTROLLER_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsController, self), pControllerProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsController, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_GetPortProperties(self: *const T, sPortNumber: i16, pPortProp: *VDS_PORT_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).GetPortProperties(@ptrCast(*const IVdsController, self), sPortNumber, pPortProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_FlushCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).FlushCache(@ptrCast(*const IVdsController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_InvalidateCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).InvalidateCache(@ptrCast(*const IVdsController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).Reset(@ptrCast(*const IVdsController, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_QueryAssociatedLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).QueryAssociatedLuns(@ptrCast(*const IVdsController, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsController_SetStatus(self: *const T, status: VDS_CONTROLLER_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsController.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsController, self), status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsControllerControllerPort_Value = @import("../zig.zig").Guid.initString("ca5d735f-6bae-42c0-b30e-f2666045ce71");
pub const IID_IVdsControllerControllerPort = &IID_IVdsControllerControllerPort_Value;
pub const IVdsControllerControllerPort = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryControllerPorts: fn(
            self: *const IVdsControllerControllerPort,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsControllerControllerPort_QueryControllerPorts(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsControllerControllerPort.VTable, self.vtable).QueryControllerPorts(@ptrCast(*const IVdsControllerControllerPort, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsDrive_Value = @import("../zig.zig").Guid.initString("ff24efa4-aade-4b6b-898b-eaa6a20887c7");
pub const IID_IVdsDrive = &IID_IVdsDrive_Value;
pub const IVdsDrive = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsDrive,
            pDriveProp: *VDS_DRIVE_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsDrive,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryExtents: fn(
            self: *const IVdsDrive,
            ppExtentArray: ?[*]?*VDS_DRIVE_EXTENT,
            plNumberOfExtents: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IVdsDrive,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearFlags: fn(
            self: *const IVdsDrive,
            ulFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsDrive,
            status: VDS_DRIVE_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_GetProperties(self: *const T, pDriveProp: *VDS_DRIVE_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsDrive, self), pDriveProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsDrive, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_QueryExtents(self: *const T, ppExtentArray: ?[*]?*VDS_DRIVE_EXTENT, plNumberOfExtents: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).QueryExtents(@ptrCast(*const IVdsDrive, self), ppExtentArray, plNumberOfExtents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_SetFlags(self: *const T, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).SetFlags(@ptrCast(*const IVdsDrive, self), ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_ClearFlags(self: *const T, ulFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).ClearFlags(@ptrCast(*const IVdsDrive, self), ulFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive_SetStatus(self: *const T, status: VDS_DRIVE_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsDrive, self), status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsDrive2_Value = @import("../zig.zig").Guid.initString("60b5a730-addf-4436-8ca7-5769e2d1ffa4");
pub const IID_IVdsDrive2 = &IID_IVdsDrive2_Value;
pub const IVdsDrive2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties2: fn(
            self: *const IVdsDrive2,
            pDriveProp2: *VDS_DRIVE_PROP2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsDrive2_GetProperties2(self: *const T, pDriveProp2: *VDS_DRIVE_PROP2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsDrive2.VTable, self.vtable).GetProperties2(@ptrCast(*const IVdsDrive2, self), pDriveProp2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsLun_Value = @import("../zig.zig").Guid.initString("3540a9c7-e60f-4111-a840-8bba6c2c83d8");
pub const IID_IVdsLun = &IID_IVdsLun_Value;
pub const IVdsLun = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsLun,
            pLunProp: *VDS_LUN_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsLun,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentificationData: fn(
            self: *const IVdsLun,
            pLunInfo: *VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryActiveControllers: fn(
            self: *const IVdsLun,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Extend: fn(
            self: *const IVdsLun,
            ullNumberOfBytesToAdd: u64,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shrink: fn(
            self: *const IVdsLun,
            ullNumberOfBytesToRemove: u64,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPlexes: fn(
            self: *const IVdsLun,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPlex: fn(
            self: *const IVdsLun,
            lunId: Guid,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePlex: fn(
            self: *const IVdsLun,
            plexId: Guid,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Recover: fn(
            self: *const IVdsLun,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMask: fn(
            self: *const IVdsLun,
            pwszUnmaskingList: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IVdsLun,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssociateControllers: fn(
            self: *const IVdsLun,
            pActiveControllerIdArray: ?[*]Guid,
            lNumberOfActiveControllers: i32,
            pInactiveControllerIdArray: ?[*]Guid,
            lNumberOfInactiveControllers: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHints: fn(
            self: *const IVdsLun,
            pHints: *VDS_HINTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyHints: fn(
            self: *const IVdsLun,
            pHints: *VDS_HINTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsLun,
            status: VDS_LUN_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMaxLunExtendSize: fn(
            self: *const IVdsLun,
            pDriveIdArray: ?[*]Guid,
            lNumberOfDrives: i32,
            pullMaxBytesToBeAdded: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_GetProperties(self: *const T, pLunProp: *VDS_LUN_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsLun, self), pLunProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsLun, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_GetIdentificationData(self: *const T, pLunInfo: *VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).GetIdentificationData(@ptrCast(*const IVdsLun, self), pLunInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_QueryActiveControllers(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).QueryActiveControllers(@ptrCast(*const IVdsLun, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_Extend(self: *const T, ullNumberOfBytesToAdd: u64, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).Extend(@ptrCast(*const IVdsLun, self), ullNumberOfBytesToAdd, pDriveIdArray, lNumberOfDrives, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_Shrink(self: *const T, ullNumberOfBytesToRemove: u64, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).Shrink(@ptrCast(*const IVdsLun, self), ullNumberOfBytesToRemove, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_QueryPlexes(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).QueryPlexes(@ptrCast(*const IVdsLun, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_AddPlex(self: *const T, lunId: Guid, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).AddPlex(@ptrCast(*const IVdsLun, self), lunId, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_RemovePlex(self: *const T, plexId: Guid, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).RemovePlex(@ptrCast(*const IVdsLun, self), plexId, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_Recover(self: *const T, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).Recover(@ptrCast(*const IVdsLun, self), ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_SetMask(self: *const T, pwszUnmaskingList: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).SetMask(@ptrCast(*const IVdsLun, self), pwszUnmaskingList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_Delete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).Delete(@ptrCast(*const IVdsLun, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_AssociateControllers(self: *const T, pActiveControllerIdArray: ?[*]Guid, lNumberOfActiveControllers: i32, pInactiveControllerIdArray: ?[*]Guid, lNumberOfInactiveControllers: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).AssociateControllers(@ptrCast(*const IVdsLun, self), pActiveControllerIdArray, lNumberOfActiveControllers, pInactiveControllerIdArray, lNumberOfInactiveControllers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_QueryHints(self: *const T, pHints: *VDS_HINTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).QueryHints(@ptrCast(*const IVdsLun, self), pHints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_ApplyHints(self: *const T, pHints: *VDS_HINTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).ApplyHints(@ptrCast(*const IVdsLun, self), pHints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_SetStatus(self: *const T, status: VDS_LUN_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsLun, self), status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun_QueryMaxLunExtendSize(self: *const T, pDriveIdArray: ?[*]Guid, lNumberOfDrives: i32, pullMaxBytesToBeAdded: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun.VTable, self.vtable).QueryMaxLunExtendSize(@ptrCast(*const IVdsLun, self), pDriveIdArray, lNumberOfDrives, pullMaxBytesToBeAdded);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsLun2_Value = @import("../zig.zig").Guid.initString("e5b3a735-9efb-499a-8071-4394d9ee6fcb");
pub const IID_IVdsLun2 = &IID_IVdsLun2_Value;
pub const IVdsLun2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryHints2: fn(
            self: *const IVdsLun2,
            pHints2: *VDS_HINTS2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyHints2: fn(
            self: *const IVdsLun2,
            pHints2: *VDS_HINTS2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun2_QueryHints2(self: *const T, pHints2: *VDS_HINTS2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun2.VTable, self.vtable).QueryHints2(@ptrCast(*const IVdsLun2, self), pHints2);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLun2_ApplyHints2(self: *const T, pHints2: *VDS_HINTS2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLun2.VTable, self.vtable).ApplyHints2(@ptrCast(*const IVdsLun2, self), pHints2);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsLunNaming_Value = @import("../zig.zig").Guid.initString("907504cb-6b4e-4d88-a34d-17ba661fbb06");
pub const IID_IVdsLunNaming = &IID_IVdsLunNaming_Value;
pub const IVdsLunNaming = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetFriendlyName: fn(
            self: *const IVdsLunNaming,
            pwszFriendlyName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunNaming_SetFriendlyName(self: *const T, pwszFriendlyName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunNaming.VTable, self.vtable).SetFriendlyName(@ptrCast(*const IVdsLunNaming, self), pwszFriendlyName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsLunNumber_Value = @import("../zig.zig").Guid.initString("d3f95e46-54b3-41f9-b678-0f1871443a08");
pub const IID_IVdsLunNumber = &IID_IVdsLunNumber_Value;
pub const IVdsLunNumber = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLunNumber: fn(
            self: *const IVdsLunNumber,
            pulLunNumber: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunNumber_GetLunNumber(self: *const T, pulLunNumber: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunNumber.VTable, self.vtable).GetLunNumber(@ptrCast(*const IVdsLunNumber, self), pulLunNumber);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsLunControllerPorts_Value = @import("../zig.zig").Guid.initString("451fe266-da6d-406a-bb60-82e534f85aeb");
pub const IID_IVdsLunControllerPorts = &IID_IVdsLunControllerPorts_Value;
pub const IVdsLunControllerPorts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateControllerPorts: fn(
            self: *const IVdsLunControllerPorts,
            pActiveControllerPortIdArray: ?[*]Guid,
            lNumberOfActiveControllerPorts: i32,
            pInactiveControllerPortIdArray: ?[*]Guid,
            lNumberOfInactiveControllerPorts: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryActiveControllerPorts: fn(
            self: *const IVdsLunControllerPorts,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunControllerPorts_AssociateControllerPorts(self: *const T, pActiveControllerPortIdArray: ?[*]Guid, lNumberOfActiveControllerPorts: i32, pInactiveControllerPortIdArray: ?[*]Guid, lNumberOfInactiveControllerPorts: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunControllerPorts.VTable, self.vtable).AssociateControllerPorts(@ptrCast(*const IVdsLunControllerPorts, self), pActiveControllerPortIdArray, lNumberOfActiveControllerPorts, pInactiveControllerPortIdArray, lNumberOfInactiveControllerPorts);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunControllerPorts_QueryActiveControllerPorts(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunControllerPorts.VTable, self.vtable).QueryActiveControllerPorts(@ptrCast(*const IVdsLunControllerPorts, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsLunMpio_Value = @import("../zig.zig").Guid.initString("7c5fbae3-333a-48a1-a982-33c15788cde3");
pub const IID_IVdsLunMpio = &IID_IVdsLunMpio_Value;
pub const IVdsLunMpio = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPathInfo: fn(
            self: *const IVdsLunMpio,
            ppPaths: ?[*]?*VDS_PATH_INFO,
            plNumberOfPaths: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLoadBalancePolicy: fn(
            self: *const IVdsLunMpio,
            pPolicy: *VDS_LOADBALANCE_POLICY_ENUM,
            ppPaths: ?[*]?*VDS_PATH_POLICY,
            plNumberOfPaths: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLoadBalancePolicy: fn(
            self: *const IVdsLunMpio,
            policy: VDS_LOADBALANCE_POLICY_ENUM,
            pPaths: ?[*]VDS_PATH_POLICY,
            lNumberOfPaths: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedLbPolicies: fn(
            self: *const IVdsLunMpio,
            pulLbFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunMpio_GetPathInfo(self: *const T, ppPaths: ?[*]?*VDS_PATH_INFO, plNumberOfPaths: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunMpio.VTable, self.vtable).GetPathInfo(@ptrCast(*const IVdsLunMpio, self), ppPaths, plNumberOfPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunMpio_GetLoadBalancePolicy(self: *const T, pPolicy: *VDS_LOADBALANCE_POLICY_ENUM, ppPaths: ?[*]?*VDS_PATH_POLICY, plNumberOfPaths: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunMpio.VTable, self.vtable).GetLoadBalancePolicy(@ptrCast(*const IVdsLunMpio, self), pPolicy, ppPaths, plNumberOfPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunMpio_SetLoadBalancePolicy(self: *const T, policy: VDS_LOADBALANCE_POLICY_ENUM, pPaths: ?[*]VDS_PATH_POLICY, lNumberOfPaths: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunMpio.VTable, self.vtable).SetLoadBalancePolicy(@ptrCast(*const IVdsLunMpio, self), policy, pPaths, lNumberOfPaths);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunMpio_GetSupportedLbPolicies(self: *const T, pulLbFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunMpio.VTable, self.vtable).GetSupportedLbPolicies(@ptrCast(*const IVdsLunMpio, self), pulLbFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsLunIscsi_Value = @import("../zig.zig").Guid.initString("0d7c1e64-b59b-45ae-b86a-2c2cc6a42067");
pub const IID_IVdsLunIscsi = &IID_IVdsLunIscsi_Value;
pub const IVdsLunIscsi = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AssociateTargets: fn(
            self: *const IVdsLunIscsi,
            pTargetIdArray: ?[*]Guid,
            lNumberOfTargets: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedTargets: fn(
            self: *const IVdsLunIscsi,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunIscsi_AssociateTargets(self: *const T, pTargetIdArray: ?[*]Guid, lNumberOfTargets: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunIscsi.VTable, self.vtable).AssociateTargets(@ptrCast(*const IVdsLunIscsi, self), pTargetIdArray, lNumberOfTargets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunIscsi_QueryAssociatedTargets(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunIscsi.VTable, self.vtable).QueryAssociatedTargets(@ptrCast(*const IVdsLunIscsi, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsLunPlex_Value = @import("../zig.zig").Guid.initString("0ee1a790-5d2e-4abb-8c99-c481e8be2138");
pub const IID_IVdsLunPlex = &IID_IVdsLunPlex_Value;
pub const IVdsLunPlex = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsLunPlex,
            pPlexProp: *VDS_LUN_PLEX_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLun: fn(
            self: *const IVdsLunPlex,
            ppLun: ?*?*IVdsLun,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryExtents: fn(
            self: *const IVdsLunPlex,
            ppExtentArray: ?[*]?*VDS_DRIVE_EXTENT,
            plNumberOfExtents: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryHints: fn(
            self: *const IVdsLunPlex,
            pHints: *VDS_HINTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ApplyHints: fn(
            self: *const IVdsLunPlex,
            pHints: *VDS_HINTS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_GetProperties(self: *const T, pPlexProp: *VDS_LUN_PLEX_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsLunPlex, self), pPlexProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_GetLun(self: *const T, ppLun: ?*?*IVdsLun) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).GetLun(@ptrCast(*const IVdsLunPlex, self), ppLun);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_QueryExtents(self: *const T, ppExtentArray: ?[*]?*VDS_DRIVE_EXTENT, plNumberOfExtents: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).QueryExtents(@ptrCast(*const IVdsLunPlex, self), ppExtentArray, plNumberOfExtents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_QueryHints(self: *const T, pHints: *VDS_HINTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).QueryHints(@ptrCast(*const IVdsLunPlex, self), pHints);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsLunPlex_ApplyHints(self: *const T, pHints: *VDS_HINTS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsLunPlex.VTable, self.vtable).ApplyHints(@ptrCast(*const IVdsLunPlex, self), pHints);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsIscsiPortal_Value = @import("../zig.zig").Guid.initString("7fa1499d-ec85-4a8a-a47b-ff69201fcd34");
pub const IID_IVdsIscsiPortal = &IID_IVdsIscsiPortal_Value;
pub const IVdsIscsiPortal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsIscsiPortal,
            pPortalProp: *VDS_ISCSI_PORTAL_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsIscsiPortal,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedPortalGroups: fn(
            self: *const IVdsIscsiPortal,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IVdsIscsiPortal,
            status: VDS_ISCSI_PORTAL_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIpsecTunnelAddress: fn(
            self: *const IVdsIscsiPortal,
            pTunnelAddress: *VDS_IPADDRESS,
            pDestinationAddress: *VDS_IPADDRESS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIpsecSecurity: fn(
            self: *const IVdsIscsiPortal,
            pInitiatorPortalAddress: *VDS_IPADDRESS,
            pullSecurityFlags: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIpsecSecurity: fn(
            self: *const IVdsIscsiPortal,
            pInitiatorPortalAddress: *VDS_IPADDRESS,
            ullSecurityFlags: u64,
            pIpsecKey: ?*VDS_ISCSI_IPSEC_KEY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_GetProperties(self: *const T, pPortalProp: *VDS_ISCSI_PORTAL_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsIscsiPortal, self), pPortalProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsIscsiPortal, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_QueryAssociatedPortalGroups(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).QueryAssociatedPortalGroups(@ptrCast(*const IVdsIscsiPortal, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_SetStatus(self: *const T, status: VDS_ISCSI_PORTAL_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).SetStatus(@ptrCast(*const IVdsIscsiPortal, self), status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_SetIpsecTunnelAddress(self: *const T, pTunnelAddress: *VDS_IPADDRESS, pDestinationAddress: *VDS_IPADDRESS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).SetIpsecTunnelAddress(@ptrCast(*const IVdsIscsiPortal, self), pTunnelAddress, pDestinationAddress);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_GetIpsecSecurity(self: *const T, pInitiatorPortalAddress: *VDS_IPADDRESS, pullSecurityFlags: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).GetIpsecSecurity(@ptrCast(*const IVdsIscsiPortal, self), pInitiatorPortalAddress, pullSecurityFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortal_SetIpsecSecurity(self: *const T, pInitiatorPortalAddress: *VDS_IPADDRESS, ullSecurityFlags: u64, pIpsecKey: ?*VDS_ISCSI_IPSEC_KEY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortal.VTable, self.vtable).SetIpsecSecurity(@ptrCast(*const IVdsIscsiPortal, self), pInitiatorPortalAddress, ullSecurityFlags, pIpsecKey);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsIscsiTarget_Value = @import("../zig.zig").Guid.initString("aa8f5055-83e5-4bcc-aa73-19851a36a849");
pub const IID_IVdsIscsiTarget = &IID_IVdsIscsiTarget_Value;
pub const IVdsIscsiTarget = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsIscsiTarget,
            pTargetProp: *VDS_ISCSI_TARGET_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubSystem: fn(
            self: *const IVdsIscsiTarget,
            ppSubSystem: ?*?*IVdsSubSystem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPortalGroups: fn(
            self: *const IVdsIscsiTarget,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedLuns: fn(
            self: *const IVdsIscsiTarget,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePortalGroup: fn(
            self: *const IVdsIscsiTarget,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IVdsIscsiTarget,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFriendlyName: fn(
            self: *const IVdsIscsiTarget,
            pwszFriendlyName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSharedSecret: fn(
            self: *const IVdsIscsiTarget,
            pTargetSharedSecret: ?*VDS_ISCSI_SHARED_SECRET,
            pwszInitiatorName: ?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RememberInitiatorSharedSecret: fn(
            self: *const IVdsIscsiTarget,
            pwszInitiatorName: PWSTR,
            pInitiatorSharedSecret: ?*VDS_ISCSI_SHARED_SECRET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConnectedInitiators: fn(
            self: *const IVdsIscsiTarget,
            pppwszInitiatorList: ?[*]?*?PWSTR,
            plNumberOfInitiators: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_GetProperties(self: *const T, pTargetProp: *VDS_ISCSI_TARGET_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsIscsiTarget, self), pTargetProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_GetSubSystem(self: *const T, ppSubSystem: ?*?*IVdsSubSystem) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).GetSubSystem(@ptrCast(*const IVdsIscsiTarget, self), ppSubSystem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_QueryPortalGroups(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).QueryPortalGroups(@ptrCast(*const IVdsIscsiTarget, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_QueryAssociatedLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).QueryAssociatedLuns(@ptrCast(*const IVdsIscsiTarget, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_CreatePortalGroup(self: *const T, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).CreatePortalGroup(@ptrCast(*const IVdsIscsiTarget, self), ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_Delete(self: *const T, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).Delete(@ptrCast(*const IVdsIscsiTarget, self), ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_SetFriendlyName(self: *const T, pwszFriendlyName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).SetFriendlyName(@ptrCast(*const IVdsIscsiTarget, self), pwszFriendlyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_SetSharedSecret(self: *const T, pTargetSharedSecret: ?*VDS_ISCSI_SHARED_SECRET, pwszInitiatorName: ?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).SetSharedSecret(@ptrCast(*const IVdsIscsiTarget, self), pTargetSharedSecret, pwszInitiatorName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_RememberInitiatorSharedSecret(self: *const T, pwszInitiatorName: PWSTR, pInitiatorSharedSecret: ?*VDS_ISCSI_SHARED_SECRET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).RememberInitiatorSharedSecret(@ptrCast(*const IVdsIscsiTarget, self), pwszInitiatorName, pInitiatorSharedSecret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiTarget_GetConnectedInitiators(self: *const T, pppwszInitiatorList: ?[*]?*?PWSTR, plNumberOfInitiators: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiTarget.VTable, self.vtable).GetConnectedInitiators(@ptrCast(*const IVdsIscsiTarget, self), pppwszInitiatorList, plNumberOfInitiators);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsIscsiPortalGroup_Value = @import("../zig.zig").Guid.initString("fef5f89d-a3dd-4b36-bf28-e7dde045c593");
pub const IID_IVdsIscsiPortalGroup = &IID_IVdsIscsiPortalGroup_Value;
pub const IVdsIscsiPortalGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperties: fn(
            self: *const IVdsIscsiPortalGroup,
            pPortalGroupProp: *VDS_ISCSI_PORTALGROUP_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTarget: fn(
            self: *const IVdsIscsiPortalGroup,
            ppTarget: ?*?*IVdsIscsiTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssociatedPortals: fn(
            self: *const IVdsIscsiPortalGroup,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPortal: fn(
            self: *const IVdsIscsiPortalGroup,
            portalId: Guid,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemovePortal: fn(
            self: *const IVdsIscsiPortalGroup,
            portalId: Guid,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IVdsIscsiPortalGroup,
            ppAsync: ?*?*IVdsAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_GetProperties(self: *const T, pPortalGroupProp: *VDS_ISCSI_PORTALGROUP_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsIscsiPortalGroup, self), pPortalGroupProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_GetTarget(self: *const T, ppTarget: ?*?*IVdsIscsiTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).GetTarget(@ptrCast(*const IVdsIscsiPortalGroup, self), ppTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_QueryAssociatedPortals(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).QueryAssociatedPortals(@ptrCast(*const IVdsIscsiPortalGroup, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_AddPortal(self: *const T, portalId: Guid, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).AddPortal(@ptrCast(*const IVdsIscsiPortalGroup, self), portalId, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_RemovePortal(self: *const T, portalId: Guid, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).RemovePortal(@ptrCast(*const IVdsIscsiPortalGroup, self), portalId, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsIscsiPortalGroup_Delete(self: *const T, ppAsync: ?*?*IVdsAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsIscsiPortalGroup.VTable, self.vtable).Delete(@ptrCast(*const IVdsIscsiPortalGroup, self), ppAsync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsStoragePool_Value = @import("../zig.zig").Guid.initString("932ca8cf-0eb3-4ba8-9620-22665d7f8450");
pub const IID_IVdsStoragePool = &IID_IVdsStoragePool_Value;
pub const IVdsStoragePool = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProvider: fn(
            self: *const IVdsStoragePool,
            ppProvider: ?*?*IVdsProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperties: fn(
            self: *const IVdsStoragePool,
            pStoragePoolProp: *VDS_STORAGE_POOL_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAttributes: fn(
            self: *const IVdsStoragePool,
            pStoragePoolAttributes: *VDS_POOL_ATTRIBUTES,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDriveExtents: fn(
            self: *const IVdsStoragePool,
            ppExtentArray: ?[*]?*VDS_STORAGE_POOL_DRIVE_EXTENT,
            plNumberOfExtents: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAllocatedLuns: fn(
            self: *const IVdsStoragePool,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAllocatedStoragePools: fn(
            self: *const IVdsStoragePool,
            ppEnum: ?*?*IEnumVdsObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_GetProvider(self: *const T, ppProvider: ?*?*IVdsProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).GetProvider(@ptrCast(*const IVdsStoragePool, self), ppProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_GetProperties(self: *const T, pStoragePoolProp: *VDS_STORAGE_POOL_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).GetProperties(@ptrCast(*const IVdsStoragePool, self), pStoragePoolProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_GetAttributes(self: *const T, pStoragePoolAttributes: *VDS_POOL_ATTRIBUTES) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).GetAttributes(@ptrCast(*const IVdsStoragePool, self), pStoragePoolAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_QueryDriveExtents(self: *const T, ppExtentArray: ?[*]?*VDS_STORAGE_POOL_DRIVE_EXTENT, plNumberOfExtents: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).QueryDriveExtents(@ptrCast(*const IVdsStoragePool, self), ppExtentArray, plNumberOfExtents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_QueryAllocatedLuns(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).QueryAllocatedLuns(@ptrCast(*const IVdsStoragePool, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsStoragePool_QueryAllocatedStoragePools(self: *const T, ppEnum: ?*?*IEnumVdsObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsStoragePool.VTable, self.vtable).QueryAllocatedStoragePools(@ptrCast(*const IVdsStoragePool, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsMaintenance_Value = @import("../zig.zig").Guid.initString("daebeef3-8523-47ed-a2b9-05cecce2a1ae");
pub const IID_IVdsMaintenance = &IID_IVdsMaintenance_Value;
pub const IVdsMaintenance = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartMaintenance: fn(
            self: *const IVdsMaintenance,
            operation: VDS_MAINTENANCE_OPERATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopMaintenance: fn(
            self: *const IVdsMaintenance,
            operation: VDS_MAINTENANCE_OPERATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PulseMaintenance: fn(
            self: *const IVdsMaintenance,
            operation: VDS_MAINTENANCE_OPERATION,
            ulCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsMaintenance_StartMaintenance(self: *const T, operation: VDS_MAINTENANCE_OPERATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsMaintenance.VTable, self.vtable).StartMaintenance(@ptrCast(*const IVdsMaintenance, self), operation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsMaintenance_StopMaintenance(self: *const T, operation: VDS_MAINTENANCE_OPERATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsMaintenance.VTable, self.vtable).StopMaintenance(@ptrCast(*const IVdsMaintenance, self), operation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsMaintenance_PulseMaintenance(self: *const T, operation: VDS_MAINTENANCE_OPERATION, ulCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsMaintenance.VTable, self.vtable).PulseMaintenance(@ptrCast(*const IVdsMaintenance, self), operation, ulCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsHwProviderPrivate_Value = @import("../zig.zig").Guid.initString("98f17bf3-9f33-4f12-8714-8b4075092c2e");
pub const IID_IVdsHwProviderPrivate = &IID_IVdsHwProviderPrivate_Value;
pub const IVdsHwProviderPrivate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryIfCreatedLun: fn(
            self: *const IVdsHwProviderPrivate,
            pwszDevicePath: PWSTR,
            pVdsLunInformation: *VDS_LUN_INFORMATION,
            pLunId: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderPrivate_QueryIfCreatedLun(self: *const T, pwszDevicePath: PWSTR, pVdsLunInformation: *VDS_LUN_INFORMATION, pLunId: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderPrivate.VTable, self.vtable).QueryIfCreatedLun(@ptrCast(*const IVdsHwProviderPrivate, self), pwszDevicePath, pVdsLunInformation, pLunId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsHwProviderPrivateMpio_Value = @import("../zig.zig").Guid.initString("310a7715-ac2b-4c6f-9827-3d742f351676");
pub const IID_IVdsHwProviderPrivateMpio = &IID_IVdsHwProviderPrivateMpio_Value;
pub const IVdsHwProviderPrivateMpio = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetAllPathStatusesFromHbaPort: fn(
            self: *const IVdsHwProviderPrivateMpio,
            hbaPortProp: VDS_HBAPORT_PROP,
            status: VDS_PATH_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsHwProviderPrivateMpio_SetAllPathStatusesFromHbaPort(self: *const T, hbaPortProp: VDS_HBAPORT_PROP, status: VDS_PATH_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsHwProviderPrivateMpio.VTable, self.vtable).SetAllPathStatusesFromHbaPort(@ptrCast(*const IVdsHwProviderPrivateMpio, self), hbaPortProp, status);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVdsAdmin_Value = @import("../zig.zig").Guid.initString("d188e97d-85aa-4d33-abc6-26299a10ffc1");
pub const IID_IVdsAdmin = &IID_IVdsAdmin_Value;
pub const IVdsAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterProvider: fn(
            self: *const IVdsAdmin,
            providerId: Guid,
            providerClsid: Guid,
            pwszName: PWSTR,
            type: VDS_PROVIDER_TYPE,
            pwszMachineName: ?PWSTR,
            pwszVersion: PWSTR,
            guidVersionId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterProvider: fn(
            self: *const IVdsAdmin,
            providerId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAdmin_RegisterProvider(self: *const T, providerId: Guid, providerClsid: Guid, pwszName: PWSTR, type: VDS_PROVIDER_TYPE, pwszMachineName: ?PWSTR, pwszVersion: PWSTR, guidVersionId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAdmin.VTable, self.vtable).RegisterProvider(@ptrCast(*const IVdsAdmin, self), providerId, providerClsid, pwszName, type, pwszMachineName, pwszVersion, guidVersionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVdsAdmin_UnregisterProvider(self: *const T, providerId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVdsAdmin.VTable, self.vtable).UnregisterProvider(@ptrCast(*const IVdsAdmin, self), providerId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VSS_OBJECT_TYPE = extern enum(i32) {
    VSS_OBJECT_UNKNOWN = 0,
    VSS_OBJECT_NONE = 1,
    VSS_OBJECT_SNAPSHOT_SET = 2,
    VSS_OBJECT_SNAPSHOT = 3,
    VSS_OBJECT_PROVIDER = 4,
    COUNT = 5,
};
pub const VSS_OBJECT_UNKNOWN = VSS_OBJECT_TYPE.VSS_OBJECT_UNKNOWN;
pub const VSS_OBJECT_NONE = VSS_OBJECT_TYPE.VSS_OBJECT_NONE;
pub const VSS_OBJECT_SNAPSHOT_SET = VSS_OBJECT_TYPE.VSS_OBJECT_SNAPSHOT_SET;
pub const VSS_OBJECT_SNAPSHOT = VSS_OBJECT_TYPE.VSS_OBJECT_SNAPSHOT;
pub const VSS_OBJECT_PROVIDER = VSS_OBJECT_TYPE.VSS_OBJECT_PROVIDER;
pub const VSS_OBJECT_TYPE_COUNT = VSS_OBJECT_TYPE.COUNT;

pub const VSS_SNAPSHOT_STATE = extern enum(i32) {
    VSS_SS_UNKNOWN = 0,
    VSS_SS_PREPARING = 1,
    VSS_SS_PROCESSING_PREPARE = 2,
    VSS_SS_PREPARED = 3,
    VSS_SS_PROCESSING_PRECOMMIT = 4,
    VSS_SS_PRECOMMITTED = 5,
    VSS_SS_PROCESSING_COMMIT = 6,
    VSS_SS_COMMITTED = 7,
    VSS_SS_PROCESSING_POSTCOMMIT = 8,
    VSS_SS_PROCESSING_PREFINALCOMMIT = 9,
    VSS_SS_PREFINALCOMMITTED = 10,
    VSS_SS_PROCESSING_POSTFINALCOMMIT = 11,
    VSS_SS_CREATED = 12,
    VSS_SS_ABORTED = 13,
    VSS_SS_DELETED = 14,
    VSS_SS_POSTCOMMITTED = 15,
    VSS_SS_COUNT = 16,
};
pub const VSS_SS_UNKNOWN = VSS_SNAPSHOT_STATE.VSS_SS_UNKNOWN;
pub const VSS_SS_PREPARING = VSS_SNAPSHOT_STATE.VSS_SS_PREPARING;
pub const VSS_SS_PROCESSING_PREPARE = VSS_SNAPSHOT_STATE.VSS_SS_PROCESSING_PREPARE;
pub const VSS_SS_PREPARED = VSS_SNAPSHOT_STATE.VSS_SS_PREPARED;
pub const VSS_SS_PROCESSING_PRECOMMIT = VSS_SNAPSHOT_STATE.VSS_SS_PROCESSING_PRECOMMIT;
pub const VSS_SS_PRECOMMITTED = VSS_SNAPSHOT_STATE.VSS_SS_PRECOMMITTED;
pub const VSS_SS_PROCESSING_COMMIT = VSS_SNAPSHOT_STATE.VSS_SS_PROCESSING_COMMIT;
pub const VSS_SS_COMMITTED = VSS_SNAPSHOT_STATE.VSS_SS_COMMITTED;
pub const VSS_SS_PROCESSING_POSTCOMMIT = VSS_SNAPSHOT_STATE.VSS_SS_PROCESSING_POSTCOMMIT;
pub const VSS_SS_PROCESSING_PREFINALCOMMIT = VSS_SNAPSHOT_STATE.VSS_SS_PROCESSING_PREFINALCOMMIT;
pub const VSS_SS_PREFINALCOMMITTED = VSS_SNAPSHOT_STATE.VSS_SS_PREFINALCOMMITTED;
pub const VSS_SS_PROCESSING_POSTFINALCOMMIT = VSS_SNAPSHOT_STATE.VSS_SS_PROCESSING_POSTFINALCOMMIT;
pub const VSS_SS_CREATED = VSS_SNAPSHOT_STATE.VSS_SS_CREATED;
pub const VSS_SS_ABORTED = VSS_SNAPSHOT_STATE.VSS_SS_ABORTED;
pub const VSS_SS_DELETED = VSS_SNAPSHOT_STATE.VSS_SS_DELETED;
pub const VSS_SS_POSTCOMMITTED = VSS_SNAPSHOT_STATE.VSS_SS_POSTCOMMITTED;
pub const VSS_SS_COUNT = VSS_SNAPSHOT_STATE.VSS_SS_COUNT;

pub const VSS_VOLUME_SNAPSHOT_ATTRIBUTES = extern enum(i32) {
    VSS_VOLSNAP_ATTR_PERSISTENT = 1,
    VSS_VOLSNAP_ATTR_NO_AUTORECOVERY = 2,
    VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE = 4,
    VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE = 8,
    VSS_VOLSNAP_ATTR_NO_WRITERS = 16,
    VSS_VOLSNAP_ATTR_TRANSPORTABLE = 32,
    VSS_VOLSNAP_ATTR_NOT_SURFACED = 64,
    VSS_VOLSNAP_ATTR_NOT_TRANSACTED = 128,
    VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED = 65536,
    VSS_VOLSNAP_ATTR_DIFFERENTIAL = 131072,
    VSS_VOLSNAP_ATTR_PLEX = 262144,
    VSS_VOLSNAP_ATTR_IMPORTED = 524288,
    VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY = 1048576,
    VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY = 2097152,
    VSS_VOLSNAP_ATTR_AUTORECOVER = 4194304,
    VSS_VOLSNAP_ATTR_ROLLBACK_RECOVERY = 8388608,
    VSS_VOLSNAP_ATTR_DELAYED_POSTSNAPSHOT = 16777216,
    VSS_VOLSNAP_ATTR_TXF_RECOVERY = 33554432,
    VSS_VOLSNAP_ATTR_FILE_SHARE = 67108864,
};
pub const VSS_VOLSNAP_ATTR_PERSISTENT = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_PERSISTENT;
pub const VSS_VOLSNAP_ATTR_NO_AUTORECOVERY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_NO_AUTORECOVERY;
pub const VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_CLIENT_ACCESSIBLE;
pub const VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_NO_AUTO_RELEASE;
pub const VSS_VOLSNAP_ATTR_NO_WRITERS = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_NO_WRITERS;
pub const VSS_VOLSNAP_ATTR_TRANSPORTABLE = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_TRANSPORTABLE;
pub const VSS_VOLSNAP_ATTR_NOT_SURFACED = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_NOT_SURFACED;
pub const VSS_VOLSNAP_ATTR_NOT_TRANSACTED = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_NOT_TRANSACTED;
pub const VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_HARDWARE_ASSISTED;
pub const VSS_VOLSNAP_ATTR_DIFFERENTIAL = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_DIFFERENTIAL;
pub const VSS_VOLSNAP_ATTR_PLEX = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_PLEX;
pub const VSS_VOLSNAP_ATTR_IMPORTED = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_IMPORTED;
pub const VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_EXPOSED_LOCALLY;
pub const VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_EXPOSED_REMOTELY;
pub const VSS_VOLSNAP_ATTR_AUTORECOVER = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_AUTORECOVER;
pub const VSS_VOLSNAP_ATTR_ROLLBACK_RECOVERY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_ROLLBACK_RECOVERY;
pub const VSS_VOLSNAP_ATTR_DELAYED_POSTSNAPSHOT = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_DELAYED_POSTSNAPSHOT;
pub const VSS_VOLSNAP_ATTR_TXF_RECOVERY = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_TXF_RECOVERY;
pub const VSS_VOLSNAP_ATTR_FILE_SHARE = VSS_VOLUME_SNAPSHOT_ATTRIBUTES.VSS_VOLSNAP_ATTR_FILE_SHARE;

pub const VSS_SNAPSHOT_CONTEXT = extern enum(i32) {
    VSS_CTX_BACKUP = 0,
    VSS_CTX_FILE_SHARE_BACKUP = 16,
    VSS_CTX_NAS_ROLLBACK = 25,
    VSS_CTX_APP_ROLLBACK = 9,
    VSS_CTX_CLIENT_ACCESSIBLE = 29,
    VSS_CTX_CLIENT_ACCESSIBLE_WRITERS = 13,
    VSS_CTX_ALL = -1,
};
pub const VSS_CTX_BACKUP = VSS_SNAPSHOT_CONTEXT.VSS_CTX_BACKUP;
pub const VSS_CTX_FILE_SHARE_BACKUP = VSS_SNAPSHOT_CONTEXT.VSS_CTX_FILE_SHARE_BACKUP;
pub const VSS_CTX_NAS_ROLLBACK = VSS_SNAPSHOT_CONTEXT.VSS_CTX_NAS_ROLLBACK;
pub const VSS_CTX_APP_ROLLBACK = VSS_SNAPSHOT_CONTEXT.VSS_CTX_APP_ROLLBACK;
pub const VSS_CTX_CLIENT_ACCESSIBLE = VSS_SNAPSHOT_CONTEXT.VSS_CTX_CLIENT_ACCESSIBLE;
pub const VSS_CTX_CLIENT_ACCESSIBLE_WRITERS = VSS_SNAPSHOT_CONTEXT.VSS_CTX_CLIENT_ACCESSIBLE_WRITERS;
pub const VSS_CTX_ALL = VSS_SNAPSHOT_CONTEXT.VSS_CTX_ALL;

pub const VSS_PROVIDER_CAPABILITIES = extern enum(i32) {
    VSS_PRV_CAPABILITY_LEGACY = 1,
    VSS_PRV_CAPABILITY_COMPLIANT = 2,
    VSS_PRV_CAPABILITY_LUN_REPOINT = 4,
    VSS_PRV_CAPABILITY_LUN_RESYNC = 8,
    VSS_PRV_CAPABILITY_OFFLINE_CREATION = 16,
    VSS_PRV_CAPABILITY_MULTIPLE_IMPORT = 32,
    VSS_PRV_CAPABILITY_RECYCLING = 64,
    VSS_PRV_CAPABILITY_PLEX = 128,
    VSS_PRV_CAPABILITY_DIFFERENTIAL = 256,
    VSS_PRV_CAPABILITY_CLUSTERED = 512,
};
pub const VSS_PRV_CAPABILITY_LEGACY = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_LEGACY;
pub const VSS_PRV_CAPABILITY_COMPLIANT = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_COMPLIANT;
pub const VSS_PRV_CAPABILITY_LUN_REPOINT = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_LUN_REPOINT;
pub const VSS_PRV_CAPABILITY_LUN_RESYNC = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_LUN_RESYNC;
pub const VSS_PRV_CAPABILITY_OFFLINE_CREATION = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_OFFLINE_CREATION;
pub const VSS_PRV_CAPABILITY_MULTIPLE_IMPORT = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_MULTIPLE_IMPORT;
pub const VSS_PRV_CAPABILITY_RECYCLING = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_RECYCLING;
pub const VSS_PRV_CAPABILITY_PLEX = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_PLEX;
pub const VSS_PRV_CAPABILITY_DIFFERENTIAL = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_DIFFERENTIAL;
pub const VSS_PRV_CAPABILITY_CLUSTERED = VSS_PROVIDER_CAPABILITIES.VSS_PRV_CAPABILITY_CLUSTERED;

pub const VSS_HARDWARE_OPTIONS = extern enum(i32) {
    VSS_BREAKEX_FLAG_MASK_LUNS = 1,
    VSS_BREAKEX_FLAG_MAKE_READ_WRITE = 2,
    VSS_BREAKEX_FLAG_REVERT_IDENTITY_ALL = 4,
    VSS_BREAKEX_FLAG_REVERT_IDENTITY_NONE = 8,
    VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE = 256,
    VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY = 512,
    VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY = 1024,
    VSS_ONLUNSTATECHANGE_DO_MASK_LUNS = 2048,
};
pub const VSS_BREAKEX_FLAG_MASK_LUNS = VSS_HARDWARE_OPTIONS.VSS_BREAKEX_FLAG_MASK_LUNS;
pub const VSS_BREAKEX_FLAG_MAKE_READ_WRITE = VSS_HARDWARE_OPTIONS.VSS_BREAKEX_FLAG_MAKE_READ_WRITE;
pub const VSS_BREAKEX_FLAG_REVERT_IDENTITY_ALL = VSS_HARDWARE_OPTIONS.VSS_BREAKEX_FLAG_REVERT_IDENTITY_ALL;
pub const VSS_BREAKEX_FLAG_REVERT_IDENTITY_NONE = VSS_HARDWARE_OPTIONS.VSS_BREAKEX_FLAG_REVERT_IDENTITY_NONE;
pub const VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE = VSS_HARDWARE_OPTIONS.VSS_ONLUNSTATECHANGE_NOTIFY_READ_WRITE;
pub const VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY = VSS_HARDWARE_OPTIONS.VSS_ONLUNSTATECHANGE_NOTIFY_LUN_PRE_RECOVERY;
pub const VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY = VSS_HARDWARE_OPTIONS.VSS_ONLUNSTATECHANGE_NOTIFY_LUN_POST_RECOVERY;
pub const VSS_ONLUNSTATECHANGE_DO_MASK_LUNS = VSS_HARDWARE_OPTIONS.VSS_ONLUNSTATECHANGE_DO_MASK_LUNS;

pub const VSS_RECOVERY_OPTIONS = extern enum(i32) {
    VSS_RECOVERY_REVERT_IDENTITY_ALL = 256,
    VSS_RECOVERY_NO_VOLUME_CHECK = 512,
};
pub const VSS_RECOVERY_REVERT_IDENTITY_ALL = VSS_RECOVERY_OPTIONS.VSS_RECOVERY_REVERT_IDENTITY_ALL;
pub const VSS_RECOVERY_NO_VOLUME_CHECK = VSS_RECOVERY_OPTIONS.VSS_RECOVERY_NO_VOLUME_CHECK;

pub const VSS_WRITER_STATE = extern enum(i32) {
    VSS_WS_UNKNOWN = 0,
    VSS_WS_STABLE = 1,
    VSS_WS_WAITING_FOR_FREEZE = 2,
    VSS_WS_WAITING_FOR_THAW = 3,
    VSS_WS_WAITING_FOR_POST_SNAPSHOT = 4,
    VSS_WS_WAITING_FOR_BACKUP_COMPLETE = 5,
    VSS_WS_FAILED_AT_IDENTIFY = 6,
    VSS_WS_FAILED_AT_PREPARE_BACKUP = 7,
    VSS_WS_FAILED_AT_PREPARE_SNAPSHOT = 8,
    VSS_WS_FAILED_AT_FREEZE = 9,
    VSS_WS_FAILED_AT_THAW = 10,
    VSS_WS_FAILED_AT_POST_SNAPSHOT = 11,
    VSS_WS_FAILED_AT_BACKUP_COMPLETE = 12,
    VSS_WS_FAILED_AT_PRE_RESTORE = 13,
    VSS_WS_FAILED_AT_POST_RESTORE = 14,
    VSS_WS_FAILED_AT_BACKUPSHUTDOWN = 15,
    VSS_WS_COUNT = 16,
};
pub const VSS_WS_UNKNOWN = VSS_WRITER_STATE.VSS_WS_UNKNOWN;
pub const VSS_WS_STABLE = VSS_WRITER_STATE.VSS_WS_STABLE;
pub const VSS_WS_WAITING_FOR_FREEZE = VSS_WRITER_STATE.VSS_WS_WAITING_FOR_FREEZE;
pub const VSS_WS_WAITING_FOR_THAW = VSS_WRITER_STATE.VSS_WS_WAITING_FOR_THAW;
pub const VSS_WS_WAITING_FOR_POST_SNAPSHOT = VSS_WRITER_STATE.VSS_WS_WAITING_FOR_POST_SNAPSHOT;
pub const VSS_WS_WAITING_FOR_BACKUP_COMPLETE = VSS_WRITER_STATE.VSS_WS_WAITING_FOR_BACKUP_COMPLETE;
pub const VSS_WS_FAILED_AT_IDENTIFY = VSS_WRITER_STATE.VSS_WS_FAILED_AT_IDENTIFY;
pub const VSS_WS_FAILED_AT_PREPARE_BACKUP = VSS_WRITER_STATE.VSS_WS_FAILED_AT_PREPARE_BACKUP;
pub const VSS_WS_FAILED_AT_PREPARE_SNAPSHOT = VSS_WRITER_STATE.VSS_WS_FAILED_AT_PREPARE_SNAPSHOT;
pub const VSS_WS_FAILED_AT_FREEZE = VSS_WRITER_STATE.VSS_WS_FAILED_AT_FREEZE;
pub const VSS_WS_FAILED_AT_THAW = VSS_WRITER_STATE.VSS_WS_FAILED_AT_THAW;
pub const VSS_WS_FAILED_AT_POST_SNAPSHOT = VSS_WRITER_STATE.VSS_WS_FAILED_AT_POST_SNAPSHOT;
pub const VSS_WS_FAILED_AT_BACKUP_COMPLETE = VSS_WRITER_STATE.VSS_WS_FAILED_AT_BACKUP_COMPLETE;
pub const VSS_WS_FAILED_AT_PRE_RESTORE = VSS_WRITER_STATE.VSS_WS_FAILED_AT_PRE_RESTORE;
pub const VSS_WS_FAILED_AT_POST_RESTORE = VSS_WRITER_STATE.VSS_WS_FAILED_AT_POST_RESTORE;
pub const VSS_WS_FAILED_AT_BACKUPSHUTDOWN = VSS_WRITER_STATE.VSS_WS_FAILED_AT_BACKUPSHUTDOWN;
pub const VSS_WS_COUNT = VSS_WRITER_STATE.VSS_WS_COUNT;

pub const VSS_BACKUP_TYPE = extern enum(i32) {
    VSS_BT_UNDEFINED = 0,
    VSS_BT_FULL = 1,
    VSS_BT_INCREMENTAL = 2,
    VSS_BT_DIFFERENTIAL = 3,
    VSS_BT_LOG = 4,
    VSS_BT_COPY = 5,
    VSS_BT_OTHER = 6,
};
pub const VSS_BT_UNDEFINED = VSS_BACKUP_TYPE.VSS_BT_UNDEFINED;
pub const VSS_BT_FULL = VSS_BACKUP_TYPE.VSS_BT_FULL;
pub const VSS_BT_INCREMENTAL = VSS_BACKUP_TYPE.VSS_BT_INCREMENTAL;
pub const VSS_BT_DIFFERENTIAL = VSS_BACKUP_TYPE.VSS_BT_DIFFERENTIAL;
pub const VSS_BT_LOG = VSS_BACKUP_TYPE.VSS_BT_LOG;
pub const VSS_BT_COPY = VSS_BACKUP_TYPE.VSS_BT_COPY;
pub const VSS_BT_OTHER = VSS_BACKUP_TYPE.VSS_BT_OTHER;

pub const VSS_RESTORE_TYPE = extern enum(i32) {
    VSS_RTYPE_UNDEFINED = 0,
    VSS_RTYPE_BY_COPY = 1,
    VSS_RTYPE_IMPORT = 2,
    VSS_RTYPE_OTHER = 3,
};
pub const VSS_RTYPE_UNDEFINED = VSS_RESTORE_TYPE.VSS_RTYPE_UNDEFINED;
pub const VSS_RTYPE_BY_COPY = VSS_RESTORE_TYPE.VSS_RTYPE_BY_COPY;
pub const VSS_RTYPE_IMPORT = VSS_RESTORE_TYPE.VSS_RTYPE_IMPORT;
pub const VSS_RTYPE_OTHER = VSS_RESTORE_TYPE.VSS_RTYPE_OTHER;

pub const VSS_ROLLFORWARD_TYPE = extern enum(i32) {
    VSS_RF_UNDEFINED = 0,
    VSS_RF_NONE = 1,
    VSS_RF_ALL = 2,
    VSS_RF_PARTIAL = 3,
};
pub const VSS_RF_UNDEFINED = VSS_ROLLFORWARD_TYPE.VSS_RF_UNDEFINED;
pub const VSS_RF_NONE = VSS_ROLLFORWARD_TYPE.VSS_RF_NONE;
pub const VSS_RF_ALL = VSS_ROLLFORWARD_TYPE.VSS_RF_ALL;
pub const VSS_RF_PARTIAL = VSS_ROLLFORWARD_TYPE.VSS_RF_PARTIAL;

pub const VSS_PROVIDER_TYPE = extern enum(i32) {
    VSS_PROV_UNKNOWN = 0,
    VSS_PROV_SYSTEM = 1,
    VSS_PROV_SOFTWARE = 2,
    VSS_PROV_HARDWARE = 3,
    VSS_PROV_FILESHARE = 4,
};
pub const VSS_PROV_UNKNOWN = VSS_PROVIDER_TYPE.VSS_PROV_UNKNOWN;
pub const VSS_PROV_SYSTEM = VSS_PROVIDER_TYPE.VSS_PROV_SYSTEM;
pub const VSS_PROV_SOFTWARE = VSS_PROVIDER_TYPE.VSS_PROV_SOFTWARE;
pub const VSS_PROV_HARDWARE = VSS_PROVIDER_TYPE.VSS_PROV_HARDWARE;
pub const VSS_PROV_FILESHARE = VSS_PROVIDER_TYPE.VSS_PROV_FILESHARE;

pub const VSS_APPLICATION_LEVEL = extern enum(i32) {
    VSS_APP_UNKNOWN = 0,
    VSS_APP_SYSTEM = 1,
    VSS_APP_BACK_END = 2,
    VSS_APP_FRONT_END = 3,
    VSS_APP_SYSTEM_RM = 4,
    VSS_APP_AUTO = -1,
};
pub const VSS_APP_UNKNOWN = VSS_APPLICATION_LEVEL.VSS_APP_UNKNOWN;
pub const VSS_APP_SYSTEM = VSS_APPLICATION_LEVEL.VSS_APP_SYSTEM;
pub const VSS_APP_BACK_END = VSS_APPLICATION_LEVEL.VSS_APP_BACK_END;
pub const VSS_APP_FRONT_END = VSS_APPLICATION_LEVEL.VSS_APP_FRONT_END;
pub const VSS_APP_SYSTEM_RM = VSS_APPLICATION_LEVEL.VSS_APP_SYSTEM_RM;
pub const VSS_APP_AUTO = VSS_APPLICATION_LEVEL.VSS_APP_AUTO;

pub const VSS_SNAPSHOT_COMPATIBILITY = extern enum(i32) {
    VSS_SC_DISABLE_DEFRAG = 1,
    VSS_SC_DISABLE_CONTENTINDEX = 2,
};
pub const VSS_SC_DISABLE_DEFRAG = VSS_SNAPSHOT_COMPATIBILITY.VSS_SC_DISABLE_DEFRAG;
pub const VSS_SC_DISABLE_CONTENTINDEX = VSS_SNAPSHOT_COMPATIBILITY.VSS_SC_DISABLE_CONTENTINDEX;

pub const VSS_SNAPSHOT_PROPERTY_ID = extern enum(i32) {
    VSS_SPROPID_UNKNOWN = 0,
    VSS_SPROPID_SNAPSHOT_ID = 1,
    VSS_SPROPID_SNAPSHOT_SET_ID = 2,
    VSS_SPROPID_SNAPSHOTS_COUNT = 3,
    VSS_SPROPID_SNAPSHOT_DEVICE = 4,
    VSS_SPROPID_ORIGINAL_VOLUME = 5,
    VSS_SPROPID_ORIGINATING_MACHINE = 6,
    VSS_SPROPID_SERVICE_MACHINE = 7,
    VSS_SPROPID_EXPOSED_NAME = 8,
    VSS_SPROPID_EXPOSED_PATH = 9,
    VSS_SPROPID_PROVIDER_ID = 10,
    VSS_SPROPID_SNAPSHOT_ATTRIBUTES = 11,
    VSS_SPROPID_CREATION_TIMESTAMP = 12,
    VSS_SPROPID_STATUS = 13,
};
pub const VSS_SPROPID_UNKNOWN = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_UNKNOWN;
pub const VSS_SPROPID_SNAPSHOT_ID = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_SNAPSHOT_ID;
pub const VSS_SPROPID_SNAPSHOT_SET_ID = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_SNAPSHOT_SET_ID;
pub const VSS_SPROPID_SNAPSHOTS_COUNT = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_SNAPSHOTS_COUNT;
pub const VSS_SPROPID_SNAPSHOT_DEVICE = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_SNAPSHOT_DEVICE;
pub const VSS_SPROPID_ORIGINAL_VOLUME = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_ORIGINAL_VOLUME;
pub const VSS_SPROPID_ORIGINATING_MACHINE = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_ORIGINATING_MACHINE;
pub const VSS_SPROPID_SERVICE_MACHINE = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_SERVICE_MACHINE;
pub const VSS_SPROPID_EXPOSED_NAME = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_EXPOSED_NAME;
pub const VSS_SPROPID_EXPOSED_PATH = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_EXPOSED_PATH;
pub const VSS_SPROPID_PROVIDER_ID = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_PROVIDER_ID;
pub const VSS_SPROPID_SNAPSHOT_ATTRIBUTES = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_SNAPSHOT_ATTRIBUTES;
pub const VSS_SPROPID_CREATION_TIMESTAMP = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_CREATION_TIMESTAMP;
pub const VSS_SPROPID_STATUS = VSS_SNAPSHOT_PROPERTY_ID.VSS_SPROPID_STATUS;

pub const VSS_FILE_SPEC_BACKUP_TYPE = extern enum(i32) {
    VSS_FSBT_FULL_BACKUP_REQUIRED = 1,
    VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED = 2,
    VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED = 4,
    VSS_FSBT_LOG_BACKUP_REQUIRED = 8,
    VSS_FSBT_FULL_SNAPSHOT_REQUIRED = 256,
    VSS_FSBT_DIFFERENTIAL_SNAPSHOT_REQUIRED = 512,
    VSS_FSBT_INCREMENTAL_SNAPSHOT_REQUIRED = 1024,
    VSS_FSBT_LOG_SNAPSHOT_REQUIRED = 2048,
    VSS_FSBT_CREATED_DURING_BACKUP = 65536,
    VSS_FSBT_ALL_BACKUP_REQUIRED = 15,
    VSS_FSBT_ALL_SNAPSHOT_REQUIRED = 3840,
};
pub const VSS_FSBT_FULL_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_FULL_BACKUP_REQUIRED;
pub const VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_DIFFERENTIAL_BACKUP_REQUIRED;
pub const VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_INCREMENTAL_BACKUP_REQUIRED;
pub const VSS_FSBT_LOG_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_LOG_BACKUP_REQUIRED;
pub const VSS_FSBT_FULL_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_FULL_SNAPSHOT_REQUIRED;
pub const VSS_FSBT_DIFFERENTIAL_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_DIFFERENTIAL_SNAPSHOT_REQUIRED;
pub const VSS_FSBT_INCREMENTAL_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_INCREMENTAL_SNAPSHOT_REQUIRED;
pub const VSS_FSBT_LOG_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_LOG_SNAPSHOT_REQUIRED;
pub const VSS_FSBT_CREATED_DURING_BACKUP = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_CREATED_DURING_BACKUP;
pub const VSS_FSBT_ALL_BACKUP_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_ALL_BACKUP_REQUIRED;
pub const VSS_FSBT_ALL_SNAPSHOT_REQUIRED = VSS_FILE_SPEC_BACKUP_TYPE.VSS_FSBT_ALL_SNAPSHOT_REQUIRED;

pub const VSS_BACKUP_SCHEMA = extern enum(i32) {
    VSS_BS_UNDEFINED = 0,
    VSS_BS_DIFFERENTIAL = 1,
    VSS_BS_INCREMENTAL = 2,
    VSS_BS_EXCLUSIVE_INCREMENTAL_DIFFERENTIAL = 4,
    VSS_BS_LOG = 8,
    VSS_BS_COPY = 16,
    VSS_BS_TIMESTAMPED = 32,
    VSS_BS_LAST_MODIFY = 64,
    VSS_BS_LSN = 128,
    VSS_BS_WRITER_SUPPORTS_NEW_TARGET = 256,
    VSS_BS_WRITER_SUPPORTS_RESTORE_WITH_MOVE = 512,
    VSS_BS_INDEPENDENT_SYSTEM_STATE = 1024,
    VSS_BS_ROLLFORWARD_RESTORE = 4096,
    VSS_BS_RESTORE_RENAME = 8192,
    VSS_BS_AUTHORITATIVE_RESTORE = 16384,
    VSS_BS_WRITER_SUPPORTS_PARALLEL_RESTORES = 32768,
};
pub const VSS_BS_UNDEFINED = VSS_BACKUP_SCHEMA.VSS_BS_UNDEFINED;
pub const VSS_BS_DIFFERENTIAL = VSS_BACKUP_SCHEMA.VSS_BS_DIFFERENTIAL;
pub const VSS_BS_INCREMENTAL = VSS_BACKUP_SCHEMA.VSS_BS_INCREMENTAL;
pub const VSS_BS_EXCLUSIVE_INCREMENTAL_DIFFERENTIAL = VSS_BACKUP_SCHEMA.VSS_BS_EXCLUSIVE_INCREMENTAL_DIFFERENTIAL;
pub const VSS_BS_LOG = VSS_BACKUP_SCHEMA.VSS_BS_LOG;
pub const VSS_BS_COPY = VSS_BACKUP_SCHEMA.VSS_BS_COPY;
pub const VSS_BS_TIMESTAMPED = VSS_BACKUP_SCHEMA.VSS_BS_TIMESTAMPED;
pub const VSS_BS_LAST_MODIFY = VSS_BACKUP_SCHEMA.VSS_BS_LAST_MODIFY;
pub const VSS_BS_LSN = VSS_BACKUP_SCHEMA.VSS_BS_LSN;
pub const VSS_BS_WRITER_SUPPORTS_NEW_TARGET = VSS_BACKUP_SCHEMA.VSS_BS_WRITER_SUPPORTS_NEW_TARGET;
pub const VSS_BS_WRITER_SUPPORTS_RESTORE_WITH_MOVE = VSS_BACKUP_SCHEMA.VSS_BS_WRITER_SUPPORTS_RESTORE_WITH_MOVE;
pub const VSS_BS_INDEPENDENT_SYSTEM_STATE = VSS_BACKUP_SCHEMA.VSS_BS_INDEPENDENT_SYSTEM_STATE;
pub const VSS_BS_ROLLFORWARD_RESTORE = VSS_BACKUP_SCHEMA.VSS_BS_ROLLFORWARD_RESTORE;
pub const VSS_BS_RESTORE_RENAME = VSS_BACKUP_SCHEMA.VSS_BS_RESTORE_RENAME;
pub const VSS_BS_AUTHORITATIVE_RESTORE = VSS_BACKUP_SCHEMA.VSS_BS_AUTHORITATIVE_RESTORE;
pub const VSS_BS_WRITER_SUPPORTS_PARALLEL_RESTORES = VSS_BACKUP_SCHEMA.VSS_BS_WRITER_SUPPORTS_PARALLEL_RESTORES;

pub const VSS_SNAPSHOT_PROP = extern struct {
    m_SnapshotId: Guid,
    m_SnapshotSetId: Guid,
    m_lSnapshotsCount: i32,
    m_pwszSnapshotDeviceObject: *u16,
    m_pwszOriginalVolumeName: *u16,
    m_pwszOriginatingMachine: *u16,
    m_pwszServiceMachine: *u16,
    m_pwszExposedName: *u16,
    m_pwszExposedPath: *u16,
    m_ProviderId: Guid,
    m_lSnapshotAttributes: i32,
    m_tsCreationTimestamp: i64,
    m_eStatus: VSS_SNAPSHOT_STATE,
};

pub const VSS_PROVIDER_PROP = extern struct {
    m_ProviderId: Guid,
    m_pwszProviderName: *u16,
    m_eProviderType: VSS_PROVIDER_TYPE,
    m_pwszProviderVersion: *u16,
    m_ProviderVersionId: Guid,
    m_ClassId: Guid,
};

pub const __MIDL___MIDL_itf_vss_0000_0000_0001 = u32; // TODO: implement StructOrUnion types?

pub const VSS_OBJECT_PROP = extern struct {
    Type: VSS_OBJECT_TYPE,
    Obj: __MIDL___MIDL_itf_vss_0000_0000_0001,
};

const IID_IVssEnumObject_Value = @import("../zig.zig").Guid.initString("ae1c7110-2f60-11d3-8a39-00c04f72d8e3");
pub const IID_IVssEnumObject = &IID_IVssEnumObject_Value;
pub const IVssEnumObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IVssEnumObject,
            celt: u32,
            rgelt: [*]VSS_OBJECT_PROP,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IVssEnumObject,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IVssEnumObject,
            ppenum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumObject_Next(self: *const T, celt: u32, rgelt: [*]VSS_OBJECT_PROP, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumObject.VTable, self.vtable).Next(@ptrCast(*const IVssEnumObject, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumObject_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumObject.VTable, self.vtable).Skip(@ptrCast(*const IVssEnumObject, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumObject_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumObject.VTable, self.vtable).Reset(@ptrCast(*const IVssEnumObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumObject_Clone(self: *const T, ppenum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumObject.VTable, self.vtable).Clone(@ptrCast(*const IVssEnumObject, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssAsync_Value = @import("../zig.zig").Guid.initString("507c37b4-cf5b-4e95-b0af-14eb9767467e");
pub const IID_IVssAsync = &IID_IVssAsync_Value;
pub const IVssAsync = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Cancel: fn(
            self: *const IVssAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Wait: fn(
            self: *const IVssAsync,
            dwMilliseconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryStatus: fn(
            self: *const IVssAsync,
            pHrResult: *HRESULT,
            pReserved: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAsync_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAsync.VTable, self.vtable).Cancel(@ptrCast(*const IVssAsync, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAsync_Wait(self: *const T, dwMilliseconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAsync.VTable, self.vtable).Wait(@ptrCast(*const IVssAsync, self), dwMilliseconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAsync_QueryStatus(self: *const T, pHrResult: *HRESULT, pReserved: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAsync.VTable, self.vtable).QueryStatus(@ptrCast(*const IVssAsync, self), pHrResult, pReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VSS_USAGE_TYPE = extern enum(i32) {
    VSS_UT_UNDEFINED = 0,
    VSS_UT_BOOTABLESYSTEMSTATE = 1,
    VSS_UT_SYSTEMSERVICE = 2,
    VSS_UT_USERDATA = 3,
    VSS_UT_OTHER = 4,
};
pub const VSS_UT_UNDEFINED = VSS_USAGE_TYPE.VSS_UT_UNDEFINED;
pub const VSS_UT_BOOTABLESYSTEMSTATE = VSS_USAGE_TYPE.VSS_UT_BOOTABLESYSTEMSTATE;
pub const VSS_UT_SYSTEMSERVICE = VSS_USAGE_TYPE.VSS_UT_SYSTEMSERVICE;
pub const VSS_UT_USERDATA = VSS_USAGE_TYPE.VSS_UT_USERDATA;
pub const VSS_UT_OTHER = VSS_USAGE_TYPE.VSS_UT_OTHER;

pub const VSS_SOURCE_TYPE = extern enum(i32) {
    VSS_ST_UNDEFINED = 0,
    VSS_ST_TRANSACTEDDB = 1,
    VSS_ST_NONTRANSACTEDDB = 2,
    VSS_ST_OTHER = 3,
};
pub const VSS_ST_UNDEFINED = VSS_SOURCE_TYPE.VSS_ST_UNDEFINED;
pub const VSS_ST_TRANSACTEDDB = VSS_SOURCE_TYPE.VSS_ST_TRANSACTEDDB;
pub const VSS_ST_NONTRANSACTEDDB = VSS_SOURCE_TYPE.VSS_ST_NONTRANSACTEDDB;
pub const VSS_ST_OTHER = VSS_SOURCE_TYPE.VSS_ST_OTHER;

pub const VSS_RESTOREMETHOD_ENUM = extern enum(i32) {
    VSS_RME_UNDEFINED = 0,
    VSS_RME_RESTORE_IF_NOT_THERE = 1,
    VSS_RME_RESTORE_IF_CAN_REPLACE = 2,
    VSS_RME_STOP_RESTORE_START = 3,
    VSS_RME_RESTORE_TO_ALTERNATE_LOCATION = 4,
    VSS_RME_RESTORE_AT_REBOOT = 5,
    VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE = 6,
    VSS_RME_CUSTOM = 7,
    VSS_RME_RESTORE_STOP_START = 8,
};
pub const VSS_RME_UNDEFINED = VSS_RESTOREMETHOD_ENUM.VSS_RME_UNDEFINED;
pub const VSS_RME_RESTORE_IF_NOT_THERE = VSS_RESTOREMETHOD_ENUM.VSS_RME_RESTORE_IF_NOT_THERE;
pub const VSS_RME_RESTORE_IF_CAN_REPLACE = VSS_RESTOREMETHOD_ENUM.VSS_RME_RESTORE_IF_CAN_REPLACE;
pub const VSS_RME_STOP_RESTORE_START = VSS_RESTOREMETHOD_ENUM.VSS_RME_STOP_RESTORE_START;
pub const VSS_RME_RESTORE_TO_ALTERNATE_LOCATION = VSS_RESTOREMETHOD_ENUM.VSS_RME_RESTORE_TO_ALTERNATE_LOCATION;
pub const VSS_RME_RESTORE_AT_REBOOT = VSS_RESTOREMETHOD_ENUM.VSS_RME_RESTORE_AT_REBOOT;
pub const VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE = VSS_RESTOREMETHOD_ENUM.VSS_RME_RESTORE_AT_REBOOT_IF_CANNOT_REPLACE;
pub const VSS_RME_CUSTOM = VSS_RESTOREMETHOD_ENUM.VSS_RME_CUSTOM;
pub const VSS_RME_RESTORE_STOP_START = VSS_RESTOREMETHOD_ENUM.VSS_RME_RESTORE_STOP_START;

pub const VSS_WRITERRESTORE_ENUM = extern enum(i32) {
    VSS_WRE_UNDEFINED = 0,
    VSS_WRE_NEVER = 1,
    VSS_WRE_IF_REPLACE_FAILS = 2,
    VSS_WRE_ALWAYS = 3,
};
pub const VSS_WRE_UNDEFINED = VSS_WRITERRESTORE_ENUM.VSS_WRE_UNDEFINED;
pub const VSS_WRE_NEVER = VSS_WRITERRESTORE_ENUM.VSS_WRE_NEVER;
pub const VSS_WRE_IF_REPLACE_FAILS = VSS_WRITERRESTORE_ENUM.VSS_WRE_IF_REPLACE_FAILS;
pub const VSS_WRE_ALWAYS = VSS_WRITERRESTORE_ENUM.VSS_WRE_ALWAYS;

pub const VSS_COMPONENT_TYPE = extern enum(i32) {
    VSS_CT_UNDEFINED = 0,
    VSS_CT_DATABASE = 1,
    VSS_CT_FILEGROUP = 2,
};
pub const VSS_CT_UNDEFINED = VSS_COMPONENT_TYPE.VSS_CT_UNDEFINED;
pub const VSS_CT_DATABASE = VSS_COMPONENT_TYPE.VSS_CT_DATABASE;
pub const VSS_CT_FILEGROUP = VSS_COMPONENT_TYPE.VSS_CT_FILEGROUP;

pub const VSS_ALTERNATE_WRITER_STATE = extern enum(i32) {
    VSS_AWS_UNDEFINED = 0,
    VSS_AWS_NO_ALTERNATE_WRITER = 1,
    VSS_AWS_ALTERNATE_WRITER_EXISTS = 2,
    VSS_AWS_THIS_IS_ALTERNATE_WRITER = 3,
};
pub const VSS_AWS_UNDEFINED = VSS_ALTERNATE_WRITER_STATE.VSS_AWS_UNDEFINED;
pub const VSS_AWS_NO_ALTERNATE_WRITER = VSS_ALTERNATE_WRITER_STATE.VSS_AWS_NO_ALTERNATE_WRITER;
pub const VSS_AWS_ALTERNATE_WRITER_EXISTS = VSS_ALTERNATE_WRITER_STATE.VSS_AWS_ALTERNATE_WRITER_EXISTS;
pub const VSS_AWS_THIS_IS_ALTERNATE_WRITER = VSS_ALTERNATE_WRITER_STATE.VSS_AWS_THIS_IS_ALTERNATE_WRITER;

pub const VSS_SUBSCRIBE_MASK = extern enum(i32) {
    VSS_SM_POST_SNAPSHOT_FLAG = 1,
    VSS_SM_BACKUP_EVENTS_FLAG = 2,
    VSS_SM_RESTORE_EVENTS_FLAG = 4,
    VSS_SM_IO_THROTTLING_FLAG = 8,
    VSS_SM_ALL_FLAGS = -1,
};
pub const VSS_SM_POST_SNAPSHOT_FLAG = VSS_SUBSCRIBE_MASK.VSS_SM_POST_SNAPSHOT_FLAG;
pub const VSS_SM_BACKUP_EVENTS_FLAG = VSS_SUBSCRIBE_MASK.VSS_SM_BACKUP_EVENTS_FLAG;
pub const VSS_SM_RESTORE_EVENTS_FLAG = VSS_SUBSCRIBE_MASK.VSS_SM_RESTORE_EVENTS_FLAG;
pub const VSS_SM_IO_THROTTLING_FLAG = VSS_SUBSCRIBE_MASK.VSS_SM_IO_THROTTLING_FLAG;
pub const VSS_SM_ALL_FLAGS = VSS_SUBSCRIBE_MASK.VSS_SM_ALL_FLAGS;

pub const VSS_RESTORE_TARGET = extern enum(i32) {
    VSS_RT_UNDEFINED = 0,
    VSS_RT_ORIGINAL = 1,
    VSS_RT_ALTERNATE = 2,
    VSS_RT_DIRECTED = 3,
    VSS_RT_ORIGINAL_LOCATION = 4,
};
pub const VSS_RT_UNDEFINED = VSS_RESTORE_TARGET.VSS_RT_UNDEFINED;
pub const VSS_RT_ORIGINAL = VSS_RESTORE_TARGET.VSS_RT_ORIGINAL;
pub const VSS_RT_ALTERNATE = VSS_RESTORE_TARGET.VSS_RT_ALTERNATE;
pub const VSS_RT_DIRECTED = VSS_RESTORE_TARGET.VSS_RT_DIRECTED;
pub const VSS_RT_ORIGINAL_LOCATION = VSS_RESTORE_TARGET.VSS_RT_ORIGINAL_LOCATION;

pub const VSS_FILE_RESTORE_STATUS = extern enum(i32) {
    VSS_RS_UNDEFINED = 0,
    VSS_RS_NONE = 1,
    VSS_RS_ALL = 2,
    VSS_RS_FAILED = 3,
};
pub const VSS_RS_UNDEFINED = VSS_FILE_RESTORE_STATUS.VSS_RS_UNDEFINED;
pub const VSS_RS_NONE = VSS_FILE_RESTORE_STATUS.VSS_RS_NONE;
pub const VSS_RS_ALL = VSS_FILE_RESTORE_STATUS.VSS_RS_ALL;
pub const VSS_RS_FAILED = VSS_FILE_RESTORE_STATUS.VSS_RS_FAILED;

pub const VSS_COMPONENT_FLAGS = extern enum(i32) {
    VSS_CF_BACKUP_RECOVERY = 1,
    VSS_CF_APP_ROLLBACK_RECOVERY = 2,
    VSS_CF_NOT_SYSTEM_STATE = 4,
};
pub const VSS_CF_BACKUP_RECOVERY = VSS_COMPONENT_FLAGS.VSS_CF_BACKUP_RECOVERY;
pub const VSS_CF_APP_ROLLBACK_RECOVERY = VSS_COMPONENT_FLAGS.VSS_CF_APP_ROLLBACK_RECOVERY;
pub const VSS_CF_NOT_SYSTEM_STATE = VSS_COMPONENT_FLAGS.VSS_CF_NOT_SYSTEM_STATE;

pub const IVssExamineWriterMetadata = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IVssWMFiledesc = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPath: fn(
            self: *const IVssWMFiledesc,
            pbstrPath: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFilespec: fn(
            self: *const IVssWMFiledesc,
            pbstrFilespec: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRecursive: fn(
            self: *const IVssWMFiledesc,
            pbRecursive: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlternateLocation: fn(
            self: *const IVssWMFiledesc,
            pbstrAlternateLocation: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupTypeMask: fn(
            self: *const IVssWMFiledesc,
            pdwTypeMask: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetPath(self: *const T, pbstrPath: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetPath(@ptrCast(*const IVssWMFiledesc, self), pbstrPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetFilespec(self: *const T, pbstrFilespec: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetFilespec(@ptrCast(*const IVssWMFiledesc, self), pbstrFilespec);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetRecursive(self: *const T, pbRecursive: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetRecursive(@ptrCast(*const IVssWMFiledesc, self), pbRecursive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetAlternateLocation(self: *const T, pbstrAlternateLocation: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetAlternateLocation(@ptrCast(*const IVssWMFiledesc, self), pbstrAlternateLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMFiledesc_GetBackupTypeMask(self: *const T, pdwTypeMask: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMFiledesc.VTable, self.vtable).GetBackupTypeMask(@ptrCast(*const IVssWMFiledesc, self), pdwTypeMask);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVssWMDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWriterId: fn(
            self: *const IVssWMDependency,
            pWriterId: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogicalPath: fn(
            self: *const IVssWMDependency,
            pbstrLogicalPath: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentName: fn(
            self: *const IVssWMDependency,
            pbstrComponentName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMDependency_GetWriterId(self: *const T, pWriterId: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMDependency.VTable, self.vtable).GetWriterId(@ptrCast(*const IVssWMDependency, self), pWriterId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMDependency_GetLogicalPath(self: *const T, pbstrLogicalPath: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMDependency.VTable, self.vtable).GetLogicalPath(@ptrCast(*const IVssWMDependency, self), pbstrLogicalPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWMDependency_GetComponentName(self: *const T, pbstrComponentName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWMDependency.VTable, self.vtable).GetComponentName(@ptrCast(*const IVssWMDependency, self), pbstrComponentName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssComponent_Value = @import("../zig.zig").Guid.initString("d2c72c96-c121-4518-b627-e5a93d010ead");
pub const IID_IVssComponent = &IID_IVssComponent_Value;
pub const IVssComponent = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLogicalPath: fn(
            self: *const IVssComponent,
            pbstrPath: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentType: fn(
            self: *const IVssComponent,
            pct: *VSS_COMPONENT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponentName: fn(
            self: *const IVssComponent,
            pbstrName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupSucceeded: fn(
            self: *const IVssComponent,
            pbSucceeded: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlternateLocationMappingCount: fn(
            self: *const IVssComponent,
            pcMappings: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlternateLocationMapping: fn(
            self: *const IVssComponent,
            iMapping: u32,
            ppFiledesc: **IVssWMFiledesc,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupMetadata: fn(
            self: *const IVssComponent,
            wszData: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupMetadata: fn(
            self: *const IVssComponent,
            pbstrData: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddPartialFile: fn(
            self: *const IVssComponent,
            wszPath: [*:0]const u16,
            wszFilename: [*:0]const u16,
            wszRanges: [*:0]const u16,
            wszMetadata: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPartialFileCount: fn(
            self: *const IVssComponent,
            pcPartialFiles: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPartialFile: fn(
            self: *const IVssComponent,
            iPartialFile: u32,
            pbstrPath: *BSTR,
            pbstrFilename: *BSTR,
            pbstrRange: *BSTR,
            pbstrMetadata: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsSelectedForRestore: fn(
            self: *const IVssComponent,
            pbSelectedForRestore: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdditionalRestores: fn(
            self: *const IVssComponent,
            pbAdditionalRestores: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNewTargetCount: fn(
            self: *const IVssComponent,
            pcNewTarget: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNewTarget: fn(
            self: *const IVssComponent,
            iNewTarget: u32,
            ppFiledesc: **IVssWMFiledesc,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDirectedTarget: fn(
            self: *const IVssComponent,
            wszSourcePath: [*:0]const u16,
            wszSourceFilename: [*:0]const u16,
            wszSourceRangeList: [*:0]const u16,
            wszDestinationPath: [*:0]const u16,
            wszDestinationFilename: [*:0]const u16,
            wszDestinationRangeList: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectedTargetCount: fn(
            self: *const IVssComponent,
            pcDirectedTarget: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDirectedTarget: fn(
            self: *const IVssComponent,
            iDirectedTarget: u32,
            pbstrSourcePath: *BSTR,
            pbstrSourceFileName: *BSTR,
            pbstrSourceRangeList: *BSTR,
            pbstrDestinationPath: *BSTR,
            pbstrDestinationFilename: *BSTR,
            pbstrDestinationRangeList: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreMetadata: fn(
            self: *const IVssComponent,
            wszRestoreMetadata: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreMetadata: fn(
            self: *const IVssComponent,
            pbstrRestoreMetadata: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreTarget: fn(
            self: *const IVssComponent,
            target: VSS_RESTORE_TARGET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreTarget: fn(
            self: *const IVssComponent,
            pTarget: *VSS_RESTORE_TARGET,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPreRestoreFailureMsg: fn(
            self: *const IVssComponent,
            wszPreRestoreFailureMsg: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreRestoreFailureMsg: fn(
            self: *const IVssComponent,
            pbstrPreRestoreFailureMsg: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPostRestoreFailureMsg: fn(
            self: *const IVssComponent,
            wszPostRestoreFailureMsg: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPostRestoreFailureMsg: fn(
            self: *const IVssComponent,
            pbstrPostRestoreFailureMsg: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupStamp: fn(
            self: *const IVssComponent,
            wszBackupStamp: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupStamp: fn(
            self: *const IVssComponent,
            pbstrBackupStamp: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreviousBackupStamp: fn(
            self: *const IVssComponent,
            pbstrBackupStamp: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackupOptions: fn(
            self: *const IVssComponent,
            pbstrBackupOptions: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreOptions: fn(
            self: *const IVssComponent,
            pbstrRestoreOptions: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreSubcomponentCount: fn(
            self: *const IVssComponent,
            pcRestoreSubcomponent: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreSubcomponent: fn(
            self: *const IVssComponent,
            iComponent: u32,
            pbstrLogicalPath: *BSTR,
            pbstrComponentName: *BSTR,
            pbRepair: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileRestoreStatus: fn(
            self: *const IVssComponent,
            pStatus: *VSS_FILE_RESTORE_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDifferencedFilesByLastModifyTime: fn(
            self: *const IVssComponent,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: BOOL,
            ftLastModifyTime: FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDifferencedFilesByLastModifyLSN: fn(
            self: *const IVssComponent,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: BOOL,
            bstrLsnString: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDifferencedFilesCount: fn(
            self: *const IVssComponent,
            pcDifferencedFiles: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDifferencedFile: fn(
            self: *const IVssComponent,
            iDifferencedFile: u32,
            pbstrPath: *BSTR,
            pbstrFilespec: *BSTR,
            pbRecursive: *BOOL,
            pbstrLsnString: *BSTR,
            pftLastModifyTime: *FILETIME,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetLogicalPath(self: *const T, pbstrPath: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetLogicalPath(@ptrCast(*const IVssComponent, self), pbstrPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetComponentType(self: *const T, pct: *VSS_COMPONENT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetComponentType(@ptrCast(*const IVssComponent, self), pct);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetComponentName(self: *const T, pbstrName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetComponentName(@ptrCast(*const IVssComponent, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetBackupSucceeded(self: *const T, pbSucceeded: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetBackupSucceeded(@ptrCast(*const IVssComponent, self), pbSucceeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetAlternateLocationMappingCount(self: *const T, pcMappings: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetAlternateLocationMappingCount(@ptrCast(*const IVssComponent, self), pcMappings);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetAlternateLocationMapping(self: *const T, iMapping: u32, ppFiledesc: **IVssWMFiledesc) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetAlternateLocationMapping(@ptrCast(*const IVssComponent, self), iMapping, ppFiledesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetBackupMetadata(self: *const T, wszData: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetBackupMetadata(@ptrCast(*const IVssComponent, self), wszData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetBackupMetadata(self: *const T, pbstrData: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetBackupMetadata(@ptrCast(*const IVssComponent, self), pbstrData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_AddPartialFile(self: *const T, wszPath: [*:0]const u16, wszFilename: [*:0]const u16, wszRanges: [*:0]const u16, wszMetadata: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).AddPartialFile(@ptrCast(*const IVssComponent, self), wszPath, wszFilename, wszRanges, wszMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPartialFileCount(self: *const T, pcPartialFiles: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPartialFileCount(@ptrCast(*const IVssComponent, self), pcPartialFiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPartialFile(self: *const T, iPartialFile: u32, pbstrPath: *BSTR, pbstrFilename: *BSTR, pbstrRange: *BSTR, pbstrMetadata: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPartialFile(@ptrCast(*const IVssComponent, self), iPartialFile, pbstrPath, pbstrFilename, pbstrRange, pbstrMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_IsSelectedForRestore(self: *const T, pbSelectedForRestore: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).IsSelectedForRestore(@ptrCast(*const IVssComponent, self), pbSelectedForRestore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetAdditionalRestores(self: *const T, pbAdditionalRestores: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetAdditionalRestores(@ptrCast(*const IVssComponent, self), pbAdditionalRestores);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetNewTargetCount(self: *const T, pcNewTarget: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetNewTargetCount(@ptrCast(*const IVssComponent, self), pcNewTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetNewTarget(self: *const T, iNewTarget: u32, ppFiledesc: **IVssWMFiledesc) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetNewTarget(@ptrCast(*const IVssComponent, self), iNewTarget, ppFiledesc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_AddDirectedTarget(self: *const T, wszSourcePath: [*:0]const u16, wszSourceFilename: [*:0]const u16, wszSourceRangeList: [*:0]const u16, wszDestinationPath: [*:0]const u16, wszDestinationFilename: [*:0]const u16, wszDestinationRangeList: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).AddDirectedTarget(@ptrCast(*const IVssComponent, self), wszSourcePath, wszSourceFilename, wszSourceRangeList, wszDestinationPath, wszDestinationFilename, wszDestinationRangeList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetDirectedTargetCount(self: *const T, pcDirectedTarget: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetDirectedTargetCount(@ptrCast(*const IVssComponent, self), pcDirectedTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetDirectedTarget(self: *const T, iDirectedTarget: u32, pbstrSourcePath: *BSTR, pbstrSourceFileName: *BSTR, pbstrSourceRangeList: *BSTR, pbstrDestinationPath: *BSTR, pbstrDestinationFilename: *BSTR, pbstrDestinationRangeList: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetDirectedTarget(@ptrCast(*const IVssComponent, self), iDirectedTarget, pbstrSourcePath, pbstrSourceFileName, pbstrSourceRangeList, pbstrDestinationPath, pbstrDestinationFilename, pbstrDestinationRangeList);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetRestoreMetadata(self: *const T, wszRestoreMetadata: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetRestoreMetadata(@ptrCast(*const IVssComponent, self), wszRestoreMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreMetadata(self: *const T, pbstrRestoreMetadata: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreMetadata(@ptrCast(*const IVssComponent, self), pbstrRestoreMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetRestoreTarget(self: *const T, target: VSS_RESTORE_TARGET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetRestoreTarget(@ptrCast(*const IVssComponent, self), target);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreTarget(self: *const T, pTarget: *VSS_RESTORE_TARGET) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreTarget(@ptrCast(*const IVssComponent, self), pTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetPreRestoreFailureMsg(self: *const T, wszPreRestoreFailureMsg: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetPreRestoreFailureMsg(@ptrCast(*const IVssComponent, self), wszPreRestoreFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPreRestoreFailureMsg(self: *const T, pbstrPreRestoreFailureMsg: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPreRestoreFailureMsg(@ptrCast(*const IVssComponent, self), pbstrPreRestoreFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetPostRestoreFailureMsg(self: *const T, wszPostRestoreFailureMsg: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetPostRestoreFailureMsg(@ptrCast(*const IVssComponent, self), wszPostRestoreFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPostRestoreFailureMsg(self: *const T, pbstrPostRestoreFailureMsg: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPostRestoreFailureMsg(@ptrCast(*const IVssComponent, self), pbstrPostRestoreFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_SetBackupStamp(self: *const T, wszBackupStamp: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).SetBackupStamp(@ptrCast(*const IVssComponent, self), wszBackupStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetBackupStamp(self: *const T, pbstrBackupStamp: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetBackupStamp(@ptrCast(*const IVssComponent, self), pbstrBackupStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetPreviousBackupStamp(self: *const T, pbstrBackupStamp: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetPreviousBackupStamp(@ptrCast(*const IVssComponent, self), pbstrBackupStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetBackupOptions(self: *const T, pbstrBackupOptions: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetBackupOptions(@ptrCast(*const IVssComponent, self), pbstrBackupOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreOptions(self: *const T, pbstrRestoreOptions: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreOptions(@ptrCast(*const IVssComponent, self), pbstrRestoreOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreSubcomponentCount(self: *const T, pcRestoreSubcomponent: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreSubcomponentCount(@ptrCast(*const IVssComponent, self), pcRestoreSubcomponent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetRestoreSubcomponent(self: *const T, iComponent: u32, pbstrLogicalPath: *BSTR, pbstrComponentName: *BSTR, pbRepair: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetRestoreSubcomponent(@ptrCast(*const IVssComponent, self), iComponent, pbstrLogicalPath, pbstrComponentName, pbRepair);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetFileRestoreStatus(self: *const T, pStatus: *VSS_FILE_RESTORE_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetFileRestoreStatus(@ptrCast(*const IVssComponent, self), pStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_AddDifferencedFilesByLastModifyTime(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: BOOL, ftLastModifyTime: FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).AddDifferencedFilesByLastModifyTime(@ptrCast(*const IVssComponent, self), wszPath, wszFilespec, bRecursive, ftLastModifyTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_AddDifferencedFilesByLastModifyLSN(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: BOOL, bstrLsnString: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).AddDifferencedFilesByLastModifyLSN(@ptrCast(*const IVssComponent, self), wszPath, wszFilespec, bRecursive, bstrLsnString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetDifferencedFilesCount(self: *const T, pcDifferencedFiles: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetDifferencedFilesCount(@ptrCast(*const IVssComponent, self), pcDifferencedFiles);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponent_GetDifferencedFile(self: *const T, iDifferencedFile: u32, pbstrPath: *BSTR, pbstrFilespec: *BSTR, pbRecursive: *BOOL, pbstrLsnString: *BSTR, pftLastModifyTime: *FILETIME) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponent.VTable, self.vtable).GetDifferencedFile(@ptrCast(*const IVssComponent, self), iDifferencedFile, pbstrPath, pbstrFilespec, pbRecursive, pbstrLsnString, pftLastModifyTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVssWriterComponents = extern struct {
    pub const VTable = extern struct {
        GetComponentCount: fn(
            self: *const IVssWriterComponents,
            pcComponents: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWriterInfo: fn(
            self: *const IVssWriterComponents,
            pidInstance: *Guid,
            pidWriter: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComponent: fn(
            self: *const IVssWriterComponents,
            iComponent: u32,
            ppComponent: **IVssComponent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterComponents_GetComponentCount(self: *const T, pcComponents: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterComponents.VTable, self.vtable).GetComponentCount(@ptrCast(*const IVssWriterComponents, self), pcComponents);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterComponents_GetWriterInfo(self: *const T, pidInstance: *Guid, pidWriter: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterComponents.VTable, self.vtable).GetWriterInfo(@ptrCast(*const IVssWriterComponents, self), pidInstance, pidWriter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterComponents_GetComponent(self: *const T, iComponent: u32, ppComponent: **IVssComponent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterComponents.VTable, self.vtable).GetComponent(@ptrCast(*const IVssWriterComponents, self), iComponent, ppComponent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssComponentEx_Value = @import("../zig.zig").Guid.initString("156c8b5e-f131-4bd7-9c97-d1923be7e1fa");
pub const IID_IVssComponentEx = &IID_IVssComponentEx_Value;
pub const IVssComponentEx = extern struct {
    pub const VTable = extern struct {
        base: IVssComponent.VTable,
        SetPrepareForBackupFailureMsg: fn(
            self: *const IVssComponentEx,
            wszFailureMsg: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPostSnapshotFailureMsg: fn(
            self: *const IVssComponentEx,
            wszFailureMsg: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrepareForBackupFailureMsg: fn(
            self: *const IVssComponentEx,
            pbstrFailureMsg: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPostSnapshotFailureMsg: fn(
            self: *const IVssComponentEx,
            pbstrFailureMsg: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAuthoritativeRestore: fn(
            self: *const IVssComponentEx,
            pbAuth: *bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRollForward: fn(
            self: *const IVssComponentEx,
            pRollType: *VSS_ROLLFORWARD_TYPE,
            pbstrPoint: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRestoreName: fn(
            self: *const IVssComponentEx,
            pbstrName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssComponent.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_SetPrepareForBackupFailureMsg(self: *const T, wszFailureMsg: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).SetPrepareForBackupFailureMsg(@ptrCast(*const IVssComponentEx, self), wszFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_SetPostSnapshotFailureMsg(self: *const T, wszFailureMsg: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).SetPostSnapshotFailureMsg(@ptrCast(*const IVssComponentEx, self), wszFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetPrepareForBackupFailureMsg(self: *const T, pbstrFailureMsg: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetPrepareForBackupFailureMsg(@ptrCast(*const IVssComponentEx, self), pbstrFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetPostSnapshotFailureMsg(self: *const T, pbstrFailureMsg: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetPostSnapshotFailureMsg(@ptrCast(*const IVssComponentEx, self), pbstrFailureMsg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetAuthoritativeRestore(self: *const T, pbAuth: *bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetAuthoritativeRestore(@ptrCast(*const IVssComponentEx, self), pbAuth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetRollForward(self: *const T, pRollType: *VSS_ROLLFORWARD_TYPE, pbstrPoint: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetRollForward(@ptrCast(*const IVssComponentEx, self), pRollType, pbstrPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx_GetRestoreName(self: *const T, pbstrName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx.VTable, self.vtable).GetRestoreName(@ptrCast(*const IVssComponentEx, self), pbstrName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssComponentEx2_Value = @import("../zig.zig").Guid.initString("3b5be0f2-07a9-4e4b-bdd3-cfdc8e2c0d2d");
pub const IID_IVssComponentEx2 = &IID_IVssComponentEx2_Value;
pub const IVssComponentEx2 = extern struct {
    pub const VTable = extern struct {
        base: IVssComponentEx.VTable,
        SetFailure: fn(
            self: *const IVssComponentEx2,
            hr: HRESULT,
            hrApplication: HRESULT,
            wszApplicationMessage: ?[*:0]const u16,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFailure: fn(
            self: *const IVssComponentEx2,
            phr: *HRESULT,
            phrApplication: *HRESULT,
            pbstrApplicationMessage: *BSTR,
            pdwReserved: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssComponentEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx2_SetFailure(self: *const T, hr: HRESULT, hrApplication: HRESULT, wszApplicationMessage: ?[*:0]const u16, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx2.VTable, self.vtable).SetFailure(@ptrCast(*const IVssComponentEx2, self), hr, hrApplication, wszApplicationMessage, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssComponentEx2_GetFailure(self: *const T, phr: *HRESULT, phrApplication: *HRESULT, pbstrApplicationMessage: *BSTR, pdwReserved: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssComponentEx2.VTable, self.vtable).GetFailure(@ptrCast(*const IVssComponentEx2, self), phr, phrApplication, pbstrApplicationMessage, pdwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVssCreateWriterMetadata = extern struct {
    pub const VTable = extern struct {
        AddIncludeFiles: fn(
            self: *const IVssCreateWriterMetadata,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
            wszAlternateLocation: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExcludeFiles: fn(
            self: *const IVssCreateWriterMetadata,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponent: fn(
            self: *const IVssCreateWriterMetadata,
            ct: VSS_COMPONENT_TYPE,
            wszLogicalPath: [*:0]const u16,
            wszComponentName: [*:0]const u16,
            wszCaption: [*:0]const u16,
            pbIcon: *const u8,
            cbIcon: u32,
            bRestoreMetadata: u8,
            bNotifyOnBackupComplete: u8,
            bSelectable: u8,
            bSelectableForRestore: u8,
            dwComponentFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDatabaseFiles: fn(
            self: *const IVssCreateWriterMetadata,
            wszLogicalPath: [*:0]const u16,
            wszDatabaseName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDatabaseLogFiles: fn(
            self: *const IVssCreateWriterMetadata,
            wszLogicalPath: [*:0]const u16,
            wszDatabaseName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFilesToFileGroup: fn(
            self: *const IVssCreateWriterMetadata,
            wszLogicalPath: [*:0]const u16,
            wszGroupName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
            wszAlternateLocation: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreMethod: fn(
            self: *const IVssCreateWriterMetadata,
            method: VSS_RESTOREMETHOD_ENUM,
            wszService: [*:0]const u16,
            wszUserProcedure: [*:0]const u16,
            writerRestore: VSS_WRITERRESTORE_ENUM,
            bRebootRequired: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAlternateLocationMapping: fn(
            self: *const IVssCreateWriterMetadata,
            wszSourcePath: [*:0]const u16,
            wszSourceFilespec: [*:0]const u16,
            bRecursive: u8,
            wszDestination: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponentDependency: fn(
            self: *const IVssCreateWriterMetadata,
            wszForLogicalPath: [*:0]const u16,
            wszForComponentName: [*:0]const u16,
            onWriterId: Guid,
            wszOnLogicalPath: [*:0]const u16,
            wszOnComponentName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupSchema: fn(
            self: *const IVssCreateWriterMetadata,
            dwSchemaMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocument: fn(
            self: *const IVssCreateWriterMetadata,
            pDoc: **IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAsXML: fn(
            self: *const IVssCreateWriterMetadata,
            pbstrXML: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddIncludeFiles(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8, wszAlternateLocation: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddIncludeFiles(@ptrCast(*const IVssCreateWriterMetadata, self), wszPath, wszFilespec, bRecursive, wszAlternateLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddExcludeFiles(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddExcludeFiles(@ptrCast(*const IVssCreateWriterMetadata, self), wszPath, wszFilespec, bRecursive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddComponent(self: *const T, ct: VSS_COMPONENT_TYPE, wszLogicalPath: [*:0]const u16, wszComponentName: [*:0]const u16, wszCaption: [*:0]const u16, pbIcon: *const u8, cbIcon: u32, bRestoreMetadata: u8, bNotifyOnBackupComplete: u8, bSelectable: u8, bSelectableForRestore: u8, dwComponentFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddComponent(@ptrCast(*const IVssCreateWriterMetadata, self), ct, wszLogicalPath, wszComponentName, wszCaption, pbIcon, cbIcon, bRestoreMetadata, bNotifyOnBackupComplete, bSelectable, bSelectableForRestore, dwComponentFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddDatabaseFiles(self: *const T, wszLogicalPath: [*:0]const u16, wszDatabaseName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddDatabaseFiles(@ptrCast(*const IVssCreateWriterMetadata, self), wszLogicalPath, wszDatabaseName, wszPath, wszFilespec, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddDatabaseLogFiles(self: *const T, wszLogicalPath: [*:0]const u16, wszDatabaseName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddDatabaseLogFiles(@ptrCast(*const IVssCreateWriterMetadata, self), wszLogicalPath, wszDatabaseName, wszPath, wszFilespec, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddFilesToFileGroup(self: *const T, wszLogicalPath: [*:0]const u16, wszGroupName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8, wszAlternateLocation: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddFilesToFileGroup(@ptrCast(*const IVssCreateWriterMetadata, self), wszLogicalPath, wszGroupName, wszPath, wszFilespec, bRecursive, wszAlternateLocation, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_SetRestoreMethod(self: *const T, method: VSS_RESTOREMETHOD_ENUM, wszService: [*:0]const u16, wszUserProcedure: [*:0]const u16, writerRestore: VSS_WRITERRESTORE_ENUM, bRebootRequired: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).SetRestoreMethod(@ptrCast(*const IVssCreateWriterMetadata, self), method, wszService, wszUserProcedure, writerRestore, bRebootRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddAlternateLocationMapping(self: *const T, wszSourcePath: [*:0]const u16, wszSourceFilespec: [*:0]const u16, bRecursive: u8, wszDestination: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddAlternateLocationMapping(@ptrCast(*const IVssCreateWriterMetadata, self), wszSourcePath, wszSourceFilespec, bRecursive, wszDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_AddComponentDependency(self: *const T, wszForLogicalPath: [*:0]const u16, wszForComponentName: [*:0]const u16, onWriterId: Guid, wszOnLogicalPath: [*:0]const u16, wszOnComponentName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).AddComponentDependency(@ptrCast(*const IVssCreateWriterMetadata, self), wszForLogicalPath, wszForComponentName, onWriterId, wszOnLogicalPath, wszOnComponentName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_SetBackupSchema(self: *const T, dwSchemaMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).SetBackupSchema(@ptrCast(*const IVssCreateWriterMetadata, self), dwSchemaMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_GetDocument(self: *const T, pDoc: **IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).GetDocument(@ptrCast(*const IVssCreateWriterMetadata, self), pDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadata_SaveAsXML(self: *const T, pbstrXML: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadata.VTable, self.vtable).SaveAsXML(@ptrCast(*const IVssCreateWriterMetadata, self), pbstrXML);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssCreateWriterMetadataEx_Value = @import("../zig.zig").Guid.initString("9f21981d-d469-4349-b807-39e64e4674e1");
pub const IID_IVssCreateWriterMetadataEx = &IID_IVssCreateWriterMetadataEx_Value;
pub const IVssCreateWriterMetadataEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDatabaseFiles: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszLogicalPath: [*:0]const u16,
            wszDatabaseName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDatabaseLogFiles: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszLogicalPath: [*:0]const u16,
            wszDatabaseName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFilesToFileGroup: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszLogicalPath: [*:0]const u16,
            wszGroupName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
            wszAlternateLocation: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreMethod: fn(
            self: *const IVssCreateWriterMetadataEx,
            method: VSS_RESTOREMETHOD_ENUM,
            wszService: [*:0]const u16,
            wszUserProcedure: [*:0]const u16,
            writerRestore: VSS_WRITERRESTORE_ENUM,
            bRebootRequired: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAlternateLocationMapping: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszSourcePath: [*:0]const u16,
            wszSourceFilespec: [*:0]const u16,
            bRecursive: u8,
            wszDestination: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponentDependency: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszForLogicalPath: [*:0]const u16,
            wszForComponentName: [*:0]const u16,
            onWriterId: Guid,
            wszOnLogicalPath: [*:0]const u16,
            wszOnComponentName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupSchema: fn(
            self: *const IVssCreateWriterMetadataEx,
            dwSchemaMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocument: fn(
            self: *const IVssCreateWriterMetadataEx,
            pDoc: **IXMLDOMDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAsXML: fn(
            self: *const IVssCreateWriterMetadataEx,
            pbstrXML: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInterface: fn(
            self: *const IVssCreateWriterMetadataEx,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddRef: fn(
            self: *const IVssCreateWriterMetadataEx,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        Release: fn(
            self: *const IVssCreateWriterMetadataEx,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        AddExcludeFilesFromSnapshot: fn(
            self: *const IVssCreateWriterMetadataEx,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddDatabaseFiles(self: *const T, wszLogicalPath: [*:0]const u16, wszDatabaseName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddDatabaseFiles(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszLogicalPath, wszDatabaseName, wszPath, wszFilespec, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddDatabaseLogFiles(self: *const T, wszLogicalPath: [*:0]const u16, wszDatabaseName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddDatabaseLogFiles(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszLogicalPath, wszDatabaseName, wszPath, wszFilespec, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddFilesToFileGroup(self: *const T, wszLogicalPath: [*:0]const u16, wszGroupName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8, wszAlternateLocation: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddFilesToFileGroup(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszLogicalPath, wszGroupName, wszPath, wszFilespec, bRecursive, wszAlternateLocation, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_SetRestoreMethod(self: *const T, method: VSS_RESTOREMETHOD_ENUM, wszService: [*:0]const u16, wszUserProcedure: [*:0]const u16, writerRestore: VSS_WRITERRESTORE_ENUM, bRebootRequired: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).SetRestoreMethod(@ptrCast(*const IVssCreateWriterMetadataEx, self), method, wszService, wszUserProcedure, writerRestore, bRebootRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddAlternateLocationMapping(self: *const T, wszSourcePath: [*:0]const u16, wszSourceFilespec: [*:0]const u16, bRecursive: u8, wszDestination: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddAlternateLocationMapping(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszSourcePath, wszSourceFilespec, bRecursive, wszDestination);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddComponentDependency(self: *const T, wszForLogicalPath: [*:0]const u16, wszForComponentName: [*:0]const u16, onWriterId: Guid, wszOnLogicalPath: [*:0]const u16, wszOnComponentName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddComponentDependency(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszForLogicalPath, wszForComponentName, onWriterId, wszOnLogicalPath, wszOnComponentName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_SetBackupSchema(self: *const T, dwSchemaMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).SetBackupSchema(@ptrCast(*const IVssCreateWriterMetadataEx, self), dwSchemaMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_GetDocument(self: *const T, pDoc: **IXMLDOMDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).GetDocument(@ptrCast(*const IVssCreateWriterMetadataEx, self), pDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_SaveAsXML(self: *const T, pbstrXML: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).SaveAsXML(@ptrCast(*const IVssCreateWriterMetadataEx, self), pbstrXML);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_QueryInterface(self: *const T, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).QueryInterface(@ptrCast(*const IVssCreateWriterMetadataEx, self), riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddRef(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddRef(@ptrCast(*const IVssCreateWriterMetadataEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_Release(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).Release(@ptrCast(*const IVssCreateWriterMetadataEx, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateWriterMetadataEx_AddExcludeFilesFromSnapshot(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateWriterMetadataEx.VTable, self.vtable).AddExcludeFilesFromSnapshot(@ptrCast(*const IVssCreateWriterMetadataEx, self), wszPath, wszFilespec, bRecursive);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IVssWriterImpl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IVssWriterImpl,
            writerId: Guid,
            wszWriterName: [*:0]const u16,
            wszWriterInstanceName: ?[*:0]const u16,
            dwMajorVersion: u32,
            dwMinorVersion: u32,
            ut: VSS_USAGE_TYPE,
            st: VSS_SOURCE_TYPE,
            nLevel: VSS_APPLICATION_LEVEL,
            dwTimeout: u32,
            aws: VSS_ALTERNATE_WRITER_STATE,
            bIOThrottlingOnly: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Subscribe: fn(
            self: *const IVssWriterImpl,
            dwSubscribeTimeout: u32,
            dwEventFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unsubscribe: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Uninitialize: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetCurrentVolumeArray: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) *PWSTR,
        GetCurrentVolumeCount: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        GetSnapshotDeviceName: fn(
            self: *const IVssWriterImpl,
            wszOriginalVolume: [*:0]const u16,
            ppwszSnapshotDevice: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSnapshotSetId: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) Guid,
        GetContext: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetCurrentLevel: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) VSS_APPLICATION_LEVEL,
        IsPathAffected: fn(
            self: *const IVssWriterImpl,
            wszPath: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        IsBootableSystemStateBackedUp: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        AreComponentsSelected: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        GetBackupType: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) VSS_BACKUP_TYPE,
        GetRestoreType: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) VSS_RESTORE_TYPE,
        SetWriterFailure: fn(
            self: *const IVssWriterImpl,
            hr: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPartialFileSupportEnabled: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        InstallAlternateWriter: fn(
            self: *const IVssWriterImpl,
            idWriter: Guid,
            clsid: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentityInformation: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) *IVssExamineWriterMetadata,
        SetWriterFailureEx: fn(
            self: *const IVssWriterImpl,
            hr: HRESULT,
            hrApplication: HRESULT,
            wszApplicationMessage: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSessionId: fn(
            self: *const IVssWriterImpl,
            idSession: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsWriterShuttingDown: fn(
            self: *const IVssWriterImpl,
        ) callconv(@import("std").os.windows.WINAPI) bool,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_Initialize(self: *const T, writerId: Guid, wszWriterName: [*:0]const u16, wszWriterInstanceName: ?[*:0]const u16, dwMajorVersion: u32, dwMinorVersion: u32, ut: VSS_USAGE_TYPE, st: VSS_SOURCE_TYPE, nLevel: VSS_APPLICATION_LEVEL, dwTimeout: u32, aws: VSS_ALTERNATE_WRITER_STATE, bIOThrottlingOnly: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).Initialize(@ptrCast(*const IVssWriterImpl, self), writerId, wszWriterName, wszWriterInstanceName, dwMajorVersion, dwMinorVersion, ut, st, nLevel, dwTimeout, aws, bIOThrottlingOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_Subscribe(self: *const T, dwSubscribeTimeout: u32, dwEventFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).Subscribe(@ptrCast(*const IVssWriterImpl, self), dwSubscribeTimeout, dwEventFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_Unsubscribe(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).Unsubscribe(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_Uninitialize(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).Uninitialize(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetCurrentVolumeArray(self: *const T) callconv(.Inline) *PWSTR {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetCurrentVolumeArray(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetCurrentVolumeCount(self: *const T) callconv(.Inline) u32 {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetCurrentVolumeCount(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetSnapshotDeviceName(self: *const T, wszOriginalVolume: [*:0]const u16, ppwszSnapshotDevice: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetSnapshotDeviceName(@ptrCast(*const IVssWriterImpl, self), wszOriginalVolume, ppwszSnapshotDevice);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetCurrentSnapshotSetId(self: *const T) callconv(.Inline) Guid {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetCurrentSnapshotSetId(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetContext(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetContext(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetCurrentLevel(self: *const T) callconv(.Inline) VSS_APPLICATION_LEVEL {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetCurrentLevel(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_IsPathAffected(self: *const T, wszPath: [*:0]const u16) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).IsPathAffected(@ptrCast(*const IVssWriterImpl, self), wszPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_IsBootableSystemStateBackedUp(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).IsBootableSystemStateBackedUp(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_AreComponentsSelected(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).AreComponentsSelected(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetBackupType(self: *const T) callconv(.Inline) VSS_BACKUP_TYPE {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetBackupType(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetRestoreType(self: *const T) callconv(.Inline) VSS_RESTORE_TYPE {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetRestoreType(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_SetWriterFailure(self: *const T, hr: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).SetWriterFailure(@ptrCast(*const IVssWriterImpl, self), hr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_IsPartialFileSupportEnabled(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).IsPartialFileSupportEnabled(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_InstallAlternateWriter(self: *const T, idWriter: Guid, clsid: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).InstallAlternateWriter(@ptrCast(*const IVssWriterImpl, self), idWriter, clsid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetIdentityInformation(self: *const T) callconv(.Inline) *IVssExamineWriterMetadata {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetIdentityInformation(@ptrCast(*const IVssWriterImpl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_SetWriterFailureEx(self: *const T, hr: HRESULT, hrApplication: HRESULT, wszApplicationMessage: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).SetWriterFailureEx(@ptrCast(*const IVssWriterImpl, self), hr, hrApplication, wszApplicationMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_GetSessionId(self: *const T, idSession: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).GetSessionId(@ptrCast(*const IVssWriterImpl, self), idSession);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssWriterImpl_IsWriterShuttingDown(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IVssWriterImpl.VTable, self.vtable).IsWriterShuttingDown(@ptrCast(*const IVssWriterImpl, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssCreateExpressWriterMetadata_Value = @import("../zig.zig").Guid.initString("9c772e77-b26e-427f-92dd-c996f41ea5e3");
pub const IID_IVssCreateExpressWriterMetadata = &IID_IVssCreateExpressWriterMetadata_Value;
pub const IVssCreateExpressWriterMetadata = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddExcludeFiles: fn(
            self: *const IVssCreateExpressWriterMetadata,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponent: fn(
            self: *const IVssCreateExpressWriterMetadata,
            ct: VSS_COMPONENT_TYPE,
            wszLogicalPath: [*:0]const u16,
            wszComponentName: [*:0]const u16,
            wszCaption: [*:0]const u16,
            pbIcon: *const u8,
            cbIcon: u32,
            bRestoreMetadata: u8,
            bNotifyOnBackupComplete: u8,
            bSelectable: u8,
            bSelectableForRestore: u8,
            dwComponentFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFilesToFileGroup: fn(
            self: *const IVssCreateExpressWriterMetadata,
            wszLogicalPath: [*:0]const u16,
            wszGroupName: [*:0]const u16,
            wszPath: [*:0]const u16,
            wszFilespec: [*:0]const u16,
            bRecursive: u8,
            wszAlternateLocation: [*:0]const u16,
            dwBackupTypeMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRestoreMethod: fn(
            self: *const IVssCreateExpressWriterMetadata,
            method: VSS_RESTOREMETHOD_ENUM,
            wszService: [*:0]const u16,
            wszUserProcedure: [*:0]const u16,
            writerRestore: VSS_WRITERRESTORE_ENUM,
            bRebootRequired: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddComponentDependency: fn(
            self: *const IVssCreateExpressWriterMetadata,
            wszForLogicalPath: [*:0]const u16,
            wszForComponentName: [*:0]const u16,
            onWriterId: Guid,
            wszOnLogicalPath: [*:0]const u16,
            wszOnComponentName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackupSchema: fn(
            self: *const IVssCreateExpressWriterMetadata,
            dwSchemaMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveAsXML: fn(
            self: *const IVssCreateExpressWriterMetadata,
            pbstrXML: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_AddExcludeFiles(self: *const T, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).AddExcludeFiles(@ptrCast(*const IVssCreateExpressWriterMetadata, self), wszPath, wszFilespec, bRecursive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_AddComponent(self: *const T, ct: VSS_COMPONENT_TYPE, wszLogicalPath: [*:0]const u16, wszComponentName: [*:0]const u16, wszCaption: [*:0]const u16, pbIcon: *const u8, cbIcon: u32, bRestoreMetadata: u8, bNotifyOnBackupComplete: u8, bSelectable: u8, bSelectableForRestore: u8, dwComponentFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).AddComponent(@ptrCast(*const IVssCreateExpressWriterMetadata, self), ct, wszLogicalPath, wszComponentName, wszCaption, pbIcon, cbIcon, bRestoreMetadata, bNotifyOnBackupComplete, bSelectable, bSelectableForRestore, dwComponentFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_AddFilesToFileGroup(self: *const T, wszLogicalPath: [*:0]const u16, wszGroupName: [*:0]const u16, wszPath: [*:0]const u16, wszFilespec: [*:0]const u16, bRecursive: u8, wszAlternateLocation: [*:0]const u16, dwBackupTypeMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).AddFilesToFileGroup(@ptrCast(*const IVssCreateExpressWriterMetadata, self), wszLogicalPath, wszGroupName, wszPath, wszFilespec, bRecursive, wszAlternateLocation, dwBackupTypeMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_SetRestoreMethod(self: *const T, method: VSS_RESTOREMETHOD_ENUM, wszService: [*:0]const u16, wszUserProcedure: [*:0]const u16, writerRestore: VSS_WRITERRESTORE_ENUM, bRebootRequired: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).SetRestoreMethod(@ptrCast(*const IVssCreateExpressWriterMetadata, self), method, wszService, wszUserProcedure, writerRestore, bRebootRequired);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_AddComponentDependency(self: *const T, wszForLogicalPath: [*:0]const u16, wszForComponentName: [*:0]const u16, onWriterId: Guid, wszOnLogicalPath: [*:0]const u16, wszOnComponentName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).AddComponentDependency(@ptrCast(*const IVssCreateExpressWriterMetadata, self), wszForLogicalPath, wszForComponentName, onWriterId, wszOnLogicalPath, wszOnComponentName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_SetBackupSchema(self: *const T, dwSchemaMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).SetBackupSchema(@ptrCast(*const IVssCreateExpressWriterMetadata, self), dwSchemaMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssCreateExpressWriterMetadata_SaveAsXML(self: *const T, pbstrXML: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssCreateExpressWriterMetadata.VTable, self.vtable).SaveAsXML(@ptrCast(*const IVssCreateExpressWriterMetadata, self), pbstrXML);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssExpressWriter_Value = @import("../zig.zig").Guid.initString("e33affdc-59c7-47b1-97d5-4266598f6235");
pub const IID_IVssExpressWriter = &IID_IVssExpressWriter_Value;
pub const IVssExpressWriter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMetadata: fn(
            self: *const IVssExpressWriter,
            writerId: Guid,
            writerName: [*:0]const u16,
            usageType: VSS_USAGE_TYPE,
            versionMajor: u32,
            versionMinor: u32,
            reserved: u32,
            ppMetadata: **IVssCreateExpressWriterMetadata,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadMetadata: fn(
            self: *const IVssExpressWriter,
            metadata: [*:0]const u16,
            reserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Register: fn(
            self: *const IVssExpressWriter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unregister: fn(
            self: *const IVssExpressWriter,
            writerId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssExpressWriter_CreateMetadata(self: *const T, writerId: Guid, writerName: [*:0]const u16, usageType: VSS_USAGE_TYPE, versionMajor: u32, versionMinor: u32, reserved: u32, ppMetadata: **IVssCreateExpressWriterMetadata) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssExpressWriter.VTable, self.vtable).CreateMetadata(@ptrCast(*const IVssExpressWriter, self), writerId, writerName, usageType, versionMajor, versionMinor, reserved, ppMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssExpressWriter_LoadMetadata(self: *const T, metadata: [*:0]const u16, reserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssExpressWriter.VTable, self.vtable).LoadMetadata(@ptrCast(*const IVssExpressWriter, self), metadata, reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssExpressWriter_Register(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssExpressWriter.VTable, self.vtable).Register(@ptrCast(*const IVssExpressWriter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssExpressWriter_Unregister(self: *const T, writerId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssExpressWriter.VTable, self.vtable).Unregister(@ptrCast(*const IVssExpressWriter, self), writerId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_VssSnapshotMgmt_Value = @import("../zig.zig").Guid.initString("0b5a2c52-3eb9-470a-96e2-6c6d4570e40f");
pub const CLSID_VssSnapshotMgmt = &CLSID_VssSnapshotMgmt_Value;

pub const VSS_MGMT_OBJECT_TYPE = extern enum(i32) {
    VSS_MGMT_OBJECT_UNKNOWN = 0,
    VSS_MGMT_OBJECT_VOLUME = 1,
    VSS_MGMT_OBJECT_DIFF_VOLUME = 2,
    VSS_MGMT_OBJECT_DIFF_AREA = 3,
};
pub const VSS_MGMT_OBJECT_UNKNOWN = VSS_MGMT_OBJECT_TYPE.VSS_MGMT_OBJECT_UNKNOWN;
pub const VSS_MGMT_OBJECT_VOLUME = VSS_MGMT_OBJECT_TYPE.VSS_MGMT_OBJECT_VOLUME;
pub const VSS_MGMT_OBJECT_DIFF_VOLUME = VSS_MGMT_OBJECT_TYPE.VSS_MGMT_OBJECT_DIFF_VOLUME;
pub const VSS_MGMT_OBJECT_DIFF_AREA = VSS_MGMT_OBJECT_TYPE.VSS_MGMT_OBJECT_DIFF_AREA;

pub const VSS_VOLUME_PROP = extern struct {
    m_pwszVolumeName: *u16,
    m_pwszVolumeDisplayName: *u16,
};

pub const VSS_DIFF_VOLUME_PROP = extern struct {
    m_pwszVolumeName: *u16,
    m_pwszVolumeDisplayName: *u16,
    m_llVolumeFreeSpace: i64,
    m_llVolumeTotalSpace: i64,
};

pub const VSS_DIFF_AREA_PROP = extern struct {
    m_pwszVolumeName: *u16,
    m_pwszDiffAreaVolumeName: *u16,
    m_llMaximumDiffSpace: i64,
    m_llAllocatedDiffSpace: i64,
    m_llUsedDiffSpace: i64,
};

pub const __MIDL___MIDL_itf_vsmgmt_0000_0000_0001 = u32; // TODO: implement StructOrUnion types?

pub const VSS_MGMT_OBJECT_PROP = extern struct {
    Type: VSS_MGMT_OBJECT_TYPE,
    Obj: __MIDL___MIDL_itf_vsmgmt_0000_0000_0001,
};

pub const VSS_PROTECTION_LEVEL = extern enum(i32) {
    ORIGINAL_VOLUME = 0,
    SNAPSHOT = 1,
};
pub const VSS_PROTECTION_LEVEL_ORIGINAL_VOLUME = VSS_PROTECTION_LEVEL.ORIGINAL_VOLUME;
pub const VSS_PROTECTION_LEVEL_SNAPSHOT = VSS_PROTECTION_LEVEL.SNAPSHOT;

pub const VSS_PROTECTION_FAULT = extern enum(i32) {
    NONE = 0,
    DIFF_AREA_MISSING = 1,
    IO_FAILURE_DURING_ONLINE = 2,
    META_DATA_CORRUPTION = 3,
    MEMORY_ALLOCATION_FAILURE = 4,
    MAPPED_MEMORY_FAILURE = 5,
    COW_READ_FAILURE = 6,
    COW_WRITE_FAILURE = 7,
    DIFF_AREA_FULL = 8,
    GROW_TOO_SLOW = 9,
    GROW_FAILED = 10,
    DESTROY_ALL_SNAPSHOTS = 11,
    FILE_SYSTEM_FAILURE = 12,
    IO_FAILURE = 13,
    DIFF_AREA_REMOVED = 14,
    EXTERNAL_WRITER_TO_DIFF_AREA = 15,
    MOUNT_DURING_CLUSTER_OFFLINE = 16,
};
pub const VSS_PROTECTION_FAULT_NONE = VSS_PROTECTION_FAULT.NONE;
pub const VSS_PROTECTION_FAULT_DIFF_AREA_MISSING = VSS_PROTECTION_FAULT.DIFF_AREA_MISSING;
pub const VSS_PROTECTION_FAULT_IO_FAILURE_DURING_ONLINE = VSS_PROTECTION_FAULT.IO_FAILURE_DURING_ONLINE;
pub const VSS_PROTECTION_FAULT_META_DATA_CORRUPTION = VSS_PROTECTION_FAULT.META_DATA_CORRUPTION;
pub const VSS_PROTECTION_FAULT_MEMORY_ALLOCATION_FAILURE = VSS_PROTECTION_FAULT.MEMORY_ALLOCATION_FAILURE;
pub const VSS_PROTECTION_FAULT_MAPPED_MEMORY_FAILURE = VSS_PROTECTION_FAULT.MAPPED_MEMORY_FAILURE;
pub const VSS_PROTECTION_FAULT_COW_READ_FAILURE = VSS_PROTECTION_FAULT.COW_READ_FAILURE;
pub const VSS_PROTECTION_FAULT_COW_WRITE_FAILURE = VSS_PROTECTION_FAULT.COW_WRITE_FAILURE;
pub const VSS_PROTECTION_FAULT_DIFF_AREA_FULL = VSS_PROTECTION_FAULT.DIFF_AREA_FULL;
pub const VSS_PROTECTION_FAULT_GROW_TOO_SLOW = VSS_PROTECTION_FAULT.GROW_TOO_SLOW;
pub const VSS_PROTECTION_FAULT_GROW_FAILED = VSS_PROTECTION_FAULT.GROW_FAILED;
pub const VSS_PROTECTION_FAULT_DESTROY_ALL_SNAPSHOTS = VSS_PROTECTION_FAULT.DESTROY_ALL_SNAPSHOTS;
pub const VSS_PROTECTION_FAULT_FILE_SYSTEM_FAILURE = VSS_PROTECTION_FAULT.FILE_SYSTEM_FAILURE;
pub const VSS_PROTECTION_FAULT_IO_FAILURE = VSS_PROTECTION_FAULT.IO_FAILURE;
pub const VSS_PROTECTION_FAULT_DIFF_AREA_REMOVED = VSS_PROTECTION_FAULT.DIFF_AREA_REMOVED;
pub const VSS_PROTECTION_FAULT_EXTERNAL_WRITER_TO_DIFF_AREA = VSS_PROTECTION_FAULT.EXTERNAL_WRITER_TO_DIFF_AREA;
pub const VSS_PROTECTION_FAULT_MOUNT_DURING_CLUSTER_OFFLINE = VSS_PROTECTION_FAULT.MOUNT_DURING_CLUSTER_OFFLINE;

pub const VSS_VOLUME_PROTECTION_INFO = extern struct {
    m_protectionLevel: VSS_PROTECTION_LEVEL,
    m_volumeIsOfflineForProtection: BOOL,
    m_protectionFault: VSS_PROTECTION_FAULT,
    m_failureStatus: i32,
    m_volumeHasUnusedDiffArea: BOOL,
    m_reserved: u32,
};

const IID_IVssSnapshotMgmt_Value = @import("../zig.zig").Guid.initString("fa7df749-66e7-4986-a27f-e2f04ae53772");
pub const IID_IVssSnapshotMgmt = &IID_IVssSnapshotMgmt_Value;
pub const IVssSnapshotMgmt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProviderMgmtInterface: fn(
            self: *const IVssSnapshotMgmt,
            ProviderId: Guid,
            InterfaceId: *const Guid,
            ppItf: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryVolumesSupportedForSnapshots: fn(
            self: *const IVssSnapshotMgmt,
            ProviderId: Guid,
            lContext: i32,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QuerySnapshotsByVolume: fn(
            self: *const IVssSnapshotMgmt,
            pwszVolumeName: *u16,
            ProviderId: Guid,
            ppEnum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSnapshotMgmt_GetProviderMgmtInterface(self: *const T, ProviderId: Guid, InterfaceId: *const Guid, ppItf: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSnapshotMgmt.VTable, self.vtable).GetProviderMgmtInterface(@ptrCast(*const IVssSnapshotMgmt, self), ProviderId, InterfaceId, ppItf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSnapshotMgmt_QueryVolumesSupportedForSnapshots(self: *const T, ProviderId: Guid, lContext: i32, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSnapshotMgmt.VTable, self.vtable).QueryVolumesSupportedForSnapshots(@ptrCast(*const IVssSnapshotMgmt, self), ProviderId, lContext, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSnapshotMgmt_QuerySnapshotsByVolume(self: *const T, pwszVolumeName: *u16, ProviderId: Guid, ppEnum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSnapshotMgmt.VTable, self.vtable).QuerySnapshotsByVolume(@ptrCast(*const IVssSnapshotMgmt, self), pwszVolumeName, ProviderId, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssSnapshotMgmt2_Value = @import("../zig.zig").Guid.initString("0f61ec39-fe82-45f2-a3f0-768b5d427102");
pub const IID_IVssSnapshotMgmt2 = &IID_IVssSnapshotMgmt2_Value;
pub const IVssSnapshotMgmt2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetMinDiffAreaSize: fn(
            self: *const IVssSnapshotMgmt2,
            pllMinDiffAreaSize: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSnapshotMgmt2_GetMinDiffAreaSize(self: *const T, pllMinDiffAreaSize: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSnapshotMgmt2.VTable, self.vtable).GetMinDiffAreaSize(@ptrCast(*const IVssSnapshotMgmt2, self), pllMinDiffAreaSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssDifferentialSoftwareSnapshotMgmt_Value = @import("../zig.zig").Guid.initString("214a0f28-b737-4026-b847-4f9e37d79529");
pub const IID_IVssDifferentialSoftwareSnapshotMgmt = &IID_IVssDifferentialSoftwareSnapshotMgmt_Value;
pub const IVssDifferentialSoftwareSnapshotMgmt = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDiffArea: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            llMaximumDiffSpace: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDiffAreaMaximumSize: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            llMaximumDiffSpace: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryVolumesSupportedForDiffAreas: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszOriginalVolumeName: *u16,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDiffAreasForVolume: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszVolumeName: *u16,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDiffAreasOnVolume: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            pwszVolumeName: *u16,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryDiffAreasForSnapshot: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt,
            SnapshotId: Guid,
            ppEnum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_AddDiffArea(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, llMaximumDiffSpace: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).AddDiffArea(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszVolumeName, pwszDiffAreaVolumeName, llMaximumDiffSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_ChangeDiffAreaMaximumSize(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, llMaximumDiffSpace: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).ChangeDiffAreaMaximumSize(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszVolumeName, pwszDiffAreaVolumeName, llMaximumDiffSpace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_QueryVolumesSupportedForDiffAreas(self: *const T, pwszOriginalVolumeName: *u16, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).QueryVolumesSupportedForDiffAreas(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszOriginalVolumeName, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForVolume(self: *const T, pwszVolumeName: *u16, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).QueryDiffAreasForVolume(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszVolumeName, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasOnVolume(self: *const T, pwszVolumeName: *u16, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).QueryDiffAreasOnVolume(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), pwszVolumeName, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt_QueryDiffAreasForSnapshot(self: *const T, SnapshotId: Guid, ppEnum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt.VTable, self.vtable).QueryDiffAreasForSnapshot(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt, self), SnapshotId, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssDifferentialSoftwareSnapshotMgmt2_Value = @import("../zig.zig").Guid.initString("949d7353-675f-4275-8969-f044c6277815");
pub const IID_IVssDifferentialSoftwareSnapshotMgmt2 = &IID_IVssDifferentialSoftwareSnapshotMgmt2_Value;
pub const IVssDifferentialSoftwareSnapshotMgmt2 = extern struct {
    pub const VTable = extern struct {
        base: IVssDifferentialSoftwareSnapshotMgmt.VTable,
        ChangeDiffAreaMaximumSizeEx: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt2,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            llMaximumDiffSpace: i64,
            bVolatile: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MigrateDiffAreas: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt2,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            pwszNewDiffAreaVolumeName: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryMigrationStatus: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt2,
            pwszVolumeName: *u16,
            pwszDiffAreaVolumeName: *u16,
            ppAsync: **IVssAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapshotPriority: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt2,
            idSnapshot: Guid,
            priority: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssDifferentialSoftwareSnapshotMgmt.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt2_ChangeDiffAreaMaximumSizeEx(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, llMaximumDiffSpace: i64, bVolatile: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2.VTable, self.vtable).ChangeDiffAreaMaximumSizeEx(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2, self), pwszVolumeName, pwszDiffAreaVolumeName, llMaximumDiffSpace, bVolatile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt2_MigrateDiffAreas(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, pwszNewDiffAreaVolumeName: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2.VTable, self.vtable).MigrateDiffAreas(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2, self), pwszVolumeName, pwszDiffAreaVolumeName, pwszNewDiffAreaVolumeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt2_QueryMigrationStatus(self: *const T, pwszVolumeName: *u16, pwszDiffAreaVolumeName: *u16, ppAsync: **IVssAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2.VTable, self.vtable).QueryMigrationStatus(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2, self), pwszVolumeName, pwszDiffAreaVolumeName, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt2_SetSnapshotPriority(self: *const T, idSnapshot: Guid, priority: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2.VTable, self.vtable).SetSnapshotPriority(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt2, self), idSnapshot, priority);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssDifferentialSoftwareSnapshotMgmt3_Value = @import("../zig.zig").Guid.initString("383f7e71-a4c5-401f-b27f-f826289f8458");
pub const IID_IVssDifferentialSoftwareSnapshotMgmt3 = &IID_IVssDifferentialSoftwareSnapshotMgmt3_Value;
pub const IVssDifferentialSoftwareSnapshotMgmt3 = extern struct {
    pub const VTable = extern struct {
        base: IVssDifferentialSoftwareSnapshotMgmt2.VTable,
        SetVolumeProtectLevel: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            pwszVolumeName: *u16,
            protectionLevel: VSS_PROTECTION_LEVEL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVolumeProtectLevel: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            pwszVolumeName: *u16,
            protectionLevel: *VSS_VOLUME_PROTECTION_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearVolumeProtectFault: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            pwszVolumeName: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteUnusedDiffAreas: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            pwszDiffAreaVolumeName: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QuerySnapshotDeltaBitmap: fn(
            self: *const IVssDifferentialSoftwareSnapshotMgmt3,
            idSnapshotOlder: Guid,
            idSnapshotYounger: Guid,
            pcBlockSizePerBit: *u32,
            pcBitmapLength: *u32,
            ppbBitmap: [*]*u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssDifferentialSoftwareSnapshotMgmt2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_SetVolumeProtectLevel(self: *const T, pwszVolumeName: *u16, protectionLevel: VSS_PROTECTION_LEVEL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).SetVolumeProtectLevel(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), pwszVolumeName, protectionLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_GetVolumeProtectLevel(self: *const T, pwszVolumeName: *u16, protectionLevel: *VSS_VOLUME_PROTECTION_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).GetVolumeProtectLevel(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), pwszVolumeName, protectionLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_ClearVolumeProtectFault(self: *const T, pwszVolumeName: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).ClearVolumeProtectFault(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), pwszVolumeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_DeleteUnusedDiffAreas(self: *const T, pwszDiffAreaVolumeName: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).DeleteUnusedDiffAreas(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), pwszDiffAreaVolumeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssDifferentialSoftwareSnapshotMgmt3_QuerySnapshotDeltaBitmap(self: *const T, idSnapshotOlder: Guid, idSnapshotYounger: Guid, pcBlockSizePerBit: *u32, pcBitmapLength: *u32, ppbBitmap: [*]*u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3.VTable, self.vtable).QuerySnapshotDeltaBitmap(@ptrCast(*const IVssDifferentialSoftwareSnapshotMgmt3, self), idSnapshotOlder, idSnapshotYounger, pcBlockSizePerBit, pcBitmapLength, ppbBitmap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssEnumMgmtObject_Value = @import("../zig.zig").Guid.initString("01954e6b-9254-4e6e-808c-c9e05d007696");
pub const IID_IVssEnumMgmtObject = &IID_IVssEnumMgmtObject_Value;
pub const IVssEnumMgmtObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IVssEnumMgmtObject,
            celt: u32,
            rgelt: [*]VSS_MGMT_OBJECT_PROP,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IVssEnumMgmtObject,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IVssEnumMgmtObject,
            ppenum: **IVssEnumMgmtObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumMgmtObject_Next(self: *const T, celt: u32, rgelt: [*]VSS_MGMT_OBJECT_PROP, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumMgmtObject.VTable, self.vtable).Next(@ptrCast(*const IVssEnumMgmtObject, self), celt, rgelt, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumMgmtObject_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumMgmtObject.VTable, self.vtable).Skip(@ptrCast(*const IVssEnumMgmtObject, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumMgmtObject_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumMgmtObject.VTable, self.vtable).Reset(@ptrCast(*const IVssEnumMgmtObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssEnumMgmtObject_Clone(self: *const T, ppenum: **IVssEnumMgmtObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssEnumMgmtObject.VTable, self.vtable).Clone(@ptrCast(*const IVssEnumMgmtObject, self), ppenum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_VSSCoordinator_Value = @import("../zig.zig").Guid.initString("e579ab5f-1cc4-44b4-bed9-de0991ff0623");
pub const CLSID_VSSCoordinator = &CLSID_VSSCoordinator_Value;

const IID_IVssAdmin_Value = @import("../zig.zig").Guid.initString("77ed5996-2f63-11d3-8a39-00c04f72d8e3");
pub const IID_IVssAdmin = &IID_IVssAdmin_Value;
pub const IVssAdmin = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterProvider: fn(
            self: *const IVssAdmin,
            pProviderId: Guid,
            ClassId: Guid,
            pwszProviderName: *u16,
            eProviderType: VSS_PROVIDER_TYPE,
            pwszProviderVersion: *u16,
            ProviderVersionId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterProvider: fn(
            self: *const IVssAdmin,
            ProviderId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryProviders: fn(
            self: *const IVssAdmin,
            ppEnum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortAllSnapshotsInProgress: fn(
            self: *const IVssAdmin,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdmin_RegisterProvider(self: *const T, pProviderId: Guid, ClassId: Guid, pwszProviderName: *u16, eProviderType: VSS_PROVIDER_TYPE, pwszProviderVersion: *u16, ProviderVersionId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdmin.VTable, self.vtable).RegisterProvider(@ptrCast(*const IVssAdmin, self), pProviderId, ClassId, pwszProviderName, eProviderType, pwszProviderVersion, ProviderVersionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdmin_UnregisterProvider(self: *const T, ProviderId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdmin.VTable, self.vtable).UnregisterProvider(@ptrCast(*const IVssAdmin, self), ProviderId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdmin_QueryProviders(self: *const T, ppEnum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdmin.VTable, self.vtable).QueryProviders(@ptrCast(*const IVssAdmin, self), ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdmin_AbortAllSnapshotsInProgress(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdmin.VTable, self.vtable).AbortAllSnapshotsInProgress(@ptrCast(*const IVssAdmin, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssAdminEx_Value = @import("../zig.zig").Guid.initString("7858a9f8-b1fa-41a6-964f-b9b36b8cd8d8");
pub const IID_IVssAdminEx = &IID_IVssAdminEx_Value;
pub const IVssAdminEx = extern struct {
    pub const VTable = extern struct {
        base: IVssAdmin.VTable,
        GetProviderCapability: fn(
            self: *const IVssAdminEx,
            pProviderId: Guid,
            pllOriginalCapabilityMask: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderContext: fn(
            self: *const IVssAdminEx,
            ProviderId: Guid,
            plContext: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProviderContext: fn(
            self: *const IVssAdminEx,
            ProviderId: Guid,
            lContext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssAdmin.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdminEx_GetProviderCapability(self: *const T, pProviderId: Guid, pllOriginalCapabilityMask: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdminEx.VTable, self.vtable).GetProviderCapability(@ptrCast(*const IVssAdminEx, self), pProviderId, pllOriginalCapabilityMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdminEx_GetProviderContext(self: *const T, ProviderId: Guid, plContext: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdminEx.VTable, self.vtable).GetProviderContext(@ptrCast(*const IVssAdminEx, self), ProviderId, plContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssAdminEx_SetProviderContext(self: *const T, ProviderId: Guid, lContext: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssAdminEx.VTable, self.vtable).SetProviderContext(@ptrCast(*const IVssAdminEx, self), ProviderId, lContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssSoftwareSnapshotProvider_Value = @import("../zig.zig").Guid.initString("609e123e-2c5a-44d3-8f01-0b1d9a47d1ff");
pub const IID_IVssSoftwareSnapshotProvider = &IID_IVssSoftwareSnapshotProvider_Value;
pub const IVssSoftwareSnapshotProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetContext: fn(
            self: *const IVssSoftwareSnapshotProvider,
            lContext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapshotProperties: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SnapshotId: Guid,
            pProp: *VSS_SNAPSHOT_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IVssSoftwareSnapshotProvider,
            QueriedObjectId: Guid,
            eQueriedObjectType: VSS_OBJECT_TYPE,
            eReturnedObjectsType: VSS_OBJECT_TYPE,
            ppEnum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSnapshots: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SourceObjectId: Guid,
            eSourceObjectType: VSS_OBJECT_TYPE,
            bForceDelete: BOOL,
            plDeletedSnapshots: *i32,
            pNondeletedSnapshotID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginPrepareSnapshot: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SnapshotSetId: Guid,
            SnapshotId: Guid,
            pwszVolumeName: *u16,
            lNewContext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVolumeSupported: fn(
            self: *const IVssSoftwareSnapshotProvider,
            pwszVolumeName: *u16,
            pbSupportedByThisProvider: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVolumeSnapshotted: fn(
            self: *const IVssSoftwareSnapshotProvider,
            pwszVolumeName: *u16,
            pbSnapshotsPresent: *BOOL,
            plSnapshotCompatibility: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapshotProperty: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SnapshotId: Guid,
            eSnapshotPropertyId: VSS_SNAPSHOT_PROPERTY_ID,
            vProperty: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RevertToSnapshot: fn(
            self: *const IVssSoftwareSnapshotProvider,
            SnapshotId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryRevertStatus: fn(
            self: *const IVssSoftwareSnapshotProvider,
            pwszVolume: *u16,
            ppAsync: **IVssAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_SetContext(self: *const T, lContext: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).SetContext(@ptrCast(*const IVssSoftwareSnapshotProvider, self), lContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_GetSnapshotProperties(self: *const T, SnapshotId: Guid, pProp: *VSS_SNAPSHOT_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).GetSnapshotProperties(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SnapshotId, pProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_Query(self: *const T, QueriedObjectId: Guid, eQueriedObjectType: VSS_OBJECT_TYPE, eReturnedObjectsType: VSS_OBJECT_TYPE, ppEnum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).Query(@ptrCast(*const IVssSoftwareSnapshotProvider, self), QueriedObjectId, eQueriedObjectType, eReturnedObjectsType, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_DeleteSnapshots(self: *const T, SourceObjectId: Guid, eSourceObjectType: VSS_OBJECT_TYPE, bForceDelete: BOOL, plDeletedSnapshots: *i32, pNondeletedSnapshotID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).DeleteSnapshots(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SourceObjectId, eSourceObjectType, bForceDelete, plDeletedSnapshots, pNondeletedSnapshotID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_BeginPrepareSnapshot(self: *const T, SnapshotSetId: Guid, SnapshotId: Guid, pwszVolumeName: *u16, lNewContext: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).BeginPrepareSnapshot(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SnapshotSetId, SnapshotId, pwszVolumeName, lNewContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_IsVolumeSupported(self: *const T, pwszVolumeName: *u16, pbSupportedByThisProvider: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).IsVolumeSupported(@ptrCast(*const IVssSoftwareSnapshotProvider, self), pwszVolumeName, pbSupportedByThisProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_IsVolumeSnapshotted(self: *const T, pwszVolumeName: *u16, pbSnapshotsPresent: *BOOL, plSnapshotCompatibility: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).IsVolumeSnapshotted(@ptrCast(*const IVssSoftwareSnapshotProvider, self), pwszVolumeName, pbSnapshotsPresent, plSnapshotCompatibility);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_SetSnapshotProperty(self: *const T, SnapshotId: Guid, eSnapshotPropertyId: VSS_SNAPSHOT_PROPERTY_ID, vProperty: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).SetSnapshotProperty(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SnapshotId, eSnapshotPropertyId, vProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_RevertToSnapshot(self: *const T, SnapshotId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).RevertToSnapshot(@ptrCast(*const IVssSoftwareSnapshotProvider, self), SnapshotId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssSoftwareSnapshotProvider_QueryRevertStatus(self: *const T, pwszVolume: *u16, ppAsync: **IVssAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssSoftwareSnapshotProvider.VTable, self.vtable).QueryRevertStatus(@ptrCast(*const IVssSoftwareSnapshotProvider, self), pwszVolume, ppAsync);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssProviderCreateSnapshotSet_Value = @import("../zig.zig").Guid.initString("5f894e5b-1e39-4778-8e23-9abad9f0e08c");
pub const IID_IVssProviderCreateSnapshotSet = &IID_IVssProviderCreateSnapshotSet_Value;
pub const IVssProviderCreateSnapshotSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EndPrepareSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreCommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostCommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
            lSnapshotsCount: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreFinalCommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostFinalCommitSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortSnapshots: fn(
            self: *const IVssProviderCreateSnapshotSet,
            SnapshotSetId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_EndPrepareSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).EndPrepareSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_PreCommitSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).PreCommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_CommitSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).CommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_PostCommitSnapshots(self: *const T, SnapshotSetId: Guid, lSnapshotsCount: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).PostCommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId, lSnapshotsCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_PreFinalCommitSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).PreFinalCommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_PostFinalCommitSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).PostFinalCommitSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderCreateSnapshotSet_AbortSnapshots(self: *const T, SnapshotSetId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderCreateSnapshotSet.VTable, self.vtable).AbortSnapshots(@ptrCast(*const IVssProviderCreateSnapshotSet, self), SnapshotSetId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssProviderNotifications_Value = @import("../zig.zig").Guid.initString("e561901f-03a5-4afe-86d0-72baeece7004");
pub const IID_IVssProviderNotifications = &IID_IVssProviderNotifications_Value;
pub const IVssProviderNotifications = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnLoad: fn(
            self: *const IVssProviderNotifications,
            pCallback: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnUnload: fn(
            self: *const IVssProviderNotifications,
            bForceUnload: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderNotifications_OnLoad(self: *const T, pCallback: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderNotifications.VTable, self.vtable).OnLoad(@ptrCast(*const IVssProviderNotifications, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssProviderNotifications_OnUnload(self: *const T, bForceUnload: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssProviderNotifications.VTable, self.vtable).OnUnload(@ptrCast(*const IVssProviderNotifications, self), bForceUnload);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssHardwareSnapshotProvider_Value = @import("../zig.zig").Guid.initString("9593a157-44e9-4344-bbeb-44fbf9b06b10");
pub const IID_IVssHardwareSnapshotProvider = &IID_IVssHardwareSnapshotProvider_Value;
pub const IVssHardwareSnapshotProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AreLunsSupported: fn(
            self: *const IVssHardwareSnapshotProvider,
            lLunCount: i32,
            lContext: i32,
            rgwszDevices: [*]*u16,
            pLunInformation: [*]VDS_LUN_INFORMATION,
            pbIsSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillInLunInfo: fn(
            self: *const IVssHardwareSnapshotProvider,
            wszDeviceName: *u16,
            pLunInfo: *VDS_LUN_INFORMATION,
            pbIsSupported: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginPrepareSnapshot: fn(
            self: *const IVssHardwareSnapshotProvider,
            SnapshotSetId: Guid,
            SnapshotId: Guid,
            lContext: i32,
            lLunCount: i32,
            rgDeviceNames: [*]*u16,
            rgLunInformation: [*]VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetLuns: fn(
            self: *const IVssHardwareSnapshotProvider,
            lLunCount: i32,
            rgDeviceNames: [*]*u16,
            rgSourceLuns: [*]VDS_LUN_INFORMATION,
            rgDestinationLuns: [*]VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LocateLuns: fn(
            self: *const IVssHardwareSnapshotProvider,
            lLunCount: i32,
            rgSourceLuns: [*]VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLunEmpty: fn(
            self: *const IVssHardwareSnapshotProvider,
            wszDeviceName: *u16,
            pInformation: *VDS_LUN_INFORMATION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_AreLunsSupported(self: *const T, lLunCount: i32, lContext: i32, rgwszDevices: [*]*u16, pLunInformation: [*]VDS_LUN_INFORMATION, pbIsSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).AreLunsSupported(@ptrCast(*const IVssHardwareSnapshotProvider, self), lLunCount, lContext, rgwszDevices, pLunInformation, pbIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_FillInLunInfo(self: *const T, wszDeviceName: *u16, pLunInfo: *VDS_LUN_INFORMATION, pbIsSupported: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).FillInLunInfo(@ptrCast(*const IVssHardwareSnapshotProvider, self), wszDeviceName, pLunInfo, pbIsSupported);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_BeginPrepareSnapshot(self: *const T, SnapshotSetId: Guid, SnapshotId: Guid, lContext: i32, lLunCount: i32, rgDeviceNames: [*]*u16, rgLunInformation: [*]VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).BeginPrepareSnapshot(@ptrCast(*const IVssHardwareSnapshotProvider, self), SnapshotSetId, SnapshotId, lContext, lLunCount, rgDeviceNames, rgLunInformation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_GetTargetLuns(self: *const T, lLunCount: i32, rgDeviceNames: [*]*u16, rgSourceLuns: [*]VDS_LUN_INFORMATION, rgDestinationLuns: [*]VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).GetTargetLuns(@ptrCast(*const IVssHardwareSnapshotProvider, self), lLunCount, rgDeviceNames, rgSourceLuns, rgDestinationLuns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_LocateLuns(self: *const T, lLunCount: i32, rgSourceLuns: [*]VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).LocateLuns(@ptrCast(*const IVssHardwareSnapshotProvider, self), lLunCount, rgSourceLuns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProvider_OnLunEmpty(self: *const T, wszDeviceName: *u16, pInformation: *VDS_LUN_INFORMATION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProvider.VTable, self.vtable).OnLunEmpty(@ptrCast(*const IVssHardwareSnapshotProvider, self), wszDeviceName, pInformation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssHardwareSnapshotProviderEx_Value = @import("../zig.zig").Guid.initString("7f5ba925-cdb1-4d11-a71f-339eb7e709fd");
pub const IID_IVssHardwareSnapshotProviderEx = &IID_IVssHardwareSnapshotProviderEx_Value;
pub const IVssHardwareSnapshotProviderEx = extern struct {
    pub const VTable = extern struct {
        base: IVssHardwareSnapshotProvider.VTable,
        GetProviderCapabilities: fn(
            self: *const IVssHardwareSnapshotProviderEx,
            pllOriginalCapabilityMask: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLunStateChange: fn(
            self: *const IVssHardwareSnapshotProviderEx,
            pSnapshotLuns: [*]VDS_LUN_INFORMATION,
            pOriginalLuns: [*]VDS_LUN_INFORMATION,
            dwCount: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResyncLuns: fn(
            self: *const IVssHardwareSnapshotProviderEx,
            pSourceLuns: [*]VDS_LUN_INFORMATION,
            pTargetLuns: [*]VDS_LUN_INFORMATION,
            dwCount: u32,
            ppAsync: **IVssAsync,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnReuseLuns: fn(
            self: *const IVssHardwareSnapshotProviderEx,
            pSnapshotLuns: [*]VDS_LUN_INFORMATION,
            pOriginalLuns: [*]VDS_LUN_INFORMATION,
            dwCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IVssHardwareSnapshotProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProviderEx_GetProviderCapabilities(self: *const T, pllOriginalCapabilityMask: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProviderEx.VTable, self.vtable).GetProviderCapabilities(@ptrCast(*const IVssHardwareSnapshotProviderEx, self), pllOriginalCapabilityMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProviderEx_OnLunStateChange(self: *const T, pSnapshotLuns: [*]VDS_LUN_INFORMATION, pOriginalLuns: [*]VDS_LUN_INFORMATION, dwCount: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProviderEx.VTable, self.vtable).OnLunStateChange(@ptrCast(*const IVssHardwareSnapshotProviderEx, self), pSnapshotLuns, pOriginalLuns, dwCount, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProviderEx_ResyncLuns(self: *const T, pSourceLuns: [*]VDS_LUN_INFORMATION, pTargetLuns: [*]VDS_LUN_INFORMATION, dwCount: u32, ppAsync: **IVssAsync) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProviderEx.VTable, self.vtable).ResyncLuns(@ptrCast(*const IVssHardwareSnapshotProviderEx, self), pSourceLuns, pTargetLuns, dwCount, ppAsync);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssHardwareSnapshotProviderEx_OnReuseLuns(self: *const T, pSnapshotLuns: [*]VDS_LUN_INFORMATION, pOriginalLuns: [*]VDS_LUN_INFORMATION, dwCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssHardwareSnapshotProviderEx.VTable, self.vtable).OnReuseLuns(@ptrCast(*const IVssHardwareSnapshotProviderEx, self), pSnapshotLuns, pOriginalLuns, dwCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IVssFileShareSnapshotProvider_Value = @import("../zig.zig").Guid.initString("c8636060-7c2e-11df-8c4a-0800200c9a66");
pub const IID_IVssFileShareSnapshotProvider = &IID_IVssFileShareSnapshotProvider_Value;
pub const IVssFileShareSnapshotProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetContext: fn(
            self: *const IVssFileShareSnapshotProvider,
            lContext: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapshotProperties: fn(
            self: *const IVssFileShareSnapshotProvider,
            SnapshotId: Guid,
            pProp: *VSS_SNAPSHOT_PROP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Query: fn(
            self: *const IVssFileShareSnapshotProvider,
            QueriedObjectId: Guid,
            eQueriedObjectType: VSS_OBJECT_TYPE,
            eReturnedObjectsType: VSS_OBJECT_TYPE,
            ppEnum: **IVssEnumObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSnapshots: fn(
            self: *const IVssFileShareSnapshotProvider,
            SourceObjectId: Guid,
            eSourceObjectType: VSS_OBJECT_TYPE,
            bForceDelete: BOOL,
            plDeletedSnapshots: *i32,
            pNondeletedSnapshotID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginPrepareSnapshot: fn(
            self: *const IVssFileShareSnapshotProvider,
            SnapshotSetId: Guid,
            SnapshotId: Guid,
            pwszSharePath: *u16,
            lNewContext: i32,
            ProviderId: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPathSupported: fn(
            self: *const IVssFileShareSnapshotProvider,
            pwszSharePath: *u16,
            pbSupportedByThisProvider: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPathSnapshotted: fn(
            self: *const IVssFileShareSnapshotProvider,
            pwszSharePath: *u16,
            pbSnapshotsPresent: *BOOL,
            plSnapshotCompatibility: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapshotProperty: fn(
            self: *const IVssFileShareSnapshotProvider,
            SnapshotId: Guid,
            eSnapshotPropertyId: VSS_SNAPSHOT_PROPERTY_ID,
            vProperty: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_SetContext(self: *const T, lContext: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).SetContext(@ptrCast(*const IVssFileShareSnapshotProvider, self), lContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_GetSnapshotProperties(self: *const T, SnapshotId: Guid, pProp: *VSS_SNAPSHOT_PROP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).GetSnapshotProperties(@ptrCast(*const IVssFileShareSnapshotProvider, self), SnapshotId, pProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_Query(self: *const T, QueriedObjectId: Guid, eQueriedObjectType: VSS_OBJECT_TYPE, eReturnedObjectsType: VSS_OBJECT_TYPE, ppEnum: **IVssEnumObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).Query(@ptrCast(*const IVssFileShareSnapshotProvider, self), QueriedObjectId, eQueriedObjectType, eReturnedObjectsType, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_DeleteSnapshots(self: *const T, SourceObjectId: Guid, eSourceObjectType: VSS_OBJECT_TYPE, bForceDelete: BOOL, plDeletedSnapshots: *i32, pNondeletedSnapshotID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).DeleteSnapshots(@ptrCast(*const IVssFileShareSnapshotProvider, self), SourceObjectId, eSourceObjectType, bForceDelete, plDeletedSnapshots, pNondeletedSnapshotID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_BeginPrepareSnapshot(self: *const T, SnapshotSetId: Guid, SnapshotId: Guid, pwszSharePath: *u16, lNewContext: i32, ProviderId: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).BeginPrepareSnapshot(@ptrCast(*const IVssFileShareSnapshotProvider, self), SnapshotSetId, SnapshotId, pwszSharePath, lNewContext, ProviderId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_IsPathSupported(self: *const T, pwszSharePath: *u16, pbSupportedByThisProvider: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).IsPathSupported(@ptrCast(*const IVssFileShareSnapshotProvider, self), pwszSharePath, pbSupportedByThisProvider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_IsPathSnapshotted(self: *const T, pwszSharePath: *u16, pbSnapshotsPresent: *BOOL, plSnapshotCompatibility: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).IsPathSnapshotted(@ptrCast(*const IVssFileShareSnapshotProvider, self), pwszSharePath, pbSnapshotsPresent, plSnapshotCompatibility);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IVssFileShareSnapshotProvider_SetSnapshotProperty(self: *const T, SnapshotId: Guid, eSnapshotPropertyId: VSS_SNAPSHOT_PROPERTY_ID, vProperty: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IVssFileShareSnapshotProvider.VTable, self.vtable).SetSnapshotProperty(@ptrCast(*const IVssFileShareSnapshotProvider, self), SnapshotId, eSnapshotPropertyId, vProperty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IDDVideoPortContainer = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawVideoPort = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawVideoPortNotify = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDDVideoPortContainerVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawVideoPortVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IDirectDrawVideoPortNotifyVtbl = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const LPDDENUMVIDEOCALLBACK = fn(
    param0: *DDVIDEOPORTCAPS,
    param1: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DDVIDEOPORTSTATUS = extern struct {
    dwSize: u32,
    bInUse: BOOL,
    dwFlags: u32,
    dwReserved1: u32,
    VideoPortType: DDVIDEOPORTCONNECT,
    dwReserved2: ?*c_void,
    dwReserved3: ?*c_void,
};

pub const DDVIDEOPORTNOTIFY = extern struct {
    ApproximateTimeStamp: LARGE_INTEGER,
    lField: i32,
    dwSurfaceIndex: u32,
    lDone: i32,
};

pub const _DD_DESTROYDRIVERDATA = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const _DD_SETMODEDATA = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const _DD_GETVPORTAUTOFLIPSURFACEDATA = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const PDD_SETCOLORKEY = fn(
    param0: *DD_DRVSETCOLORKEYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_DESTROYDRIVER = fn(
    param0: *_DD_DESTROYDRIVERDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_SETMODE = fn(
    param0: *_DD_SETMODEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_ALPHABLT = fn(
    param0: *DD_BLTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_SURFCB_SETCLIPLIST = fn(
    param0: *DD_SETCLIPLISTDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDD_VPORTCB_GETAUTOFLIPSURF = fn(
    param0: *_DD_GETVPORTAUTOFLIPSURFACEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DD_MORECAPS = extern struct {
    dwSize: u32,
    dwAlphaCaps: u32,
    dwSVBAlphaCaps: u32,
    dwVSBAlphaCaps: u32,
    dwSSBAlphaCaps: u32,
    dwFilterCaps: u32,
    dwSVBFilterCaps: u32,
    dwVSBFilterCaps: u32,
    dwSSBFilterCaps: u32,
};

pub const DDNTCORECAPS = extern struct {
    dwSize: u32,
    dwCaps: u32,
    dwCaps2: u32,
    dwCKeyCaps: u32,
    dwFXCaps: u32,
    dwFXAlphaCaps: u32,
    dwPalCaps: u32,
    dwSVCaps: u32,
    dwAlphaBltConstBitDepths: u32,
    dwAlphaBltPixelBitDepths: u32,
    dwAlphaBltSurfaceBitDepths: u32,
    dwAlphaOverlayConstBitDepths: u32,
    dwAlphaOverlayPixelBitDepths: u32,
    dwAlphaOverlaySurfaceBitDepths: u32,
    dwZBufferBitDepths: u32,
    dwVidMemTotal: u32,
    dwVidMemFree: u32,
    dwMaxVisibleOverlays: u32,
    dwCurrVisibleOverlays: u32,
    dwNumFourCCCodes: u32,
    dwAlignBoundarySrc: u32,
    dwAlignSizeSrc: u32,
    dwAlignBoundaryDest: u32,
    dwAlignSizeDest: u32,
    dwAlignStrideAlign: u32,
    dwRops: [8]u32,
    ddsCaps: DDSCAPS,
    dwMinOverlayStretch: u32,
    dwMaxOverlayStretch: u32,
    dwMinLiveVideoStretch: u32,
    dwMaxLiveVideoStretch: u32,
    dwMinHwCodecStretch: u32,
    dwMaxHwCodecStretch: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwSVBCaps: u32,
    dwSVBCKeyCaps: u32,
    dwSVBFXCaps: u32,
    dwSVBRops: [8]u32,
    dwVSBCaps: u32,
    dwVSBCKeyCaps: u32,
    dwVSBFXCaps: u32,
    dwVSBRops: [8]u32,
    dwSSBCaps: u32,
    dwSSBCKeyCaps: u32,
    dwSSBFXCaps: u32,
    dwSSBRops: [8]u32,
    dwMaxVideoPorts: u32,
    dwCurrVideoPorts: u32,
    dwSVBCaps2: u32,
};

pub const DD_HALINFO_V4 = extern struct {
    dwSize: u32,
    vmiData: VIDEOMEMORYINFO,
    ddCaps: DDNTCORECAPS,
    GetDriverInfo: PDD_GETDRIVERINFO,
    dwFlags: u32,
};

pub const DD_SETCLIPLISTDATA = extern struct {
    lpDD: *DD_DIRECTDRAW_GLOBAL,
    lpDDSurface: *DD_SURFACE_LOCAL,
    ddRVal: HRESULT,
    SetClipList: *c_void,
};

pub const DD_DRVSETCOLORKEYDATA = extern struct {
    lpDDSurface: *DD_SURFACE_LOCAL,
    dwFlags: u32,
    ckNew: DDCOLORKEY,
    ddRVal: HRESULT,
    SetColorKey: *c_void,
};

pub const DD_DESTROYDDLOCALDATA = extern struct {
    dwFlags: u32,
    pDDLcl: *DD_DIRECTDRAW_LOCAL,
    ddRVal: HRESULT,
};

pub const LPD3DVALIDATECALLBACK = fn(
    lpUserArg: *c_void,
    dwOffset: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPD3DENUMTEXTUREFORMATSCALLBACK = fn(
    lpDdsd: *DDSURFACEDESC,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPD3DENUMPIXELFORMATSCALLBACK = fn(
    lpDDPixFmt: *DDPIXELFORMAT,
    lpContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const D3DRECT = extern struct {
    Anonymous1: D3DRECT._Anonymous1_e__Union,
    Anonymous2: D3DRECT._Anonymous2_e__Union,
    Anonymous3: D3DRECT._Anonymous3_e__Union,
    Anonymous4: D3DRECT._Anonymous4_e__Union,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DVECTOR = extern struct {
    Anonymous1: D3DVECTOR._Anonymous1_e__Union,
    Anonymous2: D3DVECTOR._Anonymous2_e__Union,
    Anonymous3: D3DVECTOR._Anonymous3_e__Union,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DHVERTEX = extern struct {
    dwFlags: u32,
    Anonymous1: D3DHVERTEX._Anonymous1_e__Union,
    Anonymous2: D3DHVERTEX._Anonymous2_e__Union,
    Anonymous3: D3DHVERTEX._Anonymous3_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DTLVERTEX = extern struct {
    Anonymous1: D3DTLVERTEX._Anonymous1_e__Union,
    Anonymous2: D3DTLVERTEX._Anonymous2_e__Union,
    Anonymous3: D3DTLVERTEX._Anonymous3_e__Union,
    Anonymous4: D3DTLVERTEX._Anonymous4_e__Union,
    Anonymous5: D3DTLVERTEX._Anonymous5_e__Union,
    Anonymous6: D3DTLVERTEX._Anonymous6_e__Union,
    Anonymous7: D3DTLVERTEX._Anonymous7_e__Union,
    Anonymous8: D3DTLVERTEX._Anonymous8_e__Union,
    const _Anonymous7_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous8_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous6_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DLVERTEX = extern struct {
    Anonymous1: D3DLVERTEX._Anonymous1_e__Union,
    Anonymous2: D3DLVERTEX._Anonymous2_e__Union,
    Anonymous3: D3DLVERTEX._Anonymous3_e__Union,
    dwReserved: u32,
    Anonymous4: D3DLVERTEX._Anonymous4_e__Union,
    Anonymous5: D3DLVERTEX._Anonymous5_e__Union,
    Anonymous6: D3DLVERTEX._Anonymous6_e__Union,
    Anonymous7: D3DLVERTEX._Anonymous7_e__Union,
    const _Anonymous7_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous6_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DVERTEX = extern struct {
    Anonymous1: D3DVERTEX._Anonymous1_e__Union,
    Anonymous2: D3DVERTEX._Anonymous2_e__Union,
    Anonymous3: D3DVERTEX._Anonymous3_e__Union,
    Anonymous4: D3DVERTEX._Anonymous4_e__Union,
    Anonymous5: D3DVERTEX._Anonymous5_e__Union,
    Anonymous6: D3DVERTEX._Anonymous6_e__Union,
    Anonymous7: D3DVERTEX._Anonymous7_e__Union,
    Anonymous8: D3DVERTEX._Anonymous8_e__Union,
    const _Anonymous8_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous6_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous7_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DVIEWPORT = extern struct {
    dwSize: u32,
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
    dvScaleX: f32,
    dvScaleY: f32,
    dvMaxX: f32,
    dvMaxY: f32,
    dvMinZ: f32,
    dvMaxZ: f32,
};

pub const D3DVIEWPORT2 = extern struct {
    dwSize: u32,
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
    dvClipX: f32,
    dvClipY: f32,
    dvClipWidth: f32,
    dvClipHeight: f32,
    dvMinZ: f32,
    dvMaxZ: f32,
};

pub const D3DVIEWPORT7 = extern struct {
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
    dvMinZ: f32,
    dvMaxZ: f32,
};

pub const D3DTRANSFORMDATA = extern struct {
    dwSize: u32,
    lpIn: *c_void,
    dwInSize: u32,
    lpOut: *c_void,
    dwOutSize: u32,
    lpHOut: *D3DHVERTEX,
    dwClip: u32,
    dwClipIntersection: u32,
    dwClipUnion: u32,
    drExtent: D3DRECT,
};

pub const D3DLIGHTINGELEMENT = extern struct {
    dvPosition: D3DVECTOR,
    dvNormal: D3DVECTOR,
};

pub const D3DMATERIAL = extern struct {
    dwSize: u32,
    Anonymous1: D3DMATERIAL._Anonymous1_e__Union,
    Anonymous2: D3DMATERIAL._Anonymous2_e__Union,
    Anonymous3: D3DMATERIAL._Anonymous3_e__Union,
    Anonymous4: D3DMATERIAL._Anonymous4_e__Union,
    Anonymous5: D3DMATERIAL._Anonymous5_e__Union,
    hTexture: u32,
    dwRampSize: u32,
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DMATERIAL7 = extern struct {
    Anonymous1: D3DMATERIAL7._Anonymous1_e__Union,
    Anonymous2: D3DMATERIAL7._Anonymous2_e__Union,
    Anonymous3: D3DMATERIAL7._Anonymous3_e__Union,
    Anonymous4: D3DMATERIAL7._Anonymous4_e__Union,
    Anonymous5: D3DMATERIAL7._Anonymous5_e__Union,
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DLIGHTTYPE = extern enum(i32) {
    D3DLIGHT_POINT = 1,
    D3DLIGHT_SPOT = 2,
    D3DLIGHT_DIRECTIONAL = 3,
    D3DLIGHT_PARALLELPOINT = 4,
    D3DLIGHT_FORCE_DWORD = 2147483647,
};
pub const D3DLIGHT_POINT = D3DLIGHTTYPE.D3DLIGHT_POINT;
pub const D3DLIGHT_SPOT = D3DLIGHTTYPE.D3DLIGHT_SPOT;
pub const D3DLIGHT_DIRECTIONAL = D3DLIGHTTYPE.D3DLIGHT_DIRECTIONAL;
pub const D3DLIGHT_PARALLELPOINT = D3DLIGHTTYPE.D3DLIGHT_PARALLELPOINT;
pub const D3DLIGHT_FORCE_DWORD = D3DLIGHTTYPE.D3DLIGHT_FORCE_DWORD;

pub const D3DLIGHT = extern struct {
    dwSize: u32,
    dltType: D3DLIGHTTYPE,
    dcvColor: DXGI_RGBA,
    dvPosition: D3DVECTOR,
    dvDirection: D3DVECTOR,
    dvRange: f32,
    dvFalloff: f32,
    dvAttenuation0: f32,
    dvAttenuation1: f32,
    dvAttenuation2: f32,
    dvTheta: f32,
    dvPhi: f32,
};

pub const D3DLIGHT7 = extern struct {
    dltType: D3DLIGHTTYPE,
    dcvDiffuse: DXGI_RGBA,
    dcvSpecular: DXGI_RGBA,
    dcvAmbient: DXGI_RGBA,
    dvPosition: D3DVECTOR,
    dvDirection: D3DVECTOR,
    dvRange: f32,
    dvFalloff: f32,
    dvAttenuation0: f32,
    dvAttenuation1: f32,
    dvAttenuation2: f32,
    dvTheta: f32,
    dvPhi: f32,
};

pub const D3DLIGHT2 = extern struct {
    dwSize: u32,
    dltType: D3DLIGHTTYPE,
    dcvColor: DXGI_RGBA,
    dvPosition: D3DVECTOR,
    dvDirection: D3DVECTOR,
    dvRange: f32,
    dvFalloff: f32,
    dvAttenuation0: f32,
    dvAttenuation1: f32,
    dvAttenuation2: f32,
    dvTheta: f32,
    dvPhi: f32,
    dwFlags: u32,
};

pub const D3DLIGHTDATA = extern struct {
    dwSize: u32,
    lpIn: *D3DLIGHTINGELEMENT,
    dwInSize: u32,
    lpOut: *D3DTLVERTEX,
    dwOutSize: u32,
};

pub const D3DOPCODE = extern enum(i32) {
    D3DOP_POINT = 1,
    D3DOP_LINE = 2,
    D3DOP_TRIANGLE = 3,
    D3DOP_MATRIXLOAD = 4,
    D3DOP_MATRIXMULTIPLY = 5,
    D3DOP_STATETRANSFORM = 6,
    D3DOP_STATELIGHT = 7,
    D3DOP_STATERENDER = 8,
    D3DOP_PROCESSVERTICES = 9,
    D3DOP_TEXTURELOAD = 10,
    D3DOP_EXIT = 11,
    D3DOP_BRANCHFORWARD = 12,
    D3DOP_SPAN = 13,
    D3DOP_SETSTATUS = 14,
    D3DOP_FORCE_DWORD = 2147483647,
};
pub const D3DOP_POINT = D3DOPCODE.D3DOP_POINT;
pub const D3DOP_LINE = D3DOPCODE.D3DOP_LINE;
pub const D3DOP_TRIANGLE = D3DOPCODE.D3DOP_TRIANGLE;
pub const D3DOP_MATRIXLOAD = D3DOPCODE.D3DOP_MATRIXLOAD;
pub const D3DOP_MATRIXMULTIPLY = D3DOPCODE.D3DOP_MATRIXMULTIPLY;
pub const D3DOP_STATETRANSFORM = D3DOPCODE.D3DOP_STATETRANSFORM;
pub const D3DOP_STATELIGHT = D3DOPCODE.D3DOP_STATELIGHT;
pub const D3DOP_STATERENDER = D3DOPCODE.D3DOP_STATERENDER;
pub const D3DOP_PROCESSVERTICES = D3DOPCODE.D3DOP_PROCESSVERTICES;
pub const D3DOP_TEXTURELOAD = D3DOPCODE.D3DOP_TEXTURELOAD;
pub const D3DOP_EXIT = D3DOPCODE.D3DOP_EXIT;
pub const D3DOP_BRANCHFORWARD = D3DOPCODE.D3DOP_BRANCHFORWARD;
pub const D3DOP_SPAN = D3DOPCODE.D3DOP_SPAN;
pub const D3DOP_SETSTATUS = D3DOPCODE.D3DOP_SETSTATUS;
pub const D3DOP_FORCE_DWORD = D3DOPCODE.D3DOP_FORCE_DWORD;

pub const D3DINSTRUCTION = extern struct {
    bOpcode: u8,
    bSize: u8,
    wCount: u16,
};

pub const D3DTEXTURELOAD = extern struct {
    hDestTexture: u32,
    hSrcTexture: u32,
};

pub const D3DPICKRECORD = extern struct {
    bOpcode: u8,
    bPad: u8,
    dwOffset: u32,
    dvZ: f32,
};

pub const D3DSHADEMODE = extern enum(i32) {
    D3DSHADE_FLAT = 1,
    D3DSHADE_GOURAUD = 2,
    D3DSHADE_PHONG = 3,
    D3DSHADE_FORCE_DWORD = 2147483647,
};
pub const D3DSHADE_FLAT = D3DSHADEMODE.D3DSHADE_FLAT;
pub const D3DSHADE_GOURAUD = D3DSHADEMODE.D3DSHADE_GOURAUD;
pub const D3DSHADE_PHONG = D3DSHADEMODE.D3DSHADE_PHONG;
pub const D3DSHADE_FORCE_DWORD = D3DSHADEMODE.D3DSHADE_FORCE_DWORD;

pub const D3DFILLMODE = extern enum(i32) {
    D3DFILL_POINT = 1,
    D3DFILL_WIREFRAME = 2,
    D3DFILL_SOLID = 3,
    D3DFILL_FORCE_DWORD = 2147483647,
};
pub const D3DFILL_POINT = D3DFILLMODE.D3DFILL_POINT;
pub const D3DFILL_WIREFRAME = D3DFILLMODE.D3DFILL_WIREFRAME;
pub const D3DFILL_SOLID = D3DFILLMODE.D3DFILL_SOLID;
pub const D3DFILL_FORCE_DWORD = D3DFILLMODE.D3DFILL_FORCE_DWORD;

pub const D3DLINEPATTERN = extern struct {
    wRepeatFactor: u16,
    wLinePattern: u16,
};

pub const D3DTEXTUREFILTER = extern enum(i32) {
    D3DFILTER_NEAREST = 1,
    D3DFILTER_LINEAR = 2,
    D3DFILTER_MIPNEAREST = 3,
    D3DFILTER_MIPLINEAR = 4,
    D3DFILTER_LINEARMIPNEAREST = 5,
    D3DFILTER_LINEARMIPLINEAR = 6,
    D3DFILTER_FORCE_DWORD = 2147483647,
};
pub const D3DFILTER_NEAREST = D3DTEXTUREFILTER.D3DFILTER_NEAREST;
pub const D3DFILTER_LINEAR = D3DTEXTUREFILTER.D3DFILTER_LINEAR;
pub const D3DFILTER_MIPNEAREST = D3DTEXTUREFILTER.D3DFILTER_MIPNEAREST;
pub const D3DFILTER_MIPLINEAR = D3DTEXTUREFILTER.D3DFILTER_MIPLINEAR;
pub const D3DFILTER_LINEARMIPNEAREST = D3DTEXTUREFILTER.D3DFILTER_LINEARMIPNEAREST;
pub const D3DFILTER_LINEARMIPLINEAR = D3DTEXTUREFILTER.D3DFILTER_LINEARMIPLINEAR;
pub const D3DFILTER_FORCE_DWORD = D3DTEXTUREFILTER.D3DFILTER_FORCE_DWORD;

pub const D3DBLEND = extern enum(u32) {
    ZERO = 1,
    ONE = 2,
    SRCCOLOR = 3,
    INVSRCCOLOR = 4,
    SRCALPHA = 5,
    INVSRCALPHA = 6,
    DESTALPHA = 7,
    INVDESTALPHA = 8,
    DESTCOLOR = 9,
    INVDESTCOLOR = 10,
    SRCALPHASAT = 11,
    BOTHSRCALPHA = 12,
    BOTHINVSRCALPHA = 13,
    FORCE_DWORD = 2147483647,
};
pub const D3DBLEND_ZERO = D3DBLEND.ZERO;
pub const D3DBLEND_ONE = D3DBLEND.ONE;
pub const D3DBLEND_SRCCOLOR = D3DBLEND.SRCCOLOR;
pub const D3DBLEND_INVSRCCOLOR = D3DBLEND.INVSRCCOLOR;
pub const D3DBLEND_SRCALPHA = D3DBLEND.SRCALPHA;
pub const D3DBLEND_INVSRCALPHA = D3DBLEND.INVSRCALPHA;
pub const D3DBLEND_DESTALPHA = D3DBLEND.DESTALPHA;
pub const D3DBLEND_INVDESTALPHA = D3DBLEND.INVDESTALPHA;
pub const D3DBLEND_DESTCOLOR = D3DBLEND.DESTCOLOR;
pub const D3DBLEND_INVDESTCOLOR = D3DBLEND.INVDESTCOLOR;
pub const D3DBLEND_SRCALPHASAT = D3DBLEND.SRCALPHASAT;
pub const D3DBLEND_BOTHSRCALPHA = D3DBLEND.BOTHSRCALPHA;
pub const D3DBLEND_BOTHINVSRCALPHA = D3DBLEND.BOTHINVSRCALPHA;
pub const D3DBLEND_FORCE_DWORD = D3DBLEND.FORCE_DWORD;

pub const D3DTEXTUREBLEND = extern enum(i32) {
    D3DTBLEND_DECAL = 1,
    D3DTBLEND_MODULATE = 2,
    D3DTBLEND_DECALALPHA = 3,
    D3DTBLEND_MODULATEALPHA = 4,
    D3DTBLEND_DECALMASK = 5,
    D3DTBLEND_MODULATEMASK = 6,
    D3DTBLEND_COPY = 7,
    D3DTBLEND_ADD = 8,
    D3DTBLEND_FORCE_DWORD = 2147483647,
};
pub const D3DTBLEND_DECAL = D3DTEXTUREBLEND.D3DTBLEND_DECAL;
pub const D3DTBLEND_MODULATE = D3DTEXTUREBLEND.D3DTBLEND_MODULATE;
pub const D3DTBLEND_DECALALPHA = D3DTEXTUREBLEND.D3DTBLEND_DECALALPHA;
pub const D3DTBLEND_MODULATEALPHA = D3DTEXTUREBLEND.D3DTBLEND_MODULATEALPHA;
pub const D3DTBLEND_DECALMASK = D3DTEXTUREBLEND.D3DTBLEND_DECALMASK;
pub const D3DTBLEND_MODULATEMASK = D3DTEXTUREBLEND.D3DTBLEND_MODULATEMASK;
pub const D3DTBLEND_COPY = D3DTEXTUREBLEND.D3DTBLEND_COPY;
pub const D3DTBLEND_ADD = D3DTEXTUREBLEND.D3DTBLEND_ADD;
pub const D3DTBLEND_FORCE_DWORD = D3DTEXTUREBLEND.D3DTBLEND_FORCE_DWORD;

pub const D3DTEXTUREADDRESS = extern enum(i32) {
    D3DTADDRESS_WRAP = 1,
    D3DTADDRESS_MIRROR = 2,
    D3DTADDRESS_CLAMP = 3,
    D3DTADDRESS_BORDER = 4,
    D3DTADDRESS_FORCE_DWORD = 2147483647,
};
pub const D3DTADDRESS_WRAP = D3DTEXTUREADDRESS.D3DTADDRESS_WRAP;
pub const D3DTADDRESS_MIRROR = D3DTEXTUREADDRESS.D3DTADDRESS_MIRROR;
pub const D3DTADDRESS_CLAMP = D3DTEXTUREADDRESS.D3DTADDRESS_CLAMP;
pub const D3DTADDRESS_BORDER = D3DTEXTUREADDRESS.D3DTADDRESS_BORDER;
pub const D3DTADDRESS_FORCE_DWORD = D3DTEXTUREADDRESS.D3DTADDRESS_FORCE_DWORD;

pub const D3DCULL = extern enum(u32) {
    NONE = 1,
    CW = 2,
    CCW = 3,
    FORCE_DWORD = 2147483647,
};
pub const D3DCULL_NONE = D3DCULL.NONE;
pub const D3DCULL_CW = D3DCULL.CW;
pub const D3DCULL_CCW = D3DCULL.CCW;
pub const D3DCULL_FORCE_DWORD = D3DCULL.FORCE_DWORD;

pub const D3DCMPFUNC = extern enum(i32) {
    D3DCMP_NEVER = 1,
    D3DCMP_LESS = 2,
    D3DCMP_EQUAL = 3,
    D3DCMP_LESSEQUAL = 4,
    D3DCMP_GREATER = 5,
    D3DCMP_NOTEQUAL = 6,
    D3DCMP_GREATEREQUAL = 7,
    D3DCMP_ALWAYS = 8,
    D3DCMP_FORCE_DWORD = 2147483647,
};
pub const D3DCMP_NEVER = D3DCMPFUNC.D3DCMP_NEVER;
pub const D3DCMP_LESS = D3DCMPFUNC.D3DCMP_LESS;
pub const D3DCMP_EQUAL = D3DCMPFUNC.D3DCMP_EQUAL;
pub const D3DCMP_LESSEQUAL = D3DCMPFUNC.D3DCMP_LESSEQUAL;
pub const D3DCMP_GREATER = D3DCMPFUNC.D3DCMP_GREATER;
pub const D3DCMP_NOTEQUAL = D3DCMPFUNC.D3DCMP_NOTEQUAL;
pub const D3DCMP_GREATEREQUAL = D3DCMPFUNC.D3DCMP_GREATEREQUAL;
pub const D3DCMP_ALWAYS = D3DCMPFUNC.D3DCMP_ALWAYS;
pub const D3DCMP_FORCE_DWORD = D3DCMPFUNC.D3DCMP_FORCE_DWORD;

pub const D3DSTENCILOP = extern enum(u32) {
    KEEP = 1,
    ZERO = 2,
    REPLACE = 3,
    INCRSAT = 4,
    DECRSAT = 5,
    INVERT = 6,
    INCR = 7,
    DECR = 8,
    FORCE_DWORD = 2147483647,
};
pub const D3DSTENCILOP_KEEP = D3DSTENCILOP.KEEP;
pub const D3DSTENCILOP_ZERO = D3DSTENCILOP.ZERO;
pub const D3DSTENCILOP_REPLACE = D3DSTENCILOP.REPLACE;
pub const D3DSTENCILOP_INCRSAT = D3DSTENCILOP.INCRSAT;
pub const D3DSTENCILOP_DECRSAT = D3DSTENCILOP.DECRSAT;
pub const D3DSTENCILOP_INVERT = D3DSTENCILOP.INVERT;
pub const D3DSTENCILOP_INCR = D3DSTENCILOP.INCR;
pub const D3DSTENCILOP_DECR = D3DSTENCILOP.DECR;
pub const D3DSTENCILOP_FORCE_DWORD = D3DSTENCILOP.FORCE_DWORD;

pub const D3DFOGMODE = extern enum(i32) {
    D3DFOG_NONE = 0,
    D3DFOG_EXP = 1,
    D3DFOG_EXP2 = 2,
    D3DFOG_LINEAR = 3,
    D3DFOG_FORCE_DWORD = 2147483647,
};
pub const D3DFOG_NONE = D3DFOGMODE.D3DFOG_NONE;
pub const D3DFOG_EXP = D3DFOGMODE.D3DFOG_EXP;
pub const D3DFOG_EXP2 = D3DFOGMODE.D3DFOG_EXP2;
pub const D3DFOG_LINEAR = D3DFOGMODE.D3DFOG_LINEAR;
pub const D3DFOG_FORCE_DWORD = D3DFOGMODE.D3DFOG_FORCE_DWORD;

pub const D3DZBUFFERTYPE = extern enum(i32) {
    D3DZB_FALSE = 0,
    D3DZB_TRUE = 1,
    D3DZB_USEW = 2,
    D3DZB_FORCE_DWORD = 2147483647,
};
pub const D3DZB_FALSE = D3DZBUFFERTYPE.D3DZB_FALSE;
pub const D3DZB_TRUE = D3DZBUFFERTYPE.D3DZB_TRUE;
pub const D3DZB_USEW = D3DZBUFFERTYPE.D3DZB_USEW;
pub const D3DZB_FORCE_DWORD = D3DZBUFFERTYPE.D3DZB_FORCE_DWORD;

pub const D3DANTIALIASMODE = extern enum(i32) {
    D3DANTIALIAS_NONE = 0,
    D3DANTIALIAS_SORTDEPENDENT = 1,
    D3DANTIALIAS_SORTINDEPENDENT = 2,
    D3DANTIALIAS_FORCE_DWORD = 2147483647,
};
pub const D3DANTIALIAS_NONE = D3DANTIALIASMODE.D3DANTIALIAS_NONE;
pub const D3DANTIALIAS_SORTDEPENDENT = D3DANTIALIASMODE.D3DANTIALIAS_SORTDEPENDENT;
pub const D3DANTIALIAS_SORTINDEPENDENT = D3DANTIALIASMODE.D3DANTIALIAS_SORTINDEPENDENT;
pub const D3DANTIALIAS_FORCE_DWORD = D3DANTIALIASMODE.D3DANTIALIAS_FORCE_DWORD;

pub const D3DVERTEXTYPE = extern enum(i32) {
    D3DVT_VERTEX = 1,
    D3DVT_LVERTEX = 2,
    D3DVT_TLVERTEX = 3,
    D3DVT_FORCE_DWORD = 2147483647,
};
pub const D3DVT_VERTEX = D3DVERTEXTYPE.D3DVT_VERTEX;
pub const D3DVT_LVERTEX = D3DVERTEXTYPE.D3DVT_LVERTEX;
pub const D3DVT_TLVERTEX = D3DVERTEXTYPE.D3DVT_TLVERTEX;
pub const D3DVT_FORCE_DWORD = D3DVERTEXTYPE.D3DVT_FORCE_DWORD;

pub const D3DPRIMITIVETYPE = extern enum(i32) {
    D3DPT_POINTLIST = 1,
    D3DPT_LINELIST = 2,
    D3DPT_LINESTRIP = 3,
    D3DPT_TRIANGLELIST = 4,
    D3DPT_TRIANGLESTRIP = 5,
    D3DPT_TRIANGLEFAN = 6,
    D3DPT_FORCE_DWORD = 2147483647,
};
pub const D3DPT_POINTLIST = D3DPRIMITIVETYPE.D3DPT_POINTLIST;
pub const D3DPT_LINELIST = D3DPRIMITIVETYPE.D3DPT_LINELIST;
pub const D3DPT_LINESTRIP = D3DPRIMITIVETYPE.D3DPT_LINESTRIP;
pub const D3DPT_TRIANGLELIST = D3DPRIMITIVETYPE.D3DPT_TRIANGLELIST;
pub const D3DPT_TRIANGLESTRIP = D3DPRIMITIVETYPE.D3DPT_TRIANGLESTRIP;
pub const D3DPT_TRIANGLEFAN = D3DPRIMITIVETYPE.D3DPT_TRIANGLEFAN;
pub const D3DPT_FORCE_DWORD = D3DPRIMITIVETYPE.D3DPT_FORCE_DWORD;

pub const D3DTRANSFORMSTATETYPE = extern enum(i32) {
    D3DTRANSFORMSTATE_WORLD = 1,
    D3DTRANSFORMSTATE_VIEW = 2,
    D3DTRANSFORMSTATE_PROJECTION = 3,
    D3DTRANSFORMSTATE_WORLD1 = 4,
    D3DTRANSFORMSTATE_WORLD2 = 5,
    D3DTRANSFORMSTATE_WORLD3 = 6,
    D3DTRANSFORMSTATE_TEXTURE0 = 16,
    D3DTRANSFORMSTATE_TEXTURE1 = 17,
    D3DTRANSFORMSTATE_TEXTURE2 = 18,
    D3DTRANSFORMSTATE_TEXTURE3 = 19,
    D3DTRANSFORMSTATE_TEXTURE4 = 20,
    D3DTRANSFORMSTATE_TEXTURE5 = 21,
    D3DTRANSFORMSTATE_TEXTURE6 = 22,
    D3DTRANSFORMSTATE_TEXTURE7 = 23,
    D3DTRANSFORMSTATE_FORCE_DWORD = 2147483647,
};
pub const D3DTRANSFORMSTATE_WORLD = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_WORLD;
pub const D3DTRANSFORMSTATE_VIEW = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_VIEW;
pub const D3DTRANSFORMSTATE_PROJECTION = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_PROJECTION;
pub const D3DTRANSFORMSTATE_WORLD1 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_WORLD1;
pub const D3DTRANSFORMSTATE_WORLD2 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_WORLD2;
pub const D3DTRANSFORMSTATE_WORLD3 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_WORLD3;
pub const D3DTRANSFORMSTATE_TEXTURE0 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_TEXTURE0;
pub const D3DTRANSFORMSTATE_TEXTURE1 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_TEXTURE1;
pub const D3DTRANSFORMSTATE_TEXTURE2 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_TEXTURE2;
pub const D3DTRANSFORMSTATE_TEXTURE3 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_TEXTURE3;
pub const D3DTRANSFORMSTATE_TEXTURE4 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_TEXTURE4;
pub const D3DTRANSFORMSTATE_TEXTURE5 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_TEXTURE5;
pub const D3DTRANSFORMSTATE_TEXTURE6 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_TEXTURE6;
pub const D3DTRANSFORMSTATE_TEXTURE7 = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_TEXTURE7;
pub const D3DTRANSFORMSTATE_FORCE_DWORD = D3DTRANSFORMSTATETYPE.D3DTRANSFORMSTATE_FORCE_DWORD;

pub const D3DLIGHTSTATETYPE = extern enum(i32) {
    D3DLIGHTSTATE_MATERIAL = 1,
    D3DLIGHTSTATE_AMBIENT = 2,
    D3DLIGHTSTATE_COLORMODEL = 3,
    D3DLIGHTSTATE_FOGMODE = 4,
    D3DLIGHTSTATE_FOGSTART = 5,
    D3DLIGHTSTATE_FOGEND = 6,
    D3DLIGHTSTATE_FOGDENSITY = 7,
    D3DLIGHTSTATE_COLORVERTEX = 8,
    D3DLIGHTSTATE_FORCE_DWORD = 2147483647,
};
pub const D3DLIGHTSTATE_MATERIAL = D3DLIGHTSTATETYPE.D3DLIGHTSTATE_MATERIAL;
pub const D3DLIGHTSTATE_AMBIENT = D3DLIGHTSTATETYPE.D3DLIGHTSTATE_AMBIENT;
pub const D3DLIGHTSTATE_COLORMODEL = D3DLIGHTSTATETYPE.D3DLIGHTSTATE_COLORMODEL;
pub const D3DLIGHTSTATE_FOGMODE = D3DLIGHTSTATETYPE.D3DLIGHTSTATE_FOGMODE;
pub const D3DLIGHTSTATE_FOGSTART = D3DLIGHTSTATETYPE.D3DLIGHTSTATE_FOGSTART;
pub const D3DLIGHTSTATE_FOGEND = D3DLIGHTSTATETYPE.D3DLIGHTSTATE_FOGEND;
pub const D3DLIGHTSTATE_FOGDENSITY = D3DLIGHTSTATETYPE.D3DLIGHTSTATE_FOGDENSITY;
pub const D3DLIGHTSTATE_COLORVERTEX = D3DLIGHTSTATETYPE.D3DLIGHTSTATE_COLORVERTEX;
pub const D3DLIGHTSTATE_FORCE_DWORD = D3DLIGHTSTATETYPE.D3DLIGHTSTATE_FORCE_DWORD;

pub const D3DRENDERSTATETYPE = extern enum(i32) {
    D3DRENDERSTATE_ANTIALIAS = 2,
    D3DRENDERSTATE_TEXTUREPERSPECTIVE = 4,
    D3DRENDERSTATE_ZENABLE = 7,
    D3DRENDERSTATE_FILLMODE = 8,
    D3DRENDERSTATE_SHADEMODE = 9,
    D3DRENDERSTATE_LINEPATTERN = 10,
    D3DRENDERSTATE_ZWRITEENABLE = 14,
    D3DRENDERSTATE_ALPHATESTENABLE = 15,
    D3DRENDERSTATE_LASTPIXEL = 16,
    D3DRENDERSTATE_SRCBLEND = 19,
    D3DRENDERSTATE_DESTBLEND = 20,
    D3DRENDERSTATE_CULLMODE = 22,
    D3DRENDERSTATE_ZFUNC = 23,
    D3DRENDERSTATE_ALPHAREF = 24,
    D3DRENDERSTATE_ALPHAFUNC = 25,
    D3DRENDERSTATE_DITHERENABLE = 26,
    D3DRENDERSTATE_ALPHABLENDENABLE = 27,
    D3DRENDERSTATE_FOGENABLE = 28,
    D3DRENDERSTATE_SPECULARENABLE = 29,
    D3DRENDERSTATE_ZVISIBLE = 30,
    D3DRENDERSTATE_STIPPLEDALPHA = 33,
    D3DRENDERSTATE_FOGCOLOR = 34,
    D3DRENDERSTATE_FOGTABLEMODE = 35,
    D3DRENDERSTATE_FOGSTART = 36,
    D3DRENDERSTATE_FOGEND = 37,
    D3DRENDERSTATE_FOGDENSITY = 38,
    D3DRENDERSTATE_EDGEANTIALIAS = 40,
    D3DRENDERSTATE_COLORKEYENABLE = 41,
    D3DRENDERSTATE_ZBIAS = 47,
    D3DRENDERSTATE_RANGEFOGENABLE = 48,
    D3DRENDERSTATE_STENCILENABLE = 52,
    D3DRENDERSTATE_STENCILFAIL = 53,
    D3DRENDERSTATE_STENCILZFAIL = 54,
    D3DRENDERSTATE_STENCILPASS = 55,
    D3DRENDERSTATE_STENCILFUNC = 56,
    D3DRENDERSTATE_STENCILREF = 57,
    D3DRENDERSTATE_STENCILMASK = 58,
    D3DRENDERSTATE_STENCILWRITEMASK = 59,
    D3DRENDERSTATE_TEXTUREFACTOR = 60,
    D3DRENDERSTATE_WRAP0 = 128,
    D3DRENDERSTATE_WRAP1 = 129,
    D3DRENDERSTATE_WRAP2 = 130,
    D3DRENDERSTATE_WRAP3 = 131,
    D3DRENDERSTATE_WRAP4 = 132,
    D3DRENDERSTATE_WRAP5 = 133,
    D3DRENDERSTATE_WRAP6 = 134,
    D3DRENDERSTATE_WRAP7 = 135,
    D3DRENDERSTATE_CLIPPING = 136,
    D3DRENDERSTATE_LIGHTING = 137,
    D3DRENDERSTATE_EXTENTS = 138,
    D3DRENDERSTATE_AMBIENT = 139,
    D3DRENDERSTATE_FOGVERTEXMODE = 140,
    D3DRENDERSTATE_COLORVERTEX = 141,
    D3DRENDERSTATE_LOCALVIEWER = 142,
    D3DRENDERSTATE_NORMALIZENORMALS = 143,
    D3DRENDERSTATE_COLORKEYBLENDENABLE = 144,
    D3DRENDERSTATE_DIFFUSEMATERIALSOURCE = 145,
    D3DRENDERSTATE_SPECULARMATERIALSOURCE = 146,
    D3DRENDERSTATE_AMBIENTMATERIALSOURCE = 147,
    D3DRENDERSTATE_EMISSIVEMATERIALSOURCE = 148,
    D3DRENDERSTATE_VERTEXBLEND = 151,
    D3DRENDERSTATE_CLIPPLANEENABLE = 152,
    D3DRENDERSTATE_TEXTUREHANDLE = 1,
    D3DRENDERSTATE_TEXTUREADDRESS = 3,
    D3DRENDERSTATE_WRAPU = 5,
    D3DRENDERSTATE_WRAPV = 6,
    D3DRENDERSTATE_MONOENABLE = 11,
    D3DRENDERSTATE_ROP2 = 12,
    D3DRENDERSTATE_PLANEMASK = 13,
    D3DRENDERSTATE_TEXTUREMAG = 17,
    D3DRENDERSTATE_TEXTUREMIN = 18,
    D3DRENDERSTATE_TEXTUREMAPBLEND = 21,
    D3DRENDERSTATE_SUBPIXEL = 31,
    D3DRENDERSTATE_SUBPIXELX = 32,
    D3DRENDERSTATE_STIPPLEENABLE = 39,
    D3DRENDERSTATE_BORDERCOLOR = 43,
    D3DRENDERSTATE_TEXTUREADDRESSU = 44,
    D3DRENDERSTATE_TEXTUREADDRESSV = 45,
    D3DRENDERSTATE_MIPMAPLODBIAS = 46,
    D3DRENDERSTATE_ANISOTROPY = 49,
    D3DRENDERSTATE_FLUSHBATCH = 50,
    D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT = 51,
    D3DRENDERSTATE_STIPPLEPATTERN00 = 64,
    D3DRENDERSTATE_STIPPLEPATTERN01 = 65,
    D3DRENDERSTATE_STIPPLEPATTERN02 = 66,
    D3DRENDERSTATE_STIPPLEPATTERN03 = 67,
    D3DRENDERSTATE_STIPPLEPATTERN04 = 68,
    D3DRENDERSTATE_STIPPLEPATTERN05 = 69,
    D3DRENDERSTATE_STIPPLEPATTERN06 = 70,
    D3DRENDERSTATE_STIPPLEPATTERN07 = 71,
    D3DRENDERSTATE_STIPPLEPATTERN08 = 72,
    D3DRENDERSTATE_STIPPLEPATTERN09 = 73,
    D3DRENDERSTATE_STIPPLEPATTERN10 = 74,
    D3DRENDERSTATE_STIPPLEPATTERN11 = 75,
    D3DRENDERSTATE_STIPPLEPATTERN12 = 76,
    D3DRENDERSTATE_STIPPLEPATTERN13 = 77,
    D3DRENDERSTATE_STIPPLEPATTERN14 = 78,
    D3DRENDERSTATE_STIPPLEPATTERN15 = 79,
    D3DRENDERSTATE_STIPPLEPATTERN16 = 80,
    D3DRENDERSTATE_STIPPLEPATTERN17 = 81,
    D3DRENDERSTATE_STIPPLEPATTERN18 = 82,
    D3DRENDERSTATE_STIPPLEPATTERN19 = 83,
    D3DRENDERSTATE_STIPPLEPATTERN20 = 84,
    D3DRENDERSTATE_STIPPLEPATTERN21 = 85,
    D3DRENDERSTATE_STIPPLEPATTERN22 = 86,
    D3DRENDERSTATE_STIPPLEPATTERN23 = 87,
    D3DRENDERSTATE_STIPPLEPATTERN24 = 88,
    D3DRENDERSTATE_STIPPLEPATTERN25 = 89,
    D3DRENDERSTATE_STIPPLEPATTERN26 = 90,
    D3DRENDERSTATE_STIPPLEPATTERN27 = 91,
    D3DRENDERSTATE_STIPPLEPATTERN28 = 92,
    D3DRENDERSTATE_STIPPLEPATTERN29 = 93,
    D3DRENDERSTATE_STIPPLEPATTERN30 = 94,
    D3DRENDERSTATE_STIPPLEPATTERN31 = 95,
    D3DRENDERSTATE_FOGTABLESTART = 36,
    D3DRENDERSTATE_FOGTABLEEND = 37,
    D3DRENDERSTATE_FOGTABLEDENSITY = 38,
    D3DRENDERSTATE_FORCE_DWORD = 2147483647,
};
pub const D3DRENDERSTATE_ANTIALIAS = D3DRENDERSTATETYPE.D3DRENDERSTATE_ANTIALIAS;
pub const D3DRENDERSTATE_TEXTUREPERSPECTIVE = D3DRENDERSTATETYPE.D3DRENDERSTATE_TEXTUREPERSPECTIVE;
pub const D3DRENDERSTATE_ZENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_ZENABLE;
pub const D3DRENDERSTATE_FILLMODE = D3DRENDERSTATETYPE.D3DRENDERSTATE_FILLMODE;
pub const D3DRENDERSTATE_SHADEMODE = D3DRENDERSTATETYPE.D3DRENDERSTATE_SHADEMODE;
pub const D3DRENDERSTATE_LINEPATTERN = D3DRENDERSTATETYPE.D3DRENDERSTATE_LINEPATTERN;
pub const D3DRENDERSTATE_ZWRITEENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_ZWRITEENABLE;
pub const D3DRENDERSTATE_ALPHATESTENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_ALPHATESTENABLE;
pub const D3DRENDERSTATE_LASTPIXEL = D3DRENDERSTATETYPE.D3DRENDERSTATE_LASTPIXEL;
pub const D3DRENDERSTATE_SRCBLEND = D3DRENDERSTATETYPE.D3DRENDERSTATE_SRCBLEND;
pub const D3DRENDERSTATE_DESTBLEND = D3DRENDERSTATETYPE.D3DRENDERSTATE_DESTBLEND;
pub const D3DRENDERSTATE_CULLMODE = D3DRENDERSTATETYPE.D3DRENDERSTATE_CULLMODE;
pub const D3DRENDERSTATE_ZFUNC = D3DRENDERSTATETYPE.D3DRENDERSTATE_ZFUNC;
pub const D3DRENDERSTATE_ALPHAREF = D3DRENDERSTATETYPE.D3DRENDERSTATE_ALPHAREF;
pub const D3DRENDERSTATE_ALPHAFUNC = D3DRENDERSTATETYPE.D3DRENDERSTATE_ALPHAFUNC;
pub const D3DRENDERSTATE_DITHERENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_DITHERENABLE;
pub const D3DRENDERSTATE_ALPHABLENDENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_ALPHABLENDENABLE;
pub const D3DRENDERSTATE_FOGENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGENABLE;
pub const D3DRENDERSTATE_SPECULARENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_SPECULARENABLE;
pub const D3DRENDERSTATE_ZVISIBLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_ZVISIBLE;
pub const D3DRENDERSTATE_STIPPLEDALPHA = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEDALPHA;
pub const D3DRENDERSTATE_FOGCOLOR = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGCOLOR;
pub const D3DRENDERSTATE_FOGTABLEMODE = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGTABLEMODE;
pub const D3DRENDERSTATE_FOGSTART = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGSTART;
pub const D3DRENDERSTATE_FOGEND = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGEND;
pub const D3DRENDERSTATE_FOGDENSITY = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGDENSITY;
pub const D3DRENDERSTATE_EDGEANTIALIAS = D3DRENDERSTATETYPE.D3DRENDERSTATE_EDGEANTIALIAS;
pub const D3DRENDERSTATE_COLORKEYENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_COLORKEYENABLE;
pub const D3DRENDERSTATE_ZBIAS = D3DRENDERSTATETYPE.D3DRENDERSTATE_ZBIAS;
pub const D3DRENDERSTATE_RANGEFOGENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_RANGEFOGENABLE;
pub const D3DRENDERSTATE_STENCILENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_STENCILENABLE;
pub const D3DRENDERSTATE_STENCILFAIL = D3DRENDERSTATETYPE.D3DRENDERSTATE_STENCILFAIL;
pub const D3DRENDERSTATE_STENCILZFAIL = D3DRENDERSTATETYPE.D3DRENDERSTATE_STENCILZFAIL;
pub const D3DRENDERSTATE_STENCILPASS = D3DRENDERSTATETYPE.D3DRENDERSTATE_STENCILPASS;
pub const D3DRENDERSTATE_STENCILFUNC = D3DRENDERSTATETYPE.D3DRENDERSTATE_STENCILFUNC;
pub const D3DRENDERSTATE_STENCILREF = D3DRENDERSTATETYPE.D3DRENDERSTATE_STENCILREF;
pub const D3DRENDERSTATE_STENCILMASK = D3DRENDERSTATETYPE.D3DRENDERSTATE_STENCILMASK;
pub const D3DRENDERSTATE_STENCILWRITEMASK = D3DRENDERSTATETYPE.D3DRENDERSTATE_STENCILWRITEMASK;
pub const D3DRENDERSTATE_TEXTUREFACTOR = D3DRENDERSTATETYPE.D3DRENDERSTATE_TEXTUREFACTOR;
pub const D3DRENDERSTATE_WRAP0 = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAP0;
pub const D3DRENDERSTATE_WRAP1 = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAP1;
pub const D3DRENDERSTATE_WRAP2 = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAP2;
pub const D3DRENDERSTATE_WRAP3 = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAP3;
pub const D3DRENDERSTATE_WRAP4 = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAP4;
pub const D3DRENDERSTATE_WRAP5 = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAP5;
pub const D3DRENDERSTATE_WRAP6 = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAP6;
pub const D3DRENDERSTATE_WRAP7 = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAP7;
pub const D3DRENDERSTATE_CLIPPING = D3DRENDERSTATETYPE.D3DRENDERSTATE_CLIPPING;
pub const D3DRENDERSTATE_LIGHTING = D3DRENDERSTATETYPE.D3DRENDERSTATE_LIGHTING;
pub const D3DRENDERSTATE_EXTENTS = D3DRENDERSTATETYPE.D3DRENDERSTATE_EXTENTS;
pub const D3DRENDERSTATE_AMBIENT = D3DRENDERSTATETYPE.D3DRENDERSTATE_AMBIENT;
pub const D3DRENDERSTATE_FOGVERTEXMODE = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGVERTEXMODE;
pub const D3DRENDERSTATE_COLORVERTEX = D3DRENDERSTATETYPE.D3DRENDERSTATE_COLORVERTEX;
pub const D3DRENDERSTATE_LOCALVIEWER = D3DRENDERSTATETYPE.D3DRENDERSTATE_LOCALVIEWER;
pub const D3DRENDERSTATE_NORMALIZENORMALS = D3DRENDERSTATETYPE.D3DRENDERSTATE_NORMALIZENORMALS;
pub const D3DRENDERSTATE_COLORKEYBLENDENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_COLORKEYBLENDENABLE;
pub const D3DRENDERSTATE_DIFFUSEMATERIALSOURCE = D3DRENDERSTATETYPE.D3DRENDERSTATE_DIFFUSEMATERIALSOURCE;
pub const D3DRENDERSTATE_SPECULARMATERIALSOURCE = D3DRENDERSTATETYPE.D3DRENDERSTATE_SPECULARMATERIALSOURCE;
pub const D3DRENDERSTATE_AMBIENTMATERIALSOURCE = D3DRENDERSTATETYPE.D3DRENDERSTATE_AMBIENTMATERIALSOURCE;
pub const D3DRENDERSTATE_EMISSIVEMATERIALSOURCE = D3DRENDERSTATETYPE.D3DRENDERSTATE_EMISSIVEMATERIALSOURCE;
pub const D3DRENDERSTATE_VERTEXBLEND = D3DRENDERSTATETYPE.D3DRENDERSTATE_VERTEXBLEND;
pub const D3DRENDERSTATE_CLIPPLANEENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_CLIPPLANEENABLE;
pub const D3DRENDERSTATE_TEXTUREHANDLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_TEXTUREHANDLE;
pub const D3DRENDERSTATE_TEXTUREADDRESS = D3DRENDERSTATETYPE.D3DRENDERSTATE_TEXTUREADDRESS;
pub const D3DRENDERSTATE_WRAPU = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAPU;
pub const D3DRENDERSTATE_WRAPV = D3DRENDERSTATETYPE.D3DRENDERSTATE_WRAPV;
pub const D3DRENDERSTATE_MONOENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_MONOENABLE;
pub const D3DRENDERSTATE_ROP2 = D3DRENDERSTATETYPE.D3DRENDERSTATE_ROP2;
pub const D3DRENDERSTATE_PLANEMASK = D3DRENDERSTATETYPE.D3DRENDERSTATE_PLANEMASK;
pub const D3DRENDERSTATE_TEXTUREMAG = D3DRENDERSTATETYPE.D3DRENDERSTATE_TEXTUREMAG;
pub const D3DRENDERSTATE_TEXTUREMIN = D3DRENDERSTATETYPE.D3DRENDERSTATE_TEXTUREMIN;
pub const D3DRENDERSTATE_TEXTUREMAPBLEND = D3DRENDERSTATETYPE.D3DRENDERSTATE_TEXTUREMAPBLEND;
pub const D3DRENDERSTATE_SUBPIXEL = D3DRENDERSTATETYPE.D3DRENDERSTATE_SUBPIXEL;
pub const D3DRENDERSTATE_SUBPIXELX = D3DRENDERSTATETYPE.D3DRENDERSTATE_SUBPIXELX;
pub const D3DRENDERSTATE_STIPPLEENABLE = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEENABLE;
pub const D3DRENDERSTATE_BORDERCOLOR = D3DRENDERSTATETYPE.D3DRENDERSTATE_BORDERCOLOR;
pub const D3DRENDERSTATE_TEXTUREADDRESSU = D3DRENDERSTATETYPE.D3DRENDERSTATE_TEXTUREADDRESSU;
pub const D3DRENDERSTATE_TEXTUREADDRESSV = D3DRENDERSTATETYPE.D3DRENDERSTATE_TEXTUREADDRESSV;
pub const D3DRENDERSTATE_MIPMAPLODBIAS = D3DRENDERSTATETYPE.D3DRENDERSTATE_MIPMAPLODBIAS;
pub const D3DRENDERSTATE_ANISOTROPY = D3DRENDERSTATETYPE.D3DRENDERSTATE_ANISOTROPY;
pub const D3DRENDERSTATE_FLUSHBATCH = D3DRENDERSTATETYPE.D3DRENDERSTATE_FLUSHBATCH;
pub const D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT = D3DRENDERSTATETYPE.D3DRENDERSTATE_TRANSLUCENTSORTINDEPENDENT;
pub const D3DRENDERSTATE_STIPPLEPATTERN00 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN00;
pub const D3DRENDERSTATE_STIPPLEPATTERN01 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN01;
pub const D3DRENDERSTATE_STIPPLEPATTERN02 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN02;
pub const D3DRENDERSTATE_STIPPLEPATTERN03 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN03;
pub const D3DRENDERSTATE_STIPPLEPATTERN04 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN04;
pub const D3DRENDERSTATE_STIPPLEPATTERN05 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN05;
pub const D3DRENDERSTATE_STIPPLEPATTERN06 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN06;
pub const D3DRENDERSTATE_STIPPLEPATTERN07 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN07;
pub const D3DRENDERSTATE_STIPPLEPATTERN08 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN08;
pub const D3DRENDERSTATE_STIPPLEPATTERN09 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN09;
pub const D3DRENDERSTATE_STIPPLEPATTERN10 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN10;
pub const D3DRENDERSTATE_STIPPLEPATTERN11 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN11;
pub const D3DRENDERSTATE_STIPPLEPATTERN12 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN12;
pub const D3DRENDERSTATE_STIPPLEPATTERN13 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN13;
pub const D3DRENDERSTATE_STIPPLEPATTERN14 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN14;
pub const D3DRENDERSTATE_STIPPLEPATTERN15 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN15;
pub const D3DRENDERSTATE_STIPPLEPATTERN16 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN16;
pub const D3DRENDERSTATE_STIPPLEPATTERN17 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN17;
pub const D3DRENDERSTATE_STIPPLEPATTERN18 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN18;
pub const D3DRENDERSTATE_STIPPLEPATTERN19 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN19;
pub const D3DRENDERSTATE_STIPPLEPATTERN20 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN20;
pub const D3DRENDERSTATE_STIPPLEPATTERN21 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN21;
pub const D3DRENDERSTATE_STIPPLEPATTERN22 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN22;
pub const D3DRENDERSTATE_STIPPLEPATTERN23 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN23;
pub const D3DRENDERSTATE_STIPPLEPATTERN24 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN24;
pub const D3DRENDERSTATE_STIPPLEPATTERN25 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN25;
pub const D3DRENDERSTATE_STIPPLEPATTERN26 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN26;
pub const D3DRENDERSTATE_STIPPLEPATTERN27 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN27;
pub const D3DRENDERSTATE_STIPPLEPATTERN28 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN28;
pub const D3DRENDERSTATE_STIPPLEPATTERN29 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN29;
pub const D3DRENDERSTATE_STIPPLEPATTERN30 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN30;
pub const D3DRENDERSTATE_STIPPLEPATTERN31 = D3DRENDERSTATETYPE.D3DRENDERSTATE_STIPPLEPATTERN31;
pub const D3DRENDERSTATE_FOGTABLESTART = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGTABLESTART;
pub const D3DRENDERSTATE_FOGTABLEEND = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGTABLEEND;
pub const D3DRENDERSTATE_FOGTABLEDENSITY = D3DRENDERSTATETYPE.D3DRENDERSTATE_FOGTABLEDENSITY;
pub const D3DRENDERSTATE_FORCE_DWORD = D3DRENDERSTATETYPE.D3DRENDERSTATE_FORCE_DWORD;

pub const D3DMATERIALCOLORSOURCE = extern enum(i32) {
    D3DMCS_MATERIAL = 0,
    D3DMCS_COLOR1 = 1,
    D3DMCS_COLOR2 = 2,
    D3DMCS_FORCE_DWORD = 2147483647,
};
pub const D3DMCS_MATERIAL = D3DMATERIALCOLORSOURCE.D3DMCS_MATERIAL;
pub const D3DMCS_COLOR1 = D3DMATERIALCOLORSOURCE.D3DMCS_COLOR1;
pub const D3DMCS_COLOR2 = D3DMATERIALCOLORSOURCE.D3DMCS_COLOR2;
pub const D3DMCS_FORCE_DWORD = D3DMATERIALCOLORSOURCE.D3DMCS_FORCE_DWORD;

pub const D3DSTATE = extern struct {
    Anonymous1: D3DSTATE._Anonymous1_e__Union,
    Anonymous2: D3DSTATE._Anonymous2_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DMATRIXLOAD = extern struct {
    hDestMatrix: u32,
    hSrcMatrix: u32,
};

pub const D3DMATRIXMULTIPLY = extern struct {
    hDestMatrix: u32,
    hSrcMatrix1: u32,
    hSrcMatrix2: u32,
};

pub const D3DPROCESSVERTICES = extern struct {
    dwFlags: u32,
    wStart: u16,
    wDest: u16,
    dwCount: u32,
    dwReserved: u32,
};

pub const D3DTEXTURESTAGESTATETYPE = extern enum(i32) {
    D3DTSS_COLOROP = 1,
    D3DTSS_COLORARG1 = 2,
    D3DTSS_COLORARG2 = 3,
    D3DTSS_ALPHAOP = 4,
    D3DTSS_ALPHAARG1 = 5,
    D3DTSS_ALPHAARG2 = 6,
    D3DTSS_BUMPENVMAT00 = 7,
    D3DTSS_BUMPENVMAT01 = 8,
    D3DTSS_BUMPENVMAT10 = 9,
    D3DTSS_BUMPENVMAT11 = 10,
    D3DTSS_TEXCOORDINDEX = 11,
    D3DTSS_ADDRESS = 12,
    D3DTSS_ADDRESSU = 13,
    D3DTSS_ADDRESSV = 14,
    D3DTSS_BORDERCOLOR = 15,
    D3DTSS_MAGFILTER = 16,
    D3DTSS_MINFILTER = 17,
    D3DTSS_MIPFILTER = 18,
    D3DTSS_MIPMAPLODBIAS = 19,
    D3DTSS_MAXMIPLEVEL = 20,
    D3DTSS_MAXANISOTROPY = 21,
    D3DTSS_BUMPENVLSCALE = 22,
    D3DTSS_BUMPENVLOFFSET = 23,
    D3DTSS_TEXTURETRANSFORMFLAGS = 24,
    D3DTSS_FORCE_DWORD = 2147483647,
};
pub const D3DTSS_COLOROP = D3DTEXTURESTAGESTATETYPE.D3DTSS_COLOROP;
pub const D3DTSS_COLORARG1 = D3DTEXTURESTAGESTATETYPE.D3DTSS_COLORARG1;
pub const D3DTSS_COLORARG2 = D3DTEXTURESTAGESTATETYPE.D3DTSS_COLORARG2;
pub const D3DTSS_ALPHAOP = D3DTEXTURESTAGESTATETYPE.D3DTSS_ALPHAOP;
pub const D3DTSS_ALPHAARG1 = D3DTEXTURESTAGESTATETYPE.D3DTSS_ALPHAARG1;
pub const D3DTSS_ALPHAARG2 = D3DTEXTURESTAGESTATETYPE.D3DTSS_ALPHAARG2;
pub const D3DTSS_BUMPENVMAT00 = D3DTEXTURESTAGESTATETYPE.D3DTSS_BUMPENVMAT00;
pub const D3DTSS_BUMPENVMAT01 = D3DTEXTURESTAGESTATETYPE.D3DTSS_BUMPENVMAT01;
pub const D3DTSS_BUMPENVMAT10 = D3DTEXTURESTAGESTATETYPE.D3DTSS_BUMPENVMAT10;
pub const D3DTSS_BUMPENVMAT11 = D3DTEXTURESTAGESTATETYPE.D3DTSS_BUMPENVMAT11;
pub const D3DTSS_TEXCOORDINDEX = D3DTEXTURESTAGESTATETYPE.D3DTSS_TEXCOORDINDEX;
pub const D3DTSS_ADDRESS = D3DTEXTURESTAGESTATETYPE.D3DTSS_ADDRESS;
pub const D3DTSS_ADDRESSU = D3DTEXTURESTAGESTATETYPE.D3DTSS_ADDRESSU;
pub const D3DTSS_ADDRESSV = D3DTEXTURESTAGESTATETYPE.D3DTSS_ADDRESSV;
pub const D3DTSS_BORDERCOLOR = D3DTEXTURESTAGESTATETYPE.D3DTSS_BORDERCOLOR;
pub const D3DTSS_MAGFILTER = D3DTEXTURESTAGESTATETYPE.D3DTSS_MAGFILTER;
pub const D3DTSS_MINFILTER = D3DTEXTURESTAGESTATETYPE.D3DTSS_MINFILTER;
pub const D3DTSS_MIPFILTER = D3DTEXTURESTAGESTATETYPE.D3DTSS_MIPFILTER;
pub const D3DTSS_MIPMAPLODBIAS = D3DTEXTURESTAGESTATETYPE.D3DTSS_MIPMAPLODBIAS;
pub const D3DTSS_MAXMIPLEVEL = D3DTEXTURESTAGESTATETYPE.D3DTSS_MAXMIPLEVEL;
pub const D3DTSS_MAXANISOTROPY = D3DTEXTURESTAGESTATETYPE.D3DTSS_MAXANISOTROPY;
pub const D3DTSS_BUMPENVLSCALE = D3DTEXTURESTAGESTATETYPE.D3DTSS_BUMPENVLSCALE;
pub const D3DTSS_BUMPENVLOFFSET = D3DTEXTURESTAGESTATETYPE.D3DTSS_BUMPENVLOFFSET;
pub const D3DTSS_TEXTURETRANSFORMFLAGS = D3DTEXTURESTAGESTATETYPE.D3DTSS_TEXTURETRANSFORMFLAGS;
pub const D3DTSS_FORCE_DWORD = D3DTEXTURESTAGESTATETYPE.D3DTSS_FORCE_DWORD;

pub const D3DTEXTUREOP = extern enum(i32) {
    D3DTOP_DISABLE = 1,
    D3DTOP_SELECTARG1 = 2,
    D3DTOP_SELECTARG2 = 3,
    D3DTOP_MODULATE = 4,
    D3DTOP_MODULATE2X = 5,
    D3DTOP_MODULATE4X = 6,
    D3DTOP_ADD = 7,
    D3DTOP_ADDSIGNED = 8,
    D3DTOP_ADDSIGNED2X = 9,
    D3DTOP_SUBTRACT = 10,
    D3DTOP_ADDSMOOTH = 11,
    D3DTOP_BLENDDIFFUSEALPHA = 12,
    D3DTOP_BLENDTEXTUREALPHA = 13,
    D3DTOP_BLENDFACTORALPHA = 14,
    D3DTOP_BLENDTEXTUREALPHAPM = 15,
    D3DTOP_BLENDCURRENTALPHA = 16,
    D3DTOP_PREMODULATE = 17,
    D3DTOP_MODULATEALPHA_ADDCOLOR = 18,
    D3DTOP_MODULATECOLOR_ADDALPHA = 19,
    D3DTOP_MODULATEINVALPHA_ADDCOLOR = 20,
    D3DTOP_MODULATEINVCOLOR_ADDALPHA = 21,
    D3DTOP_BUMPENVMAP = 22,
    D3DTOP_BUMPENVMAPLUMINANCE = 23,
    D3DTOP_DOTPRODUCT3 = 24,
    D3DTOP_FORCE_DWORD = 2147483647,
};
pub const D3DTOP_DISABLE = D3DTEXTUREOP.D3DTOP_DISABLE;
pub const D3DTOP_SELECTARG1 = D3DTEXTUREOP.D3DTOP_SELECTARG1;
pub const D3DTOP_SELECTARG2 = D3DTEXTUREOP.D3DTOP_SELECTARG2;
pub const D3DTOP_MODULATE = D3DTEXTUREOP.D3DTOP_MODULATE;
pub const D3DTOP_MODULATE2X = D3DTEXTUREOP.D3DTOP_MODULATE2X;
pub const D3DTOP_MODULATE4X = D3DTEXTUREOP.D3DTOP_MODULATE4X;
pub const D3DTOP_ADD = D3DTEXTUREOP.D3DTOP_ADD;
pub const D3DTOP_ADDSIGNED = D3DTEXTUREOP.D3DTOP_ADDSIGNED;
pub const D3DTOP_ADDSIGNED2X = D3DTEXTUREOP.D3DTOP_ADDSIGNED2X;
pub const D3DTOP_SUBTRACT = D3DTEXTUREOP.D3DTOP_SUBTRACT;
pub const D3DTOP_ADDSMOOTH = D3DTEXTUREOP.D3DTOP_ADDSMOOTH;
pub const D3DTOP_BLENDDIFFUSEALPHA = D3DTEXTUREOP.D3DTOP_BLENDDIFFUSEALPHA;
pub const D3DTOP_BLENDTEXTUREALPHA = D3DTEXTUREOP.D3DTOP_BLENDTEXTUREALPHA;
pub const D3DTOP_BLENDFACTORALPHA = D3DTEXTUREOP.D3DTOP_BLENDFACTORALPHA;
pub const D3DTOP_BLENDTEXTUREALPHAPM = D3DTEXTUREOP.D3DTOP_BLENDTEXTUREALPHAPM;
pub const D3DTOP_BLENDCURRENTALPHA = D3DTEXTUREOP.D3DTOP_BLENDCURRENTALPHA;
pub const D3DTOP_PREMODULATE = D3DTEXTUREOP.D3DTOP_PREMODULATE;
pub const D3DTOP_MODULATEALPHA_ADDCOLOR = D3DTEXTUREOP.D3DTOP_MODULATEALPHA_ADDCOLOR;
pub const D3DTOP_MODULATECOLOR_ADDALPHA = D3DTEXTUREOP.D3DTOP_MODULATECOLOR_ADDALPHA;
pub const D3DTOP_MODULATEINVALPHA_ADDCOLOR = D3DTEXTUREOP.D3DTOP_MODULATEINVALPHA_ADDCOLOR;
pub const D3DTOP_MODULATEINVCOLOR_ADDALPHA = D3DTEXTUREOP.D3DTOP_MODULATEINVCOLOR_ADDALPHA;
pub const D3DTOP_BUMPENVMAP = D3DTEXTUREOP.D3DTOP_BUMPENVMAP;
pub const D3DTOP_BUMPENVMAPLUMINANCE = D3DTEXTUREOP.D3DTOP_BUMPENVMAPLUMINANCE;
pub const D3DTOP_DOTPRODUCT3 = D3DTEXTUREOP.D3DTOP_DOTPRODUCT3;
pub const D3DTOP_FORCE_DWORD = D3DTEXTUREOP.D3DTOP_FORCE_DWORD;

pub const D3DTEXTUREMAGFILTER = extern enum(i32) {
    D3DTFG_POINT = 1,
    D3DTFG_LINEAR = 2,
    D3DTFG_FLATCUBIC = 3,
    D3DTFG_GAUSSIANCUBIC = 4,
    D3DTFG_ANISOTROPIC = 5,
    D3DTFG_FORCE_DWORD = 2147483647,
};
pub const D3DTFG_POINT = D3DTEXTUREMAGFILTER.D3DTFG_POINT;
pub const D3DTFG_LINEAR = D3DTEXTUREMAGFILTER.D3DTFG_LINEAR;
pub const D3DTFG_FLATCUBIC = D3DTEXTUREMAGFILTER.D3DTFG_FLATCUBIC;
pub const D3DTFG_GAUSSIANCUBIC = D3DTEXTUREMAGFILTER.D3DTFG_GAUSSIANCUBIC;
pub const D3DTFG_ANISOTROPIC = D3DTEXTUREMAGFILTER.D3DTFG_ANISOTROPIC;
pub const D3DTFG_FORCE_DWORD = D3DTEXTUREMAGFILTER.D3DTFG_FORCE_DWORD;

pub const D3DTEXTUREMINFILTER = extern enum(i32) {
    D3DTFN_POINT = 1,
    D3DTFN_LINEAR = 2,
    D3DTFN_ANISOTROPIC = 3,
    D3DTFN_FORCE_DWORD = 2147483647,
};
pub const D3DTFN_POINT = D3DTEXTUREMINFILTER.D3DTFN_POINT;
pub const D3DTFN_LINEAR = D3DTEXTUREMINFILTER.D3DTFN_LINEAR;
pub const D3DTFN_ANISOTROPIC = D3DTEXTUREMINFILTER.D3DTFN_ANISOTROPIC;
pub const D3DTFN_FORCE_DWORD = D3DTEXTUREMINFILTER.D3DTFN_FORCE_DWORD;

pub const D3DTEXTUREMIPFILTER = extern enum(i32) {
    D3DTFP_NONE = 1,
    D3DTFP_POINT = 2,
    D3DTFP_LINEAR = 3,
    D3DTFP_FORCE_DWORD = 2147483647,
};
pub const D3DTFP_NONE = D3DTEXTUREMIPFILTER.D3DTFP_NONE;
pub const D3DTFP_POINT = D3DTEXTUREMIPFILTER.D3DTFP_POINT;
pub const D3DTFP_LINEAR = D3DTEXTUREMIPFILTER.D3DTFP_LINEAR;
pub const D3DTFP_FORCE_DWORD = D3DTEXTUREMIPFILTER.D3DTFP_FORCE_DWORD;

pub const D3DTRIANGLE = extern struct {
    Anonymous1: D3DTRIANGLE._Anonymous1_e__Union,
    Anonymous2: D3DTRIANGLE._Anonymous2_e__Union,
    Anonymous3: D3DTRIANGLE._Anonymous3_e__Union,
    wFlags: u16,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DLINE = extern struct {
    Anonymous1: D3DLINE._Anonymous1_e__Union,
    Anonymous2: D3DLINE._Anonymous2_e__Union,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DSPAN = extern struct {
    wCount: u16,
    wFirst: u16,
};

pub const D3DPOINT = extern struct {
    wCount: u16,
    wFirst: u16,
};

pub const D3DBRANCH = extern struct {
    dwMask: u32,
    dwValue: u32,
    bNegate: BOOL,
    dwOffset: u32,
};

pub const D3DSTATUS = extern struct {
    dwFlags: u32,
    dwStatus: u32,
    drExtent: D3DRECT,
};

pub const D3DCLIPSTATUS = extern struct {
    dwFlags: u32,
    dwStatus: u32,
    minx: f32,
    maxx: f32,
    miny: f32,
    maxy: f32,
    minz: f32,
    maxz: f32,
};

pub const D3DSTATS = extern struct {
    dwSize: u32,
    dwTrianglesDrawn: u32,
    dwLinesDrawn: u32,
    dwPointsDrawn: u32,
    dwSpansDrawn: u32,
    dwVerticesProcessed: u32,
};

pub const D3DEXECUTEDATA = extern struct {
    dwSize: u32,
    dwVertexOffset: u32,
    dwVertexCount: u32,
    dwInstructionOffset: u32,
    dwInstructionLength: u32,
    dwHVertexOffset: u32,
    dsStatus: D3DSTATUS,
};

pub const D3DVERTEXBUFFERDESC = extern struct {
    dwSize: u32,
    dwCaps: u32,
    dwFVF: u32,
    dwNumVertices: u32,
};

pub const D3DDP_PTRSTRIDE = extern struct {
    lpvData: *c_void,
    dwStride: u32,
};

pub const D3DDRAWPRIMITIVESTRIDEDDATA = extern struct {
    position: D3DDP_PTRSTRIDE,
    normal: D3DDP_PTRSTRIDE,
    diffuse: D3DDP_PTRSTRIDE,
    specular: D3DDP_PTRSTRIDE,
    textureCoords: [8]D3DDP_PTRSTRIDE,
};

pub const D3DSTATEBLOCKTYPE = extern enum(i32) {
    D3DSBT_ALL = 1,
    D3DSBT_PIXELSTATE = 2,
    D3DSBT_VERTEXSTATE = 3,
    D3DSBT_FORCE_DWORD = -1,
};
pub const D3DSBT_ALL = D3DSTATEBLOCKTYPE.D3DSBT_ALL;
pub const D3DSBT_PIXELSTATE = D3DSTATEBLOCKTYPE.D3DSBT_PIXELSTATE;
pub const D3DSBT_VERTEXSTATE = D3DSTATEBLOCKTYPE.D3DSBT_VERTEXSTATE;
pub const D3DSBT_FORCE_DWORD = D3DSTATEBLOCKTYPE.D3DSBT_FORCE_DWORD;

pub const D3DVERTEXBLENDFLAGS = extern enum(i32) {
    D3DVBLEND_DISABLE = 0,
    D3DVBLEND_1WEIGHT = 1,
    D3DVBLEND_2WEIGHTS = 2,
    D3DVBLEND_3WEIGHTS = 3,
};
pub const D3DVBLEND_DISABLE = D3DVERTEXBLENDFLAGS.D3DVBLEND_DISABLE;
pub const D3DVBLEND_1WEIGHT = D3DVERTEXBLENDFLAGS.D3DVBLEND_1WEIGHT;
pub const D3DVBLEND_2WEIGHTS = D3DVERTEXBLENDFLAGS.D3DVBLEND_2WEIGHTS;
pub const D3DVBLEND_3WEIGHTS = D3DVERTEXBLENDFLAGS.D3DVBLEND_3WEIGHTS;

pub const D3DTEXTURETRANSFORMFLAGS = extern enum(i32) {
    D3DTTFF_DISABLE = 0,
    D3DTTFF_COUNT1 = 1,
    D3DTTFF_COUNT2 = 2,
    D3DTTFF_COUNT3 = 3,
    D3DTTFF_COUNT4 = 4,
    D3DTTFF_PROJECTED = 256,
    D3DTTFF_FORCE_DWORD = 2147483647,
};
pub const D3DTTFF_DISABLE = D3DTEXTURETRANSFORMFLAGS.D3DTTFF_DISABLE;
pub const D3DTTFF_COUNT1 = D3DTEXTURETRANSFORMFLAGS.D3DTTFF_COUNT1;
pub const D3DTTFF_COUNT2 = D3DTEXTURETRANSFORMFLAGS.D3DTTFF_COUNT2;
pub const D3DTTFF_COUNT3 = D3DTEXTURETRANSFORMFLAGS.D3DTTFF_COUNT3;
pub const D3DTTFF_COUNT4 = D3DTEXTURETRANSFORMFLAGS.D3DTTFF_COUNT4;
pub const D3DTTFF_PROJECTED = D3DTEXTURETRANSFORMFLAGS.D3DTTFF_PROJECTED;
pub const D3DTTFF_FORCE_DWORD = D3DTEXTURETRANSFORMFLAGS.D3DTTFF_FORCE_DWORD;

pub const D3DTRANSFORMCAPS = extern struct {
    dwSize: u32,
    dwCaps: u32,
};

pub const D3DLIGHTINGCAPS = extern struct {
    dwSize: u32,
    dwCaps: u32,
    dwLightingModel: u32,
    dwNumLights: u32,
};

pub const _D3DPrimCaps = extern struct {
    dwSize: u32,
    dwMiscCaps: u32,
    dwRasterCaps: u32,
    dwZCmpCaps: u32,
    dwSrcBlendCaps: u32,
    dwDestBlendCaps: u32,
    dwAlphaCmpCaps: u32,
    dwShadeCaps: u32,
    dwTextureCaps: u32,
    dwTextureFilterCaps: u32,
    dwTextureBlendCaps: u32,
    dwTextureAddressCaps: u32,
    dwStippleWidth: u32,
    dwStippleHeight: u32,
};

pub const _D3DDeviceDesc = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
};

pub const _D3DDeviceDesc7 = extern struct {
    dwDevCaps: u32,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
    dwMaxActiveLights: u32,
    dvMaxVertexW: f32,
    deviceGUID: Guid,
    wMaxUserClipPlanes: u16,
    wMaxVertexBlendMatrices: u16,
    dwVertexProcessingCaps: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwReserved4: u32,
};

pub const LPD3DENUMDEVICESCALLBACK = fn(
    lpGuid: *Guid,
    lpDeviceDescription: PSTR,
    lpDeviceName: PSTR,
    param3: *_D3DDeviceDesc,
    param4: *_D3DDeviceDesc,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const LPD3DENUMDEVICESCALLBACK7 = fn(
    lpDeviceDescription: PSTR,
    lpDeviceName: PSTR,
    param2: *_D3DDeviceDesc7,
    param3: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const D3DFINDDEVICESEARCH = extern struct {
    dwSize: u32,
    dwFlags: u32,
    bHardware: BOOL,
    dcmColorModel: u32,
    guid: Guid,
    dwCaps: u32,
    dpcPrimCaps: _D3DPrimCaps,
};

pub const D3DFINDDEVICERESULT = extern struct {
    dwSize: u32,
    guid: Guid,
    ddHwDesc: _D3DDeviceDesc,
    ddSwDesc: _D3DDeviceDesc,
};

pub const _D3DExecuteBufferDesc = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dwCaps: u32,
    dwBufferSize: u32,
    lpData: *c_void,
};

pub const D3DDEVINFO_TEXTUREMANAGER = extern struct {
    bThrashing: BOOL,
    dwApproxBytesDownloaded: u32,
    dwNumEvicts: u32,
    dwNumVidCreates: u32,
    dwNumTexturesUsed: u32,
    dwNumUsedTexInVid: u32,
    dwWorkingSet: u32,
    dwWorkingSetBytes: u32,
    dwTotalManaged: u32,
    dwTotalBytes: u32,
    dwLastPri: u32,
};

pub const D3DDEVINFO_TEXTURING = extern struct {
    dwNumLoads: u32,
    dwApproxBytesLoaded: u32,
    dwNumPreLoads: u32,
    dwNumSet: u32,
    dwNumCreates: u32,
    dwNumDestroys: u32,
    dwNumSetPriorities: u32,
    dwNumSetLODs: u32,
    dwNumLocks: u32,
    dwNumGetDCs: u32,
};

pub const _D3DNTHALDeviceDesc_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
};

pub const _D3DNTHALDeviceDesc_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
};

pub const _D3DNTDeviceDesc_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    dcmColorModel: u32,
    dwDevCaps: u32,
    dtcTransformCaps: D3DTRANSFORMCAPS,
    bClipping: BOOL,
    dlcLightingCaps: D3DLIGHTINGCAPS,
    dpcLineCaps: _D3DPrimCaps,
    dpcTriCaps: _D3DPrimCaps,
    dwDeviceRenderBitDepth: u32,
    dwDeviceZBufferBitDepth: u32,
    dwMaxBufferSize: u32,
    dwMaxVertexCount: u32,
    dwMinTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureWidth: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
};

pub const D3DNTHAL_GLOBALDRIVERDATA = extern struct {
    dwSize: u32,
    hwCaps: _D3DNTHALDeviceDesc_V1,
    dwNumVertices: u32,
    dwNumClipVertices: u32,
    dwNumTextureFormats: u32,
    lpTextureFormats: *DDSURFACEDESC,
};

pub const D3DNTHAL_D3DDX6EXTENDEDCAPS = extern struct {
    dwSize: u32,
    dwMinTextureWidth: u32,
    dwMaxTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
};

pub const D3DNTHAL_D3DEXTENDEDCAPS = extern struct {
    dwSize: u32,
    dwMinTextureWidth: u32,
    dwMaxTextureWidth: u32,
    dwMinTextureHeight: u32,
    dwMaxTextureHeight: u32,
    dwMinStippleWidth: u32,
    dwMaxStippleWidth: u32,
    dwMinStippleHeight: u32,
    dwMaxStippleHeight: u32,
    dwMaxTextureRepeat: u32,
    dwMaxTextureAspectRatio: u32,
    dwMaxAnisotropy: u32,
    dvGuardBandLeft: f32,
    dvGuardBandTop: f32,
    dvGuardBandRight: f32,
    dvGuardBandBottom: f32,
    dvExtentsAdjust: f32,
    dwStencilCaps: u32,
    dwFVFCaps: u32,
    dwTextureOpCaps: u32,
    wMaxTextureBlendStages: u16,
    wMaxSimultaneousTextures: u16,
    dwMaxActiveLights: u32,
    dvMaxVertexW: f32,
    wMaxUserClipPlanes: u16,
    wMaxVertexBlendMatrices: u16,
    dwVertexProcessingCaps: u32,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwReserved4: u32,
};

pub const D3DNTHAL_CONTEXTCREATEDATA = extern struct {
    Anonymous1: D3DNTHAL_CONTEXTCREATEDATA._Anonymous1_e__Union,
    Anonymous2: D3DNTHAL_CONTEXTCREATEDATA._Anonymous2_e__Union,
    Anonymous3: D3DNTHAL_CONTEXTCREATEDATA._Anonymous3_e__Union,
    dwPID: u32,
    dwhContext: ?*c_void,
    ddrval: HRESULT,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DNTHAL_CONTEXTDESTROYDATA = extern struct {
    dwhContext: ?*c_void,
    ddrval: HRESULT,
};

pub const D3DNTHAL_CONTEXTDESTROYALLDATA = extern struct {
    dwPID: u32,
    ddrval: HRESULT,
};

pub const D3DNTHAL_SCENECAPTUREDATA = extern struct {
    dwhContext: ?*c_void,
    dwFlag: u32,
    ddrval: HRESULT,
};

pub const D3DNTHAL_TEXTURECREATEDATA = extern struct {
    dwhContext: ?*c_void,
    hDDS: HANDLE,
    dwHandle: ?*c_void,
    ddrval: HRESULT,
};

pub const D3DNTHAL_TEXTUREDESTROYDATA = extern struct {
    dwhContext: ?*c_void,
    dwHandle: ?*c_void,
    ddrval: HRESULT,
};

pub const D3DNTHAL_TEXTURESWAPDATA = extern struct {
    dwhContext: ?*c_void,
    dwHandle1: ?*c_void,
    dwHandle2: ?*c_void,
    ddrval: HRESULT,
};

pub const D3DNTHAL_TEXTUREGETSURFDATA = extern struct {
    dwhContext: ?*c_void,
    hDDS: HANDLE,
    dwHandle: ?*c_void,
    ddrval: HRESULT,
};

pub const LPD3DNTHAL_CONTEXTCREATECB = fn(
    param0: *D3DNTHAL_CONTEXTCREATEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_CONTEXTDESTROYCB = fn(
    param0: *D3DNTHAL_CONTEXTDESTROYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_CONTEXTDESTROYALLCB = fn(
    param0: *D3DNTHAL_CONTEXTDESTROYALLDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_SCENECAPTURECB = fn(
    param0: *D3DNTHAL_SCENECAPTUREDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_TEXTURECREATECB = fn(
    param0: *D3DNTHAL_TEXTURECREATEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_TEXTUREDESTROYCB = fn(
    param0: *D3DNTHAL_TEXTUREDESTROYDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_TEXTURESWAPCB = fn(
    param0: *D3DNTHAL_TEXTURESWAPDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_TEXTUREGETSURFCB = fn(
    param0: *D3DNTHAL_TEXTUREGETSURFDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const D3DNTHAL_CALLBACKS = extern struct {
    dwSize: u32,
    ContextCreate: LPD3DNTHAL_CONTEXTCREATECB,
    ContextDestroy: LPD3DNTHAL_CONTEXTDESTROYCB,
    ContextDestroyAll: LPD3DNTHAL_CONTEXTDESTROYALLCB,
    SceneCapture: LPD3DNTHAL_SCENECAPTURECB,
    dwReserved10: *c_void,
    dwReserved11: *c_void,
    dwReserved22: *c_void,
    dwReserved23: *c_void,
    dwReserved: ?*c_void,
    TextureCreate: LPD3DNTHAL_TEXTURECREATECB,
    TextureDestroy: LPD3DNTHAL_TEXTUREDESTROYCB,
    TextureSwap: LPD3DNTHAL_TEXTURESWAPCB,
    TextureGetSurf: LPD3DNTHAL_TEXTUREGETSURFCB,
    dwReserved12: *c_void,
    dwReserved13: *c_void,
    dwReserved14: *c_void,
    dwReserved15: *c_void,
    dwReserved16: *c_void,
    dwReserved17: *c_void,
    dwReserved18: *c_void,
    dwReserved19: *c_void,
    dwReserved20: *c_void,
    dwReserved21: *c_void,
    dwReserved24: *c_void,
    dwReserved0: ?*c_void,
    dwReserved1: ?*c_void,
    dwReserved2: ?*c_void,
    dwReserved3: ?*c_void,
    dwReserved4: ?*c_void,
    dwReserved5: ?*c_void,
    dwReserved6: ?*c_void,
    dwReserved7: ?*c_void,
    dwReserved8: ?*c_void,
    dwReserved9: ?*c_void,
};

pub const D3DNTHAL_SETRENDERTARGETDATA = extern struct {
    dwhContext: ?*c_void,
    lpDDS: *DD_SURFACE_LOCAL,
    lpDDSZ: *DD_SURFACE_LOCAL,
    ddrval: HRESULT,
};

pub const LPD3DNTHAL_SETRENDERTARGETCB = fn(
    param0: *D3DNTHAL_SETRENDERTARGETDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const D3DNTHAL_CALLBACKS2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    SetRenderTarget: LPD3DNTHAL_SETRENDERTARGETCB,
    dwReserved1: *c_void,
    dwReserved2: *c_void,
    dwReserved3: *c_void,
    dwReserved4: *c_void,
};

pub const D3DNTHAL_CLEAR2DATA = extern struct {
    dwhContext: ?*c_void,
    dwFlags: u32,
    dwFillColor: u32,
    dvFillDepth: f32,
    dwFillStencil: u32,
    lpRects: *D3DRECT,
    dwNumRects: u32,
    ddrval: HRESULT,
};

pub const D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA = extern struct {
    dwhContext: ?*c_void,
    dwFlags: u32,
    dwReserved: ?*c_void,
    dwNumPasses: u32,
    ddrval: HRESULT,
};

pub const D3DNTHAL_DP2COMMAND = extern struct {
    bCommand: u8,
    bReserved: u8,
    Anonymous: D3DNTHAL_DP2COMMAND._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DNTHAL_DP2OPERATION = extern enum(i32) {
    D3DNTDP2OP_POINTS = 1,
    D3DNTDP2OP_INDEXEDLINELIST = 2,
    D3DNTDP2OP_INDEXEDTRIANGLELIST = 3,
    D3DNTDP2OP_RENDERSTATE = 8,
    D3DNTDP2OP_LINELIST = 15,
    D3DNTDP2OP_LINESTRIP = 16,
    D3DNTDP2OP_INDEXEDLINESTRIP = 17,
    D3DNTDP2OP_TRIANGLELIST = 18,
    D3DNTDP2OP_TRIANGLESTRIP = 19,
    D3DNTDP2OP_INDEXEDTRIANGLESTRIP = 20,
    D3DNTDP2OP_TRIANGLEFAN = 21,
    D3DNTDP2OP_INDEXEDTRIANGLEFAN = 22,
    D3DNTDP2OP_TRIANGLEFAN_IMM = 23,
    D3DNTDP2OP_LINELIST_IMM = 24,
    D3DNTDP2OP_TEXTURESTAGESTATE = 25,
    D3DNTDP2OP_INDEXEDTRIANGLELIST2 = 26,
    D3DNTDP2OP_INDEXEDLINELIST2 = 27,
    D3DNTDP2OP_VIEWPORTINFO = 28,
    D3DNTDP2OP_WINFO = 29,
    D3DNTDP2OP_SETPALETTE = 30,
    D3DNTDP2OP_UPDATEPALETTE = 31,
    D3DNTDP2OP_ZRANGE = 32,
    D3DNTDP2OP_SETMATERIAL = 33,
    D3DNTDP2OP_SETLIGHT = 34,
    D3DNTDP2OP_CREATELIGHT = 35,
    D3DNTDP2OP_SETTRANSFORM = 36,
    D3DNTDP2OP_TEXBLT = 38,
    D3DNTDP2OP_STATESET = 39,
    D3DNTDP2OP_SETPRIORITY = 40,
    D3DNTDP2OP_SETRENDERTARGET = 41,
    D3DNTDP2OP_CLEAR = 42,
    D3DNTDP2OP_SETTEXLOD = 43,
    D3DNTDP2OP_SETCLIPPLANE = 44,
};
pub const D3DNTDP2OP_POINTS = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_POINTS;
pub const D3DNTDP2OP_INDEXEDLINELIST = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_INDEXEDLINELIST;
pub const D3DNTDP2OP_INDEXEDTRIANGLELIST = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_INDEXEDTRIANGLELIST;
pub const D3DNTDP2OP_RENDERSTATE = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_RENDERSTATE;
pub const D3DNTDP2OP_LINELIST = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_LINELIST;
pub const D3DNTDP2OP_LINESTRIP = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_LINESTRIP;
pub const D3DNTDP2OP_INDEXEDLINESTRIP = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_INDEXEDLINESTRIP;
pub const D3DNTDP2OP_TRIANGLELIST = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_TRIANGLELIST;
pub const D3DNTDP2OP_TRIANGLESTRIP = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_TRIANGLESTRIP;
pub const D3DNTDP2OP_INDEXEDTRIANGLESTRIP = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_INDEXEDTRIANGLESTRIP;
pub const D3DNTDP2OP_TRIANGLEFAN = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_TRIANGLEFAN;
pub const D3DNTDP2OP_INDEXEDTRIANGLEFAN = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_INDEXEDTRIANGLEFAN;
pub const D3DNTDP2OP_TRIANGLEFAN_IMM = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_TRIANGLEFAN_IMM;
pub const D3DNTDP2OP_LINELIST_IMM = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_LINELIST_IMM;
pub const D3DNTDP2OP_TEXTURESTAGESTATE = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_TEXTURESTAGESTATE;
pub const D3DNTDP2OP_INDEXEDTRIANGLELIST2 = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_INDEXEDTRIANGLELIST2;
pub const D3DNTDP2OP_INDEXEDLINELIST2 = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_INDEXEDLINELIST2;
pub const D3DNTDP2OP_VIEWPORTINFO = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_VIEWPORTINFO;
pub const D3DNTDP2OP_WINFO = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_WINFO;
pub const D3DNTDP2OP_SETPALETTE = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_SETPALETTE;
pub const D3DNTDP2OP_UPDATEPALETTE = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_UPDATEPALETTE;
pub const D3DNTDP2OP_ZRANGE = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_ZRANGE;
pub const D3DNTDP2OP_SETMATERIAL = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_SETMATERIAL;
pub const D3DNTDP2OP_SETLIGHT = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_SETLIGHT;
pub const D3DNTDP2OP_CREATELIGHT = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_CREATELIGHT;
pub const D3DNTDP2OP_SETTRANSFORM = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_SETTRANSFORM;
pub const D3DNTDP2OP_TEXBLT = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_TEXBLT;
pub const D3DNTDP2OP_STATESET = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_STATESET;
pub const D3DNTDP2OP_SETPRIORITY = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_SETPRIORITY;
pub const D3DNTDP2OP_SETRENDERTARGET = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_SETRENDERTARGET;
pub const D3DNTDP2OP_CLEAR = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_CLEAR;
pub const D3DNTDP2OP_SETTEXLOD = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_SETTEXLOD;
pub const D3DNTDP2OP_SETCLIPPLANE = D3DNTHAL_DP2OPERATION.D3DNTDP2OP_SETCLIPPLANE;

pub const D3DNTHAL_DP2POINTS = extern struct {
    wCount: u16,
    wVStart: u16,
};

pub const D3DNTHAL_DP2STARTVERTEX = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2LINELIST = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDLINELIST = extern struct {
    wV1: u16,
    wV2: u16,
};

pub const D3DNTHAL_DP2LINESTRIP = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDLINESTRIP = extern struct {
    wV: [2]u16,
};

pub const D3DNTHAL_DP2TRIANGLELIST = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDTRIANGLELIST = extern struct {
    wV1: u16,
    wV2: u16,
    wV3: u16,
    wFlags: u16,
};

pub const D3DNTHAL_DP2INDEXEDTRIANGLELIST2 = extern struct {
    wV1: u16,
    wV2: u16,
    wV3: u16,
};

pub const D3DNTHAL_DP2TRIANGLESTRIP = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDTRIANGLESTRIP = extern struct {
    wV: [3]u16,
};

pub const D3DNTHAL_DP2TRIANGLEFAN = extern struct {
    wVStart: u16,
};

pub const D3DNTHAL_DP2INDEXEDTRIANGLEFAN = extern struct {
    wV: [3]u16,
};

pub const D3DNTHAL_DP2TRIANGLEFAN_IMM = extern struct {
    dwEdgeFlags: u32,
};

pub const D3DNTHAL_DP2RENDERSTATE = extern struct {
    RenderState: D3DRENDERSTATETYPE,
    Anonymous: D3DNTHAL_DP2RENDERSTATE._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DNTHAL_DP2TEXTURESTAGESTATE = extern struct {
    wStage: u16,
    TSState: u16,
    dwValue: u32,
};

pub const D3DNTHAL_DP2VIEWPORTINFO = extern struct {
    dwX: u32,
    dwY: u32,
    dwWidth: u32,
    dwHeight: u32,
};

pub const D3DNTHAL_DP2WINFO = extern struct {
    dvWNear: f32,
    dvWFar: f32,
};

pub const D3DNTHAL_DP2SETPALETTE = extern struct {
    dwPaletteHandle: u32,
    dwPaletteFlags: u32,
    dwSurfaceHandle: u32,
};

pub const D3DNTHAL_DP2UPDATEPALETTE = extern struct {
    dwPaletteHandle: u32,
    wStartIndex: u16,
    wNumEntries: u16,
};

pub const D3DNTHAL_DP2SETRENDERTARGET = extern struct {
    hRenderTarget: u32,
    hZBuffer: u32,
};

pub const D3DNTHAL_DP2STATESET = extern struct {
    dwOperation: u32,
    dwParam: u32,
    sbType: D3DSTATEBLOCKTYPE,
};

pub const D3DNTHAL_DP2ZRANGE = extern struct {
    dvMinZ: f32,
    dvMaxZ: f32,
};

pub const D3DNTHAL_DP2SETLIGHT = extern struct {
    dwIndex: u32,
    Anonymous: D3DNTHAL_DP2SETLIGHT._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const D3DNTHAL_DP2SETCLIPPLANE = extern struct {
    dwIndex: u32,
    plane: [4]f32,
};

pub const D3DNTHAL_DP2CREATELIGHT = extern struct {
    dwIndex: u32,
};

pub const D3DNTHAL_DP2SETTRANSFORM = extern struct {
    xfrmType: D3DTRANSFORMSTATETYPE,
    matrix: D3DMATRIX,
};

pub const D3DNTHAL_DP2EXT = extern struct {
    dwExtToken: u32,
    dwSize: u32,
};

pub const D3DNTHAL_DP2TEXBLT = extern struct {
    dwDDDestSurface: u32,
    dwDDSrcSurface: u32,
    pDest: POINT,
    rSrc: RECTL,
    dwFlags: u32,
};

pub const D3DNTHAL_DP2SETPRIORITY = extern struct {
    dwDDDestSurface: u32,
    dwPriority: u32,
};

pub const D3DNTHAL_DP2CLEAR = extern struct {
    dwFlags: u32,
    dwFillColor: u32,
    dvFillDepth: f32,
    dwFillStencil: u32,
    Rects: [1]RECT,
};

pub const D3DNTHAL_DP2SETTEXLOD = extern struct {
    dwDDSurface: u32,
    dwLOD: u32,
};

pub const D3DNTHAL_DRAWPRIMITIVES2DATA = extern struct {
    dwhContext: ?*c_void,
    dwFlags: u32,
    dwVertexType: u32,
    lpDDCommands: *DD_SURFACE_LOCAL,
    dwCommandOffset: u32,
    dwCommandLength: u32,
    Anonymous1: D3DNTHAL_DRAWPRIMITIVES2DATA._Anonymous1_e__Union,
    dwVertexOffset: u32,
    dwVertexLength: u32,
    dwReqVertexBufSize: u32,
    dwReqCommandBufSize: u32,
    lpdwRStates: *u32,
    Anonymous2: D3DNTHAL_DRAWPRIMITIVES2DATA._Anonymous2_e__Union,
    dwErrorOffset: u32,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const LPD3DNTHAL_CLEAR2CB = fn(
    param0: *D3DNTHAL_CLEAR2DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB = fn(
    param0: *D3DNTHAL_VALIDATETEXTURESTAGESTATEDATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPD3DNTHAL_DRAWPRIMITIVES2CB = fn(
    param0: *D3DNTHAL_DRAWPRIMITIVES2DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const D3DNTHAL_CALLBACKS3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    Clear2: LPD3DNTHAL_CLEAR2CB,
    lpvReserved: *c_void,
    ValidateTextureStageState: LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB,
    DrawPrimitives2: LPD3DNTHAL_DRAWPRIMITIVES2CB,
};

pub const PFND3DNTPARSEUNKNOWNCOMMAND = fn(
    lpvCommands: *c_void,
    lplpvReturnedCommand: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const POINTE = extern struct {
    x: u32,
    y: u32,
};

pub const FLOAT_LONG = u32; // TODO: implement StructOrUnion types?

pub const POINTFIX = extern struct {
    x: i32,
    y: i32,
};

pub const RECTFX = extern struct {
    xLeft: i32,
    yTop: i32,
    xRight: i32,
    yBottom: i32,
};

pub const HBM__ = extern struct {
    unused: i32,
};

pub const HDEV__ = extern struct {
    unused: i32,
};

pub const DHSURF__ = extern struct {
    unused: i32,
};

pub const DHPDEV__ = extern struct {
    unused: i32,
};

pub const LIGATURE = extern struct {
    culSize: u32,
    pwsz: PWSTR,
    chglyph: u32,
    ahglyph: [1]u32,
};

pub const FD_LIGATURE = extern struct {
    culThis: u32,
    ulType: u32,
    cLigatures: u32,
    alig: [1]LIGATURE,
};

pub const POINTQF = extern struct {
    x: LARGE_INTEGER,
    y: LARGE_INTEGER,
};

pub const PFN = fn(
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const CDDDXGK_REDIRBITMAPPRESENTINFO = extern struct {
    NumDirtyRects: u32,
    DirtyRect: *RECT,
    NumContexts: u32,
    hContext: [65]?*c_void,
    bDoNotSynchronizeWithDxContent: u8,
};

// TODO: this function pointer causes dependency loop problems, so it's stubbed out
pub const FREEOBJPROC = fn() callconv(@import("std").os.windows.WINAPI) void;

pub const XFORMOBJ = extern struct {
    ulReserved: u32,
};

pub const WNDOBJCHANGEPROC = fn(
    pwo: *WNDOBJ,
    fl: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const SORTCOMP = fn(
    pv1: *const c_void,
    pv2: *const c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ENG_SYSTEM_ATTRIBUTE = extern enum(i32) {
    EngProcessorFeature = 1,
    EngNumberOfProcessors = 2,
    EngOptimumAvailableUserMemory = 3,
    EngOptimumAvailableSystemMemory = 4,
};
pub const EngProcessorFeature = ENG_SYSTEM_ATTRIBUTE.EngProcessorFeature;
pub const EngNumberOfProcessors = ENG_SYSTEM_ATTRIBUTE.EngNumberOfProcessors;
pub const EngOptimumAvailableUserMemory = ENG_SYSTEM_ATTRIBUTE.EngOptimumAvailableUserMemory;
pub const EngOptimumAvailableSystemMemory = ENG_SYSTEM_ATTRIBUTE.EngOptimumAvailableSystemMemory;

pub const ENG_DEVICE_ATTRIBUTE = extern enum(i32) {
    QDA_RESERVED = 0,
    QDA_ACCELERATION_LEVEL = 1,
};
pub const QDA_RESERVED = ENG_DEVICE_ATTRIBUTE.QDA_RESERVED;
pub const QDA_ACCELERATION_LEVEL = ENG_DEVICE_ATTRIBUTE.QDA_ACCELERATION_LEVEL;

pub const EMFINFO = extern struct {
    nSize: u32,
    hdc: HDC,
    pvEMF: *u8,
    pvCurrentRecord: *u8,
};

pub const PFN_DrvEnableDriver = fn(
    param0: u32,
    param1: u32,
    param2: *DRVENABLEDATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEnablePDEV = fn(
    param0: *DEVMODEW,
    param1: PWSTR,
    param2: u32,
    param3: *HSURF,
    param4: u32,
    param5: *GDIINFO,
    param6: u32,
    param7: *DEVINFO,
    param8: ?*c_void,
    param9: PWSTR,
    param10: HANDLE,
) callconv(@import("std").os.windows.WINAPI) *DHPDEV__;

pub const PFN_DrvCompletePDEV = fn(
    param0: *DHPDEV__,
    param1: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvResetDevice = fn(
    param0: *DHPDEV__,
    param1: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvDisablePDEV = fn(
    param0: *DHPDEV__,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvSynchronize = fn(
    param0: *DHPDEV__,
    param1: *RECTL,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvEnableSurface = fn(
    param0: *DHPDEV__,
) callconv(@import("std").os.windows.WINAPI) HSURF;

pub const PFN_DrvDisableDriver = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvDisableSurface = fn(
    param0: *DHPDEV__,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvAssertMode = fn(
    param0: *DHPDEV__,
    param1: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvTextOut = fn(
    param0: *SURFOBJ,
    param1: *STROBJ,
    param2: *FONTOBJ,
    param3: *CLIPOBJ,
    param4: *RECTL,
    param5: *RECTL,
    param6: *BRUSHOBJ,
    param7: *BRUSHOBJ,
    param8: *POINTL,
    param9: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStretchBlt = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *CLIPOBJ,
    param4: *XLATEOBJ,
    param5: *COLORADJUSTMENT,
    param6: *POINTL,
    param7: *RECTL,
    param8: *RECTL,
    param9: *POINTL,
    param10: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStretchBltROP = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *CLIPOBJ,
    param4: *XLATEOBJ,
    param5: *COLORADJUSTMENT,
    param6: *POINTL,
    param7: *RECTL,
    param8: *RECTL,
    param9: *POINTL,
    param10: u32,
    param11: *BRUSHOBJ,
    param12: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvTransparentBlt = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *CLIPOBJ,
    param3: *XLATEOBJ,
    param4: *RECTL,
    param5: *RECTL,
    param6: u32,
    param7: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvPlgBlt = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *CLIPOBJ,
    param4: *XLATEOBJ,
    param5: *COLORADJUSTMENT,
    param6: *POINTL,
    param7: *POINTFIX,
    param8: *RECTL,
    param9: *POINTL,
    param10: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvBitBlt = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *CLIPOBJ,
    param4: *XLATEOBJ,
    param5: *RECTL,
    param6: *POINTL,
    param7: *POINTL,
    param8: *BRUSHOBJ,
    param9: *POINTL,
    param10: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvRealizeBrush = fn(
    param0: *BRUSHOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *SURFOBJ,
    param4: *XLATEOBJ,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvCopyBits = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *CLIPOBJ,
    param3: *XLATEOBJ,
    param4: *RECTL,
    param5: *POINTL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvDitherColor = fn(
    param0: *DHPDEV__,
    param1: u32,
    param2: u32,
    param3: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvCreateDeviceBitmap = fn(
    param0: *DHPDEV__,
    param1: SIZE,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) HBITMAP;

pub const PFN_DrvDeleteDeviceBitmap = fn(
    param0: *DHSURF__,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvSetPalette = fn(
    param0: *DHPDEV__,
    param1: *PALOBJ,
    param2: u32,
    param3: u32,
    param4: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEscape = fn(
    param0: *SURFOBJ,
    param1: u32,
    param2: u32,
    param3: *c_void,
    param4: u32,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvDrawEscape = fn(
    param0: *SURFOBJ,
    param1: u32,
    param2: *CLIPOBJ,
    param3: *RECTL,
    param4: u32,
    param5: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvQueryFont = fn(
    param0: *DHPDEV__,
    param1: ?*c_void,
    param2: u32,
    param3: *?*c_void,
) callconv(@import("std").os.windows.WINAPI) *IFIMETRICS;

pub const PFN_DrvQueryFontTree = fn(
    param0: *DHPDEV__,
    param1: ?*c_void,
    param2: u32,
    param3: u32,
    param4: *?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFN_DrvQueryFontData = fn(
    param0: *DHPDEV__,
    param1: *FONTOBJ,
    param2: u32,
    param3: u32,
    param4: *GLYPHDATA,
    param5: *c_void,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvFree = fn(
    param0: *c_void,
    param1: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvDestroyFont = fn(
    param0: *FONTOBJ,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvQueryFontCaps = fn(
    param0: u32,
    param1: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvLoadFontFile = fn(
    param0: u32,
    param1: *?*c_void,
    param2: **c_void,
    param3: *u32,
    param4: *DESIGNVECTOR,
    param5: u32,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const PFN_DrvUnloadFontFile = fn(
    param0: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvSetPointerShape = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *SURFOBJ,
    param3: *XLATEOBJ,
    param4: i32,
    param5: i32,
    param6: i32,
    param7: i32,
    param8: *RECTL,
    param9: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvMovePointer = fn(
    pso: *SURFOBJ,
    x: i32,
    y: i32,
    prcl: *RECTL,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvSendPage = fn(
    param0: *SURFOBJ,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStartPage = fn(
    pso: *SURFOBJ,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStartDoc = fn(
    pso: *SURFOBJ,
    pwszDocName: PWSTR,
    dwJobId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEndDoc = fn(
    pso: *SURFOBJ,
    fl: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvQuerySpoolType = fn(
    dhpdev: *DHPDEV__,
    pwchType: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvLineTo = fn(
    param0: *SURFOBJ,
    param1: *CLIPOBJ,
    param2: *BRUSHOBJ,
    param3: i32,
    param4: i32,
    param5: i32,
    param6: i32,
    param7: *RECTL,
    param8: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStrokePath = fn(
    param0: *SURFOBJ,
    param1: *PATHOBJ,
    param2: *CLIPOBJ,
    param3: *XFORMOBJ,
    param4: *BRUSHOBJ,
    param5: *POINTL,
    param6: *LINEATTRS,
    param7: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvFillPath = fn(
    param0: *SURFOBJ,
    param1: *PATHOBJ,
    param2: *CLIPOBJ,
    param3: *BRUSHOBJ,
    param4: *POINTL,
    param5: u32,
    param6: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStrokeAndFillPath = fn(
    param0: *SURFOBJ,
    param1: *PATHOBJ,
    param2: *CLIPOBJ,
    param3: *XFORMOBJ,
    param4: *BRUSHOBJ,
    param5: *LINEATTRS,
    param6: *BRUSHOBJ,
    param7: *POINTL,
    param8: u32,
    param9: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvPaint = fn(
    param0: *SURFOBJ,
    param1: *CLIPOBJ,
    param2: *BRUSHOBJ,
    param3: *POINTL,
    param4: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvGetGlyphMode = fn(
    dhpdev: *DHPDEV__,
    pfo: *FONTOBJ,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvResetPDEV = fn(
    dhpdevOld: *DHPDEV__,
    dhpdevNew: *DHPDEV__,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvSaveScreenBits = fn(
    param0: *SURFOBJ,
    param1: u32,
    param2: ?*c_void,
    param3: *RECTL,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const PFN_DrvGetModes = fn(
    param0: HANDLE,
    param1: u32,
    param2: *DEVMODEW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvQueryTrueTypeTable = fn(
    param0: ?*c_void,
    param1: u32,
    param2: u32,
    param3: i32,
    param4: u32,
    param5: *u8,
    param6: **u8,
    param7: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvQueryTrueTypeSection = fn(
    param0: u32,
    param1: u32,
    param2: u32,
    param3: *HANDLE,
    param4: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvQueryTrueTypeOutline = fn(
    param0: *DHPDEV__,
    param1: *FONTOBJ,
    param2: u32,
    param3: BOOL,
    param4: *GLYPHDATA,
    param5: u32,
    param6: *TTPOLYGONHEADER,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvGetTrueTypeFile = fn(
    param0: ?*c_void,
    param1: *u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFN_DrvQueryFontFile = fn(
    param0: ?*c_void,
    param1: u32,
    param2: u32,
    param3: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvQueryAdvanceWidths = fn(
    param0: *DHPDEV__,
    param1: *FONTOBJ,
    param2: u32,
    param3: *u32,
    param4: *c_void,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvFontManagement = fn(
    param0: *SURFOBJ,
    param1: *FONTOBJ,
    param2: u32,
    param3: u32,
    param4: *c_void,
    param5: u32,
    param6: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFN_DrvSetPixelFormat = fn(
    param0: *SURFOBJ,
    param1: i32,
    param2: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvDescribePixelFormat = fn(
    param0: *DHPDEV__,
    param1: i32,
    param2: u32,
    param3: *PIXELFORMATDESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvSwapBuffers = fn(
    param0: *SURFOBJ,
    param1: *WNDOBJ,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStartBanding = fn(
    param0: *SURFOBJ,
    ppointl: *POINTL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvNextBand = fn(
    param0: *SURFOBJ,
    ppointl: *POINTL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvQueryPerBandInfo = fn(
    param0: *SURFOBJ,
    param1: *PERBANDINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEnableDirectDraw = fn(
    param0: *DHPDEV__,
    param1: *DD_CALLBACKS,
    param2: *DD_SURFACECALLBACKS,
    param3: *DD_PALETTECALLBACKS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvDisableDirectDraw = fn(
    param0: *DHPDEV__,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvGetDirectDrawInfo = fn(
    param0: *DHPDEV__,
    param1: *DD_HALINFO,
    param2: *u32,
    param3: *VIDEOMEMORY,
    param4: *u32,
    param5: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvIcmCreateColorTransform = fn(
    param0: *DHPDEV__,
    param1: *LOGCOLORSPACEW,
    param2: *c_void,
    param3: u32,
    param4: *c_void,
    param5: u32,
    param6: *c_void,
    param7: u32,
    param8: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const PFN_DrvIcmDeleteColorTransform = fn(
    param0: *DHPDEV__,
    param1: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvIcmCheckBitmapBits = fn(
    param0: *DHPDEV__,
    param1: HANDLE,
    param2: *SURFOBJ,
    param3: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvIcmSetDeviceGammaRamp = fn(
    param0: *DHPDEV__,
    param1: u32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvAlphaBlend = fn(
    param0: *SURFOBJ,
    param1: *SURFOBJ,
    param2: *CLIPOBJ,
    param3: *XLATEOBJ,
    param4: *RECTL,
    param5: *RECTL,
    param6: *BLENDOBJ,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvGradientFill = fn(
    param0: *SURFOBJ,
    param1: *CLIPOBJ,
    param2: *XLATEOBJ,
    param3: *TRIVERTEX,
    param4: u32,
    param5: *c_void,
    param6: u32,
    param7: *RECTL,
    param8: *POINTL,
    param9: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvQueryDeviceSupport = fn(
    param0: *SURFOBJ,
    param1: *XLATEOBJ,
    param2: *XFORMOBJ,
    param3: u32,
    param4: u32,
    param5: *c_void,
    param6: u32,
    param7: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvDeriveSurface = fn(
    param0: *DD_DIRECTDRAW_GLOBAL,
    param1: *DD_SURFACE_LOCAL,
) callconv(@import("std").os.windows.WINAPI) HBITMAP;

pub const PFN_DrvSynchronizeSurface = fn(
    param0: *SURFOBJ,
    param1: *RECTL,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvNotify = fn(
    param0: *SURFOBJ,
    param1: u32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvRenderHint = fn(
    dhpdev: *DHPDEV__,
    NotifyCode: u32,
    Length: ?*c_void,
    Data: ?[*]u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const DRH_APIBITMAPDATA = extern struct {
    pso: *SURFOBJ,
    b: BOOL,
};

pub const PFN_EngCreateRectRgn = fn(
    left: i32,
    top: i32,
    right: i32,
    bottom: i32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub const PFN_EngDeleteRgn = fn(
    hrgn: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_EngCombineRgn = fn(
    hrgnTrg: HANDLE,
    hrgnSrc1: HANDLE,
    hrgnSrc2: HANDLE,
    imode: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngCopyRgn = fn(
    hrgnDst: HANDLE,
    hrgnSrc: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngIntersectRgn = fn(
    hrgnResult: HANDLE,
    hRgnA: HANDLE,
    hRgnB: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngSubtractRgn = fn(
    hrgnResult: HANDLE,
    hRgnA: HANDLE,
    hRgnB: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngUnionRgn = fn(
    hrgnResult: HANDLE,
    hRgnA: HANDLE,
    hRgnB: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_EngXorRgn = fn(
    hrgnResult: HANDLE,
    hRgnA: HANDLE,
    hRgnB: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFN_DrvCreateDeviceBitmapEx = fn(
    param0: *DHPDEV__,
    param1: SIZE,
    param2: u32,
    param3: u32,
    param4: *DHSURF__,
    param5: u32,
    param6: u32,
    param7: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) HBITMAP;

pub const PFN_DrvDeleteDeviceBitmapEx = fn(
    param0: *DHSURF__,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvAssociateSharedSurface = fn(
    param0: *SURFOBJ,
    param1: HANDLE,
    param2: HANDLE,
    param3: SIZE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvSynchronizeRedirectionBitmaps = fn(
    param0: *DHPDEV__,
    param1: *u64,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const PFN_DrvAccumulateD3DDirtyRect = fn(
    param0: *SURFOBJ,
    param1: *CDDDXGK_REDIRBITMAPPRESENTINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvStartDxInterop = fn(
    param0: *SURFOBJ,
    param1: BOOL,
    KernelModeDeviceHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvEndDxInterop = fn(
    param0: *SURFOBJ,
    param1: BOOL,
    param2: *BOOL,
    KernelModeDeviceHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_DrvLockDisplayArea = fn(
    param0: *DHPDEV__,
    param1: *RECTL,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvUnlockDisplayArea = fn(
    param0: *DHPDEV__,
    param1: *RECTL,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_DrvSurfaceComplete = fn(
    param0: *DHPDEV__,
    param1: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const DEVICE_EVENT_MOUNT = extern struct {
    Version: u32,
    Flags: u32,
    FileSystemNameLength: u32,
    FileSystemNameOffset: u32,
};

pub const DEVICE_EVENT_BECOMING_READY = extern struct {
    Version: u32,
    Reason: u32,
    Estimated100msToReady: u32,
};

pub const DEVICE_EVENT_EXTERNAL_REQUEST = extern struct {
    Version: u32,
    DeviceClass: u32,
    ButtonStatus: u16,
    Request: u16,
    SystemTime: LARGE_INTEGER,
};

pub const DEVICE_EVENT_GENERIC_DATA = extern struct {
    EventNumber: u32,
};

pub const DEVICE_EVENT_RBC_DATA = extern struct {
    EventNumber: u32,
    SenseQualifier: u8,
    SenseCode: u8,
    SenseKey: u8,
    Reserved: u8,
    Information: u32,
};

pub const GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION = extern struct {
    DiskNumber: u32,
};

pub const DISK_HEALTH_NOTIFICATION_DATA = extern struct {
    DeviceGuid: Guid,
};

pub const DEVPROPKEY = extern struct {
    fmtid: Guid,
    pid: u32,
};

pub const DEVPROPSTORE = extern enum(i32) {
    DEVPROP_STORE_SYSTEM = 0,
    DEVPROP_STORE_USER = 1,
};
pub const DEVPROP_STORE_SYSTEM = DEVPROPSTORE.DEVPROP_STORE_SYSTEM;
pub const DEVPROP_STORE_USER = DEVPROPSTORE.DEVPROP_STORE_USER;

pub const DEVPROPCOMPKEY = extern struct {
    Key: DEVPROPKEY,
    Store: DEVPROPSTORE,
    LocaleName: [*:0]const u16,
};

pub const DEVPROPERTY = extern struct {
    CompKey: DEVPROPCOMPKEY,
    Type: u32,
    BufferSize: u32,
    Buffer: *c_void,
};

pub const REDBOOK_DIGITAL_AUDIO_EXTRACTION_INFO = extern struct {
    Version: u32,
    Accurate: u32,
    Supported: u32,
    AccurateMask0: u32,
};

pub const DEV_BROADCAST_HDR = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
};

pub const VolLockBroadcast = extern struct {
    vlb_dbh: DEV_BROADCAST_HDR,
    vlb_owner: u32,
    vlb_perms: u8,
    vlb_lockType: u8,
    vlb_drive: u8,
    vlb_flags: u8,
};

pub const _DEV_BROADCAST_HEADER = extern struct {
    dbcd_size: u32,
    dbcd_devicetype: u32,
    dbcd_reserved: u32,
};

pub const DEV_BROADCAST_OEM = extern struct {
    dbco_size: u32,
    dbco_devicetype: u32,
    dbco_reserved: u32,
    dbco_identifier: u32,
    dbco_suppfunc: u32,
};

pub const DEV_BROADCAST_DEVNODE = extern struct {
    dbcd_size: u32,
    dbcd_devicetype: u32,
    dbcd_reserved: u32,
    dbcd_devnode: u32,
};

pub const DEV_BROADCAST_VOLUME = extern struct {
    dbcv_size: u32,
    dbcv_devicetype: u32,
    dbcv_reserved: u32,
    dbcv_unitmask: u32,
    dbcv_flags: u16,
};

pub const DEV_BROADCAST_PORT_A = extern struct {
    dbcp_size: u32,
    dbcp_devicetype: u32,
    dbcp_reserved: u32,
    dbcp_name: [1]i8,
};

pub const DEV_BROADCAST_PORT_W = extern struct {
    dbcp_size: u32,
    dbcp_devicetype: u32,
    dbcp_reserved: u32,
    dbcp_name: [1]u16,
};

pub const DEV_BROADCAST_NET = extern struct {
    dbcn_size: u32,
    dbcn_devicetype: u32,
    dbcn_reserved: u32,
    dbcn_resource: u32,
    dbcn_flags: u32,
};

pub const DEV_BROADCAST_DEVICEINTERFACE_A = extern struct {
    dbcc_size: u32,
    dbcc_devicetype: u32,
    dbcc_reserved: u32,
    dbcc_classguid: Guid,
    dbcc_name: [1]i8,
};

pub const DEV_BROADCAST_DEVICEINTERFACE_W = extern struct {
    dbcc_size: u32,
    dbcc_devicetype: u32,
    dbcc_reserved: u32,
    dbcc_classguid: Guid,
    dbcc_name: [1]u16,
};

pub const DEV_BROADCAST_HANDLE = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
    dbch_handle: HANDLE,
    dbch_hdevnotify: *c_void,
    dbch_eventguid: Guid,
    dbch_nameoffset: i32,
    dbch_data: [1]u8,
};

pub const DEV_BROADCAST_HANDLE32 = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
    dbch_handle: u32,
    dbch_hdevnotify: u32,
    dbch_eventguid: Guid,
    dbch_nameoffset: i32,
    dbch_data: [1]u8,
};

pub const DEV_BROADCAST_HANDLE64 = extern struct {
    dbch_size: u32,
    dbch_devicetype: u32,
    dbch_reserved: u32,
    dbch_handle: u64,
    dbch_hdevnotify: u64,
    dbch_eventguid: Guid,
    dbch_nameoffset: i32,
    dbch_data: [1]u8,
};

pub const _DEV_BROADCAST_USERDEFINED = extern struct {
    dbud_dbh: DEV_BROADCAST_HDR,
    dbud_szName: [1]i8,
};

pub const PWM_CONTROLLER_INFO = extern struct {
    Size: ?*c_void,
    PinCount: u32,
    MinimumPeriod: u64,
    MaximumPeriod: u64,
};

pub const PWM_CONTROLLER_GET_ACTUAL_PERIOD_OUTPUT = extern struct {
    ActualPeriod: u64,
};

pub const PWM_CONTROLLER_SET_DESIRED_PERIOD_INPUT = extern struct {
    DesiredPeriod: u64,
};

pub const PWM_CONTROLLER_SET_DESIRED_PERIOD_OUTPUT = extern struct {
    ActualPeriod: u64,
};

pub const PWM_PIN_GET_ACTIVE_DUTY_CYCLE_PERCENTAGE_OUTPUT = extern struct {
    Percentage: u64,
};

pub const PWM_PIN_SET_ACTIVE_DUTY_CYCLE_PERCENTAGE_INPUT = extern struct {
    Percentage: u64,
};

pub const PWM_POLARITY = extern enum(i32) {
    PWM_ACTIVE_HIGH = 0,
    PWM_ACTIVE_LOW = 1,
};
pub const PWM_ACTIVE_HIGH = PWM_POLARITY.PWM_ACTIVE_HIGH;
pub const PWM_ACTIVE_LOW = PWM_POLARITY.PWM_ACTIVE_LOW;

pub const PWM_PIN_GET_POLARITY_OUTPUT = extern struct {
    Polarity: PWM_POLARITY,
};

pub const PWM_PIN_SET_POLARITY_INPUT = extern struct {
    Polarity: PWM_POLARITY,
};

pub const PWM_PIN_IS_STARTED_OUTPUT = extern struct {
    IsStarted: u8,
};

pub const AtlThunkData_t = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const ENCLAVE_SEALING_IDENTITY_POLICY = extern enum(i32) {
    ENCLAVE_IDENTITY_POLICY_SEAL_INVALID = 0,
    ENCLAVE_IDENTITY_POLICY_SEAL_EXACT_CODE = 1,
    ENCLAVE_IDENTITY_POLICY_SEAL_SAME_PRIMARY_CODE = 2,
    ENCLAVE_IDENTITY_POLICY_SEAL_SAME_IMAGE = 3,
    ENCLAVE_IDENTITY_POLICY_SEAL_SAME_FAMILY = 4,
    ENCLAVE_IDENTITY_POLICY_SEAL_SAME_AUTHOR = 5,
};
pub const ENCLAVE_IDENTITY_POLICY_SEAL_INVALID = ENCLAVE_SEALING_IDENTITY_POLICY.ENCLAVE_IDENTITY_POLICY_SEAL_INVALID;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_EXACT_CODE = ENCLAVE_SEALING_IDENTITY_POLICY.ENCLAVE_IDENTITY_POLICY_SEAL_EXACT_CODE;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_SAME_PRIMARY_CODE = ENCLAVE_SEALING_IDENTITY_POLICY.ENCLAVE_IDENTITY_POLICY_SEAL_SAME_PRIMARY_CODE;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_SAME_IMAGE = ENCLAVE_SEALING_IDENTITY_POLICY.ENCLAVE_IDENTITY_POLICY_SEAL_SAME_IMAGE;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_SAME_FAMILY = ENCLAVE_SEALING_IDENTITY_POLICY.ENCLAVE_IDENTITY_POLICY_SEAL_SAME_FAMILY;
pub const ENCLAVE_IDENTITY_POLICY_SEAL_SAME_AUTHOR = ENCLAVE_SEALING_IDENTITY_POLICY.ENCLAVE_IDENTITY_POLICY_SEAL_SAME_AUTHOR;

pub const ENCLAVE_IDENTITY = extern struct {
    OwnerId: [32]u8,
    UniqueId: [32]u8,
    AuthorId: [32]u8,
    FamilyId: [16]u8,
    ImageId: [16]u8,
    EnclaveSvn: u32,
    SecureKernelSvn: u32,
    PlatformSvn: u32,
    Flags: u32,
    SigningLevel: u32,
    EnclaveType: u32,
};

pub const VBS_ENCLAVE_REPORT_PKG_HEADER = extern struct {
    PackageSize: u32,
    Version: u32,
    SignatureScheme: u32,
    SignedStatementSize: u32,
    SignatureSize: u32,
    Reserved: u32,
};

pub const VBS_ENCLAVE_REPORT = extern struct {
    ReportSize: u32,
    ReportVersion: u32,
    EnclaveData: [64]u8,
    EnclaveIdentity: ENCLAVE_IDENTITY,
};

pub const VBS_ENCLAVE_REPORT_VARDATA_HEADER = extern struct {
    DataType: u32,
    Size: u32,
};

pub const VBS_ENCLAVE_REPORT_MODULE = extern struct {
    Header: VBS_ENCLAVE_REPORT_VARDATA_HEADER,
    UniqueId: [32]u8,
    AuthorId: [32]u8,
    FamilyId: [16]u8,
    ImageId: [16]u8,
    Svn: u32,
    ModuleName: [1]u16,
};

pub const ENCLAVE_INFORMATION = extern struct {
    EnclaveType: u32,
    Reserved: u32,
    BaseAddress: *c_void,
    Size: ?*c_void,
    Identity: ENCLAVE_IDENTITY,
};

pub const VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32 = extern struct {
    ThreadContext: [4]u32,
    EntryPoint: u32,
    StackPointer: u32,
    ExceptionEntryPoint: u32,
    ExceptionStack: u32,
    ExceptionActive: u32,
};

pub const VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR64 = extern struct {
    ThreadContext: [4]u64,
    EntryPoint: u64,
    StackPointer: u64,
    ExceptionEntryPoint: u64,
    ExceptionStack: u64,
    ExceptionActive: u32,
};

pub const VBS_BASIC_ENCLAVE_EXCEPTION_AMD64 = extern struct {
    ExceptionCode: u32,
    NumberParameters: u32,
    ExceptionInformation: [3]?*c_void,
    ExceptionRAX: ?*c_void,
    ExceptionRCX: ?*c_void,
    ExceptionRIP: ?*c_void,
    ExceptionRFLAGS: ?*c_void,
    ExceptionRSP: ?*c_void,
};

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE = fn(
    ReturnValue: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION = fn(
    ExceptionRecord: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD = fn(
    ThreadDescriptor: *VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD = fn(
    ThreadDescriptor: *VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES = fn(
    EnclaveAddress: *c_void,
    NumberOfBytes: ?*c_void,
    SourceAddress: ?*c_void,
    PageProtection: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES = fn(
    EnclaveAddress: *c_void,
    NumberOfBytes: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES = fn(
    EnclaveAddress: *c_void,
    NumberOfytes: ?*c_void,
    PageProtection: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD = fn(
    ThreadDescriptor: *VBS_BASIC_ENCLAVE_THREAD_DESCRIPTOR32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION = fn(
    EnclaveInfo: *ENCLAVE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const ENCLAVE_VBS_BASIC_KEY_REQUEST = extern struct {
    RequestSize: u32,
    Flags: u32,
    EnclaveSVN: u32,
    SystemKeyID: u32,
    CurrentSystemKeyID: u32,
};

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY = fn(
    KeyRequest: *ENCLAVE_VBS_BASIC_KEY_REQUEST,
    RequestedKeySize: u32,
    ReturnedKey: [*:0]u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT = fn(
    EnclaveData: ?*const u8,
    Report: ?[*]u8,
    BufferSize: u32,
    OutputSize: *u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT = fn(
    Report: [*]const u8,
    ReportSize: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA = fn(
    Buffer: [*:0]u8,
    NumberOfBytes: u32,
    Generation: *u64,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const VBS_BASIC_ENCLAVE_SYSCALL_PAGE = extern struct {
    ReturnFromEnclave: *VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE,
    ReturnFromException: *VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION,
    TerminateThread: *VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD,
    InterruptThread: *VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD,
    CommitPages: *VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES,
    DecommitPages: *VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES,
    ProtectPages: *VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES,
    CreateThread: *VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD,
    GetEnclaveInformation: *VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION,
    GenerateKey: *VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY,
    GenerateReport: *VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT,
    VerifyReport: *VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT,
    GenerateRandomData: *VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA,
};

pub const EFFECTIVE_POWER_MODE = extern enum(i32) {
    EffectivePowerModeBatterySaver = 0,
    EffectivePowerModeBetterBattery = 1,
    EffectivePowerModeBalanced = 2,
    EffectivePowerModeHighPerformance = 3,
    EffectivePowerModeMaxPerformance = 4,
    EffectivePowerModeGameMode = 5,
    EffectivePowerModeMixedReality = 6,
};
pub const EffectivePowerModeBatterySaver = EFFECTIVE_POWER_MODE.EffectivePowerModeBatterySaver;
pub const EffectivePowerModeBetterBattery = EFFECTIVE_POWER_MODE.EffectivePowerModeBetterBattery;
pub const EffectivePowerModeBalanced = EFFECTIVE_POWER_MODE.EffectivePowerModeBalanced;
pub const EffectivePowerModeHighPerformance = EFFECTIVE_POWER_MODE.EffectivePowerModeHighPerformance;
pub const EffectivePowerModeMaxPerformance = EFFECTIVE_POWER_MODE.EffectivePowerModeMaxPerformance;
pub const EffectivePowerModeGameMode = EFFECTIVE_POWER_MODE.EffectivePowerModeGameMode;
pub const EffectivePowerModeMixedReality = EFFECTIVE_POWER_MODE.EffectivePowerModeMixedReality;

pub const EFFECTIVE_POWER_MODE_CALLBACK = fn(
    Mode: EFFECTIVE_POWER_MODE,
    Context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const GLOBAL_MACHINE_POWER_POLICY = extern struct {
    Revision: u32,
    LidOpenWakeAc: SYSTEM_POWER_STATE,
    LidOpenWakeDc: SYSTEM_POWER_STATE,
    BroadcastCapacityResolution: u32,
};

pub const GLOBAL_USER_POWER_POLICY = extern struct {
    Revision: u32,
    PowerButtonAc: POWER_ACTION_POLICY,
    PowerButtonDc: POWER_ACTION_POLICY,
    SleepButtonAc: POWER_ACTION_POLICY,
    SleepButtonDc: POWER_ACTION_POLICY,
    LidCloseAc: POWER_ACTION_POLICY,
    LidCloseDc: POWER_ACTION_POLICY,
    DischargePolicy: [4]SYSTEM_POWER_LEVEL,
    GlobalFlags: u32,
};

pub const GLOBAL_POWER_POLICY = extern struct {
    user: GLOBAL_USER_POWER_POLICY,
    mach: GLOBAL_MACHINE_POWER_POLICY,
};

pub const MACHINE_POWER_POLICY = extern struct {
    Revision: u32,
    MinSleepAc: SYSTEM_POWER_STATE,
    MinSleepDc: SYSTEM_POWER_STATE,
    ReducedLatencySleepAc: SYSTEM_POWER_STATE,
    ReducedLatencySleepDc: SYSTEM_POWER_STATE,
    DozeTimeoutAc: u32,
    DozeTimeoutDc: u32,
    DozeS4TimeoutAc: u32,
    DozeS4TimeoutDc: u32,
    MinThrottleAc: u8,
    MinThrottleDc: u8,
    pad1: [2]u8,
    OverThrottledAc: POWER_ACTION_POLICY,
    OverThrottledDc: POWER_ACTION_POLICY,
};

pub const MACHINE_PROCESSOR_POWER_POLICY = extern struct {
    Revision: u32,
    ProcessorPolicyAc: PROCESSOR_POWER_POLICY,
    ProcessorPolicyDc: PROCESSOR_POWER_POLICY,
};

pub const USER_POWER_POLICY = extern struct {
    Revision: u32,
    IdleAc: POWER_ACTION_POLICY,
    IdleDc: POWER_ACTION_POLICY,
    IdleTimeoutAc: u32,
    IdleTimeoutDc: u32,
    IdleSensitivityAc: u8,
    IdleSensitivityDc: u8,
    ThrottlePolicyAc: u8,
    ThrottlePolicyDc: u8,
    MaxSleepAc: SYSTEM_POWER_STATE,
    MaxSleepDc: SYSTEM_POWER_STATE,
    Reserved: [2]u32,
    VideoTimeoutAc: u32,
    VideoTimeoutDc: u32,
    SpindownTimeoutAc: u32,
    SpindownTimeoutDc: u32,
    OptimizeForPowerAc: u8,
    OptimizeForPowerDc: u8,
    FanThrottleToleranceAc: u8,
    FanThrottleToleranceDc: u8,
    ForcedThrottleAc: u8,
    ForcedThrottleDc: u8,
};

pub const POWER_POLICY = extern struct {
    user: USER_POWER_POLICY,
    mach: MACHINE_POWER_POLICY,
};

pub const PWRSCHEMESENUMPROC_V1 = fn(
    Index: u32,
    NameSize: u32,
    Name: [*]i8,
    DescriptionSize: u32,
    Description: [*]i8,
    Policy: *POWER_POLICY,
    Context: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const PWRSCHEMESENUMPROC_V2 = fn(
    Index: u32,
    NameSize: u32,
    Name: [*:0]u16,
    DescriptionSize: u32,
    Description: [*:0]u16,
    Policy: *POWER_POLICY,
    Context: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u8;

pub const PWRSCHEMESENUMPROC = fn(
) callconv(@import("std").os.windows.WINAPI) u8;

pub const POWER_DATA_ACCESSOR = extern enum(i32) {
    ACCESS_AC_POWER_SETTING_INDEX = 0,
    ACCESS_DC_POWER_SETTING_INDEX = 1,
    ACCESS_FRIENDLY_NAME = 2,
    ACCESS_DESCRIPTION = 3,
    ACCESS_POSSIBLE_POWER_SETTING = 4,
    ACCESS_POSSIBLE_POWER_SETTING_FRIENDLY_NAME = 5,
    ACCESS_POSSIBLE_POWER_SETTING_DESCRIPTION = 6,
    ACCESS_DEFAULT_AC_POWER_SETTING = 7,
    ACCESS_DEFAULT_DC_POWER_SETTING = 8,
    ACCESS_POSSIBLE_VALUE_MIN = 9,
    ACCESS_POSSIBLE_VALUE_MAX = 10,
    ACCESS_POSSIBLE_VALUE_INCREMENT = 11,
    ACCESS_POSSIBLE_VALUE_UNITS = 12,
    ACCESS_ICON_RESOURCE = 13,
    ACCESS_DEFAULT_SECURITY_DESCRIPTOR = 14,
    ACCESS_ATTRIBUTES = 15,
    ACCESS_SCHEME = 16,
    ACCESS_SUBGROUP = 17,
    ACCESS_INDIVIDUAL_SETTING = 18,
    ACCESS_ACTIVE_SCHEME = 19,
    ACCESS_CREATE_SCHEME = 20,
    ACCESS_AC_POWER_SETTING_MAX = 21,
    ACCESS_DC_POWER_SETTING_MAX = 22,
    ACCESS_AC_POWER_SETTING_MIN = 23,
    ACCESS_DC_POWER_SETTING_MIN = 24,
    ACCESS_PROFILE = 25,
    ACCESS_OVERLAY_SCHEME = 26,
    ACCESS_ACTIVE_OVERLAY_SCHEME = 27,
};
pub const ACCESS_AC_POWER_SETTING_INDEX = POWER_DATA_ACCESSOR.ACCESS_AC_POWER_SETTING_INDEX;
pub const ACCESS_DC_POWER_SETTING_INDEX = POWER_DATA_ACCESSOR.ACCESS_DC_POWER_SETTING_INDEX;
pub const ACCESS_FRIENDLY_NAME = POWER_DATA_ACCESSOR.ACCESS_FRIENDLY_NAME;
pub const ACCESS_DESCRIPTION = POWER_DATA_ACCESSOR.ACCESS_DESCRIPTION;
pub const ACCESS_POSSIBLE_POWER_SETTING = POWER_DATA_ACCESSOR.ACCESS_POSSIBLE_POWER_SETTING;
pub const ACCESS_POSSIBLE_POWER_SETTING_FRIENDLY_NAME = POWER_DATA_ACCESSOR.ACCESS_POSSIBLE_POWER_SETTING_FRIENDLY_NAME;
pub const ACCESS_POSSIBLE_POWER_SETTING_DESCRIPTION = POWER_DATA_ACCESSOR.ACCESS_POSSIBLE_POWER_SETTING_DESCRIPTION;
pub const ACCESS_DEFAULT_AC_POWER_SETTING = POWER_DATA_ACCESSOR.ACCESS_DEFAULT_AC_POWER_SETTING;
pub const ACCESS_DEFAULT_DC_POWER_SETTING = POWER_DATA_ACCESSOR.ACCESS_DEFAULT_DC_POWER_SETTING;
pub const ACCESS_POSSIBLE_VALUE_MIN = POWER_DATA_ACCESSOR.ACCESS_POSSIBLE_VALUE_MIN;
pub const ACCESS_POSSIBLE_VALUE_MAX = POWER_DATA_ACCESSOR.ACCESS_POSSIBLE_VALUE_MAX;
pub const ACCESS_POSSIBLE_VALUE_INCREMENT = POWER_DATA_ACCESSOR.ACCESS_POSSIBLE_VALUE_INCREMENT;
pub const ACCESS_POSSIBLE_VALUE_UNITS = POWER_DATA_ACCESSOR.ACCESS_POSSIBLE_VALUE_UNITS;
pub const ACCESS_ICON_RESOURCE = POWER_DATA_ACCESSOR.ACCESS_ICON_RESOURCE;
pub const ACCESS_DEFAULT_SECURITY_DESCRIPTOR = POWER_DATA_ACCESSOR.ACCESS_DEFAULT_SECURITY_DESCRIPTOR;
pub const ACCESS_ATTRIBUTES = POWER_DATA_ACCESSOR.ACCESS_ATTRIBUTES;
pub const ACCESS_SCHEME = POWER_DATA_ACCESSOR.ACCESS_SCHEME;
pub const ACCESS_SUBGROUP = POWER_DATA_ACCESSOR.ACCESS_SUBGROUP;
pub const ACCESS_INDIVIDUAL_SETTING = POWER_DATA_ACCESSOR.ACCESS_INDIVIDUAL_SETTING;
pub const ACCESS_ACTIVE_SCHEME = POWER_DATA_ACCESSOR.ACCESS_ACTIVE_SCHEME;
pub const ACCESS_CREATE_SCHEME = POWER_DATA_ACCESSOR.ACCESS_CREATE_SCHEME;
pub const ACCESS_AC_POWER_SETTING_MAX = POWER_DATA_ACCESSOR.ACCESS_AC_POWER_SETTING_MAX;
pub const ACCESS_DC_POWER_SETTING_MAX = POWER_DATA_ACCESSOR.ACCESS_DC_POWER_SETTING_MAX;
pub const ACCESS_AC_POWER_SETTING_MIN = POWER_DATA_ACCESSOR.ACCESS_AC_POWER_SETTING_MIN;
pub const ACCESS_DC_POWER_SETTING_MIN = POWER_DATA_ACCESSOR.ACCESS_DC_POWER_SETTING_MIN;
pub const ACCESS_PROFILE = POWER_DATA_ACCESSOR.ACCESS_PROFILE;
pub const ACCESS_OVERLAY_SCHEME = POWER_DATA_ACCESSOR.ACCESS_OVERLAY_SCHEME;
pub const ACCESS_ACTIVE_OVERLAY_SCHEME = POWER_DATA_ACCESSOR.ACCESS_ACTIVE_OVERLAY_SCHEME;

pub const DEVICE_NOTIFY_CALLBACK_ROUTINE = fn(
    Context: ?*c_void,
    Type: u32,
    Setting: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PDEVICE_NOTIFY_CALLBACK_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DEVICE_NOTIFY_SUBSCRIBE_PARAMETERS = extern struct {
    Callback: PDEVICE_NOTIFY_CALLBACK_ROUTINE,
    Context: *c_void,
};

pub const THERMAL_EVENT = extern struct {
    Version: u32,
    Size: u32,
    Type: u32,
    Temperature: u32,
    TripPointTemperature: u32,
    Initiator: PWSTR,
};

pub const BATTERY_QUERY_INFORMATION_LEVEL = extern enum(i32) {
    BatteryInformation = 0,
    BatteryGranularityInformation = 1,
    BatteryTemperature = 2,
    BatteryEstimatedTime = 3,
    BatteryDeviceName = 4,
    BatteryManufactureDate = 5,
    BatteryManufactureName = 6,
    BatteryUniqueID = 7,
    BatterySerialNumber = 8,
};
pub const BatteryInformation = BATTERY_QUERY_INFORMATION_LEVEL.BatteryInformation;
pub const BatteryGranularityInformation = BATTERY_QUERY_INFORMATION_LEVEL.BatteryGranularityInformation;
pub const BatteryTemperature = BATTERY_QUERY_INFORMATION_LEVEL.BatteryTemperature;
pub const BatteryEstimatedTime = BATTERY_QUERY_INFORMATION_LEVEL.BatteryEstimatedTime;
pub const BatteryDeviceName = BATTERY_QUERY_INFORMATION_LEVEL.BatteryDeviceName;
pub const BatteryManufactureDate = BATTERY_QUERY_INFORMATION_LEVEL.BatteryManufactureDate;
pub const BatteryManufactureName = BATTERY_QUERY_INFORMATION_LEVEL.BatteryManufactureName;
pub const BatteryUniqueID = BATTERY_QUERY_INFORMATION_LEVEL.BatteryUniqueID;
pub const BatterySerialNumber = BATTERY_QUERY_INFORMATION_LEVEL.BatterySerialNumber;

pub const BATTERY_QUERY_INFORMATION = extern struct {
    BatteryTag: u32,
    InformationLevel: BATTERY_QUERY_INFORMATION_LEVEL,
    AtRate: u32,
};

pub const BATTERY_INFORMATION = extern struct {
    Capabilities: u32,
    Technology: u8,
    Reserved: [3]u8,
    Chemistry: [4]u8,
    DesignedCapacity: u32,
    FullChargedCapacity: u32,
    DefaultAlert1: u32,
    DefaultAlert2: u32,
    CriticalBias: u32,
    CycleCount: u32,
};

pub const BATTERY_CHARGING_SOURCE_TYPE = extern enum(i32) {
    BatteryChargingSourceType_AC = 1,
    BatteryChargingSourceType_USB = 2,
    BatteryChargingSourceType_Wireless = 3,
    BatteryChargingSourceType_Max = 4,
};
pub const BatteryChargingSourceType_AC = BATTERY_CHARGING_SOURCE_TYPE.BatteryChargingSourceType_AC;
pub const BatteryChargingSourceType_USB = BATTERY_CHARGING_SOURCE_TYPE.BatteryChargingSourceType_USB;
pub const BatteryChargingSourceType_Wireless = BATTERY_CHARGING_SOURCE_TYPE.BatteryChargingSourceType_Wireless;
pub const BatteryChargingSourceType_Max = BATTERY_CHARGING_SOURCE_TYPE.BatteryChargingSourceType_Max;

pub const BATTERY_CHARGING_SOURCE = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    MaxCurrent: u32,
};

pub const BATTERY_CHARGING_SOURCE_INFORMATION = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    SourceOnline: u8,
};

pub const USB_CHARGER_PORT = extern enum(i32) {
    UsbChargerPort_Legacy = 0,
    UsbChargerPort_TypeC = 1,
    UsbChargerPort_Max = 2,
};
pub const UsbChargerPort_Legacy = USB_CHARGER_PORT.UsbChargerPort_Legacy;
pub const UsbChargerPort_TypeC = USB_CHARGER_PORT.UsbChargerPort_TypeC;
pub const UsbChargerPort_Max = USB_CHARGER_PORT.UsbChargerPort_Max;

pub const BATTERY_SET_INFORMATION_LEVEL = extern enum(i32) {
    BatteryCriticalBias = 0,
    BatteryCharge = 1,
    BatteryDischarge = 2,
    BatteryChargingSource = 3,
    BatteryChargerId = 4,
    BatteryChargerStatus = 5,
};
pub const BatteryCriticalBias = BATTERY_SET_INFORMATION_LEVEL.BatteryCriticalBias;
pub const BatteryCharge = BATTERY_SET_INFORMATION_LEVEL.BatteryCharge;
pub const BatteryDischarge = BATTERY_SET_INFORMATION_LEVEL.BatteryDischarge;
pub const BatteryChargingSource = BATTERY_SET_INFORMATION_LEVEL.BatteryChargingSource;
pub const BatteryChargerId = BATTERY_SET_INFORMATION_LEVEL.BatteryChargerId;
pub const BatteryChargerStatus = BATTERY_SET_INFORMATION_LEVEL.BatteryChargerStatus;

pub const BATTERY_SET_INFORMATION = extern struct {
    BatteryTag: u32,
    InformationLevel: BATTERY_SET_INFORMATION_LEVEL,
    Buffer: [1]u8,
};

pub const BATTERY_CHARGER_STATUS = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    VaData: [1]u32,
};

pub const BATTERY_USB_CHARGER_STATUS = extern struct {
    Type: BATTERY_CHARGING_SOURCE_TYPE,
    Reserved: u32,
    Flags: u32,
    MaxCurrent: u32,
    Voltage: u32,
    PortType: USB_CHARGER_PORT,
    PortId: u64,
    PowerSourceInformation: *c_void,
    OemCharger: Guid,
};

pub const BATTERY_WAIT_STATUS = extern struct {
    BatteryTag: u32,
    Timeout: u32,
    PowerState: u32,
    LowCapacity: u32,
    HighCapacity: u32,
};

pub const BATTERY_STATUS = extern struct {
    PowerState: u32,
    Capacity: u32,
    Voltage: u32,
    Rate: i32,
};

pub const BATTERY_MANUFACTURE_DATE = extern struct {
    Day: u8,
    Month: u8,
    Year: u16,
};

pub const THERMAL_INFORMATION = extern struct {
    ThermalStamp: u32,
    ThermalConstant1: u32,
    ThermalConstant2: u32,
    Processors: ?*c_void,
    SamplingPeriod: u32,
    CurrentTemperature: u32,
    PassiveTripPoint: u32,
    CriticalTripPoint: u32,
    ActiveTripPointCount: u8,
    ActiveTripPoint: [10]u32,
};

pub const THERMAL_WAIT_READ = extern struct {
    Timeout: u32,
    LowTemperature: u32,
    HighTemperature: u32,
};

pub const THERMAL_POLICY = extern struct {
    Version: u32,
    WaitForUpdate: u8,
    Hibernate: u8,
    Critical: u8,
    ThermalStandby: u8,
    ActivationReasons: u32,
    PassiveLimit: u32,
    ActiveLevel: u32,
    OverThrottled: u8,
};

pub const PROCESSOR_OBJECT_INFO = extern struct {
    PhysicalID: u32,
    PBlkAddress: u32,
    PBlkLength: u8,
};

pub const PROCESSOR_OBJECT_INFO_EX = extern struct {
    PhysicalID: u32,
    PBlkAddress: u32,
    PBlkLength: u8,
    InitialApicId: u32,
};

pub const WAKE_ALARM_INFORMATION = extern struct {
    TimerIdentifier: u32,
    Timeout: u32,
};

pub const ACPI_REAL_TIME = extern struct {
    Year: u16,
    Month: u8,
    Day: u8,
    Hour: u8,
    Minute: u8,
    Second: u8,
    Valid: u8,
    Milliseconds: u16,
    TimeZone: i16,
    DayLight: u8,
    Reserved1: [3]u8,
};

pub const INDIRECT_DISPLAY_INFO = extern struct {
    DisplayAdapterLuid: LUID,
    Flags: u32,
    NumMonitors: u32,
    DisplayAdapterTargetBase: u32,
};

pub const VIDEO_VDM = extern struct {
    ProcessHandle: HANDLE,
};

pub const VIDEO_REGISTER_VDM = extern struct {
    MinimumStateSize: u32,
};

pub const VIDEO_MONITOR_DESCRIPTOR = extern struct {
    DescriptorSize: u32,
    Descriptor: [1]u8,
};

pub const VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE = extern enum(i32) {
    VideoPowerNotifyCallout = 1,
    VideoEnumChildPdoNotifyCallout = 3,
    VideoFindAdapterCallout = 4,
    VideoPnpNotifyCallout = 7,
    VideoDxgkDisplaySwitchCallout = 8,
    VideoDxgkFindAdapterTdrCallout = 10,
    VideoDxgkHardwareProtectionTeardown = 11,
    VideoRepaintDesktop = 12,
    VideoUpdateCursor = 13,
    VideoDisableMultiPlaneOverlay = 14,
    VideoDesktopDuplicationChange = 15,
    VideoBlackScreenDiagnostics = 16,
};
pub const VideoPowerNotifyCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoPowerNotifyCallout;
pub const VideoEnumChildPdoNotifyCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoEnumChildPdoNotifyCallout;
pub const VideoFindAdapterCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoFindAdapterCallout;
pub const VideoPnpNotifyCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoPnpNotifyCallout;
pub const VideoDxgkDisplaySwitchCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoDxgkDisplaySwitchCallout;
pub const VideoDxgkFindAdapterTdrCallout = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoDxgkFindAdapterTdrCallout;
pub const VideoDxgkHardwareProtectionTeardown = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoDxgkHardwareProtectionTeardown;
pub const VideoRepaintDesktop = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoRepaintDesktop;
pub const VideoUpdateCursor = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoUpdateCursor;
pub const VideoDisableMultiPlaneOverlay = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoDisableMultiPlaneOverlay;
pub const VideoDesktopDuplicationChange = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoDesktopDuplicationChange;
pub const VideoBlackScreenDiagnostics = VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE.VideoBlackScreenDiagnostics;

pub const BlackScreenDiagnosticsCalloutParam = extern enum(i32) {
    BlackScreenDiagnosticsData = 1,
    BlackScreenDisplayRecovery = 2,
};
pub const BlackScreenDiagnosticsData = BlackScreenDiagnosticsCalloutParam.BlackScreenDiagnosticsData;
pub const BlackScreenDisplayRecovery = BlackScreenDiagnosticsCalloutParam.BlackScreenDisplayRecovery;

pub const DXGK_WIN32K_PARAM_DATA = extern struct {
    PathsArray: *c_void,
    ModesArray: *c_void,
    NumPathArrayElements: u32,
    NumModeArrayElements: u32,
    SDCFlags: u32,
};

pub const VIDEO_WIN32K_CALLBACKS_PARAMS = extern struct {
    CalloutType: VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE,
    PhysDisp: *c_void,
    Param: ?*c_void,
    Status: i32,
    LockUserSession: u8,
    IsPostDevice: u8,
    SurpriseRemoval: u8,
    WaitForQueueReady: u8,
};

pub const PVIDEO_WIN32K_CALLOUT = fn(
    Params: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const VIDEO_WIN32K_CALLBACKS = extern struct {
    PhysDisp: *c_void,
    Callout: PVIDEO_WIN32K_CALLOUT,
    bACPI: u32,
    pPhysDeviceObject: HANDLE,
    DualviewFlags: u32,
};

pub const VIDEO_DEVICE_SESSION_STATUS = extern struct {
    bEnable: u32,
    bSuccess: u32,
};

pub const VIDEO_HARDWARE_STATE_HEADER = extern struct {
    Length: u32,
    PortValue: [48]u8,
    AttribIndexDataState: u32,
    BasicSequencerOffset: u32,
    BasicCrtContOffset: u32,
    BasicGraphContOffset: u32,
    BasicAttribContOffset: u32,
    BasicDacOffset: u32,
    BasicLatchesOffset: u32,
    ExtendedSequencerOffset: u32,
    ExtendedCrtContOffset: u32,
    ExtendedGraphContOffset: u32,
    ExtendedAttribContOffset: u32,
    ExtendedDacOffset: u32,
    ExtendedValidatorStateOffset: u32,
    ExtendedMiscDataOffset: u32,
    PlaneLength: u32,
    Plane1Offset: u32,
    Plane2Offset: u32,
    Plane3Offset: u32,
    Plane4Offset: u32,
    VGAStateFlags: u32,
    DIBOffset: u32,
    DIBBitsPerPixel: u32,
    DIBXResolution: u32,
    DIBYResolution: u32,
    DIBXlatOffset: u32,
    DIBXlatLength: u32,
    VesaInfoOffset: u32,
    FrameBufferData: *c_void,
};

pub const VIDEO_HARDWARE_STATE = extern struct {
    StateHeader: *VIDEO_HARDWARE_STATE_HEADER,
    StateLength: u32,
};

pub const VIDEO_NUM_MODES = extern struct {
    NumModes: u32,
    ModeInformationLength: u32,
};

pub const VIDEO_MODE = extern struct {
    RequestedMode: u32,
};

pub const VIDEO_MODE_INFORMATION = extern struct {
    Length: u32,
    ModeIndex: u32,
    VisScreenWidth: u32,
    VisScreenHeight: u32,
    ScreenStride: u32,
    NumberOfPlanes: u32,
    BitsPerPlane: u32,
    Frequency: u32,
    XMillimeter: u32,
    YMillimeter: u32,
    NumberRedBits: u32,
    NumberGreenBits: u32,
    NumberBlueBits: u32,
    RedMask: u32,
    GreenMask: u32,
    BlueMask: u32,
    AttributeFlags: u32,
    VideoMemoryBitmapWidth: u32,
    VideoMemoryBitmapHeight: u32,
    DriverSpecificAttributeFlags: u32,
};

pub const VIDEO_LOAD_FONT_INFORMATION = extern struct {
    WidthInPixels: u16,
    HeightInPixels: u16,
    FontSize: u32,
    Font: [1]u8,
};

pub const VIDEO_PALETTE_DATA = extern struct {
    NumEntries: u16,
    FirstEntry: u16,
    Colors: [1]u16,
};

pub const VIDEO_CLUTDATA = extern struct {
    Red: u8,
    Green: u8,
    Blue: u8,
    Unused: u8,
};

pub const VIDEO_CLUT = extern struct {
    NumEntries: u16,
    FirstEntry: u16,
    LookupTable: [1]VIDEO_CLUT._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const VIDEO_CURSOR_POSITION = extern struct {
    Column: i16,
    Row: i16,
};

pub const VIDEO_CURSOR_ATTRIBUTES = extern struct {
    Width: u16,
    Height: u16,
    Column: i16,
    Row: i16,
    Rate: u8,
    Enable: u8,
};

pub const VIDEO_POINTER_POSITION = extern struct {
    Column: i16,
    Row: i16,
};

pub const VIDEO_POINTER_ATTRIBUTES = extern struct {
    Flags: u32,
    Width: u32,
    Height: u32,
    WidthInBytes: u32,
    Enable: u32,
    Column: i16,
    Row: i16,
    Pixels: [1]u8,
};

pub const VIDEO_POINTER_CAPABILITIES = extern struct {
    Flags: u32,
    MaxWidth: u32,
    MaxHeight: u32,
    HWPtrBitmapStart: u32,
    HWPtrBitmapEnd: u32,
};

pub const VIDEO_BANK_SELECT = extern struct {
    Length: u32,
    Size: u32,
    BankingFlags: u32,
    BankingType: u32,
    PlanarHCBankingType: u32,
    BitmapWidthInBytes: u32,
    BitmapSize: u32,
    Granularity: u32,
    PlanarHCGranularity: u32,
    CodeOffset: u32,
    PlanarHCBankCodeOffset: u32,
    PlanarHCEnableCodeOffset: u32,
    PlanarHCDisableCodeOffset: u32,
};

pub const VIDEO_BANK_TYPE = extern enum(i32) {
    VideoNotBanked = 0,
    VideoBanked1RW = 1,
    VideoBanked1R1W = 2,
    VideoBanked2RW = 3,
    NumVideoBankTypes = 4,
};
pub const VideoNotBanked = VIDEO_BANK_TYPE.VideoNotBanked;
pub const VideoBanked1RW = VIDEO_BANK_TYPE.VideoBanked1RW;
pub const VideoBanked1R1W = VIDEO_BANK_TYPE.VideoBanked1R1W;
pub const VideoBanked2RW = VIDEO_BANK_TYPE.VideoBanked2RW;
pub const NumVideoBankTypes = VIDEO_BANK_TYPE.NumVideoBankTypes;

pub const VIDEO_MEMORY = extern struct {
    RequestedVirtualAddress: *c_void,
};

pub const VIDEO_SHARE_MEMORY = extern struct {
    ProcessHandle: HANDLE,
    ViewOffset: u32,
    ViewSize: u32,
    RequestedVirtualAddress: *c_void,
};

pub const VIDEO_SHARE_MEMORY_INFORMATION = extern struct {
    SharedViewOffset: u32,
    SharedViewSize: u32,
    VirtualAddress: *c_void,
};

pub const VIDEO_MEMORY_INFORMATION = extern struct {
    VideoRamBase: *c_void,
    VideoRamLength: u32,
    FrameBufferBase: *c_void,
    FrameBufferLength: u32,
};

pub const VIDEO_PUBLIC_ACCESS_RANGES = extern struct {
    InIoSpace: u32,
    MappedInIoSpace: u32,
    VirtualAddress: *c_void,
};

pub const VIDEO_COLOR_CAPABILITIES = extern struct {
    Length: u32,
    AttributeFlags: u32,
    RedPhosphoreDecay: i32,
    GreenPhosphoreDecay: i32,
    BluePhosphoreDecay: i32,
    WhiteChromaticity_x: i32,
    WhiteChromaticity_y: i32,
    WhiteChromaticity_Y: i32,
    RedChromaticity_x: i32,
    RedChromaticity_y: i32,
    GreenChromaticity_x: i32,
    GreenChromaticity_y: i32,
    BlueChromaticity_x: i32,
    BlueChromaticity_y: i32,
    WhiteGamma: i32,
    RedGamma: i32,
    GreenGamma: i32,
    BlueGamma: i32,
};

pub const VIDEO_POWER_STATE = extern enum(i32) {
    VideoPowerUnspecified = 0,
    VideoPowerOn = 1,
    VideoPowerStandBy = 2,
    VideoPowerSuspend = 3,
    VideoPowerOff = 4,
    VideoPowerHibernate = 5,
    VideoPowerShutdown = 6,
    VideoPowerMaximum = 7,
};
pub const VideoPowerUnspecified = VIDEO_POWER_STATE.VideoPowerUnspecified;
pub const VideoPowerOn = VIDEO_POWER_STATE.VideoPowerOn;
pub const VideoPowerStandBy = VIDEO_POWER_STATE.VideoPowerStandBy;
pub const VideoPowerSuspend = VIDEO_POWER_STATE.VideoPowerSuspend;
pub const VideoPowerOff = VIDEO_POWER_STATE.VideoPowerOff;
pub const VideoPowerHibernate = VIDEO_POWER_STATE.VideoPowerHibernate;
pub const VideoPowerShutdown = VIDEO_POWER_STATE.VideoPowerShutdown;
pub const VideoPowerMaximum = VIDEO_POWER_STATE.VideoPowerMaximum;

pub const VIDEO_POWER_MANAGEMENT = extern struct {
    Length: u32,
    DPMSVersion: u32,
    PowerState: u32,
};

pub const VIDEO_COLOR_LUT_DATA = extern struct {
    Length: u32,
    LutDataFormat: u32,
    LutData: [1]u8,
};

pub const VIDEO_LUT_RGB256WORDS = extern struct {
    Red: [256]u16,
    Green: [256]u16,
    Blue: [256]u16,
};

pub const BANK_POSITION = extern struct {
    ReadBankPosition: u32,
    WriteBankPosition: u32,
};

pub const DISPLAY_BRIGHTNESS = extern struct {
    ucDisplayPolicy: u8,
    ucACBrightness: u8,
    ucDCBrightness: u8,
};

pub const VIDEO_BRIGHTNESS_POLICY = extern struct {
    DefaultToBiosPolicy: u8,
    LevelCount: u8,
    Level: [1]VIDEO_BRIGHTNESS_POLICY._Anonymous_e__Struct,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const FSCNTL_SCREEN_INFO = extern struct {
    Position: COORD,
    ScreenSize: COORD,
    nNumberOfChars: u32,
};

pub const FONT_IMAGE_INFO = extern struct {
    FontSize: COORD,
    ImageBits: *u8,
};

pub const CHAR_IMAGE_INFO = extern struct {
    CharInfo: CHAR_INFO,
    FontImageInfo: FONT_IMAGE_INFO,
};

pub const VGA_CHAR = extern struct {
    Char: i8,
    Attributes: i8,
};

pub const FSVIDEO_COPY_FRAME_BUFFER = extern struct {
    SrcScreen: FSCNTL_SCREEN_INFO,
    DestScreen: FSCNTL_SCREEN_INFO,
};

pub const FSVIDEO_WRITE_TO_FRAME_BUFFER = extern struct {
    SrcBuffer: *CHAR_IMAGE_INFO,
    DestScreen: FSCNTL_SCREEN_INFO,
};

pub const FSVIDEO_REVERSE_MOUSE_POINTER = extern struct {
    Screen: FSCNTL_SCREEN_INFO,
    dwType: u32,
};

pub const FSVIDEO_MODE_INFORMATION = extern struct {
    VideoMode: VIDEO_MODE_INFORMATION,
    VideoMemory: VIDEO_MEMORY_INFORMATION,
};

pub const FSVIDEO_SCREEN_INFORMATION = extern struct {
    ScreenSize: COORD,
    FontSize: COORD,
};

pub const FSVIDEO_CURSOR_POSITION = extern struct {
    Coord: VIDEO_CURSOR_POSITION,
    dwType: u32,
};

pub const ENG_EVENT = extern struct {
    pKEvent: *c_void,
    fFlags: u32,
};

pub const VIDEO_PERFORMANCE_COUNTER = extern struct {
    NbOfAllocationEvicted: [10]u64,
    NbOfAllocationMarked: [10]u64,
    NbOfAllocationRestored: [10]u64,
    KBytesEvicted: [10]u64,
    KBytesMarked: [10]u64,
    KBytesRestored: [10]u64,
    NbProcessCommited: u64,
    NbAllocationCommited: u64,
    NbAllocationMarked: u64,
    KBytesAllocated: u64,
    KBytesAvailable: u64,
    KBytesCurMarked: u64,
    Reference: u64,
    Unreference: u64,
    TrueReference: u64,
    NbOfPageIn: u64,
    KBytesPageIn: u64,
    NbOfPageOut: u64,
    KBytesPageOut: u64,
    NbOfRotateOut: u64,
    KBytesRotateOut: u64,
};

pub const VIDEO_QUERY_PERFORMANCE_COUNTER = extern struct {
    BufferSize: u32,
    Buffer: *VIDEO_PERFORMANCE_COUNTER,
};

pub const BRIGHTNESS_INTERFACE_VERSION = extern enum(i32) {
    _1 = 1,
    _2 = 2,
    _3 = 3,
};
pub const BRIGHTNESS_INTERFACE_VERSION_1 = BRIGHTNESS_INTERFACE_VERSION._1;
pub const BRIGHTNESS_INTERFACE_VERSION_2 = BRIGHTNESS_INTERFACE_VERSION._2;
pub const BRIGHTNESS_INTERFACE_VERSION_3 = BRIGHTNESS_INTERFACE_VERSION._3;

pub const PANEL_QUERY_BRIGHTNESS_CAPS = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: PANEL_QUERY_BRIGHTNESS_CAPS._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const BRIGHTNESS_LEVEL = extern struct {
    Count: u8,
    Level: [103]u8,
};

pub const BRIGHTNESS_NIT_RANGE = extern struct {
    MinLevelInMillinit: u32,
    MaxLevelInMillinit: u32,
    StepSizeInMillinit: u32,
};

pub const BRIGHTNESS_NIT_RANGES = extern struct {
    NormalRangeCount: u32,
    RangeCount: u32,
    PreferredMaximumBrightness: u32,
    SupportedRanges: [16]BRIGHTNESS_NIT_RANGE,
};

pub const PANEL_QUERY_BRIGHTNESS_RANGES = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: PANEL_QUERY_BRIGHTNESS_RANGES._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PANEL_GET_BRIGHTNESS = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: PANEL_GET_BRIGHTNESS._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CHROMATICITY_COORDINATE = extern struct {
    x: f32,
    y: f32,
};

pub const PANEL_BRIGHTNESS_SENSOR_DATA = extern struct {
    Anonymous: PANEL_BRIGHTNESS_SENSOR_DATA._Anonymous_e__Union,
    AlsReading: f32,
    ChromaticityCoordinate: CHROMATICITY_COORDINATE,
    ColorTemperature: f32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PANEL_SET_BRIGHTNESS = extern struct {
    Version: BRIGHTNESS_INTERFACE_VERSION,
    Anonymous: PANEL_SET_BRIGHTNESS._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PANEL_SET_BRIGHTNESS_STATE = extern struct {
    Anonymous: PANEL_SET_BRIGHTNESS_STATE._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const BACKLIGHT_OPTIMIZATION_LEVEL = extern enum(i32) {
    BacklightOptimizationDisable = 0,
    BacklightOptimizationDesktop = 1,
    BacklightOptimizationDynamic = 2,
    BacklightOptimizationDimmed = 3,
    BacklightOptimizationEDR = 4,
};
pub const BacklightOptimizationDisable = BACKLIGHT_OPTIMIZATION_LEVEL.BacklightOptimizationDisable;
pub const BacklightOptimizationDesktop = BACKLIGHT_OPTIMIZATION_LEVEL.BacklightOptimizationDesktop;
pub const BacklightOptimizationDynamic = BACKLIGHT_OPTIMIZATION_LEVEL.BacklightOptimizationDynamic;
pub const BacklightOptimizationDimmed = BACKLIGHT_OPTIMIZATION_LEVEL.BacklightOptimizationDimmed;
pub const BacklightOptimizationEDR = BACKLIGHT_OPTIMIZATION_LEVEL.BacklightOptimizationEDR;

pub const PANEL_SET_BACKLIGHT_OPTIMIZATION = extern struct {
    Level: BACKLIGHT_OPTIMIZATION_LEVEL,
};

pub const BACKLIGHT_REDUCTION_GAMMA_RAMP = extern struct {
    R: [256]u16,
    G: [256]u16,
    B: [256]u16,
};

pub const PANEL_GET_BACKLIGHT_REDUCTION = extern struct {
    BacklightUsersetting: u16,
    BacklightEffective: u16,
    GammaRamp: BACKLIGHT_REDUCTION_GAMMA_RAMP,
};

pub const COLORSPACE_TRANSFORM_DATA_TYPE = extern enum(i32) {
    FIXED_POINT = 0,
    FLOAT = 1,
};
pub const COLORSPACE_TRANSFORM_DATA_TYPE_FIXED_POINT = COLORSPACE_TRANSFORM_DATA_TYPE.FIXED_POINT;
pub const COLORSPACE_TRANSFORM_DATA_TYPE_FLOAT = COLORSPACE_TRANSFORM_DATA_TYPE.FLOAT;

pub const COLORSPACE_TRANSFORM_DATA_CAP = extern struct {
    DataType: COLORSPACE_TRANSFORM_DATA_TYPE,
    Anonymous: COLORSPACE_TRANSFORM_DATA_CAP._Anonymous_e__Union,
    NumericRangeMin: f32,
    NumericRangeMax: f32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const COLORSPACE_TRANSFORM_1DLUT_CAP = extern struct {
    NumberOfLUTEntries: u32,
    DataCap: COLORSPACE_TRANSFORM_DATA_CAP,
};

pub const COLORSPACE_TRANSFORM_MATRIX_CAP = extern struct {
    Anonymous: COLORSPACE_TRANSFORM_MATRIX_CAP._Anonymous_e__Union,
    DataCap: COLORSPACE_TRANSFORM_DATA_CAP,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION = extern enum(i32) {
    COLORSPACE_TRANSFORM_VERSION_DEFAULT = 0,
    COLORSPACE_TRANSFORM_VERSION_1 = 1,
    COLORSPACE_TRANSFORM_VERSION_NOT_SUPPORTED = 0,
};
pub const COLORSPACE_TRANSFORM_VERSION_DEFAULT = COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION.COLORSPACE_TRANSFORM_VERSION_DEFAULT;
pub const COLORSPACE_TRANSFORM_VERSION_1 = COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION.COLORSPACE_TRANSFORM_VERSION_1;
pub const COLORSPACE_TRANSFORM_VERSION_NOT_SUPPORTED = COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION.COLORSPACE_TRANSFORM_VERSION_NOT_SUPPORTED;

pub const COLORSPACE_TRANSFORM_TARGET_CAPS = extern struct {
    Version: COLORSPACE_TRANSFORM_TARGET_CAPS_VERSION,
    LookupTable1DDegammaCap: COLORSPACE_TRANSFORM_1DLUT_CAP,
    ColorMatrix3x3Cap: COLORSPACE_TRANSFORM_MATRIX_CAP,
    LookupTable1DRegammaCap: COLORSPACE_TRANSFORM_1DLUT_CAP,
};

pub const COLORSPACE_TRANSFORM_TYPE = extern enum(i32) {
    UNINITIALIZED = 0,
    DEFAULT = 1,
    RGB256x3x16 = 2,
    DXGI_1 = 3,
    MATRIX_3x4 = 4,
    MATRIX_V2 = 5,
};
pub const COLORSPACE_TRANSFORM_TYPE_UNINITIALIZED = COLORSPACE_TRANSFORM_TYPE.UNINITIALIZED;
pub const COLORSPACE_TRANSFORM_TYPE_DEFAULT = COLORSPACE_TRANSFORM_TYPE.DEFAULT;
pub const COLORSPACE_TRANSFORM_TYPE_RGB256x3x16 = COLORSPACE_TRANSFORM_TYPE.RGB256x3x16;
pub const COLORSPACE_TRANSFORM_TYPE_DXGI_1 = COLORSPACE_TRANSFORM_TYPE.DXGI_1;
pub const COLORSPACE_TRANSFORM_TYPE_MATRIX_3x4 = COLORSPACE_TRANSFORM_TYPE.MATRIX_3x4;
pub const COLORSPACE_TRANSFORM_TYPE_MATRIX_V2 = COLORSPACE_TRANSFORM_TYPE.MATRIX_V2;

pub const GAMMA_RAMP_RGB256x3x16 = extern struct {
    Red: [256]u16,
    Green: [256]u16,
    Blue: [256]u16,
};

pub const GAMMA_RAMP_RGB = extern struct {
    Red: f32,
    Green: f32,
    Blue: f32,
};

pub const GAMMA_RAMP_DXGI_1 = extern struct {
    Scale: GAMMA_RAMP_RGB,
    Offset: GAMMA_RAMP_RGB,
    GammaCurve: [1025]GAMMA_RAMP_RGB,
};

pub const COLORSPACE_TRANSFORM_3x4 = extern struct {
    ColorMatrix3x4: [12]f32,
    ScalarMultiplier: f32,
    LookupTable1D: [4096]GAMMA_RAMP_RGB,
};

pub const OUTPUT_WIRE_COLOR_SPACE_TYPE = extern enum(i32) {
    OUTPUT_WIRE_COLOR_SPACE_G22_P709 = 0,
    OUTPUT_WIRE_COLOR_SPACE_RESERVED = 4,
    OUTPUT_WIRE_COLOR_SPACE_G2084_P2020 = 12,
    OUTPUT_WIRE_COLOR_SPACE_G22_P709_WCG = 30,
    OUTPUT_WIRE_COLOR_SPACE_G22_P2020 = 31,
    OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_HDR10PLUS = 32,
    OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_DVLL = 33,
};
pub const OUTPUT_WIRE_COLOR_SPACE_G22_P709 = OUTPUT_WIRE_COLOR_SPACE_TYPE.OUTPUT_WIRE_COLOR_SPACE_G22_P709;
pub const OUTPUT_WIRE_COLOR_SPACE_RESERVED = OUTPUT_WIRE_COLOR_SPACE_TYPE.OUTPUT_WIRE_COLOR_SPACE_RESERVED;
pub const OUTPUT_WIRE_COLOR_SPACE_G2084_P2020 = OUTPUT_WIRE_COLOR_SPACE_TYPE.OUTPUT_WIRE_COLOR_SPACE_G2084_P2020;
pub const OUTPUT_WIRE_COLOR_SPACE_G22_P709_WCG = OUTPUT_WIRE_COLOR_SPACE_TYPE.OUTPUT_WIRE_COLOR_SPACE_G22_P709_WCG;
pub const OUTPUT_WIRE_COLOR_SPACE_G22_P2020 = OUTPUT_WIRE_COLOR_SPACE_TYPE.OUTPUT_WIRE_COLOR_SPACE_G22_P2020;
pub const OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_HDR10PLUS = OUTPUT_WIRE_COLOR_SPACE_TYPE.OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_HDR10PLUS;
pub const OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_DVLL = OUTPUT_WIRE_COLOR_SPACE_TYPE.OUTPUT_WIRE_COLOR_SPACE_G2084_P2020_DVLL;

pub const OUTPUT_COLOR_ENCODING = extern enum(i32) {
    RGB = 0,
    YCBCR444 = 1,
    YCBCR422 = 2,
    YCBCR420 = 3,
    INTENSITY = 4,
    FORCE_UINT32 = -1,
};
pub const OUTPUT_COLOR_ENCODING_RGB = OUTPUT_COLOR_ENCODING.RGB;
pub const OUTPUT_COLOR_ENCODING_YCBCR444 = OUTPUT_COLOR_ENCODING.YCBCR444;
pub const OUTPUT_COLOR_ENCODING_YCBCR422 = OUTPUT_COLOR_ENCODING.YCBCR422;
pub const OUTPUT_COLOR_ENCODING_YCBCR420 = OUTPUT_COLOR_ENCODING.YCBCR420;
pub const OUTPUT_COLOR_ENCODING_INTENSITY = OUTPUT_COLOR_ENCODING.INTENSITY;
pub const OUTPUT_COLOR_ENCODING_FORCE_UINT32 = OUTPUT_COLOR_ENCODING.FORCE_UINT32;

pub const OUTPUT_WIRE_FORMAT = extern struct {
    ColorEncoding: OUTPUT_COLOR_ENCODING,
    BitsPerPixel: u32,
};

pub const COLORSPACE_TRANSFORM_STAGE_CONTROL = extern enum(i32) {
    ColorSpaceTransformStageControl_No_Change = 0,
    ColorSpaceTransformStageControl_Enable = 1,
    ColorSpaceTransformStageControl_Bypass = 2,
};
pub const ColorSpaceTransformStageControl_No_Change = COLORSPACE_TRANSFORM_STAGE_CONTROL.ColorSpaceTransformStageControl_No_Change;
pub const ColorSpaceTransformStageControl_Enable = COLORSPACE_TRANSFORM_STAGE_CONTROL.ColorSpaceTransformStageControl_Enable;
pub const ColorSpaceTransformStageControl_Bypass = COLORSPACE_TRANSFORM_STAGE_CONTROL.ColorSpaceTransformStageControl_Bypass;

pub const COLORSPACE_TRANSFORM_MATRIX_V2 = extern struct {
    StageControlLookupTable1DDegamma: COLORSPACE_TRANSFORM_STAGE_CONTROL,
    LookupTable1DDegamma: [4096]GAMMA_RAMP_RGB,
    StageControlColorMatrix3x3: COLORSPACE_TRANSFORM_STAGE_CONTROL,
    ColorMatrix3x3: [9]f32,
    StageControlLookupTable1DRegamma: COLORSPACE_TRANSFORM_STAGE_CONTROL,
    LookupTable1DRegamma: [4096]GAMMA_RAMP_RGB,
};

pub const COLORSPACE_TRANSFORM = extern struct {
    Type: COLORSPACE_TRANSFORM_TYPE,
    Data: COLORSPACE_TRANSFORM._Data_e__Union,
    const _Data_e__Union = u32; // TODO: generate this nested type!
};

pub const COLORSPACE_TRANSFORM_SET_INPUT = extern struct {
    OutputWireColorSpaceExpected: OUTPUT_WIRE_COLOR_SPACE_TYPE,
    OutputWireFormatExpected: OUTPUT_WIRE_FORMAT,
    ColorSpaceTransform: COLORSPACE_TRANSFORM,
};

pub const SET_ACTIVE_COLOR_PROFILE_NAME = extern struct {
    ColorProfileName: [1]u16,
};

pub const MIPI_DSI_CAPS = extern struct {
    DSITypeMajor: u8,
    DSITypeMinor: u8,
    SpecVersionMajor: u8,
    SpecVersionMinor: u8,
    SpecVersionPatch: u8,
    TargetMaximumReturnPacketSize: u16,
    ResultCodeFlags: u8,
    ResultCodeStatus: u8,
    Revision: u8,
    Level: u8,
    DeviceClassHi: u8,
    DeviceClassLo: u8,
    ManufacturerHi: u8,
    ManufacturerLo: u8,
    ProductHi: u8,
    ProductLo: u8,
    LengthHi: u8,
    LengthLo: u8,
};

pub const DSI_CONTROL_TRANSMISSION_MODE = extern enum(i32) {
    DCT_DEFAULT = 0,
    DCT_FORCE_LOW_POWER = 1,
    DCT_FORCE_HIGH_PERFORMANCE = 2,
};
pub const DCT_DEFAULT = DSI_CONTROL_TRANSMISSION_MODE.DCT_DEFAULT;
pub const DCT_FORCE_LOW_POWER = DSI_CONTROL_TRANSMISSION_MODE.DCT_FORCE_LOW_POWER;
pub const DCT_FORCE_HIGH_PERFORMANCE = DSI_CONTROL_TRANSMISSION_MODE.DCT_FORCE_HIGH_PERFORMANCE;

pub const MIPI_DSI_PACKET = extern struct {
    Anonymous1: MIPI_DSI_PACKET._Anonymous1_e__Union,
    Anonymous2: MIPI_DSI_PACKET._Anonymous2_e__Union,
    EccFiller: u8,
    Payload: [8]u8,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const MIPI_DSI_TRANSMISSION = extern struct {
    TotalBufferSize: u32,
    PacketCount: u8,
    FailedPacket: u8,
    Anonymous: MIPI_DSI_TRANSMISSION._Anonymous_e__Struct,
    ReadWordCount: u16,
    FinalCommandExtraPayload: u16,
    MipiErrors: u16,
    HostErrors: u16,
    Packets: [1]MIPI_DSI_PACKET,
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const MIPI_DSI_RESET = extern struct {
    Flags: u32,
    Anonymous: MIPI_DSI_RESET._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROCESS_INFORMATION = extern struct {
    hProcess: HANDLE,
    hThread: HANDLE,
    dwProcessId: u32,
    dwThreadId: u32,
};

pub const STARTUPINFOA = extern struct {
    cb: u32,
    lpReserved: PSTR,
    lpDesktop: PSTR,
    lpTitle: PSTR,
    dwX: u32,
    dwY: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwXCountChars: u32,
    dwYCountChars: u32,
    dwFillAttribute: u32,
    dwFlags: u32,
    wShowWindow: u16,
    cbReserved2: u16,
    lpReserved2: *u8,
    hStdInput: HANDLE,
    hStdOutput: HANDLE,
    hStdError: HANDLE,
};

pub const STARTUPINFOW = extern struct {
    cb: u32,
    lpReserved: PWSTR,
    lpDesktop: PWSTR,
    lpTitle: PWSTR,
    dwX: u32,
    dwY: u32,
    dwXSize: u32,
    dwYSize: u32,
    dwXCountChars: u32,
    dwYCountChars: u32,
    dwFillAttribute: u32,
    dwFlags: u32,
    wShowWindow: u16,
    cbReserved2: u16,
    lpReserved2: *u8,
    hStdInput: HANDLE,
    hStdOutput: HANDLE,
    hStdError: HANDLE,
};

pub const MEMORY_PRIORITY_INFORMATION = extern struct {
    MemoryPriority: u32,
};

pub const THREAD_POWER_THROTTLING_STATE = extern struct {
    Version: u32,
    ControlMask: u32,
    StateMask: u32,
};

pub const APP_MEMORY_INFORMATION = extern struct {
    AvailableCommit: u64,
    PrivateCommitUsage: u64,
    PeakPrivateCommitUsage: u64,
    TotalCommitUsage: u64,
};

pub const PROCESS_MEMORY_EXHAUSTION_TYPE = extern enum(i32) {
    PMETypeFailFastOnCommitFailure = 0,
    PMETypeMax = 1,
};
pub const PMETypeFailFastOnCommitFailure = PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeFailFastOnCommitFailure;
pub const PMETypeMax = PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeMax;

pub const PROCESS_MEMORY_EXHAUSTION_INFO = extern struct {
    Version: u16,
    Reserved: u16,
    Type: PROCESS_MEMORY_EXHAUSTION_TYPE,
    Value: ?*c_void,
};

pub const PROCESS_POWER_THROTTLING_STATE = extern struct {
    Version: u32,
    ControlMask: u32,
    StateMask: u32,
};

pub const PROCESS_PROTECTION_LEVEL_INFORMATION = extern struct {
    ProtectionLevel: u32,
};

pub const PROCESS_LEAP_SECOND_INFO = extern struct {
    Flags: u32,
    Reserved: u32,
};

pub const MEMORYSTATUSEX = extern struct {
    dwLength: u32,
    dwMemoryLoad: u32,
    ullTotalPhys: u64,
    ullAvailPhys: u64,
    ullTotalPageFile: u64,
    ullAvailPageFile: u64,
    ullTotalVirtual: u64,
    ullAvailVirtual: u64,
    ullAvailExtendedVirtual: u64,
};

pub const PFIBER_START_ROUTINE = fn(
    lpFiberParameter: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const COMMPROP = extern struct {
    wPacketLength: u16,
    wPacketVersion: u16,
    dwServiceMask: u32,
    dwReserved1: u32,
    dwMaxTxQueue: u32,
    dwMaxRxQueue: u32,
    dwMaxBaud: u32,
    dwProvSubType: u32,
    dwProvCapabilities: u32,
    dwSettableParams: u32,
    dwSettableBaud: u32,
    wSettableData: u16,
    wSettableStopParity: u16,
    dwCurrentTxQueue: u32,
    dwCurrentRxQueue: u32,
    dwProvSpec1: u32,
    dwProvSpec2: u32,
    wcProvChar: [1]u16,
};

pub const COMSTAT = extern struct {
    _bitfield: u32,
    cbInQue: u32,
    cbOutQue: u32,
};

pub const DCB = extern struct {
    DCBlength: u32,
    BaudRate: u32,
    _bitfield: u32,
    wReserved: u16,
    XonLim: u16,
    XoffLim: u16,
    ByteSize: u8,
    Parity: u8,
    StopBits: u8,
    XonChar: i8,
    XoffChar: i8,
    ErrorChar: i8,
    EofChar: i8,
    EvtChar: i8,
    wReserved1: u16,
};

pub const COMMTIMEOUTS = extern struct {
    ReadIntervalTimeout: u32,
    ReadTotalTimeoutMultiplier: u32,
    ReadTotalTimeoutConstant: u32,
    WriteTotalTimeoutMultiplier: u32,
    WriteTotalTimeoutConstant: u32,
};

pub const COMMCONFIG = extern struct {
    dwSize: u32,
    wVersion: u16,
    wReserved: u16,
    dcb: DCB,
    dwProviderSubType: u32,
    dwProviderOffset: u32,
    dwProviderSize: u32,
    wcProviderData: [1]u16,
};

pub const MEMORYSTATUS = extern struct {
    dwLength: u32,
    dwMemoryLoad: u32,
    dwTotalPhys: ?*c_void,
    dwAvailPhys: ?*c_void,
    dwTotalPageFile: ?*c_void,
    dwAvailPageFile: ?*c_void,
    dwTotalVirtual: ?*c_void,
    dwAvailVirtual: ?*c_void,
};

pub const UMS_SCHEDULER_STARTUP_INFO = extern struct {
    UmsVersion: u32,
    CompletionList: *c_void,
    SchedulerProc: PUMS_SCHEDULER_ENTRY_POINT,
    SchedulerParam: *c_void,
};

pub const UMS_SYSTEM_THREAD_INFORMATION = extern struct {
    UmsVersion: u32,
    Anonymous: UMS_SYSTEM_THREAD_INFORMATION._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const WIN32_STREAM_ID = extern struct {
    dwStreamId: u32,
    dwStreamAttributes: u32,
    Size: LARGE_INTEGER,
    dwStreamNameSize: u32,
    cStreamName: [1]u16,
};

pub const STARTUPINFOEXA = extern struct {
    StartupInfo: STARTUPINFOA,
    lpAttributeList: ?*c_void,
};

pub const STARTUPINFOEXW = extern struct {
    StartupInfo: STARTUPINFOW,
    lpAttributeList: ?*c_void,
};

pub const EVENTLOG_FULL_INFORMATION = extern struct {
    dwFull: u32,
};

pub const SYSTEM_POWER_STATUS = extern struct {
    ACLineStatus: u8,
    BatteryFlag: u8,
    BatteryLifePercent: u8,
    SystemStatusFlag: u8,
    BatteryLifeTime: u32,
    BatteryFullLifeTime: u32,
};

pub const PEB_LDR_DATA = extern struct {
    Reserved1: [8]u8,
    Reserved2: [3]*c_void,
    InMemoryOrderModuleList: LIST_ENTRY,
};

pub const RTL_USER_PROCESS_PARAMETERS = extern struct {
    Reserved1: [16]u8,
    Reserved2: [10]*c_void,
    ImagePathName: UNICODE_STRING,
    CommandLine: UNICODE_STRING,
};

pub const PEB = extern struct {
    Reserved1: [2]u8,
    BeingDebugged: u8,
    Reserved2: [1]u8,
    Reserved3: [2]*c_void,
    Ldr: *PEB_LDR_DATA,
    ProcessParameters: *RTL_USER_PROCESS_PARAMETERS,
    Reserved4: [3]*c_void,
    AtlThunkSListPtr: *c_void,
    Reserved5: *c_void,
    Reserved6: u32,
    Reserved7: *c_void,
    Reserved8: u32,
    AtlThunkSListPtr32: u32,
    Reserved9: [45]*c_void,
    Reserved10: [96]u8,
    PostProcessInitRoutine: PPS_POST_PROCESS_INIT_ROUTINE,
    Reserved11: [128]u8,
    Reserved12: [1]*c_void,
    SessionId: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (918)
//--------------------------------------------------------------------------------
pub extern "USER32" fn ExitWindowsEx(
    uFlags: u32,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IsWow64Message(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn RegisterDeviceNotificationA(
    hRecipient: HANDLE,
    NotificationFilter: *c_void,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "USER32" fn RegisterDeviceNotificationW(
    hRecipient: HANDLE,
    NotificationFilter: *c_void,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "USER32" fn UnregisterDeviceNotification(
    Handle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn RegisterPowerSettingNotification(
    hRecipient: HANDLE,
    PowerSettingGuid: *Guid,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "USER32" fn UnregisterPowerSettingNotification(
    Handle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn RegisterSuspendResumeNotification(
    hRecipient: HANDLE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "USER32" fn UnregisterSuspendResumeNotification(
    Handle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn AttachThreadInput(
    idAttach: u32,
    idAttachTo: u32,
    fAttach: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn WaitForInputIdle(
    hProcess: HANDLE,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "USER32" fn MsgWaitForMultipleObjects(
    nCount: u32,
    pHandles: ?[*]const HANDLE,
    fWaitAll: BOOL,
    dwMilliseconds: u32,
    dwWakeMask: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "USER32" fn MsgWaitForMultipleObjectsEx(
    nCount: u32,
    pHandles: ?[*]const HANDLE,
    dwMilliseconds: u32,
    dwWakeMask: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "USER32" fn GetGuiResources(
    hProcess: HANDLE,
    uiFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "USER32" fn LockWorkStation(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn UserHandleGrantAccess(
    hUserHandle: HANDLE,
    hJob: HANDLE,
    bGrant: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn ShutdownBlockReasonCreate(
    hWnd: HWND,
    pwszReason: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn ShutdownBlockReasonQuery(
    hWnd: HWND,
    pwszBuff: ?[*:0]u16,
    pcchBuff: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn ShutdownBlockReasonDestroy(
    hWnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetAutoRotationState(
    pState: *AR_STATE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetDisplayAutoRotationPreferences(
    pOrientation: *ORIENTATION_PREFERENCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn SetDisplayAutoRotationPreferences(
    orientation: ORIENTATION_PREFERENCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IsImmersiveProcess(
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn SetProcessRestrictionExemption(
    fEnableExemption: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn RtlCompareMemory(
    Source1: *const c_void,
    Source2: *const c_void,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "ntdll" fn RtlInitializeSListHead(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlFirstEntrySList(
    ListHead: *const SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SINGLE_LIST_ENTRY;

pub extern "ntdll" fn RtlInterlockedPopEntrySList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SINGLE_LIST_ENTRY;

pub extern "ntdll" fn RtlInterlockedPushEntrySList(
    ListHead: *SLIST_HEADER,
    ListEntry: *SINGLE_LIST_ENTRY,
) callconv(@import("std").os.windows.WINAPI) *SINGLE_LIST_ENTRY;

pub extern "ntdll" fn RtlInterlockedPushListSListEx(
    ListHead: *SLIST_HEADER,
    List: *SINGLE_LIST_ENTRY,
    ListEnd: *SINGLE_LIST_ENTRY,
    Count: u32,
) callconv(@import("std").os.windows.WINAPI) *SINGLE_LIST_ENTRY;

pub extern "ntdll" fn RtlInterlockedFlushSList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SINGLE_LIST_ENTRY;

pub extern "ntdll" fn RtlQueryDepthSList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "ntdll" fn RtlGetReturnAddressHijackTarget(
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "ntdll" fn RtlGetProductInfo(
    OSMajorVersion: u32,
    OSMinorVersion: u32,
    SpMajorVersion: u32,
    SpMinorVersion: u32,
    ReturnedProductType: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ntdll" fn RtlCrc32(
    Buffer: [*]const u8,
    Size: ?*c_void,
    InitialCrc: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlCrc64(
    Buffer: [*]const u8,
    Size: ?*c_void,
    InitialCrc: u64,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "ntdll" fn RtlOsDeploymentState(
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) OS_DEPLOYEMENT_STATE_VALUES;

pub extern "ntdll" fn RtlInitializeCorrelationVector(
    CorrelationVector: *CORRELATION_VECTOR,
    Version: i32,
    Guid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlIncrementCorrelationVector(
    CorrelationVector: *CORRELATION_VECTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlExtendCorrelationVector(
    CorrelationVector: *CORRELATION_VECTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlValidateCorrelationVector(
    Vector: *CORRELATION_VECTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlRaiseCustomSystemEventTrigger(
    TriggerConfig: *CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlIsZeroMemory(
    Buffer: *c_void,
    Length: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ntdll" fn RtlNormalizeSecurityDescriptor(
    SecurityDescriptor: **c_void,
    SecurityDescriptorLength: u32,
    NewSecurityDescriptor: ?*?*c_void,
    NewSecurityDescriptorLength: ?*u32,
    CheckOnly: u8,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "ntdll" fn RtlGetDeviceFamilyInfoEnum(
    pullUAPInfo: ?*u64,
    pulDeviceFamily: ?*u32,
    pulDeviceForm: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ntdll" fn RtlConvertDeviceFamilyInfoToString(
    pulDeviceFamilyBufferSize: *u32,
    pulDeviceFormBufferSize: *u32,
    DeviceFamily: [*:0]u16,
    DeviceForm: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn RtlSwitchedVVI(
    VersionInfo: *OSVERSIONINFOEXW,
    TypeMask: u32,
    ConditionMask: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn FlsAlloc(
    lpCallback: ?PFLS_CALLBACK_FUNCTION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn FlsGetValue(
    dwFlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn FlsSetValue(
    dwFlsIndex: u32,
    lpFlsData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FlsFree(
    dwFlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsThreadAFiber(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitializeSRWLock(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn ReleaseSRWLockExclusive(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn ReleaseSRWLockShared(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn AcquireSRWLockExclusive(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn AcquireSRWLockShared(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn TryAcquireSRWLockExclusive(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "KERNEL32" fn TryAcquireSRWLockShared(
    SRWLock: *RTL_SRWLOCK,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "KERNEL32" fn InitializeCriticalSection(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn LeaveCriticalSection(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn InitializeCriticalSectionAndSpinCount(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
    dwSpinCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitializeCriticalSectionEx(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
    dwSpinCount: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCriticalSectionSpinCount(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
    dwSpinCount: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn TryEnterCriticalSection(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DeleteCriticalSection(
    lpCriticalSection: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn InitOnceInitialize(
    InitOnce: *RTL_RUN_ONCE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn InitOnceExecuteOnce(
    InitOnce: *RTL_RUN_ONCE,
    InitFn: PINIT_ONCE_FN,
    Parameter: ?*c_void,
    Context: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitOnceBeginInitialize(
    lpInitOnce: *RTL_RUN_ONCE,
    dwFlags: u32,
    fPending: *BOOL,
    lpContext: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitOnceComplete(
    lpInitOnce: *RTL_RUN_ONCE,
    dwFlags: u32,
    lpContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitializeConditionVariable(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn WakeConditionVariable(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn WakeAllConditionVariable(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn SleepConditionVariableCS(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
    CriticalSection: *RTL_CRITICAL_SECTION,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SleepConditionVariableSRW(
    ConditionVariable: *RTL_CONDITION_VARIABLE,
    SRWLock: *RTL_SRWLOCK,
    dwMilliseconds: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ResetEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReleaseSemaphore(
    hSemaphore: HANDLE,
    lReleaseCount: i32,
    lpPreviousCount: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReleaseMutex(
    hMutex: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WaitForSingleObject(
    hHandle: HANDLE,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SleepEx(
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn WaitForSingleObjectEx(
    hHandle: HANDLE,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn WaitForMultipleObjectsEx(
    nCount: u32,
    lpHandles: [*]const HANDLE,
    bWaitAll: BOOL,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn CreateMutexA(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    bInitialOwner: BOOL,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateMutexW(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    bInitialOwner: BOOL,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenMutexW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateEventA(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    bInitialState: BOOL,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateEventW(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    bInitialState: BOOL,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenEventA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenEventW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenSemaphoreW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenWaitableTimerW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpTimerName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn SetWaitableTimerEx(
    hTimer: HANDLE,
    lpDueTime: *const LARGE_INTEGER,
    lPeriod: i32,
    pfnCompletionRoutine: ?PTIMERAPCROUTINE,
    lpArgToCompletionRoutine: ?*c_void,
    WakeContext: ?*REASON_CONTEXT,
    TolerableDelay: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetWaitableTimer(
    hTimer: HANDLE,
    lpDueTime: *const LARGE_INTEGER,
    lPeriod: i32,
    pfnCompletionRoutine: ?PTIMERAPCROUTINE,
    lpArgToCompletionRoutine: ?*c_void,
    fResume: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CancelWaitableTimer(
    hTimer: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateMutexExA(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateMutexExW(
    lpMutexAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateEventExA(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateEventExW(
    lpEventAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateSemaphoreExW(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?[*:0]const u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateWaitableTimerExW(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    lpTimerName: ?[*:0]const u16,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn EnterSynchronizationBarrier(
    lpBarrier: *RTL_BARRIER,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitializeSynchronizationBarrier(
    lpBarrier: *RTL_BARRIER,
    lTotalThreads: i32,
    lSpinCount: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DeleteSynchronizationBarrier(
    lpBarrier: *RTL_BARRIER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn Sleep(
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "vertdll" fn WaitOnAddress(
    Address: [*]u8,
    CompareAddress: [*]u8,
    AddressSize: ?*c_void,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "vertdll" fn WakeByAddressSingle(
    Address: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "vertdll" fn WakeByAddressAll(
    Address: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn WaitForMultipleObjects(
    nCount: u32,
    lpHandles: [*]const HANDLE,
    bWaitAll: BOOL,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn CreateSemaphoreW(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateWaitableTimerW(
    lpTimerAttributes: ?*SECURITY_ATTRIBUTES,
    bManualReset: BOOL,
    lpTimerName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn InitializeSListHead(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn InterlockedPopEntrySList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SINGLE_LIST_ENTRY;

pub extern "KERNEL32" fn InterlockedPushEntrySList(
    ListHead: *SLIST_HEADER,
    ListEntry: *SINGLE_LIST_ENTRY,
) callconv(@import("std").os.windows.WINAPI) *SINGLE_LIST_ENTRY;

pub extern "KERNEL32" fn InterlockedPushListSListEx(
    ListHead: *SLIST_HEADER,
    List: *SINGLE_LIST_ENTRY,
    ListEnd: *SINGLE_LIST_ENTRY,
    Count: u32,
) callconv(@import("std").os.windows.WINAPI) *SINGLE_LIST_ENTRY;

pub extern "KERNEL32" fn InterlockedFlushSList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) *SINGLE_LIST_ENTRY;

pub extern "KERNEL32" fn QueryDepthSList(
    ListHead: *SLIST_HEADER,
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "KERNEL32" fn QueueUserWorkItem(
    Function: LPTHREAD_START_ROUTINE,
    Context: ?*c_void,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn UnregisterWaitEx(
    WaitHandle: HANDLE,
    CompletionEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateTimerQueue(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateTimerQueueTimer(
    phNewTimer: *HANDLE,
    TimerQueue: HANDLE,
    Callback: WAITORTIMERCALLBACK,
    Parameter: ?*c_void,
    DueTime: u32,
    Period: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ChangeTimerQueueTimer(
    TimerQueue: HANDLE,
    Timer: HANDLE,
    DueTime: u32,
    Period: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DeleteTimerQueueTimer(
    TimerQueue: HANDLE,
    Timer: HANDLE,
    CompletionEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DeleteTimerQueueEx(
    TimerQueue: HANDLE,
    CompletionEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateThreadpool(
    reserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) PTP_POOL;

pub extern "KERNEL32" fn SetThreadpoolThreadMaximum(
    ptpp: PTP_POOL,
    cthrdMost: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn SetThreadpoolThreadMinimum(
    ptpp: PTP_POOL,
    cthrdMic: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadpoolStackInformation(
    ptpp: PTP_POOL,
    ptpsi: *TP_POOL_STACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryThreadpoolStackInformation(
    ptpp: PTP_POOL,
    ptpsi: *TP_POOL_STACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CloseThreadpool(
    ptpp: PTP_POOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CreateThreadpoolCleanupGroup(
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn CloseThreadpoolCleanupGroupMembers(
    ptpcg: ?*c_void,
    fCancelPendingCallbacks: BOOL,
    pvCleanupContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CloseThreadpoolCleanupGroup(
    ptpcg: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn SetEventWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    evt: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn ReleaseSemaphoreWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    sem: HANDLE,
    crel: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn ReleaseMutexWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    mut: HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn LeaveCriticalSectionWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    pcs: *RTL_CRITICAL_SECTION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn FreeLibraryWhenCallbackReturns(
    pci: *TP_CALLBACK_INSTANCE,
    mod: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CallbackMayRunLong(
    pci: *TP_CALLBACK_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DisassociateCurrentThreadFromCallback(
    pci: *TP_CALLBACK_INSTANCE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn TrySubmitThreadpoolCallback(
    pfns: PTP_SIMPLE_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateThreadpoolWork(
    pfnwk: PTP_WORK_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) *TP_WORK;

pub extern "KERNEL32" fn SubmitThreadpoolWork(
    pwk: *TP_WORK,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn WaitForThreadpoolWorkCallbacks(
    pwk: *TP_WORK,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CloseThreadpoolWork(
    pwk: *TP_WORK,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CreateThreadpoolTimer(
    pfnti: PTP_TIMER_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) *TP_TIMER;

pub extern "KERNEL32" fn SetThreadpoolTimer(
    pti: *TP_TIMER,
    pftDueTime: ?*FILETIME,
    msPeriod: u32,
    msWindowLength: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn IsThreadpoolTimerSet(
    pti: *TP_TIMER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WaitForThreadpoolTimerCallbacks(
    pti: *TP_TIMER,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CloseThreadpoolTimer(
    pti: *TP_TIMER,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CreateThreadpoolWait(
    pfnwa: PTP_WAIT_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) *TP_WAIT;

pub extern "KERNEL32" fn SetThreadpoolWait(
    pwa: *TP_WAIT,
    h: HANDLE,
    pftTimeout: ?*FILETIME,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn WaitForThreadpoolWaitCallbacks(
    pwa: *TP_WAIT,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CloseThreadpoolWait(
    pwa: *TP_WAIT,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CreateThreadpoolIo(
    fl: HANDLE,
    pfnio: PTP_WIN32_IO_CALLBACK,
    pv: ?*c_void,
    pcbe: ?*TP_CALLBACK_ENVIRON_V3,
) callconv(@import("std").os.windows.WINAPI) *TP_IO;

pub extern "KERNEL32" fn StartThreadpoolIo(
    pio: *TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CancelThreadpoolIo(
    pio: *TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn WaitForThreadpoolIoCallbacks(
    pio: *TP_IO,
    fCancelPendingCallbacks: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn CloseThreadpoolIo(
    pio: *TP_IO,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn SetThreadpoolTimerEx(
    pti: *TP_TIMER,
    pftDueTime: ?*FILETIME,
    msPeriod: u32,
    msWindowLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadpoolWaitEx(
    pwa: *TP_WAIT,
    h: HANDLE,
    pftTimeout: ?*FILETIME,
    Reserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsProcessInJob(
    ProcessHandle: HANDLE,
    JobHandle: HANDLE,
    Result: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateJobObjectW(
    lpJobAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn FreeMemoryJobObject(
    Buffer: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn OpenJobObjectW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn AssignProcessToJobObject(
    hJob: HANDLE,
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn TerminateJobObject(
    hJob: HANDLE,
    uExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetInformationJobObject(
    hJob: HANDLE,
    JobObjectInformationClass: JOBOBJECTINFOCLASS,
    lpJobObjectInformation: [*]u8,
    cbJobObjectInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetIoRateControlInformationJobObject(
    hJob: HANDLE,
    IoRateControlInfo: *JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn QueryInformationJobObject(
    hJob: HANDLE,
    JobObjectInformationClass: JOBOBJECTINFOCLASS,
    lpJobObjectInformation: [*]u8,
    cbJobObjectInformationLength: u32,
    lpReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryIoRateControlInformationJobObject(
    hJob: HANDLE,
    VolumeName: ?[*:0]const u16,
    InfoBlocks: **JOBOBJECT_IO_RATE_CONTROL_INFORMATION,
    InfoBlockCount: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn CreatePrivateNamespaceW(
    lpPrivateNamespaceAttributes: ?*SECURITY_ATTRIBUTES,
    lpBoundaryDescriptor: *c_void,
    lpAliasPrefix: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NamespaceHandle;

pub extern "KERNEL32" fn OpenPrivateNamespaceW(
    lpBoundaryDescriptor: *c_void,
    lpAliasPrefix: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) NamespaceHandle;

pub extern "KERNEL32" fn ClosePrivateNamespace(
    Handle: NamespaceHandle,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "KERNEL32" fn CreateBoundaryDescriptorW(
    Name: [*:0]const u16,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BoundaryDescriptorHandle;

pub extern "KERNEL32" fn AddSIDToBoundaryDescriptor(
    BoundaryDescriptor: *HANDLE,
    RequiredSid: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DeleteBoundaryDescriptor(
    BoundaryDescriptor: BoundaryDescriptorHandle,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetNumaHighestNodeNumber(
    HighestNodeNumber: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumaNodeProcessorMaskEx(
    Node: u16,
    ProcessorMask: *GROUP_AFFINITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumaProximityNodeEx(
    ProximityId: u32,
    NodeNumber: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessGroupAffinity(
    hProcess: HANDLE,
    GroupCount: *u16,
    GroupArray: [*:0]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadGroupAffinity(
    hThread: HANDLE,
    GroupAffinity: *GROUP_AFFINITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadGroupAffinity(
    hThread: HANDLE,
    GroupAffinity: *const GROUP_AFFINITY,
    PreviousGroupAffinity: ?*GROUP_AFFINITY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreatePipe(
    hReadPipe: *HANDLE,
    hWritePipe: *HANDLE,
    lpPipeAttributes: ?*SECURITY_ATTRIBUTES,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ConnectNamedPipe(
    hNamedPipe: HANDLE,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DisconnectNamedPipe(
    hNamedPipe: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetNamedPipeHandleState(
    hNamedPipe: HANDLE,
    lpMode: ?*u32,
    lpMaxCollectionCount: ?*u32,
    lpCollectDataTimeout: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn PeekNamedPipe(
    hNamedPipe: HANDLE,
    lpBuffer: ?[*]u8,
    nBufferSize: u32,
    lpBytesRead: ?*u32,
    lpTotalBytesAvail: ?*u32,
    lpBytesLeftThisMessage: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn TransactNamedPipe(
    hNamedPipe: HANDLE,
    lpInBuffer: ?[*]u8,
    nInBufferSize: u32,
    lpOutBuffer: ?[*]u8,
    nOutBufferSize: u32,
    lpBytesRead: *u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateNamedPipeW(
    lpName: [*:0]const u16,
    dwOpenMode: u32,
    dwPipeMode: u32,
    nMaxInstances: u32,
    nOutBufferSize: u32,
    nInBufferSize: u32,
    nDefaultTimeOut: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn WaitNamedPipeW(
    lpNamedPipeName: [*:0]const u16,
    nTimeOut: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeClientComputerNameW(
    Pipe: HANDLE,
    ClientComputerName: [*:0]u16,
    ClientComputerNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeInfo(
    hNamedPipe: HANDLE,
    lpFlags: ?*u32,
    lpOutBufferSize: ?*u32,
    lpInBufferSize: ?*u32,
    lpMaxInstances: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeHandleStateW(
    hNamedPipe: HANDLE,
    lpState: ?*u32,
    lpCurInstances: ?*u32,
    lpMaxCollectionCount: ?*u32,
    lpCollectDataTimeout: ?*u32,
    lpUserName: ?[*:0]u16,
    nMaxUserNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CallNamedPipeW(
    lpNamedPipeName: [*:0]const u16,
    lpInBuffer: ?[*]u8,
    nInBufferSize: u32,
    lpOutBuffer: ?[*]u8,
    nOutBufferSize: u32,
    lpBytesRead: *u32,
    nTimeOut: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapCreate(
    flOptions: u32,
    dwInitialSize: ?*c_void,
    dwMaximumSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HeapHandle;

pub extern "KERNEL32" fn HeapDestroy(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapAlloc(
    hHeap: HeapHandle,
    dwFlags: u32,
    dwBytes: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn HeapReAlloc(
    hHeap: HeapHandle,
    dwFlags: u32,
    lpMem: ?*c_void,
    dwBytes: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn HeapFree(
    hHeap: HANDLE,
    dwFlags: u32,
    lpMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapSize(
    hHeap: HeapHandle,
    dwFlags: u32,
    lpMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GetProcessHeap(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn HeapCompact(
    hHeap: HeapHandle,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn HeapSetInformation(
    HeapHandle: HANDLE,
    HeapInformationClass: HEAP_INFORMATION_CLASS,
    HeapInformation: ?[*]u8,
    HeapInformationLength: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapValidate(
    hHeap: HANDLE,
    dwFlags: u32,
    lpMem: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapSummary(
    hHeap: HANDLE,
    dwFlags: u32,
    lpSummary: *HEAP_SUMMARY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessHeaps(
    NumberOfHeaps: u32,
    ProcessHeaps: [*]HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn HeapLock(
    hHeap: HeapHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapUnlock(
    hHeap: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapWalk(
    hHeap: HANDLE,
    lpEntry: *PROCESS_HEAP_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn HeapQueryInformation(
    HeapHandle: HANDLE,
    HeapInformationClass: HEAP_INFORMATION_CLASS,
    HeapInformation: ?[*]u8,
    HeapInformationLength: ?*c_void,
    ReturnLength: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VirtualAlloc(
    lpAddress: ?*c_void,
    dwSize: ?*c_void,
    flAllocationType: u32,
    flProtect: PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn VirtualProtect(
    lpAddress: *c_void,
    dwSize: ?*c_void,
    flNewProtect: PAGE_TYPE,
    lpflOldProtect: *PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VirtualFree(
    lpAddress: *c_void,
    dwSize: ?*c_void,
    dwFreeType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VirtualQuery(
    lpAddress: ?*const c_void,
    lpBuffer: [*]MEMORY_BASIC_INFORMATION,
    dwLength: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn VirtualAllocEx(
    hProcess: HANDLE,
    lpAddress: ?*c_void,
    dwSize: ?*c_void,
    flAllocationType: u32,
    flProtect: PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn VirtualProtectEx(
    hProcess: HANDLE,
    lpAddress: *c_void,
    dwSize: ?*c_void,
    flNewProtect: PAGE_TYPE,
    lpflOldProtect: *PAGE_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VirtualQueryEx(
    hProcess: HANDLE,
    lpAddress: ?*const c_void,
    lpBuffer: [*]MEMORY_BASIC_INFORMATION,
    dwLength: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn CreateFileMappingW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: PAGE_TYPE,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenFileMappingW(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn MapViewOfFile(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: u32,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn MapViewOfFileEx(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: u32,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: ?*c_void,
    lpBaseAddress: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn VirtualFreeEx(
    hProcess: HANDLE,
    lpAddress: *c_void,
    dwSize: ?*c_void,
    dwFreeType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FlushViewOfFile(
    lpBaseAddress: *const c_void,
    dwNumberOfBytesToFlush: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn UnmapViewOfFile(
    lpBaseAddress: *const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetLargePageMinimum(
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GetProcessWorkingSetSizeEx(
    hProcess: HANDLE,
    lpMinimumWorkingSetSize: *?*c_void,
    lpMaximumWorkingSetSize: *?*c_void,
    Flags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessWorkingSetSizeEx(
    hProcess: HANDLE,
    dwMinimumWorkingSetSize: ?*c_void,
    dwMaximumWorkingSetSize: ?*c_void,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VirtualLock(
    lpAddress: *c_void,
    dwSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VirtualUnlock(
    lpAddress: *c_void,
    dwSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetWriteWatch(
    dwFlags: u32,
    lpBaseAddress: *c_void,
    dwRegionSize: ?*c_void,
    lpAddresses: ?[*]?*c_void,
    lpdwCount: ?*?*c_void,
    lpdwGranularity: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn ResetWriteWatch(
    lpBaseAddress: *c_void,
    dwRegionSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn CreateMemoryResourceNotification(
    NotificationType: MEMORY_RESOURCE_NOTIFICATION_TYPE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn QueryMemoryResourceNotification(
    ResourceNotificationHandle: HANDLE,
    ResourceState: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemFileCacheSize(
    lpMinimumFileCacheSize: *?*c_void,
    lpMaximumFileCacheSize: *?*c_void,
    lpFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetSystemFileCacheSize(
    MinimumFileCacheSize: ?*c_void,
    MaximumFileCacheSize: ?*c_void,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateFileMappingNumaW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: u32,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u16,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn PrefetchVirtualMemory(
    hProcess: HANDLE,
    NumberOfEntries: ?*c_void,
    VirtualAddresses: [*]WIN32_MEMORY_RANGE_ENTRY,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateFileMappingFromApp(
    hFile: HANDLE,
    SecurityAttributes: ?*SECURITY_ATTRIBUTES,
    PageProtection: u32,
    MaximumSize: u64,
    Name: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn MapViewOfFileFromApp(
    hFileMappingObject: HANDLE,
    DesiredAccess: u32,
    FileOffset: u64,
    NumberOfBytesToMap: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn UnmapViewOfFileEx(
    BaseAddress: *c_void,
    UnmapFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn AllocateUserPhysicalPages(
    hProcess: HANDLE,
    NumberOfPages: *u32,
    PageArray: [*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FreeUserPhysicalPages(
    hProcess: HANDLE,
    NumberOfPages: *u32,
    PageArray: [*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn MapUserPhysicalPages(
    VirtualAddress: *c_void,
    NumberOfPages: ?*c_void,
    PageArray: ?[*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn AllocateUserPhysicalPagesNuma(
    hProcess: HANDLE,
    NumberOfPages: *u32,
    PageArray: [*]u32,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn VirtualAllocExNuma(
    hProcess: HANDLE,
    lpAddress: ?*c_void,
    dwSize: ?*c_void,
    flAllocationType: u32,
    flProtect: u32,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn GetMemoryErrorHandlingCapabilities(
    Capabilities: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn RegisterBadMemoryNotification(
    Callback: PBAD_MEMORY_CALLBACK_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn UnregisterBadMemoryNotification(
    RegistrationHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn OfferVirtualMemory(
    VirtualAddress: [*]u8,
    Size: ?*c_void,
    Priority: OFFER_PRIORITY,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn ReclaimVirtualMemory(
    VirtualAddress: [*]const u8,
    Size: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn DiscardVirtualMemory(
    VirtualAddress: [*]u8,
    Size: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "api-ms-win-core-memory-l1-1-3" fn SetProcessValidCallTargets(
    hProcess: HANDLE,
    VirtualAddress: *c_void,
    RegionSize: ?*c_void,
    NumberOfOffsets: u32,
    OffsetInformation: [*]CFG_CALL_TARGET_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-7" fn SetProcessValidCallTargetsForMappedView(
    Process: HANDLE,
    VirtualAddress: *c_void,
    RegionSize: ?*c_void,
    NumberOfOffsets: u32,
    OffsetInformation: [*]CFG_CALL_TARGET_INFO,
    Section: HANDLE,
    ExpectedFileOffset: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-3" fn VirtualAllocFromApp(
    BaseAddress: ?*c_void,
    Size: ?*c_void,
    AllocationType: u32,
    Protection: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "api-ms-win-core-memory-l1-1-3" fn VirtualProtectFromApp(
    Address: *c_void,
    Size: ?*c_void,
    NewProtection: u32,
    OldProtection: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-3" fn OpenFileMappingFromApp(
    DesiredAccess: u32,
    InheritHandle: BOOL,
    Name: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "api-ms-win-core-memory-l1-1-4" fn QueryVirtualMemoryInformation(
    Process: HANDLE,
    VirtualAddress: *const c_void,
    MemoryInformationClass: WIN32_MEMORY_INFORMATION_CLASS,
    MemoryInformation: [*]u8,
    MemoryInformationSize: ?*c_void,
    ReturnSize: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-5" fn MapViewOfFileNuma2(
    FileMappingHandle: HANDLE,
    ProcessHandle: HANDLE,
    Offset: u64,
    BaseAddress: ?*c_void,
    ViewSize: ?*c_void,
    AllocationType: u32,
    PageProtection: u32,
    PreferredNode: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "api-ms-win-core-memory-l1-1-5" fn UnmapViewOfFile2(
    Process: HANDLE,
    BaseAddress: *c_void,
    UnmapFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-5" fn VirtualUnlockEx(
    Process: HANDLE,
    Address: *c_void,
    Size: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-memory-l1-1-6" fn VirtualAlloc2(
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Size: ?*c_void,
    AllocationType: u32,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "api-ms-win-core-memory-l1-1-6" fn MapViewOfFile3(
    FileMapping: HANDLE,
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Offset: u64,
    ViewSize: ?*c_void,
    AllocationType: u32,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "api-ms-win-core-memory-l1-1-6" fn VirtualAlloc2FromApp(
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Size: ?*c_void,
    AllocationType: u32,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "api-ms-win-core-memory-l1-1-6" fn MapViewOfFile3FromApp(
    FileMapping: HANDLE,
    Process: HANDLE,
    BaseAddress: ?*c_void,
    Offset: u64,
    ViewSize: ?*c_void,
    AllocationType: u32,
    PageProtection: u32,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "api-ms-win-core-memory-l1-1-7" fn CreateFileMapping2(
    File: HANDLE,
    SecurityAttributes: ?*SECURITY_ATTRIBUTES,
    DesiredAccess: u32,
    PageProtection: u32,
    AllocationAttributes: u32,
    MaximumSize: u64,
    Name: ?[*:0]const u16,
    ExtendedParameters: ?[*]MEM_EXTENDED_PARAMETER,
    ParameterCount: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn IsEnclaveTypeSupported(
    flEnclaveType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateEnclave(
    hProcess: HANDLE,
    lpAddress: ?*c_void,
    dwSize: ?*c_void,
    dwInitialCommitment: ?*c_void,
    flEnclaveType: u32,
    lpEnclaveInformation: [*]const u8,
    dwInfoLength: u32,
    lpEnclaveError: ?*u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn LoadEnclaveData(
    hProcess: HANDLE,
    lpAddress: *c_void,
    lpBuffer: [*]const u8,
    nSize: ?*c_void,
    flProtect: u32,
    lpPageInformation: [*]const u8,
    dwInfoLength: u32,
    lpNumberOfBytesWritten: *?*c_void,
    lpEnclaveError: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitializeEnclave(
    hProcess: HANDLE,
    lpAddress: *c_void,
    lpEnclaveInformation: [*]const u8,
    dwInfoLength: u32,
    lpEnclaveError: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-enclave-l1-1-1" fn LoadEnclaveImageA(
    lpEnclaveAddress: *c_void,
    lpImageName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-enclave-l1-1-1" fn LoadEnclaveImageW(
    lpEnclaveAddress: *c_void,
    lpImageName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "vertdll" fn CallEnclave(
    lpRoutine: LPENCLAVE_ROUTINE,
    lpParameter: *c_void,
    fWaitForThread: BOOL,
    lpReturnValue: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "vertdll" fn TerminateEnclave(
    lpAddress: *c_void,
    fWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-enclave-l1-1-1" fn DeleteEnclave(
    lpAddress: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DisableThreadLibraryCalls(
    hLibModule: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FindResourceExW(
    hModule: ?*c_void,
    lpType: [*:0]const u16,
    lpName: [*:0]const u16,
    wLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) HRSRC;

pub extern "KERNEL32" fn FreeLibrary(
    hLibModule: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FreeLibraryAndExitThread(
    hLibModule: ?*c_void,
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetModuleFileNameA(
    hModule: ?*c_void,
    lpFilename: [*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetModuleFileNameW(
    hModule: ?*c_void,
    lpFilename: [*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetModuleHandleA(
    lpModuleName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GetModuleHandleW(
    lpModuleName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GetModuleHandleExA(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u8,
    phModule: *?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetModuleHandleExW(
    dwFlags: u32,
    lpModuleName: ?[*:0]const u16,
    phModule: *?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcAddress(
    hModule: ?*c_void,
    lpProcName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) FARPROC;

pub extern "KERNEL32" fn LoadLibraryExA(
    lpLibFileName: [*:0]const u8,
    hFile: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn LoadLibraryExW(
    lpLibFileName: [*:0]const u16,
    hFile: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn AddDllDirectory(
    NewDirectory: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn RemoveDllDirectory(
    Cookie: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetDefaultDllDirectories(
    DirectoryFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FindResourceW(
    hModule: ?*c_void,
    lpName: [*:0]const u16,
    lpType: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRSRC;

pub extern "KERNEL32" fn LoadLibraryA(
    lpLibFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn LoadLibraryW(
    lpLibFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn EnumResourceNamesW(
    hModule: ?*c_void,
    lpType: [*:0]const u16,
    lpEnumFunc: ENUMRESNAMEPROCW,
    lParam: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn AllocConsole(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FreeConsole(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn AttachConsole(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleCP(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleOutputCP(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleMode(
    hConsoleHandle: HANDLE,
    lpMode: *ConsoleMode,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleMode(
    hConsoleHandle: HANDLE,
    dwMode: ConsoleMode,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumberOfConsoleInputEvents(
    hConsoleInput: HANDLE,
    lpNumberOfEvents: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleInputA(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn PeekConsoleInputA(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn PeekConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: [*]INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleA(
    hConsoleInput: HANDLE,
    lpBuffer: *c_void,
    nNumberOfCharsToRead: u32,
    lpNumberOfCharsRead: *u32,
    pInputControl: ?*CONSOLE_READCONSOLE_CONTROL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleW(
    hConsoleInput: HANDLE,
    lpBuffer: *c_void,
    nNumberOfCharsToRead: u32,
    lpNumberOfCharsRead: *u32,
    pInputControl: ?*CONSOLE_READCONSOLE_CONTROL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleA(
    hConsoleOutput: HANDLE,
    lpBuffer: [*]const u8,
    nNumberOfCharsToWrite: u32,
    lpNumberOfCharsWritten: ?*u32,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleW(
    hConsoleOutput: HANDLE,
    lpBuffer: [*]const u8,
    nNumberOfCharsToWrite: u32,
    lpNumberOfCharsWritten: ?*u32,
    lpReserved: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleCtrlHandler(
    HandlerRoutine: ?PHANDLER_ROUTINE,
    Add: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreatePseudoConsole(
    size: COORD,
    hInput: HANDLE,
    hOutput: HANDLE,
    dwFlags: u32,
    phPC: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn ResizePseudoConsole(
    hPC: *c_void,
    size: COORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn ClosePseudoConsole(
    hPC: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn FillConsoleOutputCharacterA(
    hConsoleOutput: HANDLE,
    cCharacter: i8,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FillConsoleOutputCharacterW(
    hConsoleOutput: HANDLE,
    cCharacter: u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FillConsoleOutputAttribute(
    hConsoleOutput: HANDLE,
    wAttribute: u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfAttrsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GenerateConsoleCtrlEvent(
    dwCtrlEvent: u32,
    dwProcessGroupId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateConsoleScreenBuffer(
    dwDesiredAccess: u32,
    dwShareMode: u32,
    lpSecurityAttributes: ?*const SECURITY_ATTRIBUTES,
    dwFlags: u32,
    lpScreenBufferData: *c_void,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn SetConsoleActiveScreenBuffer(
    hConsoleOutput: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FlushConsoleInputBuffer(
    hConsoleInput: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleCP(
    wCodePageID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleOutputCP(
    wCodePageID: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleCursorInfo(
    hConsoleOutput: HANDLE,
    lpConsoleCursorInfo: *CONSOLE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleCursorInfo(
    hConsoleOutput: HANDLE,
    lpConsoleCursorInfo: *const CONSOLE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleScreenBufferInfo(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfo: *CONSOLE_SCREEN_BUFFER_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleScreenBufferInfoEx(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfoEx: *CONSOLE_SCREEN_BUFFER_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleScreenBufferInfoEx(
    hConsoleOutput: HANDLE,
    lpConsoleScreenBufferInfoEx: *CONSOLE_SCREEN_BUFFER_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleScreenBufferSize(
    hConsoleOutput: HANDLE,
    dwSize: COORD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleCursorPosition(
    hConsoleOutput: HANDLE,
    dwCursorPosition: COORD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetLargestConsoleWindowSize(
    hConsoleOutput: HANDLE,
) callconv(@import("std").os.windows.WINAPI) COORD;

pub extern "KERNEL32" fn SetConsoleTextAttribute(
    hConsoleOutput: HANDLE,
    wAttributes: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleWindowInfo(
    hConsoleOutput: HANDLE,
    bAbsolute: BOOL,
    lpConsoleWindow: *const SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputCharacterA(
    hConsoleOutput: HANDLE,
    lpCharacter: [*:0]const u8,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputCharacterW(
    hConsoleOutput: HANDLE,
    lpCharacter: [*:0]const u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfCharsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputAttribute(
    hConsoleOutput: HANDLE,
    lpAttribute: [*:0]const u16,
    nLength: u32,
    dwWriteCoord: COORD,
    lpNumberOfAttrsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputCharacterA(
    hConsoleOutput: HANDLE,
    lpCharacter: [*:0]u8,
    nLength: u32,
    dwReadCoord: COORD,
    lpNumberOfCharsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputCharacterW(
    hConsoleOutput: HANDLE,
    lpCharacter: [*:0]u16,
    nLength: u32,
    dwReadCoord: COORD,
    lpNumberOfCharsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputAttribute(
    hConsoleOutput: HANDLE,
    lpAttribute: [*:0]u16,
    nLength: u32,
    dwReadCoord: COORD,
    lpNumberOfAttrsRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleInputA(
    hConsoleInput: HANDLE,
    lpBuffer: [*]const INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleInputW(
    hConsoleInput: HANDLE,
    lpBuffer: [*]const INPUT_RECORD,
    nLength: u32,
    lpNumberOfEventsWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ScrollConsoleScreenBufferA(
    hConsoleOutput: HANDLE,
    lpScrollRectangle: *const SMALL_RECT,
    lpClipRectangle: ?*const SMALL_RECT,
    dwDestinationOrigin: COORD,
    lpFill: *const CHAR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ScrollConsoleScreenBufferW(
    hConsoleOutput: HANDLE,
    lpScrollRectangle: *const SMALL_RECT,
    lpClipRectangle: ?*const SMALL_RECT,
    dwDestinationOrigin: COORD,
    lpFill: *const CHAR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputA(
    hConsoleOutput: HANDLE,
    lpBuffer: *const CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpWriteRegion: *SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteConsoleOutputW(
    hConsoleOutput: HANDLE,
    lpBuffer: *const CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpWriteRegion: *SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputA(
    hConsoleOutput: HANDLE,
    lpBuffer: *CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpReadRegion: *SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadConsoleOutputW(
    hConsoleOutput: HANDLE,
    lpBuffer: *CHAR_INFO,
    dwBufferSize: COORD,
    dwBufferCoord: COORD,
    lpReadRegion: *SMALL_RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleTitleA(
    lpConsoleTitle: [*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleTitleW(
    lpConsoleTitle: [*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleOriginalTitleA(
    lpConsoleTitle: [*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleOriginalTitleW(
    lpConsoleTitle: [*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetConsoleTitleA(
    lpConsoleTitle: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleTitleW(
    lpConsoleTitle: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumberOfConsoleMouseButtons(
    lpNumberOfMouseButtons: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleFontSize(
    hConsoleOutput: HANDLE,
    nFont: u32,
) callconv(@import("std").os.windows.WINAPI) COORD;

pub extern "KERNEL32" fn GetCurrentConsoleFont(
    hConsoleOutput: HANDLE,
    bMaximumWindow: BOOL,
    lpConsoleCurrentFont: *CONSOLE_FONT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCurrentConsoleFontEx(
    hConsoleOutput: HANDLE,
    bMaximumWindow: BOOL,
    lpConsoleCurrentFontEx: *CONSOLE_FONT_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCurrentConsoleFontEx(
    hConsoleOutput: HANDLE,
    bMaximumWindow: BOOL,
    lpConsoleCurrentFontEx: *CONSOLE_FONT_INFOEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleSelectionInfo(
    lpConsoleSelectionInfo: *CONSOLE_SELECTION_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleHistoryInfo(
    lpConsoleHistoryInfo: *CONSOLE_HISTORY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleHistoryInfo(
    lpConsoleHistoryInfo: *CONSOLE_HISTORY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleDisplayMode(
    lpModeFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleDisplayMode(
    hConsoleOutput: HANDLE,
    dwFlags: u32,
    lpNewScreenBufferDimensions: ?*COORD,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleWindow(
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "KERNEL32" fn AddConsoleAliasA(
    Source: PSTR,
    Target: PSTR,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn AddConsoleAliasW(
    Source: PWSTR,
    Target: PWSTR,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleAliasA(
    Source: PSTR,
    TargetBuffer: [*:0]u8,
    TargetBufferLength: u32,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasW(
    Source: PWSTR,
    TargetBuffer: [*:0]u16,
    TargetBufferLength: u32,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasesLengthA(
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasesLengthW(
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasExesLengthA(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasExesLengthW(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasesA(
    AliasBuffer: [*:0]u8,
    AliasBufferLength: u32,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasesW(
    AliasBuffer: [*:0]u16,
    AliasBufferLength: u32,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasExesA(
    ExeNameBuffer: [*:0]u8,
    ExeNameBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleAliasExesW(
    ExeNameBuffer: [*:0]u16,
    ExeNameBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn ExpungeConsoleCommandHistoryA(
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn ExpungeConsoleCommandHistoryW(
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn SetConsoleNumberOfCommandsA(
    Number: u32,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetConsoleNumberOfCommandsW(
    Number: u32,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetConsoleCommandHistoryLengthA(
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleCommandHistoryLengthW(
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleCommandHistoryA(
    Commands: [*:0]u8,
    CommandBufferLength: u32,
    ExeName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleCommandHistoryW(
    Commands: [*:0]u16,
    CommandBufferLength: u32,
    ExeName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetConsoleProcessList(
    lpdwProcessList: [*]u32,
    dwProcessCount: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn timeSetEvent(
    uDelay: u32,
    uResolution: u32,
    fptc: LPTIMECALLBACK,
    dwUser: ?*c_void,
    fuEvent: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINMM" fn timeKillEvent(
    uTimerID: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "RPCNS4" fn I_RpcNsGetBuffer(
    Message: *RPC_MESSAGE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "RPCNS4" fn I_RpcNsSendReceive(
    Message: *RPC_MESSAGE,
    Handle: **c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "RPCNS4" fn I_RpcNsRaiseException(
    Message: *RPC_MESSAGE,
    Status: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "RPCNS4" fn I_RpcReBindBuffer(
    Message: *RPC_MESSAGE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINSPOOL" fn EnumPrintersA(
    Flags: u32,
    Name: ?PSTR,
    Level: u32,
    pPrinterEnum: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrintersW(
    Flags: u32,
    Name: ?PWSTR,
    Level: u32,
    pPrinterEnum: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetSpoolFileHandle(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn CommitSpoolData(
    hPrinter: HANDLE,
    hSpoolFile: HANDLE,
    cbCommit: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn CloseSpoolFileHandle(
    hPrinter: HANDLE,
    hSpoolFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn OpenPrinterA(
    pPrinterName: ?PSTR,
    phPrinter: *HANDLE,
    pDefault: ?*PRINTER_DEFAULTSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn OpenPrinterW(
    pPrinterName: ?PWSTR,
    phPrinter: *HANDLE,
    pDefault: ?*PRINTER_DEFAULTSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn ResetPrinterA(
    hPrinter: HANDLE,
    pDefault: ?*PRINTER_DEFAULTSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn ResetPrinterW(
    hPrinter: HANDLE,
    pDefault: ?*PRINTER_DEFAULTSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetJobA(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetJobW(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetJobA(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetJobW(
    hPrinter: HANDLE,
    JobId: u32,
    Level: u32,
    pJob: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumJobsA(
    hPrinter: HANDLE,
    FirstJob: u32,
    NoJobs: u32,
    Level: u32,
    pJob: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumJobsW(
    hPrinter: HANDLE,
    FirstJob: u32,
    NoJobs: u32,
    Level: u32,
    pJob: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterA(
    pName: ?PSTR,
    Level: u32,
    pPrinter: *u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn AddPrinterW(
    pName: ?PWSTR,
    Level: u32,
    pPrinter: *u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn DeletePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetPrinterA(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetPrinterW(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?*u8,
    Command: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterA(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterW(
    hPrinter: HANDLE,
    Level: u32,
    pPrinter: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterDriverA(
    pName: ?PSTR,
    Level: u32,
    pDriverInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPrinterDriverW(
    pName: ?PWSTR,
    Level: u32,
    pDriverInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterDriverExA(
    pName: ?PSTR,
    Level: u32,
    lpbDriverInfo: *u8,
    dwFileCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPrinterDriverExW(
    pName: ?PWSTR,
    Level: u32,
    lpbDriverInfo: *u8,
    dwFileCopyFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrinterDriversA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    Level: u32,
    pDriverInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrinterDriversW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    Level: u32,
    pDriverInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriverA(
    hPrinter: HANDLE,
    pEnvironment: ?PSTR,
    Level: u32,
    pDriverInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriverW(
    hPrinter: HANDLE,
    pEnvironment: ?PWSTR,
    Level: u32,
    pDriverInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriverDirectoryA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    Level: u32,
    pDriverDirectory: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriverDirectoryW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    Level: u32,
    pDriverDirectory: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrinterDriverA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pDriverName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePrinterDriverW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pDriverName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrinterDriverExA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pDriverName: PSTR,
    dwDeleteFlag: u32,
    dwVersionFlag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePrinterDriverExW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pDriverName: PWSTR,
    dwDeleteFlag: u32,
    dwVersionFlag: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrintProcessorA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pPathName: PSTR,
    pPrintProcessorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPrintProcessorW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pPathName: PWSTR,
    pPrintProcessorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrintProcessorsA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    Level: u32,
    pPrintProcessorInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EnumPrintProcessorsW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    Level: u32,
    pPrintProcessorInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrintProcessorDirectoryA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    Level: u32,
    pPrintProcessorInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn GetPrintProcessorDirectoryW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    Level: u32,
    pPrintProcessorInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPrintProcessorDatatypesA(
    pName: ?PSTR,
    pPrintProcessorName: PSTR,
    Level: u32,
    pDatatypes: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EnumPrintProcessorDatatypesW(
    pName: ?PWSTR,
    pPrintProcessorName: PWSTR,
    Level: u32,
    pDatatypes: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrintProcessorA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pPrintProcessorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePrintProcessorW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pPrintProcessorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn StartDocPrinterA(
    hPrinter: HANDLE,
    Level: u32,
    pDocInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn StartDocPrinterW(
    hPrinter: HANDLE,
    Level: u32,
    pDocInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn StartPagePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn WritePrinter(
    hPrinter: HANDLE,
    pBuf: [*]u8,
    cbBuf: u32,
    pcWritten: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn FlushPrinter(
    hPrinter: HANDLE,
    pBuf: ?[*]u8,
    cbBuf: u32,
    pcWritten: *u32,
    cSleep: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EndPagePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AbortPrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn ReadPrinter(
    hPrinter: HANDLE,
    pBuf: [*]u8,
    cbBuf: u32,
    pNoBytesRead: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EndDocPrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddJobA(
    hPrinter: HANDLE,
    Level: u32,
    pData: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddJobW(
    hPrinter: HANDLE,
    Level: u32,
    pData: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn ScheduleJob(
    hPrinter: HANDLE,
    JobId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn PrinterProperties(
    hWnd: HWND,
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DocumentPropertiesA(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: PSTR,
    pDevModeOutput: ?*DEVMODEA,
    pDevModeInput: ?*DEVMODEA,
    fMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINSPOOL" fn DocumentPropertiesW(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: PWSTR,
    pDevModeOutput: ?*DEVMODEW,
    pDevModeInput: ?*DEVMODEW,
    fMode: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINSPOOL" fn AdvancedDocumentPropertiesA(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: PSTR,
    pDevModeOutput: ?*DEVMODEA,
    pDevModeInput: ?*DEVMODEA,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINSPOOL" fn AdvancedDocumentPropertiesW(
    hWnd: HWND,
    hPrinter: HANDLE,
    pDeviceName: PWSTR,
    pDevModeOutput: ?*DEVMODEW,
    pDevModeInput: ?*DEVMODEW,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "WINSPOOL" fn GetPrinterDataA(
    hPrinter: HANDLE,
    pValueName: PSTR,
    pType: ?*u32,
    pData: ?[*:0]u8,
    nSize: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn GetPrinterDataW(
    hPrinter: HANDLE,
    pValueName: PWSTR,
    pType: ?*u32,
    pData: ?[*:0]u8,
    nSize: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn GetPrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    pValueName: [*:0]const u8,
    pType: ?*u32,
    pData: ?[*:0]u8,
    nSize: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn GetPrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    pValueName: [*:0]const u16,
    pType: ?*u32,
    pData: ?[*:0]u8,
    nSize: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn EnumPrinterDataA(
    hPrinter: HANDLE,
    dwIndex: u32,
    pValueName: [*:0]u8,
    cbValueName: u32,
    pcbValueName: *u32,
    pType: ?*u32,
    pData: ?[*:0]u8,
    cbData: u32,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn EnumPrinterDataW(
    hPrinter: HANDLE,
    dwIndex: u32,
    pValueName: [*:0]u16,
    cbValueName: u32,
    pcbValueName: *u32,
    pType: ?*u32,
    pData: ?[*:0]u8,
    cbData: u32,
    pcbData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn EnumPrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    pEnumValues: ?[*:0]u8,
    cbEnumValues: u32,
    pcbEnumValues: *u32,
    pnEnumValues: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn EnumPrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    pEnumValues: ?[*:0]u8,
    cbEnumValues: u32,
    pcbEnumValues: *u32,
    pnEnumValues: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn EnumPrinterKeyA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    pSubkey: ?[*:0]u8,
    cbSubkey: u32,
    pcbSubkey: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn EnumPrinterKeyW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    pSubkey: ?[*:0]u16,
    cbSubkey: u32,
    pcbSubkey: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn SetPrinterDataA(
    hPrinter: HANDLE,
    pValueName: PSTR,
    Type: u32,
    pData: [*:0]u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn SetPrinterDataW(
    hPrinter: HANDLE,
    pValueName: PWSTR,
    Type: u32,
    pData: [*:0]u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn SetPrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    pValueName: [*:0]const u8,
    Type: u32,
    pData: [*:0]u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn SetPrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    pValueName: [*:0]const u16,
    Type: u32,
    pData: [*:0]u8,
    cbData: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterDataA(
    hPrinter: HANDLE,
    pValueName: PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterDataW(
    hPrinter: HANDLE,
    pValueName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterDataExA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
    pValueName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterDataExW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
    pValueName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn DeletePrinterKeyA(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn DeletePrinterKeyW(
    hPrinter: HANDLE,
    pKeyName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn WaitForPrinterChange(
    hPrinter: HANDLE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn FindFirstPrinterChangeNotification(
    hPrinter: HANDLE,
    fdwFilter: u32,
    fdwOptions: u32,
    pPrinterNotifyOptions: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn FindNextPrinterChangeNotification(
    hChange: HANDLE,
    pdwChange: ?*u32,
    pvReserved: ?*c_void,
    ppPrinterNotifyInfo: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn FreePrinterNotifyInfo(
    pPrinterNotifyInfo: *PRINTER_NOTIFY_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn FindClosePrinterChangeNotification(
    hChange: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn PrinterMessageBoxA(
    hPrinter: HANDLE,
    Error: u32,
    hWnd: HWND,
    pText: PSTR,
    pCaption: PSTR,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn PrinterMessageBoxW(
    hPrinter: HANDLE,
    Error: u32,
    hWnd: HWND,
    pText: PWSTR,
    pCaption: PWSTR,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn ClosePrinter(
    hPrinter: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddFormA(
    hPrinter: HANDLE,
    Level: u32,
    pForm: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddFormW(
    hPrinter: HANDLE,
    Level: u32,
    pForm: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeleteFormA(
    hPrinter: HANDLE,
    pFormName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeleteFormW(
    hPrinter: HANDLE,
    pFormName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetFormA(
    hPrinter: HANDLE,
    pFormName: PSTR,
    Level: u32,
    pForm: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn GetFormW(
    hPrinter: HANDLE,
    pFormName: PWSTR,
    Level: u32,
    pForm: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetFormA(
    hPrinter: HANDLE,
    pFormName: PSTR,
    Level: u32,
    pForm: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn SetFormW(
    hPrinter: HANDLE,
    pFormName: PWSTR,
    Level: u32,
    pForm: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumFormsA(
    hPrinter: HANDLE,
    Level: u32,
    pForm: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EnumFormsW(
    hPrinter: HANDLE,
    Level: u32,
    pForm: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumMonitorsA(
    pName: ?PSTR,
    Level: u32,
    pMonitor: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn EnumMonitorsW(
    pName: ?PWSTR,
    Level: u32,
    pMonitor: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddMonitorA(
    pName: ?PSTR,
    Level: u32,
    pMonitors: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddMonitorW(
    pName: ?PWSTR,
    Level: u32,
    pMonitors: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeleteMonitorA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pMonitorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeleteMonitorW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pMonitorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPortsA(
    pName: ?PSTR,
    Level: u32,
    pPort: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn EnumPortsW(
    pName: ?PWSTR,
    Level: u32,
    pPort: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
    pcReturned: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPortA(
    pName: ?PSTR,
    hWnd: HWND,
    pMonitorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPortW(
    pName: ?PWSTR,
    hWnd: HWND,
    pMonitorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn ConfigurePortA(
    pName: ?PSTR,
    hWnd: HWND,
    pPortName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn ConfigurePortW(
    pName: ?PWSTR,
    hWnd: HWND,
    pPortName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePortA(
    pName: ?PSTR,
    hWnd: HWND,
    pPortName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePortW(
    pName: ?PWSTR,
    hWnd: HWND,
    pPortName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn XcvDataW(
    hXcv: HANDLE,
    pszDataName: [*:0]const u16,
    pInputData: ?[*:0]u8,
    cbInputData: u32,
    pOutputData: ?[*:0]u8,
    cbOutputData: u32,
    pcbOutputNeeded: *u32,
    pdwStatus: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetDefaultPrinterA(
    pszBuffer: ?[*:0]u8,
    pcchBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetDefaultPrinterW(
    pszBuffer: ?[*:0]u16,
    pcchBuffer: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetDefaultPrinterA(
    pszPrinter: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetDefaultPrinterW(
    pszPrinter: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn SetPortA(
    pName: ?PSTR,
    pPortName: PSTR,
    dwLevel: u32,
    pPortInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn SetPortW(
    pName: ?PWSTR,
    pPortName: PWSTR,
    dwLevel: u32,
    pPortInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterConnectionA(
    pName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterConnectionW(
    pName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrinterConnectionA(
    pName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrinterConnectionW(
    pName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn ConnectToPrinterDlg(
    hwnd: HWND,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "WINSPOOL" fn AddPrintProvidorA(
    pName: ?PSTR,
    Level: u32,
    pProvidorInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn AddPrintProvidorW(
    pName: ?PWSTR,
    Level: u32,
    pProvidorInfo: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn DeletePrintProvidorA(
    pName: ?PSTR,
    pEnvironment: ?PSTR,
    pPrintProvidorName: PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn DeletePrintProvidorW(
    pName: ?PWSTR,
    pEnvironment: ?PWSTR,
    pPrintProvidorName: PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn IsValidDevmodeA(
    pDevmode: ?*DEVMODEA,
    DevmodeSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn IsValidDevmodeW(
    pDevmode: ?*DEVMODEW,
    DevmodeSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn OpenPrinter2A(
    pPrinterName: ?[*:0]const u8,
    phPrinter: *HANDLE,
    pDefault: ?*PRINTER_DEFAULTSA,
    pOptions: ?*PRINTER_OPTIONSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn OpenPrinter2W(
    pPrinterName: ?[*:0]const u16,
    phPrinter: *HANDLE,
    pDefault: ?*PRINTER_DEFAULTSW,
    pOptions: ?*PRINTER_OPTIONSW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterConnection2A(
    hWnd: HWND,
    pszName: [*:0]const u8,
    dwLevel: u32,
    pConnectionInfo: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn AddPrinterConnection2W(
    hWnd: HWND,
    pszName: [*:0]const u16,
    dwLevel: u32,
    pConnectionInfo: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn InstallPrinterDriverFromPackageA(
    pszServer: ?[*:0]const u8,
    pszInfPath: ?[*:0]const u8,
    pszDriverName: [*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn InstallPrinterDriverFromPackageW(
    pszServer: ?[*:0]const u16,
    pszInfPath: ?[*:0]const u16,
    pszDriverName: [*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn UploadPrinterDriverPackageA(
    pszServer: ?[*:0]const u8,
    pszInfPath: [*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
    dwFlags: u32,
    hwnd: HWND,
    pszDestInfPath: [*:0]u8,
    pcchDestInfPath: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn UploadPrinterDriverPackageW(
    pszServer: ?[*:0]const u16,
    pszInfPath: [*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
    dwFlags: u32,
    hwnd: HWND,
    pszDestInfPath: [*:0]u16,
    pcchDestInfPath: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn GetCorePrinterDriversA(
    pszServer: ?[*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
    pszzCoreDriverDependencies: [*:0]const u8,
    cCorePrinterDrivers: u32,
    pCorePrinterDrivers: [*]CORE_PRINTER_DRIVERA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn GetCorePrinterDriversW(
    pszServer: ?[*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
    pszzCoreDriverDependencies: [*:0]const u16,
    cCorePrinterDrivers: u32,
    pCorePrinterDrivers: [*]CORE_PRINTER_DRIVERW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// This function from dll 'WINSPOOL' is being skipped because it has some sort of issue
pub fn CorePrinterDriverInstalledA() void { @panic("this function is not working"); }

// This function from dll 'WINSPOOL' is being skipped because it has some sort of issue
pub fn CorePrinterDriverInstalledW() void { @panic("this function is not working"); }

pub extern "WINSPOOL" fn GetPrinterDriverPackagePathA(
    pszServer: ?[*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
    pszLanguage: ?[*:0]const u8,
    pszPackageID: [*:0]const u8,
    pszDriverPackageCab: ?[*:0]u8,
    cchDriverPackageCab: u32,
    pcchRequiredSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn GetPrinterDriverPackagePathW(
    pszServer: ?[*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
    pszLanguage: ?[*:0]const u16,
    pszPackageID: [*:0]const u16,
    pszDriverPackageCab: ?[*:0]u16,
    cchDriverPackageCab: u32,
    pcchRequiredSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn DeletePrinterDriverPackageA(
    pszServer: ?[*:0]const u8,
    pszInfPath: [*:0]const u8,
    pszEnvironment: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn DeletePrinterDriverPackageW(
    pszServer: ?[*:0]const u16,
    pszInfPath: [*:0]const u16,
    pszEnvironment: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn ReportJobProcessingProgress(
    printerHandle: HANDLE,
    jobId: u32,
    jobOperation: EPrintXPSJobOperation,
    jobProgress: EPrintXPSJobProgress,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "WINSPOOL" fn GetPrinterDriver2A(
    hWnd: HWND,
    hPrinter: HANDLE,
    pEnvironment: ?PSTR,
    Level: u32,
    pDriverInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrinterDriver2W(
    hWnd: HWND,
    hPrinter: HANDLE,
    pEnvironment: ?PWSTR,
    Level: u32,
    pDriverInfo: ?[*:0]u8,
    cbBuf: u32,
    pcbNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINSPOOL" fn GetPrintExecutionData(
    pData: *PRINT_EXECUTION_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "SPOOLSS" fn GetJobNamedPropertyValue(
    hPrinter: HANDLE,
    JobId: u32,
    pszName: [*:0]const u16,
    pValue: *PrintPropertyValue,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn FreePrintPropertyValue(
    pValue: *PrintPropertyValue,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WINSPOOL" fn FreePrintNamedPropertyArray(
    cProperties: u32,
    ppProperties: ?[*]?*PrintNamedProperty,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WINSPOOL" fn SetJobNamedProperty(
    hPrinter: HANDLE,
    JobId: u32,
    pProperty: *const PrintNamedProperty,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "SPOOLSS" fn DeleteJobNamedProperty(
    hPrinter: HANDLE,
    JobId: u32,
    pszName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn EnumJobNamedProperties(
    hPrinter: HANDLE,
    JobId: u32,
    pcProperties: *u32,
    ppProperties: **PrintNamedProperty,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WINSPOOL" fn GetPrintOutputInfo(
    hWnd: HWND,
    pszPrinter: [*:0]const u16,
    phFile: *HANDLE,
    ppszOutputFile: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "CoreMessaging" fn CreateDispatcherQueueController(
    options: DispatcherQueueOptions,
    dispatcherQueueController: **struct{comment: []const u8 = "MissingClrType DispatcherQueueController.Windows.System"},
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "VSSAPI" fn CreateVssExpressWriterInternal(
    ppWriter: **IVssExpressWriter,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "GDI32" fn EngQueryEMFInfo(
    hdev: ?*c_void,
    pEMFInfo: *EMFINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-libraryloader-l2-1-0" fn QueryOptionalDelayLoadedAPI(
    hParentModule: ?*c_void,
    lpDllName: [*:0]const u8,
    lpProcName: [*:0]const u8,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "vertdll" fn EnclaveGetAttestationReport(
    EnclaveData: ?*const u8,
    Report: ?[*]u8,
    BufferSize: u32,
    OutputSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "vertdll" fn EnclaveVerifyAttestationReport(
    EnclaveType: u32,
    Report: [*]const u8,
    ReportSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "vertdll" fn EnclaveSealData(
    DataToEncrypt: [*]const u8,
    DataToEncryptSize: u32,
    IdentityPolicy: ENCLAVE_SEALING_IDENTITY_POLICY,
    RuntimePolicy: u32,
    ProtectedBlob: ?[*]u8,
    BufferSize: u32,
    ProtectedBlobSize: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "vertdll" fn EnclaveUnsealData(
    ProtectedBlob: [*]const u8,
    ProtectedBlobSize: u32,
    DecryptedData: ?[*]u8,
    BufferSize: u32,
    DecryptedDataSize: *u32,
    SealingIdentity: ?*ENCLAVE_IDENTITY,
    UnsealingFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "vertdll" fn EnclaveGetEnclaveInformation(
    InformationSize: u32,
    EnclaveInformation: [*]ENCLAVE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "POWRPROF" fn CallNtPowerInformation(
    InformationLevel: POWER_INFORMATION_LEVEL,
    InputBuffer: ?[*]u8,
    InputBufferLength: u32,
    OutputBuffer: ?[*]u8,
    OutputBufferLength: u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "POWRPROF" fn GetPwrCapabilities(
    lpspc: *SYSTEM_POWER_CAPABILITIES,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn PowerDeterminePlatformRoleEx(
    Version: u32,
) callconv(@import("std").os.windows.WINAPI) POWER_PLATFORM_ROLE;

pub extern "POWRPROF" fn PowerRegisterSuspendResumeNotification(
    Flags: u32,
    Recipient: HANDLE,
    RegistrationHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerUnregisterSuspendResumeNotification(
    RegistrationHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadACValue(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Type: ?*u32,
    Buffer: ?[*:0]u8,
    BufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadDCValue(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Type: ?*u32,
    Buffer: ?[*:0]u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerGetActiveScheme(
    UserRootPowerKey: HKEY,
    ActivePolicyGuid: **Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerSetActiveScheme(
    UserRootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerSettingRegisterNotification(
    SettingGuid: *Guid,
    Flags: u32,
    Recipient: HANDLE,
    RegistrationHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerSettingUnregisterNotification(
    RegistrationHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerRegisterForEffectivePowerModeNotifications(
    Version: u32,
    Callback: *EFFECTIVE_POWER_MODE_CALLBACK,
    Context: ?*c_void,
    RegistrationHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "POWRPROF" fn PowerUnregisterFromEffectivePowerModeNotifications(
    RegistrationHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "POWRPROF" fn GetPwrDiskSpindownRange(
    puiMax: *u32,
    puiMin: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn EnumPwrSchemes(
    lpfn: PWRSCHEMESENUMPROC,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn ReadGlobalPwrPolicy(
    pGlobalPowerPolicy: *GLOBAL_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn ReadPwrScheme(
    uiID: u32,
    pPowerPolicy: *POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn WritePwrScheme(
    puiID: *u32,
    lpszSchemeName: [*:0]const u16,
    lpszDescription: ?[*:0]const u16,
    lpScheme: *POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn WriteGlobalPwrPolicy(
    pGlobalPowerPolicy: *GLOBAL_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn DeletePwrScheme(
    uiID: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn GetActivePwrScheme(
    puiID: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn SetActivePwrScheme(
    uiID: u32,
    pGlobalPowerPolicy: ?*GLOBAL_POWER_POLICY,
    pPowerPolicy: ?*POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn IsPwrSuspendAllowed(
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn IsPwrHibernateAllowed(
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn IsPwrShutdownAllowed(
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn IsAdminOverrideActive(
    papp: *ADMINISTRATOR_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn SetSuspendState(
    bHibernate: u8,
    bForce: u8,
    bWakeupEventsDisabled: u8,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn GetCurrentPowerPolicies(
    pGlobalPowerPolicy: *GLOBAL_POWER_POLICY,
    pPowerPolicy: *POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn CanUserWritePwrScheme(
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn ReadProcessorPwrScheme(
    uiID: u32,
    pMachineProcessorPowerPolicy: *MACHINE_PROCESSOR_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn WriteProcessorPwrScheme(
    uiID: u32,
    pMachineProcessorPowerPolicy: *MACHINE_PROCESSOR_POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn ValidatePowerPolicies(
    pGlobalPowerPolicy: ?*GLOBAL_POWER_POLICY,
    pPowerPolicy: ?*POWER_POLICY,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn PowerIsSettingRangeDefined(
    SubKeyGuid: ?*const Guid,
    SettingGuid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn PowerSettingAccessCheckEx(
    AccessFlags: POWER_DATA_ACCESSOR,
    PowerGuid: ?*const Guid,
    AccessType: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerSettingAccessCheck(
    AccessFlags: POWER_DATA_ACCESSOR,
    PowerGuid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadFriendlyName(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Buffer: ?[*:0]u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadDescription(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Buffer: ?[*:0]u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadPossibleValue(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Type: ?*u32,
    PossibleSettingIndex: u32,
    Buffer: ?[*:0]u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadPossibleFriendlyName(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    PossibleSettingIndex: u32,
    Buffer: ?[*:0]u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadPossibleDescription(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    PossibleSettingIndex: u32,
    Buffer: ?[*:0]u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadValueMin(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueMinimum: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadValueMax(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueMaximum: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadValueIncrement(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueIncrement: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadValueUnitsSpecifier(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Buffer: ?[*:0]u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadIconResourceSpecifier(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Buffer: ?[*:0]u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReadSettingAttributes(
    SubGroupGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWriteFriendlyName(
    RootPowerKey: HKEY,
    SchemeGuid: *const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Buffer: [*:0]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWriteDescription(
    RootPowerKey: HKEY,
    SchemeGuid: *const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Buffer: [*:0]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWritePossibleValue(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Type: u32,
    PossibleSettingIndex: u32,
    Buffer: [*:0]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWritePossibleFriendlyName(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    PossibleSettingIndex: u32,
    Buffer: [*:0]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWritePossibleDescription(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    PossibleSettingIndex: u32,
    Buffer: [*:0]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWriteValueMin(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueMinimum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWriteValueMax(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueMaximum: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWriteValueIncrement(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    ValueIncrement: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWriteValueUnitsSpecifier(
    RootPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Buffer: [*:0]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWriteIconResourceSpecifier(
    RootPowerKey: HKEY,
    SchemeGuid: *const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Buffer: [*:0]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerWriteSettingAttributes(
    SubGroupGuid: ?*const Guid,
    PowerSettingGuid: ?*const Guid,
    Attributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerDuplicateScheme(
    RootPowerKey: HKEY,
    SourceSchemeGuid: *const Guid,
    DestinationSchemeGuid: **Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerImportPowerScheme(
    RootPowerKey: HKEY,
    ImportFileNamePath: [*:0]const u16,
    DestinationSchemeGuid: **Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerDeleteScheme(
    RootPowerKey: HKEY,
    SchemeGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerRemovePowerSetting(
    PowerSettingSubKeyGuid: *const Guid,
    PowerSettingGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerCreateSetting(
    RootSystemPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: *const Guid,
    PowerSettingGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerCreatePossibleSetting(
    RootSystemPowerKey: HKEY,
    SubGroupOfPowerSettingsGuid: *const Guid,
    PowerSettingGuid: *const Guid,
    PossibleSettingIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerEnumerate(
    RootPowerKey: HKEY,
    SchemeGuid: ?*const Guid,
    SubGroupOfPowerSettingsGuid: ?*const Guid,
    AccessFlags: POWER_DATA_ACCESSOR,
    Index: u32,
    Buffer: ?[*:0]u8,
    BufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerOpenUserPowerKey(
    phUserPowerKey: *HKEY,
    Access: u32,
    OpenExisting: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerOpenSystemPowerKey(
    phSystemPowerKey: *HKEY,
    Access: u32,
    OpenExisting: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerCanRestoreIndividualDefaultPowerScheme(
    SchemeGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerRestoreIndividualDefaultPowerScheme(
    SchemeGuid: *const Guid,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerRestoreDefaultPowerSchemes(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerReplaceDefaultPowerSchemes(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn PowerDeterminePlatformRole(
) callconv(@import("std").os.windows.WINAPI) POWER_PLATFORM_ROLE;

pub extern "POWRPROF" fn DevicePowerEnumDevices(
    QueryIndex: u32,
    QueryInterpretationFlags: u32,
    QueryFlags: u32,
    pReturnBuffer: ?[*:0]u8,
    pBufferSize: *u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn DevicePowerSetDeviceState(
    DeviceDescription: [*:0]const u16,
    SetFlags: u32,
    SetData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "POWRPROF" fn DevicePowerOpen(
    DebugMask: u32,
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn DevicePowerClose(
) callconv(@import("std").os.windows.WINAPI) u8;

pub extern "POWRPROF" fn PowerReportThermalEvent(
    Event: *THERMAL_EVENT,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn DeviceIoControl(
    hDevice: HANDLE,
    dwIoControlCode: u32,
    lpInBuffer: ?[*]u8,
    nInBufferSize: u32,
    lpOutBuffer: ?[*]u8,
    nOutBufferSize: u32,
    lpBytesReturned: ?*u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetOverlappedResult(
    hFile: HANDLE,
    lpOverlapped: *OVERLAPPED,
    lpNumberOfBytesTransferred: *u32,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetOverlappedResultEx(
    hFile: HANDLE,
    lpOverlapped: *OVERLAPPED,
    lpNumberOfBytesTransferred: *u32,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsWow64Process(
    hProcess: HANDLE,
    Wow64Process: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsWow64Process2(
    hProcess: HANDLE,
    pProcessMachine: *u16,
    pNativeMachine: ?*u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCommandLineA(
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "KERNEL32" fn GetCommandLineW(
) callconv(@import("std").os.windows.WINAPI) PWSTR;

pub extern "KERNEL32" fn GetEnvironmentStrings(
) callconv(@import("std").os.windows.WINAPI) PSTR;

pub extern "KERNEL32" fn GetEnvironmentStringsW(
) callconv(@import("std").os.windows.WINAPI) PWSTR;

pub extern "KERNEL32" fn FreeEnvironmentStringsA(
    penv: [*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FreeEnvironmentStringsW(
    penv: [*]u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetEnvironmentVariableA(
    lpName: ?[*:0]const u8,
    lpBuffer: ?[*:0]u8,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetEnvironmentVariableW(
    lpName: ?[*:0]const u16,
    lpBuffer: ?[*:0]u16,
    nSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetEnvironmentVariableA(
    lpName: [*:0]const u8,
    lpValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetEnvironmentVariableW(
    lpName: [*:0]const u16,
    lpValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn NeedCurrentDirectoryForExePathA(
    ExeName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn NeedCurrentDirectoryForExePathW(
    ExeName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueueUserAPC(
    pfnAPC: PAPCFUNC,
    hThread: HANDLE,
    dwData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetProcessTimes(
    hProcess: HANDLE,
    lpCreationTime: *FILETIME,
    lpExitTime: *FILETIME,
    lpKernelTime: *FILETIME,
    lpUserTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCurrentProcess(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn GetCurrentProcessId(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn ExitProcess(
    uExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn TerminateProcess(
    hProcess: HANDLE,
    uExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetExitCodeProcess(
    hProcess: HANDLE,
    lpExitCode: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SwitchToThread(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateThread(
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    dwStackSize: ?*c_void,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?*c_void,
    dwCreationFlags: u32,
    lpThreadId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateRemoteThread(
    hProcess: HANDLE,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    dwStackSize: ?*c_void,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?*c_void,
    dwCreationFlags: u32,
    lpThreadId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn GetCurrentThread(
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn GetCurrentThreadId(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn OpenThread(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    dwThreadId: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn SetThreadPriority(
    hThread: HANDLE,
    nPriority: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadPriorityBoost(
    hThread: HANDLE,
    bDisablePriorityBoost: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadPriorityBoost(
    hThread: HANDLE,
    pDisablePriorityBoost: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadPriority(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn ExitThread(
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn TerminateThread(
    hThread: HANDLE,
    dwExitCode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetExitCodeThread(
    hThread: HANDLE,
    lpExitCode: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SuspendThread(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn ResumeThread(
    hThread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn TlsAlloc(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn TlsGetValue(
    dwTlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn TlsSetValue(
    dwTlsIndex: u32,
    lpTlsValue: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn TlsFree(
    dwTlsIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateProcessA(
    lpApplicationName: ?[*:0]const u8,
    lpCommandLine: ?PSTR,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: PROCESS_CREATION_FLAGS,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u8,
    lpStartupInfo: *STARTUPINFOA,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateProcessW(
    lpApplicationName: ?[*:0]const u16,
    lpCommandLine: ?PWSTR,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: PROCESS_CREATION_FLAGS,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u16,
    lpStartupInfo: *STARTUPINFOW,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessShutdownParameters(
    dwLevel: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessVersion(
    ProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetStartupInfoW(
    lpStartupInfo: *STARTUPINFOW,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ADVAPI32" fn CreateProcessAsUserW(
    hToken: HANDLE,
    lpApplicationName: ?[*:0]const u16,
    lpCommandLine: ?PWSTR,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: u32,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u16,
    lpStartupInfo: *STARTUPINFOW,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetPriorityClass(
    hProcess: HANDLE,
    dwPriorityClass: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetPriorityClass(
    hProcess: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetThreadStackGuarantee(
    StackSizeInBytes: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessId(
    Process: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetThreadId(
    Thread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn FlushProcessWriteBuffers(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetProcessIdOfThread(
    Thread: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn InitializeProcThreadAttributeList(
    lpAttributeList: ?[*]u8,
    dwAttributeCount: u32,
    dwFlags: u32,
    lpSize: *?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DeleteProcThreadAttributeList(
    lpAttributeList: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn UpdateProcThreadAttribute(
    lpAttributeList: ?*c_void,
    dwFlags: u32,
    Attribute: ?*c_void,
    lpValue: ?[*]u8,
    cbSize: ?*c_void,
    lpPreviousValue: ?[*]u8,
    lpReturnSize: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessAffinityUpdateMode(
    hProcess: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryProcessAffinityUpdateMode(
    hProcess: HANDLE,
    lpdwFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateRemoteThreadEx(
    hProcess: HANDLE,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    dwStackSize: ?*c_void,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpParameter: ?*c_void,
    dwCreationFlags: u32,
    lpAttributeList: ?*c_void,
    lpThreadId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn GetCurrentThreadStackLimits(
    LowLimit: *u32,
    HighLimit: *u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetProcessMitigationPolicy(
    hProcess: HANDLE,
    MitigationPolicy: PROCESS_MITIGATION_POLICY,
    lpBuffer: [*]u8,
    dwLength: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessMitigationPolicy(
    MitigationPolicy: PROCESS_MITIGATION_POLICY,
    lpBuffer: [*]u8,
    dwLength: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadTimes(
    hThread: HANDLE,
    lpCreationTime: *FILETIME,
    lpExitTime: *FILETIME,
    lpKernelTime: *FILETIME,
    lpUserTime: *FILETIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn OpenProcess(
    dwDesiredAccess: PROCESS_ACCESS_RIGHTS,
    bInheritHandle: BOOL,
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn GetProcessHandleCount(
    hProcess: HANDLE,
    pdwHandleCount: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCurrentProcessorNumber(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetThreadIdealProcessorEx(
    hThread: HANDLE,
    lpIdealProcessor: *PROCESSOR_NUMBER,
    lpPreviousIdealProcessor: ?*PROCESSOR_NUMBER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadIdealProcessorEx(
    hThread: HANDLE,
    lpIdealProcessor: *PROCESSOR_NUMBER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCurrentProcessorNumberEx(
    ProcNumber: *PROCESSOR_NUMBER,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetProcessPriorityBoost(
    hProcess: HANDLE,
    pDisablePriorityBoost: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessPriorityBoost(
    hProcess: HANDLE,
    bDisablePriorityBoost: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadIOPendingFlag(
    hThread: HANDLE,
    lpIOIsPending: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadInformation(
    hThread: HANDLE,
    ThreadInformationClass: THREAD_INFORMATION_CLASS,
    ThreadInformation: [*]u8,
    ThreadInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadInformation(
    hThread: HANDLE,
    ThreadInformationClass: THREAD_INFORMATION_CLASS,
    ThreadInformation: [*]u8,
    ThreadInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsProcessCritical(
    hProcess: HANDLE,
    Critical: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProtectedPolicy(
    PolicyGuid: *Guid,
    PolicyValue: ?*c_void,
    OldPolicyValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryProtectedPolicy(
    PolicyGuid: *Guid,
    PolicyValue: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadIdealProcessor(
    hThread: HANDLE,
    dwIdealProcessor: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetProcessInformation(
    hProcess: HANDLE,
    ProcessInformationClass: PROCESS_INFORMATION_CLASS,
    ProcessInformation: [*]u8,
    ProcessInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessInformation(
    hProcess: HANDLE,
    ProcessInformationClass: PROCESS_INFORMATION_CLASS,
    ProcessInformation: [*]u8,
    ProcessInformationSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn CreateProcessAsUserA(
    hToken: HANDLE,
    lpApplicationName: ?[*:0]const u8,
    lpCommandLine: ?PSTR,
    lpProcessAttributes: ?*SECURITY_ATTRIBUTES,
    lpThreadAttributes: ?*SECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: u32,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u8,
    lpStartupInfo: *STARTUPINFOA,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessShutdownParameters(
    lpdwLevel: *u32,
    lpdwFlags: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadDescription(
    hThread: HANDLE,
    lpThreadDescription: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn GetThreadDescription(
    hThread: HANDLE,
    ppszThreadDescription: *PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn GlobalMemoryStatusEx(
    lpBuffer: *MEMORYSTATUSEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetLogicalProcessorInformation(
    Buffer: ?[*]SYSTEM_LOGICAL_PROCESSOR_INFORMATION,
    ReturnedLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetLogicalProcessorInformationEx(
    RelationshipType: LOGICAL_PROCESSOR_RELATIONSHIP,
    Buffer: ?[*]SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,
    ReturnedLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetPhysicallyInstalledSystemMemory(
    TotalMemoryInKilobytes: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessorSystemCycleTime(
    Group: u16,
    Buffer: ?[*]SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION,
    ReturnedLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryThreadCycleTime(
    ThreadHandle: HANDLE,
    CycleTime: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryProcessCycleTime(
    ProcessHandle: HANDLE,
    CycleTime: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryIdleProcessorCycleTime(
    BufferLength: *u32,
    ProcessorIdleCycleTime: ?[*]u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryIdleProcessorCycleTimeEx(
    Group: u16,
    BufferLength: *u32,
    ProcessorIdleCycleTime: ?[*]u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GlobalAlloc(
    uFlags: u32,
    dwBytes: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GlobalReAlloc(
    hMem: ?*c_void,
    dwBytes: ?*c_void,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GlobalSize(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GlobalUnlock(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GlobalLock(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn GlobalFlags(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GlobalHandle(
    pMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GlobalFree(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GlobalMemoryStatus(
    lpBuffer: *MEMORYSTATUS,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn LocalAlloc(
    uFlags: u32,
    uBytes: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn LocalReAlloc(
    hMem: ?*c_void,
    uBytes: ?*c_void,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn LocalLock(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn LocalHandle(
    pMem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn LocalUnlock(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LocalSize(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn LocalFlags(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn LocalFree(
    hMem: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn GetProcessAffinityMask(
    hProcess: HANDLE,
    lpProcessAffinityMask: *?*c_void,
    lpSystemAffinityMask: *?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessAffinityMask(
    hProcess: HANDLE,
    dwProcessAffinityMask: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessIoCounters(
    hProcess: HANDLE,
    lpIoCounters: *IO_COUNTERS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessWorkingSetSize(
    hProcess: HANDLE,
    lpMinimumWorkingSetSize: *?*c_void,
    lpMaximumWorkingSetSize: *?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetProcessWorkingSetSize(
    hProcess: HANDLE,
    dwMinimumWorkingSetSize: ?*c_void,
    dwMaximumWorkingSetSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SwitchToFiber(
    lpFiber: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn DeleteFiber(
    lpFiber: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn ConvertFiberToThread(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateFiberEx(
    dwStackCommitSize: ?*c_void,
    dwStackReserveSize: ?*c_void,
    dwFlags: u32,
    lpStartAddress: LPFIBER_START_ROUTINE,
    lpParameter: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn ConvertThreadToFiberEx(
    lpParameter: ?*c_void,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn CreateFiber(
    dwStackSize: ?*c_void,
    lpStartAddress: LPFIBER_START_ROUTINE,
    lpParameter: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn ConvertThreadToFiber(
    lpParameter: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn CreateUmsCompletionList(
    UmsCompletionList: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DequeueUmsCompletionListItems(
    UmsCompletionList: *c_void,
    WaitTimeOut: u32,
    UmsThreadList: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetUmsCompletionListEvent(
    UmsCompletionList: *c_void,
    UmsCompletionEvent: *HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ExecuteUmsThread(
    UmsThread: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn UmsThreadYield(
    SchedulerParam: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DeleteUmsCompletionList(
    UmsCompletionList: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCurrentUmsThread(
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn GetNextUmsListItem(
    UmsContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn QueryUmsThreadInformation(
    UmsThread: *c_void,
    UmsThreadInfoClass: RTL_UMS_THREAD_INFO_CLASS,
    UmsThreadInformation: [*]u8,
    UmsThreadInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetUmsThreadInformation(
    UmsThread: *c_void,
    UmsThreadInfoClass: RTL_UMS_THREAD_INFO_CLASS,
    UmsThreadInformation: *c_void,
    UmsThreadInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DeleteUmsThreadContext(
    UmsThread: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateUmsThreadContext(
    lpUmsThread: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn EnterUmsSchedulingMode(
    SchedulerStartupInfo: *UMS_SCHEDULER_STARTUP_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetUmsSystemThreadInformation(
    ThreadHandle: HANDLE,
    SystemThreadInfo: *UMS_SYSTEM_THREAD_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadAffinityMask(
    hThread: HANDLE,
    dwThreadAffinityMask: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn SetProcessDEPPolicy(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetProcessDEPPolicy(
    hProcess: HANDLE,
    lpFlags: *u32,
    lpPermanent: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn RequestWakeupLatency(
    latency: LATENCY_TIME,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsSystemResumeAutomatic(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadExecutionState(
    esFlags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn PowerCreateRequest(
    Context: *REASON_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn PowerSetRequest(
    PowerRequest: HANDLE,
    RequestType: POWER_REQUEST_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn PowerClearRequest(
    PowerRequest: HANDLE,
    RequestType: POWER_REQUEST_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn PulseEvent(
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetDevicePowerState(
    hDevice: HANDLE,
    pfOn: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LoadModule(
    lpModuleName: [*:0]const u8,
    lpParameterBlock: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn WinExec(
    lpCmdLine: [*:0]const u8,
    uCmdShow: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn ClearCommBreak(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ClearCommError(
    hFile: HANDLE,
    lpErrors: ?*u32,
    lpStat: ?*COMSTAT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetupComm(
    hFile: HANDLE,
    dwInQueue: u32,
    dwOutQueue: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn EscapeCommFunction(
    hFile: HANDLE,
    dwFunc: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCommConfig(
    hCommDev: HANDLE,
    lpCC: ?[*]COMMCONFIG,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCommMask(
    hFile: HANDLE,
    lpEvtMask: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCommProperties(
    hFile: HANDLE,
    lpCommProp: *COMMPROP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCommModemStatus(
    hFile: HANDLE,
    lpModemStat: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCommState(
    hFile: HANDLE,
    lpDCB: *DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCommTimeouts(
    hFile: HANDLE,
    lpCommTimeouts: *COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn PurgeComm(
    hFile: HANDLE,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCommBreak(
    hFile: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCommConfig(
    hCommDev: HANDLE,
    lpCC: [*]COMMCONFIG,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCommMask(
    hFile: HANDLE,
    dwEvtMask: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCommState(
    hFile: HANDLE,
    lpDCB: *DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCommTimeouts(
    hFile: HANDLE,
    lpCommTimeouts: *COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn TransmitCommChar(
    hFile: HANDLE,
    cChar: i8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WaitCommEvent(
    hFile: HANDLE,
    lpEvtMask: *u32,
    lpOverlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-comm-l1-1-1" fn OpenCommPort(
    uPortNumber: u32,
    dwDesiredAccess: u32,
    dwFlagsAndAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "api-ms-win-core-comm-l1-1-2" fn GetCommPorts(
    lpPortNumbers: [*]u32,
    uPortNumbersCount: u32,
    puPortNumbersFound: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetTapePosition(
    hDevice: HANDLE,
    dwPositionMethod: u32,
    dwPartition: u32,
    dwOffsetLow: u32,
    dwOffsetHigh: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetTapePosition(
    hDevice: HANDLE,
    dwPositionType: u32,
    lpdwPartition: *u32,
    lpdwOffsetLow: *u32,
    lpdwOffsetHigh: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn PrepareTape(
    hDevice: HANDLE,
    dwOperation: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn EraseTape(
    hDevice: HANDLE,
    dwEraseType: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn CreateTapePartition(
    hDevice: HANDLE,
    dwPartitionMethod: u32,
    dwCount: u32,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn WriteTapemark(
    hDevice: HANDLE,
    dwTapemarkType: u32,
    dwTapemarkCount: u32,
    bImmediate: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetTapeStatus(
    hDevice: HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetTapeParameters(
    hDevice: HANDLE,
    dwOperation: u32,
    lpdwSize: *u32,
    lpTapeInformation: [*]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetTapeParameters(
    hDevice: HANDLE,
    dwOperation: u32,
    lpTapeInformation: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetSystemDEPPolicy(
) callconv(@import("std").os.windows.WINAPI) DEP_SYSTEM_POLICY_TYPE;

pub extern "KERNEL32" fn CreateMailslotA(
    lpName: [*:0]const u8,
    nMaxMessageSize: u32,
    lReadTimeout: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateMailslotW(
    lpName: [*:0]const u16,
    nMaxMessageSize: u32,
    lReadTimeout: u32,
    lpSecurityAttributes: ?*SECURITY_ATTRIBUTES,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn GetMailslotInfo(
    hMailslot: HANDLE,
    lpMaxMessageSize: ?*u32,
    lpNextSize: ?*u32,
    lpMessageCount: ?*u32,
    lpReadTimeout: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetMailslotInfo(
    hMailslot: HANDLE,
    lReadTimeout: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SignalObjectAndWait(
    hObjectToSignal: HANDLE,
    hObjectToWaitOn: HANDLE,
    dwMilliseconds: u32,
    bAlertable: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn BackupRead(
    hFile: HANDLE,
    lpBuffer: [*:0]u8,
    nNumberOfBytesToRead: u32,
    lpNumberOfBytesRead: *u32,
    bAbort: BOOL,
    bProcessSecurity: BOOL,
    lpContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn BackupSeek(
    hFile: HANDLE,
    dwLowBytesToSeek: u32,
    dwHighBytesToSeek: u32,
    lpdwLowByteSeeked: *u32,
    lpdwHighByteSeeked: *u32,
    lpContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn BackupWrite(
    hFile: HANDLE,
    lpBuffer: [*:0]u8,
    nNumberOfBytesToWrite: u32,
    lpNumberOfBytesWritten: *u32,
    bAbort: BOOL,
    bProcessSecurity: BOOL,
    lpContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateSemaphoreA(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateSemaphoreExA(
    lpSemaphoreAttributes: ?*SECURITY_ATTRIBUTES,
    lInitialCount: i32,
    lMaximumCount: i32,
    lpName: ?[*:0]const u8,
    dwFlags: u32,
    dwDesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateFileMappingA(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: PAGE_TYPE,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn CreateFileMappingNumaA(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*SECURITY_ATTRIBUTES,
    flProtect: u32,
    dwMaximumSizeHigh: u32,
    dwMaximumSizeLow: u32,
    lpName: ?[*:0]const u8,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenFileMappingA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn LoadPackagedLibrary(
    lpwLibFileName: [*:0]const u16,
    Reserved: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn QueryFullProcessImageNameA(
    hProcess: HANDLE,
    dwFlags: u32,
    lpExeName: [*:0]u8,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn QueryFullProcessImageNameW(
    hProcess: HANDLE,
    dwFlags: u32,
    lpExeName: [*:0]u16,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetDllDirectoryA(
    lpPathName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetDllDirectoryW(
    lpPathName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetDllDirectoryA(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetDllDirectoryW(
    nBufferLength: u32,
    lpBuffer: ?[*:0]u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetNamedPipeHandleStateA(
    hNamedPipe: HANDLE,
    lpState: ?*u32,
    lpCurInstances: ?*u32,
    lpMaxCollectionCount: ?*u32,
    lpCollectDataTimeout: ?*u32,
    lpUserName: ?[*:0]u8,
    nMaxUserNameSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CallNamedPipeA(
    lpNamedPipeName: [*:0]const u8,
    lpInBuffer: ?[*]u8,
    nInBufferSize: u32,
    lpOutBuffer: ?[*]u8,
    nOutBufferSize: u32,
    lpBytesRead: *u32,
    nTimeOut: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeClientComputerNameA(
    Pipe: HANDLE,
    ClientComputerName: [*:0]u8,
    ClientComputerNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeClientProcessId(
    Pipe: HANDLE,
    ClientProcessId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeClientSessionId(
    Pipe: HANDLE,
    ClientSessionId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeServerProcessId(
    Pipe: HANDLE,
    ServerProcessId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNamedPipeServerSessionId(
    Pipe: HANDLE,
    ServerSessionId: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ClearEventLogA(
    hEventLog: HANDLE,
    lpBackupFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ClearEventLogW(
    hEventLog: HANDLE,
    lpBackupFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn BackupEventLogA(
    hEventLog: HANDLE,
    lpBackupFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn BackupEventLogW(
    hEventLog: HANDLE,
    lpBackupFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn CloseEventLog(
    hEventLog: EventLogHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn DeregisterEventSource(
    hEventLog: EventSourceHandle,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn NotifyChangeEventLog(
    hEventLog: HANDLE,
    hEvent: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn GetNumberOfEventLogRecords(
    hEventLog: HANDLE,
    NumberOfRecords: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn GetOldestEventLogRecord(
    hEventLog: HANDLE,
    OldestRecord: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn OpenEventLogA(
    lpUNCServerName: ?[*:0]const u8,
    lpSourceName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

pub extern "ADVAPI32" fn OpenEventLogW(
    lpUNCServerName: ?[*:0]const u16,
    lpSourceName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

pub extern "ADVAPI32" fn RegisterEventSourceA(
    lpUNCServerName: ?[*:0]const u8,
    lpSourceName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) EventSourceHandle;

pub extern "ADVAPI32" fn RegisterEventSourceW(
    lpUNCServerName: ?[*:0]const u16,
    lpSourceName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "ADVAPI32" fn OpenBackupEventLogA(
    lpUNCServerName: ?[*:0]const u8,
    lpFileName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

pub extern "ADVAPI32" fn OpenBackupEventLogW(
    lpUNCServerName: ?[*:0]const u16,
    lpFileName: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) EventLogHandle;

pub extern "ADVAPI32" fn ReadEventLogA(
    hEventLog: HANDLE,
    dwReadFlags: u32,
    dwRecordOffset: u32,
    lpBuffer: [*]u8,
    nNumberOfBytesToRead: u32,
    pnBytesRead: *u32,
    pnMinNumberOfBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ReadEventLogW(
    hEventLog: HANDLE,
    dwReadFlags: u32,
    dwRecordOffset: u32,
    lpBuffer: [*]u8,
    nNumberOfBytesToRead: u32,
    pnBytesRead: *u32,
    pnMinNumberOfBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ReportEventA(
    hEventLog: HANDLE,
    wType: u16,
    wCategory: u16,
    dwEventID: u32,
    lpUserSid: ?*c_void,
    wNumStrings: u16,
    dwDataSize: u32,
    lpStrings: ?[*]?PSTR,
    lpRawData: ?[*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ReportEventW(
    hEventLog: HANDLE,
    wType: u16,
    wCategory: u16,
    dwEventID: u32,
    lpUserSid: ?*c_void,
    wNumStrings: u16,
    dwDataSize: u32,
    lpStrings: ?[*]?PWSTR,
    lpRawData: ?[*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn GetEventLogInformation(
    hEventLog: HANDLE,
    dwInfoLevel: u32,
    lpBuffer: [*]u8,
    cbBufSize: u32,
    pcbBytesNeeded: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn MapViewOfFileExNuma(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: u32,
    dwFileOffsetHigh: u32,
    dwFileOffsetLow: u32,
    dwNumberOfBytesToMap: ?*c_void,
    lpBaseAddress: ?*c_void,
    nndPreferred: u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn IsBadReadPtr(
    lp: ?*const c_void,
    ucb: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsBadWritePtr(
    lp: ?*c_void,
    ucb: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsBadCodePtr(
    lpfn: ?FARPROC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsBadStringPtrA(
    lpsz: ?[*:0]const u8,
    ucchMax: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsBadStringPtrW(
    lpsz: ?[*:0]const u16,
    ucchMax: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn BuildCommDCBA(
    lpDef: [*:0]const u8,
    lpDCB: *DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn BuildCommDCBW(
    lpDef: [*:0]const u16,
    lpDCB: *DCB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn BuildCommDCBAndTimeoutsA(
    lpDef: [*:0]const u8,
    lpDCB: *DCB,
    lpCommTimeouts: *COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn BuildCommDCBAndTimeoutsW(
    lpDef: [*:0]const u16,
    lpDCB: *DCB,
    lpCommTimeouts: *COMMTIMEOUTS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CommConfigDialogA(
    lpszName: [*:0]const u8,
    hWnd: HWND,
    lpCC: *COMMCONFIG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CommConfigDialogW(
    lpszName: [*:0]const u16,
    hWnd: HWND,
    lpCC: *COMMCONFIG,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetDefaultCommConfigA(
    lpszName: [*:0]const u8,
    lpCC: [*]COMMCONFIG,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetDefaultCommConfigW(
    lpszName: [*:0]const u16,
    lpCC: [*]COMMCONFIG,
    lpdwSize: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetDefaultCommConfigA(
    lpszName: [*:0]const u8,
    lpCC: [*]COMMCONFIG,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetDefaultCommConfigW(
    lpszName: [*:0]const u16,
    lpCC: [*]COMMCONFIG,
    dwSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn CreateProcessWithLogonW(
    lpUsername: [*:0]const u16,
    lpDomain: ?[*:0]const u16,
    lpPassword: [*:0]const u16,
    dwLogonFlags: u32,
    lpApplicationName: ?[*:0]const u16,
    lpCommandLine: ?PWSTR,
    dwCreationFlags: u32,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u16,
    lpStartupInfo: *STARTUPINFOW,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn CreateProcessWithTokenW(
    hToken: HANDLE,
    dwLogonFlags: u32,
    lpApplicationName: ?[*:0]const u16,
    lpCommandLine: ?PWSTR,
    dwCreationFlags: u32,
    lpEnvironment: ?*c_void,
    lpCurrentDirectory: ?[*:0]const u16,
    lpStartupInfo: *STARTUPINFOW,
    lpProcessInformation: *PROCESS_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn RegisterWaitForSingleObject(
    phNewWaitObject: *HANDLE,
    hObject: HANDLE,
    Callback: WAITORTIMERCALLBACK,
    Context: ?*c_void,
    dwMilliseconds: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn UnregisterWait(
    WaitHandle: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn BindIoCompletionCallback(
    FileHandle: HANDLE,
    Function: LPOVERLAPPED_COMPLETION_ROUTINE,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DeleteTimerQueue(
    TimerQueue: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateBoundaryDescriptorA(
    Name: [*:0]const u8,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BoundaryDescriptorHandle;

pub extern "KERNEL32" fn AddIntegrityLabelToBoundaryDescriptor(
    BoundaryDescriptor: *HANDLE,
    IntegrityLabel: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetSystemPowerState(
    fSuspend: BOOL,
    fForce: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetSystemPowerStatus(
    lpSystemPowerStatus: *SYSTEM_POWER_STATUS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn MapUserPhysicalPagesScatter(
    VirtualAddresses: [*]*c_void,
    NumberOfPages: ?*c_void,
    PageArray: ?[*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CreateJobObjectA(
    lpJobAttributes: ?*SECURITY_ATTRIBUTES,
    lpName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn OpenJobObjectA(
    dwDesiredAccess: u32,
    bInheritHandle: BOOL,
    lpName: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HANDLE;

pub extern "KERNEL32" fn GetActiveProcessorGroupCount(
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "KERNEL32" fn GetMaximumProcessorGroupCount(
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "KERNEL32" fn GetActiveProcessorCount(
    GroupNumber: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetMaximumProcessorCount(
    GroupNumber: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn GetNumaProcessorNode(
    Processor: u8,
    NodeNumber: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumaNodeNumberFromHandle(
    hFile: HANDLE,
    NodeNumber: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumaProcessorNodeEx(
    Processor: *PROCESSOR_NUMBER,
    NodeNumber: *u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumaNodeProcessorMask(
    Node: u8,
    ProcessorMask: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumaAvailableMemoryNode(
    Node: u8,
    AvailableBytes: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumaAvailableMemoryNodeEx(
    Node: u16,
    AvailableBytes: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetNumaProximityNode(
    ProximityId: u32,
    NodeNumber: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn AddSecureMemoryCacheCallback(
    pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn RemoveSecureMemoryCacheCallback(
    pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn InitiateSystemShutdownA(
    lpMachineName: ?PSTR,
    lpMessage: ?PSTR,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn InitiateSystemShutdownW(
    lpMachineName: ?PWSTR,
    lpMessage: ?PWSTR,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AbortSystemShutdownA(
    lpMachineName: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AbortSystemShutdownW(
    lpMachineName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn InitiateSystemShutdownExA(
    lpMachineName: ?PSTR,
    lpMessage: ?PSTR,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn InitiateSystemShutdownExW(
    lpMachineName: ?PWSTR,
    lpMessage: ?PWSTR,
    dwTimeout: u32,
    bForceAppsClosed: BOOL,
    bRebootAfterShutdown: BOOL,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn InitiateShutdownA(
    lpMachineName: ?PSTR,
    lpMessage: ?PSTR,
    dwGracePeriod: u32,
    dwShutdownFlags: u32,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ADVAPI32" fn InitiateShutdownW(
    lpMachineName: ?PWSTR,
    lpMessage: ?PWSTR,
    dwGracePeriod: u32,
    dwShutdownFlags: u32,
    dwReason: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "ntdll" fn NtQueryInformationProcess(
    ProcessHandle: HANDLE,
    ProcessInformationClass: PROCESSINFOCLASS,
    ProcessInformation: *c_void,
    ProcessInformationLength: u32,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub extern "ntdll" fn NtQueryInformationThread(
    ThreadHandle: HANDLE,
    ThreadInformationClass: THREADINFOCLASS,
    ThreadInformation: *c_void,
    ThreadInformationLength: u32,
    ReturnLength: *u32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (183)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const ENUMRESLANGPROC = ENUMRESLANGPROCA;
        pub const PGET_MODULE_HANDLE_EX = PGET_MODULE_HANDLE_EXA;
        pub const PRINTER_INFO_1 = PRINTER_INFO_1A;
        pub const PRINTER_INFO_2 = PRINTER_INFO_2A;
        pub const PRINTER_INFO_4 = PRINTER_INFO_4A;
        pub const PRINTER_INFO_5 = PRINTER_INFO_5A;
        pub const PRINTER_INFO_7 = PRINTER_INFO_7A;
        pub const PRINTER_INFO_8 = PRINTER_INFO_8A;
        pub const PRINTER_INFO_9 = PRINTER_INFO_9A;
        pub const JOB_INFO_1 = JOB_INFO_1A;
        pub const JOB_INFO_2 = JOB_INFO_2A;
        pub const JOB_INFO_4 = JOB_INFO_4A;
        pub const ADDJOB_INFO_1 = ADDJOB_INFO_1A;
        pub const DRIVER_INFO_1 = DRIVER_INFO_1A;
        pub const DRIVER_INFO_2 = DRIVER_INFO_2A;
        pub const DRIVER_INFO_3 = DRIVER_INFO_3A;
        pub const DRIVER_INFO_4 = DRIVER_INFO_4A;
        pub const DRIVER_INFO_5 = DRIVER_INFO_5A;
        pub const DRIVER_INFO_6 = DRIVER_INFO_6A;
        pub const DRIVER_INFO_8 = DRIVER_INFO_8A;
        pub const DOC_INFO_1 = DOC_INFO_1A;
        pub const FORM_INFO_1 = FORM_INFO_1A;
        pub const FORM_INFO_2 = FORM_INFO_2A;
        pub const DOC_INFO_2 = DOC_INFO_2A;
        pub const DOC_INFO_3 = DOC_INFO_3A;
        pub const PRINTPROCESSOR_INFO_1 = PRINTPROCESSOR_INFO_1A;
        pub const PORT_INFO_1 = PORT_INFO_1A;
        pub const PORT_INFO_2 = PORT_INFO_2A;
        pub const PORT_INFO_3 = PORT_INFO_3A;
        pub const MONITOR_INFO_1 = MONITOR_INFO_1A;
        pub const MONITOR_INFO_2 = MONITOR_INFO_2A;
        pub const DATATYPES_INFO_1 = DATATYPES_INFO_1A;
        pub const PRINTER_DEFAULTS = PRINTER_DEFAULTSA;
        pub const PRINTER_ENUM_VALUES = PRINTER_ENUM_VALUESA;
        pub const PROVIDOR_INFO_1 = PROVIDOR_INFO_1A;
        pub const PROVIDOR_INFO_2 = PROVIDOR_INFO_2A;
        pub const PRINTER_OPTIONS = PRINTER_OPTIONSA;
        pub const PRINTER_CONNECTION_INFO_1 = PRINTER_CONNECTION_INFO_1A;
        pub const CORE_PRINTER_DRIVER = CORE_PRINTER_DRIVERA;
        pub const DEV_BROADCAST_PORT_ = DEV_BROADCAST_PORT_A;
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = DEV_BROADCAST_DEVICEINTERFACE_A;
        pub const STARTUPINFO = STARTUPINFOA;
        pub const STARTUPINFOEX = STARTUPINFOEXA;
        pub const RegisterDeviceNotification = RegisterDeviceNotificationA;
        pub const CreateMutex = CreateMutexA;
        pub const CreateEvent = CreateEventA;
        pub const OpenEvent = OpenEventA;
        pub const CreateMutexEx = CreateMutexExA;
        pub const CreateEventEx = CreateEventExA;
        pub const CreateSemaphoreEx = CreateSemaphoreExA;
        pub const CreateSemaphore = CreateSemaphoreA;
        pub const CreateJobObject = CreateJobObjectA;
        pub const OpenJobObject = OpenJobObjectA;
        pub const CreateBoundaryDescriptor = CreateBoundaryDescriptorA;
        pub const GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameA;
        pub const GetNamedPipeHandleState = GetNamedPipeHandleStateA;
        pub const CallNamedPipe = CallNamedPipeA;
        pub const CreateFileMapping = CreateFileMappingA;
        pub const OpenFileMapping = OpenFileMappingA;
        pub const CreateFileMappingNuma = CreateFileMappingNumaA;
        pub const LoadEnclaveImage = LoadEnclaveImageA;
        pub const GetModuleFileName = GetModuleFileNameA;
        pub const GetModuleHandle = GetModuleHandleA;
        pub const GetModuleHandleEx = GetModuleHandleExA;
        pub const LoadLibraryEx = LoadLibraryExA;
        pub const LoadLibrary = LoadLibraryA;
        pub const ReadConsoleInput = ReadConsoleInputA;
        pub const PeekConsoleInput = PeekConsoleInputA;
        pub const ReadConsole = ReadConsoleA;
        pub const WriteConsole = WriteConsoleA;
        pub const FillConsoleOutputCharacter = FillConsoleOutputCharacterA;
        pub const WriteConsoleOutputCharacter = WriteConsoleOutputCharacterA;
        pub const ReadConsoleOutputCharacter = ReadConsoleOutputCharacterA;
        pub const WriteConsoleInput = WriteConsoleInputA;
        pub const ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferA;
        pub const WriteConsoleOutput = WriteConsoleOutputA;
        pub const ReadConsoleOutput = ReadConsoleOutputA;
        pub const GetConsoleTitle = GetConsoleTitleA;
        pub const GetConsoleOriginalTitle = GetConsoleOriginalTitleA;
        pub const SetConsoleTitle = SetConsoleTitleA;
        pub const AddConsoleAlias = AddConsoleAliasA;
        pub const GetConsoleAlias = GetConsoleAliasA;
        pub const GetConsoleAliasesLength = GetConsoleAliasesLengthA;
        pub const GetConsoleAliasExesLength = GetConsoleAliasExesLengthA;
        pub const GetConsoleAliases = GetConsoleAliasesA;
        pub const GetConsoleAliasExes = GetConsoleAliasExesA;
        pub const ExpungeConsoleCommandHistory = ExpungeConsoleCommandHistoryA;
        pub const SetConsoleNumberOfCommands = SetConsoleNumberOfCommandsA;
        pub const GetConsoleCommandHistoryLength = GetConsoleCommandHistoryLengthA;
        pub const GetConsoleCommandHistory = GetConsoleCommandHistoryA;
        pub const EnumPrinters = EnumPrintersA;
        pub const OpenPrinter = OpenPrinterA;
        pub const ResetPrinter = ResetPrinterA;
        pub const SetJob = SetJobA;
        pub const GetJob = GetJobA;
        pub const EnumJobs = EnumJobsA;
        pub const AddPrinter = AddPrinterA;
        pub const SetPrinter = SetPrinterA;
        pub const GetPrinter = GetPrinterA;
        pub const AddPrinterDriver = AddPrinterDriverA;
        pub const AddPrinterDriverEx = AddPrinterDriverExA;
        pub const EnumPrinterDrivers = EnumPrinterDriversA;
        pub const GetPrinterDriver = GetPrinterDriverA;
        pub const GetPrinterDriverDirectory = GetPrinterDriverDirectoryA;
        pub const DeletePrinterDriver = DeletePrinterDriverA;
        pub const DeletePrinterDriverEx = DeletePrinterDriverExA;
        pub const AddPrintProcessor = AddPrintProcessorA;
        pub const EnumPrintProcessors = EnumPrintProcessorsA;
        pub const GetPrintProcessorDirectory = GetPrintProcessorDirectoryA;
        pub const EnumPrintProcessorDatatypes = EnumPrintProcessorDatatypesA;
        pub const DeletePrintProcessor = DeletePrintProcessorA;
        pub const StartDocPrinter = StartDocPrinterA;
        pub const AddJob = AddJobA;
        pub const DocumentProperties = DocumentPropertiesA;
        pub const AdvancedDocumentProperties = AdvancedDocumentPropertiesA;
        pub const GetPrinterData = GetPrinterDataA;
        pub const GetPrinterDataEx = GetPrinterDataExA;
        pub const EnumPrinterData = EnumPrinterDataA;
        pub const EnumPrinterDataEx = EnumPrinterDataExA;
        pub const EnumPrinterKey = EnumPrinterKeyA;
        pub const SetPrinterData = SetPrinterDataA;
        pub const SetPrinterDataEx = SetPrinterDataExA;
        pub const DeletePrinterData = DeletePrinterDataA;
        pub const DeletePrinterDataEx = DeletePrinterDataExA;
        pub const DeletePrinterKey = DeletePrinterKeyA;
        pub const PrinterMessageBox = PrinterMessageBoxA;
        pub const AddForm = AddFormA;
        pub const DeleteForm = DeleteFormA;
        pub const GetForm = GetFormA;
        pub const SetForm = SetFormA;
        pub const EnumForms = EnumFormsA;
        pub const EnumMonitors = EnumMonitorsA;
        pub const AddMonitor = AddMonitorA;
        pub const DeleteMonitor = DeleteMonitorA;
        pub const EnumPorts = EnumPortsA;
        pub const AddPort = AddPortA;
        pub const ConfigurePort = ConfigurePortA;
        pub const DeletePort = DeletePortA;
        pub const GetDefaultPrinter = GetDefaultPrinterA;
        pub const SetDefaultPrinter = SetDefaultPrinterA;
        pub const SetPort = SetPortA;
        pub const AddPrinterConnection = AddPrinterConnectionA;
        pub const DeletePrinterConnection = DeletePrinterConnectionA;
        pub const AddPrintProvidor = AddPrintProvidorA;
        pub const DeletePrintProvidor = DeletePrintProvidorA;
        pub const IsValidDevmode = IsValidDevmodeA;
        pub const OpenPrinter2 = OpenPrinter2A;
        pub const AddPrinterConnection2 = AddPrinterConnection2A;
        pub const InstallPrinterDriverFromPackage = InstallPrinterDriverFromPackageA;
        pub const UploadPrinterDriverPackage = UploadPrinterDriverPackageA;
        pub const GetCorePrinterDrivers = GetCorePrinterDriversA;
        pub const CorePrinterDriverInstalled = CorePrinterDriverInstalledA;
        pub const GetPrinterDriverPackagePath = GetPrinterDriverPackagePathA;
        pub const DeletePrinterDriverPackage = DeletePrinterDriverPackageA;
        pub const GetPrinterDriver2 = GetPrinterDriver2A;
        pub const GetCommandLine = GetCommandLineA;
        pub const FreeEnvironmentStrings = FreeEnvironmentStringsA;
        pub const GetEnvironmentVariable = GetEnvironmentVariableA;
        pub const SetEnvironmentVariable = SetEnvironmentVariableA;
        pub const NeedCurrentDirectoryForExePath = NeedCurrentDirectoryForExePathA;
        pub const CreateProcess = CreateProcessA;
        pub const CreateProcessAsUser = CreateProcessAsUserA;
        pub const CreateMailslot = CreateMailslotA;
        pub const QueryFullProcessImageName = QueryFullProcessImageNameA;
        pub const SetDllDirectory = SetDllDirectoryA;
        pub const GetDllDirectory = GetDllDirectoryA;
        pub const ClearEventLog = ClearEventLogA;
        pub const BackupEventLog = BackupEventLogA;
        pub const OpenEventLog = OpenEventLogA;
        pub const RegisterEventSource = RegisterEventSourceA;
        pub const OpenBackupEventLog = OpenBackupEventLogA;
        pub const ReadEventLog = ReadEventLogA;
        pub const ReportEvent = ReportEventA;
        pub const IsBadStringPtr = IsBadStringPtrA;
        pub const BuildCommDCB = BuildCommDCBA;
        pub const BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
        pub const CommConfigDialog = CommConfigDialogA;
        pub const GetDefaultCommConfig = GetDefaultCommConfigA;
        pub const SetDefaultCommConfig = SetDefaultCommConfigA;
        pub const InitiateSystemShutdown = InitiateSystemShutdownA;
        pub const AbortSystemShutdown = AbortSystemShutdownA;
        pub const InitiateSystemShutdownEx = InitiateSystemShutdownExA;
        pub const InitiateShutdown = InitiateShutdownA;
    },
    .wide => struct {
        pub const ENUMRESLANGPROC = ENUMRESLANGPROCW;
        pub const PGET_MODULE_HANDLE_EX = PGET_MODULE_HANDLE_EXW;
        pub const PRINTER_INFO_1 = PRINTER_INFO_1W;
        pub const PRINTER_INFO_2 = PRINTER_INFO_2W;
        pub const PRINTER_INFO_4 = PRINTER_INFO_4W;
        pub const PRINTER_INFO_5 = PRINTER_INFO_5W;
        pub const PRINTER_INFO_7 = PRINTER_INFO_7W;
        pub const PRINTER_INFO_8 = PRINTER_INFO_8W;
        pub const PRINTER_INFO_9 = PRINTER_INFO_9W;
        pub const JOB_INFO_1 = JOB_INFO_1W;
        pub const JOB_INFO_2 = JOB_INFO_2W;
        pub const JOB_INFO_4 = JOB_INFO_4W;
        pub const ADDJOB_INFO_1 = ADDJOB_INFO_1W;
        pub const DRIVER_INFO_1 = DRIVER_INFO_1W;
        pub const DRIVER_INFO_2 = DRIVER_INFO_2W;
        pub const DRIVER_INFO_3 = DRIVER_INFO_3W;
        pub const DRIVER_INFO_4 = DRIVER_INFO_4W;
        pub const DRIVER_INFO_5 = DRIVER_INFO_5W;
        pub const DRIVER_INFO_6 = DRIVER_INFO_6W;
        pub const DRIVER_INFO_8 = DRIVER_INFO_8W;
        pub const DOC_INFO_1 = DOC_INFO_1W;
        pub const FORM_INFO_1 = FORM_INFO_1W;
        pub const FORM_INFO_2 = FORM_INFO_2W;
        pub const DOC_INFO_2 = DOC_INFO_2W;
        pub const DOC_INFO_3 = DOC_INFO_3W;
        pub const PRINTPROCESSOR_INFO_1 = PRINTPROCESSOR_INFO_1W;
        pub const PORT_INFO_1 = PORT_INFO_1W;
        pub const PORT_INFO_2 = PORT_INFO_2W;
        pub const PORT_INFO_3 = PORT_INFO_3W;
        pub const MONITOR_INFO_1 = MONITOR_INFO_1W;
        pub const MONITOR_INFO_2 = MONITOR_INFO_2W;
        pub const DATATYPES_INFO_1 = DATATYPES_INFO_1W;
        pub const PRINTER_DEFAULTS = PRINTER_DEFAULTSW;
        pub const PRINTER_ENUM_VALUES = PRINTER_ENUM_VALUESW;
        pub const PROVIDOR_INFO_1 = PROVIDOR_INFO_1W;
        pub const PROVIDOR_INFO_2 = PROVIDOR_INFO_2W;
        pub const PRINTER_OPTIONS = PRINTER_OPTIONSW;
        pub const PRINTER_CONNECTION_INFO_1 = PRINTER_CONNECTION_INFO_1W;
        pub const CORE_PRINTER_DRIVER = CORE_PRINTER_DRIVERW;
        pub const DEV_BROADCAST_PORT_ = DEV_BROADCAST_PORT_W;
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = DEV_BROADCAST_DEVICEINTERFACE_W;
        pub const STARTUPINFO = STARTUPINFOW;
        pub const STARTUPINFOEX = STARTUPINFOEXW;
        pub const RegisterDeviceNotification = RegisterDeviceNotificationW;
        pub const CreateMutex = CreateMutexW;
        pub const CreateEvent = CreateEventW;
        pub const OpenEvent = OpenEventW;
        pub const CreateMutexEx = CreateMutexExW;
        pub const CreateEventEx = CreateEventExW;
        pub const CreateSemaphoreEx = CreateSemaphoreExW;
        pub const CreateSemaphore = CreateSemaphoreW;
        pub const CreateJobObject = CreateJobObjectW;
        pub const OpenJobObject = OpenJobObjectW;
        pub const CreateBoundaryDescriptor = CreateBoundaryDescriptorW;
        pub const GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameW;
        pub const GetNamedPipeHandleState = GetNamedPipeHandleStateW;
        pub const CallNamedPipe = CallNamedPipeW;
        pub const CreateFileMapping = CreateFileMappingW;
        pub const OpenFileMapping = OpenFileMappingW;
        pub const CreateFileMappingNuma = CreateFileMappingNumaW;
        pub const LoadEnclaveImage = LoadEnclaveImageW;
        pub const GetModuleFileName = GetModuleFileNameW;
        pub const GetModuleHandle = GetModuleHandleW;
        pub const GetModuleHandleEx = GetModuleHandleExW;
        pub const LoadLibraryEx = LoadLibraryExW;
        pub const LoadLibrary = LoadLibraryW;
        pub const ReadConsoleInput = ReadConsoleInputW;
        pub const PeekConsoleInput = PeekConsoleInputW;
        pub const ReadConsole = ReadConsoleW;
        pub const WriteConsole = WriteConsoleW;
        pub const FillConsoleOutputCharacter = FillConsoleOutputCharacterW;
        pub const WriteConsoleOutputCharacter = WriteConsoleOutputCharacterW;
        pub const ReadConsoleOutputCharacter = ReadConsoleOutputCharacterW;
        pub const WriteConsoleInput = WriteConsoleInputW;
        pub const ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferW;
        pub const WriteConsoleOutput = WriteConsoleOutputW;
        pub const ReadConsoleOutput = ReadConsoleOutputW;
        pub const GetConsoleTitle = GetConsoleTitleW;
        pub const GetConsoleOriginalTitle = GetConsoleOriginalTitleW;
        pub const SetConsoleTitle = SetConsoleTitleW;
        pub const AddConsoleAlias = AddConsoleAliasW;
        pub const GetConsoleAlias = GetConsoleAliasW;
        pub const GetConsoleAliasesLength = GetConsoleAliasesLengthW;
        pub const GetConsoleAliasExesLength = GetConsoleAliasExesLengthW;
        pub const GetConsoleAliases = GetConsoleAliasesW;
        pub const GetConsoleAliasExes = GetConsoleAliasExesW;
        pub const ExpungeConsoleCommandHistory = ExpungeConsoleCommandHistoryW;
        pub const SetConsoleNumberOfCommands = SetConsoleNumberOfCommandsW;
        pub const GetConsoleCommandHistoryLength = GetConsoleCommandHistoryLengthW;
        pub const GetConsoleCommandHistory = GetConsoleCommandHistoryW;
        pub const EnumPrinters = EnumPrintersW;
        pub const OpenPrinter = OpenPrinterW;
        pub const ResetPrinter = ResetPrinterW;
        pub const SetJob = SetJobW;
        pub const GetJob = GetJobW;
        pub const EnumJobs = EnumJobsW;
        pub const AddPrinter = AddPrinterW;
        pub const SetPrinter = SetPrinterW;
        pub const GetPrinter = GetPrinterW;
        pub const AddPrinterDriver = AddPrinterDriverW;
        pub const AddPrinterDriverEx = AddPrinterDriverExW;
        pub const EnumPrinterDrivers = EnumPrinterDriversW;
        pub const GetPrinterDriver = GetPrinterDriverW;
        pub const GetPrinterDriverDirectory = GetPrinterDriverDirectoryW;
        pub const DeletePrinterDriver = DeletePrinterDriverW;
        pub const DeletePrinterDriverEx = DeletePrinterDriverExW;
        pub const AddPrintProcessor = AddPrintProcessorW;
        pub const EnumPrintProcessors = EnumPrintProcessorsW;
        pub const GetPrintProcessorDirectory = GetPrintProcessorDirectoryW;
        pub const EnumPrintProcessorDatatypes = EnumPrintProcessorDatatypesW;
        pub const DeletePrintProcessor = DeletePrintProcessorW;
        pub const StartDocPrinter = StartDocPrinterW;
        pub const AddJob = AddJobW;
        pub const DocumentProperties = DocumentPropertiesW;
        pub const AdvancedDocumentProperties = AdvancedDocumentPropertiesW;
        pub const GetPrinterData = GetPrinterDataW;
        pub const GetPrinterDataEx = GetPrinterDataExW;
        pub const EnumPrinterData = EnumPrinterDataW;
        pub const EnumPrinterDataEx = EnumPrinterDataExW;
        pub const EnumPrinterKey = EnumPrinterKeyW;
        pub const SetPrinterData = SetPrinterDataW;
        pub const SetPrinterDataEx = SetPrinterDataExW;
        pub const DeletePrinterData = DeletePrinterDataW;
        pub const DeletePrinterDataEx = DeletePrinterDataExW;
        pub const DeletePrinterKey = DeletePrinterKeyW;
        pub const PrinterMessageBox = PrinterMessageBoxW;
        pub const AddForm = AddFormW;
        pub const DeleteForm = DeleteFormW;
        pub const GetForm = GetFormW;
        pub const SetForm = SetFormW;
        pub const EnumForms = EnumFormsW;
        pub const EnumMonitors = EnumMonitorsW;
        pub const AddMonitor = AddMonitorW;
        pub const DeleteMonitor = DeleteMonitorW;
        pub const EnumPorts = EnumPortsW;
        pub const AddPort = AddPortW;
        pub const ConfigurePort = ConfigurePortW;
        pub const DeletePort = DeletePortW;
        pub const GetDefaultPrinter = GetDefaultPrinterW;
        pub const SetDefaultPrinter = SetDefaultPrinterW;
        pub const SetPort = SetPortW;
        pub const AddPrinterConnection = AddPrinterConnectionW;
        pub const DeletePrinterConnection = DeletePrinterConnectionW;
        pub const AddPrintProvidor = AddPrintProvidorW;
        pub const DeletePrintProvidor = DeletePrintProvidorW;
        pub const IsValidDevmode = IsValidDevmodeW;
        pub const OpenPrinter2 = OpenPrinter2W;
        pub const AddPrinterConnection2 = AddPrinterConnection2W;
        pub const InstallPrinterDriverFromPackage = InstallPrinterDriverFromPackageW;
        pub const UploadPrinterDriverPackage = UploadPrinterDriverPackageW;
        pub const GetCorePrinterDrivers = GetCorePrinterDriversW;
        pub const CorePrinterDriverInstalled = CorePrinterDriverInstalledW;
        pub const GetPrinterDriverPackagePath = GetPrinterDriverPackagePathW;
        pub const DeletePrinterDriverPackage = DeletePrinterDriverPackageW;
        pub const GetPrinterDriver2 = GetPrinterDriver2W;
        pub const GetCommandLine = GetCommandLineW;
        pub const FreeEnvironmentStrings = FreeEnvironmentStringsW;
        pub const GetEnvironmentVariable = GetEnvironmentVariableW;
        pub const SetEnvironmentVariable = SetEnvironmentVariableW;
        pub const NeedCurrentDirectoryForExePath = NeedCurrentDirectoryForExePathW;
        pub const CreateProcess = CreateProcessW;
        pub const CreateProcessAsUser = CreateProcessAsUserW;
        pub const CreateMailslot = CreateMailslotW;
        pub const QueryFullProcessImageName = QueryFullProcessImageNameW;
        pub const SetDllDirectory = SetDllDirectoryW;
        pub const GetDllDirectory = GetDllDirectoryW;
        pub const ClearEventLog = ClearEventLogW;
        pub const BackupEventLog = BackupEventLogW;
        pub const OpenEventLog = OpenEventLogW;
        pub const RegisterEventSource = RegisterEventSourceW;
        pub const OpenBackupEventLog = OpenBackupEventLogW;
        pub const ReadEventLog = ReadEventLogW;
        pub const ReportEvent = ReportEventW;
        pub const IsBadStringPtr = IsBadStringPtrW;
        pub const BuildCommDCB = BuildCommDCBW;
        pub const BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsW;
        pub const CommConfigDialog = CommConfigDialogW;
        pub const GetDefaultCommConfig = GetDefaultCommConfigW;
        pub const SetDefaultCommConfig = SetDefaultCommConfigW;
        pub const InitiateSystemShutdown = InitiateSystemShutdownW;
        pub const AbortSystemShutdown = AbortSystemShutdownW;
        pub const InitiateSystemShutdownEx = InitiateSystemShutdownExW;
        pub const InitiateShutdown = InitiateShutdownW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const ENUMRESLANGPROC = *opaque{};
        pub const PGET_MODULE_HANDLE_EX = *opaque{};
        pub const PRINTER_INFO_1 = *opaque{};
        pub const PRINTER_INFO_2 = *opaque{};
        pub const PRINTER_INFO_4 = *opaque{};
        pub const PRINTER_INFO_5 = *opaque{};
        pub const PRINTER_INFO_7 = *opaque{};
        pub const PRINTER_INFO_8 = *opaque{};
        pub const PRINTER_INFO_9 = *opaque{};
        pub const JOB_INFO_1 = *opaque{};
        pub const JOB_INFO_2 = *opaque{};
        pub const JOB_INFO_4 = *opaque{};
        pub const ADDJOB_INFO_1 = *opaque{};
        pub const DRIVER_INFO_1 = *opaque{};
        pub const DRIVER_INFO_2 = *opaque{};
        pub const DRIVER_INFO_3 = *opaque{};
        pub const DRIVER_INFO_4 = *opaque{};
        pub const DRIVER_INFO_5 = *opaque{};
        pub const DRIVER_INFO_6 = *opaque{};
        pub const DRIVER_INFO_8 = *opaque{};
        pub const DOC_INFO_1 = *opaque{};
        pub const FORM_INFO_1 = *opaque{};
        pub const FORM_INFO_2 = *opaque{};
        pub const DOC_INFO_2 = *opaque{};
        pub const DOC_INFO_3 = *opaque{};
        pub const PRINTPROCESSOR_INFO_1 = *opaque{};
        pub const PORT_INFO_1 = *opaque{};
        pub const PORT_INFO_2 = *opaque{};
        pub const PORT_INFO_3 = *opaque{};
        pub const MONITOR_INFO_1 = *opaque{};
        pub const MONITOR_INFO_2 = *opaque{};
        pub const DATATYPES_INFO_1 = *opaque{};
        pub const PRINTER_DEFAULTS = *opaque{};
        pub const PRINTER_ENUM_VALUES = *opaque{};
        pub const PROVIDOR_INFO_1 = *opaque{};
        pub const PROVIDOR_INFO_2 = *opaque{};
        pub const PRINTER_OPTIONS = *opaque{};
        pub const PRINTER_CONNECTION_INFO_1 = *opaque{};
        pub const CORE_PRINTER_DRIVER = *opaque{};
        pub const DEV_BROADCAST_PORT_ = *opaque{};
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = *opaque{};
        pub const STARTUPINFO = *opaque{};
        pub const STARTUPINFOEX = *opaque{};
        pub const RegisterDeviceNotification = *opaque{};
        pub const CreateMutex = *opaque{};
        pub const CreateEvent = *opaque{};
        pub const OpenEvent = *opaque{};
        pub const CreateMutexEx = *opaque{};
        pub const CreateEventEx = *opaque{};
        pub const CreateSemaphoreEx = *opaque{};
        pub const CreateSemaphore = *opaque{};
        pub const CreateJobObject = *opaque{};
        pub const OpenJobObject = *opaque{};
        pub const CreateBoundaryDescriptor = *opaque{};
        pub const GetNamedPipeClientComputerName = *opaque{};
        pub const GetNamedPipeHandleState = *opaque{};
        pub const CallNamedPipe = *opaque{};
        pub const CreateFileMapping = *opaque{};
        pub const OpenFileMapping = *opaque{};
        pub const CreateFileMappingNuma = *opaque{};
        pub const LoadEnclaveImage = *opaque{};
        pub const GetModuleFileName = *opaque{};
        pub const GetModuleHandle = *opaque{};
        pub const GetModuleHandleEx = *opaque{};
        pub const LoadLibraryEx = *opaque{};
        pub const LoadLibrary = *opaque{};
        pub const ReadConsoleInput = *opaque{};
        pub const PeekConsoleInput = *opaque{};
        pub const ReadConsole = *opaque{};
        pub const WriteConsole = *opaque{};
        pub const FillConsoleOutputCharacter = *opaque{};
        pub const WriteConsoleOutputCharacter = *opaque{};
        pub const ReadConsoleOutputCharacter = *opaque{};
        pub const WriteConsoleInput = *opaque{};
        pub const ScrollConsoleScreenBuffer = *opaque{};
        pub const WriteConsoleOutput = *opaque{};
        pub const ReadConsoleOutput = *opaque{};
        pub const GetConsoleTitle = *opaque{};
        pub const GetConsoleOriginalTitle = *opaque{};
        pub const SetConsoleTitle = *opaque{};
        pub const AddConsoleAlias = *opaque{};
        pub const GetConsoleAlias = *opaque{};
        pub const GetConsoleAliasesLength = *opaque{};
        pub const GetConsoleAliasExesLength = *opaque{};
        pub const GetConsoleAliases = *opaque{};
        pub const GetConsoleAliasExes = *opaque{};
        pub const ExpungeConsoleCommandHistory = *opaque{};
        pub const SetConsoleNumberOfCommands = *opaque{};
        pub const GetConsoleCommandHistoryLength = *opaque{};
        pub const GetConsoleCommandHistory = *opaque{};
        pub const EnumPrinters = *opaque{};
        pub const OpenPrinter = *opaque{};
        pub const ResetPrinter = *opaque{};
        pub const SetJob = *opaque{};
        pub const GetJob = *opaque{};
        pub const EnumJobs = *opaque{};
        pub const AddPrinter = *opaque{};
        pub const SetPrinter = *opaque{};
        pub const GetPrinter = *opaque{};
        pub const AddPrinterDriver = *opaque{};
        pub const AddPrinterDriverEx = *opaque{};
        pub const EnumPrinterDrivers = *opaque{};
        pub const GetPrinterDriver = *opaque{};
        pub const GetPrinterDriverDirectory = *opaque{};
        pub const DeletePrinterDriver = *opaque{};
        pub const DeletePrinterDriverEx = *opaque{};
        pub const AddPrintProcessor = *opaque{};
        pub const EnumPrintProcessors = *opaque{};
        pub const GetPrintProcessorDirectory = *opaque{};
        pub const EnumPrintProcessorDatatypes = *opaque{};
        pub const DeletePrintProcessor = *opaque{};
        pub const StartDocPrinter = *opaque{};
        pub const AddJob = *opaque{};
        pub const DocumentProperties = *opaque{};
        pub const AdvancedDocumentProperties = *opaque{};
        pub const GetPrinterData = *opaque{};
        pub const GetPrinterDataEx = *opaque{};
        pub const EnumPrinterData = *opaque{};
        pub const EnumPrinterDataEx = *opaque{};
        pub const EnumPrinterKey = *opaque{};
        pub const SetPrinterData = *opaque{};
        pub const SetPrinterDataEx = *opaque{};
        pub const DeletePrinterData = *opaque{};
        pub const DeletePrinterDataEx = *opaque{};
        pub const DeletePrinterKey = *opaque{};
        pub const PrinterMessageBox = *opaque{};
        pub const AddForm = *opaque{};
        pub const DeleteForm = *opaque{};
        pub const GetForm = *opaque{};
        pub const SetForm = *opaque{};
        pub const EnumForms = *opaque{};
        pub const EnumMonitors = *opaque{};
        pub const AddMonitor = *opaque{};
        pub const DeleteMonitor = *opaque{};
        pub const EnumPorts = *opaque{};
        pub const AddPort = *opaque{};
        pub const ConfigurePort = *opaque{};
        pub const DeletePort = *opaque{};
        pub const GetDefaultPrinter = *opaque{};
        pub const SetDefaultPrinter = *opaque{};
        pub const SetPort = *opaque{};
        pub const AddPrinterConnection = *opaque{};
        pub const DeletePrinterConnection = *opaque{};
        pub const AddPrintProvidor = *opaque{};
        pub const DeletePrintProvidor = *opaque{};
        pub const IsValidDevmode = *opaque{};
        pub const OpenPrinter2 = *opaque{};
        pub const AddPrinterConnection2 = *opaque{};
        pub const InstallPrinterDriverFromPackage = *opaque{};
        pub const UploadPrinterDriverPackage = *opaque{};
        pub const GetCorePrinterDrivers = *opaque{};
        pub const CorePrinterDriverInstalled = *opaque{};
        pub const GetPrinterDriverPackagePath = *opaque{};
        pub const DeletePrinterDriverPackage = *opaque{};
        pub const GetPrinterDriver2 = *opaque{};
        pub const GetCommandLine = *opaque{};
        pub const FreeEnvironmentStrings = *opaque{};
        pub const GetEnvironmentVariable = *opaque{};
        pub const SetEnvironmentVariable = *opaque{};
        pub const NeedCurrentDirectoryForExePath = *opaque{};
        pub const CreateProcess = *opaque{};
        pub const CreateProcessAsUser = *opaque{};
        pub const CreateMailslot = *opaque{};
        pub const QueryFullProcessImageName = *opaque{};
        pub const SetDllDirectory = *opaque{};
        pub const GetDllDirectory = *opaque{};
        pub const ClearEventLog = *opaque{};
        pub const BackupEventLog = *opaque{};
        pub const OpenEventLog = *opaque{};
        pub const RegisterEventSource = *opaque{};
        pub const OpenBackupEventLog = *opaque{};
        pub const ReadEventLog = *opaque{};
        pub const ReportEvent = *opaque{};
        pub const IsBadStringPtr = *opaque{};
        pub const BuildCommDCB = *opaque{};
        pub const BuildCommDCBAndTimeouts = *opaque{};
        pub const CommConfigDialog = *opaque{};
        pub const GetDefaultCommConfig = *opaque{};
        pub const SetDefaultCommConfig = *opaque{};
        pub const InitiateSystemShutdown = *opaque{};
        pub const AbortSystemShutdown = *opaque{};
        pub const InitiateSystemShutdownEx = *opaque{};
        pub const InitiateShutdown = *opaque{};
    } else struct {
        pub const ENUMRESLANGPROC = @compileError("'ENUMRESLANGPROC' requires that UNICODE be set to true or false in the root module");
        pub const PGET_MODULE_HANDLE_EX = @compileError("'PGET_MODULE_HANDLE_EX' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_1 = @compileError("'PRINTER_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_2 = @compileError("'PRINTER_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_4 = @compileError("'PRINTER_INFO_4' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_5 = @compileError("'PRINTER_INFO_5' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_7 = @compileError("'PRINTER_INFO_7' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_8 = @compileError("'PRINTER_INFO_8' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_INFO_9 = @compileError("'PRINTER_INFO_9' requires that UNICODE be set to true or false in the root module");
        pub const JOB_INFO_1 = @compileError("'JOB_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const JOB_INFO_2 = @compileError("'JOB_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const JOB_INFO_4 = @compileError("'JOB_INFO_4' requires that UNICODE be set to true or false in the root module");
        pub const ADDJOB_INFO_1 = @compileError("'ADDJOB_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_1 = @compileError("'DRIVER_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_2 = @compileError("'DRIVER_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_3 = @compileError("'DRIVER_INFO_3' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_4 = @compileError("'DRIVER_INFO_4' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_5 = @compileError("'DRIVER_INFO_5' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_6 = @compileError("'DRIVER_INFO_6' requires that UNICODE be set to true or false in the root module");
        pub const DRIVER_INFO_8 = @compileError("'DRIVER_INFO_8' requires that UNICODE be set to true or false in the root module");
        pub const DOC_INFO_1 = @compileError("'DOC_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const FORM_INFO_1 = @compileError("'FORM_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const FORM_INFO_2 = @compileError("'FORM_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DOC_INFO_2 = @compileError("'DOC_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DOC_INFO_3 = @compileError("'DOC_INFO_3' requires that UNICODE be set to true or false in the root module");
        pub const PRINTPROCESSOR_INFO_1 = @compileError("'PRINTPROCESSOR_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PORT_INFO_1 = @compileError("'PORT_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PORT_INFO_2 = @compileError("'PORT_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const PORT_INFO_3 = @compileError("'PORT_INFO_3' requires that UNICODE be set to true or false in the root module");
        pub const MONITOR_INFO_1 = @compileError("'MONITOR_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const MONITOR_INFO_2 = @compileError("'MONITOR_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const DATATYPES_INFO_1 = @compileError("'DATATYPES_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_DEFAULTS = @compileError("'PRINTER_DEFAULTS' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_ENUM_VALUES = @compileError("'PRINTER_ENUM_VALUES' requires that UNICODE be set to true or false in the root module");
        pub const PROVIDOR_INFO_1 = @compileError("'PROVIDOR_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const PROVIDOR_INFO_2 = @compileError("'PROVIDOR_INFO_2' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_OPTIONS = @compileError("'PRINTER_OPTIONS' requires that UNICODE be set to true or false in the root module");
        pub const PRINTER_CONNECTION_INFO_1 = @compileError("'PRINTER_CONNECTION_INFO_1' requires that UNICODE be set to true or false in the root module");
        pub const CORE_PRINTER_DRIVER = @compileError("'CORE_PRINTER_DRIVER' requires that UNICODE be set to true or false in the root module");
        pub const DEV_BROADCAST_PORT_ = @compileError("'DEV_BROADCAST_PORT_' requires that UNICODE be set to true or false in the root module");
        pub const DEV_BROADCAST_DEVICEINTERFACE_ = @compileError("'DEV_BROADCAST_DEVICEINTERFACE_' requires that UNICODE be set to true or false in the root module");
        pub const STARTUPINFO = @compileError("'STARTUPINFO' requires that UNICODE be set to true or false in the root module");
        pub const STARTUPINFOEX = @compileError("'STARTUPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const RegisterDeviceNotification = @compileError("'RegisterDeviceNotification' requires that UNICODE be set to true or false in the root module");
        pub const CreateMutex = @compileError("'CreateMutex' requires that UNICODE be set to true or false in the root module");
        pub const CreateEvent = @compileError("'CreateEvent' requires that UNICODE be set to true or false in the root module");
        pub const OpenEvent = @compileError("'OpenEvent' requires that UNICODE be set to true or false in the root module");
        pub const CreateMutexEx = @compileError("'CreateMutexEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateEventEx = @compileError("'CreateEventEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateSemaphoreEx = @compileError("'CreateSemaphoreEx' requires that UNICODE be set to true or false in the root module");
        pub const CreateSemaphore = @compileError("'CreateSemaphore' requires that UNICODE be set to true or false in the root module");
        pub const CreateJobObject = @compileError("'CreateJobObject' requires that UNICODE be set to true or false in the root module");
        pub const OpenJobObject = @compileError("'OpenJobObject' requires that UNICODE be set to true or false in the root module");
        pub const CreateBoundaryDescriptor = @compileError("'CreateBoundaryDescriptor' requires that UNICODE be set to true or false in the root module");
        pub const GetNamedPipeClientComputerName = @compileError("'GetNamedPipeClientComputerName' requires that UNICODE be set to true or false in the root module");
        pub const GetNamedPipeHandleState = @compileError("'GetNamedPipeHandleState' requires that UNICODE be set to true or false in the root module");
        pub const CallNamedPipe = @compileError("'CallNamedPipe' requires that UNICODE be set to true or false in the root module");
        pub const CreateFileMapping = @compileError("'CreateFileMapping' requires that UNICODE be set to true or false in the root module");
        pub const OpenFileMapping = @compileError("'OpenFileMapping' requires that UNICODE be set to true or false in the root module");
        pub const CreateFileMappingNuma = @compileError("'CreateFileMappingNuma' requires that UNICODE be set to true or false in the root module");
        pub const LoadEnclaveImage = @compileError("'LoadEnclaveImage' requires that UNICODE be set to true or false in the root module");
        pub const GetModuleFileName = @compileError("'GetModuleFileName' requires that UNICODE be set to true or false in the root module");
        pub const GetModuleHandle = @compileError("'GetModuleHandle' requires that UNICODE be set to true or false in the root module");
        pub const GetModuleHandleEx = @compileError("'GetModuleHandleEx' requires that UNICODE be set to true or false in the root module");
        pub const LoadLibraryEx = @compileError("'LoadLibraryEx' requires that UNICODE be set to true or false in the root module");
        pub const LoadLibrary = @compileError("'LoadLibrary' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsoleInput = @compileError("'ReadConsoleInput' requires that UNICODE be set to true or false in the root module");
        pub const PeekConsoleInput = @compileError("'PeekConsoleInput' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsole = @compileError("'ReadConsole' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsole = @compileError("'WriteConsole' requires that UNICODE be set to true or false in the root module");
        pub const FillConsoleOutputCharacter = @compileError("'FillConsoleOutputCharacter' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsoleOutputCharacter = @compileError("'WriteConsoleOutputCharacter' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsoleOutputCharacter = @compileError("'ReadConsoleOutputCharacter' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsoleInput = @compileError("'WriteConsoleInput' requires that UNICODE be set to true or false in the root module");
        pub const ScrollConsoleScreenBuffer = @compileError("'ScrollConsoleScreenBuffer' requires that UNICODE be set to true or false in the root module");
        pub const WriteConsoleOutput = @compileError("'WriteConsoleOutput' requires that UNICODE be set to true or false in the root module");
        pub const ReadConsoleOutput = @compileError("'ReadConsoleOutput' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleTitle = @compileError("'GetConsoleTitle' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleOriginalTitle = @compileError("'GetConsoleOriginalTitle' requires that UNICODE be set to true or false in the root module");
        pub const SetConsoleTitle = @compileError("'SetConsoleTitle' requires that UNICODE be set to true or false in the root module");
        pub const AddConsoleAlias = @compileError("'AddConsoleAlias' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAlias = @compileError("'GetConsoleAlias' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliasesLength = @compileError("'GetConsoleAliasesLength' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliasExesLength = @compileError("'GetConsoleAliasExesLength' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliases = @compileError("'GetConsoleAliases' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleAliasExes = @compileError("'GetConsoleAliasExes' requires that UNICODE be set to true or false in the root module");
        pub const ExpungeConsoleCommandHistory = @compileError("'ExpungeConsoleCommandHistory' requires that UNICODE be set to true or false in the root module");
        pub const SetConsoleNumberOfCommands = @compileError("'SetConsoleNumberOfCommands' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleCommandHistoryLength = @compileError("'GetConsoleCommandHistoryLength' requires that UNICODE be set to true or false in the root module");
        pub const GetConsoleCommandHistory = @compileError("'GetConsoleCommandHistory' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinters = @compileError("'EnumPrinters' requires that UNICODE be set to true or false in the root module");
        pub const OpenPrinter = @compileError("'OpenPrinter' requires that UNICODE be set to true or false in the root module");
        pub const ResetPrinter = @compileError("'ResetPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetJob = @compileError("'SetJob' requires that UNICODE be set to true or false in the root module");
        pub const GetJob = @compileError("'GetJob' requires that UNICODE be set to true or false in the root module");
        pub const EnumJobs = @compileError("'EnumJobs' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinter = @compileError("'AddPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetPrinter = @compileError("'SetPrinter' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinter = @compileError("'GetPrinter' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterDriver = @compileError("'AddPrinterDriver' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterDriverEx = @compileError("'AddPrinterDriverEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterDrivers = @compileError("'EnumPrinterDrivers' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriver = @compileError("'GetPrinterDriver' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriverDirectory = @compileError("'GetPrinterDriverDirectory' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDriver = @compileError("'DeletePrinterDriver' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDriverEx = @compileError("'DeletePrinterDriverEx' requires that UNICODE be set to true or false in the root module");
        pub const AddPrintProcessor = @compileError("'AddPrintProcessor' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrintProcessors = @compileError("'EnumPrintProcessors' requires that UNICODE be set to true or false in the root module");
        pub const GetPrintProcessorDirectory = @compileError("'GetPrintProcessorDirectory' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrintProcessorDatatypes = @compileError("'EnumPrintProcessorDatatypes' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrintProcessor = @compileError("'DeletePrintProcessor' requires that UNICODE be set to true or false in the root module");
        pub const StartDocPrinter = @compileError("'StartDocPrinter' requires that UNICODE be set to true or false in the root module");
        pub const AddJob = @compileError("'AddJob' requires that UNICODE be set to true or false in the root module");
        pub const DocumentProperties = @compileError("'DocumentProperties' requires that UNICODE be set to true or false in the root module");
        pub const AdvancedDocumentProperties = @compileError("'AdvancedDocumentProperties' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterData = @compileError("'GetPrinterData' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDataEx = @compileError("'GetPrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterData = @compileError("'EnumPrinterData' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterDataEx = @compileError("'EnumPrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const EnumPrinterKey = @compileError("'EnumPrinterKey' requires that UNICODE be set to true or false in the root module");
        pub const SetPrinterData = @compileError("'SetPrinterData' requires that UNICODE be set to true or false in the root module");
        pub const SetPrinterDataEx = @compileError("'SetPrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterData = @compileError("'DeletePrinterData' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDataEx = @compileError("'DeletePrinterDataEx' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterKey = @compileError("'DeletePrinterKey' requires that UNICODE be set to true or false in the root module");
        pub const PrinterMessageBox = @compileError("'PrinterMessageBox' requires that UNICODE be set to true or false in the root module");
        pub const AddForm = @compileError("'AddForm' requires that UNICODE be set to true or false in the root module");
        pub const DeleteForm = @compileError("'DeleteForm' requires that UNICODE be set to true or false in the root module");
        pub const GetForm = @compileError("'GetForm' requires that UNICODE be set to true or false in the root module");
        pub const SetForm = @compileError("'SetForm' requires that UNICODE be set to true or false in the root module");
        pub const EnumForms = @compileError("'EnumForms' requires that UNICODE be set to true or false in the root module");
        pub const EnumMonitors = @compileError("'EnumMonitors' requires that UNICODE be set to true or false in the root module");
        pub const AddMonitor = @compileError("'AddMonitor' requires that UNICODE be set to true or false in the root module");
        pub const DeleteMonitor = @compileError("'DeleteMonitor' requires that UNICODE be set to true or false in the root module");
        pub const EnumPorts = @compileError("'EnumPorts' requires that UNICODE be set to true or false in the root module");
        pub const AddPort = @compileError("'AddPort' requires that UNICODE be set to true or false in the root module");
        pub const ConfigurePort = @compileError("'ConfigurePort' requires that UNICODE be set to true or false in the root module");
        pub const DeletePort = @compileError("'DeletePort' requires that UNICODE be set to true or false in the root module");
        pub const GetDefaultPrinter = @compileError("'GetDefaultPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetDefaultPrinter = @compileError("'SetDefaultPrinter' requires that UNICODE be set to true or false in the root module");
        pub const SetPort = @compileError("'SetPort' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterConnection = @compileError("'AddPrinterConnection' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterConnection = @compileError("'DeletePrinterConnection' requires that UNICODE be set to true or false in the root module");
        pub const AddPrintProvidor = @compileError("'AddPrintProvidor' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrintProvidor = @compileError("'DeletePrintProvidor' requires that UNICODE be set to true or false in the root module");
        pub const IsValidDevmode = @compileError("'IsValidDevmode' requires that UNICODE be set to true or false in the root module");
        pub const OpenPrinter2 = @compileError("'OpenPrinter2' requires that UNICODE be set to true or false in the root module");
        pub const AddPrinterConnection2 = @compileError("'AddPrinterConnection2' requires that UNICODE be set to true or false in the root module");
        pub const InstallPrinterDriverFromPackage = @compileError("'InstallPrinterDriverFromPackage' requires that UNICODE be set to true or false in the root module");
        pub const UploadPrinterDriverPackage = @compileError("'UploadPrinterDriverPackage' requires that UNICODE be set to true or false in the root module");
        pub const GetCorePrinterDrivers = @compileError("'GetCorePrinterDrivers' requires that UNICODE be set to true or false in the root module");
        pub const CorePrinterDriverInstalled = @compileError("'CorePrinterDriverInstalled' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriverPackagePath = @compileError("'GetPrinterDriverPackagePath' requires that UNICODE be set to true or false in the root module");
        pub const DeletePrinterDriverPackage = @compileError("'DeletePrinterDriverPackage' requires that UNICODE be set to true or false in the root module");
        pub const GetPrinterDriver2 = @compileError("'GetPrinterDriver2' requires that UNICODE be set to true or false in the root module");
        pub const GetCommandLine = @compileError("'GetCommandLine' requires that UNICODE be set to true or false in the root module");
        pub const FreeEnvironmentStrings = @compileError("'FreeEnvironmentStrings' requires that UNICODE be set to true or false in the root module");
        pub const GetEnvironmentVariable = @compileError("'GetEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const SetEnvironmentVariable = @compileError("'SetEnvironmentVariable' requires that UNICODE be set to true or false in the root module");
        pub const NeedCurrentDirectoryForExePath = @compileError("'NeedCurrentDirectoryForExePath' requires that UNICODE be set to true or false in the root module");
        pub const CreateProcess = @compileError("'CreateProcess' requires that UNICODE be set to true or false in the root module");
        pub const CreateProcessAsUser = @compileError("'CreateProcessAsUser' requires that UNICODE be set to true or false in the root module");
        pub const CreateMailslot = @compileError("'CreateMailslot' requires that UNICODE be set to true or false in the root module");
        pub const QueryFullProcessImageName = @compileError("'QueryFullProcessImageName' requires that UNICODE be set to true or false in the root module");
        pub const SetDllDirectory = @compileError("'SetDllDirectory' requires that UNICODE be set to true or false in the root module");
        pub const GetDllDirectory = @compileError("'GetDllDirectory' requires that UNICODE be set to true or false in the root module");
        pub const ClearEventLog = @compileError("'ClearEventLog' requires that UNICODE be set to true or false in the root module");
        pub const BackupEventLog = @compileError("'BackupEventLog' requires that UNICODE be set to true or false in the root module");
        pub const OpenEventLog = @compileError("'OpenEventLog' requires that UNICODE be set to true or false in the root module");
        pub const RegisterEventSource = @compileError("'RegisterEventSource' requires that UNICODE be set to true or false in the root module");
        pub const OpenBackupEventLog = @compileError("'OpenBackupEventLog' requires that UNICODE be set to true or false in the root module");
        pub const ReadEventLog = @compileError("'ReadEventLog' requires that UNICODE be set to true or false in the root module");
        pub const ReportEvent = @compileError("'ReportEvent' requires that UNICODE be set to true or false in the root module");
        pub const IsBadStringPtr = @compileError("'IsBadStringPtr' requires that UNICODE be set to true or false in the root module");
        pub const BuildCommDCB = @compileError("'BuildCommDCB' requires that UNICODE be set to true or false in the root module");
        pub const BuildCommDCBAndTimeouts = @compileError("'BuildCommDCBAndTimeouts' requires that UNICODE be set to true or false in the root module");
        pub const CommConfigDialog = @compileError("'CommConfigDialog' requires that UNICODE be set to true or false in the root module");
        pub const GetDefaultCommConfig = @compileError("'GetDefaultCommConfig' requires that UNICODE be set to true or false in the root module");
        pub const SetDefaultCommConfig = @compileError("'SetDefaultCommConfig' requires that UNICODE be set to true or false in the root module");
        pub const InitiateSystemShutdown = @compileError("'InitiateSystemShutdown' requires that UNICODE be set to true or false in the root module");
        pub const AbortSystemShutdown = @compileError("'AbortSystemShutdown' requires that UNICODE be set to true or false in the root module");
        pub const InitiateSystemShutdownEx = @compileError("'InitiateSystemShutdownEx' requires that UNICODE be set to true or false in the root module");
        pub const InitiateShutdown = @compileError("'InitiateShutdown' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (96)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const STORAGE_PROPERTY_ID = @import("file_system.zig").STORAGE_PROPERTY_ID;
const DDSCAPS = @import("direct_draw.zig").DDSCAPS;
const FILETIME = @import("windows_programming.zig").FILETIME;
const IXMLDOMDocument = @import("windows_programming.zig").IXMLDOMDocument;
const OBJECT_TYPE_LIST = @import("security.zig").OBJECT_TYPE_LIST;
const DXGI_RGBA = @import("dxgi.zig").DXGI_RGBA;
const TTPOLYGONHEADER = @import("gdi.zig").TTPOLYGONHEADER;
const PIXELFORMATDESCRIPTOR = @import("open_gl.zig").PIXELFORMATDESCRIPTOR;
const DD_CALLBACKS = @import("display_devices.zig").DD_CALLBACKS;
const LOGCOLORSPACEW = @import("windows_color_system.zig").LOGCOLORSPACEW;
const TOKEN_PRIVILEGES = @import("security.zig").TOKEN_PRIVILEGES;
const PROCESS_CREATION_FLAGS = @import("windows_programming.zig").PROCESS_CREATION_FLAGS;
const PROCESSINFOCLASS = @import("windows_programming.zig").PROCESSINFOCLASS;
const ENUMRESNAMEPROCW = @import("menus_and_resources.zig").ENUMRESNAMEPROCW;
const DEVMODEA = @import("xps.zig").DEVMODEA;
const THREAD_INFORMATION_CLASS = @import("windows_programming.zig").THREAD_INFORMATION_CLASS;
const PERBANDINFO = @import("display_devices.zig").PERBANDINFO;
const EXCEPTION_ROUTINE = @import("kernel.zig").EXCEPTION_ROUTINE;
const VIRTUAL_STORAGE_TYPE = @import("virtual_storage.zig").VIRTUAL_STORAGE_TYPE;
const DD_PALETTECALLBACKS = @import("display_devices.zig").DD_PALETTECALLBACKS;
const LIST_ENTRY = @import("kernel.zig").LIST_ENTRY;
const SINGLE_LIST_ENTRY = @import("kernel.zig").SINGLE_LIST_ENTRY;
const DDCOLORKEY = @import("direct_show.zig").DDCOLORKEY;
const XLATEOBJ = @import("display_devices.zig").XLATEOBJ;
const STROBJ = @import("display_devices.zig").STROBJ;
const DDVIDEOPORTCONNECT = @import("core_audio.zig").DDVIDEOPORTCONNECT;
const UNICODE_STRING = @import("security.zig").UNICODE_STRING;
const GLYPHDATA = @import("display_devices.zig").GLYPHDATA;
const FONTOBJ = @import("display_devices.zig").FONTOBJ;
const TOKEN_GROUPS = @import("security.zig").TOKEN_GROUPS;
const BSTR = @import("automation.zig").BSTR;
const IMAGE_FILE_HEADER = @import("debug.zig").IMAGE_FILE_HEADER;
const RECT = @import("display_devices.zig").RECT;
const PALOBJ = @import("display_devices.zig").PALOBJ;
const DEP_SYSTEM_POLICY_TYPE = @import("windows_programming.zig").DEP_SYSTEM_POLICY_TYPE;
const ACE_HEADER = @import("security.zig").ACE_HEADER;
const BRUSHOBJ = @import("display_devices.zig").BRUSHOBJ;
const DD_DIRECTDRAW_GLOBAL = @import("display_devices.zig").DD_DIRECTDRAW_GLOBAL;
const SYSTEMTIME = @import("windows_programming.zig").SYSTEMTIME;
const DD_HALINFO = @import("display_devices.zig").DD_HALINFO;
const DEVINFO = @import("display_devices.zig").DEVINFO;
const TRIVERTEX = @import("gdi.zig").TRIVERTEX;
const PARTITION_STYLE = @import("file_system.zig").PARTITION_STYLE;
const HDC = @import("gdi.zig").HDC;
const DDVIDEOPORTCAPS = @import("display_devices.zig").DDVIDEOPORTCAPS;
const GDIINFO = @import("display_devices.zig").GDIINFO;
const POINTL = @import("display_devices.zig").POINTL;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const HKEY = @import("windows_programming.zig").HKEY;
const PROCESS_INFORMATION_CLASS = @import("security.zig").PROCESS_INFORMATION_CLASS;
const HRESULT = @import("com.zig").HRESULT;
const LPOVERLAPPED_COMPLETION_ROUTINE = @import("file_system.zig").LPOVERLAPPED_COMPLETION_ROUTINE;
const RPC_BINDING_VECTOR = @import("rpc.zig").RPC_BINDING_VECTOR;
const LUID = @import("kernel.zig").LUID;
const PRIVILEGE_SET = @import("security.zig").PRIVILEGE_SET;
const WOW64_LDT_ENTRY = @import("debug.zig").WOW64_LDT_ENTRY;
const VIDEOMEMORY = @import("display_devices.zig").VIDEOMEMORY;
const BLENDOBJ = @import("display_devices.zig").BLENDOBJ;
const DDSURFACEDESC = @import("direct_draw.zig").DDSURFACEDESC;
const IMAGE_DATA_DIRECTORY = @import("debug.zig").IMAGE_DATA_DIRECTORY;
const STORAGE_PROTOCOL_TYPE = @import("file_system.zig").STORAGE_PROTOCOL_TYPE;
const IFIMETRICS = @import("display_devices.zig").IFIMETRICS;
const COLORADJUSTMENT = @import("gdi.zig").COLORADJUSTMENT;
const PPS_POST_PROCESS_INIT_ROUTINE = @import("windows_programming.zig").PPS_POST_PROCESS_INIT_ROUTINE;
const CLIPOBJ = @import("display_devices.zig").CLIPOBJ;
const DRVENABLEDATA = @import("display_devices.zig").DRVENABLEDATA;
const DD_SURFACECALLBACKS = @import("display_devices.zig").DD_SURFACECALLBACKS;
const RPC_MESSAGE = @import("rpc.zig").RPC_MESSAGE;
const PDD_GETDRIVERINFO = @import("display_devices.zig").PDD_GETDRIVERINFO;
const THREADINFOCLASS = @import("windows_programming.zig").THREADINFOCLASS;
const OSVERSIONINFOEXW = @import("windows_programming.zig").OSVERSIONINFOEXW;
const DEVMODEW = @import("display_devices.zig").DEVMODEW;
const IUnknown = @import("com.zig").IUnknown;
const LINEATTRS = @import("display_devices.zig").LINEATTRS;
const LPFIBER_START_ROUTINE = @import("windows_programming.zig").LPFIBER_START_ROUTINE;
const WNDOBJ = @import("display_devices.zig").WNDOBJ;
const GENERIC_MAPPING = @import("security.zig").GENERIC_MAPPING;
const DD_SURFACE_LOCAL = @import("display_devices.zig").DD_SURFACE_LOCAL;
const SURFOBJ = @import("display_devices.zig").SURFOBJ;
const FILE_ID_128 = @import("file_system.zig").FILE_ID_128;
const HBITMAP = @import("gdi.zig").HBITMAP;
const DESIGNVECTOR = @import("gdi.zig").DESIGNVECTOR;
const HWND = @import("windows_and_messaging.zig").HWND;
const SECURITY_IMPERSONATION_LEVEL = @import("security.zig").SECURITY_IMPERSONATION_LEVEL;
const VARIANT = @import("automation.zig").VARIANT;
const DDPIXELFORMAT = @import("direct_draw.zig").DDPIXELFORMAT;
const D3DMATRIX = @import("direct3d9.zig").D3DMATRIX;
const PUMS_SCHEDULER_ENTRY_POINT = @import("windows_programming.zig").PUMS_SCHEDULER_ENTRY_POINT;
const PATHOBJ = @import("display_devices.zig").PATHOBJ;
const POINT = @import("display_devices.zig").POINT;
const VIDEOMEMORYINFO = @import("display_devices.zig").VIDEOMEMORYINFO;
const SIZE = @import("display_devices.zig").SIZE;
const RECTL = @import("display_devices.zig").RECTL;
const DD_BLTDATA = @import("display_devices.zig").DD_BLTDATA;
const DD_DIRECTDRAW_LOCAL = @import("display_devices.zig").DD_DIRECTDRAW_LOCAL;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = ENCLAVE_TARGET_FUNCTION;
    _ = PENCLAVE_TARGET_FUNCTION;
    _ = LPENCLAVE_TARGET_FUNCTION;
    _ = PIMAGE_TLS_CALLBACK;
    _ = RTL_UMS_SCHEDULER_ENTRY_POINT;
    _ = PRTL_UMS_SCHEDULER_ENTRY_POINT;
    _ = PAPCFUNC;
    _ = WAITORTIMERCALLBACKFUNC;
    _ = WORKERCALLBACKFUNC;
    _ = APC_CALLBACK_FUNCTION;
    _ = WAITORTIMERCALLBACK;
    _ = PFLS_CALLBACK_FUNCTION;
    _ = PSECURE_MEMORY_CACHE_CALLBACK;
    _ = PTP_SIMPLE_CALLBACK;
    _ = PTP_CLEANUP_GROUP_CANCEL_CALLBACK;
    _ = PTP_WORK_CALLBACK;
    _ = PTP_TIMER_CALLBACK;
    _ = PTP_WAIT_CALLBACK;
    _ = FARPROC;
    _ = NEARPROC;
    _ = PROC;
    _ = PINIT_ONCE_FN;
    _ = PTIMERAPCROUTINE;
    _ = PTP_WIN32_IO_CALLBACK;
    _ = PTHREAD_START_ROUTINE;
    _ = LPTHREAD_START_ROUTINE;
    _ = PENCLAVE_ROUTINE;
    _ = LPENCLAVE_ROUTINE;
    _ = BAD_MEMORY_CALLBACK_ROUTINE;
    _ = PBAD_MEMORY_CALLBACK_ROUTINE;
    _ = ENUMRESLANGPROCA;
    _ = ENUMRESLANGPROCW;
    _ = PGET_MODULE_HANDLE_EXA;
    _ = PGET_MODULE_HANDLE_EXW;
    _ = PHANDLER_ROUTINE;
    _ = TIMECALLBACK;
    _ = LPTIMECALLBACK;
    _ = PM_OPEN_PROC;
    _ = PM_QUERY_PROC;
    _ = PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK;
    _ = LPDDENUMVIDEOCALLBACK;
    _ = PDD_SETCOLORKEY;
    _ = PDD_DESTROYDRIVER;
    _ = PDD_SETMODE;
    _ = PDD_ALPHABLT;
    _ = PDD_SURFCB_SETCLIPLIST;
    _ = PDD_VPORTCB_GETAUTOFLIPSURF;
    _ = LPD3DVALIDATECALLBACK;
    _ = LPD3DENUMTEXTUREFORMATSCALLBACK;
    _ = LPD3DENUMPIXELFORMATSCALLBACK;
    _ = LPD3DENUMDEVICESCALLBACK;
    _ = LPD3DENUMDEVICESCALLBACK7;
    _ = LPD3DNTHAL_CONTEXTCREATECB;
    _ = LPD3DNTHAL_CONTEXTDESTROYCB;
    _ = LPD3DNTHAL_CONTEXTDESTROYALLCB;
    _ = LPD3DNTHAL_SCENECAPTURECB;
    _ = LPD3DNTHAL_TEXTURECREATECB;
    _ = LPD3DNTHAL_TEXTUREDESTROYCB;
    _ = LPD3DNTHAL_TEXTURESWAPCB;
    _ = LPD3DNTHAL_TEXTUREGETSURFCB;
    _ = LPD3DNTHAL_SETRENDERTARGETCB;
    _ = LPD3DNTHAL_CLEAR2CB;
    _ = LPD3DNTHAL_VALIDATETEXTURESTAGESTATECB;
    _ = LPD3DNTHAL_DRAWPRIMITIVES2CB;
    _ = PFND3DNTPARSEUNKNOWNCOMMAND;
    _ = PFN;
    _ = WNDOBJCHANGEPROC;
    _ = SORTCOMP;
    _ = PFN_DrvEnableDriver;
    _ = PFN_DrvEnablePDEV;
    _ = PFN_DrvCompletePDEV;
    _ = PFN_DrvResetDevice;
    _ = PFN_DrvDisablePDEV;
    _ = PFN_DrvSynchronize;
    _ = PFN_DrvEnableSurface;
    _ = PFN_DrvDisableDriver;
    _ = PFN_DrvDisableSurface;
    _ = PFN_DrvAssertMode;
    _ = PFN_DrvTextOut;
    _ = PFN_DrvStretchBlt;
    _ = PFN_DrvStretchBltROP;
    _ = PFN_DrvTransparentBlt;
    _ = PFN_DrvPlgBlt;
    _ = PFN_DrvBitBlt;
    _ = PFN_DrvRealizeBrush;
    _ = PFN_DrvCopyBits;
    _ = PFN_DrvDitherColor;
    _ = PFN_DrvCreateDeviceBitmap;
    _ = PFN_DrvDeleteDeviceBitmap;
    _ = PFN_DrvSetPalette;
    _ = PFN_DrvEscape;
    _ = PFN_DrvDrawEscape;
    _ = PFN_DrvQueryFont;
    _ = PFN_DrvQueryFontTree;
    _ = PFN_DrvQueryFontData;
    _ = PFN_DrvFree;
    _ = PFN_DrvDestroyFont;
    _ = PFN_DrvQueryFontCaps;
    _ = PFN_DrvLoadFontFile;
    _ = PFN_DrvUnloadFontFile;
    _ = PFN_DrvSetPointerShape;
    _ = PFN_DrvMovePointer;
    _ = PFN_DrvSendPage;
    _ = PFN_DrvStartPage;
    _ = PFN_DrvStartDoc;
    _ = PFN_DrvEndDoc;
    _ = PFN_DrvQuerySpoolType;
    _ = PFN_DrvLineTo;
    _ = PFN_DrvStrokePath;
    _ = PFN_DrvFillPath;
    _ = PFN_DrvStrokeAndFillPath;
    _ = PFN_DrvPaint;
    _ = PFN_DrvGetGlyphMode;
    _ = PFN_DrvResetPDEV;
    _ = PFN_DrvSaveScreenBits;
    _ = PFN_DrvGetModes;
    _ = PFN_DrvQueryTrueTypeTable;
    _ = PFN_DrvQueryTrueTypeSection;
    _ = PFN_DrvQueryTrueTypeOutline;
    _ = PFN_DrvGetTrueTypeFile;
    _ = PFN_DrvQueryFontFile;
    _ = PFN_DrvQueryAdvanceWidths;
    _ = PFN_DrvFontManagement;
    _ = PFN_DrvSetPixelFormat;
    _ = PFN_DrvDescribePixelFormat;
    _ = PFN_DrvSwapBuffers;
    _ = PFN_DrvStartBanding;
    _ = PFN_DrvNextBand;
    _ = PFN_DrvQueryPerBandInfo;
    _ = PFN_DrvEnableDirectDraw;
    _ = PFN_DrvDisableDirectDraw;
    _ = PFN_DrvGetDirectDrawInfo;
    _ = PFN_DrvIcmCreateColorTransform;
    _ = PFN_DrvIcmDeleteColorTransform;
    _ = PFN_DrvIcmCheckBitmapBits;
    _ = PFN_DrvIcmSetDeviceGammaRamp;
    _ = PFN_DrvAlphaBlend;
    _ = PFN_DrvGradientFill;
    _ = PFN_DrvQueryDeviceSupport;
    _ = PFN_DrvDeriveSurface;
    _ = PFN_DrvSynchronizeSurface;
    _ = PFN_DrvNotify;
    _ = PFN_DrvRenderHint;
    _ = PFN_EngCreateRectRgn;
    _ = PFN_EngDeleteRgn;
    _ = PFN_EngCombineRgn;
    _ = PFN_EngCopyRgn;
    _ = PFN_EngIntersectRgn;
    _ = PFN_EngSubtractRgn;
    _ = PFN_EngUnionRgn;
    _ = PFN_EngXorRgn;
    _ = PFN_DrvCreateDeviceBitmapEx;
    _ = PFN_DrvDeleteDeviceBitmapEx;
    _ = PFN_DrvAssociateSharedSurface;
    _ = PFN_DrvSynchronizeRedirectionBitmaps;
    _ = PFN_DrvAccumulateD3DDirtyRect;
    _ = PFN_DrvStartDxInterop;
    _ = PFN_DrvEndDxInterop;
    _ = PFN_DrvLockDisplayArea;
    _ = PFN_DrvUnlockDisplayArea;
    _ = PFN_DrvSurfaceComplete;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_ENCLAVE;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_RETURN_FROM_EXCEPTION;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_TERMINATE_THREAD;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_INTERRUPT_THREAD;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_COMMIT_PAGES;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_DECOMMIT_PAGES;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_PROTECT_PAGES;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_CREATE_THREAD;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_GET_ENCLAVE_INFORMATION;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_KEY;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_REPORT;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_VERIFY_REPORT;
    _ = VBS_BASIC_ENCLAVE_BASIC_CALL_GENERATE_RANDOM_DATA;
    _ = EFFECTIVE_POWER_MODE_CALLBACK;
    _ = PWRSCHEMESENUMPROC_V1;
    _ = PWRSCHEMESENUMPROC_V2;
    _ = PWRSCHEMESENUMPROC;
    _ = DEVICE_NOTIFY_CALLBACK_ROUTINE;
    _ = PDEVICE_NOTIFY_CALLBACK_ROUTINE;
    _ = PVIDEO_WIN32K_CALLOUT;
    _ = PFIBER_START_ROUTINE;

    const constant_export_count = 9877;
    const type_export_count = 1581;
    const enum_value_export_count = 2161;
    const com_iface_id_export_count = 59;
    const com_class_id_export_count = 2;
    const func_export_count = 918;
    const unicode_alias_count = 183;
    const import_count = 96;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
