//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (45)
//--------------------------------------------------------------------------------
pub const HHWIN_NAVTYPE_TOC : i32 = 0;
pub const HHWIN_NAVTYPE_INDEX : i32 = 1;
pub const HHWIN_NAVTYPE_SEARCH : i32 = 2;
pub const HHWIN_NAVTYPE_FAVORITES : i32 = 3;
pub const HHWIN_NAVTYPE_HISTORY : i32 = 4;
pub const HHWIN_NAVTYPE_AUTHOR : i32 = 5;
pub const HHWIN_NAVTYPE_CUSTOM_FIRST : i32 = 11;
pub const IT_INCLUSIVE : i32 = 0;
pub const IT_EXCLUSIVE : i32 = 1;
pub const IT_HIDDEN : i32 = 2;
pub const HHWIN_NAVTAB_TOP : i32 = 0;
pub const HHWIN_NAVTAB_LEFT : i32 = 1;
pub const HHWIN_NAVTAB_BOTTOM : i32 = 2;
pub const HH_TAB_CONTENTS : i32 = 0;
pub const HH_TAB_INDEX : i32 = 1;
pub const HH_TAB_SEARCH : i32 = 2;
pub const HH_TAB_FAVORITES : i32 = 3;
pub const HH_TAB_HISTORY : i32 = 4;
pub const HH_TAB_AUTHOR : i32 = 5;
pub const HH_TAB_CUSTOM_FIRST : i32 = 11;
pub const HH_TAB_CUSTOM_LAST : i32 = 19;
pub const HHACT_TAB_CONTENTS : i32 = 0;
pub const HHACT_TAB_INDEX : i32 = 1;
pub const HHACT_TAB_SEARCH : i32 = 2;
pub const HHACT_TAB_HISTORY : i32 = 3;
pub const HHACT_TAB_FAVORITES : i32 = 4;
pub const HHACT_EXPAND : i32 = 5;
pub const HHACT_CONTRACT : i32 = 6;
pub const HHACT_BACK : i32 = 7;
pub const HHACT_FORWARD : i32 = 8;
pub const HHACT_STOP : i32 = 9;
pub const HHACT_REFRESH : i32 = 10;
pub const HHACT_HOME : i32 = 11;
pub const HHACT_SYNC : i32 = 12;
pub const HHACT_OPTIONS : i32 = 13;
pub const HHACT_PRINT : i32 = 14;
pub const HHACT_HIGHLIGHT : i32 = 15;
pub const HHACT_CUSTOMIZE : i32 = 16;
pub const HHACT_JUMP1 : i32 = 17;
pub const HHACT_JUMP2 : i32 = 18;
pub const HHACT_ZOOM : i32 = 19;
pub const HHACT_TOC_NEXT : i32 = 20;
pub const HHACT_TOC_PREV : i32 = 21;
pub const HHACT_NOTES : i32 = 22;
pub const HHACT_LAST_ENUM : i32 = 23;

//--------------------------------------------------------------------------------
// Section: Types (26)
//--------------------------------------------------------------------------------
pub const HHN_NOTIFY = extern struct {
    hdr: NMHDR,
    pszUrl: [*:0]const u8,
};

pub const HH_POPUP = extern struct {
    cbStruct: i32,
    hinst: HINSTANCE,
    idString: u32,
    pszText: *i8,
    pt: POINT,
    clrForeground: u32,
    clrBackground: u32,
    rcMargins: RECT,
    pszFont: *i8,
};

pub const HH_AKLINK = extern struct {
    cbStruct: i32,
    fReserved: BOOL,
    pszKeywords: *i8,
    pszUrl: *i8,
    pszMsgText: *i8,
    pszMsgTitle: *i8,
    pszWindow: *i8,
    fIndexOnFail: BOOL,
};

pub const HH_ENUM_IT = extern struct {
    cbStruct: i32,
    iType: i32,
    pszCatName: [*:0]const u8,
    pszITName: [*:0]const u8,
    pszITDescription: [*:0]const u8,
};

pub const HH_ENUM_CAT = extern struct {
    cbStruct: i32,
    pszCatName: [*:0]const u8,
    pszCatDescription: [*:0]const u8,
};

pub const HH_SET_INFOTYPE = extern struct {
    cbStruct: i32,
    pszCatName: [*:0]const u8,
    pszInfoTypeName: [*:0]const u8,
};

pub const HH_FTS_QUERY = extern struct {
    cbStruct: i32,
    fUniCodeStrings: BOOL,
    pszSearchQuery: *i8,
    iProximity: i32,
    fStemmedSearch: BOOL,
    fTitleOnly: BOOL,
    fExecute: BOOL,
    pszWindow: *i8,
};

pub const HH_WINTYPE = extern struct {
    cbStruct: i32,
    fUniCodeStrings: BOOL,
    pszType: *i8,
    fsValidMembers: u32,
    fsWinProperties: u32,
    pszCaption: *i8,
    dwStyles: u32,
    dwExStyles: u32,
    rcWindowPos: RECT,
    nShowState: i32,
    hwndHelp: HWND,
    hwndCaller: HWND,
    paInfoTypes: *u32,
    hwndToolBar: HWND,
    hwndNavigation: HWND,
    hwndHTML: HWND,
    iNavWidth: i32,
    rcHTML: RECT,
    pszToc: *i8,
    pszIndex: *i8,
    pszFile: *i8,
    pszHome: *i8,
    fsToolBarFlags: u32,
    fNotExpanded: BOOL,
    curNavType: i32,
    tabpos: i32,
    idNotify: i32,
    tabOrder: [20]u8,
    cHistory: i32,
    pszJump1: *i8,
    pszJump2: *i8,
    pszUrlJump1: *i8,
    pszUrlJump2: *i8,
    rcMinSize: RECT,
    cbInfoTypes: i32,
    pszCustomTabs: *i8,
};

pub const HHNTRACK = extern struct {
    hdr: NMHDR,
    pszCurUrl: [*:0]const u8,
    idAction: i32,
    phhWinType: *HH_WINTYPE,
};

pub const HH_GPROPID = extern enum(i32) {
    SINGLETHREAD = 1,
    TOOLBAR_MARGIN = 2,
    UI_LANGUAGE = 3,
    CURRENT_SUBSET = 4,
    CONTENT_LANGUAGE = 5,
};
pub const HH_GPROPID_SINGLETHREAD = HH_GPROPID.SINGLETHREAD;
pub const HH_GPROPID_TOOLBAR_MARGIN = HH_GPROPID.TOOLBAR_MARGIN;
pub const HH_GPROPID_UI_LANGUAGE = HH_GPROPID.UI_LANGUAGE;
pub const HH_GPROPID_CURRENT_SUBSET = HH_GPROPID.CURRENT_SUBSET;
pub const HH_GPROPID_CONTENT_LANGUAGE = HH_GPROPID.CONTENT_LANGUAGE;

pub const HH_GLOBAL_PROPERTY = extern struct {
    id: HH_GPROPID,
    @"var": VARIANT,
};

pub const CProperty = extern struct {
    dwPropID: u32,
    cbData: u32,
    dwType: u32,
    Anonymous: CProperty._Anonymous_e__Union,
    fPersist: BOOL,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const IITPropList = extern struct {
    pub const VTable = extern struct {
        base: IPersistStreamInit.VTable,
        Set: fn(
            self: *const IITPropList,
            PropID: u32,
            dwData: u32,
            dwOperation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set1: fn(
            self: *const IITPropList,
            PropID: u32,
            lpvData: *c_void,
            cbData: u32,
            dwOperation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set2: fn(
            self: *const IITPropList,
            PropID: u32,
            lpszwString: [*:0]const u16,
            dwOperation: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IITPropList,
            Prop: *CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: fn(
            self: *const IITPropList,
            PropID: u32,
            Property: *CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IITPropList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPersist: fn(
            self: *const IITPropList,
            PropID: u32,
            fPersist: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPersist1: fn(
            self: *const IITPropList,
            fPersist: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirst: fn(
            self: *const IITPropList,
            Property: *CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IITPropList,
            Property: *CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropCount: fn(
            self: *const IITPropList,
            cProp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveHeader: fn(
            self: *const IITPropList,
            lpvData: *c_void,
            dwHdrSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveData: fn(
            self: *const IITPropList,
            lpvHeader: *c_void,
            dwHdrSize: u32,
            lpvData: *c_void,
            dwBufSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeaderSize: fn(
            self: *const IITPropList,
            dwHdrSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataSize: fn(
            self: *const IITPropList,
            lpvHeader: *c_void,
            dwHdrSize: u32,
            dwDataSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveDataToStream: fn(
            self: *const IITPropList,
            lpvHeader: *c_void,
            dwHdrSize: u32,
            pStream: *IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadFromMem: fn(
            self: *const IITPropList,
            lpvData: *c_void,
            dwBufSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveToMem: fn(
            self: *const IITPropList,
            lpvData: *c_void,
            dwBufSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPersistStreamInit.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Set(self: *const T, PropID: u32, dwData: u32, dwOperation: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).Set(@ptrCast(*const IITPropList, self), PropID, dwData, dwOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Set1(self: *const T, PropID: u32, lpvData: *c_void, cbData: u32, dwOperation: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).Set(@ptrCast(*const IITPropList, self), PropID, lpvData, cbData, dwOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Set2(self: *const T, PropID: u32, lpszwString: [*:0]const u16, dwOperation: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).Set(@ptrCast(*const IITPropList, self), PropID, lpszwString, dwOperation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Add(self: *const T, Prop: *CProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).Add(@ptrCast(*const IITPropList, self), Prop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Get(self: *const T, PropID: u32, Property: *CProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).Get(@ptrCast(*const IITPropList, self), PropID, Property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).Clear(@ptrCast(*const IITPropList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SetPersist(self: *const T, PropID: u32, fPersist: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).SetPersist(@ptrCast(*const IITPropList, self), PropID, fPersist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SetPersist1(self: *const T, fPersist: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).SetPersist(@ptrCast(*const IITPropList, self), fPersist);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetFirst(self: *const T, Property: *CProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).GetFirst(@ptrCast(*const IITPropList, self), Property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetNext(self: *const T, Property: *CProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).GetNext(@ptrCast(*const IITPropList, self), Property);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetPropCount(self: *const T, cProp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).GetPropCount(@ptrCast(*const IITPropList, self), cProp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SaveHeader(self: *const T, lpvData: *c_void, dwHdrSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).SaveHeader(@ptrCast(*const IITPropList, self), lpvData, dwHdrSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SaveData(self: *const T, lpvHeader: *c_void, dwHdrSize: u32, lpvData: *c_void, dwBufSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).SaveData(@ptrCast(*const IITPropList, self), lpvHeader, dwHdrSize, lpvData, dwBufSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetHeaderSize(self: *const T, dwHdrSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).GetHeaderSize(@ptrCast(*const IITPropList, self), dwHdrSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_GetDataSize(self: *const T, lpvHeader: *c_void, dwHdrSize: u32, dwDataSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).GetDataSize(@ptrCast(*const IITPropList, self), lpvHeader, dwHdrSize, dwDataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SaveDataToStream(self: *const T, lpvHeader: *c_void, dwHdrSize: u32, pStream: *IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).SaveDataToStream(@ptrCast(*const IITPropList, self), lpvHeader, dwHdrSize, pStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_LoadFromMem(self: *const T, lpvData: *c_void, dwBufSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).LoadFromMem(@ptrCast(*const IITPropList, self), lpvData, dwBufSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITPropList_SaveToMem(self: *const T, lpvData: *c_void, dwBufSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITPropList.VTable, self.vtable).SaveToMem(@ptrCast(*const IITPropList, self), lpvData, dwBufSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IITDatabase = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IITDatabase,
            lpszHost: [*:0]const u16,
            lpszMoniker: [*:0]const u16,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IITDatabase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateObject: fn(
            self: *const IITDatabase,
            rclsid: *const Guid,
            pdwObjInstance: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObject: fn(
            self: *const IITDatabase,
            dwObjInstance: u32,
            riid: *const Guid,
            ppvObj: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectPersistence: fn(
            self: *const IITDatabase,
            lpwszObject: [*:0]const u16,
            dwObjInstance: u32,
            ppvPersistence: **c_void,
            fStream: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_Open(self: *const T, lpszHost: [*:0]const u16, lpszMoniker: [*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITDatabase.VTable, self.vtable).Open(@ptrCast(*const IITDatabase, self), lpszHost, lpszMoniker, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITDatabase.VTable, self.vtable).Close(@ptrCast(*const IITDatabase, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_CreateObject(self: *const T, rclsid: *const Guid, pdwObjInstance: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITDatabase.VTable, self.vtable).CreateObject(@ptrCast(*const IITDatabase, self), rclsid, pdwObjInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_GetObject(self: *const T, dwObjInstance: u32, riid: *const Guid, ppvObj: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITDatabase.VTable, self.vtable).GetObject(@ptrCast(*const IITDatabase, self), dwObjInstance, riid, ppvObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITDatabase_GetObjectPersistence(self: *const T, lpwszObject: [*:0]const u16, dwObjInstance: u32, ppvPersistence: **c_void, fStream: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITDatabase.VTable, self.vtable).GetObjectPersistence(@ptrCast(*const IITDatabase, self), lpwszObject, dwObjInstance, ppvPersistence, fStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IITGroup = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IITQuery = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IITWordWheel = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Open: fn(
            self: *const IITWordWheel,
            lpITDB: *IITDatabase,
            lpszMoniker: [*:0]const u16,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IITWordWheel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocaleInfoA: fn(
            self: *const IITWordWheel,
            pdwCodePageID: *u32,
            plcid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSorterInstance: fn(
            self: *const IITWordWheel,
            pdwObjInstance: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Count: fn(
            self: *const IITWordWheel,
            pcEntries: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Lookup: fn(
            self: *const IITWordWheel,
            lEntry: i32,
            lpvKeyBuf: *c_void,
            cbKeyBuf: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Lookup1: fn(
            self: *const IITWordWheel,
            lEntry: i32,
            lpITResult: *IITResultSet,
            cEntries: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Lookup2: fn(
            self: *const IITWordWheel,
            lpcvPrefix: *const c_void,
            fExactMatch: BOOL,
            plEntry: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGroup: fn(
            self: *const IITWordWheel,
            piitGroup: *IITGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGroup: fn(
            self: *const IITWordWheel,
            ppiitGroup: **IITGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataCount: fn(
            self: *const IITWordWheel,
            lEntry: i32,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetData: fn(
            self: *const IITWordWheel,
            lEntry: i32,
            lpITResult: *IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataColumns: fn(
            self: *const IITWordWheel,
            pRS: *IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Open(self: *const T, lpITDB: *IITDatabase, lpszMoniker: [*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).Open(@ptrCast(*const IITWordWheel, self), lpITDB, lpszMoniker, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).Close(@ptrCast(*const IITWordWheel, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetLocaleInfoA(self: *const T, pdwCodePageID: *u32, plcid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).GetLocaleInfoA(@ptrCast(*const IITWordWheel, self), pdwCodePageID, plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetSorterInstance(self: *const T, pdwObjInstance: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).GetSorterInstance(@ptrCast(*const IITWordWheel, self), pdwObjInstance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Count(self: *const T, pcEntries: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).Count(@ptrCast(*const IITWordWheel, self), pcEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Lookup(self: *const T, lEntry: i32, lpvKeyBuf: *c_void, cbKeyBuf: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).Lookup(@ptrCast(*const IITWordWheel, self), lEntry, lpvKeyBuf, cbKeyBuf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Lookup1(self: *const T, lEntry: i32, lpITResult: *IITResultSet, cEntries: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).Lookup(@ptrCast(*const IITWordWheel, self), lEntry, lpITResult, cEntries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_Lookup2(self: *const T, lpcvPrefix: *const c_void, fExactMatch: BOOL, plEntry: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).Lookup(@ptrCast(*const IITWordWheel, self), lpcvPrefix, fExactMatch, plEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_SetGroup(self: *const T, piitGroup: *IITGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).SetGroup(@ptrCast(*const IITWordWheel, self), piitGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetGroup(self: *const T, ppiitGroup: **IITGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).GetGroup(@ptrCast(*const IITWordWheel, self), ppiitGroup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetDataCount(self: *const T, lEntry: i32, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).GetDataCount(@ptrCast(*const IITWordWheel, self), lEntry, pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetData(self: *const T, lEntry: i32, lpITResult: *IITResultSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).GetData(@ptrCast(*const IITWordWheel, self), lEntry, lpITResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITWordWheel_GetDataColumns(self: *const T, pRS: *IITResultSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITWordWheel.VTable, self.vtable).GetDataColumns(@ptrCast(*const IITWordWheel, self), pRS);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IStemSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PutAltWord: fn(
            self: *const IStemSink,
            pwcInBuf: [*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PutWord: fn(
            self: *const IStemSink,
            pwcInBuf: [*:0]const u16,
            cwc: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemSink_PutAltWord(self: *const T, pwcInBuf: [*:0]const u16, cwc: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemSink.VTable, self.vtable).PutAltWord(@ptrCast(*const IStemSink, self), pwcInBuf, cwc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemSink_PutWord(self: *const T, pwcInBuf: [*:0]const u16, cwc: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemSink.VTable, self.vtable).PutWord(@ptrCast(*const IStemSink, self), pwcInBuf, cwc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IStemmerConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLocaleInfoA: fn(
            self: *const IStemmerConfig,
            dwCodePageID: u32,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocaleInfoA: fn(
            self: *const IStemmerConfig,
            pdwCodePageID: *u32,
            plcid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControlInfo: fn(
            self: *const IStemmerConfig,
            grfStemFlags: u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlInfo: fn(
            self: *const IStemmerConfig,
            pgrfStemFlags: *u32,
            pdwReserved: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadExternalStemmerData: fn(
            self: *const IStemmerConfig,
            pStream: *IStream,
            dwExtDataType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_SetLocaleInfoA(self: *const T, dwCodePageID: u32, lcid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemmerConfig.VTable, self.vtable).SetLocaleInfoA(@ptrCast(*const IStemmerConfig, self), dwCodePageID, lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_GetLocaleInfoA(self: *const T, pdwCodePageID: *u32, plcid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemmerConfig.VTable, self.vtable).GetLocaleInfoA(@ptrCast(*const IStemmerConfig, self), pdwCodePageID, plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_SetControlInfo(self: *const T, grfStemFlags: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemmerConfig.VTable, self.vtable).SetControlInfo(@ptrCast(*const IStemmerConfig, self), grfStemFlags, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_GetControlInfo(self: *const T, pgrfStemFlags: *u32, pdwReserved: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemmerConfig.VTable, self.vtable).GetControlInfo(@ptrCast(*const IStemmerConfig, self), pgrfStemFlags, pdwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStemmerConfig_LoadExternalStemmerData(self: *const T, pStream: *IStream, dwExtDataType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStemmerConfig.VTable, self.vtable).LoadExternalStemmerData(@ptrCast(*const IStemmerConfig, self), pStream, dwExtDataType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IITStopWordList = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IWordBreakerConfig = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetLocaleInfoA: fn(
            self: *const IWordBreakerConfig,
            dwCodePageID: u32,
            lcid: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocaleInfoA: fn(
            self: *const IWordBreakerConfig,
            pdwCodePageID: *u32,
            plcid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakWordType: fn(
            self: *const IWordBreakerConfig,
            dwBreakWordType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakWordType: fn(
            self: *const IWordBreakerConfig,
            pdwBreakWordType: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetControlInfo: fn(
            self: *const IWordBreakerConfig,
            grfBreakFlags: u32,
            dwReserved: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetControlInfo: fn(
            self: *const IWordBreakerConfig,
            pgrfBreakFlags: *u32,
            pdwReserved: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LoadExternalBreakerData: fn(
            self: *const IWordBreakerConfig,
            pStream: *IStream,
            dwExtDataType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWordStemmer: fn(
            self: *const IWordBreakerConfig,
            rclsid: *const Guid,
            pStemmer: *IStemmer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWordStemmer: fn(
            self: *const IWordBreakerConfig,
            ppStemmer: **IStemmer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_SetLocaleInfoA(self: *const T, dwCodePageID: u32, lcid: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreakerConfig.VTable, self.vtable).SetLocaleInfoA(@ptrCast(*const IWordBreakerConfig, self), dwCodePageID, lcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_GetLocaleInfoA(self: *const T, pdwCodePageID: *u32, plcid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreakerConfig.VTable, self.vtable).GetLocaleInfoA(@ptrCast(*const IWordBreakerConfig, self), pdwCodePageID, plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_SetBreakWordType(self: *const T, dwBreakWordType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreakerConfig.VTable, self.vtable).SetBreakWordType(@ptrCast(*const IWordBreakerConfig, self), dwBreakWordType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_GetBreakWordType(self: *const T, pdwBreakWordType: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreakerConfig.VTable, self.vtable).GetBreakWordType(@ptrCast(*const IWordBreakerConfig, self), pdwBreakWordType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_SetControlInfo(self: *const T, grfBreakFlags: u32, dwReserved: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreakerConfig.VTable, self.vtable).SetControlInfo(@ptrCast(*const IWordBreakerConfig, self), grfBreakFlags, dwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_GetControlInfo(self: *const T, pgrfBreakFlags: *u32, pdwReserved: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreakerConfig.VTable, self.vtable).GetControlInfo(@ptrCast(*const IWordBreakerConfig, self), pgrfBreakFlags, pdwReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_LoadExternalBreakerData(self: *const T, pStream: *IStream, dwExtDataType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreakerConfig.VTable, self.vtable).LoadExternalBreakerData(@ptrCast(*const IWordBreakerConfig, self), pStream, dwExtDataType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_SetWordStemmer(self: *const T, rclsid: *const Guid, pStemmer: *IStemmer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreakerConfig.VTable, self.vtable).SetWordStemmer(@ptrCast(*const IWordBreakerConfig, self), rclsid, pStemmer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWordBreakerConfig_GetWordStemmer(self: *const T, ppStemmer: **IStemmer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWordBreakerConfig.VTable, self.vtable).GetWordStemmer(@ptrCast(*const IWordBreakerConfig, self), ppStemmer);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PRIORITY = extern enum(i32) {
    LOW = 0,
    NORMAL = 1,
    HIGH = 2,
};
pub const PRIORITY_LOW = PRIORITY.LOW;
pub const PRIORITY_NORMAL = PRIORITY.NORMAL;
pub const PRIORITY_HIGH = PRIORITY.HIGH;

pub const ROWSTATUS = extern struct {
    lRowFirst: i32,
    cRows: i32,
    cProperties: i32,
    cRowsTotal: i32,
};

pub const COLUMNSTATUS = extern struct {
    cPropCount: i32,
    cPropsLoaded: i32,
};

pub const PFNCOLHEAPFREE = fn(
    param0: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const IITResultSet = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetColumnPriority: fn(
            self: *const IITResultSet,
            lColumnIndex: i32,
            ColumnPriority: PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetColumnHeap: fn(
            self: *const IITResultSet,
            lColumnIndex: i32,
            lpvHeap: *c_void,
            pfnColHeapFree: PFNCOLHEAPFREE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeyProp: fn(
            self: *const IITResultSet,
            PropID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const IITResultSet,
            lpvHdr: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add1: fn(
            self: *const IITResultSet,
            PropID: u32,
            lpvDefaultData: *c_void,
            cbData: u32,
            Priority: PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add2: fn(
            self: *const IITResultSet,
            PropID: u32,
            lpszwDefault: [*:0]const u16,
            Priority: PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add3: fn(
            self: *const IITResultSet,
            PropID: u32,
            dwDefaultData: u32,
            Priority: PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: fn(
            self: *const IITResultSet,
            lpvHdr: *c_void,
            lpvData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set: fn(
            self: *const IITResultSet,
            lRowIndex: i32,
            lpvHdr: *c_void,
            lpvData: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set1: fn(
            self: *const IITResultSet,
            lRowIndex: i32,
            lColumnIndex: i32,
            dwData: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set2: fn(
            self: *const IITResultSet,
            lRowIndex: i32,
            lColumnIndex: i32,
            lpwStr: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Set3: fn(
            self: *const IITResultSet,
            lRowIndex: i32,
            lColumnIndex: i32,
            lpvData: *c_void,
            cbData: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const IITResultSet,
            pRSCopy: *IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendRows: fn(
            self: *const IITResultSet,
            pResSrc: *IITResultSet,
            lRowSrcFirst: i32,
            cSrcRows: i32,
            lRowFirstDest: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Get: fn(
            self: *const IITResultSet,
            lRowIndex: i32,
            lColumnIndex: i32,
            Prop: *CProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyProp: fn(
            self: *const IITResultSet,
            KeyPropID: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnPriority: fn(
            self: *const IITResultSet,
            lColumnIndex: i32,
            ColumnPriority: *PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowCount: fn(
            self: *const IITResultSet,
            lNumberOfRows: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnCount: fn(
            self: *const IITResultSet,
            lNumberOfColumns: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumn: fn(
            self: *const IITResultSet,
            lColumnIndex: i32,
            PropID: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumn1: fn(
            self: *const IITResultSet,
            lColumnIndex: i32,
            PropID: *u32,
            dwType: *u32,
            lpvDefaultValue: **c_void,
            cbSize: *u32,
            ColumnPriority: *PRIORITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnFromPropID: fn(
            self: *const IITResultSet,
            PropID: u32,
            lColumnIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clear: fn(
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearRows: fn(
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Free: fn(
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCompleted: fn(
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cancel: fn(
            self: *const IITResultSet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Pause: fn(
            self: *const IITResultSet,
            fPause: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRowStatus: fn(
            self: *const IITResultSet,
            lRowFirst: i32,
            cRows: i32,
            lpRowStatus: *ROWSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumnStatus: fn(
            self: *const IITResultSet,
            lpColStatus: *COLUMNSTATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_SetColumnPriority(self: *const T, lColumnIndex: i32, ColumnPriority: PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).SetColumnPriority(@ptrCast(*const IITResultSet, self), lColumnIndex, ColumnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_SetColumnHeap(self: *const T, lColumnIndex: i32, lpvHeap: *c_void, pfnColHeapFree: PFNCOLHEAPFREE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).SetColumnHeap(@ptrCast(*const IITResultSet, self), lColumnIndex, lpvHeap, pfnColHeapFree);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_SetKeyProp(self: *const T, PropID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).SetKeyProp(@ptrCast(*const IITResultSet, self), PropID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Add(self: *const T, lpvHdr: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Add(@ptrCast(*const IITResultSet, self), lpvHdr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Add1(self: *const T, PropID: u32, lpvDefaultData: *c_void, cbData: u32, Priority: PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Add(@ptrCast(*const IITResultSet, self), PropID, lpvDefaultData, cbData, Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Add2(self: *const T, PropID: u32, lpszwDefault: [*:0]const u16, Priority: PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Add(@ptrCast(*const IITResultSet, self), PropID, lpszwDefault, Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Add3(self: *const T, PropID: u32, dwDefaultData: u32, Priority: PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Add(@ptrCast(*const IITResultSet, self), PropID, dwDefaultData, Priority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Append(self: *const T, lpvHdr: *c_void, lpvData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Append(@ptrCast(*const IITResultSet, self), lpvHdr, lpvData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Set(self: *const T, lRowIndex: i32, lpvHdr: *c_void, lpvData: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Set(@ptrCast(*const IITResultSet, self), lRowIndex, lpvHdr, lpvData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Set1(self: *const T, lRowIndex: i32, lColumnIndex: i32, dwData: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Set(@ptrCast(*const IITResultSet, self), lRowIndex, lColumnIndex, dwData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Set2(self: *const T, lRowIndex: i32, lColumnIndex: i32, lpwStr: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Set(@ptrCast(*const IITResultSet, self), lRowIndex, lColumnIndex, lpwStr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Set3(self: *const T, lRowIndex: i32, lColumnIndex: i32, lpvData: *c_void, cbData: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Set(@ptrCast(*const IITResultSet, self), lRowIndex, lColumnIndex, lpvData, cbData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Copy(self: *const T, pRSCopy: *IITResultSet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Copy(@ptrCast(*const IITResultSet, self), pRSCopy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_AppendRows(self: *const T, pResSrc: *IITResultSet, lRowSrcFirst: i32, cSrcRows: i32, lRowFirstDest: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).AppendRows(@ptrCast(*const IITResultSet, self), pResSrc, lRowSrcFirst, cSrcRows, lRowFirstDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Get(self: *const T, lRowIndex: i32, lColumnIndex: i32, Prop: *CProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Get(@ptrCast(*const IITResultSet, self), lRowIndex, lColumnIndex, Prop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetKeyProp(self: *const T, KeyPropID: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).GetKeyProp(@ptrCast(*const IITResultSet, self), KeyPropID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumnPriority(self: *const T, lColumnIndex: i32, ColumnPriority: *PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).GetColumnPriority(@ptrCast(*const IITResultSet, self), lColumnIndex, ColumnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetRowCount(self: *const T, lNumberOfRows: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).GetRowCount(@ptrCast(*const IITResultSet, self), lNumberOfRows);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumnCount(self: *const T, lNumberOfColumns: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).GetColumnCount(@ptrCast(*const IITResultSet, self), lNumberOfColumns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumn(self: *const T, lColumnIndex: i32, PropID: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).GetColumn(@ptrCast(*const IITResultSet, self), lColumnIndex, PropID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumn1(self: *const T, lColumnIndex: i32, PropID: *u32, dwType: *u32, lpvDefaultValue: **c_void, cbSize: *u32, ColumnPriority: *PRIORITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).GetColumn(@ptrCast(*const IITResultSet, self), lColumnIndex, PropID, dwType, lpvDefaultValue, cbSize, ColumnPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumnFromPropID(self: *const T, PropID: u32, lColumnIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).GetColumnFromPropID(@ptrCast(*const IITResultSet, self), PropID, lColumnIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Clear(@ptrCast(*const IITResultSet, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_ClearRows(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).ClearRows(@ptrCast(*const IITResultSet, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Free(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Free(@ptrCast(*const IITResultSet, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_IsCompleted(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).IsCompleted(@ptrCast(*const IITResultSet, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Cancel(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Cancel(@ptrCast(*const IITResultSet, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_Pause(self: *const T, fPause: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).Pause(@ptrCast(*const IITResultSet, self), fPause);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetRowStatus(self: *const T, lRowFirst: i32, cRows: i32, lpRowStatus: *ROWSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).GetRowStatus(@ptrCast(*const IITResultSet, self), lRowFirst, cRows, lpRowStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IITResultSet_GetColumnStatus(self: *const T, lpColStatus: *COLUMNSTATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IITResultSet.VTable, self.vtable).GetColumnStatus(@ptrCast(*const IITResultSet, self), lpColStatus);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (15)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IStream = @import("structured_storage.zig").IStream;
const IStemmer = @import("search.zig").IStemmer;
const HINSTANCE = @import("system_services.zig").HINSTANCE;
const PWSTR = @import("system_services.zig").PWSTR;
const IUnknown = @import("com.zig").IUnknown;
const HRESULT = @import("com.zig").HRESULT;
const NMHDR = @import("controls.zig").NMHDR;
const PSTR = @import("system_services.zig").PSTR;
const RECT = @import("display_devices.zig").RECT;
const BOOL = @import("system_services.zig").BOOL;
const HWND = @import("windows_and_messaging.zig").HWND;
const VARIANT = @import("automation.zig").VARIANT;
const IPersistStreamInit = @import("com.zig").IPersistStreamInit;
const POINT = @import("display_devices.zig").POINT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = PFNCOLHEAPFREE;

    const constant_export_count = 45;
    const type_export_count = 26;
    const enum_value_export_count = 8;
    const com_iface_id_export_count = 0;
    const com_class_id_export_count = 0;
    const func_export_count = 0;
    const unicode_alias_count = 0;
    const import_count = 15;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
