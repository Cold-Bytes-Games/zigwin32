//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1)
//--------------------------------------------------------------------------------
pub const WinUSB_TestGuid = @import("../zig.zig").Guid.initString("da812bff-12c3-46a2-8e2b-dbd3b7834c43");

//--------------------------------------------------------------------------------
// Section: Types (124)
//--------------------------------------------------------------------------------
pub const USB_DEVICE_SPEED = extern enum(i32) {
    UsbLowSpeed = 0,
    UsbFullSpeed = 1,
    UsbHighSpeed = 2,
    UsbSuperSpeed = 3,
};
pub const UsbLowSpeed = USB_DEVICE_SPEED.UsbLowSpeed;
pub const UsbFullSpeed = USB_DEVICE_SPEED.UsbFullSpeed;
pub const UsbHighSpeed = USB_DEVICE_SPEED.UsbHighSpeed;
pub const UsbSuperSpeed = USB_DEVICE_SPEED.UsbSuperSpeed;

pub const USB_DEVICE_TYPE = extern enum(i32) {
    Usb11Device = 0,
    Usb20Device = 1,
};
pub const Usb11Device = USB_DEVICE_TYPE.Usb11Device;
pub const Usb20Device = USB_DEVICE_TYPE.Usb20Device;

pub const BM_REQUEST_TYPE = u32; // TODO: implement StructOrUnion types?

pub const USB_DEFAULT_PIPE_SETUP_PACKET = extern struct {
    bmRequestType: BM_REQUEST_TYPE,
    bRequest: u8,
    wValue: USB_DEFAULT_PIPE_SETUP_PACKET._wValue,
    wIndex: USB_DEFAULT_PIPE_SETUP_PACKET._wIndex,
    wLength: u16,
    const _wIndex = u32; // TODO: generate this nested type!
    const _wValue = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_STATUS = u32; // TODO: implement StructOrUnion types?

pub const USB_INTERFACE_STATUS = u32; // TODO: implement StructOrUnion types?

pub const USB_ENDPOINT_STATUS = u32; // TODO: implement StructOrUnion types?

pub const USB_COMMON_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
};

pub const USB_DEVICE_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bcdUSB: u16,
    bDeviceClass: u8,
    bDeviceSubClass: u8,
    bDeviceProtocol: u8,
    bMaxPacketSize0: u8,
    idVendor: u16,
    idProduct: u16,
    bcdDevice: u16,
    iManufacturer: u8,
    iProduct: u8,
    iSerialNumber: u8,
    bNumConfigurations: u8,
};

pub const USB_DEVICE_QUALIFIER_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bcdUSB: u16,
    bDeviceClass: u8,
    bDeviceSubClass: u8,
    bDeviceProtocol: u8,
    bMaxPacketSize0: u8,
    bNumConfigurations: u8,
    bReserved: u8,
};

pub const USB_BOS_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    wTotalLength: u16,
    bNumDeviceCaps: u8,
};

pub const USB_DEVICE_CAPABILITY_USB20_EXTENSION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bmAttributes: USB_DEVICE_CAPABILITY_USB20_EXTENSION_DESCRIPTOR._bmAttributes_e__Union,
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_POWER_DELIVERY_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    bmAttributes: USB_DEVICE_CAPABILITY_POWER_DELIVERY_DESCRIPTOR._bmAttributes_e__Union,
    bmProviderPorts: u16,
    bmConsumerPorts: u16,
    bcdBCVersion: u16,
    bcdPDVersion: u16,
    bcdUSBTypeCVersion: u16,
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    bmCapabilities: USB_DEVICE_CAPABILITY_PD_CONSUMER_PORT_DESCRIPTOR._bmCapabilities_e__Union,
    wMinVoltage: u16,
    wMaxVoltage: u16,
    wReserved: u16,
    dwMaxOperatingPower: u32,
    dwMaxPeakPower: u32,
    dwMaxPeakPowerTime: u32,
    const _bmCapabilities_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_SUPERSPEED_USB_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bmAttributes: u8,
    wSpeedsSupported: u16,
    bFunctionalitySupport: u8,
    bU1DevExitLat: u8,
    wU2DevExitLat: u16,
};

pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED = u32; // TODO: implement StructOrUnion types?

pub const USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_USB_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    bmAttributes: USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_USB_DESCRIPTOR._bmAttributes_e__Union,
    wFunctionalitySupport: USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_USB_DESCRIPTOR._wFunctionalitySupport_e__Union,
    wReserved: u16,
    bmSublinkSpeedAttr: [1]USB_DEVICE_CAPABILITY_SUPERSPEEDPLUS_SPEED,
    const _wFunctionalitySupport_e__Union = u32; // TODO: generate this nested type!
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_CONTAINER_ID_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    ContainerID: [16]u8,
};

pub const USB_DEVICE_CAPABILITY_PLATFORM_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bReserved: u8,
    PlatformCapabilityUuid: Guid,
    CapabililityData: [1]u8,
};

pub const USB_DEVICE_CAPABILITY_BILLBOARD_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    iAddtionalInfoURL: u8,
    bNumberOfAlternateModes: u8,
    bPreferredAlternateMode: u8,
    VconnPower: USB_DEVICE_CAPABILITY_BILLBOARD_DESCRIPTOR._VconnPower_e__Union,
    bmConfigured: [32]u8,
    bReserved: u32,
    AlternateMode: [1]USB_DEVICE_CAPABILITY_BILLBOARD_DESCRIPTOR._Anonymous_e__Struct,
    const _VconnPower_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous_e__Struct = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_FIRMWARE_STATUS_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
    bcdDescriptorVersion: u8,
    bmAttributes: USB_DEVICE_CAPABILITY_FIRMWARE_STATUS_DESCRIPTOR._bmAttributes_e__Union,
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_DEVICE_CAPABILITY_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bDevCapabilityType: u8,
};

pub const USB_CONFIGURATION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    wTotalLength: u16,
    bNumInterfaces: u8,
    bConfigurationValue: u8,
    iConfiguration: u8,
    bmAttributes: u8,
    MaxPower: u8,
};

pub const USB_INTERFACE_ASSOCIATION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bFirstInterface: u8,
    bInterfaceCount: u8,
    bFunctionClass: u8,
    bFunctionSubClass: u8,
    bFunctionProtocol: u8,
    iFunction: u8,
};

pub const USB_INTERFACE_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bInterfaceNumber: u8,
    bAlternateSetting: u8,
    bNumEndpoints: u8,
    bInterfaceClass: u8,
    bInterfaceSubClass: u8,
    bInterfaceProtocol: u8,
    iInterface: u8,
};

pub const USB_ENDPOINT_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bEndpointAddress: u8,
    bmAttributes: u8,
    wMaxPacketSize: u16,
    bInterval: u8,
};

pub const USB_HIGH_SPEED_MAXPACKET = u32; // TODO: implement StructOrUnion types?

pub const USB_STRING_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bString: [1]u16,
};

pub const USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bMaxBurst: u8,
    bmAttributes: USB_SUPERSPEED_ENDPOINT_COMPANION_DESCRIPTOR._bmAttributes_e__Union,
    wBytesPerInterval: u16,
    const _bmAttributes_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_SUPERSPEEDPLUS_ISOCH_ENDPOINT_COMPANION_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    wReserved: u16,
    dwBytesPerInterval: u32,
};

pub const USB_HUB_DESCRIPTOR = extern struct {
    bDescriptorLength: u8,
    bDescriptorType: u8,
    bNumberOfPorts: u8,
    wHubCharacteristics: u16,
    bPowerOnToPowerGood: u8,
    bHubControlCurrent: u8,
    bRemoveAndPowerMask: [64]u8,
};

pub const USB_30_HUB_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bNumberOfPorts: u8,
    wHubCharacteristics: u16,
    bPowerOnToPowerGood: u8,
    bHubControlCurrent: u8,
    bHubHdrDecLat: u8,
    wHubDelay: u16,
    DeviceRemovable: u16,
};

pub const USB_HUB_STATUS = u32; // TODO: implement StructOrUnion types?

pub const USB_HUB_CHANGE = u32; // TODO: implement StructOrUnion types?

pub const USB_HUB_STATUS_AND_CHANGE = u32; // TODO: implement StructOrUnion types?

pub const USB_20_PORT_STATUS = u32; // TODO: implement StructOrUnion types?

pub const USB_20_PORT_CHANGE = u32; // TODO: implement StructOrUnion types?

pub const USB_30_PORT_STATUS = u32; // TODO: implement StructOrUnion types?

pub const USB_30_PORT_CHANGE = u32; // TODO: implement StructOrUnion types?

pub const USB_PORT_STATUS = u32; // TODO: implement StructOrUnion types?

pub const USB_PORT_CHANGE = u32; // TODO: implement StructOrUnion types?

pub const USB_PORT_EXT_STATUS = u32; // TODO: implement StructOrUnion types?

pub const USB_PORT_STATUS_AND_CHANGE = u32; // TODO: implement StructOrUnion types?

pub const USB_PORT_EXT_STATUS_AND_CHANGE = u32; // TODO: implement StructOrUnion types?

pub const USB_HUB_30_PORT_REMOTE_WAKE_MASK = u32; // TODO: implement StructOrUnion types?

pub const USB_FUNCTION_SUSPEND_OPTIONS = u32; // TODO: implement StructOrUnion types?

pub const USB_CONFIGURATION_POWER_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    SelfPowerConsumedD0: [3]u8,
    bPowerSummaryId: u8,
    bBusPowerSavingD1: u8,
    bSelfPowerSavingD1: u8,
    bBusPowerSavingD2: u8,
    bSelfPowerSavingD2: u8,
    bBusPowerSavingD3: u8,
    bSelfPowerSavingD3: u8,
    TransitionTimeFromD1: u16,
    TransitionTimeFromD2: u16,
    TransitionTimeFromD3: u16,
};

pub const USB_INTERFACE_POWER_DESCRIPTOR = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    bmCapabilitiesFlags: u8,
    bBusPowerSavingD1: u8,
    bSelfPowerSavingD1: u8,
    bBusPowerSavingD2: u8,
    bSelfPowerSavingD2: u8,
    bBusPowerSavingD3: u8,
    bSelfPowerSavingD3: u8,
    TransitionTimeFromD1: u16,
    TransitionTimeFromD2: u16,
    TransitionTimeFromD3: u16,
};

pub const USB_CONTROLLER_FLAVOR = extern enum(i32) {
    USB_HcGeneric = 0,
    OHCI_Generic = 100,
    OHCI_Hydra = 101,
    OHCI_NEC = 102,
    UHCI_Generic = 200,
    UHCI_Piix4 = 201,
    UHCI_Piix3 = 202,
    UHCI_Ich2 = 203,
    UHCI_Reserved204 = 204,
    UHCI_Ich1 = 205,
    UHCI_Ich3m = 206,
    UHCI_Ich4 = 207,
    UHCI_Ich5 = 208,
    UHCI_Ich6 = 209,
    UHCI_Intel = 249,
    UHCI_VIA = 250,
    UHCI_VIA_x01 = 251,
    UHCI_VIA_x02 = 252,
    UHCI_VIA_x03 = 253,
    UHCI_VIA_x04 = 254,
    UHCI_VIA_x0E_FIFO = 264,
    EHCI_Generic = 1000,
    EHCI_NEC = 2000,
    EHCI_Lucent = 3000,
    EHCI_NVIDIA_Tegra2 = 4000,
    EHCI_NVIDIA_Tegra3 = 4001,
    EHCI_Intel_Medfield = 5001,
};
pub const USB_HcGeneric = USB_CONTROLLER_FLAVOR.USB_HcGeneric;
pub const OHCI_Generic = USB_CONTROLLER_FLAVOR.OHCI_Generic;
pub const OHCI_Hydra = USB_CONTROLLER_FLAVOR.OHCI_Hydra;
pub const OHCI_NEC = USB_CONTROLLER_FLAVOR.OHCI_NEC;
pub const UHCI_Generic = USB_CONTROLLER_FLAVOR.UHCI_Generic;
pub const UHCI_Piix4 = USB_CONTROLLER_FLAVOR.UHCI_Piix4;
pub const UHCI_Piix3 = USB_CONTROLLER_FLAVOR.UHCI_Piix3;
pub const UHCI_Ich2 = USB_CONTROLLER_FLAVOR.UHCI_Ich2;
pub const UHCI_Reserved204 = USB_CONTROLLER_FLAVOR.UHCI_Reserved204;
pub const UHCI_Ich1 = USB_CONTROLLER_FLAVOR.UHCI_Ich1;
pub const UHCI_Ich3m = USB_CONTROLLER_FLAVOR.UHCI_Ich3m;
pub const UHCI_Ich4 = USB_CONTROLLER_FLAVOR.UHCI_Ich4;
pub const UHCI_Ich5 = USB_CONTROLLER_FLAVOR.UHCI_Ich5;
pub const UHCI_Ich6 = USB_CONTROLLER_FLAVOR.UHCI_Ich6;
pub const UHCI_Intel = USB_CONTROLLER_FLAVOR.UHCI_Intel;
pub const UHCI_VIA = USB_CONTROLLER_FLAVOR.UHCI_VIA;
pub const UHCI_VIA_x01 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x01;
pub const UHCI_VIA_x02 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x02;
pub const UHCI_VIA_x03 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x03;
pub const UHCI_VIA_x04 = USB_CONTROLLER_FLAVOR.UHCI_VIA_x04;
pub const UHCI_VIA_x0E_FIFO = USB_CONTROLLER_FLAVOR.UHCI_VIA_x0E_FIFO;
pub const EHCI_Generic = USB_CONTROLLER_FLAVOR.EHCI_Generic;
pub const EHCI_NEC = USB_CONTROLLER_FLAVOR.EHCI_NEC;
pub const EHCI_Lucent = USB_CONTROLLER_FLAVOR.EHCI_Lucent;
pub const EHCI_NVIDIA_Tegra2 = USB_CONTROLLER_FLAVOR.EHCI_NVIDIA_Tegra2;
pub const EHCI_NVIDIA_Tegra3 = USB_CONTROLLER_FLAVOR.EHCI_NVIDIA_Tegra3;
pub const EHCI_Intel_Medfield = USB_CONTROLLER_FLAVOR.EHCI_Intel_Medfield;

pub const USBD_VERSION_INFORMATION = extern struct {
    USBDI_Version: u32,
    Supported_USB_Version: u32,
};

pub const USBD_PIPE_TYPE = extern enum(i32) {
    UsbdPipeTypeControl = 0,
    UsbdPipeTypeIsochronous = 1,
    UsbdPipeTypeBulk = 2,
    UsbdPipeTypeInterrupt = 3,
};
pub const UsbdPipeTypeControl = USBD_PIPE_TYPE.UsbdPipeTypeControl;
pub const UsbdPipeTypeIsochronous = USBD_PIPE_TYPE.UsbdPipeTypeIsochronous;
pub const UsbdPipeTypeBulk = USBD_PIPE_TYPE.UsbdPipeTypeBulk;
pub const UsbdPipeTypeInterrupt = USBD_PIPE_TYPE.UsbdPipeTypeInterrupt;

pub const USBD_DEVICE_INFORMATION = extern struct {
    OffsetNext: u32,
    UsbdDeviceHandle: *c_void,
    DeviceDescriptor: USB_DEVICE_DESCRIPTOR,
};

pub const USBD_PIPE_INFORMATION = extern struct {
    MaximumPacketSize: u16,
    EndpointAddress: u8,
    Interval: u8,
    PipeType: USBD_PIPE_TYPE,
    PipeHandle: *c_void,
    MaximumTransferSize: u32,
    PipeFlags: u32,
};

pub const USBD_ENDPOINT_OFFLOAD_MODE = extern enum(i32) {
    UsbdEndpointOffloadModeNotSupported = 0,
    UsbdEndpointOffloadSoftwareAssisted = 1,
    UsbdEndpointOffloadHardwareAssisted = 2,
};
pub const UsbdEndpointOffloadModeNotSupported = USBD_ENDPOINT_OFFLOAD_MODE.UsbdEndpointOffloadModeNotSupported;
pub const UsbdEndpointOffloadSoftwareAssisted = USBD_ENDPOINT_OFFLOAD_MODE.UsbdEndpointOffloadSoftwareAssisted;
pub const UsbdEndpointOffloadHardwareAssisted = USBD_ENDPOINT_OFFLOAD_MODE.UsbdEndpointOffloadHardwareAssisted;

pub const USBD_ENDPOINT_OFFLOAD_INFORMATION = extern struct {
    Size: u32,
    EndpointAddress: u16,
    ResourceId: u32,
    Mode: USBD_ENDPOINT_OFFLOAD_MODE,
    _bitfield1: u32,
    _bitfield2: u32,
    TransferSegmentLA: LARGE_INTEGER,
    TransferSegmentVA: *c_void,
    TransferRingSize: ?*c_void,
    TransferRingInitialCycleBit: u32,
    MessageNumber: u32,
    EventRingSegmentLA: LARGE_INTEGER,
    EventRingSegmentVA: *c_void,
    EventRingSize: ?*c_void,
    EventRingInitialCycleBit: u32,
};

pub const USBD_INTERFACE_INFORMATION = extern struct {
    Length: u16,
    InterfaceNumber: u8,
    AlternateSetting: u8,
    Class: u8,
    SubClass: u8,
    Protocol: u8,
    Reserved: u8,
    InterfaceHandle: *c_void,
    NumberOfPipes: u32,
    Pipes: [1]USBD_PIPE_INFORMATION,
};

pub const _URB_HCD_AREA = extern struct {
    Reserved8: [8]*c_void,
};

pub const _URB_HEADER = extern struct {
    Length: u16,
    Function: u16,
    Status: i32,
    UsbdDeviceHandle: *c_void,
    UsbdFlags: u32,
};

pub const _URB_SELECT_INTERFACE = extern struct {
    Hdr: _URB_HEADER,
    ConfigurationHandle: *c_void,
    Interface: USBD_INTERFACE_INFORMATION,
};

pub const _URB_SELECT_CONFIGURATION = extern struct {
    Hdr: _URB_HEADER,
    ConfigurationDescriptor: *USB_CONFIGURATION_DESCRIPTOR,
    ConfigurationHandle: *c_void,
    Interface: USBD_INTERFACE_INFORMATION,
};

pub const _URB_PIPE_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    Reserved: u32,
};

pub const _URB_FRAME_LENGTH_CONTROL = extern struct {
    Hdr: _URB_HEADER,
};

pub const _URB_GET_FRAME_LENGTH = extern struct {
    Hdr: _URB_HEADER,
    FrameLength: u32,
    FrameNumber: u32,
};

pub const _URB_SET_FRAME_LENGTH = extern struct {
    Hdr: _URB_HEADER,
    FrameLengthDelta: i32,
};

pub const _URB_GET_CURRENT_FRAME_NUMBER = extern struct {
    Hdr: _URB_HEADER,
    FrameNumber: u32,
};

pub const _URB_CONTROL_DESCRIPTOR_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved1: u16,
    Index: u8,
    DescriptorType: u8,
    LanguageId: u16,
    Reserved2: u16,
};

pub const _URB_CONTROL_GET_STATUS_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved1: [4]u8,
    Index: u16,
    Reserved2: u16,
};

pub const _URB_CONTROL_FEATURE_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved2: u32,
    Reserved3: u32,
    Reserved4: *c_void,
    Reserved5: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved0: u16,
    FeatureSelector: u16,
    Index: u16,
    Reserved1: u16,
};

pub const _URB_CONTROL_VENDOR_OR_CLASS_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    RequestTypeReservedBits: u8,
    Request: u8,
    Value: u16,
    Index: u16,
    Reserved1: u16,
};

pub const _URB_CONTROL_GET_INTERFACE_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved1: [4]u8,
    Interface: u16,
    Reserved2: u16,
};

pub const _URB_CONTROL_GET_CONFIGURATION_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    Reserved1: [8]u8,
};

pub const OS_STRING = extern struct {
    bLength: u8,
    bDescriptorType: u8,
    MicrosoftString: [7]u16,
    bVendorCode: u8,
    Anonymous: OS_STRING._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const _URB_OS_FEATURE_DESCRIPTOR_REQUEST = extern struct {
    Hdr: _URB_HEADER,
    Reserved: *c_void,
    Reserved0: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    _bitfield: u8,
    Reserved2: u8,
    InterfaceNumber: u8,
    MS_PageIndex: u8,
    MS_FeatureDescriptorIndex: u16,
    Reserved3: u16,
};

pub const _URB_CONTROL_TRANSFER = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    SetupPacket: [8]u8,
};

pub const _URB_CONTROL_TRANSFER_EX = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    Timeout: u32,
    hca: _URB_HCD_AREA,
    SetupPacket: [8]u8,
};

pub const _URB_BULK_OR_INTERRUPT_TRANSFER = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
};

pub const USBD_ISO_PACKET_DESCRIPTOR = extern struct {
    Offset: u32,
    Length: u32,
    Status: i32,
};

pub const _URB_ISOCH_TRANSFER = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    TransferFlags: u32,
    TransferBufferLength: u32,
    TransferBuffer: *c_void,
    TransferBufferMDL: *c_void,
    UrbLink: *URB,
    hca: _URB_HCD_AREA,
    StartFrame: u32,
    NumberOfPackets: u32,
    ErrorCount: u32,
    IsoPacket: [1]USBD_ISO_PACKET_DESCRIPTOR,
};

pub const USBD_STREAM_INFORMATION = extern struct {
    PipeHandle: *c_void,
    StreamID: u32,
    MaximumTransferSize: u32,
    PipeFlags: u32,
};

pub const _URB_OPEN_STATIC_STREAMS = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    NumberOfStreams: u32,
    StreamInfoVersion: u16,
    StreamInfoSize: u16,
    Streams: *USBD_STREAM_INFORMATION,
};

pub const _URB_GET_ISOCH_PIPE_TRANSFER_PATH_DELAYS = extern struct {
    Hdr: _URB_HEADER,
    PipeHandle: *c_void,
    MaximumSendPathDelayInMilliSeconds: u32,
    MaximumCompletionPathDelayInMilliSeconds: u32,
};

pub const URB = extern struct {
    Anonymous: URB._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const USB_IDLE_CALLBACK = fn(
    Context: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const USB_IDLE_CALLBACK_INFO = extern struct {
    IdleCallback: USB_IDLE_CALLBACK,
    IdleContext: *c_void,
};

pub const USB_USER_ERROR_CODE = extern enum(i32) {
    UsbUserSuccess = 0,
    UsbUserNotSupported = 1,
    UsbUserInvalidRequestCode = 2,
    UsbUserFeatureDisabled = 3,
    UsbUserInvalidHeaderParameter = 4,
    UsbUserInvalidParameter = 5,
    UsbUserMiniportError = 6,
    UsbUserBufferTooSmall = 7,
    UsbUserErrorNotMapped = 8,
    UsbUserDeviceNotStarted = 9,
    UsbUserNoDeviceConnected = 10,
};
pub const UsbUserSuccess = USB_USER_ERROR_CODE.UsbUserSuccess;
pub const UsbUserNotSupported = USB_USER_ERROR_CODE.UsbUserNotSupported;
pub const UsbUserInvalidRequestCode = USB_USER_ERROR_CODE.UsbUserInvalidRequestCode;
pub const UsbUserFeatureDisabled = USB_USER_ERROR_CODE.UsbUserFeatureDisabled;
pub const UsbUserInvalidHeaderParameter = USB_USER_ERROR_CODE.UsbUserInvalidHeaderParameter;
pub const UsbUserInvalidParameter = USB_USER_ERROR_CODE.UsbUserInvalidParameter;
pub const UsbUserMiniportError = USB_USER_ERROR_CODE.UsbUserMiniportError;
pub const UsbUserBufferTooSmall = USB_USER_ERROR_CODE.UsbUserBufferTooSmall;
pub const UsbUserErrorNotMapped = USB_USER_ERROR_CODE.UsbUserErrorNotMapped;
pub const UsbUserDeviceNotStarted = USB_USER_ERROR_CODE.UsbUserDeviceNotStarted;
pub const UsbUserNoDeviceConnected = USB_USER_ERROR_CODE.UsbUserNoDeviceConnected;

pub const USBUSER_REQUEST_HEADER = extern struct {
    UsbUserRequest: u32,
    UsbUserStatusCode: USB_USER_ERROR_CODE,
    RequestBufferLength: u32,
    ActualBufferLength: u32,
};

pub const PACKET_PARAMETERS = extern struct {
    DeviceAddress: u8,
    EndpointAddress: u8,
    MaximumPacketSize: u16,
    Timeout: u32,
    Flags: u32,
    DataLength: u32,
    HubDeviceAddress: u16,
    PortTTNumber: u16,
    ErrorCount: u8,
    Pad: [3]u8,
    UsbdStatusCode: i32,
    Data: [4]u8,
};

pub const USBUSER_SEND_ONE_PACKET = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    PacketParameters: PACKET_PARAMETERS,
};

pub const RAW_RESET_PORT_PARAMETERS = extern struct {
    PortNumber: u16,
    PortStatus: u16,
};

pub const USBUSER_RAW_RESET_ROOT_PORT = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: RAW_RESET_PORT_PARAMETERS,
};

pub const RAW_ROOTPORT_FEATURE = extern struct {
    PortNumber: u16,
    PortFeature: u16,
    PortStatus: u16,
};

pub const USBUSER_ROOTPORT_FEATURE_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: RAW_ROOTPORT_FEATURE,
};

pub const RAW_ROOTPORT_PARAMETERS = extern struct {
    PortNumber: u16,
    PortStatus: u16,
};

pub const USBUSER_ROOTPORT_PARAMETERS = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: RAW_ROOTPORT_PARAMETERS,
};

pub const USB_CONTROLLER_INFO_0 = extern struct {
    PciVendorId: u32,
    PciDeviceId: u32,
    PciRevision: u32,
    NumberOfRootPorts: u32,
    ControllerFlavor: USB_CONTROLLER_FLAVOR,
    HcFeatureFlags: u32,
};

pub const USBUSER_CONTROLLER_INFO_0 = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Info0: USB_CONTROLLER_INFO_0,
};

pub const USB_UNICODE_NAME = extern struct {
    Length: u32,
    String: [1]u16,
};

pub const USBUSER_CONTROLLER_UNICODE_NAME = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    UnicodeName: USB_UNICODE_NAME,
};

pub const USB_PASS_THRU_PARAMETERS = extern struct {
    FunctionGUID: Guid,
    ParameterLength: u32,
    Parameters: [4]u8,
};

pub const USBUSER_PASS_THRU_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    PassThru: USB_PASS_THRU_PARAMETERS,
};

pub const WDMUSB_POWER_STATE = extern enum(i32) {
    WdmUsbPowerNotMapped = 0,
    WdmUsbPowerSystemUnspecified = 100,
    WdmUsbPowerSystemWorking = 101,
    WdmUsbPowerSystemSleeping1 = 102,
    WdmUsbPowerSystemSleeping2 = 103,
    WdmUsbPowerSystemSleeping3 = 104,
    WdmUsbPowerSystemHibernate = 105,
    WdmUsbPowerSystemShutdown = 106,
    WdmUsbPowerDeviceUnspecified = 200,
    WdmUsbPowerDeviceD0 = 201,
    WdmUsbPowerDeviceD1 = 202,
    WdmUsbPowerDeviceD2 = 203,
    WdmUsbPowerDeviceD3 = 204,
};
pub const WdmUsbPowerNotMapped = WDMUSB_POWER_STATE.WdmUsbPowerNotMapped;
pub const WdmUsbPowerSystemUnspecified = WDMUSB_POWER_STATE.WdmUsbPowerSystemUnspecified;
pub const WdmUsbPowerSystemWorking = WDMUSB_POWER_STATE.WdmUsbPowerSystemWorking;
pub const WdmUsbPowerSystemSleeping1 = WDMUSB_POWER_STATE.WdmUsbPowerSystemSleeping1;
pub const WdmUsbPowerSystemSleeping2 = WDMUSB_POWER_STATE.WdmUsbPowerSystemSleeping2;
pub const WdmUsbPowerSystemSleeping3 = WDMUSB_POWER_STATE.WdmUsbPowerSystemSleeping3;
pub const WdmUsbPowerSystemHibernate = WDMUSB_POWER_STATE.WdmUsbPowerSystemHibernate;
pub const WdmUsbPowerSystemShutdown = WDMUSB_POWER_STATE.WdmUsbPowerSystemShutdown;
pub const WdmUsbPowerDeviceUnspecified = WDMUSB_POWER_STATE.WdmUsbPowerDeviceUnspecified;
pub const WdmUsbPowerDeviceD0 = WDMUSB_POWER_STATE.WdmUsbPowerDeviceD0;
pub const WdmUsbPowerDeviceD1 = WDMUSB_POWER_STATE.WdmUsbPowerDeviceD1;
pub const WdmUsbPowerDeviceD2 = WDMUSB_POWER_STATE.WdmUsbPowerDeviceD2;
pub const WdmUsbPowerDeviceD3 = WDMUSB_POWER_STATE.WdmUsbPowerDeviceD3;

pub const USB_POWER_INFO = extern struct {
    SystemState: WDMUSB_POWER_STATE,
    HcDevicePowerState: WDMUSB_POWER_STATE,
    HcDeviceWake: WDMUSB_POWER_STATE,
    HcSystemWake: WDMUSB_POWER_STATE,
    RhDevicePowerState: WDMUSB_POWER_STATE,
    RhDeviceWake: WDMUSB_POWER_STATE,
    RhSystemWake: WDMUSB_POWER_STATE,
    LastSystemSleepState: WDMUSB_POWER_STATE,
    CanWakeup: u8,
    IsPowered: u8,
};

pub const USBUSER_POWER_INFO_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    PowerInformation: USB_POWER_INFO,
};

pub const USB_OPEN_RAW_DEVICE_PARAMETERS = extern struct {
    PortStatus: u16,
    MaxPacketEp0: u16,
};

pub const USBUSER_OPEN_RAW_DEVICE = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_OPEN_RAW_DEVICE_PARAMETERS,
};

pub const USB_CLOSE_RAW_DEVICE_PARAMETERS = extern struct {
    xxx: u32,
};

pub const USBUSER_CLOSE_RAW_DEVICE = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_CLOSE_RAW_DEVICE_PARAMETERS,
};

pub const USB_SEND_RAW_COMMAND_PARAMETERS = extern struct {
    Usb_bmRequest: u8,
    Usb_bRequest: u8,
    Usb_wVlaue: u16,
    Usb_wIndex: u16,
    Usb_wLength: u16,
    DeviceAddress: u16,
    MaximumPacketSize: u16,
    Timeout: u32,
    DataLength: u32,
    UsbdStatusCode: i32,
    Data: [4]u8,
};

pub const USBUSER_SEND_RAW_COMMAND = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_SEND_RAW_COMMAND_PARAMETERS,
};

pub const USB_BANDWIDTH_INFO = extern struct {
    DeviceCount: u32,
    TotalBusBandwidth: u32,
    Total32secBandwidth: u32,
    AllocedBulkAndControl: u32,
    AllocedIso: u32,
    AllocedInterrupt_1ms: u32,
    AllocedInterrupt_2ms: u32,
    AllocedInterrupt_4ms: u32,
    AllocedInterrupt_8ms: u32,
    AllocedInterrupt_16ms: u32,
    AllocedInterrupt_32ms: u32,
};

pub const USBUSER_BANDWIDTH_INFO_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    BandwidthInformation: USB_BANDWIDTH_INFO,
};

pub const USB_BUS_STATISTICS_0 = extern struct {
    DeviceCount: u32,
    CurrentSystemTime: LARGE_INTEGER,
    CurrentUsbFrame: u32,
    BulkBytes: u32,
    IsoBytes: u32,
    InterruptBytes: u32,
    ControlDataBytes: u32,
    PciInterruptCount: u32,
    HardResetCount: u32,
    WorkerSignalCount: u32,
    CommonBufferBytes: u32,
    WorkerIdleTimeMs: u32,
    RootHubEnabled: u8,
    RootHubDevicePowerState: u8,
    Unused: u8,
    NameIndex: u8,
};

pub const USBUSER_BUS_STATISTICS_0_REQUEST = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    BusStatistics0: USB_BUS_STATISTICS_0,
};

pub const USB_DRIVER_VERSION_PARAMETERS = extern struct {
    DriverTrackingCode: u32,
    USBDI_Version: u32,
    USBUSER_Version: u32,
    CheckedPortDriver: u8,
    CheckedMiniportDriver: u8,
    USB_Version: u16,
};

pub const USBUSER_GET_DRIVER_VERSION = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_DRIVER_VERSION_PARAMETERS,
};

pub const USB_USB2HW_VERSION_PARAMETERS = extern struct {
    Usb2HwRevision: u8,
};

pub const USBUSER_GET_USB2HW_VERSION = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Parameters: USB_USB2HW_VERSION_PARAMETERS,
};

pub const USBUSER_REFRESH_HCT_REG = extern struct {
    Header: USBUSER_REQUEST_HEADER,
    Flags: u32,
};

pub const WINUSB_PIPE_INFORMATION = extern struct {
    PipeType: USBD_PIPE_TYPE,
    PipeId: u8,
    MaximumPacketSize: u16,
    Interval: u8,
};

pub const WINUSB_PIPE_INFORMATION_EX = extern struct {
    PipeType: USBD_PIPE_TYPE,
    PipeId: u8,
    MaximumPacketSize: u16,
    Interval: u8,
    MaximumBytesPerInterval: u32,
};

pub const WINUSB_SETUP_PACKET = extern struct {
    RequestType: u8,
    Request: u8,
    Value: u16,
    Index: u16,
    Length: u16,
};

pub const USB_START_TRACKING_FOR_TIME_SYNC_INFORMATION = extern struct {
    TimeTrackingHandle: HANDLE,
    IsStartupDelayTolerable: u8,
};

pub const USB_STOP_TRACKING_FOR_TIME_SYNC_INFORMATION = extern struct {
    TimeTrackingHandle: HANDLE,
};

pub const USB_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC_INFORMATION = extern struct {
    TimeTrackingHandle: HANDLE,
    InputFrameNumber: u32,
    InputMicroFrameNumber: u32,
    QueryPerformanceCounterAtInputFrameOrMicroFrame: LARGE_INTEGER,
    QueryPerformanceCounterFrequency: LARGE_INTEGER,
    PredictedAccuracyInMicroSeconds: u32,
    CurrentGenerationID: u32,
    CurrentQueryPerformanceCounter: LARGE_INTEGER,
    CurrentHardwareFrameNumber: u32,
    CurrentHardwareMicroFrameNumber: u32,
    CurrentUSBFrameNumber: u32,
};


//--------------------------------------------------------------------------------
// Section: Functions (34)
//--------------------------------------------------------------------------------
pub extern "WINUSB" fn WinUsb_Initialize(
    DeviceHandle: HANDLE,
    InterfaceHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_Free(
    InterfaceHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetAssociatedInterface(
    InterfaceHandle: *c_void,
    AssociatedInterfaceIndex: u8,
    AssociatedInterfaceHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetDescriptor(
    InterfaceHandle: *c_void,
    DescriptorType: u8,
    Index: u8,
    LanguageID: u16,
    Buffer: ?[*:0]u8,
    BufferLength: u32,
    LengthTransferred: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_QueryInterfaceSettings(
    InterfaceHandle: *c_void,
    AlternateInterfaceNumber: u8,
    UsbAltInterfaceDescriptor: *USB_INTERFACE_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_QueryDeviceInformation(
    InterfaceHandle: *c_void,
    InformationType: u32,
    BufferLength: *u32,
    Buffer: [*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_SetCurrentAlternateSetting(
    InterfaceHandle: *c_void,
    SettingNumber: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetCurrentAlternateSetting(
    InterfaceHandle: *c_void,
    SettingNumber: *u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_QueryPipe(
    InterfaceHandle: *c_void,
    AlternateInterfaceNumber: u8,
    PipeIndex: u8,
    PipeInformation: *WINUSB_PIPE_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_QueryPipeEx(
    InterfaceHandle: *c_void,
    AlternateSettingNumber: u8,
    PipeIndex: u8,
    PipeInformationEx: *WINUSB_PIPE_INFORMATION_EX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_SetPipePolicy(
    InterfaceHandle: *c_void,
    PipeID: u8,
    PolicyType: u32,
    ValueLength: u32,
    Value: [*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetPipePolicy(
    InterfaceHandle: *c_void,
    PipeID: u8,
    PolicyType: u32,
    ValueLength: *u32,
    Value: [*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ReadPipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
    Buffer: ?[*:0]u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_WritePipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
    Buffer: [*:0]u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ControlTransfer(
    InterfaceHandle: *c_void,
    SetupPacket: WINUSB_SETUP_PACKET,
    Buffer: ?[*:0]u8,
    BufferLength: u32,
    LengthTransferred: ?*u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ResetPipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_AbortPipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_FlushPipe(
    InterfaceHandle: *c_void,
    PipeID: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_SetPowerPolicy(
    InterfaceHandle: *c_void,
    PolicyType: u32,
    ValueLength: u32,
    Value: [*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetPowerPolicy(
    InterfaceHandle: *c_void,
    PolicyType: u32,
    ValueLength: *u32,
    Value: [*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetOverlappedResult(
    InterfaceHandle: *c_void,
    lpOverlapped: *OVERLAPPED,
    lpNumberOfBytesTransferred: *u32,
    bWait: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ParseConfigurationDescriptor(
    ConfigurationDescriptor: *USB_CONFIGURATION_DESCRIPTOR,
    StartPosition: *c_void,
    InterfaceNumber: i32,
    AlternateSetting: i32,
    InterfaceClass: i32,
    InterfaceSubClass: i32,
    InterfaceProtocol: i32,
) callconv(@import("std").os.windows.WINAPI) *USB_INTERFACE_DESCRIPTOR;

pub extern "WINUSB" fn WinUsb_ParseDescriptors(
    DescriptorBuffer: [*]u8,
    TotalLength: u32,
    StartPosition: *c_void,
    DescriptorType: i32,
) callconv(@import("std").os.windows.WINAPI) *USB_COMMON_DESCRIPTOR;

pub extern "WINUSB" fn WinUsb_GetCurrentFrameNumber(
    InterfaceHandle: *c_void,
    CurrentFrameNumber: *u32,
    TimeStamp: *LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetAdjustedFrameNumber(
    CurrentFrameNumber: *u32,
    TimeStamp: LARGE_INTEGER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_RegisterIsochBuffer(
    InterfaceHandle: *c_void,
    PipeID: u8,
    Buffer: [*:0]u8,
    BufferLength: u32,
    IsochBufferHandle: **c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_UnregisterIsochBuffer(
    IsochBufferHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_WriteIsochPipe(
    BufferHandle: *c_void,
    Offset: u32,
    Length: u32,
    FrameNumber: *u32,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ReadIsochPipe(
    BufferHandle: *c_void,
    Offset: u32,
    Length: u32,
    FrameNumber: *u32,
    NumberOfPackets: u32,
    IsoPacketDescriptors: [*]USBD_ISO_PACKET_DESCRIPTOR,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_WriteIsochPipeAsap(
    BufferHandle: *c_void,
    Offset: u32,
    Length: u32,
    ContinueStream: BOOL,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_ReadIsochPipeAsap(
    BufferHandle: *c_void,
    Offset: u32,
    Length: u32,
    ContinueStream: BOOL,
    NumberOfPackets: u32,
    IsoPacketDescriptors: [*]USBD_ISO_PACKET_DESCRIPTOR,
    Overlapped: ?*OVERLAPPED,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_StartTrackingForTimeSync(
    InterfaceHandle: *c_void,
    StartTrackingInfo: *USB_START_TRACKING_FOR_TIME_SYNC_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_GetCurrentFrameNumberAndQpc(
    InterfaceHandle: *c_void,
    FrameQpcInfo: *USB_FRAME_NUMBER_AND_QPC_FOR_TIME_SYNC_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINUSB" fn WinUsb_StopTrackingForTimeSync(
    InterfaceHandle: *c_void,
    StopTrackingInfo: *USB_STOP_TRACKING_FOR_TIME_SYNC_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (5)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const LARGE_INTEGER = @import("system_services.zig").LARGE_INTEGER;
const HANDLE = @import("system_services.zig").HANDLE;
const BOOL = @import("system_services.zig").BOOL;
const OVERLAPPED = @import("system_services.zig").OVERLAPPED;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = USB_IDLE_CALLBACK;

    const constant_export_count = 1;
    const type_export_count = 124;
    const enum_value_export_count = 64;
    const com_iface_id_export_count = 0;
    const com_class_id_export_count = 0;
    const func_export_count = 34;
    const unicode_alias_count = 0;
    const import_count = 5;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
