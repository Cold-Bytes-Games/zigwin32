//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (357)
//--------------------------------------------------------------------------------
pub const CRGB = extern struct {
    bRed: u8,
    bGreen: u8,
    bBlue: u8,
    bExtra: u8,
};

pub const _PSP = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const LPFNPSPCALLBACKA = fn(
    hwnd: HWND,
    uMsg: u32,
    ppsp: *PROPSHEETPAGEA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const LPFNPSPCALLBACKW = fn(
    hwnd: HWND,
    uMsg: u32,
    ppsp: *PROPSHEETPAGEW,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PROPSHEETPAGEA_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETPAGEA_V1._Anonymous1_e__Union,
    Anonymous2: PROPSHEETPAGEA_V1._Anonymous2_e__Union,
    pszTitle: [*:0]const u8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: *u32,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEA_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETPAGEA_V2._Anonymous1_e__Union,
    Anonymous2: PROPSHEETPAGEA_V2._Anonymous2_e__Union,
    pszTitle: [*:0]const u8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u8,
    pszHeaderSubTitle: [*:0]const u8,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEA_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETPAGEA_V3._Anonymous1_e__Union,
    Anonymous2: PROPSHEETPAGEA_V3._Anonymous2_e__Union,
    pszTitle: [*:0]const u8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u8,
    pszHeaderSubTitle: [*:0]const u8,
    hActCtx: HANDLE,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEA = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETPAGEA._Anonymous1_e__Union,
    Anonymous2: PROPSHEETPAGEA._Anonymous2_e__Union,
    pszTitle: [*:0]const u8,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u8,
    pszHeaderSubTitle: [*:0]const u8,
    hActCtx: HANDLE,
    Anonymous3: PROPSHEETPAGEA._Anonymous3_e__Union,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEW_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETPAGEW_V1._Anonymous1_e__Union,
    Anonymous2: PROPSHEETPAGEW_V1._Anonymous2_e__Union,
    pszTitle: [*:0]const u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: *u32,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEW_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETPAGEW_V2._Anonymous1_e__Union,
    Anonymous2: PROPSHEETPAGEW_V2._Anonymous2_e__Union,
    pszTitle: [*:0]const u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u16,
    pszHeaderSubTitle: [*:0]const u16,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEW_V3 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETPAGEW_V3._Anonymous1_e__Union,
    Anonymous2: PROPSHEETPAGEW_V3._Anonymous2_e__Union,
    pszTitle: [*:0]const u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u16,
    pszHeaderSubTitle: [*:0]const u16,
    hActCtx: HANDLE,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETPAGEW = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETPAGEW._Anonymous1_e__Union,
    Anonymous2: PROPSHEETPAGEW._Anonymous2_e__Union,
    pszTitle: [*:0]const u16,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: *u32,
    pszHeaderTitle: [*:0]const u16,
    pszHeaderSubTitle: [*:0]const u16,
    hActCtx: HANDLE,
    Anonymous3: PROPSHEETPAGEW._Anonymous3_e__Union,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
};

pub const PFNPROPSHEETCALLBACK = fn(
    param0: HWND,
    param1: u32,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PROPSHEETHEADERA_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETHEADERA_V1._Anonymous1_e__Union,
    pszCaption: [*:0]const u8,
    nPages: u32,
    Anonymous2: PROPSHEETHEADERA_V1._Anonymous2_e__Union,
    Anonymous3: PROPSHEETHEADERA_V1._Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETHEADERA_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETHEADERA_V2._Anonymous1_e__Union,
    pszCaption: [*:0]const u8,
    nPages: u32,
    Anonymous2: PROPSHEETHEADERA_V2._Anonymous2_e__Union,
    Anonymous3: PROPSHEETHEADERA_V2._Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    Anonymous4: PROPSHEETHEADERA_V2._Anonymous4_e__Union,
    hplWatermark: HPALETTE,
    Anonymous5: PROPSHEETHEADERA_V2._Anonymous5_e__Union,
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETHEADERW_V1 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETHEADERW_V1._Anonymous1_e__Union,
    pszCaption: [*:0]const u16,
    nPages: u32,
    Anonymous2: PROPSHEETHEADERW_V1._Anonymous2_e__Union,
    Anonymous3: PROPSHEETHEADERW_V1._Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PROPSHEETHEADERW_V2 = extern struct {
    dwSize: u32,
    dwFlags: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    Anonymous1: PROPSHEETHEADERW_V2._Anonymous1_e__Union,
    pszCaption: [*:0]const u16,
    nPages: u32,
    Anonymous2: PROPSHEETHEADERW_V2._Anonymous2_e__Union,
    Anonymous3: PROPSHEETHEADERW_V2._Anonymous3_e__Union,
    pfnCallback: PFNPROPSHEETCALLBACK,
    Anonymous4: PROPSHEETHEADERW_V2._Anonymous4_e__Union,
    hplWatermark: HPALETTE,
    Anonymous5: PROPSHEETHEADERW_V2._Anonymous5_e__Union,
    const _Anonymous4_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous3_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous5_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const LPFNADDPROPSHEETPAGE = fn(
    param0: HPROPSHEETPAGE,
    param1: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPFNADDPROPSHEETPAGES = fn(
    param0: *c_void,
    param1: LPFNADDPROPSHEETPAGE,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSHNOTIFY = extern struct {
    hdr: NMHDR,
    lParam: LPARAM,
};

pub const INITCOMMONCONTROLSEX = extern struct {
    dwSize: u32,
    dwICC: u32,
};

pub const COLORSCHEME = extern struct {
    dwSize: u32,
    clrBtnHighlight: u32,
    clrBtnShadow: u32,
};

pub const NMTOOLTIPSCREATED = extern struct {
    hdr: NMHDR,
    hwndToolTips: HWND,
};

pub const NMMOUSE = extern struct {
    hdr: NMHDR,
    dwItemSpec: ?*c_void,
    dwItemData: ?*c_void,
    pt: POINT,
    dwHitInfo: LPARAM,
};

pub const NMOBJECTNOTIFY = extern struct {
    hdr: NMHDR,
    iItem: i32,
    piid: *const Guid,
    pObject: *c_void,
    hResult: HRESULT,
    dwFlags: u32,
};

pub const NMKEY = extern struct {
    hdr: NMHDR,
    nVKey: u32,
    uFlags: u32,
};

pub const NMCHAR = extern struct {
    hdr: NMHDR,
    ch: u32,
    dwItemPrev: u32,
    dwItemNext: u32,
};

pub const NMCUSTOMTEXT = extern struct {
    hdr: NMHDR,
    hDC: HDC,
    lpString: [*:0]const u16,
    nCount: i32,
    lpRect: *RECT,
    uFormat: u32,
    fLink: BOOL,
};

pub const NMCUSTOMDRAW = extern struct {
    hdr: NMHDR,
    dwDrawStage: u32,
    hdc: HDC,
    rc: RECT,
    dwItemSpec: ?*c_void,
    uItemState: u32,
    lItemlParam: LPARAM,
};

pub const NMTTCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    uDrawFlags: u32,
};

pub const NMCUSTOMSPLITRECTINFO = extern struct {
    hdr: NMHDR,
    rcClient: RECT,
    rcButton: RECT,
    rcSplit: RECT,
};

pub const _IMAGELIST = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const IMAGELISTDRAWPARAMS = extern struct {
    cbSize: u32,
    himl: HIMAGELIST,
    i: i32,
    hdcDst: HDC,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    xBitmap: i32,
    yBitmap: i32,
    rgbBk: u32,
    rgbFg: u32,
    fStyle: u32,
    dwRop: u32,
    fState: u32,
    Frame: u32,
    crEffect: u32,
};

pub const IMAGEINFO = extern struct {
    hbmImage: HBITMAP,
    hbmMask: HBITMAP,
    Unused1: i32,
    Unused2: i32,
    rcImage: RECT,
};

pub const HD_TEXTFILTERA = extern struct {
    pszText: PSTR,
    cchTextMax: i32,
};

pub const HD_TEXTFILTERW = extern struct {
    pszText: PWSTR,
    cchTextMax: i32,
};

pub const HDITEMA = extern struct {
    mask: u32,
    cxy: i32,
    pszText: PSTR,
    hbm: HBITMAP,
    cchTextMax: i32,
    fmt: i32,
    lParam: LPARAM,
    iImage: i32,
    iOrder: i32,
    type: u32,
    pvFilter: *c_void,
    state: u32,
};

pub const HDITEMW = extern struct {
    mask: u32,
    cxy: i32,
    pszText: PWSTR,
    hbm: HBITMAP,
    cchTextMax: i32,
    fmt: i32,
    lParam: LPARAM,
    iImage: i32,
    iOrder: i32,
    type: u32,
    pvFilter: *c_void,
    state: u32,
};

pub const HDLAYOUT = extern struct {
    prc: *RECT,
    pwpos: *WINDOWPOS,
};

pub const HDHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iItem: i32,
};

pub const NMHEADERA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iButton: i32,
    pitem: *HDITEMA,
};

pub const NMHEADERW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iButton: i32,
    pitem: *HDITEMW,
};

pub const NMHDDISPINFOW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    mask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const NMHDDISPINFOA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    mask: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const NMHDFILTERBTNCLICK = extern struct {
    hdr: NMHDR,
    iItem: i32,
    rc: RECT,
};

pub const TBBUTTON = extern struct {
    iBitmap: i32,
    idCommand: i32,
    fsState: u8,
    fsStyle: u8,
    bReserved: [2]u8,
    dwData: ?*c_void,
    iString: ?*c_void,
};

pub const COLORMAP = extern struct {
    from: u32,
    to: u32,
};

pub const NMTBCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    hbrMonoDither: HBRUSH,
    hbrLines: HBRUSH,
    hpenLines: HPEN,
    clrText: u32,
    clrMark: u32,
    clrTextHighlight: u32,
    clrBtnFace: u32,
    clrBtnHighlight: u32,
    clrHighlightHotTrack: u32,
    rcText: RECT,
    nStringBkMode: i32,
    nHLStringBkMode: i32,
    iListGap: i32,
};

pub const TBADDBITMAP = extern struct {
    hInst: HINSTANCE,
    nID: ?*c_void,
};

pub const TBSAVEPARAMSA = extern struct {
    hkr: HKEY,
    pszSubKey: [*:0]const u8,
    pszValueName: [*:0]const u8,
};

pub const TBSAVEPARAMSW = extern struct {
    hkr: HKEY,
    pszSubKey: [*:0]const u16,
    pszValueName: [*:0]const u16,
};

pub const TBINSERTMARK = extern struct {
    iButton: i32,
    dwFlags: u32,
};

pub const TBREPLACEBITMAP = extern struct {
    hInstOld: HINSTANCE,
    nIDOld: ?*c_void,
    hInstNew: HINSTANCE,
    nIDNew: ?*c_void,
    nButtons: i32,
};

pub const TBBUTTONINFOA = extern struct {
    cbSize: u32,
    dwMask: u32,
    idCommand: i32,
    iImage: i32,
    fsState: u8,
    fsStyle: u8,
    cx: u16,
    lParam: ?*c_void,
    pszText: PSTR,
    cchText: i32,
};

pub const TBBUTTONINFOW = extern struct {
    cbSize: u32,
    dwMask: u32,
    idCommand: i32,
    iImage: i32,
    fsState: u8,
    fsStyle: u8,
    cx: u16,
    lParam: ?*c_void,
    pszText: PWSTR,
    cchText: i32,
};

pub const TBMETRICS = extern struct {
    cbSize: u32,
    dwMask: u32,
    cxPad: i32,
    cyPad: i32,
    cxBarPad: i32,
    cyBarPad: i32,
    cxButtonSpacing: i32,
    cyButtonSpacing: i32,
};

pub const NMTBHOTITEM = extern struct {
    hdr: NMHDR,
    idOld: i32,
    idNew: i32,
    dwFlags: u32,
};

pub const NMTBSAVE = extern struct {
    hdr: NMHDR,
    pData: *u32,
    pCurrent: *u32,
    cbData: u32,
    iItem: i32,
    cButtons: i32,
    tbButton: TBBUTTON,
};

pub const NMTBRESTORE = extern struct {
    hdr: NMHDR,
    pData: *u32,
    pCurrent: *u32,
    cbData: u32,
    iItem: i32,
    cButtons: i32,
    cbBytesPerRecord: i32,
    tbButton: TBBUTTON,
};

pub const NMTBGETINFOTIPA = extern struct {
    hdr: NMHDR,
    pszText: PSTR,
    cchTextMax: i32,
    iItem: i32,
    lParam: LPARAM,
};

pub const NMTBGETINFOTIPW = extern struct {
    hdr: NMHDR,
    pszText: PWSTR,
    cchTextMax: i32,
    iItem: i32,
    lParam: LPARAM,
};

pub const NMTBDISPINFOA = extern struct {
    hdr: NMHDR,
    dwMask: u32,
    idCommand: i32,
    lParam: ?*c_void,
    iImage: i32,
    pszText: PSTR,
    cchText: i32,
};

pub const NMTBDISPINFOW = extern struct {
    hdr: NMHDR,
    dwMask: u32,
    idCommand: i32,
    lParam: ?*c_void,
    iImage: i32,
    pszText: PWSTR,
    cchText: i32,
};

pub const NMTOOLBARA = extern struct {
    hdr: NMHDR,
    iItem: i32,
    tbButton: TBBUTTON,
    cchText: i32,
    pszText: PSTR,
    rcButton: RECT,
};

pub const NMTOOLBARW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    tbButton: TBBUTTON,
    cchText: i32,
    pszText: PWSTR,
    rcButton: RECT,
};

pub const REBARINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    himl: HIMAGELIST,
};

pub const REBARBANDINFOA = extern struct {
    cbSize: u32,
    fMask: u32,
    fStyle: u32,
    clrFore: u32,
    clrBack: u32,
    lpText: PSTR,
    cch: u32,
    iImage: i32,
    hwndChild: HWND,
    cxMinChild: u32,
    cyMinChild: u32,
    cx: u32,
    hbmBack: HBITMAP,
    wID: u32,
    cyChild: u32,
    cyMaxChild: u32,
    cyIntegral: u32,
    cxIdeal: u32,
    lParam: LPARAM,
    cxHeader: u32,
    rcChevronLocation: RECT,
    uChevronState: u32,
};

pub const REBARBANDINFOW = extern struct {
    cbSize: u32,
    fMask: u32,
    fStyle: u32,
    clrFore: u32,
    clrBack: u32,
    lpText: PWSTR,
    cch: u32,
    iImage: i32,
    hwndChild: HWND,
    cxMinChild: u32,
    cyMinChild: u32,
    cx: u32,
    hbmBack: HBITMAP,
    wID: u32,
    cyChild: u32,
    cyMaxChild: u32,
    cyIntegral: u32,
    cxIdeal: u32,
    lParam: LPARAM,
    cxHeader: u32,
    rcChevronLocation: RECT,
    uChevronState: u32,
};

pub const NMREBARCHILDSIZE = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    rcChild: RECT,
    rcBand: RECT,
};

pub const NMREBAR = extern struct {
    hdr: NMHDR,
    dwMask: u32,
    uBand: u32,
    fStyle: u32,
    wID: u32,
    lParam: LPARAM,
};

pub const NMRBAUTOSIZE = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    rcTarget: RECT,
    rcActual: RECT,
};

pub const NMREBARCHEVRON = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    lParam: LPARAM,
    rc: RECT,
    lParamNM: LPARAM,
};

pub const NMREBARSPLITTER = extern struct {
    hdr: NMHDR,
    rcSizing: RECT,
};

pub const NMREBARAUTOBREAK = extern struct {
    hdr: NMHDR,
    uBand: u32,
    wID: u32,
    lParam: LPARAM,
    uMsg: u32,
    fStyleCurrent: u32,
    fAutoBreak: BOOL,
};

pub const RBHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iBand: i32,
};

pub const TTTOOLINFOA = extern struct {
    cbSize: u32,
    uFlags: u32,
    hwnd: HWND,
    uId: ?*c_void,
    rect: RECT,
    hinst: HINSTANCE,
    lpszText: PSTR,
    lParam: LPARAM,
    lpReserved: *c_void,
};

pub const TTTOOLINFOW = extern struct {
    cbSize: u32,
    uFlags: u32,
    hwnd: HWND,
    uId: ?*c_void,
    rect: RECT,
    hinst: HINSTANCE,
    lpszText: PWSTR,
    lParam: LPARAM,
    lpReserved: *c_void,
};

pub const TTGETTITLE = extern struct {
    dwSize: u32,
    uTitleBitmap: u32,
    cch: u32,
    pszTitle: PWSTR,
};

pub const TTHITTESTINFOA = extern struct {
    hwnd: HWND,
    pt: POINT,
    ti: TTTOOLINFOA,
};

pub const TTHITTESTINFOW = extern struct {
    hwnd: HWND,
    pt: POINT,
    ti: TTTOOLINFOW,
};

pub const NMTTDISPINFOA = extern struct {
    hdr: NMHDR,
    lpszText: PSTR,
    szText: [80]i8,
    hinst: HINSTANCE,
    uFlags: u32,
    lParam: LPARAM,
};

pub const NMTTDISPINFOW = extern struct {
    hdr: NMHDR,
    lpszText: PWSTR,
    szText: [80]u16,
    hinst: HINSTANCE,
    uFlags: u32,
    lParam: LPARAM,
};

pub const NMTRBTHUMBPOSCHANGING = extern struct {
    hdr: NMHDR,
    dwPos: u32,
    nReason: i32,
};

pub const DRAGLISTINFO = extern struct {
    uNotification: u32,
    hWnd: HWND,
    ptCursor: POINT,
};

pub const UDACCEL = extern struct {
    nSec: u32,
    nInc: u32,
};

pub const NMUPDOWN = extern struct {
    hdr: NMHDR,
    iPos: i32,
    iDelta: i32,
};

pub const PBRANGE = extern struct {
    iLow: i32,
    iHigh: i32,
};

pub const LITEM = extern struct {
    mask: u32,
    iLink: i32,
    state: u32,
    stateMask: u32,
    szID: [48]u16,
    szUrl: [2084]u16,
};

pub const LHITTESTINFO = extern struct {
    pt: POINT,
    item: LITEM,
};

pub const NMLINK = extern struct {
    hdr: NMHDR,
    item: LITEM,
};

pub const LVITEMA = extern struct {
    mask: u32,
    iItem: i32,
    iSubItem: i32,
    state: u32,
    stateMask: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
    iIndent: i32,
    iGroupId: i32,
    cColumns: u32,
    puColumns: *u32,
    piColFmt: *i32,
    iGroup: i32,
};

pub const LVITEMW = extern struct {
    mask: u32,
    iItem: i32,
    iSubItem: i32,
    state: u32,
    stateMask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
    iIndent: i32,
    iGroupId: i32,
    cColumns: u32,
    puColumns: *u32,
    piColFmt: *i32,
    iGroup: i32,
};

pub const LVFINDINFOA = extern struct {
    flags: u32,
    psz: [*:0]const u8,
    lParam: LPARAM,
    pt: POINT,
    vkDirection: u32,
};

pub const LVFINDINFOW = extern struct {
    flags: u32,
    psz: [*:0]const u16,
    lParam: LPARAM,
    pt: POINT,
    vkDirection: u32,
};

pub const LVHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    iItem: i32,
    iSubItem: i32,
    iGroup: i32,
};

pub const LVCOLUMNA = extern struct {
    mask: u32,
    fmt: i32,
    cx: i32,
    pszText: PSTR,
    cchTextMax: i32,
    iSubItem: i32,
    iImage: i32,
    iOrder: i32,
    cxMin: i32,
    cxDefault: i32,
    cxIdeal: i32,
};

pub const LVCOLUMNW = extern struct {
    mask: u32,
    fmt: i32,
    cx: i32,
    pszText: PWSTR,
    cchTextMax: i32,
    iSubItem: i32,
    iImage: i32,
    iOrder: i32,
    cxMin: i32,
    cxDefault: i32,
    cxIdeal: i32,
};

pub const PFNLVCOMPARE = fn(
    param0: LPARAM,
    param1: LPARAM,
    param2: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LVBKIMAGEA = extern struct {
    ulFlags: u32,
    hbm: HBITMAP,
    pszImage: PSTR,
    cchImageMax: u32,
    xOffsetPercent: i32,
    yOffsetPercent: i32,
};

pub const LVBKIMAGEW = extern struct {
    ulFlags: u32,
    hbm: HBITMAP,
    pszImage: PWSTR,
    cchImageMax: u32,
    xOffsetPercent: i32,
    yOffsetPercent: i32,
};

pub const LVGROUP = extern struct {
    cbSize: u32,
    mask: u32,
    pszHeader: PWSTR,
    cchHeader: i32,
    pszFooter: PWSTR,
    cchFooter: i32,
    iGroupId: i32,
    stateMask: u32,
    state: u32,
    uAlign: u32,
    pszSubtitle: PWSTR,
    cchSubtitle: u32,
    pszTask: PWSTR,
    cchTask: u32,
    pszDescriptionTop: PWSTR,
    cchDescriptionTop: u32,
    pszDescriptionBottom: PWSTR,
    cchDescriptionBottom: u32,
    iTitleImage: i32,
    iExtendedImage: i32,
    iFirstItem: i32,
    cItems: u32,
    pszSubsetTitle: PWSTR,
    cchSubsetTitle: u32,
};

pub const LVGROUPMETRICS = extern struct {
    cbSize: u32,
    mask: u32,
    Left: u32,
    Top: u32,
    Right: u32,
    Bottom: u32,
    crLeft: u32,
    crTop: u32,
    crRight: u32,
    crBottom: u32,
    crHeader: u32,
    crFooter: u32,
};

pub const PFNLVGROUPCOMPARE = fn(
    param0: i32,
    param1: i32,
    param2: *c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LVINSERTGROUPSORTED = extern struct {
    pfnGroupCompare: PFNLVGROUPCOMPARE,
    pvData: *c_void,
    lvGroup: LVGROUP,
};

pub const LVTILEVIEWINFO = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwFlags: u32,
    sizeTile: SIZE,
    cLines: i32,
    rcLabelMargin: RECT,
};

pub const LVTILEINFO = extern struct {
    cbSize: u32,
    iItem: i32,
    cColumns: u32,
    puColumns: *u32,
    piColFmt: *i32,
};

pub const LVINSERTMARK = extern struct {
    cbSize: u32,
    dwFlags: u32,
    iItem: i32,
    dwReserved: u32,
};

pub const LVSETINFOTIP = extern struct {
    cbSize: u32,
    dwFlags: u32,
    pszText: PWSTR,
    iItem: i32,
    iSubItem: i32,
};

pub const LVFOOTERINFO = extern struct {
    mask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    cItems: u32,
};

pub const LVFOOTERITEM = extern struct {
    mask: u32,
    iItem: i32,
    pszText: PWSTR,
    cchTextMax: i32,
    state: u32,
    stateMask: u32,
};

pub const LVITEMINDEX = extern struct {
    iItem: i32,
    iGroup: i32,
};

pub const NMLISTVIEW = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iSubItem: i32,
    uNewState: u32,
    uOldState: u32,
    uChanged: u32,
    ptAction: POINT,
    lParam: LPARAM,
};

pub const NMITEMACTIVATE = extern struct {
    hdr: NMHDR,
    iItem: i32,
    iSubItem: i32,
    uNewState: u32,
    uOldState: u32,
    uChanged: u32,
    ptAction: POINT,
    lParam: LPARAM,
    uKeyFlags: u32,
};

pub const NMLVCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    clrText: u32,
    clrTextBk: u32,
    iSubItem: i32,
    dwItemType: u32,
    clrFace: u32,
    iIconEffect: i32,
    iIconPhase: i32,
    iPartId: i32,
    iStateId: i32,
    rcText: RECT,
    uAlign: u32,
};

pub const NMLVCACHEHINT = extern struct {
    hdr: NMHDR,
    iFrom: i32,
    iTo: i32,
};

pub const NMLVFINDITEMA = extern struct {
    hdr: NMHDR,
    iStart: i32,
    lvfi: LVFINDINFOA,
};

pub const NMLVFINDITEMW = extern struct {
    hdr: NMHDR,
    iStart: i32,
    lvfi: LVFINDINFOW,
};

pub const NMLVODSTATECHANGE = extern struct {
    hdr: NMHDR,
    iFrom: i32,
    iTo: i32,
    uNewState: u32,
    uOldState: u32,
};

pub const NMLVDISPINFOA = extern struct {
    hdr: NMHDR,
    item: LVITEMA,
};

pub const NMLVDISPINFOW = extern struct {
    hdr: NMHDR,
    item: LVITEMW,
};

pub const NMLVKEYDOWN = extern struct {
    hdr: NMHDR,
    wVKey: u16,
    flags: u32,
};

pub const NMLVLINK = extern struct {
    hdr: NMHDR,
    link: LITEM,
    iItem: i32,
    iSubItem: i32,
};

pub const NMLVGETINFOTIPA = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iItem: i32,
    iSubItem: i32,
    lParam: LPARAM,
};

pub const NMLVGETINFOTIPW = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iItem: i32,
    iSubItem: i32,
    lParam: LPARAM,
};

pub const NMLVSCROLL = extern struct {
    hdr: NMHDR,
    dx: i32,
    dy: i32,
};

pub const NMLVEMPTYMARKUP = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
    szMarkup: [2084]u16,
};

pub const _TREEITEM = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const NMTVSTATEIMAGECHANGING = extern struct {
    hdr: NMHDR,
    hti: *_TREEITEM,
    iOldStateImageIndex: i32,
    iNewStateImageIndex: i32,
};

pub const TVITEMA = extern struct {
    mask: u32,
    hItem: *_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: i32,
    lParam: LPARAM,
};

pub const TVITEMW = extern struct {
    mask: u32,
    hItem: *_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: i32,
    lParam: LPARAM,
};

pub const TVITEMEXA = extern struct {
    mask: u32,
    hItem: *_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: i32,
    lParam: LPARAM,
    iIntegral: i32,
    uStateEx: u32,
    hwnd: HWND,
    iExpandedImage: i32,
    iReserved: i32,
};

pub const TVITEMEXW = extern struct {
    mask: u32,
    hItem: *_TREEITEM,
    state: u32,
    stateMask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    cChildren: i32,
    lParam: LPARAM,
    iIntegral: i32,
    uStateEx: u32,
    hwnd: HWND,
    iExpandedImage: i32,
    iReserved: i32,
};

pub const TVINSERTSTRUCTA = extern struct {
    hParent: *_TREEITEM,
    hInsertAfter: *_TREEITEM,
    Anonymous: TVINSERTSTRUCTA._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const TVINSERTSTRUCTW = extern struct {
    hParent: *_TREEITEM,
    hInsertAfter: *_TREEITEM,
    Anonymous: TVINSERTSTRUCTW._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const TVHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
    hItem: *_TREEITEM,
};

pub const TVITEMPART = extern enum(i32) {
    TVGIPR_BUTTON = 1,
};
pub const TVGIPR_BUTTON = TVITEMPART.TVGIPR_BUTTON;

pub const TVGETITEMPARTRECTINFO = extern struct {
    hti: *_TREEITEM,
    prc: *RECT,
    partID: TVITEMPART,
};

pub const PFNTVCOMPARE = fn(
    lParam1: LPARAM,
    lParam2: LPARAM,
    lParamSort: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const TVSORTCB = extern struct {
    hParent: *_TREEITEM,
    lpfnCompare: PFNTVCOMPARE,
    lParam: LPARAM,
};

pub const NMTREEVIEWA = extern struct {
    hdr: NMHDR,
    action: u32,
    itemOld: TVITEMA,
    itemNew: TVITEMA,
    ptDrag: POINT,
};

pub const NMTREEVIEWW = extern struct {
    hdr: NMHDR,
    action: u32,
    itemOld: TVITEMW,
    itemNew: TVITEMW,
    ptDrag: POINT,
};

pub const NMTVDISPINFOA = extern struct {
    hdr: NMHDR,
    item: TVITEMA,
};

pub const NMTVDISPINFOW = extern struct {
    hdr: NMHDR,
    item: TVITEMW,
};

pub const NMTVDISPINFOEXA = extern struct {
    hdr: NMHDR,
    item: TVITEMEXA,
};

pub const NMTVDISPINFOEXW = extern struct {
    hdr: NMHDR,
    item: TVITEMEXW,
};

pub const NMTVKEYDOWN = extern struct {
    hdr: NMHDR,
    wVKey: u16,
    flags: u32,
};

pub const NMTVCUSTOMDRAW = extern struct {
    nmcd: NMCUSTOMDRAW,
    clrText: u32,
    clrTextBk: u32,
    iLevel: i32,
};

pub const NMTVGETINFOTIPA = extern struct {
    hdr: NMHDR,
    pszText: PSTR,
    cchTextMax: i32,
    hItem: *_TREEITEM,
    lParam: LPARAM,
};

pub const NMTVGETINFOTIPW = extern struct {
    hdr: NMHDR,
    pszText: PWSTR,
    cchTextMax: i32,
    hItem: *_TREEITEM,
    lParam: LPARAM,
};

pub const NMTVITEMCHANGE = extern struct {
    hdr: NMHDR,
    uChanged: u32,
    hItem: *_TREEITEM,
    uStateNew: u32,
    uStateOld: u32,
    lParam: LPARAM,
};

pub const NMTVASYNCDRAW = extern struct {
    hdr: NMHDR,
    pimldp: *IMAGELISTDRAWPARAMS,
    hr: HRESULT,
    hItem: *_TREEITEM,
    lParam: LPARAM,
    dwRetFlags: u32,
    iRetImageIndex: i32,
};

pub const COMBOBOXEXITEMA = extern struct {
    mask: u32,
    iItem: ?*c_void,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    iOverlay: i32,
    iIndent: i32,
    lParam: LPARAM,
};

pub const COMBOBOXEXITEMW = extern struct {
    mask: u32,
    iItem: ?*c_void,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    iSelectedImage: i32,
    iOverlay: i32,
    iIndent: i32,
    lParam: LPARAM,
};

pub const NMCOMBOBOXEXA = extern struct {
    hdr: NMHDR,
    ceItem: COMBOBOXEXITEMA,
};

pub const NMCOMBOBOXEXW = extern struct {
    hdr: NMHDR,
    ceItem: COMBOBOXEXITEMW,
};

pub const NMCBEDRAGBEGINW = extern struct {
    hdr: NMHDR,
    iItemid: i32,
    szText: [260]u16,
};

pub const NMCBEDRAGBEGINA = extern struct {
    hdr: NMHDR,
    iItemid: i32,
    szText: [260]i8,
};

pub const NMCBEENDEDITW = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    iNewSelection: i32,
    szText: [260]u16,
    iWhy: i32,
};

pub const NMCBEENDEDITA = extern struct {
    hdr: NMHDR,
    fChanged: BOOL,
    iNewSelection: i32,
    szText: [260]i8,
    iWhy: i32,
};

pub const TCITEMHEADERA = extern struct {
    mask: u32,
    lpReserved1: u32,
    lpReserved2: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
};

pub const TCITEMHEADERW = extern struct {
    mask: u32,
    lpReserved1: u32,
    lpReserved2: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
};

pub const TCITEMA = extern struct {
    mask: u32,
    dwState: u32,
    dwStateMask: u32,
    pszText: PSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const TCITEMW = extern struct {
    mask: u32,
    dwState: u32,
    dwStateMask: u32,
    pszText: PWSTR,
    cchTextMax: i32,
    iImage: i32,
    lParam: LPARAM,
};

pub const TCHITTESTINFO = extern struct {
    pt: POINT,
    flags: u32,
};

pub const NMTCKEYDOWN = extern struct {
    hdr: NMHDR,
    wVKey: u16,
    flags: u32,
};

pub const MCHITTESTINFO = extern struct {
    cbSize: u32,
    pt: POINT,
    uHit: u32,
    st: SYSTEMTIME,
    rc: RECT,
    iOffset: i32,
    iRow: i32,
    iCol: i32,
};

pub const MCGRIDINFO = extern struct {
    cbSize: u32,
    dwPart: u32,
    dwFlags: u32,
    iCalendar: i32,
    iRow: i32,
    iCol: i32,
    bSelected: BOOL,
    stStart: SYSTEMTIME,
    stEnd: SYSTEMTIME,
    rc: RECT,
    pszName: PWSTR,
    cchName: ?*c_void,
};

pub const NMSELCHANGE = extern struct {
    nmhdr: NMHDR,
    stSelStart: SYSTEMTIME,
    stSelEnd: SYSTEMTIME,
};

pub const NMDAYSTATE = extern struct {
    nmhdr: NMHDR,
    stStart: SYSTEMTIME,
    cDayState: i32,
    prgDayState: *u32,
};

pub const NMVIEWCHANGE = extern struct {
    nmhdr: NMHDR,
    dwOldView: u32,
    dwNewView: u32,
};

pub const DATETIMEPICKERINFO = extern struct {
    cbSize: u32,
    rcCheck: RECT,
    stateCheck: u32,
    rcButton: RECT,
    stateButton: u32,
    hwndEdit: HWND,
    hwndUD: HWND,
    hwndDropDown: HWND,
};

pub const NMDATETIMECHANGE = extern struct {
    nmhdr: NMHDR,
    dwFlags: u32,
    st: SYSTEMTIME,
};

pub const NMDATETIMESTRINGA = extern struct {
    nmhdr: NMHDR,
    pszUserString: [*:0]const u8,
    st: SYSTEMTIME,
    dwFlags: u32,
};

pub const NMDATETIMESTRINGW = extern struct {
    nmhdr: NMHDR,
    pszUserString: [*:0]const u16,
    st: SYSTEMTIME,
    dwFlags: u32,
};

pub const NMDATETIMEWMKEYDOWNA = extern struct {
    nmhdr: NMHDR,
    nVirtKey: i32,
    pszFormat: [*:0]const u8,
    st: SYSTEMTIME,
};

pub const NMDATETIMEWMKEYDOWNW = extern struct {
    nmhdr: NMHDR,
    nVirtKey: i32,
    pszFormat: [*:0]const u16,
    st: SYSTEMTIME,
};

pub const NMDATETIMEFORMATA = extern struct {
    nmhdr: NMHDR,
    pszFormat: [*:0]const u8,
    st: SYSTEMTIME,
    pszDisplay: [*:0]const u8,
    szDisplay: [64]i8,
};

pub const NMDATETIMEFORMATW = extern struct {
    nmhdr: NMHDR,
    pszFormat: [*:0]const u16,
    st: SYSTEMTIME,
    pszDisplay: [*:0]const u16,
    szDisplay: [64]u16,
};

pub const NMDATETIMEFORMATQUERYA = extern struct {
    nmhdr: NMHDR,
    pszFormat: [*:0]const u8,
    szMax: SIZE,
};

pub const NMDATETIMEFORMATQUERYW = extern struct {
    nmhdr: NMHDR,
    pszFormat: [*:0]const u16,
    szMax: SIZE,
};

pub const NMIPADDRESS = extern struct {
    hdr: NMHDR,
    iField: i32,
    iValue: i32,
};

pub const NMPGSCROLL = extern struct {
    hdr: NMHDR,
    fwKeys: u16,
    rcParent: RECT,
    iDir: i32,
    iXpos: i32,
    iYpos: i32,
    iScroll: i32,
};

pub const NMPGCALCSIZE = extern struct {
    hdr: NMHDR,
    dwFlag: u32,
    iWidth: i32,
    iHeight: i32,
};

pub const NMPGHOTITEM = extern struct {
    hdr: NMHDR,
    idOld: i32,
    idNew: i32,
    dwFlags: u32,
};

pub const BUTTON_IMAGELIST = extern struct {
    himl: HIMAGELIST,
    margin: RECT,
    uAlign: u32,
};

pub const NMBCHOTITEM = extern struct {
    hdr: NMHDR,
    dwFlags: u32,
};

pub const BUTTON_SPLITINFO = extern struct {
    mask: u32,
    himlGlyph: HIMAGELIST,
    uSplitStyle: u32,
    size: SIZE,
};

pub const NMBCDROPDOWN = extern struct {
    hdr: NMHDR,
    rcButton: RECT,
};

pub const EDITBALLOONTIP = extern struct {
    cbStruct: u32,
    pszTitle: [*:0]const u16,
    pszText: [*:0]const u16,
    ttiIcon: i32,
};

pub const EC_ENDOFLINE = extern enum(i32) {
    DETECTFROMCONTENT = 0,
    CRLF = 1,
    CR = 2,
    LF = 3,
};
pub const EC_ENDOFLINE_DETECTFROMCONTENT = EC_ENDOFLINE.DETECTFROMCONTENT;
pub const EC_ENDOFLINE_CRLF = EC_ENDOFLINE.CRLF;
pub const EC_ENDOFLINE_CR = EC_ENDOFLINE.CR;
pub const EC_ENDOFLINE_LF = EC_ENDOFLINE.LF;

pub const EC_SEARCHWEB_ENTRYPOINT = extern enum(i32) {
    EXTERNAL = 0,
    CONTEXTMENU = 1,
};
pub const EC_SEARCHWEB_ENTRYPOINT_EXTERNAL = EC_SEARCHWEB_ENTRYPOINT.EXTERNAL;
pub const EC_SEARCHWEB_ENTRYPOINT_CONTEXTMENU = EC_SEARCHWEB_ENTRYPOINT.CONTEXTMENU;

pub const NMSEARCHWEB = extern struct {
    hdr: NMHDR,
    entrypoint: EC_SEARCHWEB_ENTRYPOINT,
    hasQueryText: BOOL,
    invokeSucceeded: BOOL,
};

pub const PFTASKDIALOGCALLBACK = fn(
    hwnd: HWND,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    lpRefData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const _TASKDIALOG_FLAGS = extern enum(i32) {
    TDF_ENABLE_HYPERLINKS = 1,
    TDF_USE_HICON_MAIN = 2,
    TDF_USE_HICON_FOOTER = 4,
    TDF_ALLOW_DIALOG_CANCELLATION = 8,
    TDF_USE_COMMAND_LINKS = 16,
    TDF_USE_COMMAND_LINKS_NO_ICON = 32,
    TDF_EXPAND_FOOTER_AREA = 64,
    TDF_EXPANDED_BY_DEFAULT = 128,
    TDF_VERIFICATION_FLAG_CHECKED = 256,
    TDF_SHOW_PROGRESS_BAR = 512,
    TDF_SHOW_MARQUEE_PROGRESS_BAR = 1024,
    TDF_CALLBACK_TIMER = 2048,
    TDF_POSITION_RELATIVE_TO_WINDOW = 4096,
    TDF_RTL_LAYOUT = 8192,
    TDF_NO_DEFAULT_RADIO_BUTTON = 16384,
    TDF_CAN_BE_MINIMIZED = 32768,
    TDF_NO_SET_FOREGROUND = 65536,
    TDF_SIZE_TO_CONTENT = 16777216,
};
pub const TDF_ENABLE_HYPERLINKS = _TASKDIALOG_FLAGS.TDF_ENABLE_HYPERLINKS;
pub const TDF_USE_HICON_MAIN = _TASKDIALOG_FLAGS.TDF_USE_HICON_MAIN;
pub const TDF_USE_HICON_FOOTER = _TASKDIALOG_FLAGS.TDF_USE_HICON_FOOTER;
pub const TDF_ALLOW_DIALOG_CANCELLATION = _TASKDIALOG_FLAGS.TDF_ALLOW_DIALOG_CANCELLATION;
pub const TDF_USE_COMMAND_LINKS = _TASKDIALOG_FLAGS.TDF_USE_COMMAND_LINKS;
pub const TDF_USE_COMMAND_LINKS_NO_ICON = _TASKDIALOG_FLAGS.TDF_USE_COMMAND_LINKS_NO_ICON;
pub const TDF_EXPAND_FOOTER_AREA = _TASKDIALOG_FLAGS.TDF_EXPAND_FOOTER_AREA;
pub const TDF_EXPANDED_BY_DEFAULT = _TASKDIALOG_FLAGS.TDF_EXPANDED_BY_DEFAULT;
pub const TDF_VERIFICATION_FLAG_CHECKED = _TASKDIALOG_FLAGS.TDF_VERIFICATION_FLAG_CHECKED;
pub const TDF_SHOW_PROGRESS_BAR = _TASKDIALOG_FLAGS.TDF_SHOW_PROGRESS_BAR;
pub const TDF_SHOW_MARQUEE_PROGRESS_BAR = _TASKDIALOG_FLAGS.TDF_SHOW_MARQUEE_PROGRESS_BAR;
pub const TDF_CALLBACK_TIMER = _TASKDIALOG_FLAGS.TDF_CALLBACK_TIMER;
pub const TDF_POSITION_RELATIVE_TO_WINDOW = _TASKDIALOG_FLAGS.TDF_POSITION_RELATIVE_TO_WINDOW;
pub const TDF_RTL_LAYOUT = _TASKDIALOG_FLAGS.TDF_RTL_LAYOUT;
pub const TDF_NO_DEFAULT_RADIO_BUTTON = _TASKDIALOG_FLAGS.TDF_NO_DEFAULT_RADIO_BUTTON;
pub const TDF_CAN_BE_MINIMIZED = _TASKDIALOG_FLAGS.TDF_CAN_BE_MINIMIZED;
pub const TDF_NO_SET_FOREGROUND = _TASKDIALOG_FLAGS.TDF_NO_SET_FOREGROUND;
pub const TDF_SIZE_TO_CONTENT = _TASKDIALOG_FLAGS.TDF_SIZE_TO_CONTENT;

pub const TASKDIALOG_MESSAGES = extern enum(i32) {
    TDM_NAVIGATE_PAGE = 1125,
    TDM_CLICK_BUTTON = 1126,
    TDM_SET_MARQUEE_PROGRESS_BAR = 1127,
    TDM_SET_PROGRESS_BAR_STATE = 1128,
    TDM_SET_PROGRESS_BAR_RANGE = 1129,
    TDM_SET_PROGRESS_BAR_POS = 1130,
    TDM_SET_PROGRESS_BAR_MARQUEE = 1131,
    TDM_SET_ELEMENT_TEXT = 1132,
    TDM_CLICK_RADIO_BUTTON = 1134,
    TDM_ENABLE_BUTTON = 1135,
    TDM_ENABLE_RADIO_BUTTON = 1136,
    TDM_CLICK_VERIFICATION = 1137,
    TDM_UPDATE_ELEMENT_TEXT = 1138,
    TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE = 1139,
    TDM_UPDATE_ICON = 1140,
};
pub const TDM_NAVIGATE_PAGE = TASKDIALOG_MESSAGES.TDM_NAVIGATE_PAGE;
pub const TDM_CLICK_BUTTON = TASKDIALOG_MESSAGES.TDM_CLICK_BUTTON;
pub const TDM_SET_MARQUEE_PROGRESS_BAR = TASKDIALOG_MESSAGES.TDM_SET_MARQUEE_PROGRESS_BAR;
pub const TDM_SET_PROGRESS_BAR_STATE = TASKDIALOG_MESSAGES.TDM_SET_PROGRESS_BAR_STATE;
pub const TDM_SET_PROGRESS_BAR_RANGE = TASKDIALOG_MESSAGES.TDM_SET_PROGRESS_BAR_RANGE;
pub const TDM_SET_PROGRESS_BAR_POS = TASKDIALOG_MESSAGES.TDM_SET_PROGRESS_BAR_POS;
pub const TDM_SET_PROGRESS_BAR_MARQUEE = TASKDIALOG_MESSAGES.TDM_SET_PROGRESS_BAR_MARQUEE;
pub const TDM_SET_ELEMENT_TEXT = TASKDIALOG_MESSAGES.TDM_SET_ELEMENT_TEXT;
pub const TDM_CLICK_RADIO_BUTTON = TASKDIALOG_MESSAGES.TDM_CLICK_RADIO_BUTTON;
pub const TDM_ENABLE_BUTTON = TASKDIALOG_MESSAGES.TDM_ENABLE_BUTTON;
pub const TDM_ENABLE_RADIO_BUTTON = TASKDIALOG_MESSAGES.TDM_ENABLE_RADIO_BUTTON;
pub const TDM_CLICK_VERIFICATION = TASKDIALOG_MESSAGES.TDM_CLICK_VERIFICATION;
pub const TDM_UPDATE_ELEMENT_TEXT = TASKDIALOG_MESSAGES.TDM_UPDATE_ELEMENT_TEXT;
pub const TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE = TASKDIALOG_MESSAGES.TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE;
pub const TDM_UPDATE_ICON = TASKDIALOG_MESSAGES.TDM_UPDATE_ICON;

pub const TASKDIALOG_NOTIFICATIONS = extern enum(i32) {
    TDN_CREATED = 0,
    TDN_NAVIGATED = 1,
    TDN_BUTTON_CLICKED = 2,
    TDN_HYPERLINK_CLICKED = 3,
    TDN_TIMER = 4,
    TDN_DESTROYED = 5,
    TDN_RADIO_BUTTON_CLICKED = 6,
    TDN_DIALOG_CONSTRUCTED = 7,
    TDN_VERIFICATION_CLICKED = 8,
    TDN_HELP = 9,
    TDN_EXPANDO_BUTTON_CLICKED = 10,
};
pub const TDN_CREATED = TASKDIALOG_NOTIFICATIONS.TDN_CREATED;
pub const TDN_NAVIGATED = TASKDIALOG_NOTIFICATIONS.TDN_NAVIGATED;
pub const TDN_BUTTON_CLICKED = TASKDIALOG_NOTIFICATIONS.TDN_BUTTON_CLICKED;
pub const TDN_HYPERLINK_CLICKED = TASKDIALOG_NOTIFICATIONS.TDN_HYPERLINK_CLICKED;
pub const TDN_TIMER = TASKDIALOG_NOTIFICATIONS.TDN_TIMER;
pub const TDN_DESTROYED = TASKDIALOG_NOTIFICATIONS.TDN_DESTROYED;
pub const TDN_RADIO_BUTTON_CLICKED = TASKDIALOG_NOTIFICATIONS.TDN_RADIO_BUTTON_CLICKED;
pub const TDN_DIALOG_CONSTRUCTED = TASKDIALOG_NOTIFICATIONS.TDN_DIALOG_CONSTRUCTED;
pub const TDN_VERIFICATION_CLICKED = TASKDIALOG_NOTIFICATIONS.TDN_VERIFICATION_CLICKED;
pub const TDN_HELP = TASKDIALOG_NOTIFICATIONS.TDN_HELP;
pub const TDN_EXPANDO_BUTTON_CLICKED = TASKDIALOG_NOTIFICATIONS.TDN_EXPANDO_BUTTON_CLICKED;

pub const TASKDIALOG_BUTTON = extern struct {
    nButtonID: i32,
    pszButtonText: [*:0]const u16,
};

pub const TASKDIALOG_ELEMENTS = extern enum(i32) {
    TDE_CONTENT = 0,
    TDE_EXPANDED_INFORMATION = 1,
    TDE_FOOTER = 2,
    TDE_MAIN_INSTRUCTION = 3,
};
pub const TDE_CONTENT = TASKDIALOG_ELEMENTS.TDE_CONTENT;
pub const TDE_EXPANDED_INFORMATION = TASKDIALOG_ELEMENTS.TDE_EXPANDED_INFORMATION;
pub const TDE_FOOTER = TASKDIALOG_ELEMENTS.TDE_FOOTER;
pub const TDE_MAIN_INSTRUCTION = TASKDIALOG_ELEMENTS.TDE_MAIN_INSTRUCTION;

pub const TASKDIALOG_ICON_ELEMENTS = extern enum(i32) {
    TDIE_ICON_MAIN = 0,
    TDIE_ICON_FOOTER = 1,
};
pub const TDIE_ICON_MAIN = TASKDIALOG_ICON_ELEMENTS.TDIE_ICON_MAIN;
pub const TDIE_ICON_FOOTER = TASKDIALOG_ICON_ELEMENTS.TDIE_ICON_FOOTER;

pub const _TASKDIALOG_COMMON_BUTTON_FLAGS = extern enum(i32) {
    TDCBF_OK_BUTTON = 1,
    TDCBF_YES_BUTTON = 2,
    TDCBF_NO_BUTTON = 4,
    TDCBF_CANCEL_BUTTON = 8,
    TDCBF_RETRY_BUTTON = 16,
    TDCBF_CLOSE_BUTTON = 32,
};
pub const TDCBF_OK_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.TDCBF_OK_BUTTON;
pub const TDCBF_YES_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.TDCBF_YES_BUTTON;
pub const TDCBF_NO_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.TDCBF_NO_BUTTON;
pub const TDCBF_CANCEL_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.TDCBF_CANCEL_BUTTON;
pub const TDCBF_RETRY_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.TDCBF_RETRY_BUTTON;
pub const TDCBF_CLOSE_BUTTON = _TASKDIALOG_COMMON_BUTTON_FLAGS.TDCBF_CLOSE_BUTTON;

pub const TASKDIALOGCONFIG = extern struct {
    cbSize: u32,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    dwFlags: i32,
    dwCommonButtons: i32,
    pszWindowTitle: [*:0]const u16,
    Anonymous1: TASKDIALOGCONFIG._Anonymous1_e__Union,
    pszMainInstruction: [*:0]const u16,
    pszContent: [*:0]const u16,
    cButtons: u32,
    pButtons: *const TASKDIALOG_BUTTON,
    nDefaultButton: i32,
    cRadioButtons: u32,
    pRadioButtons: *const TASKDIALOG_BUTTON,
    nDefaultRadioButton: i32,
    pszVerificationText: [*:0]const u16,
    pszExpandedInformation: [*:0]const u16,
    pszExpandedControlText: [*:0]const u16,
    pszCollapsedControlText: [*:0]const u16,
    Anonymous2: TASKDIALOGCONFIG._Anonymous2_e__Union,
    pszFooter: [*:0]const u16,
    pfCallback: PFTASKDIALOGCALLBACK,
    lpCallbackData: ?*c_void,
    cxWidth: u32,
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
};

pub const PFNDAENUMCALLBACK = fn(
    p: ?*c_void,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNDAENUMCALLBACKCONST = fn(
    p: ?*const c_void,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNDACOMPARE = fn(
    p1: ?*c_void,
    p2: ?*c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PFNDACOMPARECONST = fn(
    p1: ?*const c_void,
    p2: ?*const c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const _DSA = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const _DPA = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const DPASTREAMINFO = extern struct {
    iPos: i32,
    pvItem: *c_void,
};

pub const PFNDPASTREAM = fn(
    pinfo: *DPASTREAMINFO,
    pstream: *IStream,
    pvInstData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDPAMERGE = fn(
    uMsg: u32,
    pvDest: *c_void,
    pvSrc: *c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const PFNDPAMERGECONST = fn(
    uMsg: u32,
    pvDest: *const c_void,
    pvSrc: *const c_void,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub const _LI_METRIC = extern enum(i32) {
    LIM_SMALL = 0,
    LIM_LARGE = 1,
};
pub const LIM_SMALL = _LI_METRIC.LIM_SMALL;
pub const LIM_LARGE = _LI_METRIC.LIM_LARGE;

const CLSID_ImageList_Value = @import("../zig.zig").Guid.initString("7c476ba2-02b1-48f4-8048-b24619ddc058");
pub const CLSID_ImageList = &CLSID_ImageList_Value;

const IID_IImageList_Value = @import("../zig.zig").Guid.initString("46eb5926-582e-4017-9fdf-e8998daa0950");
pub const IID_IImageList = &IID_IImageList_Value;
pub const IImageList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Add: fn(
            self: *const IImageList,
            hbmImage: HBITMAP,
            hbmMask: HBITMAP,
            pi: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceIcon: fn(
            self: *const IImageList,
            i: i32,
            hicon: HICON,
            pi: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlayImage: fn(
            self: *const IImageList,
            iImage: i32,
            iOverlay: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Replace: fn(
            self: *const IImageList,
            i: i32,
            hbmImage: HBITMAP,
            hbmMask: HBITMAP,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddMasked: fn(
            self: *const IImageList,
            hbmImage: HBITMAP,
            crMask: u32,
            pi: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Draw: fn(
            self: *const IImageList,
            pimldp: *IMAGELISTDRAWPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IImageList,
            i: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIcon: fn(
            self: *const IImageList,
            i: i32,
            flags: u32,
            picon: *HICON,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImageInfo: fn(
            self: *const IImageList,
            i: i32,
            pImageInfo: *IMAGEINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const IImageList,
            iDst: i32,
            punkSrc: *IUnknown,
            iSrc: i32,
            uFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Merge: fn(
            self: *const IImageList,
            i1: i32,
            punk2: *IUnknown,
            i2: i32,
            dx: i32,
            dy: i32,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IImageList,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImageRect: fn(
            self: *const IImageList,
            i: i32,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIconSize: fn(
            self: *const IImageList,
            cx: *i32,
            cy: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIconSize: fn(
            self: *const IImageList,
            cx: i32,
            cy: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImageCount: fn(
            self: *const IImageList,
            pi: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImageCount: fn(
            self: *const IImageList,
            uNewCount: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBkColor: fn(
            self: *const IImageList,
            clrBk: u32,
            pclr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBkColor: fn(
            self: *const IImageList,
            pclr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginDrag: fn(
            self: *const IImageList,
            iTrack: i32,
            dxHotspot: i32,
            dyHotspot: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndDrag: fn(
            self: *const IImageList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragEnter: fn(
            self: *const IImageList,
            hwndLock: HWND,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragLeave: fn(
            self: *const IImageList,
            hwndLock: HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragMove: fn(
            self: *const IImageList,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDragCursorImage: fn(
            self: *const IImageList,
            punk: *IUnknown,
            iDrag: i32,
            dxHotspot: i32,
            dyHotspot: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DragShowNolock: fn(
            self: *const IImageList,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDragImage: fn(
            self: *const IImageList,
            ppt: ?*POINT,
            pptHotspot: ?*POINT,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemFlags: fn(
            self: *const IImageList,
            i: i32,
            dwFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlayImage: fn(
            self: *const IImageList,
            iOverlay: i32,
            piIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Add(self: *const T, hbmImage: HBITMAP, hbmMask: HBITMAP, pi: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Add(@ptrCast(*const IImageList, self), hbmImage, hbmMask, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_ReplaceIcon(self: *const T, i: i32, hicon: HICON, pi: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).ReplaceIcon(@ptrCast(*const IImageList, self), i, hicon, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetOverlayImage(self: *const T, iImage: i32, iOverlay: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetOverlayImage(@ptrCast(*const IImageList, self), iImage, iOverlay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Replace(self: *const T, i: i32, hbmImage: HBITMAP, hbmMask: HBITMAP) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Replace(@ptrCast(*const IImageList, self), i, hbmImage, hbmMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_AddMasked(self: *const T, hbmImage: HBITMAP, crMask: u32, pi: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).AddMasked(@ptrCast(*const IImageList, self), hbmImage, crMask, pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Draw(self: *const T, pimldp: *IMAGELISTDRAWPARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Draw(@ptrCast(*const IImageList, self), pimldp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Remove(self: *const T, i: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Remove(@ptrCast(*const IImageList, self), i);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetIcon(self: *const T, i: i32, flags: u32, picon: *HICON) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetIcon(@ptrCast(*const IImageList, self), i, flags, picon);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetImageInfo(self: *const T, i: i32, pImageInfo: *IMAGEINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetImageInfo(@ptrCast(*const IImageList, self), i, pImageInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Copy(self: *const T, iDst: i32, punkSrc: *IUnknown, iSrc: i32, uFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Copy(@ptrCast(*const IImageList, self), iDst, punkSrc, iSrc, uFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Merge(self: *const T, i1: i32, punk2: *IUnknown, i2: i32, dx: i32, dy: i32, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Merge(@ptrCast(*const IImageList, self), i1, punk2, i2, dx, dy, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_Clone(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).Clone(@ptrCast(*const IImageList, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetImageRect(self: *const T, i: i32, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetImageRect(@ptrCast(*const IImageList, self), i, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetIconSize(self: *const T, cx: *i32, cy: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetIconSize(@ptrCast(*const IImageList, self), cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetIconSize(self: *const T, cx: i32, cy: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetIconSize(@ptrCast(*const IImageList, self), cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetImageCount(self: *const T, pi: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetImageCount(@ptrCast(*const IImageList, self), pi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetImageCount(self: *const T, uNewCount: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetImageCount(@ptrCast(*const IImageList, self), uNewCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetBkColor(self: *const T, clrBk: u32, pclr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetBkColor(@ptrCast(*const IImageList, self), clrBk, pclr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetBkColor(self: *const T, pclr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetBkColor(@ptrCast(*const IImageList, self), pclr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_BeginDrag(self: *const T, iTrack: i32, dxHotspot: i32, dyHotspot: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).BeginDrag(@ptrCast(*const IImageList, self), iTrack, dxHotspot, dyHotspot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_EndDrag(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).EndDrag(@ptrCast(*const IImageList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragEnter(self: *const T, hwndLock: HWND, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragEnter(@ptrCast(*const IImageList, self), hwndLock, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragLeave(self: *const T, hwndLock: HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragLeave(@ptrCast(*const IImageList, self), hwndLock);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragMove(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragMove(@ptrCast(*const IImageList, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_SetDragCursorImage(self: *const T, punk: *IUnknown, iDrag: i32, dxHotspot: i32, dyHotspot: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).SetDragCursorImage(@ptrCast(*const IImageList, self), punk, iDrag, dxHotspot, dyHotspot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_DragShowNolock(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).DragShowNolock(@ptrCast(*const IImageList, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetDragImage(self: *const T, ppt: ?*POINT, pptHotspot: ?*POINT, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetDragImage(@ptrCast(*const IImageList, self), ppt, pptHotspot, riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetItemFlags(self: *const T, i: i32, dwFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetItemFlags(@ptrCast(*const IImageList, self), i, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList_GetOverlayImage(self: *const T, iOverlay: i32, piIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList.VTable, self.vtable).GetOverlayImage(@ptrCast(*const IImageList, self), iOverlay, piIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IMAGELISTSTATS = extern struct {
    cbSize: u32,
    cAlloc: i32,
    cUsed: i32,
    cStandby: i32,
};

const IID_IImageList2_Value = @import("../zig.zig").Guid.initString("192b9d83-50fc-457b-90a0-2b82a8b5dae1");
pub const IID_IImageList2 = &IID_IImageList2_Value;
pub const IImageList2 = extern struct {
    pub const VTable = extern struct {
        base: IImageList.VTable,
        Resize: fn(
            self: *const IImageList2,
            cxNewIconSize: i32,
            cyNewIconSize: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalSize: fn(
            self: *const IImageList2,
            iImage: i32,
            dwFlags: u32,
            pcx: *i32,
            pcy: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOriginalSize: fn(
            self: *const IImageList2,
            iImage: i32,
            cx: i32,
            cy: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCallback: fn(
            self: *const IImageList2,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallback: fn(
            self: *const IImageList2,
            riid: *const Guid,
            ppv: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ForceImagePresent: fn(
            self: *const IImageList2,
            iImage: i32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DiscardImages: fn(
            self: *const IImageList2,
            iFirstImage: i32,
            iLastImage: i32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreloadImages: fn(
            self: *const IImageList2,
            pimldp: *IMAGELISTDRAWPARAMS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatistics: fn(
            self: *const IImageList2,
            pils: *IMAGELISTSTATS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const IImageList2,
            cx: i32,
            cy: i32,
            flags: u32,
            cInitial: i32,
            cGrow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Replace2: fn(
            self: *const IImageList2,
            i: i32,
            hbmImage: HBITMAP,
            hbmMask: HBITMAP,
            punk: ?*IUnknown,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceFromImageList: fn(
            self: *const IImageList2,
            i: i32,
            pil: *IImageList,
            iSrc: i32,
            punk: ?*IUnknown,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IImageList.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_Resize(self: *const T, cxNewIconSize: i32, cyNewIconSize: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).Resize(@ptrCast(*const IImageList2, self), cxNewIconSize, cyNewIconSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_GetOriginalSize(self: *const T, iImage: i32, dwFlags: u32, pcx: *i32, pcy: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).GetOriginalSize(@ptrCast(*const IImageList2, self), iImage, dwFlags, pcx, pcy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_SetOriginalSize(self: *const T, iImage: i32, cx: i32, cy: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).SetOriginalSize(@ptrCast(*const IImageList2, self), iImage, cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_SetCallback(self: *const T, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).SetCallback(@ptrCast(*const IImageList2, self), punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_GetCallback(self: *const T, riid: *const Guid, ppv: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).GetCallback(@ptrCast(*const IImageList2, self), riid, ppv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_ForceImagePresent(self: *const T, iImage: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).ForceImagePresent(@ptrCast(*const IImageList2, self), iImage, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_DiscardImages(self: *const T, iFirstImage: i32, iLastImage: i32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).DiscardImages(@ptrCast(*const IImageList2, self), iFirstImage, iLastImage, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_PreloadImages(self: *const T, pimldp: *IMAGELISTDRAWPARAMS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).PreloadImages(@ptrCast(*const IImageList2, self), pimldp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_GetStatistics(self: *const T, pils: *IMAGELISTSTATS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).GetStatistics(@ptrCast(*const IImageList2, self), pils);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_Initialize(self: *const T, cx: i32, cy: i32, flags: u32, cInitial: i32, cGrow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).Initialize(@ptrCast(*const IImageList2, self), cx, cy, flags, cInitial, cGrow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_Replace2(self: *const T, i: i32, hbmImage: HBITMAP, hbmMask: HBITMAP, punk: ?*IUnknown, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).Replace2(@ptrCast(*const IImageList2, self), i, hbmImage, hbmMask, punk, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IImageList2_ReplaceFromImageList(self: *const T, i: i32, pil: *IImageList, iSrc: i32, punk: ?*IUnknown, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IImageList2.VTable, self.vtable).ReplaceFromImageList(@ptrCast(*const IImageList2, self), i, pil, iSrc, punk, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TEXTMODE = extern enum(i32) {
    TM_PLAINTEXT = 1,
    TM_RICHTEXT = 2,
    TM_SINGLELEVELUNDO = 4,
    TM_MULTILEVELUNDO = 8,
    TM_SINGLECODEPAGE = 16,
    TM_MULTICODEPAGE = 32,
};
pub const TM_PLAINTEXT = TEXTMODE.TM_PLAINTEXT;
pub const TM_RICHTEXT = TEXTMODE.TM_RICHTEXT;
pub const TM_SINGLELEVELUNDO = TEXTMODE.TM_SINGLELEVELUNDO;
pub const TM_MULTILEVELUNDO = TEXTMODE.TM_MULTILEVELUNDO;
pub const TM_SINGLECODEPAGE = TEXTMODE.TM_SINGLECODEPAGE;
pub const TM_MULTICODEPAGE = TEXTMODE.TM_MULTICODEPAGE;

pub const IMECOMPTEXT = extern struct {
    cb: i32,
    flags: u32,
};

pub const TABLEROWPARMS = extern struct {
    cbRow: u8,
    cbCell: u8,
    cCell: u8,
    cRow: u8,
    dxCellMargin: i32,
    dxIndent: i32,
    dyHeight: i32,
    _bitfield: u32,
    cpStartRow: i32,
    bTableLevel: u8,
    iCell: u8,
};

pub const TABLECELLPARMS = extern struct {
    dxWidth: i32,
    _bitfield: u16,
    wShading: u16,
    dxBrdrLeft: i16,
    dyBrdrTop: i16,
    dxBrdrRight: i16,
    dyBrdrBottom: i16,
    crBrdrLeft: u32,
    crBrdrTop: u32,
    crBrdrRight: u32,
    crBrdrBottom: u32,
    crBackPat: u32,
    crForePat: u32,
};

pub const AutoCorrectProc = fn(
    langid: u16,
    pszBefore: [*:0]const u16,
    pszAfter: PWSTR,
    cchAfter: i32,
    pcchReplaced: *i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const RICHEDIT_IMAGE_PARAMETERS = extern struct {
    xWidth: i32,
    yHeight: i32,
    Ascent: i32,
    Type: i32,
    pwszAlternateText: [*:0]const u16,
    pIStream: *IStream,
};

pub const ENDCOMPOSITIONNOTIFY = extern struct {
    nmhdr: NMHDR,
    dwCode: u32,
};

pub const EDITWORDBREAKPROCEX = fn(
    pchText: *i8,
    cchText: i32,
    bCharSet: u8,
    action: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const CHARFORMATA = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwEffects: u32,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]i8,
};

pub const CHARFORMATW = extern struct {
    cbSize: u32,
    dwMask: u32,
    dwEffects: u32,
    yHeight: i32,
    yOffset: i32,
    crTextColor: u32,
    bCharSet: u8,
    bPitchAndFamily: u8,
    szFaceName: [32]u16,
};

pub const CHARFORMAT2W = extern struct {
    __AnonymousBase_richedit_L711_C23: CHARFORMATW,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: CHARFORMAT2W._Anonymous_e__Union,
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CHARFORMAT2A = extern struct {
    __AnonymousBase_richedit_L736_C23: CHARFORMATA,
    wWeight: u16,
    sSpacing: i16,
    crBackColor: u32,
    lcid: u32,
    Anonymous: CHARFORMAT2A._Anonymous_e__Union,
    sStyle: i16,
    wKerning: u16,
    bUnderlineType: u8,
    bAnimation: u8,
    bRevAuthor: u8,
    bUnderlineColor: u8,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const CHARRANGE = extern struct {
    cpMin: i32,
    cpMax: i32,
};

pub const TEXTRANGEA = extern struct {
    chrg: CHARRANGE,
    lpstrText: PSTR,
};

pub const TEXTRANGEW = extern struct {
    chrg: CHARRANGE,
    lpstrText: PWSTR,
};

pub const EDITSTREAMCALLBACK = fn(
    dwCookie: ?*c_void,
    pbBuff: *u8,
    cb: i32,
    pcb: *i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const EDITSTREAM = extern struct {
    dwCookie: ?*c_void,
    dwError: u32,
    pfnCallback: EDITSTREAMCALLBACK,
};

pub const FINDTEXTA = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u8,
};

pub const FINDTEXTW = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u16,
};

pub const FINDTEXTEXA = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u8,
    chrgText: CHARRANGE,
};

pub const FINDTEXTEXW = extern struct {
    chrg: CHARRANGE,
    lpstrText: [*:0]const u16,
    chrgText: CHARRANGE,
};

pub const FORMATRANGE = extern struct {
    hdc: HDC,
    hdcTarget: HDC,
    rc: RECT,
    rcPage: RECT,
    chrg: CHARRANGE,
};

pub const PARAFORMAT = extern struct {
    cbSize: u32,
    dwMask: u32,
    wNumbering: u16,
    Anonymous: PARAFORMAT._Anonymous_e__Union,
    dxStartIndent: i32,
    dxRightIndent: i32,
    dxOffset: i32,
    wAlignment: u16,
    cTabCount: i16,
    rgxTabs: [32]i32,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PARAFORMAT2 = extern struct {
    __AnonymousBase_richedit_L1149_C22: PARAFORMAT,
    dySpaceBefore: i32,
    dySpaceAfter: i32,
    dyLineSpacing: i32,
    sStyle: i16,
    bLineSpacingRule: u8,
    bOutlineLevel: u8,
    wShadingWeight: u16,
    wShadingStyle: u16,
    wNumberingStart: u16,
    wNumberingStyle: u16,
    wNumberingTab: u16,
    wBorderSpace: u16,
    wBorderWidth: u16,
    wBorders: u16,
};

pub const MSGFILTER = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
};

pub const REQRESIZE = extern struct {
    nmhdr: NMHDR,
    rc: RECT,
};

pub const SELCHANGE = extern struct {
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: u16,
};

pub const _grouptypingchange = extern struct {
    nmhdr: NMHDR,
    fGroupTyping: BOOL,
};

pub const CLIPBOARDFORMAT = extern struct {
    nmhdr: NMHDR,
    cf: u16,
};

pub const GETCONTEXTMENUEX = extern struct {
    chrg: CHARRANGE,
    dwFlags: u32,
    pt: POINT,
    pvReserved: *c_void,
};

pub const ENDROPFILES = extern struct {
    nmhdr: NMHDR,
    hDrop: HANDLE,
    cp: i32,
    fProtected: BOOL,
};

pub const ENPROTECTED = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};

pub const ENSAVECLIPBOARD = extern struct {
    nmhdr: NMHDR,
    cObjectCount: i32,
    cch: i32,
};

pub const ENOLEOPFAILED = extern struct {
    nmhdr: NMHDR,
    iob: i32,
    lOper: i32,
    hr: HRESULT,
};

pub const OBJECTPOSITIONS = extern struct {
    nmhdr: NMHDR,
    cObjectCount: i32,
    pcpPositions: *i32,
};

pub const ENLINK = extern struct {
    nmhdr: NMHDR,
    msg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    chrg: CHARRANGE,
};

pub const ENLOWFIRTF = extern struct {
    nmhdr: NMHDR,
    szControl: *i8,
};

pub const ENCORRECTTEXT = extern struct {
    nmhdr: NMHDR,
    chrg: CHARRANGE,
    seltyp: u16,
};

pub const PUNCTUATION = extern struct {
    iSize: u32,
    szPunctuation: PSTR,
};

pub const COMPCOLOR = extern struct {
    crText: u32,
    crBackground: u32,
    dwEffects: u32,
};

pub const REPASTESPECIAL = extern struct {
    dwAspect: u32,
    dwParam: ?*c_void,
};

pub const UNDONAMEID = extern enum(i32) {
    UID_UNKNOWN = 0,
    UID_TYPING = 1,
    UID_DELETE = 2,
    UID_DRAGDROP = 3,
    UID_CUT = 4,
    UID_PASTE = 5,
    UID_AUTOTABLE = 6,
};
pub const UID_UNKNOWN = UNDONAMEID.UID_UNKNOWN;
pub const UID_TYPING = UNDONAMEID.UID_TYPING;
pub const UID_DELETE = UNDONAMEID.UID_DELETE;
pub const UID_DRAGDROP = UNDONAMEID.UID_DRAGDROP;
pub const UID_CUT = UNDONAMEID.UID_CUT;
pub const UID_PASTE = UNDONAMEID.UID_PASTE;
pub const UID_AUTOTABLE = UNDONAMEID.UID_AUTOTABLE;

pub const SETTEXTEX = extern struct {
    flags: u32,
    codepage: u32,
};

pub const GETTEXTEX = extern struct {
    cb: u32,
    flags: u32,
    codepage: u32,
    lpDefaultChar: [*:0]const u8,
    lpUsedDefChar: *i32,
};

pub const GETTEXTLENGTHEX = extern struct {
    flags: u32,
    codepage: u32,
};

pub const BIDIOPTIONS = extern struct {
    cbSize: u32,
    wMask: u16,
    wEffects: u16,
};

pub const KHYPH = extern enum(i32) {
    khyphNil = 0,
    khyphNormal = 1,
    khyphAddBefore = 2,
    khyphChangeBefore = 3,
    khyphDeleteBefore = 4,
    khyphChangeAfter = 5,
    khyphDelAndChange = 6,
};
pub const khyphNil = KHYPH.khyphNil;
pub const khyphNormal = KHYPH.khyphNormal;
pub const khyphAddBefore = KHYPH.khyphAddBefore;
pub const khyphChangeBefore = KHYPH.khyphChangeBefore;
pub const khyphDeleteBefore = KHYPH.khyphDeleteBefore;
pub const khyphChangeAfter = KHYPH.khyphChangeAfter;
pub const khyphDelAndChange = KHYPH.khyphDelAndChange;

pub const hyphresult = extern struct {
    khyph: KHYPH,
    ichHyph: i32,
    chHyph: u16,
};

pub const HYPHENATEINFO = extern struct {
    cbSize: i16,
    dxHyphenateZone: i16,
    pfnHyphenate: ?*c_void,
};

pub const tomConstants = extern enum(i32) {
    tomFalse = 0,
    tomTrue = -1,
    tomUndefined = -9999999,
    tomToggle = -9999998,
    tomAutoColor = -9999997,
    tomDefault = -9999996,
    tomSuspend = -9999995,
    tomResume = -9999994,
    tomApplyNow = 0,
    tomApplyLater = 1,
    tomTrackParms = 2,
    tomCacheParms = 3,
    tomApplyTmp = 4,
    tomDisableSmartFont = 8,
    tomEnableSmartFont = 9,
    tomUsePoints = 10,
    tomUseTwips = 11,
    tomBackward = -1073741823,
    tomForward = 1073741823,
    tomMove = 0,
    tomExtend = 1,
    tomNoSelection = 0,
    tomSelectionIP = 1,
    tomSelectionNormal = 2,
    tomSelectionFrame = 3,
    tomSelectionColumn = 4,
    tomSelectionRow = 5,
    tomSelectionBlock = 6,
    tomSelectionInlineShape = 7,
    tomSelectionShape = 8,
    tomSelStartActive = 1,
    tomSelAtEOL = 2,
    tomSelOvertype = 4,
    tomSelActive = 8,
    tomSelReplace = 16,
    tomEnd = 0,
    tomStart = 32,
    tomCollapseEnd = 0,
    tomCollapseStart = 1,
    tomClientCoord = 256,
    tomAllowOffClient = 512,
    tomTransform = 1024,
    tomObjectArg = 2048,
    tomAtEnd = 4096,
    tomNone = 0,
    tomSingle = 1,
    tomWords = 2,
    tomDouble = 3,
    tomDotted = 4,
    tomDash = 5,
    tomDashDot = 6,
    tomDashDotDot = 7,
    tomWave = 8,
    tomThick = 9,
    tomHair = 10,
    tomDoubleWave = 11,
    tomHeavyWave = 12,
    tomLongDash = 13,
    tomThickDash = 14,
    tomThickDashDot = 15,
    tomThickDashDotDot = 16,
    tomThickDotted = 17,
    tomThickLongDash = 18,
    tomLineSpaceSingle = 0,
    tomLineSpace1pt5 = 1,
    tomLineSpaceDouble = 2,
    tomLineSpaceAtLeast = 3,
    tomLineSpaceExactly = 4,
    tomLineSpaceMultiple = 5,
    tomLineSpacePercent = 6,
    tomAlignLeft = 0,
    tomAlignCenter = 1,
    tomAlignRight = 2,
    tomAlignJustify = 3,
    tomAlignDecimal = 3,
    tomAlignBar = 4,
    tomDefaultTab = 5,
    tomAlignInterWord = 3,
    tomAlignNewspaper = 4,
    tomAlignInterLetter = 5,
    tomAlignScaled = 6,
    tomSpaces = 0,
    tomDots = 1,
    tomDashes = 2,
    tomLines = 3,
    tomThickLines = 4,
    tomEquals = 5,
    tomTabBack = -3,
    tomTabNext = -2,
    tomTabHere = -1,
    tomListNone = 0,
    tomListBullet = 1,
    tomListNumberAsArabic = 2,
    tomListNumberAsLCLetter = 3,
    tomListNumberAsUCLetter = 4,
    tomListNumberAsLCRoman = 5,
    tomListNumberAsUCRoman = 6,
    tomListNumberAsSequence = 7,
    tomListNumberedCircle = 8,
    tomListNumberedBlackCircleWingding = 9,
    tomListNumberedWhiteCircleWingding = 10,
    tomListNumberedArabicWide = 11,
    tomListNumberedChS = 12,
    tomListNumberedChT = 13,
    tomListNumberedJpnChS = 14,
    tomListNumberedJpnKor = 15,
    tomListNumberedArabic1 = 16,
    tomListNumberedArabic2 = 17,
    tomListNumberedHebrew = 18,
    tomListNumberedThaiAlpha = 19,
    tomListNumberedThaiNum = 20,
    tomListNumberedHindiAlpha = 21,
    tomListNumberedHindiAlpha1 = 22,
    tomListNumberedHindiNum = 23,
    tomListParentheses = 65536,
    tomListPeriod = 131072,
    tomListPlain = 196608,
    tomListNoNumber = 262144,
    tomListMinus = 524288,
    tomIgnoreNumberStyle = 16777216,
    tomParaStyleNormal = -1,
    tomParaStyleHeading1 = -2,
    tomParaStyleHeading2 = -3,
    tomParaStyleHeading3 = -4,
    tomParaStyleHeading4 = -5,
    tomParaStyleHeading5 = -6,
    tomParaStyleHeading6 = -7,
    tomParaStyleHeading7 = -8,
    tomParaStyleHeading8 = -9,
    tomParaStyleHeading9 = -10,
    tomCharacter = 1,
    tomWord = 2,
    tomSentence = 3,
    tomParagraph = 4,
    tomLine = 5,
    tomStory = 6,
    tomScreen = 7,
    tomSection = 8,
    tomTableColumn = 9,
    tomColumn = 9,
    tomRow = 10,
    tomWindow = 11,
    tomCell = 12,
    tomCharFormat = 13,
    tomParaFormat = 14,
    tomTable = 15,
    tomObject = 16,
    tomPage = 17,
    tomHardParagraph = 18,
    tomCluster = 19,
    tomInlineObject = 20,
    tomInlineObjectArg = 21,
    tomLeafLine = 22,
    tomLayoutColumn = 23,
    tomProcessId = 1073741825,
    tomMatchWord = 2,
    tomMatchCase = 4,
    tomMatchPattern = 8,
    tomUnknownStory = 0,
    tomMainTextStory = 1,
    tomFootnotesStory = 2,
    tomEndnotesStory = 3,
    tomCommentsStory = 4,
    tomTextFrameStory = 5,
    tomEvenPagesHeaderStory = 6,
    tomPrimaryHeaderStory = 7,
    tomEvenPagesFooterStory = 8,
    tomPrimaryFooterStory = 9,
    tomFirstPageHeaderStory = 10,
    tomFirstPageFooterStory = 11,
    tomScratchStory = 127,
    tomFindStory = 128,
    tomReplaceStory = 129,
    tomStoryInactive = 0,
    tomStoryActiveDisplay = 1,
    tomStoryActiveUI = 2,
    tomStoryActiveDisplayUI = 3,
    tomNoAnimation = 0,
    tomLasVegasLights = 1,
    tomBlinkingBackground = 2,
    tomSparkleText = 3,
    tomMarchingBlackAnts = 4,
    tomMarchingRedAnts = 5,
    tomShimmer = 6,
    tomWipeDown = 7,
    tomWipeRight = 8,
    tomAnimationMax = 8,
    tomLowerCase = 0,
    tomUpperCase = 1,
    tomTitleCase = 2,
    tomSentenceCase = 4,
    tomToggleCase = 5,
    tomReadOnly = 256,
    tomShareDenyRead = 512,
    tomShareDenyWrite = 1024,
    tomPasteFile = 4096,
    tomCreateNew = 16,
    tomCreateAlways = 32,
    tomOpenExisting = 48,
    tomOpenAlways = 64,
    tomTruncateExisting = 80,
    tomRTF = 1,
    tomText = 2,
    tomHTML = 3,
    tomWordDocument = 4,
    tomBold = -2147483647,
    tomItalic = -2147483646,
    tomUnderline = -2147483644,
    tomStrikeout = -2147483640,
    tomProtected = -2147483632,
    tomLink = -2147483616,
    tomSmallCaps = -2147483584,
    tomAllCaps = -2147483520,
    tomHidden = -2147483392,
    tomOutline = -2147483136,
    tomShadow = -2147482624,
    tomEmboss = -2147481600,
    tomImprint = -2147479552,
    tomDisabled = -2147475456,
    tomRevised = -2147467264,
    tomSubscriptCF = -2147418112,
    tomSuperscriptCF = -2147352576,
    tomFontBound = -2146435072,
    tomLinkProtected = -2139095040,
    tomInlineObjectStart = -2130706432,
    tomExtendedChar = -2113929216,
    tomAutoBackColor = -2080374784,
    tomMathZoneNoBuildUp = -2013265920,
    tomMathZone = -1879048192,
    tomMathZoneOrdinary = -1610612736,
    tomAutoTextColor = -1073741824,
    tomMathZoneDisplay = 262144,
    tomParaEffectRTL = 1,
    tomParaEffectKeep = 2,
    tomParaEffectKeepNext = 4,
    tomParaEffectPageBreakBefore = 8,
    tomParaEffectNoLineNumber = 16,
    tomParaEffectNoWidowControl = 32,
    tomParaEffectDoNotHyphen = 64,
    tomParaEffectSideBySide = 128,
    tomParaEffectCollapsed = 256,
    tomParaEffectOutlineLevel = 512,
    tomParaEffectBox = 1024,
    tomParaEffectTableRowDelimiter = 4096,
    tomParaEffectTable = 16384,
    tomModWidthPairs = 1,
    tomModWidthSpace = 2,
    tomAutoSpaceAlpha = 4,
    tomAutoSpaceNumeric = 8,
    tomAutoSpaceParens = 16,
    tomEmbeddedFont = 32,
    tomDoublestrike = 64,
    tomOverlapping = 128,
    tomNormalCaret = 0,
    tomKoreanBlockCaret = 1,
    tomNullCaret = 2,
    tomIncludeInset = 1,
    tomUnicodeBiDi = 1,
    tomMathCFCheck = 4,
    tomUnlink = 8,
    tomUnhide = 16,
    tomCheckTextLimit = 32,
    tomIgnoreCurrentFont = 0,
    tomMatchCharRep = 1,
    tomMatchFontSignature = 2,
    tomMatchAscii = 4,
    tomGetHeightOnly = 8,
    tomMatchMathFont = 16,
    tomCharset = -2147483648,
    tomCharRepFromLcid = 1073741824,
    tomAnsi = 0,
    tomEastEurope = 1,
    tomCyrillic = 2,
    tomGreek = 3,
    tomTurkish = 4,
    tomHebrew = 5,
    tomArabic = 6,
    tomBaltic = 7,
    tomVietnamese = 8,
    tomDefaultCharRep = 9,
    tomSymbol = 10,
    tomThai = 11,
    tomShiftJIS = 12,
    tomGB2312 = 13,
    tomHangul = 14,
    tomBIG5 = 15,
    tomPC437 = 16,
    tomOEM = 17,
    tomMac = 18,
    tomArmenian = 19,
    tomSyriac = 20,
    tomThaana = 21,
    tomDevanagari = 22,
    tomBengali = 23,
    tomGurmukhi = 24,
    tomGujarati = 25,
    tomOriya = 26,
    tomTamil = 27,
    tomTelugu = 28,
    tomKannada = 29,
    tomMalayalam = 30,
    tomSinhala = 31,
    tomLao = 32,
    tomTibetan = 33,
    tomMyanmar = 34,
    tomGeorgian = 35,
    tomJamo = 36,
    tomEthiopic = 37,
    tomCherokee = 38,
    tomAboriginal = 39,
    tomOgham = 40,
    tomRunic = 41,
    tomKhmer = 42,
    tomMongolian = 43,
    tomBraille = 44,
    tomYi = 45,
    tomLimbu = 46,
    tomTaiLe = 47,
    tomNewTaiLue = 48,
    tomSylotiNagri = 49,
    tomKharoshthi = 50,
    tomKayahli = 51,
    tomUsymbol = 52,
    tomEmoji = 53,
    tomGlagolitic = 54,
    tomLisu = 55,
    tomVai = 56,
    tomNKo = 57,
    tomOsmanya = 58,
    tomPhagsPa = 59,
    tomGothic = 60,
    tomDeseret = 61,
    tomTifinagh = 62,
    tomCharRepMax = 63,
    tomRE10Mode = 1,
    tomUseAtFont = 2,
    tomTextFlowMask = 12,
    tomTextFlowES = 0,
    tomTextFlowSW = 4,
    tomTextFlowWN = 8,
    tomTextFlowNE = 12,
    tomNoIME = 524288,
    tomSelfIME = 262144,
    tomNoUpScroll = 65536,
    tomNoVpScroll = 262144,
    tomNoLink = 0,
    tomClientLink = 1,
    tomFriendlyLinkName = 2,
    tomFriendlyLinkAddress = 3,
    tomAutoLinkURL = 4,
    tomAutoLinkEmail = 5,
    tomAutoLinkPhone = 6,
    tomAutoLinkPath = 7,
    tomCompressNone = 0,
    tomCompressPunctuation = 1,
    tomCompressPunctuationAndKana = 2,
    tomCompressMax = 2,
    tomUnderlinePositionAuto = 0,
    tomUnderlinePositionBelow = 1,
    tomUnderlinePositionAbove = 2,
    tomUnderlinePositionMax = 2,
    tomFontAlignmentAuto = 0,
    tomFontAlignmentTop = 1,
    tomFontAlignmentBaseline = 2,
    tomFontAlignmentBottom = 3,
    tomFontAlignmentCenter = 4,
    tomFontAlignmentMax = 4,
    tomRubyBelow = 128,
    tomRubyAlignCenter = 0,
    tomRubyAlign010 = 1,
    tomRubyAlign121 = 2,
    tomRubyAlignLeft = 3,
    tomRubyAlignRight = 4,
    tomLimitsDefault = 0,
    tomLimitsUnderOver = 1,
    tomLimitsSubSup = 2,
    tomUpperLimitAsSuperScript = 3,
    tomLimitsOpposite = 4,
    tomShowLLimPlaceHldr = 8,
    tomShowULimPlaceHldr = 16,
    tomDontGrowWithContent = 64,
    tomGrowWithContent = 128,
    tomSubSupAlign = 1,
    tomLimitAlignMask = 3,
    tomLimitAlignCenter = 0,
    tomLimitAlignLeft = 1,
    tomLimitAlignRight = 2,
    tomShowDegPlaceHldr = 8,
    tomAlignDefault = 0,
    tomAlignMatchAscentDescent = 2,
    tomMathVariant = 32,
    tomStyleDefault = 0,
    tomStyleScriptScriptCramped = 1,
    tomStyleScriptScript = 2,
    tomStyleScriptCramped = 3,
    tomStyleScript = 4,
    tomStyleTextCramped = 5,
    tomStyleText = 6,
    tomStyleDisplayCramped = 7,
    tomStyleDisplay = 8,
    tomMathRelSize = 64,
    tomDecDecSize = 254,
    tomDecSize = 255,
    tomIncSize = 65,
    tomIncIncSize = 66,
    tomGravityUI = 0,
    tomGravityBack = 1,
    tomGravityFore = 2,
    tomGravityIn = 3,
    tomGravityOut = 4,
    tomGravityBackward = 536870912,
    tomGravityForward = 1073741824,
    tomAdjustCRLF = 1,
    tomUseCRLF = 2,
    tomTextize = 4,
    tomAllowFinalEOP = 8,
    tomFoldMathAlpha = 16,
    tomNoHidden = 32,
    tomIncludeNumbering = 64,
    tomTranslateTableCell = 128,
    tomNoMathZoneBrackets = 256,
    tomConvertMathChar = 512,
    tomNoUCGreekItalic = 1024,
    tomAllowMathBold = 2048,
    tomLanguageTag = 4096,
    tomConvertRTF = 8192,
    tomApplyRtfDocProps = 16384,
    tomPhantomShow = 1,
    tomPhantomZeroWidth = 2,
    tomPhantomZeroAscent = 4,
    tomPhantomZeroDescent = 8,
    tomPhantomTransparent = 16,
    tomPhantomASmash = 5,
    tomPhantomDSmash = 9,
    tomPhantomHSmash = 3,
    tomPhantomSmash = 13,
    tomPhantomHorz = 12,
    tomPhantomVert = 2,
    tomBoxHideTop = 1,
    tomBoxHideBottom = 2,
    tomBoxHideLeft = 4,
    tomBoxHideRight = 8,
    tomBoxStrikeH = 16,
    tomBoxStrikeV = 32,
    tomBoxStrikeTLBR = 64,
    tomBoxStrikeBLTR = 128,
    tomBoxAlignCenter = 1,
    tomSpaceMask = 28,
    tomSpaceDefault = 0,
    tomSpaceUnary = 4,
    tomSpaceBinary = 8,
    tomSpaceRelational = 12,
    tomSpaceSkip = 16,
    tomSpaceOrd = 20,
    tomSpaceDifferential = 24,
    tomSizeText = 32,
    tomSizeScript = 64,
    tomSizeScriptScript = 96,
    tomNoBreak = 128,
    tomTransparentForPositioning = 256,
    tomTransparentForSpacing = 512,
    tomStretchCharBelow = 0,
    tomStretchCharAbove = 1,
    tomStretchBaseBelow = 2,
    tomStretchBaseAbove = 3,
    tomMatrixAlignMask = 3,
    tomMatrixAlignCenter = 0,
    tomMatrixAlignTopRow = 1,
    tomMatrixAlignBottomRow = 3,
    tomShowMatPlaceHldr = 8,
    tomEqArrayLayoutWidth = 1,
    tomEqArrayAlignMask = 12,
    tomEqArrayAlignCenter = 0,
    tomEqArrayAlignTopRow = 4,
    tomEqArrayAlignBottomRow = 12,
    tomMathManualBreakMask = 127,
    tomMathBreakLeft = 125,
    tomMathBreakCenter = 126,
    tomMathBreakRight = 127,
    tomMathEqAlign = 128,
    tomMathArgShadingStart = 593,
    tomMathArgShadingEnd = 594,
    tomMathObjShadingStart = 595,
    tomMathObjShadingEnd = 596,
    tomFunctionTypeNone = 0,
    tomFunctionTypeTakesArg = 1,
    tomFunctionTypeTakesLim = 2,
    tomFunctionTypeTakesLim2 = 3,
    tomFunctionTypeIsLim = 4,
    tomMathParaAlignDefault = 0,
    tomMathParaAlignCenterGroup = 1,
    tomMathParaAlignCenter = 2,
    tomMathParaAlignLeft = 3,
    tomMathParaAlignRight = 4,
    tomMathDispAlignMask = 3,
    tomMathDispAlignCenterGroup = 0,
    tomMathDispAlignCenter = 1,
    tomMathDispAlignLeft = 2,
    tomMathDispAlignRight = 3,
    tomMathDispIntUnderOver = 4,
    tomMathDispFracTeX = 8,
    tomMathDispNaryGrow = 16,
    tomMathDocEmptyArgMask = 96,
    tomMathDocEmptyArgAuto = 0,
    tomMathDocEmptyArgAlways = 32,
    tomMathDocEmptyArgNever = 64,
    tomMathDocSbSpOpUnchanged = 128,
    tomMathDocDiffMask = 768,
    tomMathDocDiffDefault = 0,
    tomMathDocDiffUpright = 256,
    tomMathDocDiffItalic = 512,
    tomMathDocDiffOpenItalic = 768,
    tomMathDispNarySubSup = 1024,
    tomMathDispDef = 2048,
    tomMathEnableRtl = 4096,
    tomMathBrkBinMask = 196608,
    tomMathBrkBinBefore = 0,
    tomMathBrkBinAfter = 65536,
    tomMathBrkBinDup = 131072,
    tomMathBrkBinSubMask = 786432,
    tomMathBrkBinSubMM = 0,
    tomMathBrkBinSubPM = 262144,
    tomMathBrkBinSubMP = 524288,
    tomSelRange = 597,
    tomHstring = 596,
    tomFontPropTeXStyle = 828,
    tomFontPropAlign = 829,
    tomFontStretch = 830,
    tomFontStyle = 831,
    tomFontStyleUpright = 0,
    tomFontStyleOblique = 1,
    tomFontStyleItalic = 2,
    tomFontStretchDefault = 0,
    tomFontStretchUltraCondensed = 1,
    tomFontStretchExtraCondensed = 2,
    tomFontStretchCondensed = 3,
    tomFontStretchSemiCondensed = 4,
    tomFontStretchNormal = 5,
    tomFontStretchSemiExpanded = 6,
    tomFontStretchExpanded = 7,
    tomFontStretchExtraExpanded = 8,
    tomFontStretchUltraExpanded = 9,
    tomFontWeightDefault = 0,
    tomFontWeightThin = 100,
    tomFontWeightExtraLight = 200,
    tomFontWeightLight = 300,
    tomFontWeightNormal = 400,
    tomFontWeightRegular = 400,
    tomFontWeightMedium = 500,
    tomFontWeightSemiBold = 600,
    tomFontWeightBold = 700,
    tomFontWeightExtraBold = 800,
    tomFontWeightBlack = 900,
    tomFontWeightHeavy = 900,
    tomFontWeightExtraBlack = 950,
    tomParaPropMathAlign = 1079,
    tomDocMathBuild = 128,
    tomMathLMargin = 129,
    tomMathRMargin = 130,
    tomMathWrapIndent = 131,
    tomMathWrapRight = 132,
    tomMathPostSpace = 134,
    tomMathPreSpace = 133,
    tomMathInterSpace = 135,
    tomMathIntraSpace = 136,
    tomCanCopy = 137,
    tomCanRedo = 138,
    tomCanUndo = 139,
    tomUndoLimit = 140,
    tomDocAutoLink = 141,
    tomEllipsisMode = 142,
    tomEllipsisState = 143,
    tomEllipsisNone = 0,
    tomEllipsisEnd = 1,
    tomEllipsisWord = 3,
    tomEllipsisPresent = 1,
    tomVTopCell = 1,
    tomVLowCell = 2,
    tomHStartCell = 4,
    tomHContCell = 8,
    tomRowUpdate = 1,
    tomRowApplyDefault = 0,
    tomCellStructureChangeOnly = 1,
    tomRowHeightActual = 2059,
};
pub const tomFalse = tomConstants.tomFalse;
pub const tomTrue = tomConstants.tomTrue;
pub const tomUndefined = tomConstants.tomUndefined;
pub const tomToggle = tomConstants.tomToggle;
pub const tomAutoColor = tomConstants.tomAutoColor;
pub const tomDefault = tomConstants.tomDefault;
pub const tomSuspend = tomConstants.tomSuspend;
pub const tomResume = tomConstants.tomResume;
pub const tomApplyNow = tomConstants.tomApplyNow;
pub const tomApplyLater = tomConstants.tomApplyLater;
pub const tomTrackParms = tomConstants.tomTrackParms;
pub const tomCacheParms = tomConstants.tomCacheParms;
pub const tomApplyTmp = tomConstants.tomApplyTmp;
pub const tomDisableSmartFont = tomConstants.tomDisableSmartFont;
pub const tomEnableSmartFont = tomConstants.tomEnableSmartFont;
pub const tomUsePoints = tomConstants.tomUsePoints;
pub const tomUseTwips = tomConstants.tomUseTwips;
pub const tomBackward = tomConstants.tomBackward;
pub const tomForward = tomConstants.tomForward;
pub const tomMove = tomConstants.tomMove;
pub const tomExtend = tomConstants.tomExtend;
pub const tomNoSelection = tomConstants.tomNoSelection;
pub const tomSelectionIP = tomConstants.tomSelectionIP;
pub const tomSelectionNormal = tomConstants.tomSelectionNormal;
pub const tomSelectionFrame = tomConstants.tomSelectionFrame;
pub const tomSelectionColumn = tomConstants.tomSelectionColumn;
pub const tomSelectionRow = tomConstants.tomSelectionRow;
pub const tomSelectionBlock = tomConstants.tomSelectionBlock;
pub const tomSelectionInlineShape = tomConstants.tomSelectionInlineShape;
pub const tomSelectionShape = tomConstants.tomSelectionShape;
pub const tomSelStartActive = tomConstants.tomSelStartActive;
pub const tomSelAtEOL = tomConstants.tomSelAtEOL;
pub const tomSelOvertype = tomConstants.tomSelOvertype;
pub const tomSelActive = tomConstants.tomSelActive;
pub const tomSelReplace = tomConstants.tomSelReplace;
pub const tomEnd = tomConstants.tomEnd;
pub const tomStart = tomConstants.tomStart;
pub const tomCollapseEnd = tomConstants.tomCollapseEnd;
pub const tomCollapseStart = tomConstants.tomCollapseStart;
pub const tomClientCoord = tomConstants.tomClientCoord;
pub const tomAllowOffClient = tomConstants.tomAllowOffClient;
pub const tomTransform = tomConstants.tomTransform;
pub const tomObjectArg = tomConstants.tomObjectArg;
pub const tomAtEnd = tomConstants.tomAtEnd;
pub const tomNone = tomConstants.tomNone;
pub const tomSingle = tomConstants.tomSingle;
pub const tomWords = tomConstants.tomWords;
pub const tomDouble = tomConstants.tomDouble;
pub const tomDotted = tomConstants.tomDotted;
pub const tomDash = tomConstants.tomDash;
pub const tomDashDot = tomConstants.tomDashDot;
pub const tomDashDotDot = tomConstants.tomDashDotDot;
pub const tomWave = tomConstants.tomWave;
pub const tomThick = tomConstants.tomThick;
pub const tomHair = tomConstants.tomHair;
pub const tomDoubleWave = tomConstants.tomDoubleWave;
pub const tomHeavyWave = tomConstants.tomHeavyWave;
pub const tomLongDash = tomConstants.tomLongDash;
pub const tomThickDash = tomConstants.tomThickDash;
pub const tomThickDashDot = tomConstants.tomThickDashDot;
pub const tomThickDashDotDot = tomConstants.tomThickDashDotDot;
pub const tomThickDotted = tomConstants.tomThickDotted;
pub const tomThickLongDash = tomConstants.tomThickLongDash;
pub const tomLineSpaceSingle = tomConstants.tomLineSpaceSingle;
pub const tomLineSpace1pt5 = tomConstants.tomLineSpace1pt5;
pub const tomLineSpaceDouble = tomConstants.tomLineSpaceDouble;
pub const tomLineSpaceAtLeast = tomConstants.tomLineSpaceAtLeast;
pub const tomLineSpaceExactly = tomConstants.tomLineSpaceExactly;
pub const tomLineSpaceMultiple = tomConstants.tomLineSpaceMultiple;
pub const tomLineSpacePercent = tomConstants.tomLineSpacePercent;
pub const tomAlignLeft = tomConstants.tomAlignLeft;
pub const tomAlignCenter = tomConstants.tomAlignCenter;
pub const tomAlignRight = tomConstants.tomAlignRight;
pub const tomAlignJustify = tomConstants.tomAlignJustify;
pub const tomAlignDecimal = tomConstants.tomAlignDecimal;
pub const tomAlignBar = tomConstants.tomAlignBar;
pub const tomDefaultTab = tomConstants.tomDefaultTab;
pub const tomAlignInterWord = tomConstants.tomAlignInterWord;
pub const tomAlignNewspaper = tomConstants.tomAlignNewspaper;
pub const tomAlignInterLetter = tomConstants.tomAlignInterLetter;
pub const tomAlignScaled = tomConstants.tomAlignScaled;
pub const tomSpaces = tomConstants.tomSpaces;
pub const tomDots = tomConstants.tomDots;
pub const tomDashes = tomConstants.tomDashes;
pub const tomLines = tomConstants.tomLines;
pub const tomThickLines = tomConstants.tomThickLines;
pub const tomEquals = tomConstants.tomEquals;
pub const tomTabBack = tomConstants.tomTabBack;
pub const tomTabNext = tomConstants.tomTabNext;
pub const tomTabHere = tomConstants.tomTabHere;
pub const tomListNone = tomConstants.tomListNone;
pub const tomListBullet = tomConstants.tomListBullet;
pub const tomListNumberAsArabic = tomConstants.tomListNumberAsArabic;
pub const tomListNumberAsLCLetter = tomConstants.tomListNumberAsLCLetter;
pub const tomListNumberAsUCLetter = tomConstants.tomListNumberAsUCLetter;
pub const tomListNumberAsLCRoman = tomConstants.tomListNumberAsLCRoman;
pub const tomListNumberAsUCRoman = tomConstants.tomListNumberAsUCRoman;
pub const tomListNumberAsSequence = tomConstants.tomListNumberAsSequence;
pub const tomListNumberedCircle = tomConstants.tomListNumberedCircle;
pub const tomListNumberedBlackCircleWingding = tomConstants.tomListNumberedBlackCircleWingding;
pub const tomListNumberedWhiteCircleWingding = tomConstants.tomListNumberedWhiteCircleWingding;
pub const tomListNumberedArabicWide = tomConstants.tomListNumberedArabicWide;
pub const tomListNumberedChS = tomConstants.tomListNumberedChS;
pub const tomListNumberedChT = tomConstants.tomListNumberedChT;
pub const tomListNumberedJpnChS = tomConstants.tomListNumberedJpnChS;
pub const tomListNumberedJpnKor = tomConstants.tomListNumberedJpnKor;
pub const tomListNumberedArabic1 = tomConstants.tomListNumberedArabic1;
pub const tomListNumberedArabic2 = tomConstants.tomListNumberedArabic2;
pub const tomListNumberedHebrew = tomConstants.tomListNumberedHebrew;
pub const tomListNumberedThaiAlpha = tomConstants.tomListNumberedThaiAlpha;
pub const tomListNumberedThaiNum = tomConstants.tomListNumberedThaiNum;
pub const tomListNumberedHindiAlpha = tomConstants.tomListNumberedHindiAlpha;
pub const tomListNumberedHindiAlpha1 = tomConstants.tomListNumberedHindiAlpha1;
pub const tomListNumberedHindiNum = tomConstants.tomListNumberedHindiNum;
pub const tomListParentheses = tomConstants.tomListParentheses;
pub const tomListPeriod = tomConstants.tomListPeriod;
pub const tomListPlain = tomConstants.tomListPlain;
pub const tomListNoNumber = tomConstants.tomListNoNumber;
pub const tomListMinus = tomConstants.tomListMinus;
pub const tomIgnoreNumberStyle = tomConstants.tomIgnoreNumberStyle;
pub const tomParaStyleNormal = tomConstants.tomParaStyleNormal;
pub const tomParaStyleHeading1 = tomConstants.tomParaStyleHeading1;
pub const tomParaStyleHeading2 = tomConstants.tomParaStyleHeading2;
pub const tomParaStyleHeading3 = tomConstants.tomParaStyleHeading3;
pub const tomParaStyleHeading4 = tomConstants.tomParaStyleHeading4;
pub const tomParaStyleHeading5 = tomConstants.tomParaStyleHeading5;
pub const tomParaStyleHeading6 = tomConstants.tomParaStyleHeading6;
pub const tomParaStyleHeading7 = tomConstants.tomParaStyleHeading7;
pub const tomParaStyleHeading8 = tomConstants.tomParaStyleHeading8;
pub const tomParaStyleHeading9 = tomConstants.tomParaStyleHeading9;
pub const tomCharacter = tomConstants.tomCharacter;
pub const tomWord = tomConstants.tomWord;
pub const tomSentence = tomConstants.tomSentence;
pub const tomParagraph = tomConstants.tomParagraph;
pub const tomLine = tomConstants.tomLine;
pub const tomStory = tomConstants.tomStory;
pub const tomScreen = tomConstants.tomScreen;
pub const tomSection = tomConstants.tomSection;
pub const tomTableColumn = tomConstants.tomTableColumn;
pub const tomColumn = tomConstants.tomColumn;
pub const tomRow = tomConstants.tomRow;
pub const tomWindow = tomConstants.tomWindow;
pub const tomCell = tomConstants.tomCell;
pub const tomCharFormat = tomConstants.tomCharFormat;
pub const tomParaFormat = tomConstants.tomParaFormat;
pub const tomTable = tomConstants.tomTable;
pub const tomObject = tomConstants.tomObject;
pub const tomPage = tomConstants.tomPage;
pub const tomHardParagraph = tomConstants.tomHardParagraph;
pub const tomCluster = tomConstants.tomCluster;
pub const tomInlineObject = tomConstants.tomInlineObject;
pub const tomInlineObjectArg = tomConstants.tomInlineObjectArg;
pub const tomLeafLine = tomConstants.tomLeafLine;
pub const tomLayoutColumn = tomConstants.tomLayoutColumn;
pub const tomProcessId = tomConstants.tomProcessId;
pub const tomMatchWord = tomConstants.tomMatchWord;
pub const tomMatchCase = tomConstants.tomMatchCase;
pub const tomMatchPattern = tomConstants.tomMatchPattern;
pub const tomUnknownStory = tomConstants.tomUnknownStory;
pub const tomMainTextStory = tomConstants.tomMainTextStory;
pub const tomFootnotesStory = tomConstants.tomFootnotesStory;
pub const tomEndnotesStory = tomConstants.tomEndnotesStory;
pub const tomCommentsStory = tomConstants.tomCommentsStory;
pub const tomTextFrameStory = tomConstants.tomTextFrameStory;
pub const tomEvenPagesHeaderStory = tomConstants.tomEvenPagesHeaderStory;
pub const tomPrimaryHeaderStory = tomConstants.tomPrimaryHeaderStory;
pub const tomEvenPagesFooterStory = tomConstants.tomEvenPagesFooterStory;
pub const tomPrimaryFooterStory = tomConstants.tomPrimaryFooterStory;
pub const tomFirstPageHeaderStory = tomConstants.tomFirstPageHeaderStory;
pub const tomFirstPageFooterStory = tomConstants.tomFirstPageFooterStory;
pub const tomScratchStory = tomConstants.tomScratchStory;
pub const tomFindStory = tomConstants.tomFindStory;
pub const tomReplaceStory = tomConstants.tomReplaceStory;
pub const tomStoryInactive = tomConstants.tomStoryInactive;
pub const tomStoryActiveDisplay = tomConstants.tomStoryActiveDisplay;
pub const tomStoryActiveUI = tomConstants.tomStoryActiveUI;
pub const tomStoryActiveDisplayUI = tomConstants.tomStoryActiveDisplayUI;
pub const tomNoAnimation = tomConstants.tomNoAnimation;
pub const tomLasVegasLights = tomConstants.tomLasVegasLights;
pub const tomBlinkingBackground = tomConstants.tomBlinkingBackground;
pub const tomSparkleText = tomConstants.tomSparkleText;
pub const tomMarchingBlackAnts = tomConstants.tomMarchingBlackAnts;
pub const tomMarchingRedAnts = tomConstants.tomMarchingRedAnts;
pub const tomShimmer = tomConstants.tomShimmer;
pub const tomWipeDown = tomConstants.tomWipeDown;
pub const tomWipeRight = tomConstants.tomWipeRight;
pub const tomAnimationMax = tomConstants.tomAnimationMax;
pub const tomLowerCase = tomConstants.tomLowerCase;
pub const tomUpperCase = tomConstants.tomUpperCase;
pub const tomTitleCase = tomConstants.tomTitleCase;
pub const tomSentenceCase = tomConstants.tomSentenceCase;
pub const tomToggleCase = tomConstants.tomToggleCase;
pub const tomReadOnly = tomConstants.tomReadOnly;
pub const tomShareDenyRead = tomConstants.tomShareDenyRead;
pub const tomShareDenyWrite = tomConstants.tomShareDenyWrite;
pub const tomPasteFile = tomConstants.tomPasteFile;
pub const tomCreateNew = tomConstants.tomCreateNew;
pub const tomCreateAlways = tomConstants.tomCreateAlways;
pub const tomOpenExisting = tomConstants.tomOpenExisting;
pub const tomOpenAlways = tomConstants.tomOpenAlways;
pub const tomTruncateExisting = tomConstants.tomTruncateExisting;
pub const tomRTF = tomConstants.tomRTF;
pub const tomText = tomConstants.tomText;
pub const tomHTML = tomConstants.tomHTML;
pub const tomWordDocument = tomConstants.tomWordDocument;
pub const tomBold = tomConstants.tomBold;
pub const tomItalic = tomConstants.tomItalic;
pub const tomUnderline = tomConstants.tomUnderline;
pub const tomStrikeout = tomConstants.tomStrikeout;
pub const tomProtected = tomConstants.tomProtected;
pub const tomLink = tomConstants.tomLink;
pub const tomSmallCaps = tomConstants.tomSmallCaps;
pub const tomAllCaps = tomConstants.tomAllCaps;
pub const tomHidden = tomConstants.tomHidden;
pub const tomOutline = tomConstants.tomOutline;
pub const tomShadow = tomConstants.tomShadow;
pub const tomEmboss = tomConstants.tomEmboss;
pub const tomImprint = tomConstants.tomImprint;
pub const tomDisabled = tomConstants.tomDisabled;
pub const tomRevised = tomConstants.tomRevised;
pub const tomSubscriptCF = tomConstants.tomSubscriptCF;
pub const tomSuperscriptCF = tomConstants.tomSuperscriptCF;
pub const tomFontBound = tomConstants.tomFontBound;
pub const tomLinkProtected = tomConstants.tomLinkProtected;
pub const tomInlineObjectStart = tomConstants.tomInlineObjectStart;
pub const tomExtendedChar = tomConstants.tomExtendedChar;
pub const tomAutoBackColor = tomConstants.tomAutoBackColor;
pub const tomMathZoneNoBuildUp = tomConstants.tomMathZoneNoBuildUp;
pub const tomMathZone = tomConstants.tomMathZone;
pub const tomMathZoneOrdinary = tomConstants.tomMathZoneOrdinary;
pub const tomAutoTextColor = tomConstants.tomAutoTextColor;
pub const tomMathZoneDisplay = tomConstants.tomMathZoneDisplay;
pub const tomParaEffectRTL = tomConstants.tomParaEffectRTL;
pub const tomParaEffectKeep = tomConstants.tomParaEffectKeep;
pub const tomParaEffectKeepNext = tomConstants.tomParaEffectKeepNext;
pub const tomParaEffectPageBreakBefore = tomConstants.tomParaEffectPageBreakBefore;
pub const tomParaEffectNoLineNumber = tomConstants.tomParaEffectNoLineNumber;
pub const tomParaEffectNoWidowControl = tomConstants.tomParaEffectNoWidowControl;
pub const tomParaEffectDoNotHyphen = tomConstants.tomParaEffectDoNotHyphen;
pub const tomParaEffectSideBySide = tomConstants.tomParaEffectSideBySide;
pub const tomParaEffectCollapsed = tomConstants.tomParaEffectCollapsed;
pub const tomParaEffectOutlineLevel = tomConstants.tomParaEffectOutlineLevel;
pub const tomParaEffectBox = tomConstants.tomParaEffectBox;
pub const tomParaEffectTableRowDelimiter = tomConstants.tomParaEffectTableRowDelimiter;
pub const tomParaEffectTable = tomConstants.tomParaEffectTable;
pub const tomModWidthPairs = tomConstants.tomModWidthPairs;
pub const tomModWidthSpace = tomConstants.tomModWidthSpace;
pub const tomAutoSpaceAlpha = tomConstants.tomAutoSpaceAlpha;
pub const tomAutoSpaceNumeric = tomConstants.tomAutoSpaceNumeric;
pub const tomAutoSpaceParens = tomConstants.tomAutoSpaceParens;
pub const tomEmbeddedFont = tomConstants.tomEmbeddedFont;
pub const tomDoublestrike = tomConstants.tomDoublestrike;
pub const tomOverlapping = tomConstants.tomOverlapping;
pub const tomNormalCaret = tomConstants.tomNormalCaret;
pub const tomKoreanBlockCaret = tomConstants.tomKoreanBlockCaret;
pub const tomNullCaret = tomConstants.tomNullCaret;
pub const tomIncludeInset = tomConstants.tomIncludeInset;
pub const tomUnicodeBiDi = tomConstants.tomUnicodeBiDi;
pub const tomMathCFCheck = tomConstants.tomMathCFCheck;
pub const tomUnlink = tomConstants.tomUnlink;
pub const tomUnhide = tomConstants.tomUnhide;
pub const tomCheckTextLimit = tomConstants.tomCheckTextLimit;
pub const tomIgnoreCurrentFont = tomConstants.tomIgnoreCurrentFont;
pub const tomMatchCharRep = tomConstants.tomMatchCharRep;
pub const tomMatchFontSignature = tomConstants.tomMatchFontSignature;
pub const tomMatchAscii = tomConstants.tomMatchAscii;
pub const tomGetHeightOnly = tomConstants.tomGetHeightOnly;
pub const tomMatchMathFont = tomConstants.tomMatchMathFont;
pub const tomCharset = tomConstants.tomCharset;
pub const tomCharRepFromLcid = tomConstants.tomCharRepFromLcid;
pub const tomAnsi = tomConstants.tomAnsi;
pub const tomEastEurope = tomConstants.tomEastEurope;
pub const tomCyrillic = tomConstants.tomCyrillic;
pub const tomGreek = tomConstants.tomGreek;
pub const tomTurkish = tomConstants.tomTurkish;
pub const tomHebrew = tomConstants.tomHebrew;
pub const tomArabic = tomConstants.tomArabic;
pub const tomBaltic = tomConstants.tomBaltic;
pub const tomVietnamese = tomConstants.tomVietnamese;
pub const tomDefaultCharRep = tomConstants.tomDefaultCharRep;
pub const tomSymbol = tomConstants.tomSymbol;
pub const tomThai = tomConstants.tomThai;
pub const tomShiftJIS = tomConstants.tomShiftJIS;
pub const tomGB2312 = tomConstants.tomGB2312;
pub const tomHangul = tomConstants.tomHangul;
pub const tomBIG5 = tomConstants.tomBIG5;
pub const tomPC437 = tomConstants.tomPC437;
pub const tomOEM = tomConstants.tomOEM;
pub const tomMac = tomConstants.tomMac;
pub const tomArmenian = tomConstants.tomArmenian;
pub const tomSyriac = tomConstants.tomSyriac;
pub const tomThaana = tomConstants.tomThaana;
pub const tomDevanagari = tomConstants.tomDevanagari;
pub const tomBengali = tomConstants.tomBengali;
pub const tomGurmukhi = tomConstants.tomGurmukhi;
pub const tomGujarati = tomConstants.tomGujarati;
pub const tomOriya = tomConstants.tomOriya;
pub const tomTamil = tomConstants.tomTamil;
pub const tomTelugu = tomConstants.tomTelugu;
pub const tomKannada = tomConstants.tomKannada;
pub const tomMalayalam = tomConstants.tomMalayalam;
pub const tomSinhala = tomConstants.tomSinhala;
pub const tomLao = tomConstants.tomLao;
pub const tomTibetan = tomConstants.tomTibetan;
pub const tomMyanmar = tomConstants.tomMyanmar;
pub const tomGeorgian = tomConstants.tomGeorgian;
pub const tomJamo = tomConstants.tomJamo;
pub const tomEthiopic = tomConstants.tomEthiopic;
pub const tomCherokee = tomConstants.tomCherokee;
pub const tomAboriginal = tomConstants.tomAboriginal;
pub const tomOgham = tomConstants.tomOgham;
pub const tomRunic = tomConstants.tomRunic;
pub const tomKhmer = tomConstants.tomKhmer;
pub const tomMongolian = tomConstants.tomMongolian;
pub const tomBraille = tomConstants.tomBraille;
pub const tomYi = tomConstants.tomYi;
pub const tomLimbu = tomConstants.tomLimbu;
pub const tomTaiLe = tomConstants.tomTaiLe;
pub const tomNewTaiLue = tomConstants.tomNewTaiLue;
pub const tomSylotiNagri = tomConstants.tomSylotiNagri;
pub const tomKharoshthi = tomConstants.tomKharoshthi;
pub const tomKayahli = tomConstants.tomKayahli;
pub const tomUsymbol = tomConstants.tomUsymbol;
pub const tomEmoji = tomConstants.tomEmoji;
pub const tomGlagolitic = tomConstants.tomGlagolitic;
pub const tomLisu = tomConstants.tomLisu;
pub const tomVai = tomConstants.tomVai;
pub const tomNKo = tomConstants.tomNKo;
pub const tomOsmanya = tomConstants.tomOsmanya;
pub const tomPhagsPa = tomConstants.tomPhagsPa;
pub const tomGothic = tomConstants.tomGothic;
pub const tomDeseret = tomConstants.tomDeseret;
pub const tomTifinagh = tomConstants.tomTifinagh;
pub const tomCharRepMax = tomConstants.tomCharRepMax;
pub const tomRE10Mode = tomConstants.tomRE10Mode;
pub const tomUseAtFont = tomConstants.tomUseAtFont;
pub const tomTextFlowMask = tomConstants.tomTextFlowMask;
pub const tomTextFlowES = tomConstants.tomTextFlowES;
pub const tomTextFlowSW = tomConstants.tomTextFlowSW;
pub const tomTextFlowWN = tomConstants.tomTextFlowWN;
pub const tomTextFlowNE = tomConstants.tomTextFlowNE;
pub const tomNoIME = tomConstants.tomNoIME;
pub const tomSelfIME = tomConstants.tomSelfIME;
pub const tomNoUpScroll = tomConstants.tomNoUpScroll;
pub const tomNoVpScroll = tomConstants.tomNoVpScroll;
pub const tomNoLink = tomConstants.tomNoLink;
pub const tomClientLink = tomConstants.tomClientLink;
pub const tomFriendlyLinkName = tomConstants.tomFriendlyLinkName;
pub const tomFriendlyLinkAddress = tomConstants.tomFriendlyLinkAddress;
pub const tomAutoLinkURL = tomConstants.tomAutoLinkURL;
pub const tomAutoLinkEmail = tomConstants.tomAutoLinkEmail;
pub const tomAutoLinkPhone = tomConstants.tomAutoLinkPhone;
pub const tomAutoLinkPath = tomConstants.tomAutoLinkPath;
pub const tomCompressNone = tomConstants.tomCompressNone;
pub const tomCompressPunctuation = tomConstants.tomCompressPunctuation;
pub const tomCompressPunctuationAndKana = tomConstants.tomCompressPunctuationAndKana;
pub const tomCompressMax = tomConstants.tomCompressMax;
pub const tomUnderlinePositionAuto = tomConstants.tomUnderlinePositionAuto;
pub const tomUnderlinePositionBelow = tomConstants.tomUnderlinePositionBelow;
pub const tomUnderlinePositionAbove = tomConstants.tomUnderlinePositionAbove;
pub const tomUnderlinePositionMax = tomConstants.tomUnderlinePositionMax;
pub const tomFontAlignmentAuto = tomConstants.tomFontAlignmentAuto;
pub const tomFontAlignmentTop = tomConstants.tomFontAlignmentTop;
pub const tomFontAlignmentBaseline = tomConstants.tomFontAlignmentBaseline;
pub const tomFontAlignmentBottom = tomConstants.tomFontAlignmentBottom;
pub const tomFontAlignmentCenter = tomConstants.tomFontAlignmentCenter;
pub const tomFontAlignmentMax = tomConstants.tomFontAlignmentMax;
pub const tomRubyBelow = tomConstants.tomRubyBelow;
pub const tomRubyAlignCenter = tomConstants.tomRubyAlignCenter;
pub const tomRubyAlign010 = tomConstants.tomRubyAlign010;
pub const tomRubyAlign121 = tomConstants.tomRubyAlign121;
pub const tomRubyAlignLeft = tomConstants.tomRubyAlignLeft;
pub const tomRubyAlignRight = tomConstants.tomRubyAlignRight;
pub const tomLimitsDefault = tomConstants.tomLimitsDefault;
pub const tomLimitsUnderOver = tomConstants.tomLimitsUnderOver;
pub const tomLimitsSubSup = tomConstants.tomLimitsSubSup;
pub const tomUpperLimitAsSuperScript = tomConstants.tomUpperLimitAsSuperScript;
pub const tomLimitsOpposite = tomConstants.tomLimitsOpposite;
pub const tomShowLLimPlaceHldr = tomConstants.tomShowLLimPlaceHldr;
pub const tomShowULimPlaceHldr = tomConstants.tomShowULimPlaceHldr;
pub const tomDontGrowWithContent = tomConstants.tomDontGrowWithContent;
pub const tomGrowWithContent = tomConstants.tomGrowWithContent;
pub const tomSubSupAlign = tomConstants.tomSubSupAlign;
pub const tomLimitAlignMask = tomConstants.tomLimitAlignMask;
pub const tomLimitAlignCenter = tomConstants.tomLimitAlignCenter;
pub const tomLimitAlignLeft = tomConstants.tomLimitAlignLeft;
pub const tomLimitAlignRight = tomConstants.tomLimitAlignRight;
pub const tomShowDegPlaceHldr = tomConstants.tomShowDegPlaceHldr;
pub const tomAlignDefault = tomConstants.tomAlignDefault;
pub const tomAlignMatchAscentDescent = tomConstants.tomAlignMatchAscentDescent;
pub const tomMathVariant = tomConstants.tomMathVariant;
pub const tomStyleDefault = tomConstants.tomStyleDefault;
pub const tomStyleScriptScriptCramped = tomConstants.tomStyleScriptScriptCramped;
pub const tomStyleScriptScript = tomConstants.tomStyleScriptScript;
pub const tomStyleScriptCramped = tomConstants.tomStyleScriptCramped;
pub const tomStyleScript = tomConstants.tomStyleScript;
pub const tomStyleTextCramped = tomConstants.tomStyleTextCramped;
pub const tomStyleText = tomConstants.tomStyleText;
pub const tomStyleDisplayCramped = tomConstants.tomStyleDisplayCramped;
pub const tomStyleDisplay = tomConstants.tomStyleDisplay;
pub const tomMathRelSize = tomConstants.tomMathRelSize;
pub const tomDecDecSize = tomConstants.tomDecDecSize;
pub const tomDecSize = tomConstants.tomDecSize;
pub const tomIncSize = tomConstants.tomIncSize;
pub const tomIncIncSize = tomConstants.tomIncIncSize;
pub const tomGravityUI = tomConstants.tomGravityUI;
pub const tomGravityBack = tomConstants.tomGravityBack;
pub const tomGravityFore = tomConstants.tomGravityFore;
pub const tomGravityIn = tomConstants.tomGravityIn;
pub const tomGravityOut = tomConstants.tomGravityOut;
pub const tomGravityBackward = tomConstants.tomGravityBackward;
pub const tomGravityForward = tomConstants.tomGravityForward;
pub const tomAdjustCRLF = tomConstants.tomAdjustCRLF;
pub const tomUseCRLF = tomConstants.tomUseCRLF;
pub const tomTextize = tomConstants.tomTextize;
pub const tomAllowFinalEOP = tomConstants.tomAllowFinalEOP;
pub const tomFoldMathAlpha = tomConstants.tomFoldMathAlpha;
pub const tomNoHidden = tomConstants.tomNoHidden;
pub const tomIncludeNumbering = tomConstants.tomIncludeNumbering;
pub const tomTranslateTableCell = tomConstants.tomTranslateTableCell;
pub const tomNoMathZoneBrackets = tomConstants.tomNoMathZoneBrackets;
pub const tomConvertMathChar = tomConstants.tomConvertMathChar;
pub const tomNoUCGreekItalic = tomConstants.tomNoUCGreekItalic;
pub const tomAllowMathBold = tomConstants.tomAllowMathBold;
pub const tomLanguageTag = tomConstants.tomLanguageTag;
pub const tomConvertRTF = tomConstants.tomConvertRTF;
pub const tomApplyRtfDocProps = tomConstants.tomApplyRtfDocProps;
pub const tomPhantomShow = tomConstants.tomPhantomShow;
pub const tomPhantomZeroWidth = tomConstants.tomPhantomZeroWidth;
pub const tomPhantomZeroAscent = tomConstants.tomPhantomZeroAscent;
pub const tomPhantomZeroDescent = tomConstants.tomPhantomZeroDescent;
pub const tomPhantomTransparent = tomConstants.tomPhantomTransparent;
pub const tomPhantomASmash = tomConstants.tomPhantomASmash;
pub const tomPhantomDSmash = tomConstants.tomPhantomDSmash;
pub const tomPhantomHSmash = tomConstants.tomPhantomHSmash;
pub const tomPhantomSmash = tomConstants.tomPhantomSmash;
pub const tomPhantomHorz = tomConstants.tomPhantomHorz;
pub const tomPhantomVert = tomConstants.tomPhantomVert;
pub const tomBoxHideTop = tomConstants.tomBoxHideTop;
pub const tomBoxHideBottom = tomConstants.tomBoxHideBottom;
pub const tomBoxHideLeft = tomConstants.tomBoxHideLeft;
pub const tomBoxHideRight = tomConstants.tomBoxHideRight;
pub const tomBoxStrikeH = tomConstants.tomBoxStrikeH;
pub const tomBoxStrikeV = tomConstants.tomBoxStrikeV;
pub const tomBoxStrikeTLBR = tomConstants.tomBoxStrikeTLBR;
pub const tomBoxStrikeBLTR = tomConstants.tomBoxStrikeBLTR;
pub const tomBoxAlignCenter = tomConstants.tomBoxAlignCenter;
pub const tomSpaceMask = tomConstants.tomSpaceMask;
pub const tomSpaceDefault = tomConstants.tomSpaceDefault;
pub const tomSpaceUnary = tomConstants.tomSpaceUnary;
pub const tomSpaceBinary = tomConstants.tomSpaceBinary;
pub const tomSpaceRelational = tomConstants.tomSpaceRelational;
pub const tomSpaceSkip = tomConstants.tomSpaceSkip;
pub const tomSpaceOrd = tomConstants.tomSpaceOrd;
pub const tomSpaceDifferential = tomConstants.tomSpaceDifferential;
pub const tomSizeText = tomConstants.tomSizeText;
pub const tomSizeScript = tomConstants.tomSizeScript;
pub const tomSizeScriptScript = tomConstants.tomSizeScriptScript;
pub const tomNoBreak = tomConstants.tomNoBreak;
pub const tomTransparentForPositioning = tomConstants.tomTransparentForPositioning;
pub const tomTransparentForSpacing = tomConstants.tomTransparentForSpacing;
pub const tomStretchCharBelow = tomConstants.tomStretchCharBelow;
pub const tomStretchCharAbove = tomConstants.tomStretchCharAbove;
pub const tomStretchBaseBelow = tomConstants.tomStretchBaseBelow;
pub const tomStretchBaseAbove = tomConstants.tomStretchBaseAbove;
pub const tomMatrixAlignMask = tomConstants.tomMatrixAlignMask;
pub const tomMatrixAlignCenter = tomConstants.tomMatrixAlignCenter;
pub const tomMatrixAlignTopRow = tomConstants.tomMatrixAlignTopRow;
pub const tomMatrixAlignBottomRow = tomConstants.tomMatrixAlignBottomRow;
pub const tomShowMatPlaceHldr = tomConstants.tomShowMatPlaceHldr;
pub const tomEqArrayLayoutWidth = tomConstants.tomEqArrayLayoutWidth;
pub const tomEqArrayAlignMask = tomConstants.tomEqArrayAlignMask;
pub const tomEqArrayAlignCenter = tomConstants.tomEqArrayAlignCenter;
pub const tomEqArrayAlignTopRow = tomConstants.tomEqArrayAlignTopRow;
pub const tomEqArrayAlignBottomRow = tomConstants.tomEqArrayAlignBottomRow;
pub const tomMathManualBreakMask = tomConstants.tomMathManualBreakMask;
pub const tomMathBreakLeft = tomConstants.tomMathBreakLeft;
pub const tomMathBreakCenter = tomConstants.tomMathBreakCenter;
pub const tomMathBreakRight = tomConstants.tomMathBreakRight;
pub const tomMathEqAlign = tomConstants.tomMathEqAlign;
pub const tomMathArgShadingStart = tomConstants.tomMathArgShadingStart;
pub const tomMathArgShadingEnd = tomConstants.tomMathArgShadingEnd;
pub const tomMathObjShadingStart = tomConstants.tomMathObjShadingStart;
pub const tomMathObjShadingEnd = tomConstants.tomMathObjShadingEnd;
pub const tomFunctionTypeNone = tomConstants.tomFunctionTypeNone;
pub const tomFunctionTypeTakesArg = tomConstants.tomFunctionTypeTakesArg;
pub const tomFunctionTypeTakesLim = tomConstants.tomFunctionTypeTakesLim;
pub const tomFunctionTypeTakesLim2 = tomConstants.tomFunctionTypeTakesLim2;
pub const tomFunctionTypeIsLim = tomConstants.tomFunctionTypeIsLim;
pub const tomMathParaAlignDefault = tomConstants.tomMathParaAlignDefault;
pub const tomMathParaAlignCenterGroup = tomConstants.tomMathParaAlignCenterGroup;
pub const tomMathParaAlignCenter = tomConstants.tomMathParaAlignCenter;
pub const tomMathParaAlignLeft = tomConstants.tomMathParaAlignLeft;
pub const tomMathParaAlignRight = tomConstants.tomMathParaAlignRight;
pub const tomMathDispAlignMask = tomConstants.tomMathDispAlignMask;
pub const tomMathDispAlignCenterGroup = tomConstants.tomMathDispAlignCenterGroup;
pub const tomMathDispAlignCenter = tomConstants.tomMathDispAlignCenter;
pub const tomMathDispAlignLeft = tomConstants.tomMathDispAlignLeft;
pub const tomMathDispAlignRight = tomConstants.tomMathDispAlignRight;
pub const tomMathDispIntUnderOver = tomConstants.tomMathDispIntUnderOver;
pub const tomMathDispFracTeX = tomConstants.tomMathDispFracTeX;
pub const tomMathDispNaryGrow = tomConstants.tomMathDispNaryGrow;
pub const tomMathDocEmptyArgMask = tomConstants.tomMathDocEmptyArgMask;
pub const tomMathDocEmptyArgAuto = tomConstants.tomMathDocEmptyArgAuto;
pub const tomMathDocEmptyArgAlways = tomConstants.tomMathDocEmptyArgAlways;
pub const tomMathDocEmptyArgNever = tomConstants.tomMathDocEmptyArgNever;
pub const tomMathDocSbSpOpUnchanged = tomConstants.tomMathDocSbSpOpUnchanged;
pub const tomMathDocDiffMask = tomConstants.tomMathDocDiffMask;
pub const tomMathDocDiffDefault = tomConstants.tomMathDocDiffDefault;
pub const tomMathDocDiffUpright = tomConstants.tomMathDocDiffUpright;
pub const tomMathDocDiffItalic = tomConstants.tomMathDocDiffItalic;
pub const tomMathDocDiffOpenItalic = tomConstants.tomMathDocDiffOpenItalic;
pub const tomMathDispNarySubSup = tomConstants.tomMathDispNarySubSup;
pub const tomMathDispDef = tomConstants.tomMathDispDef;
pub const tomMathEnableRtl = tomConstants.tomMathEnableRtl;
pub const tomMathBrkBinMask = tomConstants.tomMathBrkBinMask;
pub const tomMathBrkBinBefore = tomConstants.tomMathBrkBinBefore;
pub const tomMathBrkBinAfter = tomConstants.tomMathBrkBinAfter;
pub const tomMathBrkBinDup = tomConstants.tomMathBrkBinDup;
pub const tomMathBrkBinSubMask = tomConstants.tomMathBrkBinSubMask;
pub const tomMathBrkBinSubMM = tomConstants.tomMathBrkBinSubMM;
pub const tomMathBrkBinSubPM = tomConstants.tomMathBrkBinSubPM;
pub const tomMathBrkBinSubMP = tomConstants.tomMathBrkBinSubMP;
pub const tomSelRange = tomConstants.tomSelRange;
pub const tomHstring = tomConstants.tomHstring;
pub const tomFontPropTeXStyle = tomConstants.tomFontPropTeXStyle;
pub const tomFontPropAlign = tomConstants.tomFontPropAlign;
pub const tomFontStretch = tomConstants.tomFontStretch;
pub const tomFontStyle = tomConstants.tomFontStyle;
pub const tomFontStyleUpright = tomConstants.tomFontStyleUpright;
pub const tomFontStyleOblique = tomConstants.tomFontStyleOblique;
pub const tomFontStyleItalic = tomConstants.tomFontStyleItalic;
pub const tomFontStretchDefault = tomConstants.tomFontStretchDefault;
pub const tomFontStretchUltraCondensed = tomConstants.tomFontStretchUltraCondensed;
pub const tomFontStretchExtraCondensed = tomConstants.tomFontStretchExtraCondensed;
pub const tomFontStretchCondensed = tomConstants.tomFontStretchCondensed;
pub const tomFontStretchSemiCondensed = tomConstants.tomFontStretchSemiCondensed;
pub const tomFontStretchNormal = tomConstants.tomFontStretchNormal;
pub const tomFontStretchSemiExpanded = tomConstants.tomFontStretchSemiExpanded;
pub const tomFontStretchExpanded = tomConstants.tomFontStretchExpanded;
pub const tomFontStretchExtraExpanded = tomConstants.tomFontStretchExtraExpanded;
pub const tomFontStretchUltraExpanded = tomConstants.tomFontStretchUltraExpanded;
pub const tomFontWeightDefault = tomConstants.tomFontWeightDefault;
pub const tomFontWeightThin = tomConstants.tomFontWeightThin;
pub const tomFontWeightExtraLight = tomConstants.tomFontWeightExtraLight;
pub const tomFontWeightLight = tomConstants.tomFontWeightLight;
pub const tomFontWeightNormal = tomConstants.tomFontWeightNormal;
pub const tomFontWeightRegular = tomConstants.tomFontWeightRegular;
pub const tomFontWeightMedium = tomConstants.tomFontWeightMedium;
pub const tomFontWeightSemiBold = tomConstants.tomFontWeightSemiBold;
pub const tomFontWeightBold = tomConstants.tomFontWeightBold;
pub const tomFontWeightExtraBold = tomConstants.tomFontWeightExtraBold;
pub const tomFontWeightBlack = tomConstants.tomFontWeightBlack;
pub const tomFontWeightHeavy = tomConstants.tomFontWeightHeavy;
pub const tomFontWeightExtraBlack = tomConstants.tomFontWeightExtraBlack;
pub const tomParaPropMathAlign = tomConstants.tomParaPropMathAlign;
pub const tomDocMathBuild = tomConstants.tomDocMathBuild;
pub const tomMathLMargin = tomConstants.tomMathLMargin;
pub const tomMathRMargin = tomConstants.tomMathRMargin;
pub const tomMathWrapIndent = tomConstants.tomMathWrapIndent;
pub const tomMathWrapRight = tomConstants.tomMathWrapRight;
pub const tomMathPostSpace = tomConstants.tomMathPostSpace;
pub const tomMathPreSpace = tomConstants.tomMathPreSpace;
pub const tomMathInterSpace = tomConstants.tomMathInterSpace;
pub const tomMathIntraSpace = tomConstants.tomMathIntraSpace;
pub const tomCanCopy = tomConstants.tomCanCopy;
pub const tomCanRedo = tomConstants.tomCanRedo;
pub const tomCanUndo = tomConstants.tomCanUndo;
pub const tomUndoLimit = tomConstants.tomUndoLimit;
pub const tomDocAutoLink = tomConstants.tomDocAutoLink;
pub const tomEllipsisMode = tomConstants.tomEllipsisMode;
pub const tomEllipsisState = tomConstants.tomEllipsisState;
pub const tomEllipsisNone = tomConstants.tomEllipsisNone;
pub const tomEllipsisEnd = tomConstants.tomEllipsisEnd;
pub const tomEllipsisWord = tomConstants.tomEllipsisWord;
pub const tomEllipsisPresent = tomConstants.tomEllipsisPresent;
pub const tomVTopCell = tomConstants.tomVTopCell;
pub const tomVLowCell = tomConstants.tomVLowCell;
pub const tomHStartCell = tomConstants.tomHStartCell;
pub const tomHContCell = tomConstants.tomHContCell;
pub const tomRowUpdate = tomConstants.tomRowUpdate;
pub const tomRowApplyDefault = tomConstants.tomRowApplyDefault;
pub const tomCellStructureChangeOnly = tomConstants.tomCellStructureChangeOnly;
pub const tomRowHeightActual = tomConstants.tomRowHeightActual;

pub const OBJECTTYPE = extern enum(i32) {
    tomSimpleText = 0,
    tomRuby = 1,
    tomHorzVert = 2,
    tomWarichu = 3,
    tomEq = 9,
    tomMath = 10,
    tomAccent = 10,
    tomBox = 11,
    tomBoxedFormula = 12,
    tomBrackets = 13,
    tomBracketsWithSeps = 14,
    tomEquationArray = 15,
    tomFraction = 16,
    tomFunctionApply = 17,
    tomLeftSubSup = 18,
    tomLowerLimit = 19,
    tomMatrix = 20,
    tomNary = 21,
    tomOpChar = 22,
    tomOverbar = 23,
    tomPhantom = 24,
    tomRadical = 25,
    tomSlashedFraction = 26,
    tomStack = 27,
    tomStretchStack = 28,
    tomSubscript = 29,
    tomSubSup = 30,
    tomSuperscript = 31,
    tomUnderbar = 32,
    tomUpperLimit = 33,
    tomObjectMax = 33,
};
pub const tomSimpleText = OBJECTTYPE.tomSimpleText;
pub const tomRuby = OBJECTTYPE.tomRuby;
pub const tomHorzVert = OBJECTTYPE.tomHorzVert;
pub const tomWarichu = OBJECTTYPE.tomWarichu;
pub const tomEq = OBJECTTYPE.tomEq;
pub const tomMath = OBJECTTYPE.tomMath;
pub const tomAccent = OBJECTTYPE.tomAccent;
pub const tomBox = OBJECTTYPE.tomBox;
pub const tomBoxedFormula = OBJECTTYPE.tomBoxedFormula;
pub const tomBrackets = OBJECTTYPE.tomBrackets;
pub const tomBracketsWithSeps = OBJECTTYPE.tomBracketsWithSeps;
pub const tomEquationArray = OBJECTTYPE.tomEquationArray;
pub const tomFraction = OBJECTTYPE.tomFraction;
pub const tomFunctionApply = OBJECTTYPE.tomFunctionApply;
pub const tomLeftSubSup = OBJECTTYPE.tomLeftSubSup;
pub const tomLowerLimit = OBJECTTYPE.tomLowerLimit;
pub const tomMatrix = OBJECTTYPE.tomMatrix;
pub const tomNary = OBJECTTYPE.tomNary;
pub const tomOpChar = OBJECTTYPE.tomOpChar;
pub const tomOverbar = OBJECTTYPE.tomOverbar;
pub const tomPhantom = OBJECTTYPE.tomPhantom;
pub const tomRadical = OBJECTTYPE.tomRadical;
pub const tomSlashedFraction = OBJECTTYPE.tomSlashedFraction;
pub const tomStack = OBJECTTYPE.tomStack;
pub const tomStretchStack = OBJECTTYPE.tomStretchStack;
pub const tomSubscript = OBJECTTYPE.tomSubscript;
pub const tomSubSup = OBJECTTYPE.tomSubSup;
pub const tomSuperscript = OBJECTTYPE.tomSuperscript;
pub const tomUnderbar = OBJECTTYPE.tomUnderbar;
pub const tomUpperLimit = OBJECTTYPE.tomUpperLimit;
pub const tomObjectMax = OBJECTTYPE.tomObjectMax;

pub const MANCODE = extern enum(i32) {
    MBOLD = 16,
    MITAL = 32,
    MGREEK = 64,
    MROMN = 0,
    MSCRP = 1,
    MFRAK = 2,
    MOPEN = 3,
    MSANS = 4,
    MMONO = 5,
    MMATH = 6,
    MISOL = 7,
    MINIT = 8,
    MTAIL = 9,
    MSTRCH = 10,
    MLOOP = 11,
    MOPENA = 12,
};
pub const MBOLD = MANCODE.MBOLD;
pub const MITAL = MANCODE.MITAL;
pub const MGREEK = MANCODE.MGREEK;
pub const MROMN = MANCODE.MROMN;
pub const MSCRP = MANCODE.MSCRP;
pub const MFRAK = MANCODE.MFRAK;
pub const MOPEN = MANCODE.MOPEN;
pub const MSANS = MANCODE.MSANS;
pub const MMONO = MANCODE.MMONO;
pub const MMATH = MANCODE.MMATH;
pub const MISOL = MANCODE.MISOL;
pub const MINIT = MANCODE.MINIT;
pub const MTAIL = MANCODE.MTAIL;
pub const MSTRCH = MANCODE.MSTRCH;
pub const MLOOP = MANCODE.MLOOP;
pub const MOPENA = MANCODE.MOPENA;

const IID_ITextDocument_Value = @import("../zig.zig").Guid.initString("8cc497c0-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextDocument = &IID_ITextDocument_Value;
pub const ITextDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetName: fn(
            self: *const ITextDocument,
            pName: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection: fn(
            self: *const ITextDocument,
            ppSel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryCount: fn(
            self: *const ITextDocument,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges: fn(
            self: *const ITextDocument,
            ppStories: ?*?*ITextStoryRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSaved: fn(
            self: *const ITextDocument,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSaved: fn(
            self: *const ITextDocument,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTabStop: fn(
            self: *const ITextDocument,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTabStop: fn(
            self: *const ITextDocument,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        New: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Open: fn(
            self: *const ITextDocument,
            pVar: *VARIANT,
            Flags: i32,
            CodePage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Save: fn(
            self: *const ITextDocument,
            pVar: *VARIANT,
            Flags: i32,
            CodePage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Freeze: fn(
            self: *const ITextDocument,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unfreeze: fn(
            self: *const ITextDocument,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginEditCollection: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndEditCollection: fn(
            self: *const ITextDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Undo: fn(
            self: *const ITextDocument,
            Count: i32,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Redo: fn(
            self: *const ITextDocument,
            Count: i32,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range: fn(
            self: *const ITextDocument,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint: fn(
            self: *const ITextDocument,
            x: i32,
            y: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetName(self: *const T, pName: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetName(@ptrCast(*const ITextDocument, self), pName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetSelection(self: *const T, ppSel: ?*?*ITextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetSelection(@ptrCast(*const ITextDocument, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetStoryCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetStoryCount(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetStoryRanges(self: *const T, ppStories: ?*?*ITextStoryRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetStoryRanges(@ptrCast(*const ITextDocument, self), ppStories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetSaved(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetSaved(@ptrCast(*const ITextDocument, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_SetSaved(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).SetSaved(@ptrCast(*const ITextDocument, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_GetDefaultTabStop(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).GetDefaultTabStop(@ptrCast(*const ITextDocument, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_SetDefaultTabStop(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).SetDefaultTabStop(@ptrCast(*const ITextDocument, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_New(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).New(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Open(self: *const T, pVar: *VARIANT, Flags: i32, CodePage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Open(@ptrCast(*const ITextDocument, self), pVar, Flags, CodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Save(self: *const T, pVar: *VARIANT, Flags: i32, CodePage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Save(@ptrCast(*const ITextDocument, self), pVar, Flags, CodePage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Freeze(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Freeze(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Unfreeze(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Unfreeze(@ptrCast(*const ITextDocument, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_BeginEditCollection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).BeginEditCollection(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_EndEditCollection(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).EndEditCollection(@ptrCast(*const ITextDocument, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Undo(self: *const T, Count: i32, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Undo(@ptrCast(*const ITextDocument, self), Count, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Redo(self: *const T, Count: i32, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Redo(@ptrCast(*const ITextDocument, self), Count, pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_Range(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).Range(@ptrCast(*const ITextDocument, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument_RangeFromPoint(self: *const T, x: i32, y: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument.VTable, self.vtable).RangeFromPoint(@ptrCast(*const ITextDocument, self), x, y, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextRange_Value = @import("../zig.zig").Guid.initString("8cc497c2-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextRange = &IID_ITextRange_Value;
pub const ITextRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetText: fn(
            self: *const ITextRange,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextRange,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar: fn(
            self: *const ITextRange,
            pChar: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetChar: fn(
            self: *const ITextRange,
            Char: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate: fn(
            self: *const ITextRange,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText: fn(
            self: *const ITextRange,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStart: fn(
            self: *const ITextRange,
            pcpFirst: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStart: fn(
            self: *const ITextRange,
            cpFirst: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnd: fn(
            self: *const ITextRange,
            pcpLim: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEnd: fn(
            self: *const ITextRange,
            cpLim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont: fn(
            self: *const ITextRange,
            ppFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont: fn(
            self: *const ITextRange,
            pFont: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara: fn(
            self: *const ITextRange,
            ppPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara: fn(
            self: *const ITextRange,
            pPara: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryLength: fn(
            self: *const ITextRange,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryType: fn(
            self: *const ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Collapse: fn(
            self: *const ITextRange,
            bStart: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Expand: fn(
            self: *const ITextRange,
            Unit: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const ITextRange,
            Unit: i32,
            pIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndex: fn(
            self: *const ITextRange,
            Unit: i32,
            Index: i32,
            Extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRange: fn(
            self: *const ITextRange,
            cpAnchor: i32,
            cpActive: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InRange: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InStory: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextRange,
            pRange: ?*ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Select: fn(
            self: *const ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartOf: fn(
            self: *const ITextRange,
            Unit: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndOf: fn(
            self: *const ITextRange,
            Unit: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStart: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEnd: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveWhile: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartWhile: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndWhile: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUntil: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveStartUntil: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveEndUntil: fn(
            self: *const ITextRange,
            Cset: *VARIANT,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextA: fn(
            self: *const ITextRange,
            bstr: BSTR,
            Count: i32,
            Flags: i32,
            pLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextStart: fn(
            self: *const ITextRange,
            bstr: BSTR,
            Count: i32,
            Flags: i32,
            pLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextEnd: fn(
            self: *const ITextRange,
            bstr: BSTR,
            Count: i32,
            Flags: i32,
            pLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const ITextRange,
            Unit: i32,
            Count: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cut: fn(
            self: *const ITextRange,
            pVar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const ITextRange,
            pVar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Paste: fn(
            self: *const ITextRange,
            pVar: *VARIANT,
            Format: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanPaste: fn(
            self: *const ITextRange,
            pVar: *VARIANT,
            Format: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanEdit: fn(
            self: *const ITextRange,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeCase: fn(
            self: *const ITextRange,
            Type: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPoint: fn(
            self: *const ITextRange,
            Type: i32,
            px: *i32,
            py: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPoint: fn(
            self: *const ITextRange,
            x: i32,
            y: i32,
            Type: i32,
            Extend: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const ITextRange,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmbeddedObject: fn(
            self: *const ITextRange,
            ppObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetText(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetText(@ptrCast(*const ITextRange, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetText(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetText(@ptrCast(*const ITextRange, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetChar(self: *const T, pChar: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetChar(@ptrCast(*const ITextRange, self), pChar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetChar(self: *const T, Char: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetChar(@ptrCast(*const ITextRange, self), Char);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetDuplicate(self: *const T, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextRange, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetFormattedText(self: *const T, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetFormattedText(@ptrCast(*const ITextRange, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetFormattedText(self: *const T, pRange: ?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextRange, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStart(self: *const T, pcpFirst: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStart(@ptrCast(*const ITextRange, self), pcpFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetStart(self: *const T, cpFirst: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetStart(@ptrCast(*const ITextRange, self), cpFirst);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetEnd(self: *const T, pcpLim: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetEnd(@ptrCast(*const ITextRange, self), pcpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetEnd(self: *const T, cpLim: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetEnd(@ptrCast(*const ITextRange, self), cpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetFont(self: *const T, ppFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetFont(@ptrCast(*const ITextRange, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetFont(self: *const T, pFont: ?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetFont(@ptrCast(*const ITextRange, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetPara(self: *const T, ppPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetPara(@ptrCast(*const ITextRange, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetPara(self: *const T, pPara: ?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetPara(@ptrCast(*const ITextRange, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStoryLength(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStoryLength(@ptrCast(*const ITextRange, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetStoryType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetStoryType(@ptrCast(*const ITextRange, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Collapse(self: *const T, bStart: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Collapse(@ptrCast(*const ITextRange, self), bStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Expand(self: *const T, Unit: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Expand(@ptrCast(*const ITextRange, self), Unit, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetIndex(self: *const T, Unit: i32, pIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetIndex(@ptrCast(*const ITextRange, self), Unit, pIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetIndex(self: *const T, Unit: i32, Index: i32, Extend: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetIndex(@ptrCast(*const ITextRange, self), Unit, Index, Extend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetRange(self: *const T, cpAnchor: i32, cpActive: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetRange(@ptrCast(*const ITextRange, self), cpAnchor, cpActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_InRange(self: *const T, pRange: ?*ITextRange, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).InRange(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_InStory(self: *const T, pRange: ?*ITextRange, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).InStory(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_IsEqual(self: *const T, pRange: ?*ITextRange, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).IsEqual(@ptrCast(*const ITextRange, self), pRange, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Select(@ptrCast(*const ITextRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_StartOf(self: *const T, Unit: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).StartOf(@ptrCast(*const ITextRange, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_EndOf(self: *const T, Unit: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).EndOf(@ptrCast(*const ITextRange, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Move(self: *const T, Unit: i32, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Move(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStart(self: *const T, Unit: i32, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStart(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEnd(self: *const T, Unit: i32, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEnd(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveWhile(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStartWhile(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStartWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEndWhile(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEndWhile(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveUntil(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveStartUntil(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveStartUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_MoveEndUntil(self: *const T, Cset: *VARIANT, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).MoveEndUntil(@ptrCast(*const ITextRange, self), Cset, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindTextA(self: *const T, bstr: BSTR, Count: i32, Flags: i32, pLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindTextA(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindTextStart(self: *const T, bstr: BSTR, Count: i32, Flags: i32, pLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindTextStart(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_FindTextEnd(self: *const T, bstr: BSTR, Count: i32, Flags: i32, pLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).FindTextEnd(@ptrCast(*const ITextRange, self), bstr, Count, Flags, pLength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Delete(self: *const T, Unit: i32, Count: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Delete(@ptrCast(*const ITextRange, self), Unit, Count, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Cut(self: *const T, pVar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Cut(@ptrCast(*const ITextRange, self), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Copy(self: *const T, pVar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Copy(@ptrCast(*const ITextRange, self), pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_Paste(self: *const T, pVar: *VARIANT, Format: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).Paste(@ptrCast(*const ITextRange, self), pVar, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_CanPaste(self: *const T, pVar: *VARIANT, Format: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).CanPaste(@ptrCast(*const ITextRange, self), pVar, Format, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_CanEdit(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).CanEdit(@ptrCast(*const ITextRange, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_ChangeCase(self: *const T, Type: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).ChangeCase(@ptrCast(*const ITextRange, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetPoint(self: *const T, Type: i32, px: *i32, py: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetPoint(@ptrCast(*const ITextRange, self), Type, px, py);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_SetPoint(self: *const T, x: i32, y: i32, Type: i32, Extend: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).SetPoint(@ptrCast(*const ITextRange, self), x, y, Type, Extend);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_ScrollIntoView(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).ScrollIntoView(@ptrCast(*const ITextRange, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange_GetEmbeddedObject(self: *const T, ppObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange.VTable, self.vtable).GetEmbeddedObject(@ptrCast(*const ITextRange, self), ppObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextSelection_Value = @import("../zig.zig").Guid.initString("8cc497c1-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextSelection = &IID_ITextSelection_Value;
pub const ITextSelection = extern struct {
    pub const VTable = extern struct {
        base: ITextRange.VTable,
        GetFlags: fn(
            self: *const ITextSelection,
            pFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const ITextSelection,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ITextSelection,
            pType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveLeft: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveRight: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUp: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveDown: fn(
            self: *const ITextSelection,
            Unit: i32,
            Count: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HomeKey: fn(
            self: *const ITextSelection,
            Unit: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndKey: fn(
            self: *const ITextSelection,
            Unit: i32,
            Extend: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TypeText: fn(
            self: *const ITextSelection,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRange.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_GetFlags(self: *const T, pFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).GetFlags(@ptrCast(*const ITextSelection, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_SetFlags(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).SetFlags(@ptrCast(*const ITextSelection, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_GetType(self: *const T, pType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).GetType(@ptrCast(*const ITextSelection, self), pType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveLeft(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveLeft(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveRight(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveRight(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveUp(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveUp(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_MoveDown(self: *const T, Unit: i32, Count: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).MoveDown(@ptrCast(*const ITextSelection, self), Unit, Count, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_HomeKey(self: *const T, Unit: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).HomeKey(@ptrCast(*const ITextSelection, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_EndKey(self: *const T, Unit: i32, Extend: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).EndKey(@ptrCast(*const ITextSelection, self), Unit, Extend, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextSelection_TypeText(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextSelection.VTable, self.vtable).TypeText(@ptrCast(*const ITextSelection, self), bstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextFont_Value = @import("../zig.zig").Guid.initString("8cc497c3-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextFont = &IID_ITextFont_Value;
pub const ITextFont = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: fn(
            self: *const ITextFont,
            ppFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: fn(
            self: *const ITextFont,
            pFont: ?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextFont,
            pFont: ?*ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAllCaps: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAllCaps: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAnimation: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAnimation: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBackColor: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBackColor: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBold: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBold: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEmboss: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEmboss: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetForeColor: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetForeColor: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHidden: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHidden: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngrave: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngrave: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItalic: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetItalic: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKerning: fn(
            self: *const ITextFont,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKerning: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageID: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLanguageID: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const ITextFont,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetName: fn(
            self: *const ITextFont,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutline: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutline: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const ITextFont,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPosition: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProtected: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProtected: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetShadow: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShadow: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const ITextFont,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSize: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSmallCaps: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSmallCaps: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpacing: fn(
            self: *const ITextFont,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpacing: fn(
            self: *const ITextFont,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrikeThrough: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStrikeThrough: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubscript: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSubscript: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSuperscript: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSuperscript: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderline: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderline: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWeight: fn(
            self: *const ITextFont,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWeight: fn(
            self: *const ITextFont,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetDuplicate(self: *const T, ppFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextFont, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetDuplicate(self: *const T, pFont: ?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetDuplicate(@ptrCast(*const ITextFont, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_CanChange(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).CanChange(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_IsEqual(self: *const T, pFont: ?*ITextFont, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).IsEqual(@ptrCast(*const ITextFont, self), pFont, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_Reset(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).Reset(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetStyle(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetStyle(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetStyle(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetStyle(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetAllCaps(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetAllCaps(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetAllCaps(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetAllCaps(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetAnimation(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetAnimation(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetAnimation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetAnimation(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetBackColor(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetBackColor(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetBackColor(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetBackColor(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetBold(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetBold(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetBold(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetBold(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetEmboss(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetEmboss(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetEmboss(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetEmboss(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetForeColor(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetForeColor(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetForeColor(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetForeColor(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetHidden(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetHidden(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetHidden(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetHidden(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetEngrave(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetEngrave(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetEngrave(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetEngrave(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetItalic(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetItalic(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetItalic(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetItalic(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetKerning(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetKerning(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetKerning(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetKerning(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetLanguageID(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetLanguageID(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetLanguageID(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetLanguageID(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetName(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetName(@ptrCast(*const ITextFont, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetName(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetName(@ptrCast(*const ITextFont, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetOutline(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetOutline(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetOutline(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetOutline(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetPosition(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetPosition(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetPosition(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetPosition(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetProtected(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetProtected(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetProtected(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetProtected(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetShadow(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetShadow(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetShadow(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetShadow(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSize(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSize(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSize(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSize(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSmallCaps(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSmallCaps(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSmallCaps(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSmallCaps(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSpacing(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSpacing(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSpacing(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSpacing(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetStrikeThrough(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetStrikeThrough(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetStrikeThrough(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetStrikeThrough(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSubscript(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSubscript(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSubscript(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSubscript(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetSuperscript(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetSuperscript(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetSuperscript(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetSuperscript(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetUnderline(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetUnderline(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetUnderline(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetUnderline(@ptrCast(*const ITextFont, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_GetWeight(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).GetWeight(@ptrCast(*const ITextFont, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont_SetWeight(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont.VTable, self.vtable).SetWeight(@ptrCast(*const ITextFont, self), Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextPara_Value = @import("../zig.zig").Guid.initString("8cc497c4-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextPara = &IID_ITextPara_Value;
pub const ITextPara = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetDuplicate: fn(
            self: *const ITextPara,
            ppPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate: fn(
            self: *const ITextPara,
            pPara: ?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextPara,
            pPara: ?*ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStyle: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStyle: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAlignment: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHyphenation: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHyphenation: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFirstLineIndent: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLeftIndent: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacing: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineSpacingRule: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListAlignment: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListAlignment: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListLevelIndex: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListLevelIndex: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListStart: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListStart: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListTab: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListTab: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListType: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetListType: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNoLineNumber: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNoLineNumber: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageBreakBefore: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPageBreakBefore: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRightIndent: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRightIndent: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndents: fn(
            self: *const ITextPara,
            First: f32,
            Left: f32,
            Right: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLineSpacing: fn(
            self: *const ITextPara,
            Rule: i32,
            Spacing: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceAfter: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceAfter: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceBefore: fn(
            self: *const ITextPara,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceBefore: fn(
            self: *const ITextPara,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWidowControl: fn(
            self: *const ITextPara,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWidowControl: fn(
            self: *const ITextPara,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTabCount: fn(
            self: *const ITextPara,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTab: fn(
            self: *const ITextPara,
            tbPos: f32,
            tbAlign: i32,
            tbLeader: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearAllTabs: fn(
            self: *const ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteTab: fn(
            self: *const ITextPara,
            tbPos: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTab: fn(
            self: *const ITextPara,
            iTab: i32,
            ptbPos: *f32,
            ptbAlign: *i32,
            ptbLeader: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetDuplicate(self: *const T, ppPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetDuplicate(@ptrCast(*const ITextPara, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetDuplicate(self: *const T, pPara: ?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetDuplicate(@ptrCast(*const ITextPara, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_CanChange(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).CanChange(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_IsEqual(self: *const T, pPara: ?*ITextPara, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).IsEqual(@ptrCast(*const ITextPara, self), pPara, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_Reset(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).Reset(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetStyle(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetStyle(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetStyle(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetStyle(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetAlignment(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetAlignment(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetHyphenation(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetHyphenation(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetHyphenation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetHyphenation(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetFirstLineIndent(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetFirstLineIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetKeepTogether(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetKeepTogether(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetKeepTogether(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetKeepTogether(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetKeepWithNext(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetKeepWithNext(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetKeepWithNext(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetKeepWithNext(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLeftIndent(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLeftIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLineSpacing(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLineSpacing(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetLineSpacingRule(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetLineSpacingRule(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListAlignment(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListAlignment(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListLevelIndex(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListLevelIndex(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListLevelIndex(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListLevelIndex(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListStart(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListStart(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListStart(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListTab(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListTab(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListTab(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListTab(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetListType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetListType(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetListType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetListType(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetNoLineNumber(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetNoLineNumber(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetNoLineNumber(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetNoLineNumber(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetPageBreakBefore(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetPageBreakBefore(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetPageBreakBefore(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetPageBreakBefore(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetRightIndent(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetRightIndent(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetRightIndent(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetRightIndent(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetIndents(self: *const T, First: f32, Left: f32, Right: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetIndents(@ptrCast(*const ITextPara, self), First, Left, Right);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetLineSpacing(self: *const T, Rule: i32, Spacing: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetLineSpacing(@ptrCast(*const ITextPara, self), Rule, Spacing);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetSpaceAfter(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetSpaceAfter(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetSpaceAfter(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetSpaceAfter(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetSpaceBefore(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetSpaceBefore(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetSpaceBefore(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetSpaceBefore(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetWidowControl(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetWidowControl(@ptrCast(*const ITextPara, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_SetWidowControl(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).SetWidowControl(@ptrCast(*const ITextPara, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetTabCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetTabCount(@ptrCast(*const ITextPara, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_AddTab(self: *const T, tbPos: f32, tbAlign: i32, tbLeader: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).AddTab(@ptrCast(*const ITextPara, self), tbPos, tbAlign, tbLeader);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_ClearAllTabs(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).ClearAllTabs(@ptrCast(*const ITextPara, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_DeleteTab(self: *const T, tbPos: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).DeleteTab(@ptrCast(*const ITextPara, self), tbPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara_GetTab(self: *const T, iTab: i32, ptbPos: *f32, ptbAlign: *i32, ptbLeader: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara.VTable, self.vtable).GetTab(@ptrCast(*const ITextPara, self), iTab, ptbPos, ptbAlign, ptbLeader);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoryRanges_Value = @import("../zig.zig").Guid.initString("8cc497c5-a1df-11ce-8098-00aa0047be5d");
pub const IID_ITextStoryRanges = &IID_ITextStoryRanges_Value;
pub const ITextStoryRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        _NewEnum: fn(
            self: *const ITextStoryRanges,
            ppunkEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const ITextStoryRanges,
            Index: i32,
            ppRange: ?*?*ITextRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextStoryRanges,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges__NewEnum(self: *const T, ppunkEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable)._NewEnum(@ptrCast(*const ITextStoryRanges, self), ppunkEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable).Item(@ptrCast(*const ITextStoryRanges, self), Index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges.VTable, self.vtable).GetCount(@ptrCast(*const ITextStoryRanges, self), pCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextDocument2_Value = @import("../zig.zig").Guid.initString("c241f5e0-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDocument2 = &IID_ITextDocument2_Value;
pub const ITextDocument2 = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        GetCaretType: fn(
            self: *const ITextDocument2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplays: fn(
            self: *const ITextDocument2,
            ppDisplays: ?*?*ITextDisplays,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: fn(
            self: *const ITextDocument2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentFont: fn(
            self: *const ITextDocument2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: fn(
            self: *const ITextDocument2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentPara: fn(
            self: *const ITextDocument2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEastAsianFlags: fn(
            self: *const ITextDocument2,
            pFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenerator: fn(
            self: *const ITextDocument2,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIMEInProgress: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: fn(
            self: *const ITextDocument2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: fn(
            self: *const ITextDocument2,
            ppSel: ?*?*ITextSelection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoryRanges2: fn(
            self: *const ITextDocument2,
            ppStories: ?*?*ITextStoryRanges2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypographyOptions: fn(
            self: *const ITextDocument2,
            pOptions: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const ITextDocument2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: fn(
            self: *const ITextDocument2,
            pHwnd: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachMsgFilter: fn(
            self: *const ITextDocument2,
            pFilter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: fn(
            self: *const ITextDocument2,
            cch: i32,
            pcch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: fn(
            self: *const ITextDocument2,
            ppVoid: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: fn(
            self: *const ITextDocument2,
            Type: i32,
            pLeft: *i32,
            pTop: *i32,
            pRight: *i32,
            pBottom: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: fn(
            self: *const ITextDocument2,
            Index: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: fn(
            self: *const ITextDocument2,
            pContext: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: fn(
            self: *const ITextDocument2,
            cp: i32,
            CharRep: i32,
            Options: i32,
            curCharRep: i32,
            curFontSize: i32,
            pbstr: ?*BSTR,
            pPitchAndFamily: *i32,
            pNewFontSize: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextDocument2,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStrings: fn(
            self: *const ITextDocument2,
            ppStrs: ?*?*ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const ITextDocument2,
            Notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Range2: fn(
            self: *const ITextDocument2,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RangeFromPoint2: fn(
            self: *const ITextDocument2,
            x: i32,
            y: i32,
            Type: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: fn(
            self: *const ITextDocument2,
            pVoid: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: fn(
            self: *const ITextDocument2,
            Context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: fn(
            self: *const ITextDocument2,
            Index: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextDocument2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypographyOptions: fn(
            self: *const ITextDocument2,
            Options: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: fn(
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const ITextDocument2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: fn(
            self: *const ITextDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathProperties: fn(
            self: *const ITextDocument2,
            pOptions: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathProperties: fn(
            self: *const ITextDocument2,
            Options: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActiveStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveStory: fn(
            self: *const ITextDocument2,
            pStory: ?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMainStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNewStory: fn(
            self: *const ITextDocument2,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStory: fn(
            self: *const ITextDocument2,
            Index: i32,
            ppStory: ?*?*ITextStory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetCaretType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetCaretType(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetCaretType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetCaretType(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDisplays(self: *const T, ppDisplays: ?*?*ITextDisplays) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDisplays(@ptrCast(*const ITextDocument2, self), ppDisplays);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDocumentFont(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDocumentFont(@ptrCast(*const ITextDocument2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetDocumentFont(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetDocumentFont(@ptrCast(*const ITextDocument2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetDocumentPara(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetDocumentPara(@ptrCast(*const ITextDocument2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetDocumentPara(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetDocumentPara(@ptrCast(*const ITextDocument2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetEastAsianFlags(self: *const T, pFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetEastAsianFlags(@ptrCast(*const ITextDocument2, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetGenerator(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetGenerator(@ptrCast(*const ITextDocument2, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetIMEInProgress(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetIMEInProgress(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetNotificationMode(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetNotificationMode(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetNotificationMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetNotificationMode(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetSelection2(@ptrCast(*const ITextDocument2, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStoryRanges2(self: *const T, ppStories: ?*?*ITextStoryRanges2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStoryRanges2(@ptrCast(*const ITextDocument2, self), ppStories);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetTypographyOptions(self: *const T, pOptions: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetTypographyOptions(@ptrCast(*const ITextDocument2, self), pOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetVersion(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetVersion(@ptrCast(*const ITextDocument2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetWindow(self: *const T, pHwnd: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetWindow(@ptrCast(*const ITextDocument2, self), pHwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).AttachMsgFilter(@ptrCast(*const ITextDocument2, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_CheckTextLimit(self: *const T, cch: i32, pcch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).CheckTextLimit(@ptrCast(*const ITextDocument2, self), cch, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetCallManager(@ptrCast(*const ITextDocument2, self), ppVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetClientRect(self: *const T, Type: i32, pLeft: *i32, pTop: *i32, pRight: *i32, pBottom: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetClientRect(@ptrCast(*const ITextDocument2, self), Type, pLeft, pTop, pRight, pBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetEffectColor(self: *const T, Index: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetEffectColor(@ptrCast(*const ITextDocument2, self), Index, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetImmContext(self: *const T, pContext: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetImmContext(@ptrCast(*const ITextDocument2, self), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Options: i32, curCharRep: i32, curFontSize: i32, pbstr: ?*BSTR, pPitchAndFamily: *i32, pNewFontSize: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetPreferredFont(@ptrCast(*const ITextDocument2, self), cp, CharRep, Options, curCharRep, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextDocument2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStrings(self: *const T, ppStrs: ?*?*ITextStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStrings(@ptrCast(*const ITextDocument2, self), ppStrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Notify(self: *const T, Notify: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Notify(@ptrCast(*const ITextDocument2, self), Notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Range2(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Range2(@ptrCast(*const ITextDocument2, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_RangeFromPoint2(self: *const T, x: i32, y: i32, Type: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).RangeFromPoint2(@ptrCast(*const ITextDocument2, self), x, y, Type, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).ReleaseCallManager(@ptrCast(*const ITextDocument2, self), pVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_ReleaseImmContext(self: *const T, Context: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).ReleaseImmContext(@ptrCast(*const ITextDocument2, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetEffectColor(self: *const T, Index: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetEffectColor(@ptrCast(*const ITextDocument2, self), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextDocument2, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetTypographyOptions(self: *const T, Options: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetTypographyOptions(@ptrCast(*const ITextDocument2, self), Options, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SysBeep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SysBeep(@ptrCast(*const ITextDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_Update(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).Update(@ptrCast(*const ITextDocument2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_UpdateWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).UpdateWindow(@ptrCast(*const ITextDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetMathProperties(self: *const T, pOptions: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetMathProperties(@ptrCast(*const ITextDocument2, self), pOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetMathProperties(self: *const T, Options: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetMathProperties(@ptrCast(*const ITextDocument2, self), Options, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetActiveStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetActiveStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_SetActiveStory(self: *const T, pStory: ?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).SetActiveStory(@ptrCast(*const ITextDocument2, self), pStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetMainStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetMainStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetNewStory(self: *const T, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetNewStory(@ptrCast(*const ITextDocument2, self), ppStory);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2_GetStory(self: *const T, Index: i32, ppStory: ?*?*ITextStory) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2.VTable, self.vtable).GetStory(@ptrCast(*const ITextDocument2, self), Index, ppStory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextRange2_Value = @import("../zig.zig").Guid.initString("c241f5e2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRange2 = &IID_ITextRange2_Value;
pub const ITextRange2 = extern struct {
    pub const VTable = extern struct {
        base: ITextSelection.VTable,
        GetCch: fn(
            self: *const ITextRange2,
            pcch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCells: fn(
            self: *const ITextRange2,
            ppCells: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetColumn: fn(
            self: *const ITextRange2,
            ppColumn: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextRange2,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextRange2,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFont2: fn(
            self: *const ITextRange2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFont2: fn(
            self: *const ITextRange2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFormattedText2: fn(
            self: *const ITextRange2,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText2: fn(
            self: *const ITextRange2,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGravity: fn(
            self: *const ITextRange2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGravity: fn(
            self: *const ITextRange2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPara2: fn(
            self: *const ITextRange2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPara2: fn(
            self: *const ITextRange2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRow: fn(
            self: *const ITextRange2,
            ppRow: ?*?*ITextRow,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStartPara: fn(
            self: *const ITextRange2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTable: fn(
            self: *const ITextRange2,
            ppTable: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetURL: fn(
            self: *const ITextRange2,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetURL: fn(
            self: *const ITextRange2,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSubrange: fn(
            self: *const ITextRange2,
            cp1: i32,
            cp2: i32,
            Activate: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BuildUpMath: fn(
            self: *const ITextRange2,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteSubrange: fn(
            self: *const ITextRange2,
            cpFirst: i32,
            cpLim: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Find: fn(
            self: *const ITextRange2,
            pRange: ?*ITextRange2,
            Count: i32,
            Flags: i32,
            pDelta: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetChar2: fn(
            self: *const ITextRange2,
            pChar: *i32,
            Offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropCap: fn(
            self: *const ITextRange2,
            pcLine: *i32,
            pPosition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInlineObject: fn(
            self: *const ITextRange2,
            pType: *i32,
            pAlign: *i32,
            pChar: *i32,
            pChar1: *i32,
            pChar2: *i32,
            pCount: *i32,
            pTeXStyle: *i32,
            pcCol: *i32,
            pLevel: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextRange2,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRect: fn(
            self: *const ITextRange2,
            Type: i32,
            pLeft: *i32,
            pTop: *i32,
            pRight: *i32,
            pBottom: *i32,
            pHit: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSubrange: fn(
            self: *const ITextRange2,
            iSubrange: i32,
            pcpFirst: *i32,
            pcpLim: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText2: fn(
            self: *const ITextRange2,
            Flags: i32,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HexToUnicode: fn(
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTable: fn(
            self: *const ITextRange2,
            cCol: i32,
            cRow: i32,
            AutoFit: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Linearize: fn(
            self: *const ITextRange2,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActiveSubrange: fn(
            self: *const ITextRange2,
            cpAnchor: i32,
            cpActive: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDropCap: fn(
            self: *const ITextRange2,
            cLine: i32,
            Position: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextRange2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText2: fn(
            self: *const ITextRange2,
            Flags: i32,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnicodeToHex: fn(
            self: *const ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInlineObject: fn(
            self: *const ITextRange2,
            Type: i32,
            Align: i32,
            Char: i32,
            Char1: i32,
            Char2: i32,
            Count: i32,
            TeXStyle: i32,
            cCol: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathFunctionType: fn(
            self: *const ITextRange2,
            bstr: BSTR,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertImage: fn(
            self: *const ITextRange2,
            width: i32,
            height: i32,
            ascent: i32,
            Type: i32,
            bstrAltText: BSTR,
            pStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextSelection.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCch(self: *const T, pcch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCch(@ptrCast(*const ITextRange2, self), pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCells(self: *const T, ppCells: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCells(@ptrCast(*const ITextRange2, self), ppCells);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetColumn(self: *const T, ppColumn: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetColumn(@ptrCast(*const ITextRange2, self), ppColumn);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetCount(@ptrCast(*const ITextRange2, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetDuplicate2(self: *const T, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextRange2, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetFont2(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetFont2(@ptrCast(*const ITextRange2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetFont2(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetFont2(@ptrCast(*const ITextRange2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetFormattedText2(self: *const T, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetFormattedText2(@ptrCast(*const ITextRange2, self), ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetFormattedText2(self: *const T, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetFormattedText2(@ptrCast(*const ITextRange2, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetGravity(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetGravity(@ptrCast(*const ITextRange2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetGravity(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetGravity(@ptrCast(*const ITextRange2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetPara2(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetPara2(@ptrCast(*const ITextRange2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetPara2(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetPara2(@ptrCast(*const ITextRange2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetRow(self: *const T, ppRow: ?*?*ITextRow) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetRow(@ptrCast(*const ITextRange2, self), ppRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetStartPara(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetStartPara(@ptrCast(*const ITextRange2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetTable(self: *const T, ppTable: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetTable(@ptrCast(*const ITextRange2, self), ppTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetURL(self: *const T, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetURL(@ptrCast(*const ITextRange2, self), pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetURL(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetURL(@ptrCast(*const ITextRange2, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_AddSubrange(self: *const T, cp1: i32, cp2: i32, Activate: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).AddSubrange(@ptrCast(*const ITextRange2, self), cp1, cp2, Activate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_BuildUpMath(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).BuildUpMath(@ptrCast(*const ITextRange2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_DeleteSubrange(self: *const T, cpFirst: i32, cpLim: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).DeleteSubrange(@ptrCast(*const ITextRange2, self), cpFirst, cpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_Find(self: *const T, pRange: ?*ITextRange2, Count: i32, Flags: i32, pDelta: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).Find(@ptrCast(*const ITextRange2, self), pRange, Count, Flags, pDelta);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetChar2(self: *const T, pChar: *i32, Offset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetChar2(@ptrCast(*const ITextRange2, self), pChar, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetDropCap(self: *const T, pcLine: *i32, pPosition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetDropCap(@ptrCast(*const ITextRange2, self), pcLine, pPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetInlineObject(self: *const T, pType: *i32, pAlign: *i32, pChar: *i32, pChar1: *i32, pChar2: *i32, pCount: *i32, pTeXStyle: *i32, pcCol: *i32, pLevel: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetInlineObject(@ptrCast(*const ITextRange2, self), pType, pAlign, pChar, pChar1, pChar2, pCount, pTeXStyle, pcCol, pLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextRange2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetRect(self: *const T, Type: i32, pLeft: *i32, pTop: *i32, pRight: *i32, pBottom: *i32, pHit: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetRect(@ptrCast(*const ITextRange2, self), Type, pLeft, pTop, pRight, pBottom, pHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetSubrange(self: *const T, iSubrange: i32, pcpFirst: *i32, pcpLim: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetSubrange(@ptrCast(*const ITextRange2, self), iSubrange, pcpFirst, pcpLim);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetText2(self: *const T, Flags: i32, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetText2(@ptrCast(*const ITextRange2, self), Flags, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_HexToUnicode(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).HexToUnicode(@ptrCast(*const ITextRange2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_InsertTable(self: *const T, cCol: i32, cRow: i32, AutoFit: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).InsertTable(@ptrCast(*const ITextRange2, self), cCol, cRow, AutoFit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_Linearize(self: *const T, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).Linearize(@ptrCast(*const ITextRange2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetActiveSubrange(self: *const T, cpAnchor: i32, cpActive: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetActiveSubrange(@ptrCast(*const ITextRange2, self), cpAnchor, cpActive);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetDropCap(self: *const T, cLine: i32, Position: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetDropCap(@ptrCast(*const ITextRange2, self), cLine, Position);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextRange2, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetText2(self: *const T, Flags: i32, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetText2(@ptrCast(*const ITextRange2, self), Flags, bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_UnicodeToHex(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).UnicodeToHex(@ptrCast(*const ITextRange2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_SetInlineObject(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).SetInlineObject(@ptrCast(*const ITextRange2, self), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_GetMathFunctionType(self: *const T, bstr: BSTR, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).GetMathFunctionType(@ptrCast(*const ITextRange2, self), bstr, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRange2_InsertImage(self: *const T, width: i32, height: i32, ascent: i32, Type: i32, bstrAltText: BSTR, pStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRange2.VTable, self.vtable).InsertImage(@ptrCast(*const ITextRange2, self), width, height, ascent, Type, bstrAltText, pStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextSelection2_Value = @import("../zig.zig").Guid.initString("c241f5e1-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextSelection2 = &IID_ITextSelection2_Value;
pub const ITextSelection2 = extern struct {
    pub const VTable = extern struct {
        base: ITextRange2.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextRange2.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextFont2_Value = @import("../zig.zig").Guid.initString("c241f5e3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextFont2 = &IID_ITextFont2_Value;
pub const ITextFont2 = extern struct {
    pub const VTable = extern struct {
        base: ITextFont.VTable,
        GetCount: fn(
            self: *const ITextFont2,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutoLigatures: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutoLigatures: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceAlpha: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceAlpha: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceNumeric: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceNumeric: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAutospaceParens: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAutospaceParens: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCharRep: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCharRep: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCompressionMode: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompressionMode: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCookie: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCookie: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDoubleStrike: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDoubleStrike: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextFont2,
            ppFont: ?*?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: fn(
            self: *const ITextFont2,
            pFont: ?*ITextFont2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLinkType: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMathZone: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMathZone: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthPairs: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthPairs: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModWidthSpace: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetModWidthSpace: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOldNumbers: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOldNumbers: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOverlapping: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOverlapping: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositionSubSuper: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPositionSubSuper: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScaling: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScaling: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpaceExtension: fn(
            self: *const ITextFont2,
            pValue: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpaceExtension: fn(
            self: *const ITextFont2,
            Value: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUnderlinePositionMode: fn(
            self: *const ITextFont2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetUnderlinePositionMode: fn(
            self: *const ITextFont2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: fn(
            self: *const ITextFont2,
            pValue: *i32,
            pMask: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects2: fn(
            self: *const ITextFont2,
            pValue: *i32,
            pMask: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextFont2,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPropertyInfo: fn(
            self: *const ITextFont2,
            Index: i32,
            pType: *i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: fn(
            self: *const ITextFont2,
            pFont: ?*ITextFont2,
            pB: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: fn(
            self: *const ITextFont2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects2: fn(
            self: *const ITextFont2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextFont2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextFont.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCount(@ptrCast(*const ITextFont2, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutoLigatures(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutoLigatures(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutoLigatures(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutoLigatures(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceAlpha(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceAlpha(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceAlpha(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceAlpha(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceNumeric(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceNumeric(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceNumeric(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceNumeric(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetAutospaceParens(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetAutospaceParens(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetAutospaceParens(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetAutospaceParens(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCharRep(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCharRep(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCharRep(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCharRep(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCompressionMode(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCompressionMode(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCompressionMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCompressionMode(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetCookie(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetCookie(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetCookie(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetCookie(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetDoubleStrike(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetDoubleStrike(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetDoubleStrike(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetDoubleStrike(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetDuplicate2(self: *const T, ppFont: ?*?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextFont2, self), ppFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetDuplicate2(self: *const T, pFont: ?*ITextFont2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetDuplicate2(@ptrCast(*const ITextFont2, self), pFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetLinkType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetLinkType(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetMathZone(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetMathZone(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetMathZone(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetMathZone(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetModWidthPairs(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetModWidthPairs(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetModWidthPairs(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetModWidthPairs(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetModWidthSpace(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetModWidthSpace(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetModWidthSpace(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetModWidthSpace(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetOldNumbers(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetOldNumbers(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetOldNumbers(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetOldNumbers(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetOverlapping(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetOverlapping(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetOverlapping(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetOverlapping(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetPositionSubSuper(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetPositionSubSuper(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetPositionSubSuper(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetPositionSubSuper(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetScaling(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetScaling(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetScaling(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetScaling(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetSpaceExtension(self: *const T, pValue: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetSpaceExtension(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetSpaceExtension(self: *const T, Value: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetSpaceExtension(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetUnderlinePositionMode(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetUnderlinePositionMode(@ptrCast(*const ITextFont2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetUnderlinePositionMode(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetUnderlinePositionMode(@ptrCast(*const ITextFont2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetEffects(self: *const T, pValue: *i32, pMask: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetEffects(@ptrCast(*const ITextFont2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetEffects2(self: *const T, pValue: *i32, pMask: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetEffects2(@ptrCast(*const ITextFont2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextFont2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_GetPropertyInfo(self: *const T, Index: i32, pType: *i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).GetPropertyInfo(@ptrCast(*const ITextFont2, self), Index, pType, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_IsEqual2(self: *const T, pFont: ?*ITextFont2, pB: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).IsEqual2(@ptrCast(*const ITextFont2, self), pFont, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetEffects(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetEffects(@ptrCast(*const ITextFont2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetEffects2(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetEffects2(@ptrCast(*const ITextFont2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextFont2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextFont2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextFont2, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextPara2_Value = @import("../zig.zig").Guid.initString("c241f5e4-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextPara2 = &IID_ITextPara2_Value;
pub const ITextPara2 = extern struct {
    pub const VTable = extern struct {
        base: ITextPara.VTable,
        GetBorders: fn(
            self: *const ITextPara2,
            ppBorders: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDuplicate2: fn(
            self: *const ITextPara2,
            ppPara: ?*?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDuplicate2: fn(
            self: *const ITextPara2,
            pPara: ?*ITextPara2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFontAlignment: fn(
            self: *const ITextPara2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFontAlignment: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHangingPunctuation: fn(
            self: *const ITextPara2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHangingPunctuation: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSnapToGrid: fn(
            self: *const ITextPara2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSnapToGrid: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTrimPunctuationAtStart: fn(
            self: *const ITextPara2,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTrimPunctuationAtStart: fn(
            self: *const ITextPara2,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffects: fn(
            self: *const ITextPara2,
            pValue: *i32,
            pMask: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextPara2,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual2: fn(
            self: *const ITextPara2,
            pPara: ?*ITextPara2,
            pB: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffects: fn(
            self: *const ITextPara2,
            Value: i32,
            Mask: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextPara2,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextPara.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetBorders(self: *const T, ppBorders: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetBorders(@ptrCast(*const ITextPara2, self), ppBorders);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetDuplicate2(self: *const T, ppPara: ?*?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetDuplicate2(@ptrCast(*const ITextPara2, self), ppPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetDuplicate2(self: *const T, pPara: ?*ITextPara2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetDuplicate2(@ptrCast(*const ITextPara2, self), pPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetFontAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetFontAlignment(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetFontAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetFontAlignment(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetHangingPunctuation(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetHangingPunctuation(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetHangingPunctuation(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetHangingPunctuation(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetSnapToGrid(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetSnapToGrid(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetSnapToGrid(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetSnapToGrid(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetTrimPunctuationAtStart(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetTrimPunctuationAtStart(@ptrCast(*const ITextPara2, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetTrimPunctuationAtStart(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetTrimPunctuationAtStart(@ptrCast(*const ITextPara2, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetEffects(self: *const T, pValue: *i32, pMask: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetEffects(@ptrCast(*const ITextPara2, self), pValue, pMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).GetProperty(@ptrCast(*const ITextPara2, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_IsEqual2(self: *const T, pPara: ?*ITextPara2, pB: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).IsEqual2(@ptrCast(*const ITextPara2, self), pPara, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetEffects(self: *const T, Value: i32, Mask: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetEffects(@ptrCast(*const ITextPara2, self), Value, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextPara2_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextPara2.VTable, self.vtable).SetProperty(@ptrCast(*const ITextPara2, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStoryRanges2_Value = @import("../zig.zig").Guid.initString("c241f5e5-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStoryRanges2 = &IID_ITextStoryRanges2_Value;
pub const ITextStoryRanges2 = extern struct {
    pub const VTable = extern struct {
        base: ITextStoryRanges.VTable,
        Item2: fn(
            self: *const ITextStoryRanges2,
            Index: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextStoryRanges.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStoryRanges2_Item2(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStoryRanges2.VTable, self.vtable).Item2(@ptrCast(*const ITextStoryRanges2, self), Index, ppRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStory_Value = @import("../zig.zig").Guid.initString("c241f5f3-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStory = &IID_ITextStory_Value;
pub const ITextStory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActive: fn(
            self: *const ITextStory,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetActive: fn(
            self: *const ITextStory,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplay: fn(
            self: *const ITextStory,
            ppDisplay: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndex: fn(
            self: *const ITextStory,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ITextStory,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetType: fn(
            self: *const ITextStory,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextStory,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRange: fn(
            self: *const ITextStory,
            cpActive: i32,
            cpAnchor: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const ITextStory,
            Flags: i32,
            pbstr: ?*BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextStory,
            pUnk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextStory,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetText: fn(
            self: *const ITextStory,
            Flags: i32,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetActive(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetActive(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetActive(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetActive(@ptrCast(*const ITextStory, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetDisplay(self: *const T, ppDisplay: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetDisplay(@ptrCast(*const ITextStory, self), ppDisplay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetIndex(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetIndex(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetType(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetType(@ptrCast(*const ITextStory, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetType(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetType(@ptrCast(*const ITextStory, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetProperty(@ptrCast(*const ITextStory, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetRange(self: *const T, cpActive: i32, cpAnchor: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetRange(@ptrCast(*const ITextStory, self), cpActive, cpAnchor, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_GetText(self: *const T, Flags: i32, pbstr: ?*BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).GetText(@ptrCast(*const ITextStory, self), Flags, pbstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetFormattedText(self: *const T, pUnk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextStory, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetProperty(@ptrCast(*const ITextStory, self), Type, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStory_SetText(self: *const T, Flags: i32, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStory.VTable, self.vtable).SetText(@ptrCast(*const ITextStory, self), Flags, bstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextStrings_Value = @import("../zig.zig").Guid.initString("c241f5e7-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextStrings = &IID_ITextStrings_Value;
pub const ITextStrings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Item: fn(
            self: *const ITextStrings,
            Index: i32,
            ppRange: ?*?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const ITextStrings,
            pCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ITextStrings,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Append: fn(
            self: *const ITextStrings,
            pRange: ?*ITextRange2,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cat2: fn(
            self: *const ITextStrings,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CatTop2: fn(
            self: *const ITextStrings,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteRange: fn(
            self: *const ITextStrings,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EncodeFunction: fn(
            self: *const ITextStrings,
            Type: i32,
            Align: i32,
            Char: i32,
            Char1: i32,
            Char2: i32,
            Count: i32,
            TeXStyle: i32,
            cCol: i32,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCch: fn(
            self: *const ITextStrings,
            iString: i32,
            pcch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertNullStr: fn(
            self: *const ITextStrings,
            iString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveBoundary: fn(
            self: *const ITextStrings,
            iString: i32,
            cch: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrefixTop: fn(
            self: *const ITextStrings,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const ITextStrings,
            iString: i32,
            cString: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFormattedText: fn(
            self: *const ITextStrings,
            pRangeD: ?*ITextRange2,
            pRangeS: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOpCp: fn(
            self: *const ITextStrings,
            iString: i32,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuffixTop: fn(
            self: *const ITextStrings,
            bstr: BSTR,
            pRange: ?*ITextRange2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Swap: fn(
            self: *const ITextStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Item(self: *const T, Index: i32, ppRange: ?*?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Item(@ptrCast(*const ITextStrings, self), Index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_GetCount(self: *const T, pCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).GetCount(@ptrCast(*const ITextStrings, self), pCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Add(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Add(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Append(self: *const T, pRange: ?*ITextRange2, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Append(@ptrCast(*const ITextStrings, self), pRange, iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Cat2(self: *const T, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Cat2(@ptrCast(*const ITextStrings, self), iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_CatTop2(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).CatTop2(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_DeleteRange(self: *const T, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).DeleteRange(@ptrCast(*const ITextStrings, self), pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_EncodeFunction(self: *const T, Type: i32, Align: i32, Char: i32, Char1: i32, Char2: i32, Count: i32, TeXStyle: i32, cCol: i32, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).EncodeFunction(@ptrCast(*const ITextStrings, self), Type, Align, Char, Char1, Char2, Count, TeXStyle, cCol, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_GetCch(self: *const T, iString: i32, pcch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).GetCch(@ptrCast(*const ITextStrings, self), iString, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_InsertNullStr(self: *const T, iString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).InsertNullStr(@ptrCast(*const ITextStrings, self), iString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_MoveBoundary(self: *const T, iString: i32, cch: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).MoveBoundary(@ptrCast(*const ITextStrings, self), iString, cch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_PrefixTop(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).PrefixTop(@ptrCast(*const ITextStrings, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Remove(self: *const T, iString: i32, cString: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Remove(@ptrCast(*const ITextStrings, self), iString, cString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SetFormattedText(self: *const T, pRangeD: ?*ITextRange2, pRangeS: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SetFormattedText(@ptrCast(*const ITextStrings, self), pRangeD, pRangeS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SetOpCp(self: *const T, iString: i32, cp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SetOpCp(@ptrCast(*const ITextStrings, self), iString, cp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_SuffixTop(self: *const T, bstr: BSTR, pRange: ?*ITextRange2) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).SuffixTop(@ptrCast(*const ITextStrings, self), bstr, pRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextStrings_Swap(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextStrings.VTable, self.vtable).Swap(@ptrCast(*const ITextStrings, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextRow_Value = @import("../zig.zig").Guid.initString("c241f5ef-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextRow = &IID_ITextRow_Value;
pub const ITextRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        GetAlignment: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAlignment: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCount: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCount: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellCountCache: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellCountCache: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellIndex: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellIndex: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMargin: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMargin: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHeight: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHeight: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndent: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetIndent: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepTogether: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepTogether: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeepWithNext: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeepWithNext: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNestLevel: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRTL: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRTL: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellAlignment: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellAlignment: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorBack: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorBack: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellColorFore: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellColorFore: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellMergeFlags: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellMergeFlags: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellShading: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellShading: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellVerticalText: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellVerticalText: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellWidth: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellWidth: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderColors: fn(
            self: *const ITextRow,
            pcrLeft: *i32,
            pcrTop: *i32,
            pcrRight: *i32,
            pcrBottom: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCellBorderWidths: fn(
            self: *const ITextRow,
            pduLeft: *i32,
            pduTop: *i32,
            pduRight: *i32,
            pduBottom: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderColors: fn(
            self: *const ITextRow,
            crLeft: i32,
            crTop: i32,
            crRight: i32,
            crBottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCellBorderWidths: fn(
            self: *const ITextRow,
            duLeft: i32,
            duTop: i32,
            duRight: i32,
            duBottom: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Apply: fn(
            self: *const ITextRow,
            cRow: i32,
            Flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CanChange: fn(
            self: *const ITextRow,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ITextRow,
            Type: i32,
            pValue: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Insert: fn(
            self: *const ITextRow,
            cRow: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const ITextRow,
            pRow: ?*ITextRow,
            pB: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const ITextRow,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ITextRow,
            Type: i32,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetAlignment(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetAlignment(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellCount(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellCount(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellCount(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellCount(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellCountCache(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellCountCache(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellCountCache(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellCountCache(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellIndex(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellIndex(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellIndex(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellIndex(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellMargin(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellMargin(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellMargin(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellMargin(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetHeight(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetHeight(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetHeight(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetHeight(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetIndent(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetIndent(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetIndent(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetIndent(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetKeepTogether(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetKeepTogether(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetKeepTogether(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetKeepTogether(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetKeepWithNext(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetKeepWithNext(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetKeepWithNext(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetKeepWithNext(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetNestLevel(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetNestLevel(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetRTL(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetRTL(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetRTL(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetRTL(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellAlignment(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellAlignment(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellAlignment(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellAlignment(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellColorBack(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellColorBack(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellColorBack(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellColorBack(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellColorFore(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellColorFore(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellColorFore(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellColorFore(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellMergeFlags(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellMergeFlags(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellMergeFlags(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellMergeFlags(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellShading(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellShading(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellShading(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellShading(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellVerticalText(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellVerticalText(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellVerticalText(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellVerticalText(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellWidth(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellWidth(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellWidth(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellWidth(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellBorderColors(self: *const T, pcrLeft: *i32, pcrTop: *i32, pcrRight: *i32, pcrBottom: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellBorderColors(@ptrCast(*const ITextRow, self), pcrLeft, pcrTop, pcrRight, pcrBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetCellBorderWidths(self: *const T, pduLeft: *i32, pduTop: *i32, pduRight: *i32, pduBottom: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetCellBorderWidths(@ptrCast(*const ITextRow, self), pduLeft, pduTop, pduRight, pduBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellBorderColors(self: *const T, crLeft: i32, crTop: i32, crRight: i32, crBottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellBorderColors(@ptrCast(*const ITextRow, self), crLeft, crTop, crRight, crBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetCellBorderWidths(self: *const T, duLeft: i32, duTop: i32, duRight: i32, duBottom: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetCellBorderWidths(@ptrCast(*const ITextRow, self), duLeft, duTop, duRight, duBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Apply(self: *const T, cRow: i32, Flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Apply(@ptrCast(*const ITextRow, self), cRow, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_CanChange(self: *const T, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).CanChange(@ptrCast(*const ITextRow, self), pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_GetProperty(self: *const T, Type: i32, pValue: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).GetProperty(@ptrCast(*const ITextRow, self), Type, pValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Insert(self: *const T, cRow: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Insert(@ptrCast(*const ITextRow, self), cRow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_IsEqual(self: *const T, pRow: ?*ITextRow, pB: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).IsEqual(@ptrCast(*const ITextRow, self), pRow, pB);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_Reset(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).Reset(@ptrCast(*const ITextRow, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextRow_SetProperty(self: *const T, Type: i32, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextRow.VTable, self.vtable).SetProperty(@ptrCast(*const ITextRow, self), Type, Value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextDisplays_Value = @import("../zig.zig").Guid.initString("c241f5f2-7206-11d8-a2c7-00a0d1d6c6b3");
pub const IID_ITextDisplays = &IID_ITextDisplays_Value;
pub const ITextDisplays = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITextDocument2Old_Value = @import("../zig.zig").Guid.initString("01c25500-4268-11d1-883a-3c8b00c10000");
pub const IID_ITextDocument2Old = &IID_ITextDocument2Old_Value;
pub const ITextDocument2Old = extern struct {
    pub const VTable = extern struct {
        base: ITextDocument.VTable,
        AttachMsgFilter: fn(
            self: *const ITextDocument2Old,
            pFilter: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectColor: fn(
            self: *const ITextDocument2Old,
            Index: i32,
            cr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectColor: fn(
            self: *const ITextDocument2Old,
            Index: i32,
            pcr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaretType: fn(
            self: *const ITextDocument2Old,
            pCaretType: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretType: fn(
            self: *const ITextDocument2Old,
            CaretType: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImmContext: fn(
            self: *const ITextDocument2Old,
            pContext: *i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseImmContext: fn(
            self: *const ITextDocument2Old,
            Context: i64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPreferredFont: fn(
            self: *const ITextDocument2Old,
            cp: i32,
            CharRep: i32,
            Option: i32,
            CharRepCur: i32,
            curFontSize: i32,
            pbstr: ?*BSTR,
            pPitchAndFamily: *i32,
            pNewFontSize: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotificationMode: fn(
            self: *const ITextDocument2Old,
            pMode: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotificationMode: fn(
            self: *const ITextDocument2Old,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClientRect: fn(
            self: *const ITextDocument2Old,
            Type: i32,
            pLeft: *i32,
            pTop: *i32,
            pRight: *i32,
            pBottom: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelection2: fn(
            self: *const ITextDocument2Old,
            ppSel: ?*?*ITextSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindow: fn(
            self: *const ITextDocument2Old,
            phWnd: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFEFlags: fn(
            self: *const ITextDocument2Old,
            pFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UpdateWindow: fn(
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckTextLimit: fn(
            self: *const ITextDocument2Old,
            cch: i32,
            pcch: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IMEInProgress: fn(
            self: *const ITextDocument2Old,
            Value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SysBeep: fn(
            self: *const ITextDocument2Old,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Update: fn(
            self: *const ITextDocument2Old,
            Mode: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const ITextDocument2Old,
            Notify: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentFont: fn(
            self: *const ITextDocument2Old,
            ppITextFont: ?*?*ITextFont,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentPara: fn(
            self: *const ITextDocument2Old,
            ppITextPara: ?*?*ITextPara,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCallManager: fn(
            self: *const ITextDocument2Old,
            ppVoid: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReleaseCallManager: fn(
            self: *const ITextDocument2Old,
            pVoid: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_AttachMsgFilter(self: *const T, pFilter: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).AttachMsgFilter(@ptrCast(*const ITextDocument2Old, self), pFilter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetEffectColor(self: *const T, Index: i32, cr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetEffectColor(@ptrCast(*const ITextDocument2Old, self), Index, cr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetEffectColor(self: *const T, Index: i32, pcr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetEffectColor(@ptrCast(*const ITextDocument2Old, self), Index, pcr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetCaretType(self: *const T, pCaretType: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetCaretType(@ptrCast(*const ITextDocument2Old, self), pCaretType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetCaretType(self: *const T, CaretType: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetCaretType(@ptrCast(*const ITextDocument2Old, self), CaretType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetImmContext(self: *const T, pContext: *i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetImmContext(@ptrCast(*const ITextDocument2Old, self), pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_ReleaseImmContext(self: *const T, Context: i64) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).ReleaseImmContext(@ptrCast(*const ITextDocument2Old, self), Context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetPreferredFont(self: *const T, cp: i32, CharRep: i32, Option: i32, CharRepCur: i32, curFontSize: i32, pbstr: ?*BSTR, pPitchAndFamily: *i32, pNewFontSize: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetPreferredFont(@ptrCast(*const ITextDocument2Old, self), cp, CharRep, Option, CharRepCur, curFontSize, pbstr, pPitchAndFamily, pNewFontSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetNotificationMode(self: *const T, pMode: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetNotificationMode(@ptrCast(*const ITextDocument2Old, self), pMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SetNotificationMode(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SetNotificationMode(@ptrCast(*const ITextDocument2Old, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetClientRect(self: *const T, Type: i32, pLeft: *i32, pTop: *i32, pRight: *i32, pBottom: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetClientRect(@ptrCast(*const ITextDocument2Old, self), Type, pLeft, pTop, pRight, pBottom);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetSelection2(self: *const T, ppSel: ?*?*ITextSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetSelection2(@ptrCast(*const ITextDocument2Old, self), ppSel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetWindow(self: *const T, phWnd: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetWindow(@ptrCast(*const ITextDocument2Old, self), phWnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetFEFlags(self: *const T, pFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetFEFlags(@ptrCast(*const ITextDocument2Old, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_UpdateWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).UpdateWindow(@ptrCast(*const ITextDocument2Old, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_CheckTextLimit(self: *const T, cch: i32, pcch: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).CheckTextLimit(@ptrCast(*const ITextDocument2Old, self), cch, pcch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_IMEInProgress(self: *const T, Value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).IMEInProgress(@ptrCast(*const ITextDocument2Old, self), Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_SysBeep(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).SysBeep(@ptrCast(*const ITextDocument2Old, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_Update(self: *const T, Mode: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).Update(@ptrCast(*const ITextDocument2Old, self), Mode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_Notify(self: *const T, Notify: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).Notify(@ptrCast(*const ITextDocument2Old, self), Notify);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetDocumentFont(self: *const T, ppITextFont: ?*?*ITextFont) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetDocumentFont(@ptrCast(*const ITextDocument2Old, self), ppITextFont);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetDocumentPara(self: *const T, ppITextPara: ?*?*ITextPara) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetDocumentPara(@ptrCast(*const ITextDocument2Old, self), ppITextPara);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_GetCallManager(self: *const T, ppVoid: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).GetCallManager(@ptrCast(*const ITextDocument2Old, self), ppVoid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextDocument2Old_ReleaseCallManager(self: *const T, pVoid: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextDocument2Old.VTable, self.vtable).ReleaseCallManager(@ptrCast(*const ITextDocument2Old, self), pVoid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const REOBJECT = extern struct {
    cbStruct: u32,
    cp: i32,
    clsid: Guid,
    poleobj: *IOleObject,
    pstg: *IStorage,
    polesite: *IOleClientSite,
    sizel: SIZE,
    dvaspect: u32,
    dwFlags: u32,
    dwUser: u32,
};

pub const IRichEditOle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetClientSite: fn(
            self: *const IRichEditOle,
            lplpolesite: **IOleClientSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetObjectCount: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetLinkCount: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetObject: fn(
            self: *const IRichEditOle,
            iob: i32,
            lpreobject: *REOBJECT,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertObject: fn(
            self: *const IRichEditOle,
            lpreobject: *REOBJECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConvertObject: fn(
            self: *const IRichEditOle,
            iob: i32,
            rclsidNew: *const Guid,
            lpstrUserTypeNew: [*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAs: fn(
            self: *const IRichEditOle,
            rclsid: *const Guid,
            rclsidAs: *const Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetHostNames: fn(
            self: *const IRichEditOle,
            lpstrContainerApp: [*:0]const u8,
            lpstrContainerObj: [*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLinkAvailable: fn(
            self: *const IRichEditOle,
            iob: i32,
            fAvailable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDvaspect: fn(
            self: *const IRichEditOle,
            iob: i32,
            dvaspect: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandsOffStorage: fn(
            self: *const IRichEditOle,
            iob: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveCompleted: fn(
            self: *const IRichEditOle,
            iob: i32,
            lpstg: *IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InPlaceDeactivate: fn(
            self: *const IRichEditOle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: fn(
            self: *const IRichEditOle,
            fEnterMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: fn(
            self: *const IRichEditOle,
            lpchrg: *CHARRANGE,
            reco: u32,
            lplpdataobj: **IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ImportDataObject: fn(
            self: *const IRichEditOle,
            lpdataobj: *IDataObject,
            cf: u16,
            hMetaPict: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetClientSite(self: *const T, lplpolesite: **IOleClientSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetClientSite(@ptrCast(*const IRichEditOle, self), lplpolesite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetObjectCount(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetObjectCount(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetLinkCount(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetLinkCount(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetObject(self: *const T, iob: i32, lpreobject: *REOBJECT, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetObject(@ptrCast(*const IRichEditOle, self), iob, lpreobject, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_InsertObject(self: *const T, lpreobject: *REOBJECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).InsertObject(@ptrCast(*const IRichEditOle, self), lpreobject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ConvertObject(self: *const T, iob: i32, rclsidNew: *const Guid, lpstrUserTypeNew: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ConvertObject(@ptrCast(*const IRichEditOle, self), iob, rclsidNew, lpstrUserTypeNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ActivateAs(self: *const T, rclsid: *const Guid, rclsidAs: *const Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ActivateAs(@ptrCast(*const IRichEditOle, self), rclsid, rclsidAs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetHostNames(self: *const T, lpstrContainerApp: [*:0]const u8, lpstrContainerObj: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetHostNames(@ptrCast(*const IRichEditOle, self), lpstrContainerApp, lpstrContainerObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetLinkAvailable(self: *const T, iob: i32, fAvailable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetLinkAvailable(@ptrCast(*const IRichEditOle, self), iob, fAvailable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SetDvaspect(self: *const T, iob: i32, dvaspect: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SetDvaspect(@ptrCast(*const IRichEditOle, self), iob, dvaspect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_HandsOffStorage(self: *const T, iob: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).HandsOffStorage(@ptrCast(*const IRichEditOle, self), iob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_SaveCompleted(self: *const T, iob: i32, lpstg: *IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).SaveCompleted(@ptrCast(*const IRichEditOle, self), iob, lpstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_InPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).InPlaceDeactivate(@ptrCast(*const IRichEditOle, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ContextSensitiveHelp(@ptrCast(*const IRichEditOle, self), fEnterMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_GetClipboardData(self: *const T, lpchrg: *CHARRANGE, reco: u32, lplpdataobj: **IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).GetClipboardData(@ptrCast(*const IRichEditOle, self), lpchrg, reco, lplpdataobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOle_ImportDataObject(self: *const T, lpdataobj: *IDataObject, cf: u16, hMetaPict: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOle.VTable, self.vtable).ImportDataObject(@ptrCast(*const IRichEditOle, self), lpdataobj, cf, hMetaPict);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IRichEditOleCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNewStorage: fn(
            self: *const IRichEditOleCallback,
            lplpstg: **IStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInPlaceContext: fn(
            self: *const IRichEditOleCallback,
            lplpFrame: **IOleInPlaceFrame,
            lplpDoc: **IOleInPlaceUIWindow,
            lpFrameInfo: *OIFI,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ShowContainerUI: fn(
            self: *const IRichEditOleCallback,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryInsertObject: fn(
            self: *const IRichEditOleCallback,
            lpclsid: *Guid,
            lpstg: *IStorage,
            cp: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DeleteObject: fn(
            self: *const IRichEditOleCallback,
            lpoleobj: *IOleObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAcceptData: fn(
            self: *const IRichEditOleCallback,
            lpdataobj: *IDataObject,
            lpcfFormat: *u16,
            reco: u32,
            fReally: BOOL,
            hMetaPict: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ContextSensitiveHelp: fn(
            self: *const IRichEditOleCallback,
            fEnterMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetClipboardData: fn(
            self: *const IRichEditOleCallback,
            lpchrg: *CHARRANGE,
            reco: u32,
            lplpdataobj: **IDataObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDragDropEffect: fn(
            self: *const IRichEditOleCallback,
            fDrag: BOOL,
            grfKeyState: u32,
            pdwEffect: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextMenu: fn(
            self: *const IRichEditOleCallback,
            seltype: u16,
            lpoleobj: *IOleObject,
            lpchrg: *CHARRANGE,
            lphmenu: *HMENU,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetNewStorage(self: *const T, lplpstg: **IStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetNewStorage(@ptrCast(*const IRichEditOleCallback, self), lplpstg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetInPlaceContext(self: *const T, lplpFrame: **IOleInPlaceFrame, lplpDoc: **IOleInPlaceUIWindow, lpFrameInfo: *OIFI) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetInPlaceContext(@ptrCast(*const IRichEditOleCallback, self), lplpFrame, lplpDoc, lpFrameInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_ShowContainerUI(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).ShowContainerUI(@ptrCast(*const IRichEditOleCallback, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_QueryInsertObject(self: *const T, lpclsid: *Guid, lpstg: *IStorage, cp: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).QueryInsertObject(@ptrCast(*const IRichEditOleCallback, self), lpclsid, lpstg, cp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_DeleteObject(self: *const T, lpoleobj: *IOleObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).DeleteObject(@ptrCast(*const IRichEditOleCallback, self), lpoleobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_QueryAcceptData(self: *const T, lpdataobj: *IDataObject, lpcfFormat: *u16, reco: u32, fReally: BOOL, hMetaPict: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).QueryAcceptData(@ptrCast(*const IRichEditOleCallback, self), lpdataobj, lpcfFormat, reco, fReally, hMetaPict);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_ContextSensitiveHelp(self: *const T, fEnterMode: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).ContextSensitiveHelp(@ptrCast(*const IRichEditOleCallback, self), fEnterMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetClipboardData(self: *const T, lpchrg: *CHARRANGE, reco: u32, lplpdataobj: **IDataObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetClipboardData(@ptrCast(*const IRichEditOleCallback, self), lpchrg, reco, lplpdataobj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetDragDropEffect(self: *const T, fDrag: BOOL, grfKeyState: u32, pdwEffect: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetDragDropEffect(@ptrCast(*const IRichEditOleCallback, self), fDrag, grfKeyState, pdwEffect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditOleCallback_GetContextMenu(self: *const T, seltype: u16, lpoleobj: *IOleObject, lpchrg: *CHARRANGE, lphmenu: *HMENU) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditOleCallback.VTable, self.vtable).GetContextMenu(@ptrCast(*const IRichEditOleCallback, self), seltype, lpoleobj, lpchrg, lphmenu);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TXTBACKSTYLE = extern enum(i32) {
    TXTBACK_TRANSPARENT = 0,
    TXTBACK_OPAQUE = 1,
};
pub const TXTBACK_TRANSPARENT = TXTBACKSTYLE.TXTBACK_TRANSPARENT;
pub const TXTBACK_OPAQUE = TXTBACKSTYLE.TXTBACK_OPAQUE;

pub const TXTHITRESULT = extern enum(i32) {
    NOHIT = 0,
    TRANSPARENT = 1,
    CLOSE = 2,
    HIT = 3,
};
pub const TXTHITRESULT_NOHIT = TXTHITRESULT.NOHIT;
pub const TXTHITRESULT_TRANSPARENT = TXTHITRESULT.TRANSPARENT;
pub const TXTHITRESULT_CLOSE = TXTHITRESULT.CLOSE;
pub const TXTHITRESULT_HIT = TXTHITRESULT.HIT;

pub const TXTNATURALSIZE = extern enum(i32) {
    TXTNS_FITTOCONTENT2 = 0,
    TXTNS_FITTOCONTENT = 1,
    TXTNS_ROUNDTOLINE = 2,
    TXTNS_FITTOCONTENT3 = 3,
    TXTNS_FITTOCONTENTWSP = 4,
    TXTNS_INCLUDELASTLINE = 1073741824,
    TXTNS_EMU = -2147483648,
};
pub const TXTNS_FITTOCONTENT2 = TXTNATURALSIZE.TXTNS_FITTOCONTENT2;
pub const TXTNS_FITTOCONTENT = TXTNATURALSIZE.TXTNS_FITTOCONTENT;
pub const TXTNS_ROUNDTOLINE = TXTNATURALSIZE.TXTNS_ROUNDTOLINE;
pub const TXTNS_FITTOCONTENT3 = TXTNATURALSIZE.TXTNS_FITTOCONTENT3;
pub const TXTNS_FITTOCONTENTWSP = TXTNATURALSIZE.TXTNS_FITTOCONTENTWSP;
pub const TXTNS_INCLUDELASTLINE = TXTNATURALSIZE.TXTNS_INCLUDELASTLINE;
pub const TXTNS_EMU = TXTNATURALSIZE.TXTNS_EMU;

pub const TXTVIEW = extern enum(i32) {
    ACTIVE = 0,
    INACTIVE = -1,
};
pub const TXTVIEW_ACTIVE = TXTVIEW.ACTIVE;
pub const TXTVIEW_INACTIVE = TXTVIEW.INACTIVE;

pub const CHANGETYPE = extern enum(i32) {
    CN_GENERIC = 0,
    CN_TEXTCHANGED = 1,
    CN_NEWUNDO = 2,
    CN_NEWREDO = 4,
};
pub const CN_GENERIC = CHANGETYPE.CN_GENERIC;
pub const CN_TEXTCHANGED = CHANGETYPE.CN_TEXTCHANGED;
pub const CN_NEWUNDO = CHANGETYPE.CN_NEWUNDO;
pub const CN_NEWREDO = CHANGETYPE.CN_NEWREDO;

pub const CHANGENOTIFY = extern struct {
    dwChangeType: u32,
    pvCookieData: *c_void,
};

pub const ITextServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxSendMessage: fn(
            self: *const ITextServices,
            msg: u32,
            wparam: WPARAM,
            lparam: LPARAM,
            plresult: *LRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDraw: fn(
            self: *const ITextServices,
            dwDrawAspect: u32,
            lindex: i32,
            pvAspect: *c_void,
            ptd: *DVTARGETDEVICE,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            lprcBounds: *RECTL,
            lprcWBounds: *RECTL,
            lprcUpdate: *RECT,
            pfnContinue: **********BOOL,
            dwContinue: u32,
            lViewId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHScroll: fn(
            self: *const ITextServices,
            plMin: *i32,
            plMax: *i32,
            plPos: *i32,
            plPage: *i32,
            pfEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetVScroll: fn(
            self: *const ITextServices,
            plMin: *i32,
            plMax: *i32,
            plPos: *i32,
            plPage: *i32,
            pfEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxSetCursor: fn(
            self: *const ITextServices,
            dwDrawAspect: u32,
            lindex: i32,
            pvAspect: *c_void,
            ptd: *DVTARGETDEVICE,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            lprcClient: *RECT,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxQueryHitPoint: fn(
            self: *const ITextServices,
            dwDrawAspect: u32,
            lindex: i32,
            pvAspect: *c_void,
            ptd: *DVTARGETDEVICE,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            lprcClient: *RECT,
            x: i32,
            y: i32,
            pHitResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceActivate: fn(
            self: *const ITextServices,
            prcClient: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxInPlaceDeactivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIActivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxUIDeactivate: fn(
            self: *const ITextServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetText: fn(
            self: *const ITextServices,
            pbstrText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetText: fn(
            self: *const ITextServices,
            pszText: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCurTargetX: fn(
            self: *const ITextServices,
            param0: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetBaseLinePos: fn(
            self: *const ITextServices,
            param0: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetNaturalSize: fn(
            self: *const ITextServices,
            dwAspect: u32,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            ptd: *DVTARGETDEVICE,
            dwMode: u32,
            psizelExtent: *const SIZE,
            pwidth: *i32,
            pheight: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetDropTarget: fn(
            self: *const ITextServices,
            ppDropTarget: **IDropTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxPropertyBitsChange: fn(
            self: *const ITextServices,
            dwMask: u32,
            dwBits: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCachedSize: fn(
            self: *const ITextServices,
            pdwWidth: *u32,
            pdwHeight: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxSendMessage(self: *const T, msg: u32, wparam: WPARAM, lparam: LPARAM, plresult: *LRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxSendMessage(@ptrCast(*const ITextServices, self), msg, wparam, lparam, plresult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxDraw(self: *const T, dwDrawAspect: u32, lindex: i32, pvAspect: *c_void, ptd: *DVTARGETDEVICE, hdcDraw: HDC, hicTargetDev: HDC, lprcBounds: *RECTL, lprcWBounds: *RECTL, lprcUpdate: *RECT, pfnContinue: **********BOOL, dwContinue: u32, lViewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxDraw(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcBounds, lprcWBounds, lprcUpdate, pfnContinue, dwContinue, lViewId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetHScroll(self: *const T, plMin: *i32, plMax: *i32, plPos: *i32, plPage: *i32, pfEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetHScroll(@ptrCast(*const ITextServices, self), plMin, plMax, plPos, plPage, pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetVScroll(self: *const T, plMin: *i32, plMax: *i32, plPos: *i32, plPage: *i32, pfEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetVScroll(@ptrCast(*const ITextServices, self), plMin, plMax, plPos, plPage, pfEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxSetCursor(self: *const T, dwDrawAspect: u32, lindex: i32, pvAspect: *c_void, ptd: *DVTARGETDEVICE, hdcDraw: HDC, hicTargetDev: HDC, lprcClient: *RECT, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxSetCursor(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxQueryHitPoint(self: *const T, dwDrawAspect: u32, lindex: i32, pvAspect: *c_void, ptd: *DVTARGETDEVICE, hdcDraw: HDC, hicTargetDev: HDC, lprcClient: *RECT, x: i32, y: i32, pHitResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxQueryHitPoint(@ptrCast(*const ITextServices, self), dwDrawAspect, lindex, pvAspect, ptd, hdcDraw, hicTargetDev, lprcClient, x, y, pHitResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxInPlaceActivate(self: *const T, prcClient: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxInPlaceActivate(@ptrCast(*const ITextServices, self), prcClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxInPlaceDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxInPlaceDeactivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxUIActivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxUIActivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxUIDeactivate(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxUIDeactivate(@ptrCast(*const ITextServices, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetText(self: *const T, pbstrText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetText(@ptrCast(*const ITextServices, self), pbstrText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxSetText(self: *const T, pszText: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxSetText(@ptrCast(*const ITextServices, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetCurTargetX(self: *const T, param0: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetCurTargetX(@ptrCast(*const ITextServices, self), param0);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetBaseLinePos(self: *const T, param0: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetBaseLinePos(@ptrCast(*const ITextServices, self), param0);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetNaturalSize(self: *const T, dwAspect: u32, hdcDraw: HDC, hicTargetDev: HDC, ptd: *DVTARGETDEVICE, dwMode: u32, psizelExtent: *const SIZE, pwidth: *i32, pheight: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetNaturalSize(@ptrCast(*const ITextServices, self), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetDropTarget(self: *const T, ppDropTarget: **IDropTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetDropTarget(@ptrCast(*const ITextServices, self), ppDropTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_OnTxPropertyBitsChange(self: *const T, dwMask: u32, dwBits: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).OnTxPropertyBitsChange(@ptrCast(*const ITextServices, self), dwMask, dwBits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices_TxGetCachedSize(self: *const T, pdwWidth: *u32, pdwHeight: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices.VTable, self.vtable).TxGetCachedSize(@ptrCast(*const ITextServices, self), pdwWidth, pdwHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CARET_FLAGS = extern enum(i32) {
    CARET_NONE = 0,
    CARET_CUSTOM = 1,
    CARET_RTL = 2,
    CARET_ITALIC = 32,
    CARET_NULL = 64,
    CARET_ROTATE90 = 128,
};
pub const CARET_NONE = CARET_FLAGS.CARET_NONE;
pub const CARET_CUSTOM = CARET_FLAGS.CARET_CUSTOM;
pub const CARET_RTL = CARET_FLAGS.CARET_RTL;
pub const CARET_ITALIC = CARET_FLAGS.CARET_ITALIC;
pub const CARET_NULL = CARET_FLAGS.CARET_NULL;
pub const CARET_ROTATE90 = CARET_FLAGS.CARET_ROTATE90;

pub const CARET_INFO = u32; // TODO: implement StructOrUnion types?

pub const ITextHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        TxGetDC: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) HDC,
        TxReleaseDC: fn(
            self: *const ITextHost,
            hdc: HDC,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        TxShowScrollBar: fn(
            self: *const ITextHost,
            fnBar: i32,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxEnableScrollBar: fn(
            self: *const ITextHost,
            fuSBFlags: i32,
            fuArrowflags: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollRange: fn(
            self: *const ITextHost,
            fnBar: i32,
            nMinPos: i32,
            nMaxPos: i32,
            fRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetScrollPos: fn(
            self: *const ITextHost,
            fnBar: i32,
            nPos: i32,
            fRedraw: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxInvalidateRect: fn(
            self: *const ITextHost,
            prc: *RECT,
            fMode: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxViewChange: fn(
            self: *const ITextHost,
            fUpdate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxCreateCaret: fn(
            self: *const ITextHost,
            hbmp: HBITMAP,
            xWidth: i32,
            yHeight: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxShowCaret: fn(
            self: *const ITextHost,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetCaretPos: fn(
            self: *const ITextHost,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxSetTimer: fn(
            self: *const ITextHost,
            idTimer: u32,
            uTimeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxKillTimer: fn(
            self: *const ITextHost,
            idTimer: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScrollWindowEx: fn(
            self: *const ITextHost,
            dx: i32,
            dy: i32,
            lprcScroll: *RECT,
            lprcClip: *RECT,
            hrgnUpdate: HRGN,
            lprcUpdate: *RECT,
            fuScroll: u32,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCapture: fn(
            self: *const ITextHost,
            fCapture: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetFocus: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxSetCursor: fn(
            self: *const ITextHost,
            hcur: HCURSOR,
            fText: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxScreenToClient: fn(
            self: *const ITextHost,
            lppt: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxClientToScreen: fn(
            self: *const ITextHost,
            lppt: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxActivate: fn(
            self: *const ITextHost,
            plOldState: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDeactivate: fn(
            self: *const ITextHost,
            lNewState: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetClientRect: fn(
            self: *const ITextHost,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetViewInset: fn(
            self: *const ITextHost,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetCharFormat: fn(
            self: *const ITextHost,
            ppCF: *const *const CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetParaFormat: fn(
            self: *const ITextHost,
            ppPF: *const *const PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetSysColor: fn(
            self: *const ITextHost,
            nIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) u32,
        TxGetBackStyle: fn(
            self: *const ITextHost,
            pstyle: *TXTBACKSTYLE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetMaxLength: fn(
            self: *const ITextHost,
            plength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetScrollBars: fn(
            self: *const ITextHost,
            pdwScrollBar: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPasswordChar: fn(
            self: *const ITextHost,
            pch: *i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetAcceleratorPos: fn(
            self: *const ITextHost,
            pcp: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetExtent: fn(
            self: *const ITextHost,
            lpExtent: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxCharFormatChange: fn(
            self: *const ITextHost,
            pCF: *const CHARFORMATW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnTxParaFormatChange: fn(
            self: *const ITextHost,
            pPF: *const PARAFORMAT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPropertyBits: fn(
            self: *const ITextHost,
            dwMask: u32,
            pdwBits: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxNotify: fn(
            self: *const ITextHost,
            iNotify: u32,
            pv: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxImmGetContext: fn(
            self: *const ITextHost,
        ) callconv(@import("std").os.windows.WINAPI) *HIMC__,
        TxImmReleaseContext: fn(
            self: *const ITextHost,
            himc: *HIMC__,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetSelectionBarWidth: fn(
            self: *const ITextHost,
            lSelBarWidth: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetDC(self: *const T) callconv(.Inline) HDC {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetDC(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxReleaseDC(self: *const T, hdc: HDC) callconv(.Inline) i32 {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxReleaseDC(@ptrCast(*const ITextHost, self), hdc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxShowScrollBar(self: *const T, fnBar: i32, fShow: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxShowScrollBar(@ptrCast(*const ITextHost, self), fnBar, fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxEnableScrollBar(self: *const T, fuSBFlags: i32, fuArrowflags: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxEnableScrollBar(@ptrCast(*const ITextHost, self), fuSBFlags, fuArrowflags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetScrollRange(self: *const T, fnBar: i32, nMinPos: i32, nMaxPos: i32, fRedraw: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetScrollRange(@ptrCast(*const ITextHost, self), fnBar, nMinPos, nMaxPos, fRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetScrollPos(self: *const T, fnBar: i32, nPos: i32, fRedraw: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetScrollPos(@ptrCast(*const ITextHost, self), fnBar, nPos, fRedraw);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxInvalidateRect(self: *const T, prc: *RECT, fMode: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxInvalidateRect(@ptrCast(*const ITextHost, self), prc, fMode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxViewChange(self: *const T, fUpdate: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxViewChange(@ptrCast(*const ITextHost, self), fUpdate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxCreateCaret(self: *const T, hbmp: HBITMAP, xWidth: i32, yHeight: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxCreateCaret(@ptrCast(*const ITextHost, self), hbmp, xWidth, yHeight);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxShowCaret(self: *const T, fShow: BOOL) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxShowCaret(@ptrCast(*const ITextHost, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCaretPos(self: *const T, x: i32, y: i32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCaretPos(@ptrCast(*const ITextHost, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetTimer(self: *const T, idTimer: u32, uTimeout: u32) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetTimer(@ptrCast(*const ITextHost, self), idTimer, uTimeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxKillTimer(self: *const T, idTimer: u32) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxKillTimer(@ptrCast(*const ITextHost, self), idTimer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxScrollWindowEx(self: *const T, dx: i32, dy: i32, lprcScroll: *RECT, lprcClip: *RECT, hrgnUpdate: HRGN, lprcUpdate: *RECT, fuScroll: u32) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxScrollWindowEx(@ptrCast(*const ITextHost, self), dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate, fuScroll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCapture(self: *const T, fCapture: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCapture(@ptrCast(*const ITextHost, self), fCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetFocus(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetFocus(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxSetCursor(self: *const T, hcur: HCURSOR, fText: BOOL) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxSetCursor(@ptrCast(*const ITextHost, self), hcur, fText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxScreenToClient(self: *const T, lppt: *POINT) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxScreenToClient(@ptrCast(*const ITextHost, self), lppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxClientToScreen(self: *const T, lppt: *POINT) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxClientToScreen(@ptrCast(*const ITextHost, self), lppt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxActivate(self: *const T, plOldState: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxActivate(@ptrCast(*const ITextHost, self), plOldState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxDeactivate(self: *const T, lNewState: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxDeactivate(@ptrCast(*const ITextHost, self), lNewState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetClientRect(self: *const T, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetClientRect(@ptrCast(*const ITextHost, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetViewInset(self: *const T, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetViewInset(@ptrCast(*const ITextHost, self), prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetCharFormat(self: *const T, ppCF: *const *const CHARFORMATW) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetCharFormat(@ptrCast(*const ITextHost, self), ppCF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetParaFormat(self: *const T, ppPF: *const *const PARAFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetParaFormat(@ptrCast(*const ITextHost, self), ppPF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetSysColor(self: *const T, nIndex: i32) callconv(.Inline) u32 {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetSysColor(@ptrCast(*const ITextHost, self), nIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetBackStyle(self: *const T, pstyle: *TXTBACKSTYLE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetBackStyle(@ptrCast(*const ITextHost, self), pstyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetMaxLength(self: *const T, plength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetMaxLength(@ptrCast(*const ITextHost, self), plength);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetScrollBars(self: *const T, pdwScrollBar: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetScrollBars(@ptrCast(*const ITextHost, self), pdwScrollBar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetPasswordChar(self: *const T, pch: *i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetPasswordChar(@ptrCast(*const ITextHost, self), pch);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetAcceleratorPos(self: *const T, pcp: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetAcceleratorPos(@ptrCast(*const ITextHost, self), pcp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetExtent(self: *const T, lpExtent: *SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetExtent(@ptrCast(*const ITextHost, self), lpExtent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_OnTxCharFormatChange(self: *const T, pCF: *const CHARFORMATW) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).OnTxCharFormatChange(@ptrCast(*const ITextHost, self), pCF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_OnTxParaFormatChange(self: *const T, pPF: *const PARAFORMAT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).OnTxParaFormatChange(@ptrCast(*const ITextHost, self), pPF);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetPropertyBits(self: *const T, dwMask: u32, pdwBits: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetPropertyBits(@ptrCast(*const ITextHost, self), dwMask, pdwBits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxNotify(self: *const T, iNotify: u32, pv: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxNotify(@ptrCast(*const ITextHost, self), iNotify, pv);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxImmGetContext(self: *const T) callconv(.Inline) *HIMC__ {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxImmGetContext(@ptrCast(*const ITextHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxImmReleaseContext(self: *const T, himc: *HIMC__) callconv(.Inline) void {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxImmReleaseContext(@ptrCast(*const ITextHost, self), himc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost_TxGetSelectionBarWidth(self: *const T, lSelBarWidth: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost.VTable, self.vtable).TxGetSelectionBarWidth(@ptrCast(*const ITextHost, self), lSelBarWidth);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IRicheditWindowlessAccessibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateProvider: fn(
            self: *const IRicheditWindowlessAccessibility,
            pSite: *IRawElementProviderWindowlessSite,
            ppProvider: **IRawElementProviderSimple,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRicheditWindowlessAccessibility_CreateProvider(self: *const T, pSite: *IRawElementProviderWindowlessSite, ppProvider: **IRawElementProviderSimple) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRicheditWindowlessAccessibility.VTable, self.vtable).CreateProvider(@ptrCast(*const IRicheditWindowlessAccessibility, self), pSite, ppProvider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IRichEditUiaInformation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBoundaryRectangle: fn(
            self: *const IRichEditUiaInformation,
            pUiaRect: *UiaRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVisible: fn(
            self: *const IRichEditUiaInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditUiaInformation_GetBoundaryRectangle(self: *const T, pUiaRect: *UiaRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditUiaInformation.VTable, self.vtable).GetBoundaryRectangle(@ptrCast(*const IRichEditUiaInformation, self), pUiaRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRichEditUiaInformation_IsVisible(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRichEditUiaInformation.VTable, self.vtable).IsVisible(@ptrCast(*const IRichEditUiaInformation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const IRicheditUiaOverrides = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyOverrideValue: fn(
            self: *const IRicheditUiaOverrides,
            propertyId: i32,
            pRetValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRicheditUiaOverrides_GetPropertyOverrideValue(self: *const T, propertyId: i32, pRetValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRicheditUiaOverrides.VTable, self.vtable).GetPropertyOverrideValue(@ptrCast(*const IRicheditUiaOverrides, self), propertyId, pRetValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PCreateTextServices = fn(
    punkOuter: *IUnknown,
    pITextHost: *ITextHost,
    ppUnk: **IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PShutdownTextServices = fn(
    pTextServices: *IUnknown,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const ITextHost2 = extern struct {
    pub const VTable = extern struct {
        base: ITextHost.VTable,
        TxIsDoubleClickPending: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        TxGetWindow: fn(
            self: *const ITextHost2,
            phwnd: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetForegroundWindow: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetPalette: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HPALETTE,
        TxGetEastAsianFlags: fn(
            self: *const ITextHost2,
            pFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxSetCursor2: fn(
            self: *const ITextHost2,
            hcur: HCURSOR,
            bText: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HCURSOR,
        TxFreeTextServicesNotification: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) void,
        TxGetEditStyle: fn(
            self: *const ITextHost2,
            dwItem: u32,
            pdwData: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetWindowStyles: fn(
            self: *const ITextHost2,
            pdwStyle: *u32,
            pdwExStyle: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxShowDropCaret: fn(
            self: *const ITextHost2,
            fShow: BOOL,
            hdc: HDC,
            prc: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDestroyCaret: fn(
            self: *const ITextHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxGetHorzExtent: fn(
            self: *const ITextHost2,
            plHorzExtent: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextHost.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxIsDoubleClickPending(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxIsDoubleClickPending(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetWindow(self: *const T, phwnd: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetWindow(@ptrCast(*const ITextHost2, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxSetForegroundWindow(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxSetForegroundWindow(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetPalette(self: *const T) callconv(.Inline) HPALETTE {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetPalette(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetEastAsianFlags(self: *const T, pFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetEastAsianFlags(@ptrCast(*const ITextHost2, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxSetCursor2(self: *const T, hcur: HCURSOR, bText: BOOL) callconv(.Inline) HCURSOR {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxSetCursor2(@ptrCast(*const ITextHost2, self), hcur, bText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxFreeTextServicesNotification(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxFreeTextServicesNotification(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetEditStyle(self: *const T, dwItem: u32, pdwData: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetEditStyle(@ptrCast(*const ITextHost2, self), dwItem, pdwData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetWindowStyles(self: *const T, pdwStyle: *u32, pdwExStyle: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetWindowStyles(@ptrCast(*const ITextHost2, self), pdwStyle, pdwExStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxShowDropCaret(self: *const T, fShow: BOOL, hdc: HDC, prc: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxShowDropCaret(@ptrCast(*const ITextHost2, self), fShow, hdc, prc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxDestroyCaret(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxDestroyCaret(@ptrCast(*const ITextHost2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextHost2_TxGetHorzExtent(self: *const T, plHorzExtent: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextHost2.VTable, self.vtable).TxGetHorzExtent(@ptrCast(*const ITextHost2, self), plHorzExtent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ITextServices2 = extern struct {
    pub const VTable = extern struct {
        base: ITextServices.VTable,
        TxGetNaturalSize2: fn(
            self: *const ITextServices2,
            dwAspect: u32,
            hdcDraw: HDC,
            hicTargetDev: HDC,
            ptd: *DVTARGETDEVICE,
            dwMode: u32,
            psizelExtent: *const SIZE,
            pwidth: *i32,
            pheight: *i32,
            pascent: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TxDrawD2D: fn(
            self: *const ITextServices2,
            pRenderTarget: *ID2D1RenderTarget,
            lprcBounds: *RECTL,
            lprcUpdate: *RECT,
            lViewId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITextServices.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices2_TxGetNaturalSize2(self: *const T, dwAspect: u32, hdcDraw: HDC, hicTargetDev: HDC, ptd: *DVTARGETDEVICE, dwMode: u32, psizelExtent: *const SIZE, pwidth: *i32, pheight: *i32, pascent: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices2.VTable, self.vtable).TxGetNaturalSize2(@ptrCast(*const ITextServices2, self), dwAspect, hdcDraw, hicTargetDev, ptd, dwMode, psizelExtent, pwidth, pheight, pascent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITextServices2_TxDrawD2D(self: *const T, pRenderTarget: *ID2D1RenderTarget, lprcBounds: *RECTL, lprcUpdate: *RECT, lViewId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITextServices2.VTable, self.vtable).TxDrawD2D(@ptrCast(*const ITextServices2, self), pRenderTarget, lprcBounds, lprcUpdate, lViewId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const TA_PROPERTY = extern enum(i32) {
    TAP_FLAGS = 0,
    TAP_TRANSFORMCOUNT = 1,
    TAP_STAGGERDELAY = 2,
    TAP_STAGGERDELAYCAP = 3,
    TAP_STAGGERDELAYFACTOR = 4,
    TAP_ZORDER = 5,
};
pub const TAP_FLAGS = TA_PROPERTY.TAP_FLAGS;
pub const TAP_TRANSFORMCOUNT = TA_PROPERTY.TAP_TRANSFORMCOUNT;
pub const TAP_STAGGERDELAY = TA_PROPERTY.TAP_STAGGERDELAY;
pub const TAP_STAGGERDELAYCAP = TA_PROPERTY.TAP_STAGGERDELAYCAP;
pub const TAP_STAGGERDELAYFACTOR = TA_PROPERTY.TAP_STAGGERDELAYFACTOR;
pub const TAP_ZORDER = TA_PROPERTY.TAP_ZORDER;

pub const TA_PROPERTY_FLAG = extern enum(i32) {
    TAPF_NONE = 0,
    TAPF_HASSTAGGER = 1,
    TAPF_ISRTLAWARE = 2,
    TAPF_ALLOWCOLLECTION = 4,
    TAPF_HASBACKGROUND = 8,
    TAPF_HASPERSPECTIVE = 16,
};
pub const TAPF_NONE = TA_PROPERTY_FLAG.TAPF_NONE;
pub const TAPF_HASSTAGGER = TA_PROPERTY_FLAG.TAPF_HASSTAGGER;
pub const TAPF_ISRTLAWARE = TA_PROPERTY_FLAG.TAPF_ISRTLAWARE;
pub const TAPF_ALLOWCOLLECTION = TA_PROPERTY_FLAG.TAPF_ALLOWCOLLECTION;
pub const TAPF_HASBACKGROUND = TA_PROPERTY_FLAG.TAPF_HASBACKGROUND;
pub const TAPF_HASPERSPECTIVE = TA_PROPERTY_FLAG.TAPF_HASPERSPECTIVE;

pub const TA_TRANSFORM_TYPE = extern enum(i32) {
    TATT_TRANSLATE_2D = 0,
    TATT_SCALE_2D = 1,
    TATT_OPACITY = 2,
    TATT_CLIP = 3,
};
pub const TATT_TRANSLATE_2D = TA_TRANSFORM_TYPE.TATT_TRANSLATE_2D;
pub const TATT_SCALE_2D = TA_TRANSFORM_TYPE.TATT_SCALE_2D;
pub const TATT_OPACITY = TA_TRANSFORM_TYPE.TATT_OPACITY;
pub const TATT_CLIP = TA_TRANSFORM_TYPE.TATT_CLIP;

pub const TA_TRANSFORM_FLAG = extern enum(i32) {
    TATF_NONE = 0,
    TATF_TARGETVALUES_USER = 1,
    TATF_HASINITIALVALUES = 2,
    TATF_HASORIGINVALUES = 4,
};
pub const TATF_NONE = TA_TRANSFORM_FLAG.TATF_NONE;
pub const TATF_TARGETVALUES_USER = TA_TRANSFORM_FLAG.TATF_TARGETVALUES_USER;
pub const TATF_HASINITIALVALUES = TA_TRANSFORM_FLAG.TATF_HASINITIALVALUES;
pub const TATF_HASORIGINVALUES = TA_TRANSFORM_FLAG.TATF_HASORIGINVALUES;

pub const TA_TRANSFORM = extern struct {
    eTransformType: TA_TRANSFORM_TYPE,
    dwTimingFunctionId: u32,
    dwStartTime: u32,
    dwDurationTime: u32,
    eFlags: TA_TRANSFORM_FLAG,
};

pub const TA_TRANSFORM_2D = extern struct {
    header: TA_TRANSFORM,
    rX: f32,
    rY: f32,
    rInitialX: f32,
    rInitialY: f32,
    rOriginX: f32,
    rOriginY: f32,
};

pub const TA_TRANSFORM_OPACITY = extern struct {
    header: TA_TRANSFORM,
    rOpacity: f32,
    rInitialOpacity: f32,
};

pub const TA_TRANSFORM_CLIP = extern struct {
    header: TA_TRANSFORM,
    rLeft: f32,
    rTop: f32,
    rRight: f32,
    rBottom: f32,
    rInitialLeft: f32,
    rInitialTop: f32,
    rInitialRight: f32,
    rInitialBottom: f32,
};

pub const TA_TIMINGFUNCTION_TYPE = extern enum(i32) {
    TTFT_UNDEFINED = 0,
    TTFT_CUBIC_BEZIER = 1,
};
pub const TTFT_UNDEFINED = TA_TIMINGFUNCTION_TYPE.TTFT_UNDEFINED;
pub const TTFT_CUBIC_BEZIER = TA_TIMINGFUNCTION_TYPE.TTFT_CUBIC_BEZIER;

pub const TA_TIMINGFUNCTION = extern struct {
    eTimingFunctionType: TA_TIMINGFUNCTION_TYPE,
};

pub const TA_CUBIC_BEZIER = extern struct {
    header: TA_TIMINGFUNCTION,
    rX0: f32,
    rY0: f32,
    rX1: f32,
    rY1: f32,
};

pub const DTBGOPTS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    rcClip: RECT,
};

pub const THEMESIZE = extern enum(i32) {
    TS_MIN = 0,
    TS_TRUE = 1,
    TS_DRAW = 2,
};
pub const TS_MIN = THEMESIZE.TS_MIN;
pub const TS_TRUE = THEMESIZE.TS_TRUE;
pub const TS_DRAW = THEMESIZE.TS_DRAW;

pub const MARGINS = extern struct {
    cxLeftWidth: i32,
    cxRightWidth: i32,
    cyTopHeight: i32,
    cyBottomHeight: i32,
};

pub const INTLIST = extern struct {
    iValueCount: i32,
    iValues: [402]i32,
};

pub const PROPERTYORIGIN = extern enum(i32) {
    PO_STATE = 0,
    PO_PART = 1,
    PO_CLASS = 2,
    PO_GLOBAL = 3,
    PO_NOTFOUND = 4,
};
pub const PO_STATE = PROPERTYORIGIN.PO_STATE;
pub const PO_PART = PROPERTYORIGIN.PO_PART;
pub const PO_CLASS = PROPERTYORIGIN.PO_CLASS;
pub const PO_GLOBAL = PROPERTYORIGIN.PO_GLOBAL;
pub const PO_NOTFOUND = PROPERTYORIGIN.PO_NOTFOUND;

pub const WINDOWTHEMEATTRIBUTETYPE = extern enum(i32) {
    WTA_NONCLIENT = 1,
};
pub const WTA_NONCLIENT = WINDOWTHEMEATTRIBUTETYPE.WTA_NONCLIENT;

pub const WTA_OPTIONS = extern struct {
    dwFlags: u32,
    dwMask: u32,
};

pub const DTT_CALLBACK_PROC = fn(
    hdc: HDC,
    pszText: [*:0]u16,
    cchText: i32,
    prc: *RECT,
    dwFlags: u32,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const DTTOPTS = extern struct {
    dwSize: u32,
    dwFlags: u32,
    crText: u32,
    crBorder: u32,
    crShadow: u32,
    iTextShadowType: i32,
    ptShadowOffset: POINT,
    iBorderSize: i32,
    iFontPropId: i32,
    iColorPropId: i32,
    iStateId: i32,
    fApplyOverlay: BOOL,
    iGlowSize: i32,
    pfnDrawTextCallback: DTT_CALLBACK_PROC,
    lParam: LPARAM,
};

pub const BP_BUFFERFORMAT = extern enum(i32) {
    BPBF_COMPATIBLEBITMAP = 0,
    BPBF_DIB = 1,
    BPBF_TOPDOWNDIB = 2,
    BPBF_TOPDOWNMONODIB = 3,
};
pub const BPBF_COMPATIBLEBITMAP = BP_BUFFERFORMAT.BPBF_COMPATIBLEBITMAP;
pub const BPBF_DIB = BP_BUFFERFORMAT.BPBF_DIB;
pub const BPBF_TOPDOWNDIB = BP_BUFFERFORMAT.BPBF_TOPDOWNDIB;
pub const BPBF_TOPDOWNMONODIB = BP_BUFFERFORMAT.BPBF_TOPDOWNMONODIB;

pub const BP_ANIMATIONSTYLE = extern enum(i32) {
    BPAS_NONE = 0,
    BPAS_LINEAR = 1,
    BPAS_CUBIC = 2,
    BPAS_SINE = 3,
};
pub const BPAS_NONE = BP_ANIMATIONSTYLE.BPAS_NONE;
pub const BPAS_LINEAR = BP_ANIMATIONSTYLE.BPAS_LINEAR;
pub const BPAS_CUBIC = BP_ANIMATIONSTYLE.BPAS_CUBIC;
pub const BPAS_SINE = BP_ANIMATIONSTYLE.BPAS_SINE;

pub const BP_ANIMATIONPARAMS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    style: BP_ANIMATIONSTYLE,
    dwDuration: u32,
};

pub const BP_PAINTPARAMS = extern struct {
    cbSize: u32,
    dwFlags: u32,
    prcExclude: *const RECT,
    pBlendFunction: *const BLENDFUNCTION,
};

pub const EDITWORDBREAKPROCA = fn(
    lpch: PSTR,
    ichCurrent: i32,
    cch: i32,
    code: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const EDITWORDBREAKPROCW = fn(
    lpch: PWSTR,
    ichCurrent: i32,
    cch: i32,
    code: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const NMHDR = extern struct {
    hwndFrom: HWND,
    idFrom: ?*c_void,
    code: u32,
};

pub const MEASUREITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    itemID: u32,
    itemWidth: u32,
    itemHeight: u32,
    itemData: ?*c_void,
};

pub const DRAWITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    itemID: u32,
    itemAction: u32,
    itemState: u32,
    hwndItem: HWND,
    hDC: HDC,
    rcItem: RECT,
    itemData: ?*c_void,
};

pub const DELETEITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    itemID: u32,
    hwndItem: HWND,
    itemData: ?*c_void,
};

pub const COMPAREITEMSTRUCT = extern struct {
    CtlType: u32,
    CtlID: u32,
    hwndItem: HWND,
    itemID1: u32,
    itemData1: ?*c_void,
    itemID2: u32,
    itemData2: ?*c_void,
    dwLocaleId: u32,
};

pub const POINTER_FEEDBACK_MODE = extern enum(i32) {
    POINTER_FEEDBACK_DEFAULT = 1,
    POINTER_FEEDBACK_INDIRECT = 2,
    POINTER_FEEDBACK_NONE = 3,
};
pub const POINTER_FEEDBACK_DEFAULT = POINTER_FEEDBACK_MODE.POINTER_FEEDBACK_DEFAULT;
pub const POINTER_FEEDBACK_INDIRECT = POINTER_FEEDBACK_MODE.POINTER_FEEDBACK_INDIRECT;
pub const POINTER_FEEDBACK_NONE = POINTER_FEEDBACK_MODE.POINTER_FEEDBACK_NONE;

pub const USAGE_PROPERTIES = extern struct {
    level: u16,
    page: u16,
    usage: u16,
    logicalMinimum: i32,
    logicalMaximum: i32,
    unit: u16,
    exponent: u16,
    count: u8,
    physicalMinimum: i32,
    physicalMaximum: i32,
};

pub const POINTER_TYPE_INFO = extern struct {
    type: POINTER_INPUT_TYPE,
    Anonymous: POINTER_TYPE_INFO._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const INPUT_INJECTION_VALUE = extern struct {
    page: u16,
    usage: u16,
    value: i32,
    index: u16,
};

pub const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION = extern struct {
    score: u16,
    adjustedPoint: POINT,
};

pub const TOUCH_HIT_TESTING_INPUT = extern struct {
    pointerId: u32,
    point: POINT,
    boundingBox: RECT,
    nonOccludedBoundingBox: RECT,
    orientation: u32,
};

pub const FEEDBACK_TYPE = extern enum(i32) {
    FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1,
    FEEDBACK_PEN_BARRELVISUALIZATION = 2,
    FEEDBACK_PEN_TAP = 3,
    FEEDBACK_PEN_DOUBLETAP = 4,
    FEEDBACK_PEN_PRESSANDHOLD = 5,
    FEEDBACK_PEN_RIGHTTAP = 6,
    FEEDBACK_TOUCH_TAP = 7,
    FEEDBACK_TOUCH_DOUBLETAP = 8,
    FEEDBACK_TOUCH_PRESSANDHOLD = 9,
    FEEDBACK_TOUCH_RIGHTTAP = 10,
    FEEDBACK_GESTURE_PRESSANDTAP = 11,
    FEEDBACK_MAX = -1,
};
pub const FEEDBACK_TOUCH_CONTACTVISUALIZATION = FEEDBACK_TYPE.FEEDBACK_TOUCH_CONTACTVISUALIZATION;
pub const FEEDBACK_PEN_BARRELVISUALIZATION = FEEDBACK_TYPE.FEEDBACK_PEN_BARRELVISUALIZATION;
pub const FEEDBACK_PEN_TAP = FEEDBACK_TYPE.FEEDBACK_PEN_TAP;
pub const FEEDBACK_PEN_DOUBLETAP = FEEDBACK_TYPE.FEEDBACK_PEN_DOUBLETAP;
pub const FEEDBACK_PEN_PRESSANDHOLD = FEEDBACK_TYPE.FEEDBACK_PEN_PRESSANDHOLD;
pub const FEEDBACK_PEN_RIGHTTAP = FEEDBACK_TYPE.FEEDBACK_PEN_RIGHTTAP;
pub const FEEDBACK_TOUCH_TAP = FEEDBACK_TYPE.FEEDBACK_TOUCH_TAP;
pub const FEEDBACK_TOUCH_DOUBLETAP = FEEDBACK_TYPE.FEEDBACK_TOUCH_DOUBLETAP;
pub const FEEDBACK_TOUCH_PRESSANDHOLD = FEEDBACK_TYPE.FEEDBACK_TOUCH_PRESSANDHOLD;
pub const FEEDBACK_TOUCH_RIGHTTAP = FEEDBACK_TYPE.FEEDBACK_TOUCH_RIGHTTAP;
pub const FEEDBACK_GESTURE_PRESSANDTAP = FEEDBACK_TYPE.FEEDBACK_GESTURE_PRESSANDTAP;
pub const FEEDBACK_MAX = FEEDBACK_TYPE.FEEDBACK_MAX;

pub const SCROLLINFO = extern struct {
    cbSize: u32,
    fMask: u32,
    nMin: i32,
    nMax: i32,
    nPage: u32,
    nPos: i32,
    nTrackPos: i32,
};

pub const SCROLLBARINFO = extern struct {
    cbSize: u32,
    rcScrollBar: RECT,
    dxyLineButton: i32,
    xyThumbTop: i32,
    xyThumbBottom: i32,
    reserved: i32,
    rgstate: [6]u32,
};

pub const COMBOBOXINFO = extern struct {
    cbSize: u32,
    rcItem: RECT,
    rcButton: RECT,
    stateButton: u32,
    hwndCombo: HWND,
    hwndItem: HWND,
    hwndList: HWND,
};

pub const POINTER_DEVICE_TYPE = extern enum(i32) {
    INTEGRATED_PEN = 1,
    EXTERNAL_PEN = 2,
    TOUCH = 3,
    TOUCH_PAD = 4,
    MAX = -1,
};
pub const POINTER_DEVICE_TYPE_INTEGRATED_PEN = POINTER_DEVICE_TYPE.INTEGRATED_PEN;
pub const POINTER_DEVICE_TYPE_EXTERNAL_PEN = POINTER_DEVICE_TYPE.EXTERNAL_PEN;
pub const POINTER_DEVICE_TYPE_TOUCH = POINTER_DEVICE_TYPE.TOUCH;
pub const POINTER_DEVICE_TYPE_TOUCH_PAD = POINTER_DEVICE_TYPE.TOUCH_PAD;
pub const POINTER_DEVICE_TYPE_MAX = POINTER_DEVICE_TYPE.MAX;

pub const POINTER_DEVICE_INFO = extern struct {
    displayOrientation: u32,
    device: HANDLE,
    pointerDeviceType: POINTER_DEVICE_TYPE,
    monitor: HMONITOR,
    startingCursorId: u32,
    maxActiveContacts: u16,
    productString: [520]u16,
};

pub const POINTER_DEVICE_PROPERTY = extern struct {
    logicalMin: i32,
    logicalMax: i32,
    physicalMin: i32,
    physicalMax: i32,
    unit: u32,
    unitExponent: u32,
    usagePageId: u16,
    usageId: u16,
};

pub const POINTER_DEVICE_CURSOR_TYPE = extern enum(i32) {
    UNKNOWN = 0,
    TIP = 1,
    ERASER = 2,
    MAX = -1,
};
pub const POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = POINTER_DEVICE_CURSOR_TYPE.UNKNOWN;
pub const POINTER_DEVICE_CURSOR_TYPE_TIP = POINTER_DEVICE_CURSOR_TYPE.TIP;
pub const POINTER_DEVICE_CURSOR_TYPE_ERASER = POINTER_DEVICE_CURSOR_TYPE.ERASER;
pub const POINTER_DEVICE_CURSOR_TYPE_MAX = POINTER_DEVICE_CURSOR_TYPE.MAX;

pub const POINTER_DEVICE_CURSOR_INFO = extern struct {
    cursorId: u32,
    cursor: POINTER_DEVICE_CURSOR_TYPE,
};

pub const INPUT_MESSAGE_DEVICE_TYPE = extern enum(i32) {
    IMDT_UNAVAILABLE = 0,
    IMDT_KEYBOARD = 1,
    IMDT_MOUSE = 2,
    IMDT_TOUCH = 4,
    IMDT_PEN = 8,
    IMDT_TOUCHPAD = 16,
};
pub const IMDT_UNAVAILABLE = INPUT_MESSAGE_DEVICE_TYPE.IMDT_UNAVAILABLE;
pub const IMDT_KEYBOARD = INPUT_MESSAGE_DEVICE_TYPE.IMDT_KEYBOARD;
pub const IMDT_MOUSE = INPUT_MESSAGE_DEVICE_TYPE.IMDT_MOUSE;
pub const IMDT_TOUCH = INPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCH;
pub const IMDT_PEN = INPUT_MESSAGE_DEVICE_TYPE.IMDT_PEN;
pub const IMDT_TOUCHPAD = INPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCHPAD;

pub const INPUT_MESSAGE_ORIGIN_ID = extern enum(i32) {
    IMO_UNAVAILABLE = 0,
    IMO_HARDWARE = 1,
    IMO_INJECTED = 2,
    IMO_SYSTEM = 4,
};
pub const IMO_UNAVAILABLE = INPUT_MESSAGE_ORIGIN_ID.IMO_UNAVAILABLE;
pub const IMO_HARDWARE = INPUT_MESSAGE_ORIGIN_ID.IMO_HARDWARE;
pub const IMO_INJECTED = INPUT_MESSAGE_ORIGIN_ID.IMO_INJECTED;
pub const IMO_SYSTEM = INPUT_MESSAGE_ORIGIN_ID.IMO_SYSTEM;

pub const INPUT_MESSAGE_SOURCE = extern struct {
    deviceType: INPUT_MESSAGE_DEVICE_TYPE,
    originId: INPUT_MESSAGE_ORIGIN_ID,
};

// TODO: this type has a FreeFunc 'ImageList_Destroy', what can Zig do with this information?
pub const HIMAGELIST = ?*c_void;

// TODO: this type has a FreeFunc 'DestroyPropertySheetPage', what can Zig do with this information?
pub const HPROPSHEETPAGE = ?*c_void;

pub const HSYNTHETICPOINTERDEVICE = ?*c_void;


//--------------------------------------------------------------------------------
// Section: Functions (229)
//--------------------------------------------------------------------------------
pub extern "COMCTL32" fn CreatePropertySheetPageA(
    constPropSheetPagePointer: *PROPSHEETPAGEA,
) callconv(@import("std").os.windows.WINAPI) HPROPSHEETPAGE;

pub extern "COMCTL32" fn CreatePropertySheetPageW(
    constPropSheetPagePointer: *PROPSHEETPAGEW,
) callconv(@import("std").os.windows.WINAPI) HPROPSHEETPAGE;

pub extern "COMCTL32" fn DestroyPropertySheetPage(
    param0: HPROPSHEETPAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn PropertySheetA(
    param0: *PROPSHEETHEADERA_V2,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "COMCTL32" fn PropertySheetW(
    param0: *PROPSHEETHEADERW_V2,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "COMCTL32" fn InitCommonControls(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn InitCommonControlsEx(
    picce: *const INITCOMMONCONTROLSEX,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_Create(
    cx: i32,
    cy: i32,
    flags: u32,
    cInitial: i32,
    cGrow: i32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

pub extern "COMCTL32" fn ImageList_Destroy(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_GetImageCount(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn ImageList_SetImageCount(
    himl: HIMAGELIST,
    uNewCount: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_Add(
    himl: HIMAGELIST,
    hbmImage: HBITMAP,
    hbmMask: HBITMAP,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn ImageList_ReplaceIcon(
    himl: HIMAGELIST,
    i: i32,
    hicon: HICON,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn ImageList_SetBkColor(
    himl: HIMAGELIST,
    clrBk: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "COMCTL32" fn ImageList_GetBkColor(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "COMCTL32" fn ImageList_SetOverlayImage(
    himl: HIMAGELIST,
    iImage: i32,
    iOverlay: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_Draw(
    himl: HIMAGELIST,
    i: i32,
    hdcDst: HDC,
    x: i32,
    y: i32,
    fStyle: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_Replace(
    himl: HIMAGELIST,
    i: i32,
    hbmImage: HBITMAP,
    hbmMask: HBITMAP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_AddMasked(
    himl: HIMAGELIST,
    hbmImage: HBITMAP,
    crMask: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn ImageList_DrawEx(
    himl: HIMAGELIST,
    i: i32,
    hdcDst: HDC,
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
    rgbBk: u32,
    rgbFg: u32,
    fStyle: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_DrawIndirect(
    pimldp: *IMAGELISTDRAWPARAMS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_Remove(
    himl: HIMAGELIST,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_GetIcon(
    himl: HIMAGELIST,
    i: i32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) HICON;

pub extern "COMCTL32" fn ImageList_LoadImageA(
    hi: HINSTANCE,
    lpbmp: [*:0]const u8,
    cx: i32,
    cGrow: i32,
    crMask: u32,
    uType: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

pub extern "COMCTL32" fn ImageList_LoadImageW(
    hi: HINSTANCE,
    lpbmp: [*:0]const u16,
    cx: i32,
    cGrow: i32,
    crMask: u32,
    uType: u32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

pub extern "COMCTL32" fn ImageList_Copy(
    himlDst: HIMAGELIST,
    iDst: i32,
    himlSrc: HIMAGELIST,
    iSrc: i32,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_BeginDrag(
    himlTrack: HIMAGELIST,
    iTrack: i32,
    dxHotspot: i32,
    dyHotspot: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_EndDrag(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn ImageList_DragEnter(
    hwndLock: HWND,
    x: i32,
    y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_DragLeave(
    hwndLock: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_DragMove(
    x: i32,
    y: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_SetDragCursorImage(
    himlDrag: HIMAGELIST,
    iDrag: i32,
    dxHotspot: i32,
    dyHotspot: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_DragShowNolock(
    fShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_GetDragImage(
    ppt: ?*POINT,
    pptHotspot: ?*POINT,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

pub extern "COMCTL32" fn ImageList_Read(
    pstm: *IStream,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

pub extern "COMCTL32" fn ImageList_Write(
    himl: HIMAGELIST,
    pstm: *IStream,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_ReadEx(
    dwFlags: u32,
    pstm: *IStream,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn ImageList_WriteEx(
    himl: HIMAGELIST,
    dwFlags: u32,
    pstm: *IStream,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn ImageList_GetIconSize(
    himl: HIMAGELIST,
    cx: ?*i32,
    cy: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_SetIconSize(
    himl: HIMAGELIST,
    cx: i32,
    cy: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_GetImageInfo(
    himl: HIMAGELIST,
    i: i32,
    pImageInfo: *IMAGEINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn ImageList_Merge(
    himl1: HIMAGELIST,
    i1: i32,
    himl2: HIMAGELIST,
    i2: i32,
    dx: i32,
    dy: i32,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

pub extern "COMCTL32" fn ImageList_Duplicate(
    himl: HIMAGELIST,
) callconv(@import("std").os.windows.WINAPI) HIMAGELIST;

pub extern "COMCTL32" fn HIMAGELIST_QueryInterface(
    himl: HIMAGELIST,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn CreateToolbarEx(
    hwnd: HWND,
    ws: u32,
    wID: u32,
    nBitmaps: i32,
    hBMInst: HINSTANCE,
    wBMID: ?*c_void,
    lpButtons: *TBBUTTON,
    iNumButtons: i32,
    dxButton: i32,
    dyButton: i32,
    dxBitmap: i32,
    dyBitmap: i32,
    uStructSize: u32,
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "COMCTL32" fn CreateMappedBitmap(
    hInstance: HINSTANCE,
    idBitmap: ?*c_void,
    wFlags: u32,
    lpColorMap: ?*COLORMAP,
    iNumMaps: i32,
) callconv(@import("std").os.windows.WINAPI) HBITMAP;

pub extern "COMCTL32" fn DrawStatusTextA(
    hDC: HDC,
    lprc: *RECT,
    pszText: [*:0]const u8,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn DrawStatusTextW(
    hDC: HDC,
    lprc: *RECT,
    pszText: [*:0]const u16,
    uFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn CreateStatusWindowA(
    style: i32,
    lpszText: [*:0]const u8,
    hwndParent: HWND,
    wID: u32,
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "COMCTL32" fn CreateStatusWindowW(
    style: i32,
    lpszText: [*:0]const u16,
    hwndParent: HWND,
    wID: u32,
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "COMCTL32" fn MenuHelp(
    uMsg: u32,
    wParam: WPARAM,
    lParam: LPARAM,
    hMainMenu: HMENU,
    hInst: HINSTANCE,
    hwndStatus: HWND,
    lpwIDs: *u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn ShowHideMenuCtl(
    hWnd: HWND,
    uFlags: ?*c_void,
    lpInfo: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn GetEffectiveClientRect(
    hWnd: HWND,
    lprc: *RECT,
    lpInfo: *const i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn MakeDragList(
    hLB: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DrawInsert(
    handParent: HWND,
    hLB: HWND,
    nItem: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn LBItemFromPt(
    hLB: HWND,
    pt: POINT,
    bAutoScroll: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn CreateUpDownControl(
    dwStyle: u32,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    hParent: HWND,
    nID: i32,
    hInst: HINSTANCE,
    hBuddy: HWND,
    nUpper: i32,
    nLower: i32,
    nPos: i32,
) callconv(@import("std").os.windows.WINAPI) HWND;

pub extern "COMCTL32" fn TaskDialogIndirect(
    pTaskConfig: *const TASKDIALOGCONFIG,
    pnButton: ?*i32,
    pnRadioButton: ?*i32,
    pfVerificationFlagChecked: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn TaskDialog(
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    pszWindowTitle: ?[*:0]const u16,
    pszMainInstruction: ?[*:0]const u16,
    pszContent: ?[*:0]const u16,
    dwCommonButtons: i32,
    pszIcon: ?[*:0]const u16,
    pnButton: ?*i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn InitMUILanguage(
    uiLang: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn GetMUILanguage(
) callconv(@import("std").os.windows.WINAPI) u16;

pub extern "COMCTL32" fn DSA_Create(
    cbItem: i32,
    cItemGrow: i32,
) callconv(@import("std").os.windows.WINAPI) *_DSA;

pub extern "COMCTL32" fn DSA_Destroy(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DSA_DestroyCallback(
    hdsa: ?*_DSA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn DSA_DeleteItem(
    hdsa: *_DSA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DSA_DeleteAllItems(
    hdsa: *_DSA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DSA_EnumCallback(
    hdsa: *_DSA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn DSA_InsertItem(
    hdsa: *_DSA,
    i: i32,
    pitem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn DSA_GetItemPtr(
    hdsa: *_DSA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "COMCTL32" fn DSA_GetItem(
    hdsa: *_DSA,
    i: i32,
    pitem: *c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DSA_SetItem(
    hdsa: *_DSA,
    i: i32,
    pitem: *const c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DSA_Clone(
    hdsa: *_DSA,
) callconv(@import("std").os.windows.WINAPI) *_DSA;

pub extern "COMCTL32" fn DSA_GetSize(
    hdsa: ?*_DSA,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "COMCTL32" fn DSA_Sort(
    pdsa: *_DSA,
    pfnCompare: PFNDACOMPARE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DPA_Create(
    cItemGrow: i32,
) callconv(@import("std").os.windows.WINAPI) *_DPA;

pub extern "COMCTL32" fn DPA_CreateEx(
    cpGrow: i32,
    hheap: HANDLE,
) callconv(@import("std").os.windows.WINAPI) *_DPA;

pub extern "COMCTL32" fn DPA_Clone(
    hdpa: *const _DPA,
    hdpaNew: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) *_DPA;

pub extern "COMCTL32" fn DPA_Destroy(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DPA_DestroyCallback(
    hdpa: ?*_DPA,
    pfnCB: PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn DPA_DeletePtr(
    hdpa: *_DPA,
    i: i32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "COMCTL32" fn DPA_DeleteAllPtrs(
    hdpa: *_DPA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DPA_EnumCallback(
    hdpa: ?*_DPA,
    pfnCB: ?PFNDAENUMCALLBACK,
    pData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "COMCTL32" fn DPA_Grow(
    pdpa: *_DPA,
    cp: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DPA_InsertPtr(
    hdpa: *_DPA,
    i: i32,
    p: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn DPA_SetPtr(
    hdpa: *_DPA,
    i: i32,
    p: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DPA_GetPtr(
    hdpa: *_DPA,
    i: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "COMCTL32" fn DPA_GetPtrIndex(
    hdpa: *_DPA,
    p: ?*const c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn DPA_GetSize(
    hdpa: ?*_DPA,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "COMCTL32" fn DPA_Sort(
    hdpa: *_DPA,
    pfnCompare: PFNDACOMPARE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DPA_LoadStream(
    phdpa: **_DPA,
    pfn: PFNDPASTREAM,
    pstream: *IStream,
    pvInstData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn DPA_SaveStream(
    hdpa: *_DPA,
    pfn: PFNDPASTREAM,
    pstream: *IStream,
    pvInstData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn DPA_Merge(
    hdpaDest: *_DPA,
    hdpaSrc: *_DPA,
    dwFlags: u32,
    pfnCompare: PFNDACOMPARE,
    pfnMerge: PFNDPAMERGE,
    lParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn DPA_Search(
    hdpa: *_DPA,
    pFind: ?*c_void,
    iStart: i32,
    pfnCompare: PFNDACOMPARE,
    lParam: LPARAM,
    options: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn Str_SetPtrW(
    ppsz: *PWSTR,
    psz: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn FlatSB_EnableScrollBar(
    param0: HWND,
    param1: i32,
    param2: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn FlatSB_ShowScrollBar(
    param0: HWND,
    code: i32,
    param2: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn FlatSB_GetScrollRange(
    param0: HWND,
    code: i32,
    param2: *i32,
    param3: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn FlatSB_GetScrollInfo(
    param0: HWND,
    code: i32,
    param2: *SCROLLINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn FlatSB_GetScrollPos(
    param0: HWND,
    code: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn FlatSB_GetScrollProp(
    param0: HWND,
    propIndex: i32,
    param2: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn FlatSB_SetScrollPos(
    param0: HWND,
    code: i32,
    pos: i32,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn FlatSB_SetScrollInfo(
    param0: HWND,
    code: i32,
    psi: *SCROLLINFO,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn FlatSB_SetScrollRange(
    param0: HWND,
    code: i32,
    min: i32,
    max: i32,
    fRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn FlatSB_SetScrollProp(
    param0: HWND,
    index: u32,
    newValue: ?*c_void,
    param3: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn InitializeFlatSB(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "COMCTL32" fn UninitializeFlatSB(
    param0: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn LoadIconMetric(
    hinst: HINSTANCE,
    pszName: [*:0]const u16,
    lims: i32,
    phico: *HICON,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn LoadIconWithScaleDown(
    hinst: HINSTANCE,
    pszName: [*:0]const u16,
    cx: i32,
    cy: i32,
    phico: *HICON,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "COMCTL32" fn DrawShadowText(
    hdc: HDC,
    pszText: [*:0]const u16,
    cch: u32,
    prc: *RECT,
    dwFlags: u32,
    crText: u32,
    crShadow: u32,
    ixOffset: i32,
    iyOffset: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "COMCTL32" fn ImageList_CoCreateInstance(
    rclsid: *const Guid,
    punkOuter: ?*IUnknown,
    riid: *const Guid,
    ppv: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeAnimationProperty(
    hTheme: ?*c_void,
    iStoryboardId: i32,
    iTargetId: i32,
    eProperty: TA_PROPERTY,
    pvProperty: ?[*]u8,
    cbSize: u32,
    pcbSizeOut: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeAnimationTransform(
    hTheme: ?*c_void,
    iStoryboardId: i32,
    iTargetId: i32,
    dwTransformIndex: u32,
    pTransform: ?[*]TA_TRANSFORM,
    cbSize: u32,
    pcbSizeOut: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeTimingFunction(
    hTheme: ?*c_void,
    iTimingFunctionId: i32,
    pTimingFunction: ?[*]TA_TIMINGFUNCTION,
    cbSize: u32,
    pcbSizeOut: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn OpenThemeData(
    hwnd: HWND,
    pszClassList: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "UXTHEME" fn OpenThemeDataEx(
    hwnd: HWND,
    pszClassList: [*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "UXTHEME" fn CloseThemeData(
    hTheme: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn DrawThemeBackground(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: *RECT,
    pClipRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn DrawThemeBackgroundEx(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: *RECT,
    pOptions: ?*const DTBGOPTS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn DrawThemeText(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: [*:0]const u16,
    cchText: i32,
    dwTextFlags: u32,
    dwTextFlags2: u32,
    pRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeBackgroundContentRect(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pBoundingRect: *RECT,
    pContentRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeBackgroundExtent(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pContentRect: *RECT,
    pExtentRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeBackgroundRegion(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: *RECT,
    pRegion: *HRGN,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemePartSize(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    prc: ?*RECT,
    eSize: THEMESIZE,
    psz: *SIZE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeTextExtent(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: [*:0]const u16,
    cchCharCount: i32,
    dwTextFlags: u32,
    pBoundingRect: ?*RECT,
    pExtentRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeTextMetrics(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    ptm: *TEXTMETRICW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn HitTestThemeBackground(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    dwOptions: u32,
    pRect: *RECT,
    hrgn: HRGN,
    ptTest: POINT,
    pwHitTestCode: *u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn DrawThemeEdge(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pDestRect: *RECT,
    uEdge: u32,
    uFlags: u32,
    pContentRect: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn DrawThemeIcon(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pRect: *RECT,
    himl: HIMAGELIST,
    iImageIndex: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn IsThemePartDefined(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UxTheme" fn IsThemeBackgroundPartiallyTransparent(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UXTHEME" fn GetThemeColor(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pColor: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeMetric(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeString(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pszBuff: [*:0]u16,
    cchMaxBuffChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeBool(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pfVal: *BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeInt(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeEnumValue(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    piVal: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemePosition(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pPoint: *POINT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeFont(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pFont: *LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeRect(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeMargins(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    prc: ?*RECT,
    pMargins: *MARGINS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeIntList(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pIntList: *INTLIST,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemePropertyOrigin(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pOrigin: *PROPERTYORIGIN,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn SetWindowTheme(
    hwnd: HWND,
    pszSubAppName: ?[*:0]const u16,
    pszSubIdList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeFilename(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    pszThemeFileName: [*:0]u16,
    cchMaxBuffChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeSysColor(
    hTheme: ?*c_void,
    iColorId: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "UxTheme" fn GetThemeSysColorBrush(
    hTheme: ?*c_void,
    iColorId: i32,
) callconv(@import("std").os.windows.WINAPI) HBRUSH;

pub extern "UxTheme" fn GetThemeSysBool(
    hTheme: ?*c_void,
    iBoolId: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UxTheme" fn GetThemeSysSize(
    hTheme: ?*c_void,
    iSizeId: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "UxTheme" fn GetThemeSysFont(
    hTheme: ?*c_void,
    iFontId: i32,
    plf: *LOGFONTW,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeSysString(
    hTheme: ?*c_void,
    iStringId: i32,
    pszStringBuff: [*:0]u16,
    cchMaxStringChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeSysInt(
    hTheme: ?*c_void,
    iIntId: i32,
    piValue: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn IsThemeActive(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UXTHEME" fn IsAppThemed(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UXTHEME" fn GetWindowTheme(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "UxTheme" fn EnableThemeDialogTexture(
    hwnd: HWND,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn IsThemeDialogTextureEnabled(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UXTHEME" fn GetThemeAppProperties(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "UxTheme" fn SetThemeAppProperties(
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "UXTHEME" fn GetCurrentThemeName(
    pszThemeFileName: [*:0]u16,
    cchMaxNameChars: i32,
    pszColorBuff: ?[*:0]u16,
    cchMaxColorChars: i32,
    pszSizeBuff: ?[*:0]u16,
    cchMaxSizeChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetThemeDocumentationProperty(
    pszThemeName: [*:0]const u16,
    pszPropertyName: [*:0]const u16,
    pszValueBuff: [*:0]u16,
    cchMaxValChars: i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn DrawThemeParentBackground(
    hwnd: HWND,
    hdc: HDC,
    prc: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn EnableTheming(
    fEnable: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn DrawThemeParentBackgroundEx(
    hwnd: HWND,
    hdc: HDC,
    dwFlags: u32,
    prc: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn SetWindowThemeAttribute(
    hwnd: HWND,
    eAttribute: WINDOWTHEMEATTRIBUTETYPE,
    pvAttribute: [*]u8,
    cbAttribute: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn DrawThemeTextEx(
    hTheme: ?*c_void,
    hdc: HDC,
    iPartId: i32,
    iStateId: i32,
    pszText: [*:0]const u16,
    cchText: i32,
    dwTextFlags: u32,
    pRect: *RECT,
    pOptions: ?*const DTTOPTS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeBitmap(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    dwFlags: u32,
    phBitmap: *HBITMAP,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn GetThemeStream(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateId: i32,
    iPropId: i32,
    ppvStream: **c_void,
    pcbStream: ?*u32,
    hInst: HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn BufferedPaintInit(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn BufferedPaintUnInit(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn BeginBufferedPaint(
    hdcTarget: HDC,
    prcTarget: *const RECT,
    dwFormat: BP_BUFFERFORMAT,
    pPaintParams: ?*BP_PAINTPARAMS,
    phdc: *HDC,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "UXTHEME" fn EndBufferedPaint(
    hBufferedPaint: ?*c_void,
    fUpdateTarget: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetBufferedPaintTargetRect(
    hBufferedPaint: ?*c_void,
    prc: *RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn GetBufferedPaintTargetDC(
    hBufferedPaint: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HDC;

pub extern "UxTheme" fn GetBufferedPaintDC(
    hBufferedPaint: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) HDC;

pub extern "UXTHEME" fn GetBufferedPaintBits(
    hBufferedPaint: ?*c_void,
    ppbBuffer: **RGBQUAD,
    pcxRow: *i32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn BufferedPaintClear(
    hBufferedPaint: ?*c_void,
    prc: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn BufferedPaintSetAlpha(
    hBufferedPaint: ?*c_void,
    prc: ?*const RECT,
    alpha: u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UXTHEME" fn BufferedPaintStopAllAnimations(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn BeginBufferedAnimation(
    hwnd: HWND,
    hdcTarget: HDC,
    prcTarget: *const RECT,
    dwFormat: BP_BUFFERFORMAT,
    pPaintParams: ?*BP_PAINTPARAMS,
    pAnimationParams: *BP_ANIMATIONPARAMS,
    phdcFrom: *HDC,
    phdcTo: *HDC,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "UxTheme" fn EndBufferedAnimation(
    hbpAnimation: ?*c_void,
    fUpdateTarget: BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "UxTheme" fn BufferedPaintRenderAnimation(
    hwnd: HWND,
    hdcTarget: HDC,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UXTHEME" fn IsCompositionActive(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "UxTheme" fn GetThemeTransitionDuration(
    hTheme: ?*c_void,
    iPartId: i32,
    iStateIdFrom: i32,
    iStateIdTo: i32,
    iPropId: i32,
    pdwDuration: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "USER32" fn CheckDlgButton(
    hDlg: HWND,
    nIDButton: i32,
    uCheck: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn CheckRadioButton(
    hDlg: HWND,
    nIDFirstButton: i32,
    nIDLastButton: i32,
    nIDCheckButton: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn IsDlgButtonChecked(
    hDlg: HWND,
    nIDButton: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "USER32" fn IsCharLowerW(
    ch: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn InitializeTouchInjection(
    maxCount: u32,
    dwMode: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn InjectTouchInput(
    count: u32,
    contacts: [*]const POINTER_TOUCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn CreateSyntheticPointerDevice(
    pointerType: POINTER_INPUT_TYPE,
    maxCount: u32,
    mode: POINTER_FEEDBACK_MODE,
) callconv(@import("std").os.windows.WINAPI) HSYNTHETICPOINTERDEVICE;

pub extern "USER32" fn InjectSyntheticPointerInput(
    device: HSYNTHETICPOINTERDEVICE,
    pointerInfo: [*]const POINTER_TYPE_INFO,
    count: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn DestroySyntheticPointerDevice(
    device: HSYNTHETICPOINTERDEVICE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "USER32" fn RegisterTouchHitTestingWindow(
    hwnd: HWND,
    value: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn EvaluateProximityToRect(
    controlBoundingBox: *const RECT,
    pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: *TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn EvaluateProximityToPolygon(
    numVertices: u32,
    controlPolygon: [*]const POINT,
    pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: *TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn PackTouchHitTestingProximityEvaluation(
    pHitTestingInput: *const TOUCH_HIT_TESTING_INPUT,
    pProximityEval: *const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION,
) callconv(@import("std").os.windows.WINAPI) LRESULT;

pub extern "USER32" fn GetWindowFeedbackSetting(
    hwnd: HWND,
    feedback: FEEDBACK_TYPE,
    dwFlags: u32,
    pSize: *u32,
    config: ?[*]u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn SetWindowFeedbackSetting(
    hwnd: HWND,
    feedback: FEEDBACK_TYPE,
    dwFlags: u32,
    size: u32,
    configuration: ?[*]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn ScrollWindow(
    hWnd: HWND,
    XAmount: i32,
    YAmount: i32,
    lpRect: ?*const RECT,
    lpClipRect: ?*const RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn ScrollDC(
    hDC: HDC,
    dx: i32,
    dy: i32,
    lprcScroll: ?*const RECT,
    lprcClip: ?*const RECT,
    hrgnUpdate: HRGN,
    lprcUpdate: ?*RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn ScrollWindowEx(
    hWnd: HWND,
    dx: i32,
    dy: i32,
    prcScroll: ?*const RECT,
    prcClip: ?*const RECT,
    hrgnUpdate: HRGN,
    prcUpdate: ?*RECT,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "USER32" fn SetScrollPos(
    hWnd: HWND,
    nBar: i32,
    nPos: i32,
    bRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "USER32" fn GetScrollPos(
    hWnd: HWND,
    nBar: i32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "USER32" fn SetScrollRange(
    hWnd: HWND,
    nBar: i32,
    nMinPos: i32,
    nMaxPos: i32,
    bRedraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetScrollRange(
    hWnd: HWND,
    nBar: i32,
    lpMinPos: *i32,
    lpMaxPos: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn ShowScrollBar(
    hWnd: HWND,
    wBar: i32,
    bShow: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn EnableScrollBar(
    hWnd: HWND,
    wSBflags: u32,
    wArrows: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn DlgDirListA(
    hDlg: HWND,
    lpPathSpec: PSTR,
    nIDListBox: i32,
    nIDStaticPath: i32,
    uFileType: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "USER32" fn DlgDirListW(
    hDlg: HWND,
    lpPathSpec: PWSTR,
    nIDListBox: i32,
    nIDStaticPath: i32,
    uFileType: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "USER32" fn DlgDirSelectExA(
    hwndDlg: HWND,
    lpString: [*:0]u8,
    chCount: i32,
    idListBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn DlgDirSelectExW(
    hwndDlg: HWND,
    lpString: [*:0]u16,
    chCount: i32,
    idListBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn DlgDirListComboBoxA(
    hDlg: HWND,
    lpPathSpec: PSTR,
    nIDComboBox: i32,
    nIDStaticPath: i32,
    uFiletype: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "USER32" fn DlgDirListComboBoxW(
    hDlg: HWND,
    lpPathSpec: PWSTR,
    nIDComboBox: i32,
    nIDStaticPath: i32,
    uFiletype: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "USER32" fn DlgDirSelectComboBoxExA(
    hwndDlg: HWND,
    lpString: [*:0]u8,
    cchOut: i32,
    idComboBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn DlgDirSelectComboBoxExW(
    hwndDlg: HWND,
    lpString: [*:0]u16,
    cchOut: i32,
    idComboBox: i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn SetScrollInfo(
    hwnd: HWND,
    nBar: i32,
    lpsi: *SCROLLINFO,
    redraw: BOOL,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "USER32" fn GetScrollInfo(
    hwnd: HWND,
    nBar: i32,
    lpsi: *SCROLLINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetScrollBarInfo(
    hwnd: HWND,
    idObject: i32,
    psbi: *SCROLLBARINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetComboBoxInfo(
    hwndCombo: HWND,
    pcbi: *COMBOBOXINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetListBoxInfo(
    hwnd: HWND,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "USER32" fn GetPointerDevices(
    deviceCount: *u32,
    pointerDevices: ?[*]POINTER_DEVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetPointerDevice(
    device: HANDLE,
    pointerDevice: *POINTER_DEVICE_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetPointerDeviceProperties(
    device: HANDLE,
    propertyCount: *u32,
    pointerProperties: ?[*]POINTER_DEVICE_PROPERTY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn RegisterPointerDeviceNotifications(
    window: HWND,
    notifyRange: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetPointerDeviceRects(
    device: HANDLE,
    pointerDeviceRect: *RECT,
    displayRect: *RECT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetPointerDeviceCursors(
    device: HANDLE,
    cursorCount: *u32,
    deviceCursors: ?[*]POINTER_DEVICE_CURSOR_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetRawPointerDeviceData(
    pointerId: u32,
    historyCount: u32,
    propertiesCount: u32,
    pProperties: [*]POINTER_DEVICE_PROPERTY,
    pValues: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetCurrentInputMessageSource(
    inputMessageSource: *INPUT_MESSAGE_SOURCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn GetCIMSSM(
    inputMessageSource: *INPUT_MESSAGE_SOURCE,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (54)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const LPFNPSPCALLBACK = LPFNPSPCALLBACKA;
        pub const PROPSHEETPAGE = PROPSHEETPAGEA;
        pub const HD_TEXTFILTER = HD_TEXTFILTERA;
        pub const HDITEM = HDITEMA;
        pub const NMHEADER = NMHEADERA;
        pub const NMHDDISPINFO = NMHDDISPINFOA;
        pub const TBSAVEPARAMS = TBSAVEPARAMSA;
        pub const TBBUTTONINFO = TBBUTTONINFOA;
        pub const NMTBGETINFOTIP = NMTBGETINFOTIPA;
        pub const NMTBDISPINFO = NMTBDISPINFOA;
        pub const NMTOOLBAR = NMTOOLBARA;
        pub const REBARBANDINFO = REBARBANDINFOA;
        pub const TTTOOLINFO = TTTOOLINFOA;
        pub const TTHITTESTINFO = TTHITTESTINFOA;
        pub const NMTTDISPINFO = NMTTDISPINFOA;
        pub const LVITEM = LVITEMA;
        pub const LVFINDINFO = LVFINDINFOA;
        pub const LVCOLUMN = LVCOLUMNA;
        pub const LVBKIMAGE = LVBKIMAGEA;
        pub const NMLVFINDITEM = NMLVFINDITEMA;
        pub const NMLVDISPINFO = NMLVDISPINFOA;
        pub const NMLVGETINFOTIP = NMLVGETINFOTIPA;
        pub const TVITEM = TVITEMA;
        pub const TVITEMEX = TVITEMEXA;
        pub const TVINSERTSTRUCT = TVINSERTSTRUCTA;
        pub const NMTREEVIEW = NMTREEVIEWA;
        pub const NMTVDISPINFO = NMTVDISPINFOA;
        pub const NMTVDISPINFOEX = NMTVDISPINFOEXA;
        pub const NMTVGETINFOTIP = NMTVGETINFOTIPA;
        pub const COMBOBOXEXITEM = COMBOBOXEXITEMA;
        pub const NMCOMBOBOXEX = NMCOMBOBOXEXA;
        pub const NMCBEDRAGBEGIN = NMCBEDRAGBEGINA;
        pub const NMCBEENDEDIT = NMCBEENDEDITA;
        pub const TCITEMHEADER = TCITEMHEADERA;
        pub const TCITEM = TCITEMA;
        pub const NMDATETIMESTRING = NMDATETIMESTRINGA;
        pub const NMDATETIMEWMKEYDOWN = NMDATETIMEWMKEYDOWNA;
        pub const NMDATETIMEFORMAT = NMDATETIMEFORMATA;
        pub const NMDATETIMEFORMATQUERY = NMDATETIMEFORMATQUERYA;
        pub const CHARFORMAT = CHARFORMATA;
        pub const CHARFORMAT2 = CHARFORMAT2A;
        pub const TEXTRANGE = TEXTRANGEA;
        pub const FINDTEXT = FINDTEXTA;
        pub const FINDTEXTEX = FINDTEXTEXA;
        pub const EDITWORDBREAKPROC = EDITWORDBREAKPROCA;
        pub const CreatePropertySheetPage = CreatePropertySheetPageA;
        pub const PropertySheet = PropertySheetA;
        pub const ImageList_LoadImage = ImageList_LoadImageA;
        pub const DrawStatusText = DrawStatusTextA;
        pub const CreateStatusWindow = CreateStatusWindowA;
        pub const DlgDirList = DlgDirListA;
        pub const DlgDirSelectEx = DlgDirSelectExA;
        pub const DlgDirListComboBox = DlgDirListComboBoxA;
        pub const DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExA;
    },
    .wide => struct {
        pub const LPFNPSPCALLBACK = LPFNPSPCALLBACKW;
        pub const PROPSHEETPAGE = PROPSHEETPAGEW;
        pub const HD_TEXTFILTER = HD_TEXTFILTERW;
        pub const HDITEM = HDITEMW;
        pub const NMHEADER = NMHEADERW;
        pub const NMHDDISPINFO = NMHDDISPINFOW;
        pub const TBSAVEPARAMS = TBSAVEPARAMSW;
        pub const TBBUTTONINFO = TBBUTTONINFOW;
        pub const NMTBGETINFOTIP = NMTBGETINFOTIPW;
        pub const NMTBDISPINFO = NMTBDISPINFOW;
        pub const NMTOOLBAR = NMTOOLBARW;
        pub const REBARBANDINFO = REBARBANDINFOW;
        pub const TTTOOLINFO = TTTOOLINFOW;
        pub const TTHITTESTINFO = TTHITTESTINFOW;
        pub const NMTTDISPINFO = NMTTDISPINFOW;
        pub const LVITEM = LVITEMW;
        pub const LVFINDINFO = LVFINDINFOW;
        pub const LVCOLUMN = LVCOLUMNW;
        pub const LVBKIMAGE = LVBKIMAGEW;
        pub const NMLVFINDITEM = NMLVFINDITEMW;
        pub const NMLVDISPINFO = NMLVDISPINFOW;
        pub const NMLVGETINFOTIP = NMLVGETINFOTIPW;
        pub const TVITEM = TVITEMW;
        pub const TVITEMEX = TVITEMEXW;
        pub const TVINSERTSTRUCT = TVINSERTSTRUCTW;
        pub const NMTREEVIEW = NMTREEVIEWW;
        pub const NMTVDISPINFO = NMTVDISPINFOW;
        pub const NMTVDISPINFOEX = NMTVDISPINFOEXW;
        pub const NMTVGETINFOTIP = NMTVGETINFOTIPW;
        pub const COMBOBOXEXITEM = COMBOBOXEXITEMW;
        pub const NMCOMBOBOXEX = NMCOMBOBOXEXW;
        pub const NMCBEDRAGBEGIN = NMCBEDRAGBEGINW;
        pub const NMCBEENDEDIT = NMCBEENDEDITW;
        pub const TCITEMHEADER = TCITEMHEADERW;
        pub const TCITEM = TCITEMW;
        pub const NMDATETIMESTRING = NMDATETIMESTRINGW;
        pub const NMDATETIMEWMKEYDOWN = NMDATETIMEWMKEYDOWNW;
        pub const NMDATETIMEFORMAT = NMDATETIMEFORMATW;
        pub const NMDATETIMEFORMATQUERY = NMDATETIMEFORMATQUERYW;
        pub const CHARFORMAT = CHARFORMATW;
        pub const CHARFORMAT2 = CHARFORMAT2W;
        pub const TEXTRANGE = TEXTRANGEW;
        pub const FINDTEXT = FINDTEXTW;
        pub const FINDTEXTEX = FINDTEXTEXW;
        pub const EDITWORDBREAKPROC = EDITWORDBREAKPROCW;
        pub const CreatePropertySheetPage = CreatePropertySheetPageW;
        pub const PropertySheet = PropertySheetW;
        pub const ImageList_LoadImage = ImageList_LoadImageW;
        pub const DrawStatusText = DrawStatusTextW;
        pub const CreateStatusWindow = CreateStatusWindowW;
        pub const DlgDirList = DlgDirListW;
        pub const DlgDirSelectEx = DlgDirSelectExW;
        pub const DlgDirListComboBox = DlgDirListComboBoxW;
        pub const DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const LPFNPSPCALLBACK = *opaque{};
        pub const PROPSHEETPAGE = *opaque{};
        pub const HD_TEXTFILTER = *opaque{};
        pub const HDITEM = *opaque{};
        pub const NMHEADER = *opaque{};
        pub const NMHDDISPINFO = *opaque{};
        pub const TBSAVEPARAMS = *opaque{};
        pub const TBBUTTONINFO = *opaque{};
        pub const NMTBGETINFOTIP = *opaque{};
        pub const NMTBDISPINFO = *opaque{};
        pub const NMTOOLBAR = *opaque{};
        pub const REBARBANDINFO = *opaque{};
        pub const TTTOOLINFO = *opaque{};
        pub const TTHITTESTINFO = *opaque{};
        pub const NMTTDISPINFO = *opaque{};
        pub const LVITEM = *opaque{};
        pub const LVFINDINFO = *opaque{};
        pub const LVCOLUMN = *opaque{};
        pub const LVBKIMAGE = *opaque{};
        pub const NMLVFINDITEM = *opaque{};
        pub const NMLVDISPINFO = *opaque{};
        pub const NMLVGETINFOTIP = *opaque{};
        pub const TVITEM = *opaque{};
        pub const TVITEMEX = *opaque{};
        pub const TVINSERTSTRUCT = *opaque{};
        pub const NMTREEVIEW = *opaque{};
        pub const NMTVDISPINFO = *opaque{};
        pub const NMTVDISPINFOEX = *opaque{};
        pub const NMTVGETINFOTIP = *opaque{};
        pub const COMBOBOXEXITEM = *opaque{};
        pub const NMCOMBOBOXEX = *opaque{};
        pub const NMCBEDRAGBEGIN = *opaque{};
        pub const NMCBEENDEDIT = *opaque{};
        pub const TCITEMHEADER = *opaque{};
        pub const TCITEM = *opaque{};
        pub const NMDATETIMESTRING = *opaque{};
        pub const NMDATETIMEWMKEYDOWN = *opaque{};
        pub const NMDATETIMEFORMAT = *opaque{};
        pub const NMDATETIMEFORMATQUERY = *opaque{};
        pub const CHARFORMAT = *opaque{};
        pub const CHARFORMAT2 = *opaque{};
        pub const TEXTRANGE = *opaque{};
        pub const FINDTEXT = *opaque{};
        pub const FINDTEXTEX = *opaque{};
        pub const EDITWORDBREAKPROC = *opaque{};
        pub const CreatePropertySheetPage = *opaque{};
        pub const PropertySheet = *opaque{};
        pub const ImageList_LoadImage = *opaque{};
        pub const DrawStatusText = *opaque{};
        pub const CreateStatusWindow = *opaque{};
        pub const DlgDirList = *opaque{};
        pub const DlgDirSelectEx = *opaque{};
        pub const DlgDirListComboBox = *opaque{};
        pub const DlgDirSelectComboBoxEx = *opaque{};
    } else struct {
        pub const LPFNPSPCALLBACK = @compileError("'LPFNPSPCALLBACK' requires that UNICODE be set to true or false in the root module");
        pub const PROPSHEETPAGE = @compileError("'PROPSHEETPAGE' requires that UNICODE be set to true or false in the root module");
        pub const HD_TEXTFILTER = @compileError("'HD_TEXTFILTER' requires that UNICODE be set to true or false in the root module");
        pub const HDITEM = @compileError("'HDITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMHEADER = @compileError("'NMHEADER' requires that UNICODE be set to true or false in the root module");
        pub const NMHDDISPINFO = @compileError("'NMHDDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const TBSAVEPARAMS = @compileError("'TBSAVEPARAMS' requires that UNICODE be set to true or false in the root module");
        pub const TBBUTTONINFO = @compileError("'TBBUTTONINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTBGETINFOTIP = @compileError("'NMTBGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const NMTBDISPINFO = @compileError("'NMTBDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTOOLBAR = @compileError("'NMTOOLBAR' requires that UNICODE be set to true or false in the root module");
        pub const REBARBANDINFO = @compileError("'REBARBANDINFO' requires that UNICODE be set to true or false in the root module");
        pub const TTTOOLINFO = @compileError("'TTTOOLINFO' requires that UNICODE be set to true or false in the root module");
        pub const TTHITTESTINFO = @compileError("'TTHITTESTINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTTDISPINFO = @compileError("'NMTTDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const LVITEM = @compileError("'LVITEM' requires that UNICODE be set to true or false in the root module");
        pub const LVFINDINFO = @compileError("'LVFINDINFO' requires that UNICODE be set to true or false in the root module");
        pub const LVCOLUMN = @compileError("'LVCOLUMN' requires that UNICODE be set to true or false in the root module");
        pub const LVBKIMAGE = @compileError("'LVBKIMAGE' requires that UNICODE be set to true or false in the root module");
        pub const NMLVFINDITEM = @compileError("'NMLVFINDITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMLVDISPINFO = @compileError("'NMLVDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMLVGETINFOTIP = @compileError("'NMLVGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const TVITEM = @compileError("'TVITEM' requires that UNICODE be set to true or false in the root module");
        pub const TVITEMEX = @compileError("'TVITEMEX' requires that UNICODE be set to true or false in the root module");
        pub const TVINSERTSTRUCT = @compileError("'TVINSERTSTRUCT' requires that UNICODE be set to true or false in the root module");
        pub const NMTREEVIEW = @compileError("'NMTREEVIEW' requires that UNICODE be set to true or false in the root module");
        pub const NMTVDISPINFO = @compileError("'NMTVDISPINFO' requires that UNICODE be set to true or false in the root module");
        pub const NMTVDISPINFOEX = @compileError("'NMTVDISPINFOEX' requires that UNICODE be set to true or false in the root module");
        pub const NMTVGETINFOTIP = @compileError("'NMTVGETINFOTIP' requires that UNICODE be set to true or false in the root module");
        pub const COMBOBOXEXITEM = @compileError("'COMBOBOXEXITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMCOMBOBOXEX = @compileError("'NMCOMBOBOXEX' requires that UNICODE be set to true or false in the root module");
        pub const NMCBEDRAGBEGIN = @compileError("'NMCBEDRAGBEGIN' requires that UNICODE be set to true or false in the root module");
        pub const NMCBEENDEDIT = @compileError("'NMCBEENDEDIT' requires that UNICODE be set to true or false in the root module");
        pub const TCITEMHEADER = @compileError("'TCITEMHEADER' requires that UNICODE be set to true or false in the root module");
        pub const TCITEM = @compileError("'TCITEM' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMESTRING = @compileError("'NMDATETIMESTRING' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEWMKEYDOWN = @compileError("'NMDATETIMEWMKEYDOWN' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEFORMAT = @compileError("'NMDATETIMEFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const NMDATETIMEFORMATQUERY = @compileError("'NMDATETIMEFORMATQUERY' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT = @compileError("'CHARFORMAT' requires that UNICODE be set to true or false in the root module");
        pub const CHARFORMAT2 = @compileError("'CHARFORMAT2' requires that UNICODE be set to true or false in the root module");
        pub const TEXTRANGE = @compileError("'TEXTRANGE' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXT = @compileError("'FINDTEXT' requires that UNICODE be set to true or false in the root module");
        pub const FINDTEXTEX = @compileError("'FINDTEXTEX' requires that UNICODE be set to true or false in the root module");
        pub const EDITWORDBREAKPROC = @compileError("'EDITWORDBREAKPROC' requires that UNICODE be set to true or false in the root module");
        pub const CreatePropertySheetPage = @compileError("'CreatePropertySheetPage' requires that UNICODE be set to true or false in the root module");
        pub const PropertySheet = @compileError("'PropertySheet' requires that UNICODE be set to true or false in the root module");
        pub const ImageList_LoadImage = @compileError("'ImageList_LoadImage' requires that UNICODE be set to true or false in the root module");
        pub const DrawStatusText = @compileError("'DrawStatusText' requires that UNICODE be set to true or false in the root module");
        pub const CreateStatusWindow = @compileError("'CreateStatusWindow' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirList = @compileError("'DlgDirList' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirSelectEx = @compileError("'DlgDirSelectEx' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirListComboBox = @compileError("'DlgDirListComboBox' requires that UNICODE be set to true or false in the root module");
        pub const DlgDirSelectComboBoxEx = @compileError("'DlgDirSelectComboBoxEx' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (54)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const IDispatch = @import("automation.zig").IDispatch;
const HRGN = @import("gdi.zig").HRGN;
const HPEN = @import("gdi.zig").HPEN;
const LOGFONTW = @import("shell.zig").LOGFONTW;
const WPARAM = @import("windows_and_messaging.zig").WPARAM;
const LRESULT = @import("system_services.zig").LRESULT;
const HMENU = @import("menus_and_resources.zig").HMENU;
const IOleClientSite = @import("com.zig").IOleClientSite;
const IRawElementProviderWindowlessSite = @import("windows_accessibility.zig").IRawElementProviderWindowlessSite;
const IOleInPlaceFrame = @import("com.zig").IOleInPlaceFrame;
const IStream = @import("structured_storage.zig").IStream;
const HMONITOR = @import("gdi.zig").HMONITOR;
const PWSTR = @import("system_services.zig").PWSTR;
const POINTER_TOUCH_INFO = @import("pointer_input.zig").POINTER_TOUCH_INFO;
const BSTR = @import("automation.zig").BSTR;
const PSTR = @import("system_services.zig").PSTR;
const RECT = @import("display_devices.zig").RECT;
const IStorage = @import("structured_storage.zig").IStorage;
const BLENDFUNCTION = @import("gdi.zig").BLENDFUNCTION;
const SYSTEMTIME = @import("windows_programming.zig").SYSTEMTIME;
const HANDLE = @import("system_services.zig").HANDLE;
const UiaRect = @import("windows_accessibility.zig").UiaRect;
const HIMC__ = @import("intl.zig").HIMC__;
const HCURSOR = @import("menus_and_resources.zig").HCURSOR;
const LPARAM = @import("windows_and_messaging.zig").LPARAM;
const HDC = @import("gdi.zig").HDC;
const HINSTANCE = @import("system_services.zig").HINSTANCE;
const HKEY = @import("windows_programming.zig").HKEY;
const OIFI = @import("com.zig").OIFI;
const IRawElementProviderSimple = @import("windows_accessibility.zig").IRawElementProviderSimple;
const ID2D1RenderTarget = @import("direct2d.zig").ID2D1RenderTarget;
const HRESULT = @import("com.zig").HRESULT;
const IOleObject = @import("com.zig").IOleObject;
const RGBQUAD = @import("gdi.zig").RGBQUAD;
const BOOL = @import("system_services.zig").BOOL;
const HBRUSH = @import("gdi.zig").HBRUSH;
const IOleInPlaceUIWindow = @import("com.zig").IOleInPlaceUIWindow;
const DLGPROC = @import("windows_and_messaging.zig").DLGPROC;
const HPALETTE = @import("gdi.zig").HPALETTE;
const TEXTMETRICW = @import("gdi.zig").TEXTMETRICW;
const DVTARGETDEVICE = @import("com.zig").DVTARGETDEVICE;
const HICON = @import("menus_and_resources.zig").HICON;
const IUnknown = @import("com.zig").IUnknown;
const IDropTarget = @import("com.zig").IDropTarget;
const HBITMAP = @import("gdi.zig").HBITMAP;
const HWND = @import("windows_and_messaging.zig").HWND;
const WINDOWPOS = @import("windows_and_messaging.zig").WINDOWPOS;
const VARIANT = @import("automation.zig").VARIANT;
const IDataObject = @import("com.zig").IDataObject;
const POINTER_INPUT_TYPE = @import("menus_and_resources.zig").POINTER_INPUT_TYPE;
const POINT = @import("display_devices.zig").POINT;
const SIZE = @import("display_devices.zig").SIZE;
const RECTL = @import("display_devices.zig").RECTL;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = LPFNPSPCALLBACKA;
    _ = LPFNPSPCALLBACKW;
    _ = PFNPROPSHEETCALLBACK;
    _ = LPFNADDPROPSHEETPAGE;
    _ = LPFNADDPROPSHEETPAGES;
    _ = PFNLVCOMPARE;
    _ = PFNLVGROUPCOMPARE;
    _ = PFNTVCOMPARE;
    _ = PFTASKDIALOGCALLBACK;
    _ = PFNDAENUMCALLBACK;
    _ = PFNDAENUMCALLBACKCONST;
    _ = PFNDACOMPARE;
    _ = PFNDACOMPARECONST;
    _ = PFNDPASTREAM;
    _ = PFNDPAMERGE;
    _ = PFNDPAMERGECONST;
    _ = AutoCorrectProc;
    _ = EDITWORDBREAKPROCEX;
    _ = EDITSTREAMCALLBACK;
    _ = PCreateTextServices;
    _ = PShutdownTextServices;
    _ = DTT_CALLBACK_PROC;
    _ = EDITWORDBREAKPROCA;
    _ = EDITWORDBREAKPROCW;

    const constant_export_count = 0;
    const type_export_count = 356;
    const enum_value_export_count = 814;
    const com_iface_id_export_count = 19;
    const com_class_id_export_count = 1;
    const func_export_count = 229;
    const unicode_alias_count = 54;
    const import_count = 54;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
