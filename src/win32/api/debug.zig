//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (4)
//--------------------------------------------------------------------------------
pub const ACTIVPROF_E_PROFILER_PRESENT : i32 = -2147220992;
pub const ACTIVPROF_E_PROFILER_ABSENT : i32 = -2147220991;
pub const ACTIVPROF_E_UNABLE_TO_APPLY_ACTION : i32 = -2147220990;
pub const PROFILER_HEAP_OBJECT_NAME_ID_UNAVAILABLE : u32 = 4294967295;

//--------------------------------------------------------------------------------
// Section: Types (1702)
//--------------------------------------------------------------------------------
pub const FLASHWINFO = extern struct {
    cbSize: u32,
    hwnd: HWND,
    dwFlags: u32,
    uCount: u32,
    dwTimeout: u32,
};

pub const CONTEXT = extern struct {
    ContextFlags: u32,
    Dr0: u32,
    Dr1: u32,
    Dr2: u32,
    Dr3: u32,
    Dr6: u32,
    Dr7: u32,
    FloatSave: FLOATING_SAVE_AREA,
    SegGs: u32,
    SegFs: u32,
    SegEs: u32,
    SegDs: u32,
    Edi: u32,
    Esi: u32,
    Ebx: u32,
    Edx: u32,
    Ecx: u32,
    Eax: u32,
    Ebp: u32,
    Eip: u32,
    SegCs: u32,
    EFlags: u32,
    Esp: u32,
    SegSs: u32,
    ExtendedRegisters: [512]u8,
};

pub const LDT_ENTRY = extern struct {
    LimitLow: u16,
    BaseLow: u16,
    HighWord: LDT_ENTRY._HighWord_e__Union,
    const _HighWord_e__Union = u32; // TODO: generate this nested type!
};

pub const WOW64_FLOATING_SAVE_AREA = extern struct {
    ControlWord: u32,
    StatusWord: u32,
    TagWord: u32,
    ErrorOffset: u32,
    ErrorSelector: u32,
    DataOffset: u32,
    DataSelector: u32,
    RegisterArea: [80]u8,
    Cr0NpxState: u32,
};

pub const WOW64_CONTEXT = extern struct {
    ContextFlags: u32,
    Dr0: u32,
    Dr1: u32,
    Dr2: u32,
    Dr3: u32,
    Dr6: u32,
    Dr7: u32,
    FloatSave: WOW64_FLOATING_SAVE_AREA,
    SegGs: u32,
    SegFs: u32,
    SegEs: u32,
    SegDs: u32,
    Edi: u32,
    Esi: u32,
    Ebx: u32,
    Edx: u32,
    Ecx: u32,
    Eax: u32,
    Ebp: u32,
    Eip: u32,
    SegCs: u32,
    EFlags: u32,
    Esp: u32,
    SegSs: u32,
    ExtendedRegisters: [512]u8,
};

pub const WOW64_LDT_ENTRY = extern struct {
    LimitLow: u16,
    BaseLow: u16,
    HighWord: WOW64_LDT_ENTRY._HighWord_e__Union,
    const _HighWord_e__Union = u32; // TODO: generate this nested type!
};

pub const EXCEPTION_RECORD = extern struct {
    ExceptionCode: u32,
    ExceptionFlags: u32,
    ExceptionRecord: *EXCEPTION_RECORD,
    ExceptionAddress: *c_void,
    NumberParameters: u32,
    ExceptionInformation: [15]?*c_void,
};

pub const EXCEPTION_RECORD64 = extern struct {
    ExceptionCode: u32,
    ExceptionFlags: u32,
    ExceptionRecord: u64,
    ExceptionAddress: u64,
    NumberParameters: u32,
    __unusedAlignment: u32,
    ExceptionInformation: [15]u64,
};

pub const EXCEPTION_POINTERS = extern struct {
    ExceptionRecord: *EXCEPTION_RECORD,
    ContextRecord: *CONTEXT,
};

pub const IMAGE_FILE_HEADER = extern struct {
    Machine: u16,
    NumberOfSections: u16,
    TimeDateStamp: u32,
    PointerToSymbolTable: u32,
    NumberOfSymbols: u32,
    SizeOfOptionalHeader: u16,
    Characteristics: u16,
};

pub const IMAGE_DATA_DIRECTORY = extern struct {
    VirtualAddress: u32,
    Size: u32,
};

pub const IMAGE_OPTIONAL_HEADER64 = extern struct {
    Magic: u16,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    ImageBase: u64,
    SectionAlignment: u32,
    FileAlignment: u32,
    MajorOperatingSystemVersion: u16,
    MinorOperatingSystemVersion: u16,
    MajorImageVersion: u16,
    MinorImageVersion: u16,
    MajorSubsystemVersion: u16,
    MinorSubsystemVersion: u16,
    Win32VersionValue: u32,
    SizeOfImage: u32,
    SizeOfHeaders: u32,
    CheckSum: u32,
    Subsystem: u16,
    DllCharacteristics: u16,
    SizeOfStackReserve: u64,
    SizeOfStackCommit: u64,
    SizeOfHeapReserve: u64,
    SizeOfHeapCommit: u64,
    LoaderFlags: u32,
    NumberOfRvaAndSizes: u32,
    DataDirectory: [16]IMAGE_DATA_DIRECTORY,
};

pub const IMAGE_NT_HEADERS64 = extern struct {
    Signature: u32,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER64,
};

pub const IMAGE_SECTION_HEADER = extern struct {
    Name: [8]u8,
    Misc: IMAGE_SECTION_HEADER._Misc_e__Union,
    VirtualAddress: u32,
    SizeOfRawData: u32,
    PointerToRawData: u32,
    PointerToRelocations: u32,
    PointerToLinenumbers: u32,
    NumberOfRelocations: u16,
    NumberOfLinenumbers: u16,
    Characteristics: u32,
    const _Misc_e__Union = u32; // TODO: generate this nested type!
};

pub const IMAGE_LOAD_CONFIG_DIRECTORY32 = extern struct {
    Size: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    GlobalFlagsClear: u32,
    GlobalFlagsSet: u32,
    CriticalSectionDefaultTimeout: u32,
    DeCommitFreeBlockThreshold: u32,
    DeCommitTotalFreeThreshold: u32,
    LockPrefixTable: u32,
    MaximumAllocationSize: u32,
    VirtualMemoryThreshold: u32,
    ProcessHeapFlags: u32,
    ProcessAffinityMask: u32,
    CSDVersion: u16,
    DependentLoadFlags: u16,
    EditList: u32,
    SecurityCookie: u32,
    SEHandlerTable: u32,
    SEHandlerCount: u32,
    GuardCFCheckFunctionPointer: u32,
    GuardCFDispatchFunctionPointer: u32,
    GuardCFFunctionTable: u32,
    GuardCFFunctionCount: u32,
    GuardFlags: u32,
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    GuardAddressTakenIatEntryTable: u32,
    GuardAddressTakenIatEntryCount: u32,
    GuardLongJumpTargetTable: u32,
    GuardLongJumpTargetCount: u32,
    DynamicValueRelocTable: u32,
    CHPEMetadataPointer: u32,
    GuardRFFailureRoutine: u32,
    GuardRFFailureRoutineFunctionPointer: u32,
    DynamicValueRelocTableOffset: u32,
    DynamicValueRelocTableSection: u16,
    Reserved2: u16,
    GuardRFVerifyStackPointerFunctionPointer: u32,
    HotPatchTableOffset: u32,
    Reserved3: u32,
    EnclaveConfigurationPointer: u32,
    VolatileMetadataPointer: u32,
    GuardEHContinuationTable: u32,
    GuardEHContinuationCount: u32,
};

pub const IMAGE_LOAD_CONFIG_DIRECTORY64 = extern struct {
    Size: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    GlobalFlagsClear: u32,
    GlobalFlagsSet: u32,
    CriticalSectionDefaultTimeout: u32,
    DeCommitFreeBlockThreshold: u64,
    DeCommitTotalFreeThreshold: u64,
    LockPrefixTable: u64,
    MaximumAllocationSize: u64,
    VirtualMemoryThreshold: u64,
    ProcessAffinityMask: u64,
    ProcessHeapFlags: u32,
    CSDVersion: u16,
    DependentLoadFlags: u16,
    EditList: u64,
    SecurityCookie: u64,
    SEHandlerTable: u64,
    SEHandlerCount: u64,
    GuardCFCheckFunctionPointer: u64,
    GuardCFDispatchFunctionPointer: u64,
    GuardCFFunctionTable: u64,
    GuardCFFunctionCount: u64,
    GuardFlags: u32,
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    GuardAddressTakenIatEntryTable: u64,
    GuardAddressTakenIatEntryCount: u64,
    GuardLongJumpTargetTable: u64,
    GuardLongJumpTargetCount: u64,
    DynamicValueRelocTable: u64,
    CHPEMetadataPointer: u64,
    GuardRFFailureRoutine: u64,
    GuardRFFailureRoutineFunctionPointer: u64,
    DynamicValueRelocTableOffset: u32,
    DynamicValueRelocTableSection: u16,
    Reserved2: u16,
    GuardRFVerifyStackPointerFunctionPointer: u64,
    HotPatchTableOffset: u32,
    Reserved3: u32,
    EnclaveConfigurationPointer: u64,
    VolatileMetadataPointer: u64,
    GuardEHContinuationTable: u64,
    GuardEHContinuationCount: u64,
};

pub const IMAGE_DEBUG_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    Type: u32,
    SizeOfData: u32,
    AddressOfRawData: u32,
    PointerToRawData: u32,
};

pub const IMAGE_COFF_SYMBOLS_HEADER = extern struct {
    NumberOfSymbols: u32,
    LvaToFirstSymbol: u32,
    NumberOfLinenumbers: u32,
    LvaToFirstLinenumber: u32,
    RvaToFirstByteOfCode: u32,
    RvaToLastByteOfCode: u32,
    RvaToFirstByteOfData: u32,
    RvaToLastByteOfData: u32,
};

pub const FPO_DATA = extern struct {
    ulOffStart: u32,
    cbProcSize: u32,
    cdwLocals: u32,
    cdwParams: u16,
    _bitfield: u16,
};

pub const IMAGE_FUNCTION_ENTRY = extern struct {
    StartingAddress: u32,
    EndingAddress: u32,
    EndOfPrologue: u32,
};

pub const IMAGE_FUNCTION_ENTRY64 = extern struct {
    StartingAddress: u64,
    EndingAddress: u64,
    Anonymous: IMAGE_FUNCTION_ENTRY64._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PVECTORED_EXCEPTION_HANDLER = fn(
    ExceptionInfo: *EXCEPTION_POINTERS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const EXCEPTION_DEBUG_INFO = extern struct {
    ExceptionRecord: EXCEPTION_RECORD,
    dwFirstChance: u32,
};

pub const CREATE_THREAD_DEBUG_INFO = extern struct {
    hThread: HANDLE,
    lpThreadLocalBase: *c_void,
    lpStartAddress: LPTHREAD_START_ROUTINE,
};

pub const CREATE_PROCESS_DEBUG_INFO = extern struct {
    hFile: HANDLE,
    hProcess: HANDLE,
    hThread: HANDLE,
    lpBaseOfImage: *c_void,
    dwDebugInfoFileOffset: u32,
    nDebugInfoSize: u32,
    lpThreadLocalBase: *c_void,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpImageName: *c_void,
    fUnicode: u16,
};

pub const EXIT_THREAD_DEBUG_INFO = extern struct {
    dwExitCode: u32,
};

pub const EXIT_PROCESS_DEBUG_INFO = extern struct {
    dwExitCode: u32,
};

pub const LOAD_DLL_DEBUG_INFO = extern struct {
    hFile: HANDLE,
    lpBaseOfDll: *c_void,
    dwDebugInfoFileOffset: u32,
    nDebugInfoSize: u32,
    lpImageName: *c_void,
    fUnicode: u16,
};

pub const UNLOAD_DLL_DEBUG_INFO = extern struct {
    lpBaseOfDll: *c_void,
};

pub const OUTPUT_DEBUG_STRING_INFO = extern struct {
    lpDebugStringData: PSTR,
    fUnicode: u16,
    nDebugStringLength: u16,
};

pub const RIP_INFO = extern struct {
    dwError: u32,
    dwType: u32,
};

pub const DEBUG_EVENT = extern struct {
    dwDebugEventCode: u32,
    dwProcessId: u32,
    dwThreadId: u32,
    u: DEBUG_EVENT._u_e__Union,
    const _u_e__Union = u32; // TODO: generate this nested type!
};

pub const PTOP_LEVEL_EXCEPTION_FILTER = fn(
    ExceptionInfo: *EXCEPTION_POINTERS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const LPTOP_LEVEL_EXCEPTION_FILTER = fn(
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WCT_OBJECT_TYPE = extern enum(i32) {
    WctCriticalSectionType = 1,
    WctSendMessageType = 2,
    WctMutexType = 3,
    WctAlpcType = 4,
    WctComType = 5,
    WctThreadWaitType = 6,
    WctProcessWaitType = 7,
    WctThreadType = 8,
    WctComActivationType = 9,
    WctUnknownType = 10,
    WctSocketIoType = 11,
    WctSmbIoType = 12,
    WctMaxType = 13,
};
pub const WctCriticalSectionType = WCT_OBJECT_TYPE.WctCriticalSectionType;
pub const WctSendMessageType = WCT_OBJECT_TYPE.WctSendMessageType;
pub const WctMutexType = WCT_OBJECT_TYPE.WctMutexType;
pub const WctAlpcType = WCT_OBJECT_TYPE.WctAlpcType;
pub const WctComType = WCT_OBJECT_TYPE.WctComType;
pub const WctThreadWaitType = WCT_OBJECT_TYPE.WctThreadWaitType;
pub const WctProcessWaitType = WCT_OBJECT_TYPE.WctProcessWaitType;
pub const WctThreadType = WCT_OBJECT_TYPE.WctThreadType;
pub const WctComActivationType = WCT_OBJECT_TYPE.WctComActivationType;
pub const WctUnknownType = WCT_OBJECT_TYPE.WctUnknownType;
pub const WctSocketIoType = WCT_OBJECT_TYPE.WctSocketIoType;
pub const WctSmbIoType = WCT_OBJECT_TYPE.WctSmbIoType;
pub const WctMaxType = WCT_OBJECT_TYPE.WctMaxType;

pub const WCT_OBJECT_STATUS = extern enum(i32) {
    WctStatusNoAccess = 1,
    WctStatusRunning = 2,
    WctStatusBlocked = 3,
    WctStatusPidOnly = 4,
    WctStatusPidOnlyRpcss = 5,
    WctStatusOwned = 6,
    WctStatusNotOwned = 7,
    WctStatusAbandoned = 8,
    WctStatusUnknown = 9,
    WctStatusError = 10,
    WctStatusMax = 11,
};
pub const WctStatusNoAccess = WCT_OBJECT_STATUS.WctStatusNoAccess;
pub const WctStatusRunning = WCT_OBJECT_STATUS.WctStatusRunning;
pub const WctStatusBlocked = WCT_OBJECT_STATUS.WctStatusBlocked;
pub const WctStatusPidOnly = WCT_OBJECT_STATUS.WctStatusPidOnly;
pub const WctStatusPidOnlyRpcss = WCT_OBJECT_STATUS.WctStatusPidOnlyRpcss;
pub const WctStatusOwned = WCT_OBJECT_STATUS.WctStatusOwned;
pub const WctStatusNotOwned = WCT_OBJECT_STATUS.WctStatusNotOwned;
pub const WctStatusAbandoned = WCT_OBJECT_STATUS.WctStatusAbandoned;
pub const WctStatusUnknown = WCT_OBJECT_STATUS.WctStatusUnknown;
pub const WctStatusError = WCT_OBJECT_STATUS.WctStatusError;
pub const WctStatusMax = WCT_OBJECT_STATUS.WctStatusMax;

pub const WAITCHAIN_NODE_INFO = extern struct {
    ObjectType: WCT_OBJECT_TYPE,
    ObjectStatus: WCT_OBJECT_STATUS,
    Anonymous: WAITCHAIN_NODE_INFO._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PWAITCHAINCALLBACK = fn(
    WctHandle: *c_void,
    Context: ?*c_void,
    CallbackStatus: u32,
    NodeCount: *u32,
    NodeInfoArray: *WAITCHAIN_NODE_INFO,
    IsCycle: *i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PCOGETCALLSTATE = fn(
    param0: i32,
    param1: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PCOGETACTIVATIONSTATE = fn(
    param0: Guid,
    param1: u32,
    param2: *u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const MINIDUMP_LOCATION_DESCRIPTOR = extern struct {
    DataSize: u32,
    Rva: u32,
};

pub const MINIDUMP_LOCATION_DESCRIPTOR64 = extern struct {
    DataSize: u64,
    Rva: u64,
};

pub const MINIDUMP_MEMORY_DESCRIPTOR = extern struct {
    StartOfMemoryRange: u64,
    Memory: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_MEMORY_DESCRIPTOR64 = extern struct {
    StartOfMemoryRange: u64,
    DataSize: u64,
};

pub const MINIDUMP_HEADER = extern struct {
    Signature: u32,
    Version: u32,
    NumberOfStreams: u32,
    StreamDirectoryRva: u32,
    CheckSum: u32,
    Anonymous: MINIDUMP_HEADER._Anonymous_e__Union,
    Flags: u64,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MINIDUMP_DIRECTORY = extern struct {
    StreamType: u32,
    Location: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_STRING = extern struct {
    Length: u32,
    Buffer: [1]u16,
};

pub const MINIDUMP_STREAM_TYPE = extern enum(i32) {
    UnusedStream = 0,
    ReservedStream0 = 1,
    ReservedStream1 = 2,
    ThreadListStream = 3,
    ModuleListStream = 4,
    MemoryListStream = 5,
    ExceptionStream = 6,
    SystemInfoStream = 7,
    ThreadExListStream = 8,
    Memory64ListStream = 9,
    CommentStreamA = 10,
    CommentStreamW = 11,
    HandleDataStream = 12,
    FunctionTableStream = 13,
    UnloadedModuleListStream = 14,
    MiscInfoStream = 15,
    MemoryInfoListStream = 16,
    ThreadInfoListStream = 17,
    HandleOperationListStream = 18,
    TokenStream = 19,
    JavaScriptDataStream = 20,
    SystemMemoryInfoStream = 21,
    ProcessVmCountersStream = 22,
    IptTraceStream = 23,
    ThreadNamesStream = 24,
    ceStreamNull = 32768,
    ceStreamSystemInfo = 32769,
    ceStreamException = 32770,
    ceStreamModuleList = 32771,
    ceStreamProcessList = 32772,
    ceStreamThreadList = 32773,
    ceStreamThreadContextList = 32774,
    ceStreamThreadCallStackList = 32775,
    ceStreamMemoryVirtualList = 32776,
    ceStreamMemoryPhysicalList = 32777,
    ceStreamBucketParameters = 32778,
    ceStreamProcessModuleMap = 32779,
    ceStreamDiagnosisList = 32780,
    LastReservedStream = 65535,
};
pub const UnusedStream = MINIDUMP_STREAM_TYPE.UnusedStream;
pub const ReservedStream0 = MINIDUMP_STREAM_TYPE.ReservedStream0;
pub const ReservedStream1 = MINIDUMP_STREAM_TYPE.ReservedStream1;
pub const ThreadListStream = MINIDUMP_STREAM_TYPE.ThreadListStream;
pub const ModuleListStream = MINIDUMP_STREAM_TYPE.ModuleListStream;
pub const MemoryListStream = MINIDUMP_STREAM_TYPE.MemoryListStream;
pub const ExceptionStream = MINIDUMP_STREAM_TYPE.ExceptionStream;
pub const SystemInfoStream = MINIDUMP_STREAM_TYPE.SystemInfoStream;
pub const ThreadExListStream = MINIDUMP_STREAM_TYPE.ThreadExListStream;
pub const Memory64ListStream = MINIDUMP_STREAM_TYPE.Memory64ListStream;
pub const CommentStreamA = MINIDUMP_STREAM_TYPE.CommentStreamA;
pub const CommentStreamW = MINIDUMP_STREAM_TYPE.CommentStreamW;
pub const HandleDataStream = MINIDUMP_STREAM_TYPE.HandleDataStream;
pub const FunctionTableStream = MINIDUMP_STREAM_TYPE.FunctionTableStream;
pub const UnloadedModuleListStream = MINIDUMP_STREAM_TYPE.UnloadedModuleListStream;
pub const MiscInfoStream = MINIDUMP_STREAM_TYPE.MiscInfoStream;
pub const MemoryInfoListStream = MINIDUMP_STREAM_TYPE.MemoryInfoListStream;
pub const ThreadInfoListStream = MINIDUMP_STREAM_TYPE.ThreadInfoListStream;
pub const HandleOperationListStream = MINIDUMP_STREAM_TYPE.HandleOperationListStream;
pub const TokenStream = MINIDUMP_STREAM_TYPE.TokenStream;
pub const JavaScriptDataStream = MINIDUMP_STREAM_TYPE.JavaScriptDataStream;
pub const SystemMemoryInfoStream = MINIDUMP_STREAM_TYPE.SystemMemoryInfoStream;
pub const ProcessVmCountersStream = MINIDUMP_STREAM_TYPE.ProcessVmCountersStream;
pub const IptTraceStream = MINIDUMP_STREAM_TYPE.IptTraceStream;
pub const ThreadNamesStream = MINIDUMP_STREAM_TYPE.ThreadNamesStream;
pub const ceStreamNull = MINIDUMP_STREAM_TYPE.ceStreamNull;
pub const ceStreamSystemInfo = MINIDUMP_STREAM_TYPE.ceStreamSystemInfo;
pub const ceStreamException = MINIDUMP_STREAM_TYPE.ceStreamException;
pub const ceStreamModuleList = MINIDUMP_STREAM_TYPE.ceStreamModuleList;
pub const ceStreamProcessList = MINIDUMP_STREAM_TYPE.ceStreamProcessList;
pub const ceStreamThreadList = MINIDUMP_STREAM_TYPE.ceStreamThreadList;
pub const ceStreamThreadContextList = MINIDUMP_STREAM_TYPE.ceStreamThreadContextList;
pub const ceStreamThreadCallStackList = MINIDUMP_STREAM_TYPE.ceStreamThreadCallStackList;
pub const ceStreamMemoryVirtualList = MINIDUMP_STREAM_TYPE.ceStreamMemoryVirtualList;
pub const ceStreamMemoryPhysicalList = MINIDUMP_STREAM_TYPE.ceStreamMemoryPhysicalList;
pub const ceStreamBucketParameters = MINIDUMP_STREAM_TYPE.ceStreamBucketParameters;
pub const ceStreamProcessModuleMap = MINIDUMP_STREAM_TYPE.ceStreamProcessModuleMap;
pub const ceStreamDiagnosisList = MINIDUMP_STREAM_TYPE.ceStreamDiagnosisList;
pub const LastReservedStream = MINIDUMP_STREAM_TYPE.LastReservedStream;

pub const CPU_INFORMATION = u32; // TODO: implement StructOrUnion types?

pub const MINIDUMP_SYSTEM_INFO = extern struct {
    ProcessorArchitecture: u16,
    ProcessorLevel: u16,
    ProcessorRevision: u16,
    Anonymous1: MINIDUMP_SYSTEM_INFO._Anonymous1_e__Union,
    MajorVersion: u32,
    MinorVersion: u32,
    BuildNumber: u32,
    PlatformId: u32,
    CSDVersionRva: u32,
    Anonymous2: MINIDUMP_SYSTEM_INFO._Anonymous2_e__Union,
    Cpu: CPU_INFORMATION,
    const _Anonymous2_e__Union = u32; // TODO: generate this nested type!
    const _Anonymous1_e__Union = u32; // TODO: generate this nested type!
};

pub const MINIDUMP_THREAD = extern struct {
    ThreadId: u32,
    SuspendCount: u32,
    PriorityClass: u32,
    Priority: u32,
    Teb: u64,
    Stack: MINIDUMP_MEMORY_DESCRIPTOR,
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_THREAD_LIST = extern struct {
    NumberOfThreads: u32,
    Threads: [1]MINIDUMP_THREAD,
};

pub const MINIDUMP_THREAD_EX = extern struct {
    ThreadId: u32,
    SuspendCount: u32,
    PriorityClass: u32,
    Priority: u32,
    Teb: u64,
    Stack: MINIDUMP_MEMORY_DESCRIPTOR,
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR,
    BackingStore: MINIDUMP_MEMORY_DESCRIPTOR,
};

pub const MINIDUMP_THREAD_EX_LIST = extern struct {
    NumberOfThreads: u32,
    Threads: [1]MINIDUMP_THREAD_EX,
};

pub const MINIDUMP_EXCEPTION = extern struct {
    ExceptionCode: u32,
    ExceptionFlags: u32,
    ExceptionRecord: u64,
    ExceptionAddress: u64,
    NumberParameters: u32,
    __unusedAlignment: u32,
    ExceptionInformation: [15]u64,
};

pub const MINIDUMP_EXCEPTION_STREAM = extern struct {
    ThreadId: u32,
    __alignment: u32,
    ExceptionRecord: MINIDUMP_EXCEPTION,
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_MODULE = extern struct {
    BaseOfImage: u64,
    SizeOfImage: u32,
    CheckSum: u32,
    TimeDateStamp: u32,
    ModuleNameRva: u32,
    VersionInfo: VS_FIXEDFILEINFO,
    CvRecord: MINIDUMP_LOCATION_DESCRIPTOR,
    MiscRecord: MINIDUMP_LOCATION_DESCRIPTOR,
    Reserved0: u64,
    Reserved1: u64,
};

pub const MINIDUMP_MODULE_LIST = extern struct {
    NumberOfModules: u32,
    Modules: [1]MINIDUMP_MODULE,
};

pub const MINIDUMP_MEMORY_LIST = extern struct {
    NumberOfMemoryRanges: u32,
    MemoryRanges: [1]MINIDUMP_MEMORY_DESCRIPTOR,
};

pub const MINIDUMP_MEMORY64_LIST = extern struct {
    NumberOfMemoryRanges: u64,
    BaseRva: u64,
    MemoryRanges: [1]MINIDUMP_MEMORY_DESCRIPTOR64,
};

pub const MINIDUMP_EXCEPTION_INFORMATION = extern struct {
    ThreadId: u32,
    ExceptionPointers: *EXCEPTION_POINTERS,
    ClientPointers: BOOL,
};

pub const MINIDUMP_EXCEPTION_INFORMATION64 = extern struct {
    ThreadId: u32,
    ExceptionRecord: u64,
    ContextRecord: u64,
    ClientPointers: BOOL,
};

pub const MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE = extern enum(i32) {
    MiniHandleObjectInformationNone = 0,
    MiniThreadInformation1 = 1,
    MiniMutantInformation1 = 2,
    MiniMutantInformation2 = 3,
    MiniProcessInformation1 = 4,
    MiniProcessInformation2 = 5,
    MiniEventInformation1 = 6,
    MiniSectionInformation1 = 7,
    MiniSemaphoreInformation1 = 8,
    MiniHandleObjectInformationTypeMax = 9,
};
pub const MiniHandleObjectInformationNone = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniHandleObjectInformationNone;
pub const MiniThreadInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniThreadInformation1;
pub const MiniMutantInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniMutantInformation1;
pub const MiniMutantInformation2 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniMutantInformation2;
pub const MiniProcessInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniProcessInformation1;
pub const MiniProcessInformation2 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniProcessInformation2;
pub const MiniEventInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniEventInformation1;
pub const MiniSectionInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniSectionInformation1;
pub const MiniSemaphoreInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniSemaphoreInformation1;
pub const MiniHandleObjectInformationTypeMax = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MiniHandleObjectInformationTypeMax;

pub const MINIDUMP_HANDLE_OBJECT_INFORMATION = extern struct {
    NextInfoRva: u32,
    InfoType: u32,
    SizeOfInfo: u32,
};

pub const MINIDUMP_HANDLE_DESCRIPTOR = extern struct {
    Handle: u64,
    TypeNameRva: u32,
    ObjectNameRva: u32,
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
};

pub const MINIDUMP_HANDLE_DESCRIPTOR_2 = extern struct {
    Handle: u64,
    TypeNameRva: u32,
    ObjectNameRva: u32,
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
    ObjectInfoRva: u32,
    Reserved0: u32,
};

pub const MINIDUMP_HANDLE_DATA_STREAM = extern struct {
    SizeOfHeader: u32,
    SizeOfDescriptor: u32,
    NumberOfDescriptors: u32,
    Reserved: u32,
};

pub const MINIDUMP_HANDLE_OPERATION_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u32,
    Reserved: u32,
};

pub const MINIDUMP_FUNCTION_TABLE_DESCRIPTOR = extern struct {
    MinimumAddress: u64,
    MaximumAddress: u64,
    BaseAddress: u64,
    EntryCount: u32,
    SizeOfAlignPad: u32,
};

pub const MINIDUMP_FUNCTION_TABLE_STREAM = extern struct {
    SizeOfHeader: u32,
    SizeOfDescriptor: u32,
    SizeOfNativeDescriptor: u32,
    SizeOfFunctionEntry: u32,
    NumberOfDescriptors: u32,
    SizeOfAlignPad: u32,
};

pub const MINIDUMP_UNLOADED_MODULE = extern struct {
    BaseOfImage: u64,
    SizeOfImage: u32,
    CheckSum: u32,
    TimeDateStamp: u32,
    ModuleNameRva: u32,
};

pub const MINIDUMP_UNLOADED_MODULE_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u32,
};

pub const XSTATE_CONFIG_FEATURE_MSC_INFO = extern struct {
    SizeOfInfo: u32,
    ContextSize: u32,
    EnabledFeatures: u64,
    Features: [64]XSTATE_FEATURE,
};

pub const MINIDUMP_MISC_INFO = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
};

pub const MINIDUMP_MISC_INFO_2 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
};

pub const MINIDUMP_MISC_INFO_3 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
    ProcessIntegrityLevel: u32,
    ProcessExecuteFlags: u32,
    ProtectedProcess: u32,
    TimeZoneId: u32,
    TimeZone: TIME_ZONE_INFORMATION,
};

pub const MINIDUMP_MISC_INFO_4 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
    ProcessIntegrityLevel: u32,
    ProcessExecuteFlags: u32,
    ProtectedProcess: u32,
    TimeZoneId: u32,
    TimeZone: TIME_ZONE_INFORMATION,
    BuildString: [260]u16,
    DbgBldStr: [40]u16,
};

pub const MINIDUMP_MISC_INFO_5 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
    ProcessIntegrityLevel: u32,
    ProcessExecuteFlags: u32,
    ProtectedProcess: u32,
    TimeZoneId: u32,
    TimeZone: TIME_ZONE_INFORMATION,
    BuildString: [260]u16,
    DbgBldStr: [40]u16,
    XStateData: XSTATE_CONFIG_FEATURE_MSC_INFO,
    ProcessCookie: u32,
};

pub const MINIDUMP_MEMORY_INFO = extern struct {
    BaseAddress: u64,
    AllocationBase: u64,
    AllocationProtect: u32,
    __alignment1: u32,
    RegionSize: u64,
    State: u32,
    Protect: u32,
    Type: u32,
    __alignment2: u32,
};

pub const MINIDUMP_MEMORY_INFO_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u64,
};

pub const MINIDUMP_THREAD_NAME = extern struct {
    ThreadId: u32,
    RvaOfThreadName: u64,
};

pub const MINIDUMP_THREAD_NAME_LIST = extern struct {
    NumberOfThreadNames: u32,
    ThreadNames: [1]MINIDUMP_THREAD_NAME,
};

pub const MINIDUMP_THREAD_INFO = extern struct {
    ThreadId: u32,
    DumpFlags: u32,
    DumpError: u32,
    ExitStatus: u32,
    CreateTime: u64,
    ExitTime: u64,
    KernelTime: u64,
    UserTime: u64,
    StartAddress: u64,
    Affinity: u64,
};

pub const MINIDUMP_THREAD_INFO_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u32,
};

pub const MINIDUMP_TOKEN_INFO_HEADER = extern struct {
    TokenSize: u32,
    TokenId: u32,
    TokenHandle: u64,
};

pub const MINIDUMP_TOKEN_INFO_LIST = extern struct {
    TokenListSize: u32,
    TokenListEntries: u32,
    ListHeaderSize: u32,
    ElementHeaderSize: u32,
};

pub const MINIDUMP_SYSTEM_BASIC_INFORMATION = extern struct {
    TimerResolution: u32,
    PageSize: u32,
    NumberOfPhysicalPages: u32,
    LowestPhysicalPageNumber: u32,
    HighestPhysicalPageNumber: u32,
    AllocationGranularity: u32,
    MinimumUserModeAddress: u64,
    MaximumUserModeAddress: u64,
    ActiveProcessorsAffinityMask: u64,
    NumberOfProcessors: u32,
};

pub const MINIDUMP_SYSTEM_FILECACHE_INFORMATION = extern struct {
    CurrentSize: u64,
    PeakSize: u64,
    PageFaultCount: u32,
    MinimumWorkingSet: u64,
    MaximumWorkingSet: u64,
    CurrentSizeIncludingTransitionInPages: u64,
    PeakSizeIncludingTransitionInPages: u64,
    TransitionRePurposeCount: u32,
    Flags: u32,
};

pub const MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION = extern struct {
    AvailablePages: u64,
    CommittedPages: u64,
    CommitLimit: u64,
    PeakCommitment: u64,
};

pub const MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION = extern struct {
    IdleProcessTime: u64,
    IoReadTransferCount: u64,
    IoWriteTransferCount: u64,
    IoOtherTransferCount: u64,
    IoReadOperationCount: u32,
    IoWriteOperationCount: u32,
    IoOtherOperationCount: u32,
    AvailablePages: u32,
    CommittedPages: u32,
    CommitLimit: u32,
    PeakCommitment: u32,
    PageFaultCount: u32,
    CopyOnWriteCount: u32,
    TransitionCount: u32,
    CacheTransitionCount: u32,
    DemandZeroCount: u32,
    PageReadCount: u32,
    PageReadIoCount: u32,
    CacheReadCount: u32,
    CacheIoCount: u32,
    DirtyPagesWriteCount: u32,
    DirtyWriteIoCount: u32,
    MappedPagesWriteCount: u32,
    MappedWriteIoCount: u32,
    PagedPoolPages: u32,
    NonPagedPoolPages: u32,
    PagedPoolAllocs: u32,
    PagedPoolFrees: u32,
    NonPagedPoolAllocs: u32,
    NonPagedPoolFrees: u32,
    FreeSystemPtes: u32,
    ResidentSystemCodePage: u32,
    TotalSystemDriverPages: u32,
    TotalSystemCodePages: u32,
    NonPagedPoolLookasideHits: u32,
    PagedPoolLookasideHits: u32,
    AvailablePagedPoolPages: u32,
    ResidentSystemCachePage: u32,
    ResidentPagedPoolPage: u32,
    ResidentSystemDriverPage: u32,
    CcFastReadNoWait: u32,
    CcFastReadWait: u32,
    CcFastReadResourceMiss: u32,
    CcFastReadNotPossible: u32,
    CcFastMdlReadNoWait: u32,
    CcFastMdlReadWait: u32,
    CcFastMdlReadResourceMiss: u32,
    CcFastMdlReadNotPossible: u32,
    CcMapDataNoWait: u32,
    CcMapDataWait: u32,
    CcMapDataNoWaitMiss: u32,
    CcMapDataWaitMiss: u32,
    CcPinMappedDataCount: u32,
    CcPinReadNoWait: u32,
    CcPinReadWait: u32,
    CcPinReadNoWaitMiss: u32,
    CcPinReadWaitMiss: u32,
    CcCopyReadNoWait: u32,
    CcCopyReadWait: u32,
    CcCopyReadNoWaitMiss: u32,
    CcCopyReadWaitMiss: u32,
    CcMdlReadNoWait: u32,
    CcMdlReadWait: u32,
    CcMdlReadNoWaitMiss: u32,
    CcMdlReadWaitMiss: u32,
    CcReadAheadIos: u32,
    CcLazyWriteIos: u32,
    CcLazyWritePages: u32,
    CcDataFlushes: u32,
    CcDataPages: u32,
    ContextSwitches: u32,
    FirstLevelTbFills: u32,
    SecondLevelTbFills: u32,
    SystemCalls: u32,
    CcTotalDirtyPages: u64,
    CcDirtyPageThreshold: u64,
    ResidentAvailablePages: i64,
    SharedCommittedPages: u64,
};

pub const MINIDUMP_SYSTEM_MEMORY_INFO_1 = extern struct {
    Revision: u16,
    Flags: u16,
    BasicInfo: MINIDUMP_SYSTEM_BASIC_INFORMATION,
    FileCacheInfo: MINIDUMP_SYSTEM_FILECACHE_INFORMATION,
    BasicPerfInfo: MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION,
    PerfInfo: MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION,
};

pub const MINIDUMP_PROCESS_VM_COUNTERS_1 = extern struct {
    Revision: u16,
    PageFaultCount: u32,
    PeakWorkingSetSize: u64,
    WorkingSetSize: u64,
    QuotaPeakPagedPoolUsage: u64,
    QuotaPagedPoolUsage: u64,
    QuotaPeakNonPagedPoolUsage: u64,
    QuotaNonPagedPoolUsage: u64,
    PagefileUsage: u64,
    PeakPagefileUsage: u64,
    PrivateUsage: u64,
};

pub const MINIDUMP_PROCESS_VM_COUNTERS_2 = extern struct {
    Revision: u16,
    Flags: u16,
    PageFaultCount: u32,
    PeakWorkingSetSize: u64,
    WorkingSetSize: u64,
    QuotaPeakPagedPoolUsage: u64,
    QuotaPagedPoolUsage: u64,
    QuotaPeakNonPagedPoolUsage: u64,
    QuotaNonPagedPoolUsage: u64,
    PagefileUsage: u64,
    PeakPagefileUsage: u64,
    PeakVirtualSize: u64,
    VirtualSize: u64,
    PrivateUsage: u64,
    PrivateWorkingSetSize: u64,
    SharedCommitUsage: u64,
    JobSharedCommitUsage: u64,
    JobPrivateCommitUsage: u64,
    JobPeakPrivateCommitUsage: u64,
    JobPrivateCommitLimit: u64,
    JobTotalCommitLimit: u64,
};

pub const MINIDUMP_USER_RECORD = extern struct {
    Type: u32,
    Memory: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_USER_STREAM = extern struct {
    Type: u32,
    BufferSize: u32,
    Buffer: *c_void,
};

pub const MINIDUMP_USER_STREAM_INFORMATION = extern struct {
    UserStreamCount: u32,
    UserStreamArray: *MINIDUMP_USER_STREAM,
};

pub const MINIDUMP_CALLBACK_TYPE = extern enum(i32) {
    ModuleCallback = 0,
    ThreadCallback = 1,
    ThreadExCallback = 2,
    IncludeThreadCallback = 3,
    IncludeModuleCallback = 4,
    MemoryCallback = 5,
    CancelCallback = 6,
    WriteKernelMinidumpCallback = 7,
    KernelMinidumpStatusCallback = 8,
    RemoveMemoryCallback = 9,
    IncludeVmRegionCallback = 10,
    IoStartCallback = 11,
    IoWriteAllCallback = 12,
    IoFinishCallback = 13,
    ReadMemoryFailureCallback = 14,
    SecondaryFlagsCallback = 15,
    IsProcessSnapshotCallback = 16,
    VmStartCallback = 17,
    VmQueryCallback = 18,
    VmPreReadCallback = 19,
    VmPostReadCallback = 20,
};
pub const ModuleCallback = MINIDUMP_CALLBACK_TYPE.ModuleCallback;
pub const ThreadCallback = MINIDUMP_CALLBACK_TYPE.ThreadCallback;
pub const ThreadExCallback = MINIDUMP_CALLBACK_TYPE.ThreadExCallback;
pub const IncludeThreadCallback = MINIDUMP_CALLBACK_TYPE.IncludeThreadCallback;
pub const IncludeModuleCallback = MINIDUMP_CALLBACK_TYPE.IncludeModuleCallback;
pub const MemoryCallback = MINIDUMP_CALLBACK_TYPE.MemoryCallback;
pub const CancelCallback = MINIDUMP_CALLBACK_TYPE.CancelCallback;
pub const WriteKernelMinidumpCallback = MINIDUMP_CALLBACK_TYPE.WriteKernelMinidumpCallback;
pub const KernelMinidumpStatusCallback = MINIDUMP_CALLBACK_TYPE.KernelMinidumpStatusCallback;
pub const RemoveMemoryCallback = MINIDUMP_CALLBACK_TYPE.RemoveMemoryCallback;
pub const IncludeVmRegionCallback = MINIDUMP_CALLBACK_TYPE.IncludeVmRegionCallback;
pub const IoStartCallback = MINIDUMP_CALLBACK_TYPE.IoStartCallback;
pub const IoWriteAllCallback = MINIDUMP_CALLBACK_TYPE.IoWriteAllCallback;
pub const IoFinishCallback = MINIDUMP_CALLBACK_TYPE.IoFinishCallback;
pub const ReadMemoryFailureCallback = MINIDUMP_CALLBACK_TYPE.ReadMemoryFailureCallback;
pub const SecondaryFlagsCallback = MINIDUMP_CALLBACK_TYPE.SecondaryFlagsCallback;
pub const IsProcessSnapshotCallback = MINIDUMP_CALLBACK_TYPE.IsProcessSnapshotCallback;
pub const VmStartCallback = MINIDUMP_CALLBACK_TYPE.VmStartCallback;
pub const VmQueryCallback = MINIDUMP_CALLBACK_TYPE.VmQueryCallback;
pub const VmPreReadCallback = MINIDUMP_CALLBACK_TYPE.VmPreReadCallback;
pub const VmPostReadCallback = MINIDUMP_CALLBACK_TYPE.VmPostReadCallback;

pub const MINIDUMP_THREAD_CALLBACK = extern struct {
    ThreadId: u32,
    ThreadHandle: HANDLE,
    Context: CONTEXT,
    SizeOfContext: u32,
    StackBase: u64,
    StackEnd: u64,
};

pub const MINIDUMP_THREAD_EX_CALLBACK = extern struct {
    ThreadId: u32,
    ThreadHandle: HANDLE,
    Context: CONTEXT,
    SizeOfContext: u32,
    StackBase: u64,
    StackEnd: u64,
    BackingStoreBase: u64,
    BackingStoreEnd: u64,
};

pub const MINIDUMP_INCLUDE_THREAD_CALLBACK = extern struct {
    ThreadId: u32,
};

pub const THREAD_WRITE_FLAGS = extern enum(i32) {
    ThreadWriteThread = 1,
    ThreadWriteStack = 2,
    ThreadWriteContext = 4,
    ThreadWriteBackingStore = 8,
    ThreadWriteInstructionWindow = 16,
    ThreadWriteThreadData = 32,
    ThreadWriteThreadInfo = 64,
};
pub const ThreadWriteThread = THREAD_WRITE_FLAGS.ThreadWriteThread;
pub const ThreadWriteStack = THREAD_WRITE_FLAGS.ThreadWriteStack;
pub const ThreadWriteContext = THREAD_WRITE_FLAGS.ThreadWriteContext;
pub const ThreadWriteBackingStore = THREAD_WRITE_FLAGS.ThreadWriteBackingStore;
pub const ThreadWriteInstructionWindow = THREAD_WRITE_FLAGS.ThreadWriteInstructionWindow;
pub const ThreadWriteThreadData = THREAD_WRITE_FLAGS.ThreadWriteThreadData;
pub const ThreadWriteThreadInfo = THREAD_WRITE_FLAGS.ThreadWriteThreadInfo;

pub const MINIDUMP_MODULE_CALLBACK = extern struct {
    FullPath: [*]u16,
    BaseOfImage: u64,
    SizeOfImage: u32,
    CheckSum: u32,
    TimeDateStamp: u32,
    VersionInfo: VS_FIXEDFILEINFO,
    CvRecord: *c_void,
    SizeOfCvRecord: u32,
    MiscRecord: *c_void,
    SizeOfMiscRecord: u32,
};

pub const MINIDUMP_INCLUDE_MODULE_CALLBACK = extern struct {
    BaseOfImage: u64,
};

pub const MODULE_WRITE_FLAGS = extern enum(i32) {
    ModuleWriteModule = 1,
    ModuleWriteDataSeg = 2,
    ModuleWriteMiscRecord = 4,
    ModuleWriteCvRecord = 8,
    ModuleReferencedByMemory = 16,
    ModuleWriteTlsData = 32,
    ModuleWriteCodeSegs = 64,
};
pub const ModuleWriteModule = MODULE_WRITE_FLAGS.ModuleWriteModule;
pub const ModuleWriteDataSeg = MODULE_WRITE_FLAGS.ModuleWriteDataSeg;
pub const ModuleWriteMiscRecord = MODULE_WRITE_FLAGS.ModuleWriteMiscRecord;
pub const ModuleWriteCvRecord = MODULE_WRITE_FLAGS.ModuleWriteCvRecord;
pub const ModuleReferencedByMemory = MODULE_WRITE_FLAGS.ModuleReferencedByMemory;
pub const ModuleWriteTlsData = MODULE_WRITE_FLAGS.ModuleWriteTlsData;
pub const ModuleWriteCodeSegs = MODULE_WRITE_FLAGS.ModuleWriteCodeSegs;

pub const MINIDUMP_IO_CALLBACK = extern struct {
    Handle: HANDLE,
    Offset: u64,
    Buffer: *c_void,
    BufferBytes: u32,
};

pub const MINIDUMP_READ_MEMORY_FAILURE_CALLBACK = extern struct {
    Offset: u64,
    Bytes: u32,
    FailureStatus: HRESULT,
};

pub const MINIDUMP_VM_QUERY_CALLBACK = extern struct {
    Offset: u64,
};

pub const MINIDUMP_VM_PRE_READ_CALLBACK = extern struct {
    Offset: u64,
    Buffer: *c_void,
    Size: u32,
};

pub const MINIDUMP_VM_POST_READ_CALLBACK = extern struct {
    Offset: u64,
    Buffer: *c_void,
    Size: u32,
    Completed: u32,
    Status: HRESULT,
};

pub const MINIDUMP_CALLBACK_INPUT = extern struct {
    ProcessId: u32,
    ProcessHandle: HANDLE,
    CallbackType: u32,
    Anonymous: MINIDUMP_CALLBACK_INPUT._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MINIDUMP_CALLBACK_OUTPUT = extern struct {
    Anonymous: MINIDUMP_CALLBACK_OUTPUT._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const MINIDUMP_TYPE = extern enum(i32) {
    MiniDumpNormal = 0,
    MiniDumpWithDataSegs = 1,
    MiniDumpWithFullMemory = 2,
    MiniDumpWithHandleData = 4,
    MiniDumpFilterMemory = 8,
    MiniDumpScanMemory = 16,
    MiniDumpWithUnloadedModules = 32,
    MiniDumpWithIndirectlyReferencedMemory = 64,
    MiniDumpFilterModulePaths = 128,
    MiniDumpWithProcessThreadData = 256,
    MiniDumpWithPrivateReadWriteMemory = 512,
    MiniDumpWithoutOptionalData = 1024,
    MiniDumpWithFullMemoryInfo = 2048,
    MiniDumpWithThreadInfo = 4096,
    MiniDumpWithCodeSegs = 8192,
    MiniDumpWithoutAuxiliaryState = 16384,
    MiniDumpWithFullAuxiliaryState = 32768,
    MiniDumpWithPrivateWriteCopyMemory = 65536,
    MiniDumpIgnoreInaccessibleMemory = 131072,
    MiniDumpWithTokenInformation = 262144,
    MiniDumpWithModuleHeaders = 524288,
    MiniDumpFilterTriage = 1048576,
    MiniDumpWithAvxXStateContext = 2097152,
    MiniDumpWithIptTrace = 4194304,
    MiniDumpScanInaccessiblePartialPages = 8388608,
    MiniDumpValidTypeFlags = 16777215,
};
pub const MiniDumpNormal = MINIDUMP_TYPE.MiniDumpNormal;
pub const MiniDumpWithDataSegs = MINIDUMP_TYPE.MiniDumpWithDataSegs;
pub const MiniDumpWithFullMemory = MINIDUMP_TYPE.MiniDumpWithFullMemory;
pub const MiniDumpWithHandleData = MINIDUMP_TYPE.MiniDumpWithHandleData;
pub const MiniDumpFilterMemory = MINIDUMP_TYPE.MiniDumpFilterMemory;
pub const MiniDumpScanMemory = MINIDUMP_TYPE.MiniDumpScanMemory;
pub const MiniDumpWithUnloadedModules = MINIDUMP_TYPE.MiniDumpWithUnloadedModules;
pub const MiniDumpWithIndirectlyReferencedMemory = MINIDUMP_TYPE.MiniDumpWithIndirectlyReferencedMemory;
pub const MiniDumpFilterModulePaths = MINIDUMP_TYPE.MiniDumpFilterModulePaths;
pub const MiniDumpWithProcessThreadData = MINIDUMP_TYPE.MiniDumpWithProcessThreadData;
pub const MiniDumpWithPrivateReadWriteMemory = MINIDUMP_TYPE.MiniDumpWithPrivateReadWriteMemory;
pub const MiniDumpWithoutOptionalData = MINIDUMP_TYPE.MiniDumpWithoutOptionalData;
pub const MiniDumpWithFullMemoryInfo = MINIDUMP_TYPE.MiniDumpWithFullMemoryInfo;
pub const MiniDumpWithThreadInfo = MINIDUMP_TYPE.MiniDumpWithThreadInfo;
pub const MiniDumpWithCodeSegs = MINIDUMP_TYPE.MiniDumpWithCodeSegs;
pub const MiniDumpWithoutAuxiliaryState = MINIDUMP_TYPE.MiniDumpWithoutAuxiliaryState;
pub const MiniDumpWithFullAuxiliaryState = MINIDUMP_TYPE.MiniDumpWithFullAuxiliaryState;
pub const MiniDumpWithPrivateWriteCopyMemory = MINIDUMP_TYPE.MiniDumpWithPrivateWriteCopyMemory;
pub const MiniDumpIgnoreInaccessibleMemory = MINIDUMP_TYPE.MiniDumpIgnoreInaccessibleMemory;
pub const MiniDumpWithTokenInformation = MINIDUMP_TYPE.MiniDumpWithTokenInformation;
pub const MiniDumpWithModuleHeaders = MINIDUMP_TYPE.MiniDumpWithModuleHeaders;
pub const MiniDumpFilterTriage = MINIDUMP_TYPE.MiniDumpFilterTriage;
pub const MiniDumpWithAvxXStateContext = MINIDUMP_TYPE.MiniDumpWithAvxXStateContext;
pub const MiniDumpWithIptTrace = MINIDUMP_TYPE.MiniDumpWithIptTrace;
pub const MiniDumpScanInaccessiblePartialPages = MINIDUMP_TYPE.MiniDumpScanInaccessiblePartialPages;
pub const MiniDumpValidTypeFlags = MINIDUMP_TYPE.MiniDumpValidTypeFlags;

pub const MINIDUMP_SECONDARY_FLAGS = extern enum(i32) {
    MiniSecondaryWithoutPowerInfo = 1,
    MiniSecondaryValidFlags = 1,
};
pub const MiniSecondaryWithoutPowerInfo = MINIDUMP_SECONDARY_FLAGS.MiniSecondaryWithoutPowerInfo;
pub const MiniSecondaryValidFlags = MINIDUMP_SECONDARY_FLAGS.MiniSecondaryValidFlags;

pub const MINIDUMP_CALLBACK_ROUTINE = fn(
    CallbackParam: *c_void,
    CallbackInput: *MINIDUMP_CALLBACK_INPUT,
    CallbackOutput: *MINIDUMP_CALLBACK_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const MINIDUMP_CALLBACK_INFORMATION = extern struct {
    CallbackRoutine: MINIDUMP_CALLBACK_ROUTINE,
    CallbackParam: *c_void,
};

const CLSID_ProcessDebugManager_Value = @import("../zig.zig").Guid.initString("78A51822-51F4-11D0-8F20-00805F2CD064");
pub const CLSID_ProcessDebugManager = &CLSID_ProcessDebugManager_Value;

const CLSID_DebugHelper_Value = @import("../zig.zig").Guid.initString("0BFCC060-8C1D-11D0-ACCD-00AA0060275C");
pub const CLSID_DebugHelper = &CLSID_DebugHelper_Value;

const CLSID_CDebugDocumentHelper_Value = @import("../zig.zig").Guid.initString("83B8BCA6-687C-11D0-A405-00AA0060275C");
pub const CLSID_CDebugDocumentHelper = &CLSID_CDebugDocumentHelper_Value;

const CLSID_MachineDebugManager_RETAIL_Value = @import("../zig.zig").Guid.initString("0C0A3666-30C9-11D0-8F20-00805F2CD064");
pub const CLSID_MachineDebugManager_RETAIL = &CLSID_MachineDebugManager_RETAIL_Value;

const CLSID_MachineDebugManager_DEBUG_Value = @import("../zig.zig").Guid.initString("49769CEC-3A55-4BB0-B697-88FEDE77E8EA");
pub const CLSID_MachineDebugManager_DEBUG = &CLSID_MachineDebugManager_DEBUG_Value;

const CLSID_DefaultDebugSessionProvider_Value = @import("../zig.zig").Guid.initString("834128A2-51F4-11D0-8F20-00805F2CD064");
pub const CLSID_DefaultDebugSessionProvider = &CLSID_DefaultDebugSessionProvider_Value;

pub const SCRIPTLANGUAGEVERSION = extern enum(i32) {
    DEFAULT = 0,
    _5_7 = 1,
    _5_8 = 2,
    MAX = 255,
};
pub const SCRIPTLANGUAGEVERSION_DEFAULT = SCRIPTLANGUAGEVERSION.DEFAULT;
pub const SCRIPTLANGUAGEVERSION_5_7 = SCRIPTLANGUAGEVERSION._5_7;
pub const SCRIPTLANGUAGEVERSION_5_8 = SCRIPTLANGUAGEVERSION._5_8;
pub const SCRIPTLANGUAGEVERSION_MAX = SCRIPTLANGUAGEVERSION.MAX;

pub const SCRIPTSTATE = extern enum(i32) {
    UNINITIALIZED = 0,
    INITIALIZED = 5,
    STARTED = 1,
    CONNECTED = 2,
    DISCONNECTED = 3,
    CLOSED = 4,
};
pub const SCRIPTSTATE_UNINITIALIZED = SCRIPTSTATE.UNINITIALIZED;
pub const SCRIPTSTATE_INITIALIZED = SCRIPTSTATE.INITIALIZED;
pub const SCRIPTSTATE_STARTED = SCRIPTSTATE.STARTED;
pub const SCRIPTSTATE_CONNECTED = SCRIPTSTATE.CONNECTED;
pub const SCRIPTSTATE_DISCONNECTED = SCRIPTSTATE.DISCONNECTED;
pub const SCRIPTSTATE_CLOSED = SCRIPTSTATE.CLOSED;

pub const SCRIPTTRACEINFO = extern enum(i32) {
    SCRIPTSTART = 0,
    SCRIPTEND = 1,
    COMCALLSTART = 2,
    COMCALLEND = 3,
    CREATEOBJSTART = 4,
    CREATEOBJEND = 5,
    GETOBJSTART = 6,
    GETOBJEND = 7,
};
pub const SCRIPTTRACEINFO_SCRIPTSTART = SCRIPTTRACEINFO.SCRIPTSTART;
pub const SCRIPTTRACEINFO_SCRIPTEND = SCRIPTTRACEINFO.SCRIPTEND;
pub const SCRIPTTRACEINFO_COMCALLSTART = SCRIPTTRACEINFO.COMCALLSTART;
pub const SCRIPTTRACEINFO_COMCALLEND = SCRIPTTRACEINFO.COMCALLEND;
pub const SCRIPTTRACEINFO_CREATEOBJSTART = SCRIPTTRACEINFO.CREATEOBJSTART;
pub const SCRIPTTRACEINFO_CREATEOBJEND = SCRIPTTRACEINFO.CREATEOBJEND;
pub const SCRIPTTRACEINFO_GETOBJSTART = SCRIPTTRACEINFO.GETOBJSTART;
pub const SCRIPTTRACEINFO_GETOBJEND = SCRIPTTRACEINFO.GETOBJEND;

pub const SCRIPTTHREADSTATE = extern enum(i32) {
    NOTINSCRIPT = 0,
    RUNNING = 1,
};
pub const SCRIPTTHREADSTATE_NOTINSCRIPT = SCRIPTTHREADSTATE.NOTINSCRIPT;
pub const SCRIPTTHREADSTATE_RUNNING = SCRIPTTHREADSTATE.RUNNING;

pub const SCRIPTGCTYPE = extern enum(i32) {
    NORMAL = 0,
    EXHAUSTIVE = 1,
};
pub const SCRIPTGCTYPE_NORMAL = SCRIPTGCTYPE.NORMAL;
pub const SCRIPTGCTYPE_EXHAUSTIVE = SCRIPTGCTYPE.EXHAUSTIVE;

pub const SCRIPTUICITEM = extern enum(i32) {
    INPUTBOX = 1,
    MSGBOX = 2,
};
pub const SCRIPTUICITEM_INPUTBOX = SCRIPTUICITEM.INPUTBOX;
pub const SCRIPTUICITEM_MSGBOX = SCRIPTUICITEM.MSGBOX;

pub const SCRIPTUICHANDLING = extern enum(i32) {
    ALLOW = 0,
    NOUIERROR = 1,
    NOUIDEFAULT = 2,
};
pub const SCRIPTUICHANDLING_ALLOW = SCRIPTUICHANDLING.ALLOW;
pub const SCRIPTUICHANDLING_NOUIERROR = SCRIPTUICHANDLING.NOUIERROR;
pub const SCRIPTUICHANDLING_NOUIDEFAULT = SCRIPTUICHANDLING.NOUIDEFAULT;

const IID_IActiveScriptSite_Value = @import("../zig.zig").Guid.initString("DB01A1E3-A42B-11CF-8F20-00805F2CD064");
pub const IID_IActiveScriptSite = &IID_IActiveScriptSite_Value;
pub const IActiveScriptSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLCID: fn(
            self: *const IActiveScriptSite,
            plcid: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemInfo: fn(
            self: *const IActiveScriptSite,
            pstrName: [*:0]const u16,
            dwReturnMask: u32,
            ppiunkItem: **IUnknown,
            ppti: **ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocVersionString: fn(
            self: *const IActiveScriptSite,
            pbstrVersion: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnScriptTerminate: fn(
            self: *const IActiveScriptSite,
            pvarResult: *const VARIANT,
            pexcepinfo: *const EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStateChange: fn(
            self: *const IActiveScriptSite,
            ssScriptState: SCRIPTSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnScriptError: fn(
            self: *const IActiveScriptSite,
            pscripterror: *IActiveScriptError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEnterScript: fn(
            self: *const IActiveScriptSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLeaveScript: fn(
            self: *const IActiveScriptSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_GetLCID(self: *const T, plcid: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).GetLCID(@ptrCast(*const IActiveScriptSite, self), plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_GetItemInfo(self: *const T, pstrName: [*:0]const u16, dwReturnMask: u32, ppiunkItem: **IUnknown, ppti: **ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).GetItemInfo(@ptrCast(*const IActiveScriptSite, self), pstrName, dwReturnMask, ppiunkItem, ppti);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_GetDocVersionString(self: *const T, pbstrVersion: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).GetDocVersionString(@ptrCast(*const IActiveScriptSite, self), pbstrVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnScriptTerminate(self: *const T, pvarResult: *const VARIANT, pexcepinfo: *const EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnScriptTerminate(@ptrCast(*const IActiveScriptSite, self), pvarResult, pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnStateChange(self: *const T, ssScriptState: SCRIPTSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnStateChange(@ptrCast(*const IActiveScriptSite, self), ssScriptState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnScriptError(self: *const T, pscripterror: *IActiveScriptError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnScriptError(@ptrCast(*const IActiveScriptSite, self), pscripterror);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnEnterScript(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnEnterScript(@ptrCast(*const IActiveScriptSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnLeaveScript(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnLeaveScript(@ptrCast(*const IActiveScriptSite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptError_Value = @import("../zig.zig").Guid.initString("EAE1BA61-A4ED-11CF-8F20-00805F2CD064");
pub const IID_IActiveScriptError = &IID_IActiveScriptError_Value;
pub const IActiveScriptError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetExceptionInfo: fn(
            self: *const IActiveScriptError,
            pexcepinfo: *EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePosition: fn(
            self: *const IActiveScriptError,
            pdwSourceContext: *u32,
            pulLineNumber: *u32,
            plCharacterPosition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceLineText: fn(
            self: *const IActiveScriptError,
            pbstrSourceLine: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError_GetExceptionInfo(self: *const T, pexcepinfo: *EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptError.VTable, self.vtable).GetExceptionInfo(@ptrCast(*const IActiveScriptError, self), pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError_GetSourcePosition(self: *const T, pdwSourceContext: *u32, pulLineNumber: *u32, plCharacterPosition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptError.VTable, self.vtable).GetSourcePosition(@ptrCast(*const IActiveScriptError, self), pdwSourceContext, pulLineNumber, plCharacterPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError_GetSourceLineText(self: *const T, pbstrSourceLine: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptError.VTable, self.vtable).GetSourceLineText(@ptrCast(*const IActiveScriptError, self), pbstrSourceLine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptError64_Value = @import("../zig.zig").Guid.initString("B21FB2A1-5B8F-4963-8C21-21450F84ED7F");
pub const IID_IActiveScriptError64 = &IID_IActiveScriptError64_Value;
pub const IActiveScriptError64 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetSourcePosition64: fn(
            self: *const IActiveScriptError64,
            pdwSourceContext: *u64,
            pulLineNumber: *u32,
            plCharacterPosition: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptError.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError64_GetSourcePosition64(self: *const T, pdwSourceContext: *u64, pulLineNumber: *u32, plCharacterPosition: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptError64.VTable, self.vtable).GetSourcePosition64(@ptrCast(*const IActiveScriptError64, self), pdwSourceContext, pulLineNumber, plCharacterPosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteWindow_Value = @import("../zig.zig").Guid.initString("D10F6761-83E9-11CF-8F20-00805F2CD064");
pub const IID_IActiveScriptSiteWindow = &IID_IActiveScriptSiteWindow_Value;
pub const IActiveScriptSiteWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: fn(
            self: *const IActiveScriptSiteWindow,
            phwnd: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableModeless: fn(
            self: *const IActiveScriptSiteWindow,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteWindow_GetWindow(self: *const T, phwnd: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteWindow.VTable, self.vtable).GetWindow(@ptrCast(*const IActiveScriptSiteWindow, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteWindow_EnableModeless(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteWindow.VTable, self.vtable).EnableModeless(@ptrCast(*const IActiveScriptSiteWindow, self), fEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteUIControl_Value = @import("../zig.zig").Guid.initString("AEDAE97E-D7EE-4796-B960-7F092AE844AB");
pub const IID_IActiveScriptSiteUIControl = &IID_IActiveScriptSiteUIControl_Value;
pub const IActiveScriptSiteUIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUIBehavior: fn(
            self: *const IActiveScriptSiteUIControl,
            UicItem: SCRIPTUICITEM,
            pUicHandling: *SCRIPTUICHANDLING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteUIControl_GetUIBehavior(self: *const T, UicItem: SCRIPTUICITEM, pUicHandling: *SCRIPTUICHANDLING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteUIControl.VTable, self.vtable).GetUIBehavior(@ptrCast(*const IActiveScriptSiteUIControl, self), UicItem, pUicHandling);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteInterruptPoll_Value = @import("../zig.zig").Guid.initString("539698A0-CDCA-11CF-A5EB-00AA0047A063");
pub const IID_IActiveScriptSiteInterruptPoll = &IID_IActiveScriptSiteInterruptPoll_Value;
pub const IActiveScriptSiteInterruptPoll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContinue: fn(
            self: *const IActiveScriptSiteInterruptPoll,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteInterruptPoll_QueryContinue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteInterruptPoll.VTable, self.vtable).QueryContinue(@ptrCast(*const IActiveScriptSiteInterruptPoll, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScript_Value = @import("../zig.zig").Guid.initString("BB1A2AE1-A4F9-11CF-8F20-00805F2CD064");
pub const IID_IActiveScript = &IID_IActiveScript_Value;
pub const IActiveScript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetScriptSite: fn(
            self: *const IActiveScript,
            pass: *IActiveScriptSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptSite: fn(
            self: *const IActiveScript,
            riid: *const Guid,
            ppvObject: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScriptState: fn(
            self: *const IActiveScript,
            ss: SCRIPTSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptState: fn(
            self: *const IActiveScript,
            pssState: *SCRIPTSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IActiveScript,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddNamedItem: fn(
            self: *const IActiveScript,
            pstrName: [*:0]const u16,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTypeLib: fn(
            self: *const IActiveScript,
            rguidTypeLib: *const Guid,
            dwMajor: u32,
            dwMinor: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptDispatch: fn(
            self: *const IActiveScript,
            pstrItemName: [*:0]const u16,
            ppdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentScriptThreadID: fn(
            self: *const IActiveScript,
            pstidThread: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptThreadID: fn(
            self: *const IActiveScript,
            dwWin32ThreadId: u32,
            pstidThread: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptThreadState: fn(
            self: *const IActiveScript,
            stidThread: u32,
            pstsState: *SCRIPTTHREADSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InterruptScriptThread: fn(
            self: *const IActiveScript,
            stidThread: u32,
            pexcepinfo: *const EXCEPINFO,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IActiveScript,
            ppscript: **IActiveScript,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_SetScriptSite(self: *const T, pass: *IActiveScriptSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).SetScriptSite(@ptrCast(*const IActiveScript, self), pass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptSite(self: *const T, riid: *const Guid, ppvObject: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptSite(@ptrCast(*const IActiveScript, self), riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_SetScriptState(self: *const T, ss: SCRIPTSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).SetScriptState(@ptrCast(*const IActiveScript, self), ss);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptState(self: *const T, pssState: *SCRIPTSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptState(@ptrCast(*const IActiveScript, self), pssState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).Close(@ptrCast(*const IActiveScript, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_AddNamedItem(self: *const T, pstrName: [*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).AddNamedItem(@ptrCast(*const IActiveScript, self), pstrName, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_AddTypeLib(self: *const T, rguidTypeLib: *const Guid, dwMajor: u32, dwMinor: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).AddTypeLib(@ptrCast(*const IActiveScript, self), rguidTypeLib, dwMajor, dwMinor, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptDispatch(self: *const T, pstrItemName: [*:0]const u16, ppdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptDispatch(@ptrCast(*const IActiveScript, self), pstrItemName, ppdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetCurrentScriptThreadID(self: *const T, pstidThread: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetCurrentScriptThreadID(@ptrCast(*const IActiveScript, self), pstidThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptThreadID(self: *const T, dwWin32ThreadId: u32, pstidThread: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptThreadID(@ptrCast(*const IActiveScript, self), dwWin32ThreadId, pstidThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptThreadState(self: *const T, stidThread: u32, pstsState: *SCRIPTTHREADSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptThreadState(@ptrCast(*const IActiveScript, self), stidThread, pstsState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_InterruptScriptThread(self: *const T, stidThread: u32, pexcepinfo: *const EXCEPINFO, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).InterruptScriptThread(@ptrCast(*const IActiveScript, self), stidThread, pexcepinfo, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_Clone(self: *const T, ppscript: **IActiveScript) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).Clone(@ptrCast(*const IActiveScript, self), ppscript);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParse32_Value = @import("../zig.zig").Guid.initString("BB1A2AE2-A4F9-11CF-8F20-00805F2CD064");
pub const IID_IActiveScriptParse32 = &IID_IActiveScriptParse32_Value;
pub const IActiveScriptParse32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitNew: fn(
            self: *const IActiveScriptParse32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddScriptlet: fn(
            self: *const IActiveScriptParse32,
            pstrDefaultName: [*:0]const u16,
            pstrCode: [*:0]const u16,
            pstrItemName: [*:0]const u16,
            pstrSubItemName: [*:0]const u16,
            pstrEventName: [*:0]const u16,
            pstrDelimiter: [*:0]const u16,
            dwSourceContextCookie: u32,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            pbstrName: *BSTR,
            pexcepinfo: *EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseScriptText: fn(
            self: *const IActiveScriptParse32,
            pstrCode: [*:0]const u16,
            pstrItemName: [*:0]const u16,
            punkContext: *IUnknown,
            pstrDelimiter: [*:0]const u16,
            dwSourceContextCookie: u32,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            pvarResult: *VARIANT,
            pexcepinfo: *EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse32_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse32.VTable, self.vtable).InitNew(@ptrCast(*const IActiveScriptParse32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse32_AddScriptlet(self: *const T, pstrDefaultName: [*:0]const u16, pstrCode: [*:0]const u16, pstrItemName: [*:0]const u16, pstrSubItemName: [*:0]const u16, pstrEventName: [*:0]const u16, pstrDelimiter: [*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, pbstrName: *BSTR, pexcepinfo: *EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse32.VTable, self.vtable).AddScriptlet(@ptrCast(*const IActiveScriptParse32, self), pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pbstrName, pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse32_ParseScriptText(self: *const T, pstrCode: [*:0]const u16, pstrItemName: [*:0]const u16, punkContext: *IUnknown, pstrDelimiter: [*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, pvarResult: *VARIANT, pexcepinfo: *EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse32.VTable, self.vtable).ParseScriptText(@ptrCast(*const IActiveScriptParse32, self), pstrCode, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pvarResult, pexcepinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParse64_Value = @import("../zig.zig").Guid.initString("C7EF7658-E1EE-480E-97EA-D52CB4D76D17");
pub const IID_IActiveScriptParse64 = &IID_IActiveScriptParse64_Value;
pub const IActiveScriptParse64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitNew: fn(
            self: *const IActiveScriptParse64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddScriptlet: fn(
            self: *const IActiveScriptParse64,
            pstrDefaultName: [*:0]const u16,
            pstrCode: [*:0]const u16,
            pstrItemName: [*:0]const u16,
            pstrSubItemName: [*:0]const u16,
            pstrEventName: [*:0]const u16,
            pstrDelimiter: [*:0]const u16,
            dwSourceContextCookie: u64,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            pbstrName: *BSTR,
            pexcepinfo: *EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseScriptText: fn(
            self: *const IActiveScriptParse64,
            pstrCode: [*:0]const u16,
            pstrItemName: [*:0]const u16,
            punkContext: *IUnknown,
            pstrDelimiter: [*:0]const u16,
            dwSourceContextCookie: u64,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            pvarResult: *VARIANT,
            pexcepinfo: *EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse64_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse64.VTable, self.vtable).InitNew(@ptrCast(*const IActiveScriptParse64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse64_AddScriptlet(self: *const T, pstrDefaultName: [*:0]const u16, pstrCode: [*:0]const u16, pstrItemName: [*:0]const u16, pstrSubItemName: [*:0]const u16, pstrEventName: [*:0]const u16, pstrDelimiter: [*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, pbstrName: *BSTR, pexcepinfo: *EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse64.VTable, self.vtable).AddScriptlet(@ptrCast(*const IActiveScriptParse64, self), pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pbstrName, pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse64_ParseScriptText(self: *const T, pstrCode: [*:0]const u16, pstrItemName: [*:0]const u16, punkContext: *IUnknown, pstrDelimiter: [*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, pvarResult: *VARIANT, pexcepinfo: *EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse64.VTable, self.vtable).ParseScriptText(@ptrCast(*const IActiveScriptParse64, self), pstrCode, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pvarResult, pexcepinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedureOld32_Value = @import("../zig.zig").Guid.initString("1CFF0050-6FDD-11D0-9328-00A0C90DCAA9");
pub const IID_IActiveScriptParseProcedureOld32 = &IID_IActiveScriptParseProcedureOld32_Value;
pub const IActiveScriptParseProcedureOld32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: fn(
            self: *const IActiveScriptParseProcedureOld32,
            pstrCode: [*:0]const u16,
            pstrFormalParams: [*:0]const u16,
            pstrItemName: [*:0]const u16,
            punkContext: *IUnknown,
            pstrDelimiter: [*:0]const u16,
            dwSourceContextCookie: u32,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            ppdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedureOld32_ParseProcedureText(self: *const T, pstrCode: [*:0]const u16, pstrFormalParams: [*:0]const u16, pstrItemName: [*:0]const u16, punkContext: *IUnknown, pstrDelimiter: [*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParseProcedureOld32.VTable, self.vtable).ParseProcedureText(@ptrCast(*const IActiveScriptParseProcedureOld32, self), pstrCode, pstrFormalParams, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedureOld64_Value = @import("../zig.zig").Guid.initString("21F57128-08C9-4638-BA12-22D15D88DC5C");
pub const IID_IActiveScriptParseProcedureOld64 = &IID_IActiveScriptParseProcedureOld64_Value;
pub const IActiveScriptParseProcedureOld64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: fn(
            self: *const IActiveScriptParseProcedureOld64,
            pstrCode: [*:0]const u16,
            pstrFormalParams: [*:0]const u16,
            pstrItemName: [*:0]const u16,
            punkContext: *IUnknown,
            pstrDelimiter: [*:0]const u16,
            dwSourceContextCookie: u64,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            ppdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedureOld64_ParseProcedureText(self: *const T, pstrCode: [*:0]const u16, pstrFormalParams: [*:0]const u16, pstrItemName: [*:0]const u16, punkContext: *IUnknown, pstrDelimiter: [*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParseProcedureOld64.VTable, self.vtable).ParseProcedureText(@ptrCast(*const IActiveScriptParseProcedureOld64, self), pstrCode, pstrFormalParams, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure32_Value = @import("../zig.zig").Guid.initString("AA5B6A80-B834-11D0-932F-00A0C90DCAA9");
pub const IID_IActiveScriptParseProcedure32 = &IID_IActiveScriptParseProcedure32_Value;
pub const IActiveScriptParseProcedure32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: fn(
            self: *const IActiveScriptParseProcedure32,
            pstrCode: [*:0]const u16,
            pstrFormalParams: [*:0]const u16,
            pstrProcedureName: [*:0]const u16,
            pstrItemName: [*:0]const u16,
            punkContext: *IUnknown,
            pstrDelimiter: [*:0]const u16,
            dwSourceContextCookie: u32,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            ppdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedure32_ParseProcedureText(self: *const T, pstrCode: [*:0]const u16, pstrFormalParams: [*:0]const u16, pstrProcedureName: [*:0]const u16, pstrItemName: [*:0]const u16, punkContext: *IUnknown, pstrDelimiter: [*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParseProcedure32.VTable, self.vtable).ParseProcedureText(@ptrCast(*const IActiveScriptParseProcedure32, self), pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure64_Value = @import("../zig.zig").Guid.initString("C64713B6-E029-4CC5-9200-438B72890B6A");
pub const IID_IActiveScriptParseProcedure64 = &IID_IActiveScriptParseProcedure64_Value;
pub const IActiveScriptParseProcedure64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: fn(
            self: *const IActiveScriptParseProcedure64,
            pstrCode: [*:0]const u16,
            pstrFormalParams: [*:0]const u16,
            pstrProcedureName: [*:0]const u16,
            pstrItemName: [*:0]const u16,
            punkContext: *IUnknown,
            pstrDelimiter: [*:0]const u16,
            dwSourceContextCookie: u64,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            ppdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedure64_ParseProcedureText(self: *const T, pstrCode: [*:0]const u16, pstrFormalParams: [*:0]const u16, pstrProcedureName: [*:0]const u16, pstrItemName: [*:0]const u16, punkContext: *IUnknown, pstrDelimiter: [*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParseProcedure64.VTable, self.vtable).ParseProcedureText(@ptrCast(*const IActiveScriptParseProcedure64, self), pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure2_32_Value = @import("../zig.zig").Guid.initString("71EE5B20-FB04-11D1-B3A8-00A0C911E8B2");
pub const IID_IActiveScriptParseProcedure2_32 = &IID_IActiveScriptParseProcedure2_32_Value;
pub const IActiveScriptParseProcedure2_32 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptParseProcedure32.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptParseProcedure32.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure2_64_Value = @import("../zig.zig").Guid.initString("FE7C4271-210C-448D-9F54-76DAB7047B28");
pub const IID_IActiveScriptParseProcedure2_64 = &IID_IActiveScriptParseProcedure2_64_Value;
pub const IActiveScriptParseProcedure2_64 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptParseProcedure64.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptParseProcedure64.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptEncode_Value = @import("../zig.zig").Guid.initString("BB1A2AE3-A4F9-11CF-8F20-00805F2CD064");
pub const IID_IActiveScriptEncode = &IID_IActiveScriptEncode_Value;
pub const IActiveScriptEncode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncodeSection: fn(
            self: *const IActiveScriptEncode,
            pchIn: [*:0]const u16,
            cchIn: u32,
            pchOut: PWSTR,
            cchOut: u32,
            pcchRet: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecodeScript: fn(
            self: *const IActiveScriptEncode,
            pchIn: [*:0]const u16,
            cchIn: u32,
            pchOut: PWSTR,
            cchOut: u32,
            pcchRet: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEncodeProgId: fn(
            self: *const IActiveScriptEncode,
            pbstrOut: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptEncode_EncodeSection(self: *const T, pchIn: [*:0]const u16, cchIn: u32, pchOut: PWSTR, cchOut: u32, pcchRet: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptEncode.VTable, self.vtable).EncodeSection(@ptrCast(*const IActiveScriptEncode, self), pchIn, cchIn, pchOut, cchOut, pcchRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptEncode_DecodeScript(self: *const T, pchIn: [*:0]const u16, cchIn: u32, pchOut: PWSTR, cchOut: u32, pcchRet: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptEncode.VTable, self.vtable).DecodeScript(@ptrCast(*const IActiveScriptEncode, self), pchIn, cchIn, pchOut, cchOut, pcchRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptEncode_GetEncodeProgId(self: *const T, pbstrOut: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptEncode.VTable, self.vtable).GetEncodeProgId(@ptrCast(*const IActiveScriptEncode, self), pbstrOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptHostEncode_Value = @import("../zig.zig").Guid.initString("BEE9B76E-CFE3-11D1-B747-00C04FC2B085");
pub const IID_IActiveScriptHostEncode = &IID_IActiveScriptHostEncode_Value;
pub const IActiveScriptHostEncode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncodeScriptHostFile: fn(
            self: *const IActiveScriptHostEncode,
            bstrInFile: BSTR,
            pbstrOutFile: *BSTR,
            cFlags: u32,
            bstrDefaultLang: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptHostEncode_EncodeScriptHostFile(self: *const T, bstrInFile: BSTR, pbstrOutFile: *BSTR, cFlags: u32, bstrDefaultLang: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptHostEncode.VTable, self.vtable).EncodeScriptHostFile(@ptrCast(*const IActiveScriptHostEncode, self), bstrInFile, pbstrOutFile, cFlags, bstrDefaultLang);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindEventHandler_Value = @import("../zig.zig").Guid.initString("63CDBCB0-C1B1-11D0-9336-00A0C90DCAA9");
pub const IID_IBindEventHandler = &IID_IBindEventHandler_Value;
pub const IBindEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindHandler: fn(
            self: *const IBindEventHandler,
            pstrEvent: [*:0]const u16,
            pdisp: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindEventHandler_BindHandler(self: *const T, pstrEvent: [*:0]const u16, pdisp: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindEventHandler.VTable, self.vtable).BindHandler(@ptrCast(*const IBindEventHandler, self), pstrEvent, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptStats_Value = @import("../zig.zig").Guid.initString("B8DA6310-E19B-11D0-933C-00A0C90DCAA9");
pub const IID_IActiveScriptStats = &IID_IActiveScriptStats_Value;
pub const IActiveScriptStats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStat: fn(
            self: *const IActiveScriptStats,
            stid: u32,
            pluHi: *u32,
            pluLo: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatEx: fn(
            self: *const IActiveScriptStats,
            guid: *const Guid,
            pluHi: *u32,
            pluLo: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetStats: fn(
            self: *const IActiveScriptStats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStats_GetStat(self: *const T, stid: u32, pluHi: *u32, pluLo: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptStats.VTable, self.vtable).GetStat(@ptrCast(*const IActiveScriptStats, self), stid, pluHi, pluLo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStats_GetStatEx(self: *const T, guid: *const Guid, pluHi: *u32, pluLo: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptStats.VTable, self.vtable).GetStatEx(@ptrCast(*const IActiveScriptStats, self), guid, pluHi, pluLo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStats_ResetStats(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptStats.VTable, self.vtable).ResetStats(@ptrCast(*const IActiveScriptStats, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProperty_Value = @import("../zig.zig").Guid.initString("4954E0D0-FBC7-11D1-8410-006008C3FBFC");
pub const IID_IActiveScriptProperty = &IID_IActiveScriptProperty_Value;
pub const IActiveScriptProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: fn(
            self: *const IActiveScriptProperty,
            dwProperty: u32,
            pvarIndex: *VARIANT,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IActiveScriptProperty,
            dwProperty: u32,
            pvarIndex: *VARIANT,
            pvarValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProperty_GetProperty(self: *const T, dwProperty: u32, pvarIndex: *VARIANT, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProperty.VTable, self.vtable).GetProperty(@ptrCast(*const IActiveScriptProperty, self), dwProperty, pvarIndex, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProperty_SetProperty(self: *const T, dwProperty: u32, pvarIndex: *VARIANT, pvarValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProperty.VTable, self.vtable).SetProperty(@ptrCast(*const IActiveScriptProperty, self), dwProperty, pvarIndex, pvarValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITridentEventSink_Value = @import("../zig.zig").Guid.initString("1DC9CA50-06EF-11D2-8415-006008C3FBFC");
pub const IID_ITridentEventSink = &IID_ITridentEventSink_Value;
pub const ITridentEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireEvent: fn(
            self: *const ITridentEventSink,
            pstrEvent: [*:0]const u16,
            pdp: *DISPPARAMS,
            pvarRes: *VARIANT,
            pei: *EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITridentEventSink_FireEvent(self: *const T, pstrEvent: [*:0]const u16, pdp: *DISPPARAMS, pvarRes: *VARIANT, pei: *EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITridentEventSink.VTable, self.vtable).FireEvent(@ptrCast(*const ITridentEventSink, self), pstrEvent, pdp, pvarRes, pei);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptGarbageCollector_Value = @import("../zig.zig").Guid.initString("6AA2C4A0-2B53-11D4-A2A0-00104BD35090");
pub const IID_IActiveScriptGarbageCollector = &IID_IActiveScriptGarbageCollector_Value;
pub const IActiveScriptGarbageCollector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CollectGarbage: fn(
            self: *const IActiveScriptGarbageCollector,
            scriptgctype: SCRIPTGCTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptGarbageCollector_CollectGarbage(self: *const T, scriptgctype: SCRIPTGCTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptGarbageCollector.VTable, self.vtable).CollectGarbage(@ptrCast(*const IActiveScriptGarbageCollector, self), scriptgctype);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSIPInfo_Value = @import("../zig.zig").Guid.initString("764651D0-38DE-11D4-A2A3-00104BD35090");
pub const IID_IActiveScriptSIPInfo = &IID_IActiveScriptSIPInfo_Value;
pub const IActiveScriptSIPInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSIPOID: fn(
            self: *const IActiveScriptSIPInfo,
            poid_sip: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSIPInfo_GetSIPOID(self: *const T, poid_sip: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSIPInfo.VTable, self.vtable).GetSIPOID(@ptrCast(*const IActiveScriptSIPInfo, self), poid_sip);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteTraceInfo_Value = @import("../zig.zig").Guid.initString("4B7272AE-1955-4BFE-98B0-780621888569");
pub const IID_IActiveScriptSiteTraceInfo = &IID_IActiveScriptSiteTraceInfo_Value;
pub const IActiveScriptSiteTraceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SendScriptTraceInfo: fn(
            self: *const IActiveScriptSiteTraceInfo,
            stiEventType: SCRIPTTRACEINFO,
            guidContextID: Guid,
            dwScriptContextCookie: u32,
            lScriptStatementStart: i32,
            lScriptStatementEnd: i32,
            dwReserved: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteTraceInfo_SendScriptTraceInfo(self: *const T, stiEventType: SCRIPTTRACEINFO, guidContextID: Guid, dwScriptContextCookie: u32, lScriptStatementStart: i32, lScriptStatementEnd: i32, dwReserved: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteTraceInfo.VTable, self.vtable).SendScriptTraceInfo(@ptrCast(*const IActiveScriptSiteTraceInfo, self), stiEventType, guidContextID, dwScriptContextCookie, lScriptStatementStart, lScriptStatementEnd, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptTraceInfo_Value = @import("../zig.zig").Guid.initString("C35456E7-BEBF-4A1B-86A9-24D56BE8B369");
pub const IID_IActiveScriptTraceInfo = &IID_IActiveScriptTraceInfo_Value;
pub const IActiveScriptTraceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartScriptTracing: fn(
            self: *const IActiveScriptTraceInfo,
            pSiteTraceInfo: *IActiveScriptSiteTraceInfo,
            guidContextID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopScriptTracing: fn(
            self: *const IActiveScriptTraceInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptTraceInfo_StartScriptTracing(self: *const T, pSiteTraceInfo: *IActiveScriptSiteTraceInfo, guidContextID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptTraceInfo.VTable, self.vtable).StartScriptTracing(@ptrCast(*const IActiveScriptTraceInfo, self), pSiteTraceInfo, guidContextID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptTraceInfo_StopScriptTracing(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptTraceInfo.VTable, self.vtable).StopScriptTracing(@ptrCast(*const IActiveScriptTraceInfo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptStringCompare_Value = @import("../zig.zig").Guid.initString("58562769-ED52-42F7-8403-4963514E1F11");
pub const IID_IActiveScriptStringCompare = &IID_IActiveScriptStringCompare_Value;
pub const IActiveScriptStringCompare = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StrComp: fn(
            self: *const IActiveScriptStringCompare,
            bszStr1: BSTR,
            bszStr2: BSTR,
            iRet: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStringCompare_StrComp(self: *const T, bszStr1: BSTR, bszStr2: BSTR, iRet: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptStringCompare.VTable, self.vtable).StrComp(@ptrCast(*const IActiveScriptStringCompare, self), bszStr1, bszStr2, iRet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_dbgprop_0000_0000_0001 = extern enum(i32) {
    DBGPROP_ATTRIB_NO_ATTRIB = 0,
    DBGPROP_ATTRIB_VALUE_IS_INVALID = 8,
    DBGPROP_ATTRIB_VALUE_IS_EXPANDABLE = 16,
    DBGPROP_ATTRIB_VALUE_IS_FAKE = 32,
    DBGPROP_ATTRIB_VALUE_IS_METHOD = 256,
    DBGPROP_ATTRIB_VALUE_IS_EVENT = 512,
    DBGPROP_ATTRIB_VALUE_IS_RAW_STRING = 1024,
    DBGPROP_ATTRIB_VALUE_READONLY = 2048,
    DBGPROP_ATTRIB_ACCESS_PUBLIC = 4096,
    DBGPROP_ATTRIB_ACCESS_PRIVATE = 8192,
    DBGPROP_ATTRIB_ACCESS_PROTECTED = 16384,
    DBGPROP_ATTRIB_ACCESS_FINAL = 32768,
    DBGPROP_ATTRIB_STORAGE_GLOBAL = 65536,
    DBGPROP_ATTRIB_STORAGE_STATIC = 131072,
    DBGPROP_ATTRIB_STORAGE_FIELD = 262144,
    DBGPROP_ATTRIB_STORAGE_VIRTUAL = 524288,
    DBGPROP_ATTRIB_TYPE_IS_CONSTANT = 1048576,
    DBGPROP_ATTRIB_TYPE_IS_SYNCHRONIZED = 2097152,
    DBGPROP_ATTRIB_TYPE_IS_VOLATILE = 4194304,
    DBGPROP_ATTRIB_HAS_EXTENDED_ATTRIBS = 8388608,
    DBGPROP_ATTRIB_FRAME_INTRYBLOCK = 16777216,
    DBGPROP_ATTRIB_FRAME_INCATCHBLOCK = 33554432,
    DBGPROP_ATTRIB_FRAME_INFINALLYBLOCK = 67108864,
    DBGPROP_ATTRIB_VALUE_IS_RETURN_VALUE = 134217728,
    DBGPROP_ATTRIB_VALUE_PENDING_MUTATION = 268435456,
};
pub const DBGPROP_ATTRIB_NO_ATTRIB = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_NO_ATTRIB;
pub const DBGPROP_ATTRIB_VALUE_IS_INVALID = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_VALUE_IS_INVALID;
pub const DBGPROP_ATTRIB_VALUE_IS_EXPANDABLE = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_VALUE_IS_EXPANDABLE;
pub const DBGPROP_ATTRIB_VALUE_IS_FAKE = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_VALUE_IS_FAKE;
pub const DBGPROP_ATTRIB_VALUE_IS_METHOD = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_VALUE_IS_METHOD;
pub const DBGPROP_ATTRIB_VALUE_IS_EVENT = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_VALUE_IS_EVENT;
pub const DBGPROP_ATTRIB_VALUE_IS_RAW_STRING = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_VALUE_IS_RAW_STRING;
pub const DBGPROP_ATTRIB_VALUE_READONLY = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_VALUE_READONLY;
pub const DBGPROP_ATTRIB_ACCESS_PUBLIC = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_ACCESS_PUBLIC;
pub const DBGPROP_ATTRIB_ACCESS_PRIVATE = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_ACCESS_PRIVATE;
pub const DBGPROP_ATTRIB_ACCESS_PROTECTED = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_ACCESS_PROTECTED;
pub const DBGPROP_ATTRIB_ACCESS_FINAL = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_ACCESS_FINAL;
pub const DBGPROP_ATTRIB_STORAGE_GLOBAL = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_STORAGE_GLOBAL;
pub const DBGPROP_ATTRIB_STORAGE_STATIC = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_STORAGE_STATIC;
pub const DBGPROP_ATTRIB_STORAGE_FIELD = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_STORAGE_FIELD;
pub const DBGPROP_ATTRIB_STORAGE_VIRTUAL = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_STORAGE_VIRTUAL;
pub const DBGPROP_ATTRIB_TYPE_IS_CONSTANT = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_TYPE_IS_CONSTANT;
pub const DBGPROP_ATTRIB_TYPE_IS_SYNCHRONIZED = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_TYPE_IS_SYNCHRONIZED;
pub const DBGPROP_ATTRIB_TYPE_IS_VOLATILE = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_TYPE_IS_VOLATILE;
pub const DBGPROP_ATTRIB_HAS_EXTENDED_ATTRIBS = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_HAS_EXTENDED_ATTRIBS;
pub const DBGPROP_ATTRIB_FRAME_INTRYBLOCK = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_FRAME_INTRYBLOCK;
pub const DBGPROP_ATTRIB_FRAME_INCATCHBLOCK = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_FRAME_INCATCHBLOCK;
pub const DBGPROP_ATTRIB_FRAME_INFINALLYBLOCK = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_FRAME_INFINALLYBLOCK;
pub const DBGPROP_ATTRIB_VALUE_IS_RETURN_VALUE = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_VALUE_IS_RETURN_VALUE;
pub const DBGPROP_ATTRIB_VALUE_PENDING_MUTATION = __MIDL___MIDL_itf_dbgprop_0000_0000_0001.DBGPROP_ATTRIB_VALUE_PENDING_MUTATION;

pub const __MIDL___MIDL_itf_dbgprop_0000_0000_0002 = extern enum(i32) {
    DBGPROP_INFO_NAME = 1,
    DBGPROP_INFO_TYPE = 2,
    DBGPROP_INFO_VALUE = 4,
    DBGPROP_INFO_FULLNAME = 32,
    DBGPROP_INFO_ATTRIBUTES = 8,
    DBGPROP_INFO_DEBUGPROP = 16,
    DBGPROP_INFO_BEAUTIFY = 33554432,
    DBGPROP_INFO_CALLTOSTRING = 67108864,
    DBGPROP_INFO_AUTOEXPAND = 134217728,
};
pub const DBGPROP_INFO_NAME = __MIDL___MIDL_itf_dbgprop_0000_0000_0002.DBGPROP_INFO_NAME;
pub const DBGPROP_INFO_TYPE = __MIDL___MIDL_itf_dbgprop_0000_0000_0002.DBGPROP_INFO_TYPE;
pub const DBGPROP_INFO_VALUE = __MIDL___MIDL_itf_dbgprop_0000_0000_0002.DBGPROP_INFO_VALUE;
pub const DBGPROP_INFO_FULLNAME = __MIDL___MIDL_itf_dbgprop_0000_0000_0002.DBGPROP_INFO_FULLNAME;
pub const DBGPROP_INFO_ATTRIBUTES = __MIDL___MIDL_itf_dbgprop_0000_0000_0002.DBGPROP_INFO_ATTRIBUTES;
pub const DBGPROP_INFO_DEBUGPROP = __MIDL___MIDL_itf_dbgprop_0000_0000_0002.DBGPROP_INFO_DEBUGPROP;
pub const DBGPROP_INFO_BEAUTIFY = __MIDL___MIDL_itf_dbgprop_0000_0000_0002.DBGPROP_INFO_BEAUTIFY;
pub const DBGPROP_INFO_CALLTOSTRING = __MIDL___MIDL_itf_dbgprop_0000_0000_0002.DBGPROP_INFO_CALLTOSTRING;
pub const DBGPROP_INFO_AUTOEXPAND = __MIDL___MIDL_itf_dbgprop_0000_0000_0002.DBGPROP_INFO_AUTOEXPAND;

pub const tagOBJECT_ATTRIB_FLAG = extern enum(i32) {
    OBJECT_ATTRIB_NO_ATTRIB = 0,
    OBJECT_ATTRIB_NO_NAME = 1,
    OBJECT_ATTRIB_NO_TYPE = 2,
    OBJECT_ATTRIB_NO_VALUE = 4,
    OBJECT_ATTRIB_VALUE_IS_INVALID = 8,
    OBJECT_ATTRIB_VALUE_IS_OBJECT = 16,
    OBJECT_ATTRIB_VALUE_IS_ENUM = 32,
    OBJECT_ATTRIB_VALUE_IS_CUSTOM = 64,
    OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE = 112,
    OBJECT_ATTRIB_VALUE_HAS_CODE = 128,
    OBJECT_ATTRIB_TYPE_IS_OBJECT = 256,
    OBJECT_ATTRIB_TYPE_HAS_CODE = 512,
    OBJECT_ATTRIB_TYPE_IS_EXPANDABLE = 256,
    OBJECT_ATTRIB_SLOT_IS_CATEGORY = 1024,
    OBJECT_ATTRIB_VALUE_READONLY = 2048,
    OBJECT_ATTRIB_ACCESS_PUBLIC = 4096,
    OBJECT_ATTRIB_ACCESS_PRIVATE = 8192,
    OBJECT_ATTRIB_ACCESS_PROTECTED = 16384,
    OBJECT_ATTRIB_ACCESS_FINAL = 32768,
    OBJECT_ATTRIB_STORAGE_GLOBAL = 65536,
    OBJECT_ATTRIB_STORAGE_STATIC = 131072,
    OBJECT_ATTRIB_STORAGE_FIELD = 262144,
    OBJECT_ATTRIB_STORAGE_VIRTUAL = 524288,
    OBJECT_ATTRIB_TYPE_IS_CONSTANT = 1048576,
    OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED = 2097152,
    OBJECT_ATTRIB_TYPE_IS_VOLATILE = 4194304,
    OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS = 8388608,
    OBJECT_ATTRIB_IS_CLASS = 16777216,
    OBJECT_ATTRIB_IS_FUNCTION = 33554432,
    OBJECT_ATTRIB_IS_VARIABLE = 67108864,
    OBJECT_ATTRIB_IS_PROPERTY = 134217728,
    OBJECT_ATTRIB_IS_MACRO = 268435456,
    OBJECT_ATTRIB_IS_TYPE = 536870912,
    OBJECT_ATTRIB_IS_INHERITED = 1073741824,
    OBJECT_ATTRIB_IS_INTERFACE = -2147483648,
};
pub const OBJECT_ATTRIB_NO_ATTRIB = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_NO_ATTRIB;
pub const OBJECT_ATTRIB_NO_NAME = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_NO_NAME;
pub const OBJECT_ATTRIB_NO_TYPE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_NO_TYPE;
pub const OBJECT_ATTRIB_NO_VALUE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_NO_VALUE;
pub const OBJECT_ATTRIB_VALUE_IS_INVALID = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_VALUE_IS_INVALID;
pub const OBJECT_ATTRIB_VALUE_IS_OBJECT = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_VALUE_IS_OBJECT;
pub const OBJECT_ATTRIB_VALUE_IS_ENUM = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_VALUE_IS_ENUM;
pub const OBJECT_ATTRIB_VALUE_IS_CUSTOM = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_VALUE_IS_CUSTOM;
pub const OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE;
pub const OBJECT_ATTRIB_VALUE_HAS_CODE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_VALUE_HAS_CODE;
pub const OBJECT_ATTRIB_TYPE_IS_OBJECT = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_TYPE_IS_OBJECT;
pub const OBJECT_ATTRIB_TYPE_HAS_CODE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_TYPE_HAS_CODE;
pub const OBJECT_ATTRIB_TYPE_IS_EXPANDABLE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_TYPE_IS_EXPANDABLE;
pub const OBJECT_ATTRIB_SLOT_IS_CATEGORY = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_SLOT_IS_CATEGORY;
pub const OBJECT_ATTRIB_VALUE_READONLY = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_VALUE_READONLY;
pub const OBJECT_ATTRIB_ACCESS_PUBLIC = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_ACCESS_PUBLIC;
pub const OBJECT_ATTRIB_ACCESS_PRIVATE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_ACCESS_PRIVATE;
pub const OBJECT_ATTRIB_ACCESS_PROTECTED = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_ACCESS_PROTECTED;
pub const OBJECT_ATTRIB_ACCESS_FINAL = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_ACCESS_FINAL;
pub const OBJECT_ATTRIB_STORAGE_GLOBAL = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_STORAGE_GLOBAL;
pub const OBJECT_ATTRIB_STORAGE_STATIC = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_STORAGE_STATIC;
pub const OBJECT_ATTRIB_STORAGE_FIELD = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_STORAGE_FIELD;
pub const OBJECT_ATTRIB_STORAGE_VIRTUAL = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_STORAGE_VIRTUAL;
pub const OBJECT_ATTRIB_TYPE_IS_CONSTANT = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_TYPE_IS_CONSTANT;
pub const OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED;
pub const OBJECT_ATTRIB_TYPE_IS_VOLATILE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_TYPE_IS_VOLATILE;
pub const OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS;
pub const OBJECT_ATTRIB_IS_CLASS = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_IS_CLASS;
pub const OBJECT_ATTRIB_IS_FUNCTION = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_IS_FUNCTION;
pub const OBJECT_ATTRIB_IS_VARIABLE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_IS_VARIABLE;
pub const OBJECT_ATTRIB_IS_PROPERTY = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_IS_PROPERTY;
pub const OBJECT_ATTRIB_IS_MACRO = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_IS_MACRO;
pub const OBJECT_ATTRIB_IS_TYPE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_IS_TYPE;
pub const OBJECT_ATTRIB_IS_INHERITED = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_IS_INHERITED;
pub const OBJECT_ATTRIB_IS_INTERFACE = tagOBJECT_ATTRIB_FLAG.OBJECT_ATTRIB_IS_INTERFACE;

pub const PROP_INFO_FLAGS = extern enum(i32) {
    PROP_INFO_NAME = 1,
    PROP_INFO_TYPE = 2,
    PROP_INFO_VALUE = 4,
    PROP_INFO_FULLNAME = 32,
    PROP_INFO_ATTRIBUTES = 8,
    PROP_INFO_DEBUGPROP = 16,
    PROP_INFO_AUTOEXPAND = 134217728,
};
pub const PROP_INFO_NAME = PROP_INFO_FLAGS.PROP_INFO_NAME;
pub const PROP_INFO_TYPE = PROP_INFO_FLAGS.PROP_INFO_TYPE;
pub const PROP_INFO_VALUE = PROP_INFO_FLAGS.PROP_INFO_VALUE;
pub const PROP_INFO_FULLNAME = PROP_INFO_FLAGS.PROP_INFO_FULLNAME;
pub const PROP_INFO_ATTRIBUTES = PROP_INFO_FLAGS.PROP_INFO_ATTRIBUTES;
pub const PROP_INFO_DEBUGPROP = PROP_INFO_FLAGS.PROP_INFO_DEBUGPROP;
pub const PROP_INFO_AUTOEXPAND = PROP_INFO_FLAGS.PROP_INFO_AUTOEXPAND;

pub const DebugPropertyInfo = extern struct {
    m_dwValidFields: u32,
    m_bstrName: BSTR,
    m_bstrType: BSTR,
    m_bstrValue: BSTR,
    m_bstrFullName: BSTR,
    m_dwAttrib: u32,
    m_pDebugProp: *IDebugProperty,
};

pub const EX_PROP_INFO_FLAGS = extern enum(i32) {
    EX_PROP_INFO_ID = 256,
    EX_PROP_INFO_NTYPE = 512,
    EX_PROP_INFO_NVALUE = 1024,
    EX_PROP_INFO_LOCKBYTES = 2048,
    EX_PROP_INFO_DEBUGEXTPROP = 4096,
};
pub const EX_PROP_INFO_ID = EX_PROP_INFO_FLAGS.EX_PROP_INFO_ID;
pub const EX_PROP_INFO_NTYPE = EX_PROP_INFO_FLAGS.EX_PROP_INFO_NTYPE;
pub const EX_PROP_INFO_NVALUE = EX_PROP_INFO_FLAGS.EX_PROP_INFO_NVALUE;
pub const EX_PROP_INFO_LOCKBYTES = EX_PROP_INFO_FLAGS.EX_PROP_INFO_LOCKBYTES;
pub const EX_PROP_INFO_DEBUGEXTPROP = EX_PROP_INFO_FLAGS.EX_PROP_INFO_DEBUGEXTPROP;

pub const ExtendedDebugPropertyInfo = extern struct {
    dwValidFields: u32,
    pszName: PWSTR,
    pszType: PWSTR,
    pszValue: PWSTR,
    pszFullName: PWSTR,
    dwAttrib: u32,
    pDebugProp: *IDebugProperty,
    nDISPID: u32,
    nType: u32,
    varValue: VARIANT,
    plbValue: *ILockBytes,
    pDebugExtProp: *IDebugExtendedProperty,
};

const IID_IDebugProperty_Value = @import("../zig.zig").Guid.initString("51973C50-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugProperty = &IID_IDebugProperty_Value;
pub const IDebugProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyInfo: fn(
            self: *const IDebugProperty,
            dwFieldSpec: u32,
            nRadix: u32,
            pPropertyInfo: *DebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtendedInfo: fn(
            self: *const IDebugProperty,
            cInfos: u32,
            rgguidExtendedInfo: [*]Guid,
            rgvar: [*]VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValueAsString: fn(
            self: *const IDebugProperty,
            pszValue: [*:0]const u16,
            nRadix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMembers: fn(
            self: *const IDebugProperty,
            dwFieldSpec: u32,
            nRadix: u32,
            refiid: *const Guid,
            ppepi: **IEnumDebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParent: fn(
            self: *const IDebugProperty,
            ppDebugProp: **IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_GetPropertyInfo(self: *const T, dwFieldSpec: u32, nRadix: u32, pPropertyInfo: *DebugPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).GetPropertyInfo(@ptrCast(*const IDebugProperty, self), dwFieldSpec, nRadix, pPropertyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_GetExtendedInfo(self: *const T, cInfos: u32, rgguidExtendedInfo: [*]Guid, rgvar: [*]VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).GetExtendedInfo(@ptrCast(*const IDebugProperty, self), cInfos, rgguidExtendedInfo, rgvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_SetValueAsString(self: *const T, pszValue: [*:0]const u16, nRadix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).SetValueAsString(@ptrCast(*const IDebugProperty, self), pszValue, nRadix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_EnumMembers(self: *const T, dwFieldSpec: u32, nRadix: u32, refiid: *const Guid, ppepi: **IEnumDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).EnumMembers(@ptrCast(*const IDebugProperty, self), dwFieldSpec, nRadix, refiid, ppepi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_GetParent(self: *const T, ppDebugProp: **IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).GetParent(@ptrCast(*const IDebugProperty, self), ppDebugProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugPropertyInfo_Value = @import("../zig.zig").Guid.initString("51973C51-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IEnumDebugPropertyInfo = &IID_IEnumDebugPropertyInfo_Value;
pub const IEnumDebugPropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugPropertyInfo,
            celt: u32,
            pi: [*]DebugPropertyInfo,
            pcEltsfetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugPropertyInfo,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugPropertyInfo,
            ppepi: **IEnumDebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const IEnumDebugPropertyInfo,
            pcelt: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Next(self: *const T, celt: u32, pi: [*]DebugPropertyInfo, pcEltsfetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugPropertyInfo, self), celt, pi, pcEltsfetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugPropertyInfo, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugPropertyInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Clone(self: *const T, ppepi: **IEnumDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugPropertyInfo, self), ppepi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_GetCount(self: *const T, pcelt: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).GetCount(@ptrCast(*const IEnumDebugPropertyInfo, self), pcelt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExtendedProperty_Value = @import("../zig.zig").Guid.initString("51973C52-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugExtendedProperty = &IID_IDebugExtendedProperty_Value;
pub const IDebugExtendedProperty = extern struct {
    pub const VTable = extern struct {
        base: IDebugProperty.VTable,
        GetExtendedPropertyInfo: fn(
            self: *const IDebugExtendedProperty,
            dwFieldSpec: u32,
            nRadix: u32,
            pExtendedPropertyInfo: *ExtendedDebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumExtendedMembers: fn(
            self: *const IDebugExtendedProperty,
            dwFieldSpec: u32,
            nRadix: u32,
            ppeepi: **IEnumDebugExtendedPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExtendedProperty_GetExtendedPropertyInfo(self: *const T, dwFieldSpec: u32, nRadix: u32, pExtendedPropertyInfo: *ExtendedDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExtendedProperty.VTable, self.vtable).GetExtendedPropertyInfo(@ptrCast(*const IDebugExtendedProperty, self), dwFieldSpec, nRadix, pExtendedPropertyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExtendedProperty_EnumExtendedMembers(self: *const T, dwFieldSpec: u32, nRadix: u32, ppeepi: **IEnumDebugExtendedPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExtendedProperty.VTable, self.vtable).EnumExtendedMembers(@ptrCast(*const IDebugExtendedProperty, self), dwFieldSpec, nRadix, ppeepi);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugExtendedPropertyInfo_Value = @import("../zig.zig").Guid.initString("51973C53-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IEnumDebugExtendedPropertyInfo = &IID_IEnumDebugExtendedPropertyInfo_Value;
pub const IEnumDebugExtendedPropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
            celt: u32,
            rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
            pedpe: **IEnumDebugExtendedPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
            pcelt: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Next(self: *const T, celt: u32, rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self), celt, rgExtendedPropertyInfo, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Clone(self: *const T, pedpe: **IEnumDebugExtendedPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self), pedpe);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_GetCount(self: *const T, pcelt: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).GetCount(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self), pcelt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPerPropertyBrowsing2_Value = @import("../zig.zig").Guid.initString("51973C54-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IPerPropertyBrowsing2 = &IID_IPerPropertyBrowsing2_Value;
pub const IPerPropertyBrowsing2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayString: fn(
            self: *const IPerPropertyBrowsing2,
            dispid: i32,
            pBstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapPropertyToPage: fn(
            self: *const IPerPropertyBrowsing2,
            dispid: i32,
            pClsidPropPage: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPredefinedStrings: fn(
            self: *const IPerPropertyBrowsing2,
            dispid: i32,
            pCaStrings: *CALPOLESTR,
            pCaCookies: *CADWORD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPredefinedValue: fn(
            self: *const IPerPropertyBrowsing2,
            dispid: i32,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_GetDisplayString(self: *const T, dispid: i32, pBstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing2.VTable, self.vtable).GetDisplayString(@ptrCast(*const IPerPropertyBrowsing2, self), dispid, pBstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_MapPropertyToPage(self: *const T, dispid: i32, pClsidPropPage: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing2.VTable, self.vtable).MapPropertyToPage(@ptrCast(*const IPerPropertyBrowsing2, self), dispid, pClsidPropPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_GetPredefinedStrings(self: *const T, dispid: i32, pCaStrings: *CALPOLESTR, pCaCookies: *CADWORD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing2.VTable, self.vtable).GetPredefinedStrings(@ptrCast(*const IPerPropertyBrowsing2, self), dispid, pCaStrings, pCaCookies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_SetPredefinedValue(self: *const T, dispid: i32, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing2.VTable, self.vtable).SetPredefinedValue(@ptrCast(*const IPerPropertyBrowsing2, self), dispid, dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_All_Value = @import("../zig.zig").Guid.initString("51973C55-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugPropertyEnumType_All = &IID_IDebugPropertyEnumType_All_Value;
pub const IDebugPropertyEnumType_All = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IDebugPropertyEnumType_All,
            __MIDL__IDebugPropertyEnumType_All0000: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPropertyEnumType_All_GetName(self: *const T, __MIDL__IDebugPropertyEnumType_All0000: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPropertyEnumType_All.VTable, self.vtable).GetName(@ptrCast(*const IDebugPropertyEnumType_All, self), __MIDL__IDebugPropertyEnumType_All0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Locals_Value = @import("../zig.zig").Guid.initString("51973C56-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugPropertyEnumType_Locals = &IID_IDebugPropertyEnumType_Locals_Value;
pub const IDebugPropertyEnumType_Locals = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Arguments_Value = @import("../zig.zig").Guid.initString("51973C57-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugPropertyEnumType_Arguments = &IID_IDebugPropertyEnumType_Arguments_Value;
pub const IDebugPropertyEnumType_Arguments = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_LocalsPlusArgs_Value = @import("../zig.zig").Guid.initString("51973C58-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugPropertyEnumType_LocalsPlusArgs = &IID_IDebugPropertyEnumType_LocalsPlusArgs_Value;
pub const IDebugPropertyEnumType_LocalsPlusArgs = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Registers_Value = @import("../zig.zig").Guid.initString("51973C59-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugPropertyEnumType_Registers = &IID_IDebugPropertyEnumType_Registers_Value;
pub const IDebugPropertyEnumType_Registers = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BREAKPOINT_STATE = extern enum(i32) {
    BREAKPOINT_DELETED = 0,
    BREAKPOINT_DISABLED = 1,
    BREAKPOINT_ENABLED = 2,
};
pub const BREAKPOINT_DELETED = BREAKPOINT_STATE.BREAKPOINT_DELETED;
pub const BREAKPOINT_DISABLED = BREAKPOINT_STATE.BREAKPOINT_DISABLED;
pub const BREAKPOINT_ENABLED = BREAKPOINT_STATE.BREAKPOINT_ENABLED;

pub const BREAKREASON = extern enum(i32) {
    STEP = 0,
    BREAKPOINT = 1,
    DEBUGGER_BLOCK = 2,
    HOST_INITIATED = 3,
    LANGUAGE_INITIATED = 4,
    DEBUGGER_HALT = 5,
    ERROR = 6,
    JIT = 7,
    MUTATION_BREAKPOINT = 8,
};
pub const BREAKREASON_STEP = BREAKREASON.STEP;
pub const BREAKREASON_BREAKPOINT = BREAKREASON.BREAKPOINT;
pub const BREAKREASON_DEBUGGER_BLOCK = BREAKREASON.DEBUGGER_BLOCK;
pub const BREAKREASON_HOST_INITIATED = BREAKREASON.HOST_INITIATED;
pub const BREAKREASON_LANGUAGE_INITIATED = BREAKREASON.LANGUAGE_INITIATED;
pub const BREAKREASON_DEBUGGER_HALT = BREAKREASON.DEBUGGER_HALT;
pub const BREAKREASON_ERROR = BREAKREASON.ERROR;
pub const BREAKREASON_JIT = BREAKREASON.JIT;
pub const BREAKREASON_MUTATION_BREAKPOINT = BREAKREASON.MUTATION_BREAKPOINT;

pub const tagBREAKRESUME_ACTION = extern enum(i32) {
    BREAKRESUMEACTION_ABORT = 0,
    BREAKRESUMEACTION_CONTINUE = 1,
    BREAKRESUMEACTION_STEP_INTO = 2,
    BREAKRESUMEACTION_STEP_OVER = 3,
    BREAKRESUMEACTION_STEP_OUT = 4,
    BREAKRESUMEACTION_IGNORE = 5,
    BREAKRESUMEACTION_STEP_DOCUMENT = 6,
};
pub const BREAKRESUMEACTION_ABORT = tagBREAKRESUME_ACTION.BREAKRESUMEACTION_ABORT;
pub const BREAKRESUMEACTION_CONTINUE = tagBREAKRESUME_ACTION.BREAKRESUMEACTION_CONTINUE;
pub const BREAKRESUMEACTION_STEP_INTO = tagBREAKRESUME_ACTION.BREAKRESUMEACTION_STEP_INTO;
pub const BREAKRESUMEACTION_STEP_OVER = tagBREAKRESUME_ACTION.BREAKRESUMEACTION_STEP_OVER;
pub const BREAKRESUMEACTION_STEP_OUT = tagBREAKRESUME_ACTION.BREAKRESUMEACTION_STEP_OUT;
pub const BREAKRESUMEACTION_IGNORE = tagBREAKRESUME_ACTION.BREAKRESUMEACTION_IGNORE;
pub const BREAKRESUMEACTION_STEP_DOCUMENT = tagBREAKRESUME_ACTION.BREAKRESUMEACTION_STEP_DOCUMENT;

pub const ERRORRESUMEACTION = extern enum(i32) {
    ReexecuteErrorStatement = 0,
    AbortCallAndReturnErrorToCaller = 1,
    SkipErrorStatement = 2,
};
pub const ERRORRESUMEACTION_ReexecuteErrorStatement = ERRORRESUMEACTION.ReexecuteErrorStatement;
pub const ERRORRESUMEACTION_AbortCallAndReturnErrorToCaller = ERRORRESUMEACTION.AbortCallAndReturnErrorToCaller;
pub const ERRORRESUMEACTION_SkipErrorStatement = ERRORRESUMEACTION.SkipErrorStatement;

pub const DOCUMENTNAMETYPE = extern enum(i32) {
    APPNODE = 0,
    TITLE = 1,
    FILE_TAIL = 2,
    URL = 3,
    UNIQUE_TITLE = 4,
    SOURCE_MAP_URL = 5,
};
pub const DOCUMENTNAMETYPE_APPNODE = DOCUMENTNAMETYPE.APPNODE;
pub const DOCUMENTNAMETYPE_TITLE = DOCUMENTNAMETYPE.TITLE;
pub const DOCUMENTNAMETYPE_FILE_TAIL = DOCUMENTNAMETYPE.FILE_TAIL;
pub const DOCUMENTNAMETYPE_URL = DOCUMENTNAMETYPE.URL;
pub const DOCUMENTNAMETYPE_UNIQUE_TITLE = DOCUMENTNAMETYPE.UNIQUE_TITLE;
pub const DOCUMENTNAMETYPE_SOURCE_MAP_URL = DOCUMENTNAMETYPE.SOURCE_MAP_URL;

const IID_IActiveScriptDebug32_Value = @import("../zig.zig").Guid.initString("51973C10-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IActiveScriptDebug32 = &IID_IActiveScriptDebug32_Value;
pub const IActiveScriptDebug32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetScriptTextAttributes: fn(
            self: *const IActiveScriptDebug32,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: [*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptletTextAttributes: fn(
            self: *const IActiveScriptDebug32,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: [*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCodeContextsOfPosition: fn(
            self: *const IActiveScriptDebug32,
            dwSourceContext: u32,
            uCharacterOffset: u32,
            uNumChars: u32,
            ppescc: **IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug32_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: [*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug32.VTable, self.vtable).GetScriptTextAttributes(@ptrCast(*const IActiveScriptDebug32, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug32_GetScriptletTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: [*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug32.VTable, self.vtable).GetScriptletTextAttributes(@ptrCast(*const IActiveScriptDebug32, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug32_EnumCodeContextsOfPosition(self: *const T, dwSourceContext: u32, uCharacterOffset: u32, uNumChars: u32, ppescc: **IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug32.VTable, self.vtable).EnumCodeContextsOfPosition(@ptrCast(*const IActiveScriptDebug32, self), dwSourceContext, uCharacterOffset, uNumChars, ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptDebug64_Value = @import("../zig.zig").Guid.initString("BC437E23-F5B8-47F4-BB79-7D1CE5483B86");
pub const IID_IActiveScriptDebug64 = &IID_IActiveScriptDebug64_Value;
pub const IActiveScriptDebug64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetScriptTextAttributes: fn(
            self: *const IActiveScriptDebug64,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: [*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptletTextAttributes: fn(
            self: *const IActiveScriptDebug64,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: [*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCodeContextsOfPosition: fn(
            self: *const IActiveScriptDebug64,
            dwSourceContext: u64,
            uCharacterOffset: u32,
            uNumChars: u32,
            ppescc: **IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug64_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: [*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug64.VTable, self.vtable).GetScriptTextAttributes(@ptrCast(*const IActiveScriptDebug64, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug64_GetScriptletTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: [*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug64.VTable, self.vtable).GetScriptletTextAttributes(@ptrCast(*const IActiveScriptDebug64, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug64_EnumCodeContextsOfPosition(self: *const T, dwSourceContext: u64, uCharacterOffset: u32, uNumChars: u32, ppescc: **IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug64.VTable, self.vtable).EnumCodeContextsOfPosition(@ptrCast(*const IActiveScriptDebug64, self), dwSourceContext, uCharacterOffset, uNumChars, ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebug32_Value = @import("../zig.zig").Guid.initString("51973C11-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IActiveScriptSiteDebug32 = &IID_IActiveScriptSiteDebug32_Value;
pub const IActiveScriptSiteDebug32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContextFromPosition: fn(
            self: *const IActiveScriptSiteDebug32,
            dwSourceContext: u32,
            uCharacterOffset: u32,
            uNumChars: u32,
            ppsc: **IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplication: fn(
            self: *const IActiveScriptSiteDebug32,
            ppda: **IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootApplicationNode: fn(
            self: *const IActiveScriptSiteDebug32,
            ppdanRoot: **IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnScriptErrorDebug: fn(
            self: *const IActiveScriptSiteDebug32,
            pErrorDebug: *IActiveScriptErrorDebug,
            pfEnterDebugger: *BOOL,
            pfCallOnScriptErrorWhenContinuing: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_GetDocumentContextFromPosition(self: *const T, dwSourceContext: u32, uCharacterOffset: u32, uNumChars: u32, ppsc: **IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug32.VTable, self.vtable).GetDocumentContextFromPosition(@ptrCast(*const IActiveScriptSiteDebug32, self), dwSourceContext, uCharacterOffset, uNumChars, ppsc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_GetApplication(self: *const T, ppda: **IDebugApplication32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug32.VTable, self.vtable).GetApplication(@ptrCast(*const IActiveScriptSiteDebug32, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_GetRootApplicationNode(self: *const T, ppdanRoot: **IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug32.VTable, self.vtable).GetRootApplicationNode(@ptrCast(*const IActiveScriptSiteDebug32, self), ppdanRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_OnScriptErrorDebug(self: *const T, pErrorDebug: *IActiveScriptErrorDebug, pfEnterDebugger: *BOOL, pfCallOnScriptErrorWhenContinuing: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug32.VTable, self.vtable).OnScriptErrorDebug(@ptrCast(*const IActiveScriptSiteDebug32, self), pErrorDebug, pfEnterDebugger, pfCallOnScriptErrorWhenContinuing);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebug64_Value = @import("../zig.zig").Guid.initString("D6B96B0A-7463-402C-92AC-89984226942F");
pub const IID_IActiveScriptSiteDebug64 = &IID_IActiveScriptSiteDebug64_Value;
pub const IActiveScriptSiteDebug64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContextFromPosition: fn(
            self: *const IActiveScriptSiteDebug64,
            dwSourceContext: u64,
            uCharacterOffset: u32,
            uNumChars: u32,
            ppsc: **IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplication: fn(
            self: *const IActiveScriptSiteDebug64,
            ppda: **IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootApplicationNode: fn(
            self: *const IActiveScriptSiteDebug64,
            ppdanRoot: **IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnScriptErrorDebug: fn(
            self: *const IActiveScriptSiteDebug64,
            pErrorDebug: *IActiveScriptErrorDebug,
            pfEnterDebugger: *BOOL,
            pfCallOnScriptErrorWhenContinuing: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_GetDocumentContextFromPosition(self: *const T, dwSourceContext: u64, uCharacterOffset: u32, uNumChars: u32, ppsc: **IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug64.VTable, self.vtable).GetDocumentContextFromPosition(@ptrCast(*const IActiveScriptSiteDebug64, self), dwSourceContext, uCharacterOffset, uNumChars, ppsc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_GetApplication(self: *const T, ppda: **IDebugApplication64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug64.VTable, self.vtable).GetApplication(@ptrCast(*const IActiveScriptSiteDebug64, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_GetRootApplicationNode(self: *const T, ppdanRoot: **IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug64.VTable, self.vtable).GetRootApplicationNode(@ptrCast(*const IActiveScriptSiteDebug64, self), ppdanRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_OnScriptErrorDebug(self: *const T, pErrorDebug: *IActiveScriptErrorDebug, pfEnterDebugger: *BOOL, pfCallOnScriptErrorWhenContinuing: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug64.VTable, self.vtable).OnScriptErrorDebug(@ptrCast(*const IActiveScriptSiteDebug64, self), pErrorDebug, pfEnterDebugger, pfCallOnScriptErrorWhenContinuing);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebugEx_Value = @import("../zig.zig").Guid.initString("BB722CCB-6AD2-41C6-B780-AF9C03EE69F5");
pub const IID_IActiveScriptSiteDebugEx = &IID_IActiveScriptSiteDebugEx_Value;
pub const IActiveScriptSiteDebugEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCanNotJITScriptErrorDebug: fn(
            self: *const IActiveScriptSiteDebugEx,
            pErrorDebug: *IActiveScriptErrorDebug,
            pfCallOnScriptErrorWhenContinuing: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebugEx_OnCanNotJITScriptErrorDebug(self: *const T, pErrorDebug: *IActiveScriptErrorDebug, pfCallOnScriptErrorWhenContinuing: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebugEx.VTable, self.vtable).OnCanNotJITScriptErrorDebug(@ptrCast(*const IActiveScriptSiteDebugEx, self), pErrorDebug, pfCallOnScriptErrorWhenContinuing);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptErrorDebug_Value = @import("../zig.zig").Guid.initString("51973C12-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IActiveScriptErrorDebug = &IID_IActiveScriptErrorDebug_Value;
pub const IActiveScriptErrorDebug = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetDocumentContext: fn(
            self: *const IActiveScriptErrorDebug,
            ppssc: **IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackFrame: fn(
            self: *const IActiveScriptErrorDebug,
            ppdsf: **IDebugStackFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptError.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptErrorDebug_GetDocumentContext(self: *const T, ppssc: **IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptErrorDebug.VTable, self.vtable).GetDocumentContext(@ptrCast(*const IActiveScriptErrorDebug, self), ppssc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptErrorDebug_GetStackFrame(self: *const T, ppdsf: **IDebugStackFrame) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptErrorDebug.VTable, self.vtable).GetStackFrame(@ptrCast(*const IActiveScriptErrorDebug, self), ppdsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCodeContext_Value = @import("../zig.zig").Guid.initString("51973C13-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugCodeContext = &IID_IDebugCodeContext_Value;
pub const IDebugCodeContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContext: fn(
            self: *const IDebugCodeContext,
            ppsc: **IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakPoint: fn(
            self: *const IDebugCodeContext,
            bps: BREAKPOINT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCodeContext_GetDocumentContext(self: *const T, ppsc: **IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCodeContext.VTable, self.vtable).GetDocumentContext(@ptrCast(*const IDebugCodeContext, self), ppsc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCodeContext_SetBreakPoint(self: *const T, bps: BREAKPOINT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCodeContext.VTable, self.vtable).SetBreakPoint(@ptrCast(*const IDebugCodeContext, self), bps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpression_Value = @import("../zig.zig").Guid.initString("51973C14-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugExpression = &IID_IDebugExpression_Value;
pub const IDebugExpression = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const IDebugExpression,
            pdecb: *IDebugExpressionCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const IDebugExpression,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryIsComplete: fn(
            self: *const IDebugExpression,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResultAsString: fn(
            self: *const IDebugExpression,
            phrResult: *HRESULT,
            pbstrResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResultAsDebugProperty: fn(
            self: *const IDebugExpression,
            phrResult: *HRESULT,
            ppdp: **IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_Start(self: *const T, pdecb: *IDebugExpressionCallBack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).Start(@ptrCast(*const IDebugExpression, self), pdecb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).Abort(@ptrCast(*const IDebugExpression, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_QueryIsComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).QueryIsComplete(@ptrCast(*const IDebugExpression, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_GetResultAsString(self: *const T, phrResult: *HRESULT, pbstrResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).GetResultAsString(@ptrCast(*const IDebugExpression, self), phrResult, pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_GetResultAsDebugProperty(self: *const T, phrResult: *HRESULT, ppdp: **IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).GetResultAsDebugProperty(@ptrCast(*const IDebugExpression, self), phrResult, ppdp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpressionContext_Value = @import("../zig.zig").Guid.initString("51973C15-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugExpressionContext = &IID_IDebugExpressionContext_Value;
pub const IDebugExpressionContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseLanguageText: fn(
            self: *const IDebugExpressionContext,
            pstrCode: [*:0]const u16,
            nRadix: u32,
            pstrDelimiter: [*:0]const u16,
            dwFlags: u32,
            ppe: **IDebugExpression,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageInfo: fn(
            self: *const IDebugExpressionContext,
            pbstrLanguageName: *BSTR,
            pLanguageID: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpressionContext_ParseLanguageText(self: *const T, pstrCode: [*:0]const u16, nRadix: u32, pstrDelimiter: [*:0]const u16, dwFlags: u32, ppe: **IDebugExpression) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpressionContext.VTable, self.vtable).ParseLanguageText(@ptrCast(*const IDebugExpressionContext, self), pstrCode, nRadix, pstrDelimiter, dwFlags, ppe);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpressionContext_GetLanguageInfo(self: *const T, pbstrLanguageName: *BSTR, pLanguageID: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpressionContext.VTable, self.vtable).GetLanguageInfo(@ptrCast(*const IDebugExpressionContext, self), pbstrLanguageName, pLanguageID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpressionCallBack_Value = @import("../zig.zig").Guid.initString("51973C16-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugExpressionCallBack = &IID_IDebugExpressionCallBack_Value;
pub const IDebugExpressionCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onComplete: fn(
            self: *const IDebugExpressionCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpressionCallBack_onComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpressionCallBack.VTable, self.vtable).onComplete(@ptrCast(*const IDebugExpressionCallBack, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrame_Value = @import("../zig.zig").Guid.initString("51973C17-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugStackFrame = &IID_IDebugStackFrame_Value;
pub const IDebugStackFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCodeContext: fn(
            self: *const IDebugStackFrame,
            ppcc: **IDebugCodeContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionString: fn(
            self: *const IDebugStackFrame,
            fLong: BOOL,
            pbstrDescription: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageString: fn(
            self: *const IDebugStackFrame,
            fLong: BOOL,
            pbstrLanguage: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThread: fn(
            self: *const IDebugStackFrame,
            ppat: **IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebugProperty: fn(
            self: *const IDebugStackFrame,
            ppDebugProp: **IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetCodeContext(self: *const T, ppcc: **IDebugCodeContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetCodeContext(@ptrCast(*const IDebugStackFrame, self), ppcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetDescriptionString(self: *const T, fLong: BOOL, pbstrDescription: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetDescriptionString(@ptrCast(*const IDebugStackFrame, self), fLong, pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetLanguageString(self: *const T, fLong: BOOL, pbstrLanguage: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetLanguageString(@ptrCast(*const IDebugStackFrame, self), fLong, pbstrLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetThread(self: *const T, ppat: **IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetThread(@ptrCast(*const IDebugStackFrame, self), ppat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetDebugProperty(self: *const T, ppDebugProp: **IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetDebugProperty(@ptrCast(*const IDebugStackFrame, self), ppDebugProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSniffer_Value = @import("../zig.zig").Guid.initString("51973C18-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugStackFrameSniffer = &IID_IDebugStackFrameSniffer_Value;
pub const IDebugStackFrameSniffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumStackFrames: fn(
            self: *const IDebugStackFrameSniffer,
            ppedsf: **IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrameSniffer_EnumStackFrames(self: *const T, ppedsf: **IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrameSniffer.VTable, self.vtable).EnumStackFrames(@ptrCast(*const IDebugStackFrameSniffer, self), ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSnifferEx32_Value = @import("../zig.zig").Guid.initString("51973C19-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugStackFrameSnifferEx32 = &IID_IDebugStackFrameSnifferEx32_Value;
pub const IDebugStackFrameSnifferEx32 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrameSniffer.VTable,
        EnumStackFramesEx32: fn(
            self: *const IDebugStackFrameSnifferEx32,
            dwSpMin: u32,
            ppedsf: **IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugStackFrameSniffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrameSnifferEx32_EnumStackFramesEx32(self: *const T, dwSpMin: u32, ppedsf: **IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrameSnifferEx32.VTable, self.vtable).EnumStackFramesEx32(@ptrCast(*const IDebugStackFrameSnifferEx32, self), dwSpMin, ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSnifferEx64_Value = @import("../zig.zig").Guid.initString("8CD12AF4-49C1-4D52-8D8A-C146F47581AA");
pub const IID_IDebugStackFrameSnifferEx64 = &IID_IDebugStackFrameSnifferEx64_Value;
pub const IDebugStackFrameSnifferEx64 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrameSniffer.VTable,
        EnumStackFramesEx64: fn(
            self: *const IDebugStackFrameSnifferEx64,
            dwSpMin: u64,
            ppedsf: **IEnumDebugStackFrames64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugStackFrameSniffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrameSnifferEx64_EnumStackFramesEx64(self: *const T, dwSpMin: u64, ppedsf: **IEnumDebugStackFrames64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrameSnifferEx64.VTable, self.vtable).EnumStackFramesEx64(@ptrCast(*const IDebugStackFrameSnifferEx64, self), dwSpMin, ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSyncOperation_Value = @import("../zig.zig").Guid.initString("51973C1A-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugSyncOperation = &IID_IDebugSyncOperation_Value;
pub const IDebugSyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTargetThread: fn(
            self: *const IDebugSyncOperation,
            ppatTarget: **IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDebugSyncOperation,
            ppunkResult: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InProgressAbort: fn(
            self: *const IDebugSyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSyncOperation_GetTargetThread(self: *const T, ppatTarget: **IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSyncOperation.VTable, self.vtable).GetTargetThread(@ptrCast(*const IDebugSyncOperation, self), ppatTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSyncOperation_Execute(self: *const T, ppunkResult: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSyncOperation.VTable, self.vtable).Execute(@ptrCast(*const IDebugSyncOperation, self), ppunkResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSyncOperation_InProgressAbort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSyncOperation.VTable, self.vtable).InProgressAbort(@ptrCast(*const IDebugSyncOperation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAsyncOperation_Value = @import("../zig.zig").Guid.initString("51973C1B-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugAsyncOperation = &IID_IDebugAsyncOperation_Value;
pub const IDebugAsyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSyncDebugOperation: fn(
            self: *const IDebugAsyncOperation,
            ppsdo: **IDebugSyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: fn(
            self: *const IDebugAsyncOperation,
            padocb: *IDebugAsyncOperationCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const IDebugAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryIsComplete: fn(
            self: *const IDebugAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResult: fn(
            self: *const IDebugAsyncOperation,
            phrResult: *HRESULT,
            ppunkResult: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_GetSyncDebugOperation(self: *const T, ppsdo: **IDebugSyncOperation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).GetSyncDebugOperation(@ptrCast(*const IDebugAsyncOperation, self), ppsdo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_Start(self: *const T, padocb: *IDebugAsyncOperationCallBack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).Start(@ptrCast(*const IDebugAsyncOperation, self), padocb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).Abort(@ptrCast(*const IDebugAsyncOperation, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_QueryIsComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).QueryIsComplete(@ptrCast(*const IDebugAsyncOperation, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_GetResult(self: *const T, phrResult: *HRESULT, ppunkResult: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).GetResult(@ptrCast(*const IDebugAsyncOperation, self), phrResult, ppunkResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAsyncOperationCallBack_Value = @import("../zig.zig").Guid.initString("51973C1C-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugAsyncOperationCallBack = &IID_IDebugAsyncOperationCallBack_Value;
pub const IDebugAsyncOperationCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onComplete: fn(
            self: *const IDebugAsyncOperationCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperationCallBack_onComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperationCallBack.VTable, self.vtable).onComplete(@ptrCast(*const IDebugAsyncOperationCallBack, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugCodeContexts_Value = @import("../zig.zig").Guid.initString("51973C1D-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IEnumDebugCodeContexts = &IID_IEnumDebugCodeContexts_Value;
pub const IEnumDebugCodeContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugCodeContexts,
            celt: u32,
            pscc: **IDebugCodeContext,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugCodeContexts,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugCodeContexts,
            ppescc: **IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Next(self: *const T, celt: u32, pscc: **IDebugCodeContext, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugCodeContexts.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugCodeContexts, self), celt, pscc, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugCodeContexts.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugCodeContexts, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugCodeContexts.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugCodeContexts, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Clone(self: *const T, ppescc: **IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugCodeContexts.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugCodeContexts, self), ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DebugStackFrameDescriptor = extern struct {
    pdsf: *IDebugStackFrame,
    dwMin: u32,
    dwLim: u32,
    fFinal: BOOL,
    punkFinal: *IUnknown,
};

pub const DebugStackFrameDescriptor64 = extern struct {
    pdsf: *IDebugStackFrame,
    dwMin: u64,
    dwLim: u64,
    fFinal: BOOL,
    punkFinal: *IUnknown,
};

const IID_IEnumDebugStackFrames_Value = @import("../zig.zig").Guid.initString("51973C1E-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IEnumDebugStackFrames = &IID_IEnumDebugStackFrames_Value;
pub const IEnumDebugStackFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugStackFrames,
            celt: u32,
            prgdsfd: *DebugStackFrameDescriptor,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugStackFrames,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugStackFrames,
            ppedsf: **IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Next(self: *const T, celt: u32, prgdsfd: *DebugStackFrameDescriptor, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugStackFrames, self), celt, prgdsfd, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugStackFrames, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugStackFrames, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Clone(self: *const T, ppedsf: **IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugStackFrames, self), ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugStackFrames64_Value = @import("../zig.zig").Guid.initString("0DC38853-C1B0-4176-A984-B298361027AF");
pub const IID_IEnumDebugStackFrames64 = &IID_IEnumDebugStackFrames64_Value;
pub const IEnumDebugStackFrames64 = extern struct {
    pub const VTable = extern struct {
        base: IEnumDebugStackFrames.VTable,
        Next64: fn(
            self: *const IEnumDebugStackFrames64,
            celt: u32,
            prgdsfd: *DebugStackFrameDescriptor64,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEnumDebugStackFrames.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames64_Next64(self: *const T, celt: u32, prgdsfd: *DebugStackFrameDescriptor64, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames64.VTable, self.vtable).Next64(@ptrCast(*const IEnumDebugStackFrames64, self), celt, prgdsfd, pceltFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentInfo_Value = @import("../zig.zig").Guid.initString("51973C1F-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocumentInfo = &IID_IDebugDocumentInfo_Value;
pub const IDebugDocumentInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IDebugDocumentInfo,
            dnt: DOCUMENTNAMETYPE,
            pbstrName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentClassId: fn(
            self: *const IDebugDocumentInfo,
            pclsidDocument: *Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentInfo_GetName(self: *const T, dnt: DOCUMENTNAMETYPE, pbstrName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentInfo.VTable, self.vtable).GetName(@ptrCast(*const IDebugDocumentInfo, self), dnt, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentInfo_GetDocumentClassId(self: *const T, pclsidDocument: *Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentInfo.VTable, self.vtable).GetDocumentClassId(@ptrCast(*const IDebugDocumentInfo, self), pclsidDocument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentProvider_Value = @import("../zig.zig").Guid.initString("51973C20-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocumentProvider = &IID_IDebugDocumentProvider_Value;
pub const IDebugDocumentProvider = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentInfo.VTable,
        GetDocument: fn(
            self: *const IDebugDocumentProvider,
            ppssd: **IDebugDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentProvider_GetDocument(self: *const T, ppssd: **IDebugDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentProvider.VTable, self.vtable).GetDocument(@ptrCast(*const IDebugDocumentProvider, self), ppssd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocument_Value = @import("../zig.zig").Guid.initString("51973C21-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocument = &IID_IDebugDocument_Value;
pub const IDebugDocument = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentInfo.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentInfo.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentText_Value = @import("../zig.zig").Guid.initString("51973C22-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocumentText = &IID_IDebugDocumentText_Value;
pub const IDebugDocumentText = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocument.VTable,
        GetDocumentAttributes: fn(
            self: *const IDebugDocumentText,
            ptextdocattr: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IDebugDocumentText,
            pcNumLines: *u32,
            pcNumChars: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositionOfLine: fn(
            self: *const IDebugDocumentText,
            cLineNumber: u32,
            pcCharacterPosition: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineOfPosition: fn(
            self: *const IDebugDocumentText,
            cCharacterPosition: u32,
            pcLineNumber: *u32,
            pcCharacterOffsetInLine: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const IDebugDocumentText,
            cCharacterPosition: u32,
            pcharText: [*:0]u16,
            pstaTextAttr: ?[*:0]u16,
            pcNumChars: *u32,
            cMaxChars: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositionOfContext: fn(
            self: *const IDebugDocumentText,
            psc: *IDebugDocumentContext,
            pcCharacterPosition: *u32,
            cNumChars: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextOfPosition: fn(
            self: *const IDebugDocumentText,
            cCharacterPosition: u32,
            cNumChars: u32,
            ppsc: **IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetDocumentAttributes(self: *const T, ptextdocattr: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetDocumentAttributes(@ptrCast(*const IDebugDocumentText, self), ptextdocattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetSize(self: *const T, pcNumLines: *u32, pcNumChars: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetSize(@ptrCast(*const IDebugDocumentText, self), pcNumLines, pcNumChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetPositionOfLine(self: *const T, cLineNumber: u32, pcCharacterPosition: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetPositionOfLine(@ptrCast(*const IDebugDocumentText, self), cLineNumber, pcCharacterPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetLineOfPosition(self: *const T, cCharacterPosition: u32, pcLineNumber: *u32, pcCharacterOffsetInLine: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetLineOfPosition(@ptrCast(*const IDebugDocumentText, self), cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetText(self: *const T, cCharacterPosition: u32, pcharText: [*:0]u16, pstaTextAttr: ?[*:0]u16, pcNumChars: *u32, cMaxChars: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetText(@ptrCast(*const IDebugDocumentText, self), cCharacterPosition, pcharText, pstaTextAttr, pcNumChars, cMaxChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetPositionOfContext(self: *const T, psc: *IDebugDocumentContext, pcCharacterPosition: *u32, cNumChars: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetPositionOfContext(@ptrCast(*const IDebugDocumentText, self), psc, pcCharacterPosition, cNumChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetContextOfPosition(self: *const T, cCharacterPosition: u32, cNumChars: u32, ppsc: **IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetContextOfPosition(@ptrCast(*const IDebugDocumentText, self), cCharacterPosition, cNumChars, ppsc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextEvents_Value = @import("../zig.zig").Guid.initString("51973C23-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocumentTextEvents = &IID_IDebugDocumentTextEvents_Value;
pub const IDebugDocumentTextEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onDestroy: fn(
            self: *const IDebugDocumentTextEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onInsertText: fn(
            self: *const IDebugDocumentTextEvents,
            cCharacterPosition: u32,
            cNumToInsert: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onRemoveText: fn(
            self: *const IDebugDocumentTextEvents,
            cCharacterPosition: u32,
            cNumToRemove: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onReplaceText: fn(
            self: *const IDebugDocumentTextEvents,
            cCharacterPosition: u32,
            cNumToReplace: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onUpdateTextAttributes: fn(
            self: *const IDebugDocumentTextEvents,
            cCharacterPosition: u32,
            cNumToUpdate: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onUpdateDocumentAttributes: fn(
            self: *const IDebugDocumentTextEvents,
            textdocattr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onDestroy(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onDestroy(@ptrCast(*const IDebugDocumentTextEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onInsertText(self: *const T, cCharacterPosition: u32, cNumToInsert: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onInsertText(@ptrCast(*const IDebugDocumentTextEvents, self), cCharacterPosition, cNumToInsert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onRemoveText(self: *const T, cCharacterPosition: u32, cNumToRemove: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onRemoveText(@ptrCast(*const IDebugDocumentTextEvents, self), cCharacterPosition, cNumToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onReplaceText(self: *const T, cCharacterPosition: u32, cNumToReplace: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onReplaceText(@ptrCast(*const IDebugDocumentTextEvents, self), cCharacterPosition, cNumToReplace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onUpdateTextAttributes(self: *const T, cCharacterPosition: u32, cNumToUpdate: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onUpdateTextAttributes(@ptrCast(*const IDebugDocumentTextEvents, self), cCharacterPosition, cNumToUpdate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onUpdateDocumentAttributes(self: *const T, textdocattr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onUpdateDocumentAttributes(@ptrCast(*const IDebugDocumentTextEvents, self), textdocattr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextAuthor_Value = @import("../zig.zig").Guid.initString("51973C24-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocumentTextAuthor = &IID_IDebugDocumentTextAuthor_Value;
pub const IDebugDocumentTextAuthor = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentText.VTable,
        InsertText: fn(
            self: *const IDebugDocumentTextAuthor,
            cCharacterPosition: u32,
            cNumToInsert: u32,
            pcharText: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveText: fn(
            self: *const IDebugDocumentTextAuthor,
            cCharacterPosition: u32,
            cNumToRemove: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceTextA: fn(
            self: *const IDebugDocumentTextAuthor,
            cCharacterPosition: u32,
            cNumToReplace: u32,
            pcharText: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentText.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextAuthor_InsertText(self: *const T, cCharacterPosition: u32, cNumToInsert: u32, pcharText: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextAuthor.VTable, self.vtable).InsertText(@ptrCast(*const IDebugDocumentTextAuthor, self), cCharacterPosition, cNumToInsert, pcharText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextAuthor_RemoveText(self: *const T, cCharacterPosition: u32, cNumToRemove: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextAuthor.VTable, self.vtable).RemoveText(@ptrCast(*const IDebugDocumentTextAuthor, self), cCharacterPosition, cNumToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextAuthor_ReplaceTextA(self: *const T, cCharacterPosition: u32, cNumToReplace: u32, pcharText: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextAuthor.VTable, self.vtable).ReplaceTextA(@ptrCast(*const IDebugDocumentTextAuthor, self), cCharacterPosition, cNumToReplace, pcharText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextExternalAuthor_Value = @import("../zig.zig").Guid.initString("51973C25-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocumentTextExternalAuthor = &IID_IDebugDocumentTextExternalAuthor_Value;
pub const IDebugDocumentTextExternalAuthor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPathName: fn(
            self: *const IDebugDocumentTextExternalAuthor,
            pbstrLongName: *BSTR,
            pfIsOriginalFile: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: fn(
            self: *const IDebugDocumentTextExternalAuthor,
            pbstrShortName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyChanged: fn(
            self: *const IDebugDocumentTextExternalAuthor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextExternalAuthor_GetPathName(self: *const T, pbstrLongName: *BSTR, pfIsOriginalFile: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextExternalAuthor.VTable, self.vtable).GetPathName(@ptrCast(*const IDebugDocumentTextExternalAuthor, self), pbstrLongName, pfIsOriginalFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextExternalAuthor_GetFileName(self: *const T, pbstrShortName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextExternalAuthor.VTable, self.vtable).GetFileName(@ptrCast(*const IDebugDocumentTextExternalAuthor, self), pbstrShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextExternalAuthor_NotifyChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextExternalAuthor.VTable, self.vtable).NotifyChanged(@ptrCast(*const IDebugDocumentTextExternalAuthor, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHelper32_Value = @import("../zig.zig").Guid.initString("51973C26-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocumentHelper32 = &IID_IDebugDocumentHelper32_Value;
pub const IDebugDocumentHelper32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IDebugDocumentHelper32,
            pda: *IDebugApplication32,
            pszShortName: [*:0]const u16,
            pszLongName: [*:0]const u16,
            docAttr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Attach: fn(
            self: *const IDebugDocumentHelper32,
            pddhParent: *IDebugDocumentHelper32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const IDebugDocumentHelper32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUnicodeText: fn(
            self: *const IDebugDocumentHelper32,
            pszText: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDBCSText: fn(
            self: *const IDebugDocumentHelper32,
            pszText: [*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDebugDocumentHost: fn(
            self: *const IDebugDocumentHelper32,
            pddh: *IDebugDocumentHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDeferredText: fn(
            self: *const IDebugDocumentHelper32,
            cChars: u32,
            dwTextStartCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineScriptBlock: fn(
            self: *const IDebugDocumentHelper32,
            ulCharOffset: u32,
            cChars: u32,
            pas: *IActiveScript,
            fScriptlet: BOOL,
            pdwSourceContext: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTextAttr: fn(
            self: *const IDebugDocumentHelper32,
            staTextAttr: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextAttributes: fn(
            self: *const IDebugDocumentHelper32,
            ulCharOffset: u32,
            cChars: u32,
            pstaTextAttr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLongName: fn(
            self: *const IDebugDocumentHelper32,
            pszLongName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShortName: fn(
            self: *const IDebugDocumentHelper32,
            pszShortName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentAttr: fn(
            self: *const IDebugDocumentHelper32,
            pszAttributes: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebugApplicationNode: fn(
            self: *const IDebugDocumentHelper32,
            ppdan: **IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptBlockInfo: fn(
            self: *const IDebugDocumentHelper32,
            dwSourceContext: u32,
            ppasd: **IActiveScript,
            piCharPos: *u32,
            pcChars: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDebugDocumentContext: fn(
            self: *const IDebugDocumentHelper32,
            iCharPos: u32,
            cChars: u32,
            ppddc: **IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentToTop: fn(
            self: *const IDebugDocumentHelper32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentContextToTop: fn(
            self: *const IDebugDocumentHelper32,
            pddc: ?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_Init(self: *const T, pda: *IDebugApplication32, pszShortName: [*:0]const u16, pszLongName: [*:0]const u16, docAttr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).Init(@ptrCast(*const IDebugDocumentHelper32, self), pda, pszShortName, pszLongName, docAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_Attach(self: *const T, pddhParent: *IDebugDocumentHelper32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).Attach(@ptrCast(*const IDebugDocumentHelper32, self), pddhParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).Detach(@ptrCast(*const IDebugDocumentHelper32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_AddUnicodeText(self: *const T, pszText: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).AddUnicodeText(@ptrCast(*const IDebugDocumentHelper32, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_AddDBCSText(self: *const T, pszText: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).AddDBCSText(@ptrCast(*const IDebugDocumentHelper32, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetDebugDocumentHost(self: *const T, pddh: *IDebugDocumentHost) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetDebugDocumentHost(@ptrCast(*const IDebugDocumentHelper32, self), pddh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_AddDeferredText(self: *const T, cChars: u32, dwTextStartCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).AddDeferredText(@ptrCast(*const IDebugDocumentHelper32, self), cChars, dwTextStartCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_DefineScriptBlock(self: *const T, ulCharOffset: u32, cChars: u32, pas: *IActiveScript, fScriptlet: BOOL, pdwSourceContext: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).DefineScriptBlock(@ptrCast(*const IDebugDocumentHelper32, self), ulCharOffset, cChars, pas, fScriptlet, pdwSourceContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetDefaultTextAttr(self: *const T, staTextAttr: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetDefaultTextAttr(@ptrCast(*const IDebugDocumentHelper32, self), staTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetTextAttributes(self: *const T, ulCharOffset: u32, cChars: u32, pstaTextAttr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetTextAttributes(@ptrCast(*const IDebugDocumentHelper32, self), ulCharOffset, cChars, pstaTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetLongName(self: *const T, pszLongName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetLongName(@ptrCast(*const IDebugDocumentHelper32, self), pszLongName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetShortName(self: *const T, pszShortName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetShortName(@ptrCast(*const IDebugDocumentHelper32, self), pszShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetDocumentAttr(self: *const T, pszAttributes: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetDocumentAttr(@ptrCast(*const IDebugDocumentHelper32, self), pszAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_GetDebugApplicationNode(self: *const T, ppdan: **IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).GetDebugApplicationNode(@ptrCast(*const IDebugDocumentHelper32, self), ppdan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_GetScriptBlockInfo(self: *const T, dwSourceContext: u32, ppasd: **IActiveScript, piCharPos: *u32, pcChars: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).GetScriptBlockInfo(@ptrCast(*const IDebugDocumentHelper32, self), dwSourceContext, ppasd, piCharPos, pcChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_CreateDebugDocumentContext(self: *const T, iCharPos: u32, cChars: u32, ppddc: **IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).CreateDebugDocumentContext(@ptrCast(*const IDebugDocumentHelper32, self), iCharPos, cChars, ppddc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_BringDocumentToTop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).BringDocumentToTop(@ptrCast(*const IDebugDocumentHelper32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).BringDocumentContextToTop(@ptrCast(*const IDebugDocumentHelper32, self), pddc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHelper64_Value = @import("../zig.zig").Guid.initString("C4C7363C-20FD-47F9-BD82-4855E0150871");
pub const IID_IDebugDocumentHelper64 = &IID_IDebugDocumentHelper64_Value;
pub const IDebugDocumentHelper64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IDebugDocumentHelper64,
            pda: *IDebugApplication64,
            pszShortName: [*:0]const u16,
            pszLongName: [*:0]const u16,
            docAttr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Attach: fn(
            self: *const IDebugDocumentHelper64,
            pddhParent: *IDebugDocumentHelper64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const IDebugDocumentHelper64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUnicodeText: fn(
            self: *const IDebugDocumentHelper64,
            pszText: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDBCSText: fn(
            self: *const IDebugDocumentHelper64,
            pszText: [*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDebugDocumentHost: fn(
            self: *const IDebugDocumentHelper64,
            pddh: *IDebugDocumentHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDeferredText: fn(
            self: *const IDebugDocumentHelper64,
            cChars: u32,
            dwTextStartCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineScriptBlock: fn(
            self: *const IDebugDocumentHelper64,
            ulCharOffset: u32,
            cChars: u32,
            pas: *IActiveScript,
            fScriptlet: BOOL,
            pdwSourceContext: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTextAttr: fn(
            self: *const IDebugDocumentHelper64,
            staTextAttr: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextAttributes: fn(
            self: *const IDebugDocumentHelper64,
            ulCharOffset: u32,
            cChars: u32,
            pstaTextAttr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLongName: fn(
            self: *const IDebugDocumentHelper64,
            pszLongName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShortName: fn(
            self: *const IDebugDocumentHelper64,
            pszShortName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentAttr: fn(
            self: *const IDebugDocumentHelper64,
            pszAttributes: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebugApplicationNode: fn(
            self: *const IDebugDocumentHelper64,
            ppdan: **IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptBlockInfo: fn(
            self: *const IDebugDocumentHelper64,
            dwSourceContext: u64,
            ppasd: **IActiveScript,
            piCharPos: *u32,
            pcChars: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDebugDocumentContext: fn(
            self: *const IDebugDocumentHelper64,
            iCharPos: u32,
            cChars: u32,
            ppddc: **IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentToTop: fn(
            self: *const IDebugDocumentHelper64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentContextToTop: fn(
            self: *const IDebugDocumentHelper64,
            pddc: ?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_Init(self: *const T, pda: *IDebugApplication64, pszShortName: [*:0]const u16, pszLongName: [*:0]const u16, docAttr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).Init(@ptrCast(*const IDebugDocumentHelper64, self), pda, pszShortName, pszLongName, docAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_Attach(self: *const T, pddhParent: *IDebugDocumentHelper64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).Attach(@ptrCast(*const IDebugDocumentHelper64, self), pddhParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).Detach(@ptrCast(*const IDebugDocumentHelper64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_AddUnicodeText(self: *const T, pszText: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).AddUnicodeText(@ptrCast(*const IDebugDocumentHelper64, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_AddDBCSText(self: *const T, pszText: [*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).AddDBCSText(@ptrCast(*const IDebugDocumentHelper64, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetDebugDocumentHost(self: *const T, pddh: *IDebugDocumentHost) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetDebugDocumentHost(@ptrCast(*const IDebugDocumentHelper64, self), pddh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_AddDeferredText(self: *const T, cChars: u32, dwTextStartCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).AddDeferredText(@ptrCast(*const IDebugDocumentHelper64, self), cChars, dwTextStartCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_DefineScriptBlock(self: *const T, ulCharOffset: u32, cChars: u32, pas: *IActiveScript, fScriptlet: BOOL, pdwSourceContext: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).DefineScriptBlock(@ptrCast(*const IDebugDocumentHelper64, self), ulCharOffset, cChars, pas, fScriptlet, pdwSourceContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetDefaultTextAttr(self: *const T, staTextAttr: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetDefaultTextAttr(@ptrCast(*const IDebugDocumentHelper64, self), staTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetTextAttributes(self: *const T, ulCharOffset: u32, cChars: u32, pstaTextAttr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetTextAttributes(@ptrCast(*const IDebugDocumentHelper64, self), ulCharOffset, cChars, pstaTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetLongName(self: *const T, pszLongName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetLongName(@ptrCast(*const IDebugDocumentHelper64, self), pszLongName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetShortName(self: *const T, pszShortName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetShortName(@ptrCast(*const IDebugDocumentHelper64, self), pszShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetDocumentAttr(self: *const T, pszAttributes: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetDocumentAttr(@ptrCast(*const IDebugDocumentHelper64, self), pszAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_GetDebugApplicationNode(self: *const T, ppdan: **IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).GetDebugApplicationNode(@ptrCast(*const IDebugDocumentHelper64, self), ppdan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_GetScriptBlockInfo(self: *const T, dwSourceContext: u64, ppasd: **IActiveScript, piCharPos: *u32, pcChars: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).GetScriptBlockInfo(@ptrCast(*const IDebugDocumentHelper64, self), dwSourceContext, ppasd, piCharPos, pcChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_CreateDebugDocumentContext(self: *const T, iCharPos: u32, cChars: u32, ppddc: **IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).CreateDebugDocumentContext(@ptrCast(*const IDebugDocumentHelper64, self), iCharPos, cChars, ppddc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_BringDocumentToTop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).BringDocumentToTop(@ptrCast(*const IDebugDocumentHelper64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).BringDocumentContextToTop(@ptrCast(*const IDebugDocumentHelper64, self), pddc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHost_Value = @import("../zig.zig").Guid.initString("51973C27-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocumentHost = &IID_IDebugDocumentHost_Value;
pub const IDebugDocumentHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeferredText: fn(
            self: *const IDebugDocumentHost,
            dwTextStartCookie: u32,
            pcharText: [*:0]u16,
            pstaTextAttr: [*:0]u16,
            pcNumChars: *u32,
            cMaxChars: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptTextAttributes: fn(
            self: *const IDebugDocumentHost,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: [*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCreateDocumentContext: fn(
            self: *const IDebugDocumentHost,
            ppunkOuter: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPathName: fn(
            self: *const IDebugDocumentHost,
            pbstrLongName: *BSTR,
            pfIsOriginalFile: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: fn(
            self: *const IDebugDocumentHost,
            pbstrShortName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyChanged: fn(
            self: *const IDebugDocumentHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetDeferredText(self: *const T, dwTextStartCookie: u32, pcharText: [*:0]u16, pstaTextAttr: [*:0]u16, pcNumChars: *u32, cMaxChars: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).GetDeferredText(@ptrCast(*const IDebugDocumentHost, self), dwTextStartCookie, pcharText, pstaTextAttr, pcNumChars, cMaxChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: [*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).GetScriptTextAttributes(@ptrCast(*const IDebugDocumentHost, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_OnCreateDocumentContext(self: *const T, ppunkOuter: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).OnCreateDocumentContext(@ptrCast(*const IDebugDocumentHost, self), ppunkOuter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetPathName(self: *const T, pbstrLongName: *BSTR, pfIsOriginalFile: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).GetPathName(@ptrCast(*const IDebugDocumentHost, self), pbstrLongName, pfIsOriginalFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetFileName(self: *const T, pbstrShortName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).GetFileName(@ptrCast(*const IDebugDocumentHost, self), pbstrShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_NotifyChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).NotifyChanged(@ptrCast(*const IDebugDocumentHost, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentContext_Value = @import("../zig.zig").Guid.initString("51973C28-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugDocumentContext = &IID_IDebugDocumentContext_Value;
pub const IDebugDocumentContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocument: fn(
            self: *const IDebugDocumentContext,
            ppsd: **IDebugDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCodeContexts: fn(
            self: *const IDebugDocumentContext,
            ppescc: **IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentContext_GetDocument(self: *const T, ppsd: **IDebugDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentContext.VTable, self.vtable).GetDocument(@ptrCast(*const IDebugDocumentContext, self), ppsd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentContext_EnumCodeContexts(self: *const T, ppescc: **IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentContext.VTable, self.vtable).EnumCodeContexts(@ptrCast(*const IDebugDocumentContext, self), ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSessionProvider_Value = @import("../zig.zig").Guid.initString("51973C29-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugSessionProvider = &IID_IDebugSessionProvider_Value;
pub const IDebugSessionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartDebugSession: fn(
            self: *const IDebugSessionProvider,
            pda: *IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSessionProvider_StartDebugSession(self: *const T, pda: *IRemoteDebugApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSessionProvider.VTable, self.vtable).StartDebugSession(@ptrCast(*const IDebugSessionProvider, self), pda);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApplicationDebugger_Value = @import("../zig.zig").Guid.initString("51973C2A-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IApplicationDebugger = &IID_IApplicationDebugger_Value;
pub const IApplicationDebugger = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryAlive: fn(
            self: *const IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstanceAtDebugger: fn(
            self: *const IApplicationDebugger,
            rclsid: *const Guid,
            pUnkOuter: *IUnknown,
            dwClsContext: u32,
            riid: *const Guid,
            ppvObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onDebugOutput: fn(
            self: *const IApplicationDebugger,
            pstr: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onHandleBreakPoint: fn(
            self: *const IApplicationDebugger,
            prpt: *IRemoteDebugApplicationThread,
            br: BREAKREASON,
            pError: *IActiveScriptErrorDebug,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onClose: fn(
            self: *const IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onDebuggerEvent: fn(
            self: *const IApplicationDebugger,
            riid: *const Guid,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_QueryAlive(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).QueryAlive(@ptrCast(*const IApplicationDebugger, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_CreateInstanceAtDebugger(self: *const T, rclsid: *const Guid, pUnkOuter: *IUnknown, dwClsContext: u32, riid: *const Guid, ppvObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).CreateInstanceAtDebugger(@ptrCast(*const IApplicationDebugger, self), rclsid, pUnkOuter, dwClsContext, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onDebugOutput(self: *const T, pstr: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).onDebugOutput(@ptrCast(*const IApplicationDebugger, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onHandleBreakPoint(self: *const T, prpt: *IRemoteDebugApplicationThread, br: BREAKREASON, pError: *IActiveScriptErrorDebug) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).onHandleBreakPoint(@ptrCast(*const IApplicationDebugger, self), prpt, br, pError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onClose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).onClose(@ptrCast(*const IApplicationDebugger, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onDebuggerEvent(self: *const T, riid: *const Guid, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).onDebuggerEvent(@ptrCast(*const IApplicationDebugger, self), riid, punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApplicationDebuggerUI_Value = @import("../zig.zig").Guid.initString("51973C2B-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IApplicationDebuggerUI = &IID_IApplicationDebuggerUI_Value;
pub const IApplicationDebuggerUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BringDocumentToTop: fn(
            self: *const IApplicationDebuggerUI,
            pddt: *IDebugDocumentText,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentContextToTop: fn(
            self: *const IApplicationDebuggerUI,
            pddc: *IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebuggerUI_BringDocumentToTop(self: *const T, pddt: *IDebugDocumentText) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebuggerUI.VTable, self.vtable).BringDocumentToTop(@ptrCast(*const IApplicationDebuggerUI, self), pddt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebuggerUI_BringDocumentContextToTop(self: *const T, pddc: *IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebuggerUI.VTable, self.vtable).BringDocumentContextToTop(@ptrCast(*const IApplicationDebuggerUI, self), pddc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManager_Value = @import("../zig.zig").Guid.initString("51973C2C-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IMachineDebugManager = &IID_IMachineDebugManager_Value;
pub const IMachineDebugManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddApplication: fn(
            self: *const IMachineDebugManager,
            pda: *IRemoteDebugApplication,
            pdwAppCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveApplication: fn(
            self: *const IMachineDebugManager,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumApplications: fn(
            self: *const IMachineDebugManager,
            ppeda: **IEnumRemoteDebugApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManager_AddApplication(self: *const T, pda: *IRemoteDebugApplication, pdwAppCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManager.VTable, self.vtable).AddApplication(@ptrCast(*const IMachineDebugManager, self), pda, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManager_RemoveApplication(self: *const T, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManager.VTable, self.vtable).RemoveApplication(@ptrCast(*const IMachineDebugManager, self), dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManager_EnumApplications(self: *const T, ppeda: **IEnumRemoteDebugApplications) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManager.VTable, self.vtable).EnumApplications(@ptrCast(*const IMachineDebugManager, self), ppeda);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManagerCookie_Value = @import("../zig.zig").Guid.initString("51973C2D-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IMachineDebugManagerCookie = &IID_IMachineDebugManagerCookie_Value;
pub const IMachineDebugManagerCookie = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddApplication: fn(
            self: *const IMachineDebugManagerCookie,
            pda: *IRemoteDebugApplication,
            dwDebugAppCookie: u32,
            pdwAppCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveApplication: fn(
            self: *const IMachineDebugManagerCookie,
            dwDebugAppCookie: u32,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumApplications: fn(
            self: *const IMachineDebugManagerCookie,
            ppeda: **IEnumRemoteDebugApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerCookie_AddApplication(self: *const T, pda: *IRemoteDebugApplication, dwDebugAppCookie: u32, pdwAppCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerCookie.VTable, self.vtable).AddApplication(@ptrCast(*const IMachineDebugManagerCookie, self), pda, dwDebugAppCookie, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerCookie_RemoveApplication(self: *const T, dwDebugAppCookie: u32, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerCookie.VTable, self.vtable).RemoveApplication(@ptrCast(*const IMachineDebugManagerCookie, self), dwDebugAppCookie, dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerCookie_EnumApplications(self: *const T, ppeda: **IEnumRemoteDebugApplications) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerCookie.VTable, self.vtable).EnumApplications(@ptrCast(*const IMachineDebugManagerCookie, self), ppeda);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManagerEvents_Value = @import("../zig.zig").Guid.initString("51973C2E-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IMachineDebugManagerEvents = &IID_IMachineDebugManagerEvents_Value;
pub const IMachineDebugManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onAddApplication: fn(
            self: *const IMachineDebugManagerEvents,
            pda: *IRemoteDebugApplication,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onRemoveApplication: fn(
            self: *const IMachineDebugManagerEvents,
            pda: *IRemoteDebugApplication,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerEvents_onAddApplication(self: *const T, pda: *IRemoteDebugApplication, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerEvents.VTable, self.vtable).onAddApplication(@ptrCast(*const IMachineDebugManagerEvents, self), pda, dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerEvents_onRemoveApplication(self: *const T, pda: *IRemoteDebugApplication, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerEvents.VTable, self.vtable).onRemoveApplication(@ptrCast(*const IMachineDebugManagerEvents, self), pda, dwAppCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProcessDebugManager32_Value = @import("../zig.zig").Guid.initString("51973C2F-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IProcessDebugManager32 = &IID_IProcessDebugManager32_Value;
pub const IProcessDebugManager32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateApplication: fn(
            self: *const IProcessDebugManager32,
            ppda: **IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultApplication: fn(
            self: *const IProcessDebugManager32,
            ppda: **IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddApplication: fn(
            self: *const IProcessDebugManager32,
            pda: *IDebugApplication32,
            pdwAppCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveApplication: fn(
            self: *const IProcessDebugManager32,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDebugDocumentHelper: fn(
            self: *const IProcessDebugManager32,
            punkOuter: *IUnknown,
            pddh: **IDebugDocumentHelper32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_CreateApplication(self: *const T, ppda: **IDebugApplication32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).CreateApplication(@ptrCast(*const IProcessDebugManager32, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_GetDefaultApplication(self: *const T, ppda: **IDebugApplication32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).GetDefaultApplication(@ptrCast(*const IProcessDebugManager32, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_AddApplication(self: *const T, pda: *IDebugApplication32, pdwAppCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).AddApplication(@ptrCast(*const IProcessDebugManager32, self), pda, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_RemoveApplication(self: *const T, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).RemoveApplication(@ptrCast(*const IProcessDebugManager32, self), dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_CreateDebugDocumentHelper(self: *const T, punkOuter: *IUnknown, pddh: **IDebugDocumentHelper32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).CreateDebugDocumentHelper(@ptrCast(*const IProcessDebugManager32, self), punkOuter, pddh);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProcessDebugManager64_Value = @import("../zig.zig").Guid.initString("56B9FC1C-63A9-4CC1-AC21-087D69A17FAB");
pub const IID_IProcessDebugManager64 = &IID_IProcessDebugManager64_Value;
pub const IProcessDebugManager64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateApplication: fn(
            self: *const IProcessDebugManager64,
            ppda: **IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultApplication: fn(
            self: *const IProcessDebugManager64,
            ppda: **IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddApplication: fn(
            self: *const IProcessDebugManager64,
            pda: *IDebugApplication64,
            pdwAppCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveApplication: fn(
            self: *const IProcessDebugManager64,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDebugDocumentHelper: fn(
            self: *const IProcessDebugManager64,
            punkOuter: *IUnknown,
            pddh: **IDebugDocumentHelper64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_CreateApplication(self: *const T, ppda: **IDebugApplication64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).CreateApplication(@ptrCast(*const IProcessDebugManager64, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_GetDefaultApplication(self: *const T, ppda: **IDebugApplication64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).GetDefaultApplication(@ptrCast(*const IProcessDebugManager64, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_AddApplication(self: *const T, pda: *IDebugApplication64, pdwAppCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).AddApplication(@ptrCast(*const IProcessDebugManager64, self), pda, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_RemoveApplication(self: *const T, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).RemoveApplication(@ptrCast(*const IProcessDebugManager64, self), dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_CreateDebugDocumentHelper(self: *const T, punkOuter: *IUnknown, pddh: **IDebugDocumentHelper64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).CreateDebugDocumentHelper(@ptrCast(*const IProcessDebugManager64, self), punkOuter, pddh);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplication_Value = @import("../zig.zig").Guid.initString("51973C30-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IRemoteDebugApplication = &IID_IRemoteDebugApplication_Value;
pub const IRemoteDebugApplication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResumeFromBreakPoint: fn(
            self: *const IRemoteDebugApplication,
            prptFocus: *IRemoteDebugApplicationThread,
            bra: tagBREAKRESUME_ACTION,
            era: ERRORRESUMEACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CauseBreak: fn(
            self: *const IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectDebugger: fn(
            self: *const IRemoteDebugApplication,
            pad: *IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectDebugger: fn(
            self: *const IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebugger: fn(
            self: *const IRemoteDebugApplication,
            pad: **IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstanceAtApplication: fn(
            self: *const IRemoteDebugApplication,
            rclsid: *const Guid,
            pUnkOuter: *IUnknown,
            dwClsContext: u32,
            riid: *const Guid,
            ppvObject: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAlive: fn(
            self: *const IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumThreads: fn(
            self: *const IRemoteDebugApplication,
            pperdat: **IEnumRemoteDebugApplicationThreads,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IRemoteDebugApplication,
            pbstrName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootNode: fn(
            self: *const IRemoteDebugApplication,
            ppdanRoot: **IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumGlobalExpressionContexts: fn(
            self: *const IRemoteDebugApplication,
            ppedec: **IEnumDebugExpressionContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_ResumeFromBreakPoint(self: *const T, prptFocus: *IRemoteDebugApplicationThread, bra: tagBREAKRESUME_ACTION, era: ERRORRESUMEACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).ResumeFromBreakPoint(@ptrCast(*const IRemoteDebugApplication, self), prptFocus, bra, era);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_CauseBreak(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).CauseBreak(@ptrCast(*const IRemoteDebugApplication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_ConnectDebugger(self: *const T, pad: *IApplicationDebugger) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).ConnectDebugger(@ptrCast(*const IRemoteDebugApplication, self), pad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_DisconnectDebugger(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).DisconnectDebugger(@ptrCast(*const IRemoteDebugApplication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_GetDebugger(self: *const T, pad: **IApplicationDebugger) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).GetDebugger(@ptrCast(*const IRemoteDebugApplication, self), pad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_CreateInstanceAtApplication(self: *const T, rclsid: *const Guid, pUnkOuter: *IUnknown, dwClsContext: u32, riid: *const Guid, ppvObject: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).CreateInstanceAtApplication(@ptrCast(*const IRemoteDebugApplication, self), rclsid, pUnkOuter, dwClsContext, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_QueryAlive(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).QueryAlive(@ptrCast(*const IRemoteDebugApplication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_EnumThreads(self: *const T, pperdat: **IEnumRemoteDebugApplicationThreads) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).EnumThreads(@ptrCast(*const IRemoteDebugApplication, self), pperdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_GetName(self: *const T, pbstrName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).GetName(@ptrCast(*const IRemoteDebugApplication, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_GetRootNode(self: *const T, ppdanRoot: **IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).GetRootNode(@ptrCast(*const IRemoteDebugApplication, self), ppdanRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_EnumGlobalExpressionContexts(self: *const T, ppedec: **IEnumDebugExpressionContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).EnumGlobalExpressionContexts(@ptrCast(*const IRemoteDebugApplication, self), ppedec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication32_Value = @import("../zig.zig").Guid.initString("51973C32-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugApplication32 = &IID_IDebugApplication32_Value;
pub const IDebugApplication32 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication.VTable,
        SetName: fn(
            self: *const IDebugApplication32,
            pstrName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StepOutComplete: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DebugOutput: fn(
            self: *const IDebugApplication32,
            pstr: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartDebugSession: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleBreakPoint: fn(
            self: *const IDebugApplication32,
            br: BREAKREASON,
            pbra: *tagBREAKRESUME_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakFlags: fn(
            self: *const IDebugApplication32,
            pabf: *u32,
            pprdatSteppingThread: **IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThread: fn(
            self: *const IDebugApplication32,
            pat: **IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAsyncDebugOperation: fn(
            self: *const IDebugApplication32,
            psdo: *IDebugSyncOperation,
            ppado: **IDebugAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStackFrameSniffer: fn(
            self: *const IDebugApplication32,
            pdsfs: *IDebugStackFrameSniffer,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStackFrameSniffer: fn(
            self: *const IDebugApplication32,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryCurrentThreadIsDebuggerThread: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SynchronousCallInDebuggerThread: fn(
            self: *const IDebugApplication32,
            pptc: *IDebugThreadCall32,
            dwParam1: u32,
            dwParam2: u32,
            dwParam3: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateApplicationNode: fn(
            self: *const IDebugApplication32,
            ppdanNew: **IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FireDebuggerEvent: fn(
            self: *const IDebugApplication32,
            riid: *const Guid,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleRuntimeError: fn(
            self: *const IDebugApplication32,
            pErrorDebug: *IActiveScriptErrorDebug,
            pScriptSite: *IActiveScriptSite,
            pbra: *tagBREAKRESUME_ACTION,
            perra: *ERRORRESUMEACTION,
            pfCallOnScriptError: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FCanJitDebug: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        FIsAutoJitDebugEnabled: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        AddGlobalExpressionContextProvider: fn(
            self: *const IDebugApplication32,
            pdsfs: *IProvideExpressionContexts,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveGlobalExpressionContextProvider: fn(
            self: *const IDebugApplication32,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplication.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_SetName(self: *const T, pstrName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).SetName(@ptrCast(*const IDebugApplication32, self), pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_StepOutComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).StepOutComplete(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_DebugOutput(self: *const T, pstr: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).DebugOutput(@ptrCast(*const IDebugApplication32, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_StartDebugSession(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).StartDebugSession(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_HandleBreakPoint(self: *const T, br: BREAKREASON, pbra: *tagBREAKRESUME_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).HandleBreakPoint(@ptrCast(*const IDebugApplication32, self), br, pbra);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).Close(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_GetBreakFlags(self: *const T, pabf: *u32, pprdatSteppingThread: **IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).GetBreakFlags(@ptrCast(*const IDebugApplication32, self), pabf, pprdatSteppingThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_GetCurrentThread(self: *const T, pat: **IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).GetCurrentThread(@ptrCast(*const IDebugApplication32, self), pat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_CreateAsyncDebugOperation(self: *const T, psdo: *IDebugSyncOperation, ppado: **IDebugAsyncOperation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).CreateAsyncDebugOperation(@ptrCast(*const IDebugApplication32, self), psdo, ppado);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_AddStackFrameSniffer(self: *const T, pdsfs: *IDebugStackFrameSniffer, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).AddStackFrameSniffer(@ptrCast(*const IDebugApplication32, self), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_RemoveStackFrameSniffer(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).RemoveStackFrameSniffer(@ptrCast(*const IDebugApplication32, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_QueryCurrentThreadIsDebuggerThread(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).QueryCurrentThreadIsDebuggerThread(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_SynchronousCallInDebuggerThread(self: *const T, pptc: *IDebugThreadCall32, dwParam1: u32, dwParam2: u32, dwParam3: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).SynchronousCallInDebuggerThread(@ptrCast(*const IDebugApplication32, self), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_CreateApplicationNode(self: *const T, ppdanNew: **IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).CreateApplicationNode(@ptrCast(*const IDebugApplication32, self), ppdanNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_FireDebuggerEvent(self: *const T, riid: *const Guid, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).FireDebuggerEvent(@ptrCast(*const IDebugApplication32, self), riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_HandleRuntimeError(self: *const T, pErrorDebug: *IActiveScriptErrorDebug, pScriptSite: *IActiveScriptSite, pbra: *tagBREAKRESUME_ACTION, perra: *ERRORRESUMEACTION, pfCallOnScriptError: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).HandleRuntimeError(@ptrCast(*const IDebugApplication32, self), pErrorDebug, pScriptSite, pbra, perra, pfCallOnScriptError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_FCanJitDebug(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).FCanJitDebug(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_FIsAutoJitDebugEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).FIsAutoJitDebugEnabled(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_AddGlobalExpressionContextProvider(self: *const T, pdsfs: *IProvideExpressionContexts, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).AddGlobalExpressionContextProvider(@ptrCast(*const IDebugApplication32, self), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_RemoveGlobalExpressionContextProvider(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).RemoveGlobalExpressionContextProvider(@ptrCast(*const IDebugApplication32, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication64_Value = @import("../zig.zig").Guid.initString("4DEDC754-04C7-4F10-9E60-16A390FE6E62");
pub const IID_IDebugApplication64 = &IID_IDebugApplication64_Value;
pub const IDebugApplication64 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication.VTable,
        SetName: fn(
            self: *const IDebugApplication64,
            pstrName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StepOutComplete: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DebugOutput: fn(
            self: *const IDebugApplication64,
            pstr: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartDebugSession: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleBreakPoint: fn(
            self: *const IDebugApplication64,
            br: BREAKREASON,
            pbra: *tagBREAKRESUME_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakFlags: fn(
            self: *const IDebugApplication64,
            pabf: *u32,
            pprdatSteppingThread: **IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThread: fn(
            self: *const IDebugApplication64,
            pat: **IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAsyncDebugOperation: fn(
            self: *const IDebugApplication64,
            psdo: *IDebugSyncOperation,
            ppado: **IDebugAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStackFrameSniffer: fn(
            self: *const IDebugApplication64,
            pdsfs: *IDebugStackFrameSniffer,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStackFrameSniffer: fn(
            self: *const IDebugApplication64,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryCurrentThreadIsDebuggerThread: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SynchronousCallInDebuggerThread: fn(
            self: *const IDebugApplication64,
            pptc: *IDebugThreadCall64,
            dwParam1: u64,
            dwParam2: u64,
            dwParam3: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateApplicationNode: fn(
            self: *const IDebugApplication64,
            ppdanNew: **IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FireDebuggerEvent: fn(
            self: *const IDebugApplication64,
            riid: *const Guid,
            punk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleRuntimeError: fn(
            self: *const IDebugApplication64,
            pErrorDebug: *IActiveScriptErrorDebug,
            pScriptSite: *IActiveScriptSite,
            pbra: *tagBREAKRESUME_ACTION,
            perra: *ERRORRESUMEACTION,
            pfCallOnScriptError: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FCanJitDebug: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        FIsAutoJitDebugEnabled: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        AddGlobalExpressionContextProvider: fn(
            self: *const IDebugApplication64,
            pdsfs: *IProvideExpressionContexts,
            pdwCookie: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveGlobalExpressionContextProvider: fn(
            self: *const IDebugApplication64,
            dwCookie: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplication.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_SetName(self: *const T, pstrName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).SetName(@ptrCast(*const IDebugApplication64, self), pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_StepOutComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).StepOutComplete(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_DebugOutput(self: *const T, pstr: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).DebugOutput(@ptrCast(*const IDebugApplication64, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_StartDebugSession(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).StartDebugSession(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_HandleBreakPoint(self: *const T, br: BREAKREASON, pbra: *tagBREAKRESUME_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).HandleBreakPoint(@ptrCast(*const IDebugApplication64, self), br, pbra);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).Close(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_GetBreakFlags(self: *const T, pabf: *u32, pprdatSteppingThread: **IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).GetBreakFlags(@ptrCast(*const IDebugApplication64, self), pabf, pprdatSteppingThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_GetCurrentThread(self: *const T, pat: **IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).GetCurrentThread(@ptrCast(*const IDebugApplication64, self), pat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_CreateAsyncDebugOperation(self: *const T, psdo: *IDebugSyncOperation, ppado: **IDebugAsyncOperation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).CreateAsyncDebugOperation(@ptrCast(*const IDebugApplication64, self), psdo, ppado);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_AddStackFrameSniffer(self: *const T, pdsfs: *IDebugStackFrameSniffer, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).AddStackFrameSniffer(@ptrCast(*const IDebugApplication64, self), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_RemoveStackFrameSniffer(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).RemoveStackFrameSniffer(@ptrCast(*const IDebugApplication64, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_QueryCurrentThreadIsDebuggerThread(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).QueryCurrentThreadIsDebuggerThread(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_SynchronousCallInDebuggerThread(self: *const T, pptc: *IDebugThreadCall64, dwParam1: u64, dwParam2: u64, dwParam3: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).SynchronousCallInDebuggerThread(@ptrCast(*const IDebugApplication64, self), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_CreateApplicationNode(self: *const T, ppdanNew: **IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).CreateApplicationNode(@ptrCast(*const IDebugApplication64, self), ppdanNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_FireDebuggerEvent(self: *const T, riid: *const Guid, punk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).FireDebuggerEvent(@ptrCast(*const IDebugApplication64, self), riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_HandleRuntimeError(self: *const T, pErrorDebug: *IActiveScriptErrorDebug, pScriptSite: *IActiveScriptSite, pbra: *tagBREAKRESUME_ACTION, perra: *ERRORRESUMEACTION, pfCallOnScriptError: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).HandleRuntimeError(@ptrCast(*const IDebugApplication64, self), pErrorDebug, pScriptSite, pbra, perra, pfCallOnScriptError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_FCanJitDebug(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).FCanJitDebug(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_FIsAutoJitDebugEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).FIsAutoJitDebugEnabled(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_AddGlobalExpressionContextProvider(self: *const T, pdsfs: *IProvideExpressionContexts, pdwCookie: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).AddGlobalExpressionContextProvider(@ptrCast(*const IDebugApplication64, self), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_RemoveGlobalExpressionContextProvider(self: *const T, dwCookie: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).RemoveGlobalExpressionContextProvider(@ptrCast(*const IDebugApplication64, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplicationEvents_Value = @import("../zig.zig").Guid.initString("51973C33-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IRemoteDebugApplicationEvents = &IID_IRemoteDebugApplicationEvents_Value;
pub const IRemoteDebugApplicationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnConnectDebugger: fn(
            self: *const IRemoteDebugApplicationEvents,
            pad: *IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDisconnectDebugger: fn(
            self: *const IRemoteDebugApplicationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSetName: fn(
            self: *const IRemoteDebugApplicationEvents,
            pstrName: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDebugOutput: fn(
            self: *const IRemoteDebugApplicationEvents,
            pstr: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnClose: fn(
            self: *const IRemoteDebugApplicationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEnterBreakPoint: fn(
            self: *const IRemoteDebugApplicationEvents,
            prdat: *IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLeaveBreakPoint: fn(
            self: *const IRemoteDebugApplicationEvents,
            prdat: *IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCreateThread: fn(
            self: *const IRemoteDebugApplicationEvents,
            prdat: *IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDestroyThread: fn(
            self: *const IRemoteDebugApplicationEvents,
            prdat: *IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBreakFlagChange: fn(
            self: *const IRemoteDebugApplicationEvents,
            abf: u32,
            prdatSteppingThread: *IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnConnectDebugger(self: *const T, pad: *IApplicationDebugger) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnConnectDebugger(@ptrCast(*const IRemoteDebugApplicationEvents, self), pad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnDisconnectDebugger(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnDisconnectDebugger(@ptrCast(*const IRemoteDebugApplicationEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnSetName(self: *const T, pstrName: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnSetName(@ptrCast(*const IRemoteDebugApplicationEvents, self), pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnDebugOutput(self: *const T, pstr: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnDebugOutput(@ptrCast(*const IRemoteDebugApplicationEvents, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnClose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnClose(@ptrCast(*const IRemoteDebugApplicationEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnEnterBreakPoint(self: *const T, prdat: *IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnEnterBreakPoint(@ptrCast(*const IRemoteDebugApplicationEvents, self), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnLeaveBreakPoint(self: *const T, prdat: *IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnLeaveBreakPoint(@ptrCast(*const IRemoteDebugApplicationEvents, self), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnCreateThread(self: *const T, prdat: *IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnCreateThread(@ptrCast(*const IRemoteDebugApplicationEvents, self), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnDestroyThread(self: *const T, prdat: *IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnDestroyThread(@ptrCast(*const IRemoteDebugApplicationEvents, self), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnBreakFlagChange(self: *const T, abf: u32, prdatSteppingThread: *IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnBreakFlagChange(@ptrCast(*const IRemoteDebugApplicationEvents, self), abf, prdatSteppingThread);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationNode_Value = @import("../zig.zig").Guid.initString("51973C34-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugApplicationNode = &IID_IDebugApplicationNode_Value;
pub const IDebugApplicationNode = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentProvider.VTable,
        EnumChildren: fn(
            self: *const IDebugApplicationNode,
            pperddp: **IEnumDebugApplicationNodes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParent: fn(
            self: *const IDebugApplicationNode,
            pprddp: **IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentProvider: fn(
            self: *const IDebugApplicationNode,
            pddp: *IDebugDocumentProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Attach: fn(
            self: *const IDebugApplicationNode,
            pdanParent: *IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_EnumChildren(self: *const T, pperddp: **IEnumDebugApplicationNodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).EnumChildren(@ptrCast(*const IDebugApplicationNode, self), pperddp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_GetParent(self: *const T, pprddp: **IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).GetParent(@ptrCast(*const IDebugApplicationNode, self), pprddp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_SetDocumentProvider(self: *const T, pddp: *IDebugDocumentProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).SetDocumentProvider(@ptrCast(*const IDebugApplicationNode, self), pddp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).Close(@ptrCast(*const IDebugApplicationNode, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_Attach(self: *const T, pdanParent: *IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).Attach(@ptrCast(*const IDebugApplicationNode, self), pdanParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).Detach(@ptrCast(*const IDebugApplicationNode, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationNodeEvents_Value = @import("../zig.zig").Guid.initString("51973C35-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugApplicationNodeEvents = &IID_IDebugApplicationNodeEvents_Value;
pub const IDebugApplicationNodeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onAddChild: fn(
            self: *const IDebugApplicationNodeEvents,
            prddpChild: *IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onRemoveChild: fn(
            self: *const IDebugApplicationNodeEvents,
            prddpChild: *IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onDetach: fn(
            self: *const IDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onAttach: fn(
            self: *const IDebugApplicationNodeEvents,
            prddpParent: *IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onAddChild(self: *const T, prddpChild: *IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNodeEvents.VTable, self.vtable).onAddChild(@ptrCast(*const IDebugApplicationNodeEvents, self), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onRemoveChild(self: *const T, prddpChild: *IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNodeEvents.VTable, self.vtable).onRemoveChild(@ptrCast(*const IDebugApplicationNodeEvents, self), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onDetach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNodeEvents.VTable, self.vtable).onDetach(@ptrCast(*const IDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onAttach(self: *const T, prddpParent: *IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNodeEvents.VTable, self.vtable).onAttach(@ptrCast(*const IDebugApplicationNodeEvents, self), prddpParent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIDebugApplicationNodeEvents_Value = @import("../zig.zig").Guid.initString("A2E3AA3B-AA8D-4EBF-84CD-648B737B8C13");
pub const IID_AsyncIDebugApplicationNodeEvents = &IID_AsyncIDebugApplicationNodeEvents_Value;
pub const AsyncIDebugApplicationNodeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_onAddChild: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
            prddpChild: *IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_onAddChild: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_onRemoveChild: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
            prddpChild: *IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_onRemoveChild: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_onDetach: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_onDetach: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_onAttach: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
            prddpParent: *IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_onAttach: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onAddChild(self: *const T, prddpChild: *IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Begin_onAddChild(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onAddChild(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Finish_onAddChild(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onRemoveChild(self: *const T, prddpChild: *IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Begin_onRemoveChild(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onRemoveChild(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Finish_onRemoveChild(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onDetach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Begin_onDetach(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onDetach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Finish_onDetach(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onAttach(self: *const T, prddpParent: *IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Begin_onAttach(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self), prddpParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onAttach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Finish_onAttach(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugThreadCall32_Value = @import("../zig.zig").Guid.initString("51973C36-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugThreadCall32 = &IID_IDebugThreadCall32_Value;
pub const IDebugThreadCall32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadCallHandler: fn(
            self: *const IDebugThreadCall32,
            dwParam1: u32,
            dwParam2: u32,
            dwParam3: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugThreadCall32_ThreadCallHandler(self: *const T, dwParam1: u32, dwParam2: u32, dwParam3: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugThreadCall32.VTable, self.vtable).ThreadCallHandler(@ptrCast(*const IDebugThreadCall32, self), dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugThreadCall64_Value = @import("../zig.zig").Guid.initString("CB3FA335-E979-42FD-9FCF-A7546A0F3905");
pub const IID_IDebugThreadCall64 = &IID_IDebugThreadCall64_Value;
pub const IDebugThreadCall64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadCallHandler: fn(
            self: *const IDebugThreadCall64,
            dwParam1: u64,
            dwParam2: u64,
            dwParam3: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugThreadCall64_ThreadCallHandler(self: *const T, dwParam1: u64, dwParam2: u64, dwParam3: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugThreadCall64.VTable, self.vtable).ThreadCallHandler(@ptrCast(*const IDebugThreadCall64, self), dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplicationThread_Value = @import("../zig.zig").Guid.initString("51973C37-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IRemoteDebugApplicationThread = &IID_IRemoteDebugApplicationThread_Value;
pub const IRemoteDebugApplicationThread = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSystemThreadId: fn(
            self: *const IRemoteDebugApplicationThread,
            dwThreadId: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplication: fn(
            self: *const IRemoteDebugApplicationThread,
            pprda: **IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumStackFrames: fn(
            self: *const IRemoteDebugApplicationThread,
            ppedsf: **IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IRemoteDebugApplicationThread,
            pbstrDescription: *BSTR,
            pbstrState: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNextStatement: fn(
            self: *const IRemoteDebugApplicationThread,
            pStackFrame: *IDebugStackFrame,
            pCodeContext: *IDebugCodeContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IRemoteDebugApplicationThread,
            pState: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const IRemoteDebugApplicationThread,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IRemoteDebugApplicationThread,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSuspendCount: fn(
            self: *const IRemoteDebugApplicationThread,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetSystemThreadId(self: *const T, dwThreadId: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetSystemThreadId(@ptrCast(*const IRemoteDebugApplicationThread, self), dwThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetApplication(self: *const T, pprda: **IRemoteDebugApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetApplication(@ptrCast(*const IRemoteDebugApplicationThread, self), pprda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_EnumStackFrames(self: *const T, ppedsf: **IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).EnumStackFrames(@ptrCast(*const IRemoteDebugApplicationThread, self), ppedsf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetDescription(self: *const T, pbstrDescription: *BSTR, pbstrState: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetDescription(@ptrCast(*const IRemoteDebugApplicationThread, self), pbstrDescription, pbstrState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_SetNextStatement(self: *const T, pStackFrame: *IDebugStackFrame, pCodeContext: *IDebugCodeContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).SetNextStatement(@ptrCast(*const IRemoteDebugApplicationThread, self), pStackFrame, pCodeContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetState(self: *const T, pState: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetState(@ptrCast(*const IRemoteDebugApplicationThread, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_Suspend(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).Suspend(@ptrCast(*const IRemoteDebugApplicationThread, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_Resume(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).Resume(@ptrCast(*const IRemoteDebugApplicationThread, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetSuspendCount(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetSuspendCount(@ptrCast(*const IRemoteDebugApplicationThread, self), pdwCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread_Value = @import("../zig.zig").Guid.initString("51973C38-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugApplicationThread = &IID_IDebugApplicationThread_Value;
pub const IDebugApplicationThread = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplicationThread.VTable,
        SynchronousCallIntoThread32: fn(
            self: *const IDebugApplicationThread,
            pstcb: *IDebugThreadCall32,
            dwParam1: u32,
            dwParam2: u32,
            dwParam3: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryIsCurrentThread: fn(
            self: *const IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryIsDebuggerThread: fn(
            self: *const IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescription: fn(
            self: *const IDebugApplicationThread,
            pstrDescription: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStateString: fn(
            self: *const IDebugApplicationThread,
            pstrState: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplicationThread.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_SynchronousCallIntoThread32(self: *const T, pstcb: *IDebugThreadCall32, dwParam1: u32, dwParam2: u32, dwParam3: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).SynchronousCallIntoThread32(@ptrCast(*const IDebugApplicationThread, self), pstcb, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_QueryIsCurrentThread(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).QueryIsCurrentThread(@ptrCast(*const IDebugApplicationThread, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_QueryIsDebuggerThread(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).QueryIsDebuggerThread(@ptrCast(*const IDebugApplicationThread, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_SetDescription(self: *const T, pstrDescription: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).SetDescription(@ptrCast(*const IDebugApplicationThread, self), pstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_SetStateString(self: *const T, pstrState: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).SetStateString(@ptrCast(*const IDebugApplicationThread, self), pstrState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread64_Value = @import("../zig.zig").Guid.initString("9DAC5886-DBAD-456D-9DEE-5DEC39AB3DDA");
pub const IID_IDebugApplicationThread64 = &IID_IDebugApplicationThread64_Value;
pub const IDebugApplicationThread64 = extern struct {
    pub const VTable = extern struct {
        base: IDebugApplicationThread.VTable,
        SynchronousCallIntoThread64: fn(
            self: *const IDebugApplicationThread64,
            pstcb: *IDebugThreadCall64,
            dwParam1: u64,
            dwParam2: u64,
            dwParam3: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugApplicationThread.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread64_SynchronousCallIntoThread64(self: *const T, pstcb: *IDebugThreadCall64, dwParam1: u64, dwParam2: u64, dwParam3: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread64.VTable, self.vtable).SynchronousCallIntoThread64(@ptrCast(*const IDebugApplicationThread64, self), pstcb, dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCookie_Value = @import("../zig.zig").Guid.initString("51973C39-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugCookie = &IID_IDebugCookie_Value;
pub const IDebugCookie = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDebugCookie: fn(
            self: *const IDebugCookie,
            dwDebugAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCookie_SetDebugCookie(self: *const T, dwDebugAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCookie.VTable, self.vtable).SetDebugCookie(@ptrCast(*const IDebugCookie, self), dwDebugAppCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugApplicationNodes_Value = @import("../zig.zig").Guid.initString("51973C3A-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IEnumDebugApplicationNodes = &IID_IEnumDebugApplicationNodes_Value;
pub const IEnumDebugApplicationNodes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugApplicationNodes,
            celt: u32,
            pprddp: **IDebugApplicationNode,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugApplicationNodes,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugApplicationNodes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugApplicationNodes,
            pperddp: **IEnumDebugApplicationNodes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Next(self: *const T, celt: u32, pprddp: **IDebugApplicationNode, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugApplicationNodes.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugApplicationNodes, self), celt, pprddp, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugApplicationNodes.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugApplicationNodes, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugApplicationNodes.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugApplicationNodes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Clone(self: *const T, pperddp: **IEnumDebugApplicationNodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugApplicationNodes.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugApplicationNodes, self), pperddp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRemoteDebugApplications_Value = @import("../zig.zig").Guid.initString("51973C3B-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IEnumRemoteDebugApplications = &IID_IEnumRemoteDebugApplications_Value;
pub const IEnumRemoteDebugApplications = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumRemoteDebugApplications,
            celt: u32,
            ppda: **IRemoteDebugApplication,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumRemoteDebugApplications,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumRemoteDebugApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumRemoteDebugApplications,
            ppessd: **IEnumRemoteDebugApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Next(self: *const T, celt: u32, ppda: **IRemoteDebugApplication, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplications.VTable, self.vtable).Next(@ptrCast(*const IEnumRemoteDebugApplications, self), celt, ppda, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplications.VTable, self.vtable).Skip(@ptrCast(*const IEnumRemoteDebugApplications, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplications.VTable, self.vtable).Reset(@ptrCast(*const IEnumRemoteDebugApplications, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Clone(self: *const T, ppessd: **IEnumRemoteDebugApplications) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplications.VTable, self.vtable).Clone(@ptrCast(*const IEnumRemoteDebugApplications, self), ppessd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRemoteDebugApplicationThreads_Value = @import("../zig.zig").Guid.initString("51973C3C-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IEnumRemoteDebugApplicationThreads = &IID_IEnumRemoteDebugApplicationThreads_Value;
pub const IEnumRemoteDebugApplicationThreads = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumRemoteDebugApplicationThreads,
            celt: u32,
            pprdat: **IRemoteDebugApplicationThread,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumRemoteDebugApplicationThreads,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumRemoteDebugApplicationThreads,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumRemoteDebugApplicationThreads,
            pperdat: **IEnumRemoteDebugApplicationThreads,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Next(self: *const T, celt: u32, pprdat: **IRemoteDebugApplicationThread, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplicationThreads.VTable, self.vtable).Next(@ptrCast(*const IEnumRemoteDebugApplicationThreads, self), celt, pprdat, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplicationThreads.VTable, self.vtable).Skip(@ptrCast(*const IEnumRemoteDebugApplicationThreads, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplicationThreads.VTable, self.vtable).Reset(@ptrCast(*const IEnumRemoteDebugApplicationThreads, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Clone(self: *const T, pperdat: **IEnumRemoteDebugApplicationThreads) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplicationThreads.VTable, self.vtable).Clone(@ptrCast(*const IEnumRemoteDebugApplicationThreads, self), pperdat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugFormatter_Value = @import("../zig.zig").Guid.initString("51973C05-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugFormatter = &IID_IDebugFormatter_Value;
pub const IDebugFormatter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringForVariant: fn(
            self: *const IDebugFormatter,
            pvar: *VARIANT,
            nRadix: u32,
            pbstrValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVariantForString: fn(
            self: *const IDebugFormatter,
            pwstrValue: [*:0]const u16,
            pvar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringForVarType: fn(
            self: *const IDebugFormatter,
            vt: u16,
            ptdescArrayType: *TYPEDESC,
            pbstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFormatter_GetStringForVariant(self: *const T, pvar: *VARIANT, nRadix: u32, pbstrValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugFormatter.VTable, self.vtable).GetStringForVariant(@ptrCast(*const IDebugFormatter, self), pvar, nRadix, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFormatter_GetVariantForString(self: *const T, pwstrValue: [*:0]const u16, pvar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugFormatter.VTable, self.vtable).GetVariantForString(@ptrCast(*const IDebugFormatter, self), pwstrValue, pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFormatter_GetStringForVarType(self: *const T, vt: u16, ptdescArrayType: *TYPEDESC, pbstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugFormatter.VTable, self.vtable).GetStringForVarType(@ptrCast(*const IDebugFormatter, self), vt, ptdescArrayType, pbstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISimpleConnectionPoint_Value = @import("../zig.zig").Guid.initString("51973C3E-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_ISimpleConnectionPoint = &IID_ISimpleConnectionPoint_Value;
pub const ISimpleConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventCount: fn(
            self: *const ISimpleConnectionPoint,
            pulCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DescribeEvents: fn(
            self: *const ISimpleConnectionPoint,
            iEvent: u32,
            cEvents: u32,
            prgid: [*]i32,
            prgbstr: [*]BSTR,
            pcEventsFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const ISimpleConnectionPoint,
            pdisp: *IDispatch,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const ISimpleConnectionPoint,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_GetEventCount(self: *const T, pulCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleConnectionPoint.VTable, self.vtable).GetEventCount(@ptrCast(*const ISimpleConnectionPoint, self), pulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_DescribeEvents(self: *const T, iEvent: u32, cEvents: u32, prgid: [*]i32, prgbstr: [*]BSTR, pcEventsFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleConnectionPoint.VTable, self.vtable).DescribeEvents(@ptrCast(*const ISimpleConnectionPoint, self), iEvent, cEvents, prgid, prgbstr, pcEventsFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_Advise(self: *const T, pdisp: *IDispatch, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleConnectionPoint.VTable, self.vtable).Advise(@ptrCast(*const ISimpleConnectionPoint, self), pdisp, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleConnectionPoint.VTable, self.vtable).Unadvise(@ptrCast(*const ISimpleConnectionPoint, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHelper_Value = @import("../zig.zig").Guid.initString("51973C3F-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IDebugHelper = &IID_IDebugHelper_Value;
pub const IDebugHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePropertyBrowser: fn(
            self: *const IDebugHelper,
            pvar: *VARIANT,
            bstrName: [*:0]const u16,
            pdat: *IDebugApplicationThread,
            ppdob: **IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePropertyBrowserEx: fn(
            self: *const IDebugHelper,
            pvar: *VARIANT,
            bstrName: [*:0]const u16,
            pdat: *IDebugApplicationThread,
            pdf: *IDebugFormatter,
            ppdob: **IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSimpleConnectionPoint: fn(
            self: *const IDebugHelper,
            pdisp: *IDispatch,
            ppscp: **ISimpleConnectionPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHelper_CreatePropertyBrowser(self: *const T, pvar: *VARIANT, bstrName: [*:0]const u16, pdat: *IDebugApplicationThread, ppdob: **IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHelper.VTable, self.vtable).CreatePropertyBrowser(@ptrCast(*const IDebugHelper, self), pvar, bstrName, pdat, ppdob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHelper_CreatePropertyBrowserEx(self: *const T, pvar: *VARIANT, bstrName: [*:0]const u16, pdat: *IDebugApplicationThread, pdf: *IDebugFormatter, ppdob: **IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHelper.VTable, self.vtable).CreatePropertyBrowserEx(@ptrCast(*const IDebugHelper, self), pvar, bstrName, pdat, pdf, ppdob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHelper_CreateSimpleConnectionPoint(self: *const T, pdisp: *IDispatch, ppscp: **ISimpleConnectionPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHelper.VTable, self.vtable).CreateSimpleConnectionPoint(@ptrCast(*const IDebugHelper, self), pdisp, ppscp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugExpressionContexts_Value = @import("../zig.zig").Guid.initString("51973C40-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IEnumDebugExpressionContexts = &IID_IEnumDebugExpressionContexts_Value;
pub const IEnumDebugExpressionContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugExpressionContexts,
            celt: u32,
            ppdec: **IDebugExpressionContext,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugExpressionContexts,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugExpressionContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugExpressionContexts,
            ppedec: **IEnumDebugExpressionContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Next(self: *const T, celt: u32, ppdec: **IDebugExpressionContext, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExpressionContexts.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugExpressionContexts, self), celt, ppdec, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExpressionContexts.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugExpressionContexts, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExpressionContexts.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugExpressionContexts, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Clone(self: *const T, ppedec: **IEnumDebugExpressionContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExpressionContexts.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugExpressionContexts, self), ppedec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProvideExpressionContexts_Value = @import("../zig.zig").Guid.initString("51973C41-CB0C-11D0-B5C9-00A0244A0E7A");
pub const IID_IProvideExpressionContexts = &IID_IProvideExpressionContexts_Value;
pub const IProvideExpressionContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumExpressionContexts: fn(
            self: *const IProvideExpressionContexts,
            ppedec: **IEnumDebugExpressionContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProvideExpressionContexts_EnumExpressionContexts(self: *const T, ppedec: **IEnumDebugExpressionContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProvideExpressionContexts.VTable, self.vtable).EnumExpressionContexts(@ptrCast(*const IProvideExpressionContexts, self), ppedec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_activprof_0000_0000_0001 = extern enum(i32) {
    PROFILER_SCRIPT_TYPE_USER = 0,
    PROFILER_SCRIPT_TYPE_DYNAMIC = 1,
    PROFILER_SCRIPT_TYPE_NATIVE = 2,
    PROFILER_SCRIPT_TYPE_DOM = 3,
};
pub const PROFILER_SCRIPT_TYPE_USER = __MIDL___MIDL_itf_activprof_0000_0000_0001.PROFILER_SCRIPT_TYPE_USER;
pub const PROFILER_SCRIPT_TYPE_DYNAMIC = __MIDL___MIDL_itf_activprof_0000_0000_0001.PROFILER_SCRIPT_TYPE_DYNAMIC;
pub const PROFILER_SCRIPT_TYPE_NATIVE = __MIDL___MIDL_itf_activprof_0000_0000_0001.PROFILER_SCRIPT_TYPE_NATIVE;
pub const PROFILER_SCRIPT_TYPE_DOM = __MIDL___MIDL_itf_activprof_0000_0000_0001.PROFILER_SCRIPT_TYPE_DOM;

pub const __MIDL___MIDL_itf_activprof_0000_0000_0002 = extern enum(i32) {
    PROFILER_EVENT_MASK_TRACE_SCRIPT_FUNCTION_CALL = 1,
    PROFILER_EVENT_MASK_TRACE_NATIVE_FUNCTION_CALL = 2,
    PROFILER_EVENT_MASK_TRACE_DOM_FUNCTION_CALL = 4,
    PROFILER_EVENT_MASK_TRACE_ALL = 3,
    PROFILER_EVENT_MASK_TRACE_ALL_WITH_DOM = 7,
};
pub const PROFILER_EVENT_MASK_TRACE_SCRIPT_FUNCTION_CALL = __MIDL___MIDL_itf_activprof_0000_0000_0002.PROFILER_EVENT_MASK_TRACE_SCRIPT_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_NATIVE_FUNCTION_CALL = __MIDL___MIDL_itf_activprof_0000_0000_0002.PROFILER_EVENT_MASK_TRACE_NATIVE_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_DOM_FUNCTION_CALL = __MIDL___MIDL_itf_activprof_0000_0000_0002.PROFILER_EVENT_MASK_TRACE_DOM_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_ALL = __MIDL___MIDL_itf_activprof_0000_0000_0002.PROFILER_EVENT_MASK_TRACE_ALL;
pub const PROFILER_EVENT_MASK_TRACE_ALL_WITH_DOM = __MIDL___MIDL_itf_activprof_0000_0000_0002.PROFILER_EVENT_MASK_TRACE_ALL_WITH_DOM;

const IID_IActiveScriptProfilerControl_Value = @import("../zig.zig").Guid.initString("784B5FF0-69B0-47D1-A7DC-2518F4230E90");
pub const IID_IActiveScriptProfilerControl = &IID_IActiveScriptProfilerControl_Value;
pub const IActiveScriptProfilerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartProfiling: fn(
            self: *const IActiveScriptProfilerControl,
            clsidProfilerObject: *const Guid,
            dwEventMask: u32,
            dwContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProfilerEventMask: fn(
            self: *const IActiveScriptProfilerControl,
            dwEventMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopProfiling: fn(
            self: *const IActiveScriptProfilerControl,
            hrShutdownReason: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl_StartProfiling(self: *const T, clsidProfilerObject: *const Guid, dwEventMask: u32, dwContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl.VTable, self.vtable).StartProfiling(@ptrCast(*const IActiveScriptProfilerControl, self), clsidProfilerObject, dwEventMask, dwContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl_SetProfilerEventMask(self: *const T, dwEventMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl.VTable, self.vtable).SetProfilerEventMask(@ptrCast(*const IActiveScriptProfilerControl, self), dwEventMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl_StopProfiling(self: *const T, hrShutdownReason: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl.VTable, self.vtable).StopProfiling(@ptrCast(*const IActiveScriptProfilerControl, self), hrShutdownReason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl2_Value = @import("../zig.zig").Guid.initString("47810165-498F-40BE-94F1-653557E9E7DA");
pub const IID_IActiveScriptProfilerControl2 = &IID_IActiveScriptProfilerControl2_Value;
pub const IActiveScriptProfilerControl2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl.VTable,
        CompleteProfilerStart: fn(
            self: *const IActiveScriptProfilerControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrepareProfilerStop: fn(
            self: *const IActiveScriptProfilerControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl2_CompleteProfilerStart(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl2.VTable, self.vtable).CompleteProfilerStart(@ptrCast(*const IActiveScriptProfilerControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl2_PrepareProfilerStop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl2.VTable, self.vtable).PrepareProfilerStop(@ptrCast(*const IActiveScriptProfilerControl2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_activprof_0000_0002_0001 = extern enum(i32) {
    PROFILER_HEAP_OBJECT_FLAGS_NEW_OBJECT = 1,
    PROFILER_HEAP_OBJECT_FLAGS_IS_ROOT = 2,
    PROFILER_HEAP_OBJECT_FLAGS_SITE_CLOSED = 4,
    PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL = 8,
    PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_UNKNOWN = 16,
    PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_DISPATCH = 32,
    PROFILER_HEAP_OBJECT_FLAGS_SIZE_APPROXIMATE = 64,
    PROFILER_HEAP_OBJECT_FLAGS_SIZE_UNAVAILABLE = 128,
    PROFILER_HEAP_OBJECT_FLAGS_NEW_STATE_UNAVAILABLE = 256,
    PROFILER_HEAP_OBJECT_FLAGS_WINRT_INSTANCE = 512,
    PROFILER_HEAP_OBJECT_FLAGS_WINRT_RUNTIMECLASS = 1024,
    PROFILER_HEAP_OBJECT_FLAGS_WINRT_DELEGATE = 2048,
    PROFILER_HEAP_OBJECT_FLAGS_WINRT_NAMESPACE = 4096,
};
pub const PROFILER_HEAP_OBJECT_FLAGS_NEW_OBJECT = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_NEW_OBJECT;
pub const PROFILER_HEAP_OBJECT_FLAGS_IS_ROOT = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_IS_ROOT;
pub const PROFILER_HEAP_OBJECT_FLAGS_SITE_CLOSED = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_SITE_CLOSED;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_UNKNOWN = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_UNKNOWN;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_DISPATCH = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_DISPATCH;
pub const PROFILER_HEAP_OBJECT_FLAGS_SIZE_APPROXIMATE = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_SIZE_APPROXIMATE;
pub const PROFILER_HEAP_OBJECT_FLAGS_SIZE_UNAVAILABLE = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_SIZE_UNAVAILABLE;
pub const PROFILER_HEAP_OBJECT_FLAGS_NEW_STATE_UNAVAILABLE = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_NEW_STATE_UNAVAILABLE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_INSTANCE = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_WINRT_INSTANCE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_RUNTIMECLASS = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_WINRT_RUNTIMECLASS;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_DELEGATE = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_WINRT_DELEGATE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_NAMESPACE = __MIDL___MIDL_itf_activprof_0000_0002_0001.PROFILER_HEAP_OBJECT_FLAGS_WINRT_NAMESPACE;

pub const __MIDL___MIDL_itf_activprof_0000_0002_0002 = extern enum(i32) {
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_PROTOTYPE = 1,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_FUNCTION_NAME = 2,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SCOPE_LIST = 3,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INTERNAL_PROPERTY = 4,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_NAME_PROPERTIES = 5,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INDEX_PROPERTIES = 6,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_ATTRIBUTES_SIZE = 7,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_TEXT_CHILDREN_SIZE = 8,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_RELATIONSHIPS = 9,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WINRTEVENTS = 10,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WEAKMAP_COLLECTION_LIST = 11,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAP_COLLECTION_LIST = 12,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SET_COLLECTION_LIST = 13,
    PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAX_VALUE = 13,
};
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_PROTOTYPE = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_PROTOTYPE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_FUNCTION_NAME = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_FUNCTION_NAME;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SCOPE_LIST = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SCOPE_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INTERNAL_PROPERTY = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INTERNAL_PROPERTY;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_NAME_PROPERTIES = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_NAME_PROPERTIES;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INDEX_PROPERTIES = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INDEX_PROPERTIES;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_ATTRIBUTES_SIZE = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_ATTRIBUTES_SIZE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_TEXT_CHILDREN_SIZE = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_TEXT_CHILDREN_SIZE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_RELATIONSHIPS = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_RELATIONSHIPS;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WINRTEVENTS = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WINRTEVENTS;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WEAKMAP_COLLECTION_LIST = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WEAKMAP_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAP_COLLECTION_LIST = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAP_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SET_COLLECTION_LIST = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SET_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAX_VALUE = __MIDL___MIDL_itf_activprof_0000_0002_0002.PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAX_VALUE;

pub const __MIDL___MIDL_itf_activprof_0000_0002_0003 = extern enum(i32) {
    PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_NONE = 0,
    PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_GET_ACCESSOR = 65536,
    PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_SET_ACCESSOR = 131072,
    PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_LET_VARIABLE = 262144,
    PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_CONST_VARIABLE = 524288,
};
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_NONE = __MIDL___MIDL_itf_activprof_0000_0002_0003.PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_NONE;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_GET_ACCESSOR = __MIDL___MIDL_itf_activprof_0000_0002_0003.PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_GET_ACCESSOR;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_SET_ACCESSOR = __MIDL___MIDL_itf_activprof_0000_0002_0003.PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_SET_ACCESSOR;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_LET_VARIABLE = __MIDL___MIDL_itf_activprof_0000_0002_0003.PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_LET_VARIABLE;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_CONST_VARIABLE = __MIDL___MIDL_itf_activprof_0000_0002_0003.PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_CONST_VARIABLE;

pub const __MIDL___MIDL_itf_activprof_0000_0002_0004 = extern enum(i32) {
    PROFILER_HEAP_ENUM_FLAGS_NONE = 0,
    PROFILER_HEAP_ENUM_FLAGS_STORE_RELATIONSHIP_FLAGS = 1,
    PROFILER_HEAP_ENUM_FLAGS_SUBSTRINGS = 2,
    PROFILER_HEAP_ENUM_FLAGS_RELATIONSHIP_SUBSTRINGS = 3,
};
pub const PROFILER_HEAP_ENUM_FLAGS_NONE = __MIDL___MIDL_itf_activprof_0000_0002_0004.PROFILER_HEAP_ENUM_FLAGS_NONE;
pub const PROFILER_HEAP_ENUM_FLAGS_STORE_RELATIONSHIP_FLAGS = __MIDL___MIDL_itf_activprof_0000_0002_0004.PROFILER_HEAP_ENUM_FLAGS_STORE_RELATIONSHIP_FLAGS;
pub const PROFILER_HEAP_ENUM_FLAGS_SUBSTRINGS = __MIDL___MIDL_itf_activprof_0000_0002_0004.PROFILER_HEAP_ENUM_FLAGS_SUBSTRINGS;
pub const PROFILER_HEAP_ENUM_FLAGS_RELATIONSHIP_SUBSTRINGS = __MIDL___MIDL_itf_activprof_0000_0002_0004.PROFILER_HEAP_ENUM_FLAGS_RELATIONSHIP_SUBSTRINGS;

pub const PROFILER_HEAP_OBJECT_SCOPE_LIST = extern struct {
    count: u32,
    scopes: [1]?*c_void,
};

pub const __MIDL___MIDL_itf_activprof_0000_0002_0005 = extern enum(i32) {
    PROFILER_PROPERTY_TYPE_NUMBER = 1,
    PROFILER_PROPERTY_TYPE_STRING = 2,
    PROFILER_PROPERTY_TYPE_HEAP_OBJECT = 3,
    PROFILER_PROPERTY_TYPE_EXTERNAL_OBJECT = 4,
    PROFILER_PROPERTY_TYPE_BSTR = 5,
    PROFILER_PROPERTY_TYPE_SUBSTRING = 6,
};
pub const PROFILER_PROPERTY_TYPE_NUMBER = __MIDL___MIDL_itf_activprof_0000_0002_0005.PROFILER_PROPERTY_TYPE_NUMBER;
pub const PROFILER_PROPERTY_TYPE_STRING = __MIDL___MIDL_itf_activprof_0000_0002_0005.PROFILER_PROPERTY_TYPE_STRING;
pub const PROFILER_PROPERTY_TYPE_HEAP_OBJECT = __MIDL___MIDL_itf_activprof_0000_0002_0005.PROFILER_PROPERTY_TYPE_HEAP_OBJECT;
pub const PROFILER_PROPERTY_TYPE_EXTERNAL_OBJECT = __MIDL___MIDL_itf_activprof_0000_0002_0005.PROFILER_PROPERTY_TYPE_EXTERNAL_OBJECT;
pub const PROFILER_PROPERTY_TYPE_BSTR = __MIDL___MIDL_itf_activprof_0000_0002_0005.PROFILER_PROPERTY_TYPE_BSTR;
pub const PROFILER_PROPERTY_TYPE_SUBSTRING = __MIDL___MIDL_itf_activprof_0000_0002_0005.PROFILER_PROPERTY_TYPE_SUBSTRING;

pub const PROFILER_PROPERTY_TYPE_SUBSTRING_INFO = extern struct {
    length: u32,
    value: [*:0]const u16,
};

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP = extern struct {
    relationshipId: u32,
    relationshipInfo: __MIDL___MIDL_itf_activprof_0000_0002_0005,
    Anonymous: PROFILER_HEAP_OBJECT_RELATIONSHIP._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST = extern struct {
    count: u32,
    elements: [1]PROFILER_HEAP_OBJECT_RELATIONSHIP,
};

pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO = extern struct {
    infoType: __MIDL___MIDL_itf_activprof_0000_0002_0002,
    Anonymous: PROFILER_HEAP_OBJECT_OPTIONAL_INFO._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const PROFILER_HEAP_OBJECT = extern struct {
    size: u32,
    Anonymous: PROFILER_HEAP_OBJECT._Anonymous_e__Union,
    typeNameId: u32,
    flags: u32,
    unused: u16,
    optionalInfoCount: u16,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

const IID_IActiveScriptProfilerHeapEnum_Value = @import("../zig.zig").Guid.initString("32E4694E-0D37-419B-B93D-FA20DED6E8EA");
pub const IID_IActiveScriptProfilerHeapEnum = &IID_IActiveScriptProfilerHeapEnum_Value;
pub const IActiveScriptProfilerHeapEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IActiveScriptProfilerHeapEnum,
            celt: u32,
            heapObjects: [*]*PROFILER_HEAP_OBJECT,
            pceltFetched: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionalInfo: fn(
            self: *const IActiveScriptProfilerHeapEnum,
            heapObject: *PROFILER_HEAP_OBJECT,
            celt: u32,
            optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeObjectAndOptionalInfo: fn(
            self: *const IActiveScriptProfilerHeapEnum,
            celt: u32,
            heapObjects: [*]*PROFILER_HEAP_OBJECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameIdMap: fn(
            self: *const IActiveScriptProfilerHeapEnum,
            pNameList: [*]**PWSTR,
            pcelt: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_Next(self: *const T, celt: u32, heapObjects: [*]*PROFILER_HEAP_OBJECT, pceltFetched: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerHeapEnum.VTable, self.vtable).Next(@ptrCast(*const IActiveScriptProfilerHeapEnum, self), celt, heapObjects, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_GetOptionalInfo(self: *const T, heapObject: *PROFILER_HEAP_OBJECT, celt: u32, optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerHeapEnum.VTable, self.vtable).GetOptionalInfo(@ptrCast(*const IActiveScriptProfilerHeapEnum, self), heapObject, celt, optionalInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_FreeObjectAndOptionalInfo(self: *const T, celt: u32, heapObjects: [*]*PROFILER_HEAP_OBJECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerHeapEnum.VTable, self.vtable).FreeObjectAndOptionalInfo(@ptrCast(*const IActiveScriptProfilerHeapEnum, self), celt, heapObjects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_GetNameIdMap(self: *const T, pNameList: [*]**PWSTR, pcelt: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerHeapEnum.VTable, self.vtable).GetNameIdMap(@ptrCast(*const IActiveScriptProfilerHeapEnum, self), pNameList, pcelt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl3_Value = @import("../zig.zig").Guid.initString("0B403015-F381-4023-A5D0-6FED076DE716");
pub const IID_IActiveScriptProfilerControl3 = &IID_IActiveScriptProfilerControl3_Value;
pub const IActiveScriptProfilerControl3 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl2.VTable,
        EnumHeap: fn(
            self: *const IActiveScriptProfilerControl3,
            ppEnum: **IActiveScriptProfilerHeapEnum,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl3_EnumHeap(self: *const T, ppEnum: **IActiveScriptProfilerHeapEnum) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl3.VTable, self.vtable).EnumHeap(@ptrCast(*const IActiveScriptProfilerControl3, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const __MIDL___MIDL_itf_activprof_0000_0004_0001 = extern enum(i32) {
    PROFILER_HEAP_SUMMARY_VERSION_1 = 1,
};
pub const PROFILER_HEAP_SUMMARY_VERSION_1 = __MIDL___MIDL_itf_activprof_0000_0004_0001.PROFILER_HEAP_SUMMARY_VERSION_1;

pub const PROFILER_HEAP_SUMMARY = extern struct {
    version: __MIDL___MIDL_itf_activprof_0000_0004_0001,
    totalHeapSize: u32,
};

const IID_IActiveScriptProfilerControl4_Value = @import("../zig.zig").Guid.initString("160F94FD-9DBC-40D4-9EAC-2B71DB3132F4");
pub const IID_IActiveScriptProfilerControl4 = &IID_IActiveScriptProfilerControl4_Value;
pub const IActiveScriptProfilerControl4 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl3.VTable,
        SummarizeHeap: fn(
            self: *const IActiveScriptProfilerControl4,
            heapSummary: *PROFILER_HEAP_SUMMARY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl4_SummarizeHeap(self: *const T, heapSummary: *PROFILER_HEAP_SUMMARY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl4.VTable, self.vtable).SummarizeHeap(@ptrCast(*const IActiveScriptProfilerControl4, self), heapSummary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl5_Value = @import("../zig.zig").Guid.initString("1C01A2D1-8F0F-46A5-9720-0D7ED2C62F0A");
pub const IID_IActiveScriptProfilerControl5 = &IID_IActiveScriptProfilerControl5_Value;
pub const IActiveScriptProfilerControl5 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl4.VTable,
        EnumHeap2: fn(
            self: *const IActiveScriptProfilerControl5,
            enumFlags: __MIDL___MIDL_itf_activprof_0000_0002_0004,
            ppEnum: **IActiveScriptProfilerHeapEnum,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl5_EnumHeap2(self: *const T, enumFlags: __MIDL___MIDL_itf_activprof_0000_0002_0004, ppEnum: **IActiveScriptProfilerHeapEnum) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl5.VTable, self.vtable).EnumHeap2(@ptrCast(*const IActiveScriptProfilerControl5, self), enumFlags, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback_Value = @import("../zig.zig").Guid.initString("740ECA23-7D9D-42E5-BA9D-F8B24B1C7A9B");
pub const IID_IActiveScriptProfilerCallback = &IID_IActiveScriptProfilerCallback_Value;
pub const IActiveScriptProfilerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IActiveScriptProfilerCallback,
            dwContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IActiveScriptProfilerCallback,
            hrReason: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScriptCompiled: fn(
            self: *const IActiveScriptProfilerCallback,
            scriptId: i32,
            type: __MIDL___MIDL_itf_activprof_0000_0000_0001,
            pIDebugDocumentContext: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FunctionCompiled: fn(
            self: *const IActiveScriptProfilerCallback,
            functionId: i32,
            scriptId: i32,
            pwszFunctionName: [*:0]const u16,
            pwszFunctionNameHint: [*:0]const u16,
            pIDebugDocumentContext: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFunctionEnter: fn(
            self: *const IActiveScriptProfilerCallback,
            scriptId: i32,
            functionId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFunctionExit: fn(
            self: *const IActiveScriptProfilerCallback,
            scriptId: i32,
            functionId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_Initialize(self: *const T, dwContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).Initialize(@ptrCast(*const IActiveScriptProfilerCallback, self), dwContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_Shutdown(self: *const T, hrReason: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).Shutdown(@ptrCast(*const IActiveScriptProfilerCallback, self), hrReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_ScriptCompiled(self: *const T, scriptId: i32, type: __MIDL___MIDL_itf_activprof_0000_0000_0001, pIDebugDocumentContext: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).ScriptCompiled(@ptrCast(*const IActiveScriptProfilerCallback, self), scriptId, type, pIDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_FunctionCompiled(self: *const T, functionId: i32, scriptId: i32, pwszFunctionName: [*:0]const u16, pwszFunctionNameHint: [*:0]const u16, pIDebugDocumentContext: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).FunctionCompiled(@ptrCast(*const IActiveScriptProfilerCallback, self), functionId, scriptId, pwszFunctionName, pwszFunctionNameHint, pIDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_OnFunctionEnter(self: *const T, scriptId: i32, functionId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).OnFunctionEnter(@ptrCast(*const IActiveScriptProfilerCallback, self), scriptId, functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_OnFunctionExit(self: *const T, scriptId: i32, functionId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).OnFunctionExit(@ptrCast(*const IActiveScriptProfilerCallback, self), scriptId, functionId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback2_Value = @import("../zig.zig").Guid.initString("31B7F8AD-A637-409C-B22F-040995B6103D");
pub const IID_IActiveScriptProfilerCallback2 = &IID_IActiveScriptProfilerCallback2_Value;
pub const IActiveScriptProfilerCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerCallback.VTable,
        OnFunctionEnterByName: fn(
            self: *const IActiveScriptProfilerCallback2,
            pwszFunctionName: [*:0]const u16,
            type: __MIDL___MIDL_itf_activprof_0000_0000_0001,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFunctionExitByName: fn(
            self: *const IActiveScriptProfilerCallback2,
            pwszFunctionName: [*:0]const u16,
            type: __MIDL___MIDL_itf_activprof_0000_0000_0001,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback2_OnFunctionEnterByName(self: *const T, pwszFunctionName: [*:0]const u16, type: __MIDL___MIDL_itf_activprof_0000_0000_0001) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback2.VTable, self.vtable).OnFunctionEnterByName(@ptrCast(*const IActiveScriptProfilerCallback2, self), pwszFunctionName, type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback2_OnFunctionExitByName(self: *const T, pwszFunctionName: [*:0]const u16, type: __MIDL___MIDL_itf_activprof_0000_0000_0001) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback2.VTable, self.vtable).OnFunctionExitByName(@ptrCast(*const IActiveScriptProfilerCallback2, self), pwszFunctionName, type);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback3_Value = @import("../zig.zig").Guid.initString("6AC5AD25-2037-4687-91DF-B59979D93D73");
pub const IID_IActiveScriptProfilerCallback3 = &IID_IActiveScriptProfilerCallback3_Value;
pub const IActiveScriptProfilerCallback3 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerCallback2.VTable,
        SetWebWorkerId: fn(
            self: *const IActiveScriptProfilerCallback3,
            webWorkerId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerCallback2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback3_SetWebWorkerId(self: *const T, webWorkerId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback3.VTable, self.vtable).SetWebWorkerId(@ptrCast(*const IActiveScriptProfilerCallback3, self), webWorkerId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_HTMLCSSStyleDeclaration_Value = @import("../zig.zig").Guid.initString("30510741-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLCSSStyleDeclaration = &CLSID_HTMLCSSStyleDeclaration_Value;

const CLSID_HTMLStyle_Value = @import("../zig.zig").Guid.initString("3050F285-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyle = &CLSID_HTMLStyle_Value;

const CLSID_HTMLRuleStyle_Value = @import("../zig.zig").Guid.initString("3050F3D0-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLRuleStyle = &CLSID_HTMLRuleStyle_Value;

const CLSID_HTMLCSSRule_Value = @import("../zig.zig").Guid.initString("305106EF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLCSSRule = &CLSID_HTMLCSSRule_Value;

const CLSID_HTMLCSSImportRule_Value = @import("../zig.zig").Guid.initString("305106F0-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLCSSImportRule = &CLSID_HTMLCSSImportRule_Value;

const CLSID_HTMLCSSMediaRule_Value = @import("../zig.zig").Guid.initString("305106F1-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLCSSMediaRule = &CLSID_HTMLCSSMediaRule_Value;

const CLSID_HTMLCSSMediaList_Value = @import("../zig.zig").Guid.initString("30510732-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLCSSMediaList = &CLSID_HTMLCSSMediaList_Value;

const CLSID_HTMLCSSNamespaceRule_Value = @import("../zig.zig").Guid.initString("305106F2-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLCSSNamespaceRule = &CLSID_HTMLCSSNamespaceRule_Value;

const CLSID_HTMLMSCSSKeyframeRule_Value = @import("../zig.zig").Guid.initString("3051080E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLMSCSSKeyframeRule = &CLSID_HTMLMSCSSKeyframeRule_Value;

const CLSID_HTMLMSCSSKeyframesRule_Value = @import("../zig.zig").Guid.initString("3051080F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLMSCSSKeyframesRule = &CLSID_HTMLMSCSSKeyframesRule_Value;

const CLSID_HTMLRenderStyle_Value = @import("../zig.zig").Guid.initString("3050F6AA-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLRenderStyle = &CLSID_HTMLRenderStyle_Value;

const CLSID_HTMLCurrentStyle_Value = @import("../zig.zig").Guid.initString("3050F3DC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLCurrentStyle = &CLSID_HTMLCurrentStyle_Value;

const CLSID_HTMLDOMAttribute_Value = @import("../zig.zig").Guid.initString("3050F4B2-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDOMAttribute = &CLSID_HTMLDOMAttribute_Value;

const CLSID_HTMLDOMTextNode_Value = @import("../zig.zig").Guid.initString("3050F4BA-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDOMTextNode = &CLSID_HTMLDOMTextNode_Value;

const CLSID_HTMLDOMImplementation_Value = @import("../zig.zig").Guid.initString("3050F80E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDOMImplementation = &CLSID_HTMLDOMImplementation_Value;

const CLSID_HTMLAttributeCollection_Value = @import("../zig.zig").Guid.initString("3050F4CC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLAttributeCollection = &CLSID_HTMLAttributeCollection_Value;

const CLSID_StaticNodeList_Value = @import("../zig.zig").Guid.initString("30510467-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_StaticNodeList = &CLSID_StaticNodeList_Value;

const CLSID_DOMChildrenCollection_Value = @import("../zig.zig").Guid.initString("3050F5AA-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMChildrenCollection = &CLSID_DOMChildrenCollection_Value;

const CLSID_HTMLDefaults_Value = @import("../zig.zig").Guid.initString("3050F6C8-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDefaults = &CLSID_HTMLDefaults_Value;

const CLSID_HTCDefaultDispatch_Value = @import("../zig.zig").Guid.initString("3050F4FC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTCDefaultDispatch = &CLSID_HTCDefaultDispatch_Value;

const CLSID_HTCPropertyBehavior_Value = @import("../zig.zig").Guid.initString("3050F5DE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTCPropertyBehavior = &CLSID_HTCPropertyBehavior_Value;

const CLSID_HTCMethodBehavior_Value = @import("../zig.zig").Guid.initString("3050F630-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTCMethodBehavior = &CLSID_HTCMethodBehavior_Value;

const CLSID_HTCEventBehavior_Value = @import("../zig.zig").Guid.initString("3050F4FE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTCEventBehavior = &CLSID_HTCEventBehavior_Value;

const CLSID_HTCAttachBehavior_Value = @import("../zig.zig").Guid.initString("3050F5F5-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTCAttachBehavior = &CLSID_HTCAttachBehavior_Value;

const CLSID_HTCDescBehavior_Value = @import("../zig.zig").Guid.initString("3050F5DD-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTCDescBehavior = &CLSID_HTCDescBehavior_Value;

const CLSID_HTMLUrnCollection_Value = @import("../zig.zig").Guid.initString("3050F580-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLUrnCollection = &CLSID_HTMLUrnCollection_Value;

const CLSID_HTMLGenericElement_Value = @import("../zig.zig").Guid.initString("3050F4B8-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLGenericElement = &CLSID_HTMLGenericElement_Value;

const CLSID_HTMLStyleSheetRule_Value = @import("../zig.zig").Guid.initString("3050F3CE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyleSheetRule = &CLSID_HTMLStyleSheetRule_Value;

const CLSID_HTMLStyleSheetRulesCollection_Value = @import("../zig.zig").Guid.initString("3050F3CD-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyleSheetRulesCollection = &CLSID_HTMLStyleSheetRulesCollection_Value;

const CLSID_HTMLStyleSheetPage_Value = @import("../zig.zig").Guid.initString("3050F7EF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyleSheetPage = &CLSID_HTMLStyleSheetPage_Value;

const CLSID_HTMLStyleSheetPagesCollection_Value = @import("../zig.zig").Guid.initString("3050F7F1-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyleSheetPagesCollection = &CLSID_HTMLStyleSheetPagesCollection_Value;

const CLSID_HTMLStyleSheet_Value = @import("../zig.zig").Guid.initString("3050F2E4-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyleSheet = &CLSID_HTMLStyleSheet_Value;

const CLSID_HTMLStyleSheetsCollection_Value = @import("../zig.zig").Guid.initString("3050F37F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyleSheetsCollection = &CLSID_HTMLStyleSheetsCollection_Value;

const CLSID_HTMLLinkElement_Value = @import("../zig.zig").Guid.initString("3050F277-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLLinkElement = &CLSID_HTMLLinkElement_Value;

const CLSID_HTMLDOMRange_Value = @import("../zig.zig").Guid.initString("305106C3-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDOMRange = &CLSID_HTMLDOMRange_Value;

const CLSID_HTMLFormElement_Value = @import("../zig.zig").Guid.initString("3050F251-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLFormElement = &CLSID_HTMLFormElement_Value;

const CLSID_HTMLTextElement_Value = @import("../zig.zig").Guid.initString("3050F26A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTextElement = &CLSID_HTMLTextElement_Value;

const CLSID_HTMLImg_Value = @import("../zig.zig").Guid.initString("3050F241-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLImg = &CLSID_HTMLImg_Value;

const CLSID_HTMLImageElementFactory_Value = @import("../zig.zig").Guid.initString("3050F38F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLImageElementFactory = &CLSID_HTMLImageElementFactory_Value;

const CLSID_HTMLBody_Value = @import("../zig.zig").Guid.initString("3050F24A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLBody = &CLSID_HTMLBody_Value;

const CLSID_HTMLFontElement_Value = @import("../zig.zig").Guid.initString("3050F27B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLFontElement = &CLSID_HTMLFontElement_Value;

const CLSID_HTMLAnchorElement_Value = @import("../zig.zig").Guid.initString("3050F248-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLAnchorElement = &CLSID_HTMLAnchorElement_Value;

const CLSID_HTMLLabelElement_Value = @import("../zig.zig").Guid.initString("3050F32B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLLabelElement = &CLSID_HTMLLabelElement_Value;

const CLSID_HTMLListElement_Value = @import("../zig.zig").Guid.initString("3050F272-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLListElement = &CLSID_HTMLListElement_Value;

const CLSID_HTMLUListElement_Value = @import("../zig.zig").Guid.initString("3050F269-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLUListElement = &CLSID_HTMLUListElement_Value;

const CLSID_HTMLOListElement_Value = @import("../zig.zig").Guid.initString("3050F270-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLOListElement = &CLSID_HTMLOListElement_Value;

const CLSID_HTMLLIElement_Value = @import("../zig.zig").Guid.initString("3050F273-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLLIElement = &CLSID_HTMLLIElement_Value;

const CLSID_HTMLBlockElement_Value = @import("../zig.zig").Guid.initString("3050F281-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLBlockElement = &CLSID_HTMLBlockElement_Value;

const CLSID_HTMLDivElement_Value = @import("../zig.zig").Guid.initString("3050F27E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDivElement = &CLSID_HTMLDivElement_Value;

const CLSID_HTMLDDElement_Value = @import("../zig.zig").Guid.initString("3050F27F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDDElement = &CLSID_HTMLDDElement_Value;

const CLSID_HTMLDTElement_Value = @import("../zig.zig").Guid.initString("3050F27C-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDTElement = &CLSID_HTMLDTElement_Value;

const CLSID_HTMLBRElement_Value = @import("../zig.zig").Guid.initString("3050F280-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLBRElement = &CLSID_HTMLBRElement_Value;

const CLSID_HTMLDListElement_Value = @import("../zig.zig").Guid.initString("3050F27D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDListElement = &CLSID_HTMLDListElement_Value;

const CLSID_HTMLHRElement_Value = @import("../zig.zig").Guid.initString("3050F252-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLHRElement = &CLSID_HTMLHRElement_Value;

const CLSID_HTMLParaElement_Value = @import("../zig.zig").Guid.initString("3050F26F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLParaElement = &CLSID_HTMLParaElement_Value;

const CLSID_HTMLElementCollection_Value = @import("../zig.zig").Guid.initString("3050F4CB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLElementCollection = &CLSID_HTMLElementCollection_Value;

const CLSID_HTMLHeaderElement_Value = @import("../zig.zig").Guid.initString("3050F27A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLHeaderElement = &CLSID_HTMLHeaderElement_Value;

const CLSID_HTMLSelectElement_Value = @import("../zig.zig").Guid.initString("3050F245-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLSelectElement = &CLSID_HTMLSelectElement_Value;

const CLSID_HTMLWndSelectElement_Value = @import("../zig.zig").Guid.initString("3050F2CF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLWndSelectElement = &CLSID_HTMLWndSelectElement_Value;

const CLSID_HTMLOptionElement_Value = @import("../zig.zig").Guid.initString("3050F24D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLOptionElement = &CLSID_HTMLOptionElement_Value;

const CLSID_HTMLOptionElementFactory_Value = @import("../zig.zig").Guid.initString("3050F38D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLOptionElementFactory = &CLSID_HTMLOptionElementFactory_Value;

const CLSID_HTMLWndOptionElement_Value = @import("../zig.zig").Guid.initString("3050F2D0-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLWndOptionElement = &CLSID_HTMLWndOptionElement_Value;

const CLSID_HTMLInputElement_Value = @import("../zig.zig").Guid.initString("3050F5D8-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLInputElement = &CLSID_HTMLInputElement_Value;

const CLSID_HTMLTextAreaElement_Value = @import("../zig.zig").Guid.initString("3050F2AC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTextAreaElement = &CLSID_HTMLTextAreaElement_Value;

const CLSID_HTMLRichtextElement_Value = @import("../zig.zig").Guid.initString("3050F2DF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLRichtextElement = &CLSID_HTMLRichtextElement_Value;

const CLSID_HTMLButtonElement_Value = @import("../zig.zig").Guid.initString("3050F2C6-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLButtonElement = &CLSID_HTMLButtonElement_Value;

const CLSID_HTMLMarqueeElement_Value = @import("../zig.zig").Guid.initString("3050F2B9-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLMarqueeElement = &CLSID_HTMLMarqueeElement_Value;

const CLSID_HTMLHtmlElement_Value = @import("../zig.zig").Guid.initString("3050F491-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLHtmlElement = &CLSID_HTMLHtmlElement_Value;

const CLSID_HTMLHeadElement_Value = @import("../zig.zig").Guid.initString("3050F493-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLHeadElement = &CLSID_HTMLHeadElement_Value;

const CLSID_HTMLTitleElement_Value = @import("../zig.zig").Guid.initString("3050F284-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTitleElement = &CLSID_HTMLTitleElement_Value;

const CLSID_HTMLMetaElement_Value = @import("../zig.zig").Guid.initString("3050F275-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLMetaElement = &CLSID_HTMLMetaElement_Value;

const CLSID_HTMLBaseElement_Value = @import("../zig.zig").Guid.initString("3050F276-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLBaseElement = &CLSID_HTMLBaseElement_Value;

const CLSID_HTMLIsIndexElement_Value = @import("../zig.zig").Guid.initString("3050F278-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLIsIndexElement = &CLSID_HTMLIsIndexElement_Value;

const CLSID_HTMLNextIdElement_Value = @import("../zig.zig").Guid.initString("3050F279-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLNextIdElement = &CLSID_HTMLNextIdElement_Value;

const CLSID_HTMLBaseFontElement_Value = @import("../zig.zig").Guid.initString("3050F282-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLBaseFontElement = &CLSID_HTMLBaseFontElement_Value;

const CLSID_HTMLUnknownElement_Value = @import("../zig.zig").Guid.initString("3050F268-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLUnknownElement = &CLSID_HTMLUnknownElement_Value;

const CLSID_HTMLHistory_Value = @import("../zig.zig").Guid.initString("FECEAAA3-8405-11CF-8BA1-00AA00476DA6");
pub const CLSID_HTMLHistory = &CLSID_HTMLHistory_Value;

const CLSID_COpsProfile_Value = @import("../zig.zig").Guid.initString("3050F402-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_COpsProfile = &CLSID_COpsProfile_Value;

const CLSID_HTMLNavigator_Value = @import("../zig.zig").Guid.initString("FECEAAA6-8405-11CF-8BA1-00AA00476DA6");
pub const CLSID_HTMLNavigator = &CLSID_HTMLNavigator_Value;

const CLSID_HTMLLocation_Value = @import("../zig.zig").Guid.initString("163BB1E1-6E00-11CF-837A-48DC04C10000");
pub const CLSID_HTMLLocation = &CLSID_HTMLLocation_Value;

const CLSID_CMimeTypes_Value = @import("../zig.zig").Guid.initString("3050F3FE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_CMimeTypes = &CLSID_CMimeTypes_Value;

const CLSID_CPlugins_Value = @import("../zig.zig").Guid.initString("3050F3FF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_CPlugins = &CLSID_CPlugins_Value;

const CLSID_CEventObj_Value = @import("../zig.zig").Guid.initString("3050F48A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_CEventObj = &CLSID_CEventObj_Value;

const CLSID_HTMLStyleMedia_Value = @import("../zig.zig").Guid.initString("3051074C-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyleMedia = &CLSID_HTMLStyleMedia_Value;

const CLSID_FramesCollection_Value = @import("../zig.zig").Guid.initString("3050F7F6-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_FramesCollection = &CLSID_FramesCollection_Value;

const CLSID_HTMLScreen_Value = @import("../zig.zig").Guid.initString("3050F35D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLScreen = &CLSID_HTMLScreen_Value;

const CLSID_HTMLWindow2_Value = @import("../zig.zig").Guid.initString("D48A6EC6-6A4A-11CF-94A7-444553540000");
pub const CLSID_HTMLWindow2 = &CLSID_HTMLWindow2_Value;

const CLSID_HTMLWindowProxy_Value = @import("../zig.zig").Guid.initString("3050F391-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLWindowProxy = &CLSID_HTMLWindowProxy_Value;

const CLSID_HTMLDocumentCompatibleInfo_Value = @import("../zig.zig").Guid.initString("3051041B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDocumentCompatibleInfo = &CLSID_HTMLDocumentCompatibleInfo_Value;

const CLSID_HTMLDocumentCompatibleInfoCollection_Value = @import("../zig.zig").Guid.initString("30510419-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDocumentCompatibleInfoCollection = &CLSID_HTMLDocumentCompatibleInfoCollection_Value;

const CLSID_HTMLDocument_Value = @import("../zig.zig").Guid.initString("25336920-03F9-11CF-8FD0-00AA00686F13");
pub const CLSID_HTMLDocument = &CLSID_HTMLDocument_Value;

const CLSID_Scriptlet_Value = @import("../zig.zig").Guid.initString("AE24FDAE-03C6-11D1-8B76-0080C744F389");
pub const CLSID_Scriptlet = &CLSID_Scriptlet_Value;

const CLSID_HTMLEmbed_Value = @import("../zig.zig").Guid.initString("3050F25D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLEmbed = &CLSID_HTMLEmbed_Value;

const CLSID_HTMLAreasCollection_Value = @import("../zig.zig").Guid.initString("3050F4CA-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLAreasCollection = &CLSID_HTMLAreasCollection_Value;

const CLSID_HTMLMapElement_Value = @import("../zig.zig").Guid.initString("3050F271-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLMapElement = &CLSID_HTMLMapElement_Value;

const CLSID_HTMLAreaElement_Value = @import("../zig.zig").Guid.initString("3050F283-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLAreaElement = &CLSID_HTMLAreaElement_Value;

const CLSID_HTMLTableCaption_Value = @import("../zig.zig").Guid.initString("3050F2EC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTableCaption = &CLSID_HTMLTableCaption_Value;

const CLSID_HTMLCommentElement_Value = @import("../zig.zig").Guid.initString("3050F317-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLCommentElement = &CLSID_HTMLCommentElement_Value;

const CLSID_HTMLPhraseElement_Value = @import("../zig.zig").Guid.initString("3050F26E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLPhraseElement = &CLSID_HTMLPhraseElement_Value;

const CLSID_HTMLSpanElement_Value = @import("../zig.zig").Guid.initString("3050F3F5-98B4-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLSpanElement = &CLSID_HTMLSpanElement_Value;

const CLSID_HTMLTable_Value = @import("../zig.zig").Guid.initString("3050F26B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTable = &CLSID_HTMLTable_Value;

const CLSID_HTMLTableCol_Value = @import("../zig.zig").Guid.initString("3050F26C-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTableCol = &CLSID_HTMLTableCol_Value;

const CLSID_HTMLTableSection_Value = @import("../zig.zig").Guid.initString("3050F2E9-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTableSection = &CLSID_HTMLTableSection_Value;

const CLSID_HTMLTableRow_Value = @import("../zig.zig").Guid.initString("3050F26D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTableRow = &CLSID_HTMLTableRow_Value;

const CLSID_HTMLTableCell_Value = @import("../zig.zig").Guid.initString("3050F246-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTableCell = &CLSID_HTMLTableCell_Value;

const CLSID_HTMLScriptElement_Value = @import("../zig.zig").Guid.initString("3050F28C-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLScriptElement = &CLSID_HTMLScriptElement_Value;

const CLSID_HTMLNoShowElement_Value = @import("../zig.zig").Guid.initString("3050F38B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLNoShowElement = &CLSID_HTMLNoShowElement_Value;

const CLSID_HTMLObjectElement_Value = @import("../zig.zig").Guid.initString("3050F24E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLObjectElement = &CLSID_HTMLObjectElement_Value;

const CLSID_HTMLParamElement_Value = @import("../zig.zig").Guid.initString("3050F83E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLParamElement = &CLSID_HTMLParamElement_Value;

const CLSID_HTMLFrameBase_Value = @import("../zig.zig").Guid.initString("3050F312-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLFrameBase = &CLSID_HTMLFrameBase_Value;

const CLSID_HTMLFrameElement_Value = @import("../zig.zig").Guid.initString("3050F314-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLFrameElement = &CLSID_HTMLFrameElement_Value;

const CLSID_HTMLIFrame_Value = @import("../zig.zig").Guid.initString("3050F316-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLIFrame = &CLSID_HTMLIFrame_Value;

const CLSID_HTMLDivPosition_Value = @import("../zig.zig").Guid.initString("3050F249-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDivPosition = &CLSID_HTMLDivPosition_Value;

const CLSID_HTMLFieldSetElement_Value = @import("../zig.zig").Guid.initString("3050F3E8-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLFieldSetElement = &CLSID_HTMLFieldSetElement_Value;

const CLSID_HTMLLegendElement_Value = @import("../zig.zig").Guid.initString("3050F3E9-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLLegendElement = &CLSID_HTMLLegendElement_Value;

const CLSID_HTMLSpanFlow_Value = @import("../zig.zig").Guid.initString("3050F3E6-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLSpanFlow = &CLSID_HTMLSpanFlow_Value;

const CLSID_HTMLFrameSetSite_Value = @import("../zig.zig").Guid.initString("3050F31A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLFrameSetSite = &CLSID_HTMLFrameSetSite_Value;

const CLSID_HTMLBGsound_Value = @import("../zig.zig").Guid.initString("3050F370-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLBGsound = &CLSID_HTMLBGsound_Value;

const CLSID_HTMLStyleElement_Value = @import("../zig.zig").Guid.initString("3050F37D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyleElement = &CLSID_HTMLStyleElement_Value;

const CLSID_HTMLStyleFontFace_Value = @import("../zig.zig").Guid.initString("3050F3D4-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStyleFontFace = &CLSID_HTMLStyleFontFace_Value;

const CLSID_XDomainRequest_Value = @import("../zig.zig").Guid.initString("30510455-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_XDomainRequest = &CLSID_XDomainRequest_Value;

const CLSID_XDomainRequestFactory_Value = @import("../zig.zig").Guid.initString("30510457-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_XDomainRequestFactory = &CLSID_XDomainRequestFactory_Value;

const CLSID_HTMLStorage_Value = @import("../zig.zig").Guid.initString("30510475-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLStorage = &CLSID_HTMLStorage_Value;

const CLSID_DOMEvent_Value = @import("../zig.zig").Guid.initString("305104BB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMEvent = &CLSID_DOMEvent_Value;

const CLSID_DOMUIEvent_Value = @import("../zig.zig").Guid.initString("305106CB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMUIEvent = &CLSID_DOMUIEvent_Value;

const CLSID_DOMMouseEvent_Value = @import("../zig.zig").Guid.initString("305106CF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMMouseEvent = &CLSID_DOMMouseEvent_Value;

const CLSID_DOMDragEvent_Value = @import("../zig.zig").Guid.initString("30510762-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMDragEvent = &CLSID_DOMDragEvent_Value;

const CLSID_DOMMouseWheelEvent_Value = @import("../zig.zig").Guid.initString("305106D1-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMMouseWheelEvent = &CLSID_DOMMouseWheelEvent_Value;

const CLSID_DOMWheelEvent_Value = @import("../zig.zig").Guid.initString("305106D3-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMWheelEvent = &CLSID_DOMWheelEvent_Value;

const CLSID_DOMTextEvent_Value = @import("../zig.zig").Guid.initString("305106D5-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMTextEvent = &CLSID_DOMTextEvent_Value;

const CLSID_DOMKeyboardEvent_Value = @import("../zig.zig").Guid.initString("305106D7-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMKeyboardEvent = &CLSID_DOMKeyboardEvent_Value;

const CLSID_DOMCompositionEvent_Value = @import("../zig.zig").Guid.initString("305106D9-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMCompositionEvent = &CLSID_DOMCompositionEvent_Value;

const CLSID_DOMMutationEvent_Value = @import("../zig.zig").Guid.initString("305106DB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMMutationEvent = &CLSID_DOMMutationEvent_Value;

const CLSID_DOMBeforeUnloadEvent_Value = @import("../zig.zig").Guid.initString("30510764-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMBeforeUnloadEvent = &CLSID_DOMBeforeUnloadEvent_Value;

const CLSID_DOMFocusEvent_Value = @import("../zig.zig").Guid.initString("305106CD-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMFocusEvent = &CLSID_DOMFocusEvent_Value;

const CLSID_DOMCustomEvent_Value = @import("../zig.zig").Guid.initString("305106DF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMCustomEvent = &CLSID_DOMCustomEvent_Value;

const CLSID_CanvasGradient_Value = @import("../zig.zig").Guid.initString("30510715-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_CanvasGradient = &CLSID_CanvasGradient_Value;

const CLSID_CanvasPattern_Value = @import("../zig.zig").Guid.initString("30510717-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_CanvasPattern = &CLSID_CanvasPattern_Value;

const CLSID_CanvasTextMetrics_Value = @import("../zig.zig").Guid.initString("30510719-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_CanvasTextMetrics = &CLSID_CanvasTextMetrics_Value;

const CLSID_CanvasImageData_Value = @import("../zig.zig").Guid.initString("3051071B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_CanvasImageData = &CLSID_CanvasImageData_Value;

const CLSID_CanvasRenderingContext2D_Value = @import("../zig.zig").Guid.initString("30510700-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_CanvasRenderingContext2D = &CLSID_CanvasRenderingContext2D_Value;

const CLSID_HTMLCanvasElement_Value = @import("../zig.zig").Guid.initString("305106E5-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLCanvasElement = &CLSID_HTMLCanvasElement_Value;

const CLSID_DOMProgressEvent_Value = @import("../zig.zig").Guid.initString("3051071F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMProgressEvent = &CLSID_DOMProgressEvent_Value;

const CLSID_DOMMessageEvent_Value = @import("../zig.zig").Guid.initString("30510721-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMMessageEvent = &CLSID_DOMMessageEvent_Value;

const CLSID_DOMSiteModeEvent_Value = @import("../zig.zig").Guid.initString("30510766-98B6-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMSiteModeEvent = &CLSID_DOMSiteModeEvent_Value;

const CLSID_DOMStorageEvent_Value = @import("../zig.zig").Guid.initString("30510723-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMStorageEvent = &CLSID_DOMStorageEvent_Value;

const CLSID_XMLHttpRequestEventTarget_Value = @import("../zig.zig").Guid.initString("30510831-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_XMLHttpRequestEventTarget = &CLSID_XMLHttpRequestEventTarget_Value;

const CLSID_HTMLXMLHttpRequest_Value = @import("../zig.zig").Guid.initString("3051040B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLXMLHttpRequest = &CLSID_HTMLXMLHttpRequest_Value;

const CLSID_HTMLXMLHttpRequestFactory_Value = @import("../zig.zig").Guid.initString("3051040D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLXMLHttpRequestFactory = &CLSID_HTMLXMLHttpRequestFactory_Value;

const CLSID_SVGAngle_Value = @import("../zig.zig").Guid.initString("30510584-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAngle = &CLSID_SVGAngle_Value;

const CLSID_SVGAnimatedAngle_Value = @import("../zig.zig").Guid.initString("305105E4-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedAngle = &CLSID_SVGAnimatedAngle_Value;

const CLSID_SVGAnimatedTransformList_Value = @import("../zig.zig").Guid.initString("305105B1-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedTransformList = &CLSID_SVGAnimatedTransformList_Value;

const CLSID_SVGAnimatedBoolean_Value = @import("../zig.zig").Guid.initString("3051058B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedBoolean = &CLSID_SVGAnimatedBoolean_Value;

const CLSID_SVGAnimatedEnumeration_Value = @import("../zig.zig").Guid.initString("3051058E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedEnumeration = &CLSID_SVGAnimatedEnumeration_Value;

const CLSID_SVGAnimatedInteger_Value = @import("../zig.zig").Guid.initString("3051058F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedInteger = &CLSID_SVGAnimatedInteger_Value;

const CLSID_SVGAnimatedLength_Value = @import("../zig.zig").Guid.initString("30510581-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedLength = &CLSID_SVGAnimatedLength_Value;

const CLSID_SVGAnimatedLengthList_Value = @import("../zig.zig").Guid.initString("30510582-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedLengthList = &CLSID_SVGAnimatedLengthList_Value;

const CLSID_SVGAnimatedNumber_Value = @import("../zig.zig").Guid.initString("30510588-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedNumber = &CLSID_SVGAnimatedNumber_Value;

const CLSID_SVGAnimatedNumberList_Value = @import("../zig.zig").Guid.initString("3051058A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedNumberList = &CLSID_SVGAnimatedNumberList_Value;

const CLSID_SVGAnimatedRect_Value = @import("../zig.zig").Guid.initString("30510586-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedRect = &CLSID_SVGAnimatedRect_Value;

const CLSID_SVGAnimatedString_Value = @import("../zig.zig").Guid.initString("3051058C-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedString = &CLSID_SVGAnimatedString_Value;

const CLSID_SVGClipPathElement_Value = @import("../zig.zig").Guid.initString("305105E6-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGClipPathElement = &CLSID_SVGClipPathElement_Value;

const CLSID_SVGElement_Value = @import("../zig.zig").Guid.initString("30510564-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGElement = &CLSID_SVGElement_Value;

const CLSID_SVGLength_Value = @import("../zig.zig").Guid.initString("3051057E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGLength = &CLSID_SVGLength_Value;

const CLSID_SVGLengthList_Value = @import("../zig.zig").Guid.initString("30510580-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGLengthList = &CLSID_SVGLengthList_Value;

const CLSID_SVGMatrix_Value = @import("../zig.zig").Guid.initString("305105AE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGMatrix = &CLSID_SVGMatrix_Value;

const CLSID_SVGNumber_Value = @import("../zig.zig").Guid.initString("30510587-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGNumber = &CLSID_SVGNumber_Value;

const CLSID_SVGNumberList_Value = @import("../zig.zig").Guid.initString("30510589-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGNumberList = &CLSID_SVGNumberList_Value;

const CLSID_SVGPatternElement_Value = @import("../zig.zig").Guid.initString("305105D4-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPatternElement = &CLSID_SVGPatternElement_Value;

const CLSID_SVGPathSeg_Value = @import("../zig.zig").Guid.initString("305105B3-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSeg = &CLSID_SVGPathSeg_Value;

const CLSID_SVGPathSegArcAbs_Value = @import("../zig.zig").Guid.initString("305105BB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegArcAbs = &CLSID_SVGPathSegArcAbs_Value;

const CLSID_SVGPathSegArcRel_Value = @import("../zig.zig").Guid.initString("305105BC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegArcRel = &CLSID_SVGPathSegArcRel_Value;

const CLSID_SVGPathSegClosePath_Value = @import("../zig.zig").Guid.initString("305105BD-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegClosePath = &CLSID_SVGPathSegClosePath_Value;

const CLSID_SVGPathSegMovetoAbs_Value = @import("../zig.zig").Guid.initString("305105CC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegMovetoAbs = &CLSID_SVGPathSegMovetoAbs_Value;

const CLSID_SVGPathSegMovetoRel_Value = @import("../zig.zig").Guid.initString("305105CD-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegMovetoRel = &CLSID_SVGPathSegMovetoRel_Value;

const CLSID_SVGPathSegLinetoAbs_Value = @import("../zig.zig").Guid.initString("305105C6-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegLinetoAbs = &CLSID_SVGPathSegLinetoAbs_Value;

const CLSID_SVGPathSegLinetoRel_Value = @import("../zig.zig").Guid.initString("305105C9-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegLinetoRel = &CLSID_SVGPathSegLinetoRel_Value;

const CLSID_SVGPathSegCurvetoCubicAbs_Value = @import("../zig.zig").Guid.initString("305105BE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegCurvetoCubicAbs = &CLSID_SVGPathSegCurvetoCubicAbs_Value;

const CLSID_SVGPathSegCurvetoCubicRel_Value = @import("../zig.zig").Guid.initString("305105BF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegCurvetoCubicRel = &CLSID_SVGPathSegCurvetoCubicRel_Value;

const CLSID_SVGPathSegCurvetoCubicSmoothAbs_Value = @import("../zig.zig").Guid.initString("305105C0-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegCurvetoCubicSmoothAbs = &CLSID_SVGPathSegCurvetoCubicSmoothAbs_Value;

const CLSID_SVGPathSegCurvetoCubicSmoothRel_Value = @import("../zig.zig").Guid.initString("305105C1-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegCurvetoCubicSmoothRel = &CLSID_SVGPathSegCurvetoCubicSmoothRel_Value;

const CLSID_SVGPathSegCurvetoQuadraticAbs_Value = @import("../zig.zig").Guid.initString("305105C2-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegCurvetoQuadraticAbs = &CLSID_SVGPathSegCurvetoQuadraticAbs_Value;

const CLSID_SVGPathSegCurvetoQuadraticRel_Value = @import("../zig.zig").Guid.initString("305105C3-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegCurvetoQuadraticRel = &CLSID_SVGPathSegCurvetoQuadraticRel_Value;

const CLSID_SVGPathSegCurvetoQuadraticSmoothAbs_Value = @import("../zig.zig").Guid.initString("305105C4-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegCurvetoQuadraticSmoothAbs = &CLSID_SVGPathSegCurvetoQuadraticSmoothAbs_Value;

const CLSID_SVGPathSegCurvetoQuadraticSmoothRel_Value = @import("../zig.zig").Guid.initString("305105C5-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegCurvetoQuadraticSmoothRel = &CLSID_SVGPathSegCurvetoQuadraticSmoothRel_Value;

const CLSID_SVGPathSegLinetoHorizontalAbs_Value = @import("../zig.zig").Guid.initString("305105C7-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegLinetoHorizontalAbs = &CLSID_SVGPathSegLinetoHorizontalAbs_Value;

const CLSID_SVGPathSegLinetoHorizontalRel_Value = @import("../zig.zig").Guid.initString("305105C8-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegLinetoHorizontalRel = &CLSID_SVGPathSegLinetoHorizontalRel_Value;

const CLSID_SVGPathSegLinetoVerticalAbs_Value = @import("../zig.zig").Guid.initString("305105CA-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegLinetoVerticalAbs = &CLSID_SVGPathSegLinetoVerticalAbs_Value;

const CLSID_SVGPathSegLinetoVerticalRel_Value = @import("../zig.zig").Guid.initString("305105CB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegLinetoVerticalRel = &CLSID_SVGPathSegLinetoVerticalRel_Value;

const CLSID_SVGPathSegList_Value = @import("../zig.zig").Guid.initString("305105B4-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathSegList = &CLSID_SVGPathSegList_Value;

const CLSID_SVGPoint_Value = @import("../zig.zig").Guid.initString("305105BA-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPoint = &CLSID_SVGPoint_Value;

const CLSID_SVGPointList_Value = @import("../zig.zig").Guid.initString("305105B9-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPointList = &CLSID_SVGPointList_Value;

const CLSID_SVGRect_Value = @import("../zig.zig").Guid.initString("30510583-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGRect = &CLSID_SVGRect_Value;

const CLSID_SVGStringList_Value = @import("../zig.zig").Guid.initString("3051058D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGStringList = &CLSID_SVGStringList_Value;

const CLSID_SVGTransform_Value = @import("../zig.zig").Guid.initString("305105AF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGTransform = &CLSID_SVGTransform_Value;

const CLSID_SVGSVGElement_Value = @import("../zig.zig").Guid.initString("30510574-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGSVGElement = &CLSID_SVGSVGElement_Value;

const CLSID_SVGUseElement_Value = @import("../zig.zig").Guid.initString("30510590-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGUseElement = &CLSID_SVGUseElement_Value;

const CLSID_HTMLStyleSheetRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("EB36F845-2395-4719-B85C-D0D80E184BD9");
pub const CLSID_HTMLStyleSheetRulesAppliedCollection = &CLSID_HTMLStyleSheetRulesAppliedCollection_Value;

const CLSID_RulesApplied_Value = @import("../zig.zig").Guid.initString("7C803920-7A53-4D26-98AC-FDD23E6B9E01");
pub const CLSID_RulesApplied = &CLSID_RulesApplied_Value;

const CLSID_RulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("671926EE-C3CF-40AF-BE8F-1CBAEE6486E8");
pub const CLSID_RulesAppliedCollection = &CLSID_RulesAppliedCollection_Value;

const CLSID_HTMLW3CComputedStyle_Value = @import("../zig.zig").Guid.initString("305106C8-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLW3CComputedStyle = &CLSID_HTMLW3CComputedStyle_Value;

const CLSID_SVGTransformList_Value = @import("../zig.zig").Guid.initString("305105B0-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGTransformList = &CLSID_SVGTransformList_Value;

const CLSID_SVGCircleElement_Value = @import("../zig.zig").Guid.initString("30510578-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGCircleElement = &CLSID_SVGCircleElement_Value;

const CLSID_SVGEllipseElement_Value = @import("../zig.zig").Guid.initString("30510579-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGEllipseElement = &CLSID_SVGEllipseElement_Value;

const CLSID_SVGLineElement_Value = @import("../zig.zig").Guid.initString("3051057A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGLineElement = &CLSID_SVGLineElement_Value;

const CLSID_SVGRectElement_Value = @import("../zig.zig").Guid.initString("30510577-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGRectElement = &CLSID_SVGRectElement_Value;

const CLSID_SVGPolygonElement_Value = @import("../zig.zig").Guid.initString("3051057B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPolygonElement = &CLSID_SVGPolygonElement_Value;

const CLSID_SVGPolylineElement_Value = @import("../zig.zig").Guid.initString("3051057C-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPolylineElement = &CLSID_SVGPolylineElement_Value;

const CLSID_SVGGElement_Value = @import("../zig.zig").Guid.initString("3051056F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGGElement = &CLSID_SVGGElement_Value;

const CLSID_SVGSymbolElement_Value = @import("../zig.zig").Guid.initString("30510571-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGSymbolElement = &CLSID_SVGSymbolElement_Value;

const CLSID_SVGDefsElement_Value = @import("../zig.zig").Guid.initString("30510570-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGDefsElement = &CLSID_SVGDefsElement_Value;

const CLSID_SVGPathElement_Value = @import("../zig.zig").Guid.initString("305105B2-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPathElement = &CLSID_SVGPathElement_Value;

const CLSID_SVGPreserveAspectRatio_Value = @import("../zig.zig").Guid.initString("305105D0-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGPreserveAspectRatio = &CLSID_SVGPreserveAspectRatio_Value;

const CLSID_SVGTextElement_Value = @import("../zig.zig").Guid.initString("305105DF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGTextElement = &CLSID_SVGTextElement_Value;

const CLSID_SVGAnimatedPreserveAspectRatio_Value = @import("../zig.zig").Guid.initString("305105CE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAnimatedPreserveAspectRatio = &CLSID_SVGAnimatedPreserveAspectRatio_Value;

const CLSID_SVGImageElement_Value = @import("../zig.zig").Guid.initString("305105CF-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGImageElement = &CLSID_SVGImageElement_Value;

const CLSID_SVGStopElement_Value = @import("../zig.zig").Guid.initString("305105D5-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGStopElement = &CLSID_SVGStopElement_Value;

const CLSID_SVGGradientElement_Value = @import("../zig.zig").Guid.initString("305105D6-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGGradientElement = &CLSID_SVGGradientElement_Value;

const CLSID_SVGLinearGradientElement_Value = @import("../zig.zig").Guid.initString("305105D2-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGLinearGradientElement = &CLSID_SVGLinearGradientElement_Value;

const CLSID_SVGRadialGradientElement_Value = @import("../zig.zig").Guid.initString("305105D3-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGRadialGradientElement = &CLSID_SVGRadialGradientElement_Value;

const CLSID_SVGMaskElement_Value = @import("../zig.zig").Guid.initString("305105E7-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGMaskElement = &CLSID_SVGMaskElement_Value;

const CLSID_SVGMarkerElement_Value = @import("../zig.zig").Guid.initString("305105DE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGMarkerElement = &CLSID_SVGMarkerElement_Value;

const CLSID_SVGZoomEvent_Value = @import("../zig.zig").Guid.initString("305105D9-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGZoomEvent = &CLSID_SVGZoomEvent_Value;

const CLSID_SVGAElement_Value = @import("../zig.zig").Guid.initString("305105DB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGAElement = &CLSID_SVGAElement_Value;

const CLSID_SVGViewElement_Value = @import("../zig.zig").Guid.initString("305105DC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGViewElement = &CLSID_SVGViewElement_Value;

const CLSID_HTMLMediaError_Value = @import("../zig.zig").Guid.initString("3051070A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLMediaError = &CLSID_HTMLMediaError_Value;

const CLSID_HTMLTimeRanges_Value = @import("../zig.zig").Guid.initString("3051070B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLTimeRanges = &CLSID_HTMLTimeRanges_Value;

const CLSID_HTMLMediaElement_Value = @import("../zig.zig").Guid.initString("3051070C-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLMediaElement = &CLSID_HTMLMediaElement_Value;

const CLSID_HTMLSourceElement_Value = @import("../zig.zig").Guid.initString("3051070D-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLSourceElement = &CLSID_HTMLSourceElement_Value;

const CLSID_HTMLAudioElement_Value = @import("../zig.zig").Guid.initString("3051070E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLAudioElement = &CLSID_HTMLAudioElement_Value;

const CLSID_HTMLAudioElementFactory_Value = @import("../zig.zig").Guid.initString("305107EC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLAudioElementFactory = &CLSID_HTMLAudioElementFactory_Value;

const CLSID_HTMLVideoElement_Value = @import("../zig.zig").Guid.initString("3051070F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLVideoElement = &CLSID_HTMLVideoElement_Value;

const CLSID_SVGSwitchElement_Value = @import("../zig.zig").Guid.initString("305105D8-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGSwitchElement = &CLSID_SVGSwitchElement_Value;

const CLSID_SVGDescElement_Value = @import("../zig.zig").Guid.initString("30510572-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGDescElement = &CLSID_SVGDescElement_Value;

const CLSID_SVGTitleElement_Value = @import("../zig.zig").Guid.initString("30510573-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGTitleElement = &CLSID_SVGTitleElement_Value;

const CLSID_SVGMetadataElement_Value = @import("../zig.zig").Guid.initString("305105D7-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGMetadataElement = &CLSID_SVGMetadataElement_Value;

const CLSID_SVGElementInstance_Value = @import("../zig.zig").Guid.initString("30510575-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGElementInstance = &CLSID_SVGElementInstance_Value;

const CLSID_SVGElementInstanceList_Value = @import("../zig.zig").Guid.initString("30510576-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGElementInstanceList = &CLSID_SVGElementInstanceList_Value;

const CLSID_DOMException_Value = @import("../zig.zig").Guid.initString("3051072C-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMException = &CLSID_DOMException_Value;

const CLSID_RangeException_Value = @import("../zig.zig").Guid.initString("3051072E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_RangeException = &CLSID_RangeException_Value;

const CLSID_SVGException_Value = @import("../zig.zig").Guid.initString("30510730-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGException = &CLSID_SVGException_Value;

const CLSID_EventException_Value = @import("../zig.zig").Guid.initString("3051073B-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_EventException = &CLSID_EventException_Value;

const CLSID_SVGScriptElement_Value = @import("../zig.zig").Guid.initString("305105E1-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGScriptElement = &CLSID_SVGScriptElement_Value;

const CLSID_SVGStyleElement_Value = @import("../zig.zig").Guid.initString("305105D1-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGStyleElement = &CLSID_SVGStyleElement_Value;

const CLSID_SVGTextContentElement_Value = @import("../zig.zig").Guid.initString("305105DD-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGTextContentElement = &CLSID_SVGTextContentElement_Value;

const CLSID_SVGTextPositioningElement_Value = @import("../zig.zig").Guid.initString("305105E0-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGTextPositioningElement = &CLSID_SVGTextPositioningElement_Value;

const CLSID_DOMDocumentType_Value = @import("../zig.zig").Guid.initString("30510739-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMDocumentType = &CLSID_DOMDocumentType_Value;

const CLSID_NodeIterator_Value = @import("../zig.zig").Guid.initString("30510745-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_NodeIterator = &CLSID_NodeIterator_Value;

const CLSID_TreeWalker_Value = @import("../zig.zig").Guid.initString("30510747-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_TreeWalker = &CLSID_TreeWalker_Value;

const CLSID_DOMProcessingInstruction_Value = @import("../zig.zig").Guid.initString("30510743-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMProcessingInstruction = &CLSID_DOMProcessingInstruction_Value;

const CLSID_HTMLPerformance_Value = @import("../zig.zig").Guid.initString("3051074F-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLPerformance = &CLSID_HTMLPerformance_Value;

const CLSID_HTMLPerformanceNavigation_Value = @import("../zig.zig").Guid.initString("30510751-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLPerformanceNavigation = &CLSID_HTMLPerformanceNavigation_Value;

const CLSID_HTMLPerformanceTiming_Value = @import("../zig.zig").Guid.initString("30510753-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLPerformanceTiming = &CLSID_HTMLPerformanceTiming_Value;

const CLSID_SVGTSpanElement_Value = @import("../zig.zig").Guid.initString("305105E2-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGTSpanElement = &CLSID_SVGTSpanElement_Value;

const CLSID_CTemplatePrinter_Value = @import("../zig.zig").Guid.initString("3050F6B3-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_CTemplatePrinter = &CLSID_CTemplatePrinter_Value;

const CLSID_CPrintManagerTemplatePrinter_Value = @import("../zig.zig").Guid.initString("63619F54-9D71-4C23-A08D-50D7F18DB2E9");
pub const CLSID_CPrintManagerTemplatePrinter = &CLSID_CPrintManagerTemplatePrinter_Value;

const CLSID_SVGTextPathElement_Value = @import("../zig.zig").Guid.initString("305105EB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_SVGTextPathElement = &CLSID_SVGTextPathElement_Value;

const CLSID_XMLSerializer_Value = @import("../zig.zig").Guid.initString("3051077E-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_XMLSerializer = &CLSID_XMLSerializer_Value;

const CLSID_DOMParser_Value = @import("../zig.zig").Guid.initString("30510782-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMParser = &CLSID_DOMParser_Value;

const CLSID_HTMLDOMXmlSerializerFactory_Value = @import("../zig.zig").Guid.initString("30510780-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDOMXmlSerializerFactory = &CLSID_HTMLDOMXmlSerializerFactory_Value;

const CLSID_DOMParserFactory_Value = @import("../zig.zig").Guid.initString("30510784-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMParserFactory = &CLSID_DOMParserFactory_Value;

const CLSID_HTMLSemanticElement_Value = @import("../zig.zig").Guid.initString("305107B0-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLSemanticElement = &CLSID_HTMLSemanticElement_Value;

const CLSID_HTMLProgressElement_Value = @import("../zig.zig").Guid.initString("3050F2D5-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLProgressElement = &CLSID_HTMLProgressElement_Value;

const CLSID_DOMMSTransitionEvent_Value = @import("../zig.zig").Guid.initString("305107B6-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMMSTransitionEvent = &CLSID_DOMMSTransitionEvent_Value;

const CLSID_DOMMSAnimationEvent_Value = @import("../zig.zig").Guid.initString("305107B8-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMMSAnimationEvent = &CLSID_DOMMSAnimationEvent_Value;

const CLSID_WebGeolocation_Value = @import("../zig.zig").Guid.initString("305107C6-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_WebGeolocation = &CLSID_WebGeolocation_Value;

const CLSID_WebGeocoordinates_Value = @import("../zig.zig").Guid.initString("305107C8-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_WebGeocoordinates = &CLSID_WebGeocoordinates_Value;

const CLSID_WebGeopositionError_Value = @import("../zig.zig").Guid.initString("305107CA-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_WebGeopositionError = &CLSID_WebGeopositionError_Value;

const CLSID_WebGeoposition_Value = @import("../zig.zig").Guid.initString("305107CE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_WebGeoposition = &CLSID_WebGeoposition_Value;

const CLSID_CClientCaps_Value = @import("../zig.zig").Guid.initString("7E8BC44E-AEFF-11D1-89C2-00C04FB6BFC4");
pub const CLSID_CClientCaps = &CLSID_CClientCaps_Value;

const CLSID_DOMMSManipulationEvent_Value = @import("../zig.zig").Guid.initString("30510817-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMMSManipulationEvent = &CLSID_DOMMSManipulationEvent_Value;

const CLSID_DOMCloseEvent_Value = @import("../zig.zig").Guid.initString("30510800-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_DOMCloseEvent = &CLSID_DOMCloseEvent_Value;

const CLSID_ApplicationCache_Value = @import("../zig.zig").Guid.initString("30510829-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_ApplicationCache = &CLSID_ApplicationCache_Value;

const CLSID_HtmlDlgSafeHelper_Value = @import("../zig.zig").Guid.initString("3050F819-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HtmlDlgSafeHelper = &CLSID_HtmlDlgSafeHelper_Value;

const CLSID_BlockFormats_Value = @import("../zig.zig").Guid.initString("3050F831-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_BlockFormats = &CLSID_BlockFormats_Value;

const CLSID_FontNames_Value = @import("../zig.zig").Guid.initString("3050F83A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_FontNames = &CLSID_FontNames_Value;

const CLSID_HTMLNamespace_Value = @import("../zig.zig").Guid.initString("3050F6BC-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLNamespace = &CLSID_HTMLNamespace_Value;

const CLSID_HTMLNamespaceCollection_Value = @import("../zig.zig").Guid.initString("3050F6B9-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLNamespaceCollection = &CLSID_HTMLNamespaceCollection_Value;

const CLSID_ThreadDialogProcParam_Value = @import("../zig.zig").Guid.initString("3050F5EB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_ThreadDialogProcParam = &CLSID_ThreadDialogProcParam_Value;

const CLSID_HTMLDialog_Value = @import("../zig.zig").Guid.initString("3050F28A-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLDialog = &CLSID_HTMLDialog_Value;

const CLSID_HTMLPopup_Value = @import("../zig.zig").Guid.initString("3050F667-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLPopup = &CLSID_HTMLPopup_Value;

const CLSID_HTMLAppBehavior_Value = @import("../zig.zig").Guid.initString("3050F5CB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLAppBehavior = &CLSID_HTMLAppBehavior_Value;

const CLSID_OldHTMLDocument_Value = @import("../zig.zig").Guid.initString("D48A6EC9-6A4A-11CF-94A7-444553540000");
pub const CLSID_OldHTMLDocument = &CLSID_OldHTMLDocument_Value;

const CLSID_OldHTMLFormElement_Value = @import("../zig.zig").Guid.initString("0D04D285-6BEC-11CF-8B97-00AA00476DA6");
pub const CLSID_OldHTMLFormElement = &CLSID_OldHTMLFormElement_Value;

const CLSID_HTMLInputButtonElement_Value = @import("../zig.zig").Guid.initString("3050F2B4-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLInputButtonElement = &CLSID_HTMLInputButtonElement_Value;

const CLSID_HTMLInputTextElement_Value = @import("../zig.zig").Guid.initString("3050F2AB-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLInputTextElement = &CLSID_HTMLInputTextElement_Value;

const CLSID_HTMLInputFileElement_Value = @import("../zig.zig").Guid.initString("3050F2AE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLInputFileElement = &CLSID_HTMLInputFileElement_Value;

const CLSID_HTMLOptionButtonElement_Value = @import("../zig.zig").Guid.initString("3050F2BE-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLOptionButtonElement = &CLSID_HTMLOptionButtonElement_Value;

const CLSID_HTMLInputImage_Value = @import("../zig.zig").Guid.initString("3050F2C4-98B5-11CF-BB82-00AA00BDCE0B");
pub const CLSID_HTMLInputImage = &CLSID_HTMLInputImage_Value;

const IID_IHTMLFiltersCollection_Value = @import("../zig.zig").Guid.initString("3050F3EE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFiltersCollection = &IID_IHTMLFiltersCollection_Value;
pub const IHTMLFiltersCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLFiltersCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLFiltersCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLFiltersCollection,
            pvarIndex: *VARIANT,
            pvarResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFiltersCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFiltersCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFiltersCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFiltersCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFiltersCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLFiltersCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFiltersCollection_item(self: *const T, pvarIndex: *VARIANT, pvarResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFiltersCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLFiltersCollection, self), pvarIndex, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIE70DispatchEx_Value = @import("../zig.zig").Guid.initString("3051046B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IIE70DispatchEx = &IID_IIE70DispatchEx_Value;
pub const IIE70DispatchEx = extern struct {
    pub const VTable = extern struct {
        base: IDispatchEx.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatchEx.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIE80DispatchEx_Value = @import("../zig.zig").Guid.initString("3051046C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IIE80DispatchEx = &IID_IIE80DispatchEx_Value;
pub const IIE80DispatchEx = extern struct {
    pub const VTable = extern struct {
        base: IDispatchEx.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatchEx.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const htmlDesignMode = extern enum(i32) {
    htmlDesignModeInherit = -2,
    htmlDesignModeOn = -1,
    htmlDesignModeOff = 0,
    Max = 2147483647,
};
pub const htmlDesignModeInherit = htmlDesignMode.htmlDesignModeInherit;
pub const htmlDesignModeOn = htmlDesignMode.htmlDesignModeOn;
pub const htmlDesignModeOff = htmlDesignMode.htmlDesignModeOff;
pub const htmlDesignMode_Max = htmlDesignMode.Max;

pub const htmlZOrder = extern enum(i32) {
    htmlZOrderFront = 0,
    htmlZOrderBack = 1,
    Max = 2147483647,
};
pub const htmlZOrderFront = htmlZOrder.htmlZOrderFront;
pub const htmlZOrderBack = htmlZOrder.htmlZOrderBack;
pub const htmlZOrder_Max = htmlZOrder.Max;

pub const htmlClear = extern enum(i32) {
    htmlClearNotSet = 0,
    htmlClearAll = 1,
    htmlClearLeft = 2,
    htmlClearRight = 3,
    htmlClearBoth = 4,
    htmlClearNone = 5,
    Max = 2147483647,
};
pub const htmlClearNotSet = htmlClear.htmlClearNotSet;
pub const htmlClearAll = htmlClear.htmlClearAll;
pub const htmlClearLeft = htmlClear.htmlClearLeft;
pub const htmlClearRight = htmlClear.htmlClearRight;
pub const htmlClearBoth = htmlClear.htmlClearBoth;
pub const htmlClearNone = htmlClear.htmlClearNone;
pub const htmlClear_Max = htmlClear.Max;

pub const htmlControlAlign = extern enum(i32) {
    htmlControlAlignNotSet = 0,
    htmlControlAlignLeft = 1,
    htmlControlAlignCenter = 2,
    htmlControlAlignRight = 3,
    htmlControlAlignTextTop = 4,
    htmlControlAlignAbsMiddle = 5,
    htmlControlAlignBaseline = 6,
    htmlControlAlignAbsBottom = 7,
    htmlControlAlignBottom = 8,
    htmlControlAlignMiddle = 9,
    htmlControlAlignTop = 10,
    Max = 2147483647,
};
pub const htmlControlAlignNotSet = htmlControlAlign.htmlControlAlignNotSet;
pub const htmlControlAlignLeft = htmlControlAlign.htmlControlAlignLeft;
pub const htmlControlAlignCenter = htmlControlAlign.htmlControlAlignCenter;
pub const htmlControlAlignRight = htmlControlAlign.htmlControlAlignRight;
pub const htmlControlAlignTextTop = htmlControlAlign.htmlControlAlignTextTop;
pub const htmlControlAlignAbsMiddle = htmlControlAlign.htmlControlAlignAbsMiddle;
pub const htmlControlAlignBaseline = htmlControlAlign.htmlControlAlignBaseline;
pub const htmlControlAlignAbsBottom = htmlControlAlign.htmlControlAlignAbsBottom;
pub const htmlControlAlignBottom = htmlControlAlign.htmlControlAlignBottom;
pub const htmlControlAlignMiddle = htmlControlAlign.htmlControlAlignMiddle;
pub const htmlControlAlignTop = htmlControlAlign.htmlControlAlignTop;
pub const htmlControlAlign_Max = htmlControlAlign.Max;

pub const htmlBlockAlign = extern enum(i32) {
    htmlBlockAlignNotSet = 0,
    htmlBlockAlignLeft = 1,
    htmlBlockAlignCenter = 2,
    htmlBlockAlignRight = 3,
    htmlBlockAlignJustify = 4,
    Max = 2147483647,
};
pub const htmlBlockAlignNotSet = htmlBlockAlign.htmlBlockAlignNotSet;
pub const htmlBlockAlignLeft = htmlBlockAlign.htmlBlockAlignLeft;
pub const htmlBlockAlignCenter = htmlBlockAlign.htmlBlockAlignCenter;
pub const htmlBlockAlignRight = htmlBlockAlign.htmlBlockAlignRight;
pub const htmlBlockAlignJustify = htmlBlockAlign.htmlBlockAlignJustify;
pub const htmlBlockAlign_Max = htmlBlockAlign.Max;

pub const htmlReadyState = extern enum(i32) {
    htmlReadyStateuninitialized = 0,
    htmlReadyStateloading = 1,
    htmlReadyStateloaded = 2,
    htmlReadyStateinteractive = 3,
    htmlReadyStatecomplete = 4,
    Max = 2147483647,
};
pub const htmlReadyStateuninitialized = htmlReadyState.htmlReadyStateuninitialized;
pub const htmlReadyStateloading = htmlReadyState.htmlReadyStateloading;
pub const htmlReadyStateloaded = htmlReadyState.htmlReadyStateloaded;
pub const htmlReadyStateinteractive = htmlReadyState.htmlReadyStateinteractive;
pub const htmlReadyStatecomplete = htmlReadyState.htmlReadyStatecomplete;
pub const htmlReadyState_Max = htmlReadyState.Max;

pub const htmlLoop = extern enum(i32) {
    htmlLoopLoopInfinite = -1,
    Max = 2147483647,
};
pub const htmlLoopLoopInfinite = htmlLoop.htmlLoopLoopInfinite;
pub const htmlLoop_Max = htmlLoop.Max;

pub const mediaType = extern enum(i32) {
    mediaTypeNotSet = 0,
    mediaTypeAll = 511,
    mediaTypeAural = 1,
    mediaTypeBraille = 2,
    mediaTypeEmbossed = 4,
    mediaTypeHandheld = 8,
    mediaTypePrint = 16,
    mediaTypeProjection = 32,
    mediaTypeScreen = 64,
    mediaTypeTty = 128,
    mediaTypeTv = 256,
    Max = 2147483647,
};
pub const mediaTypeNotSet = mediaType.mediaTypeNotSet;
pub const mediaTypeAll = mediaType.mediaTypeAll;
pub const mediaTypeAural = mediaType.mediaTypeAural;
pub const mediaTypeBraille = mediaType.mediaTypeBraille;
pub const mediaTypeEmbossed = mediaType.mediaTypeEmbossed;
pub const mediaTypeHandheld = mediaType.mediaTypeHandheld;
pub const mediaTypePrint = mediaType.mediaTypePrint;
pub const mediaTypeProjection = mediaType.mediaTypeProjection;
pub const mediaTypeScreen = mediaType.mediaTypeScreen;
pub const mediaTypeTty = mediaType.mediaTypeTty;
pub const mediaTypeTv = mediaType.mediaTypeTv;
pub const mediaType_Max = mediaType.Max;

pub const DomConstructor = extern enum(i32) {
    DomConstructorObject = 0,
    DomConstructorAttr = 1,
    DomConstructorBehaviorUrnsCollection = 2,
    DomConstructorBookmarkCollection = 3,
    DomConstructorCompatibleInfo = 4,
    DomConstructorCompatibleInfoCollection = 5,
    DomConstructorControlRangeCollection = 6,
    DomConstructorCSSCurrentStyleDeclaration = 7,
    DomConstructorCSSRuleList = 8,
    DomConstructorCSSRuleStyleDeclaration = 9,
    DomConstructorCSSStyleDeclaration = 10,
    DomConstructorCSSStyleRule = 11,
    DomConstructorCSSStyleSheet = 12,
    DomConstructorDataTransfer = 13,
    DomConstructorDOMImplementation = 14,
    DomConstructorElement = 15,
    DomConstructorEvent = 16,
    DomConstructorHistory = 17,
    DomConstructorHTCElementBehaviorDefaults = 18,
    DomConstructorHTMLAnchorElement = 19,
    DomConstructorHTMLAreaElement = 20,
    DomConstructorHTMLAreasCollection = 21,
    DomConstructorHTMLBaseElement = 22,
    DomConstructorHTMLBaseFontElement = 23,
    DomConstructorHTMLBGSoundElement = 24,
    DomConstructorHTMLBlockElement = 25,
    DomConstructorHTMLBodyElement = 26,
    DomConstructorHTMLBRElement = 27,
    DomConstructorHTMLButtonElement = 28,
    DomConstructorHTMLCollection = 29,
    DomConstructorHTMLCommentElement = 30,
    DomConstructorHTMLDDElement = 31,
    DomConstructorHTMLDivElement = 32,
    DomConstructorHTMLDocument = 33,
    DomConstructorHTMLDListElement = 34,
    DomConstructorHTMLDTElement = 35,
    DomConstructorHTMLEmbedElement = 36,
    DomConstructorHTMLFieldSetElement = 37,
    DomConstructorHTMLFontElement = 38,
    DomConstructorHTMLFormElement = 39,
    DomConstructorHTMLFrameElement = 40,
    DomConstructorHTMLFrameSetElement = 41,
    DomConstructorHTMLGenericElement = 42,
    DomConstructorHTMLHeadElement = 43,
    DomConstructorHTMLHeadingElement = 44,
    DomConstructorHTMLHRElement = 45,
    DomConstructorHTMLHtmlElement = 46,
    DomConstructorHTMLIFrameElement = 47,
    DomConstructorHTMLImageElement = 48,
    DomConstructorHTMLInputElement = 49,
    DomConstructorHTMLIsIndexElement = 50,
    DomConstructorHTMLLabelElement = 51,
    DomConstructorHTMLLegendElement = 52,
    DomConstructorHTMLLIElement = 53,
    DomConstructorHTMLLinkElement = 54,
    DomConstructorHTMLMapElement = 55,
    DomConstructorHTMLMarqueeElement = 56,
    DomConstructorHTMLMetaElement = 57,
    DomConstructorHTMLModelessDialog = 58,
    DomConstructorHTMLNamespaceInfo = 59,
    DomConstructorHTMLNamespaceInfoCollection = 60,
    DomConstructorHTMLNextIdElement = 61,
    DomConstructorHTMLNoShowElement = 62,
    DomConstructorHTMLObjectElement = 63,
    DomConstructorHTMLOListElement = 64,
    DomConstructorHTMLOptionElement = 65,
    DomConstructorHTMLParagraphElement = 66,
    DomConstructorHTMLParamElement = 67,
    DomConstructorHTMLPhraseElement = 68,
    DomConstructorHTMLPluginsCollection = 69,
    DomConstructorHTMLPopup = 70,
    DomConstructorHTMLScriptElement = 71,
    DomConstructorHTMLSelectElement = 72,
    DomConstructorHTMLSpanElement = 73,
    DomConstructorHTMLStyleElement = 74,
    DomConstructorHTMLTableCaptionElement = 75,
    DomConstructorHTMLTableCellElement = 76,
    DomConstructorHTMLTableColElement = 77,
    DomConstructorHTMLTableElement = 78,
    DomConstructorHTMLTableRowElement = 79,
    DomConstructorHTMLTableSectionElement = 80,
    DomConstructorHTMLTextAreaElement = 81,
    DomConstructorHTMLTextElement = 82,
    DomConstructorHTMLTitleElement = 83,
    DomConstructorHTMLUListElement = 84,
    DomConstructorHTMLUnknownElement = 85,
    DomConstructorImage = 86,
    DomConstructorLocation = 87,
    DomConstructorNamedNodeMap = 88,
    DomConstructorNavigator = 89,
    DomConstructorNodeList = 90,
    DomConstructorOption = 91,
    DomConstructorScreen = 92,
    DomConstructorSelection = 93,
    DomConstructorStaticNodeList = 94,
    DomConstructorStorage = 95,
    DomConstructorStyleSheetList = 96,
    DomConstructorStyleSheetPage = 97,
    DomConstructorStyleSheetPageList = 98,
    DomConstructorText = 99,
    DomConstructorTextRange = 100,
    DomConstructorTextRangeCollection = 101,
    DomConstructorTextRectangle = 102,
    DomConstructorTextRectangleList = 103,
    DomConstructorWindow = 104,
    DomConstructorXDomainRequest = 105,
    DomConstructorXMLHttpRequest = 106,
    DomConstructorMax = 107,
    Max = 2147483647,
};
pub const DomConstructorObject = DomConstructor.DomConstructorObject;
pub const DomConstructorAttr = DomConstructor.DomConstructorAttr;
pub const DomConstructorBehaviorUrnsCollection = DomConstructor.DomConstructorBehaviorUrnsCollection;
pub const DomConstructorBookmarkCollection = DomConstructor.DomConstructorBookmarkCollection;
pub const DomConstructorCompatibleInfo = DomConstructor.DomConstructorCompatibleInfo;
pub const DomConstructorCompatibleInfoCollection = DomConstructor.DomConstructorCompatibleInfoCollection;
pub const DomConstructorControlRangeCollection = DomConstructor.DomConstructorControlRangeCollection;
pub const DomConstructorCSSCurrentStyleDeclaration = DomConstructor.DomConstructorCSSCurrentStyleDeclaration;
pub const DomConstructorCSSRuleList = DomConstructor.DomConstructorCSSRuleList;
pub const DomConstructorCSSRuleStyleDeclaration = DomConstructor.DomConstructorCSSRuleStyleDeclaration;
pub const DomConstructorCSSStyleDeclaration = DomConstructor.DomConstructorCSSStyleDeclaration;
pub const DomConstructorCSSStyleRule = DomConstructor.DomConstructorCSSStyleRule;
pub const DomConstructorCSSStyleSheet = DomConstructor.DomConstructorCSSStyleSheet;
pub const DomConstructorDataTransfer = DomConstructor.DomConstructorDataTransfer;
pub const DomConstructorDOMImplementation = DomConstructor.DomConstructorDOMImplementation;
pub const DomConstructorElement = DomConstructor.DomConstructorElement;
pub const DomConstructorEvent = DomConstructor.DomConstructorEvent;
pub const DomConstructorHistory = DomConstructor.DomConstructorHistory;
pub const DomConstructorHTCElementBehaviorDefaults = DomConstructor.DomConstructorHTCElementBehaviorDefaults;
pub const DomConstructorHTMLAnchorElement = DomConstructor.DomConstructorHTMLAnchorElement;
pub const DomConstructorHTMLAreaElement = DomConstructor.DomConstructorHTMLAreaElement;
pub const DomConstructorHTMLAreasCollection = DomConstructor.DomConstructorHTMLAreasCollection;
pub const DomConstructorHTMLBaseElement = DomConstructor.DomConstructorHTMLBaseElement;
pub const DomConstructorHTMLBaseFontElement = DomConstructor.DomConstructorHTMLBaseFontElement;
pub const DomConstructorHTMLBGSoundElement = DomConstructor.DomConstructorHTMLBGSoundElement;
pub const DomConstructorHTMLBlockElement = DomConstructor.DomConstructorHTMLBlockElement;
pub const DomConstructorHTMLBodyElement = DomConstructor.DomConstructorHTMLBodyElement;
pub const DomConstructorHTMLBRElement = DomConstructor.DomConstructorHTMLBRElement;
pub const DomConstructorHTMLButtonElement = DomConstructor.DomConstructorHTMLButtonElement;
pub const DomConstructorHTMLCollection = DomConstructor.DomConstructorHTMLCollection;
pub const DomConstructorHTMLCommentElement = DomConstructor.DomConstructorHTMLCommentElement;
pub const DomConstructorHTMLDDElement = DomConstructor.DomConstructorHTMLDDElement;
pub const DomConstructorHTMLDivElement = DomConstructor.DomConstructorHTMLDivElement;
pub const DomConstructorHTMLDocument = DomConstructor.DomConstructorHTMLDocument;
pub const DomConstructorHTMLDListElement = DomConstructor.DomConstructorHTMLDListElement;
pub const DomConstructorHTMLDTElement = DomConstructor.DomConstructorHTMLDTElement;
pub const DomConstructorHTMLEmbedElement = DomConstructor.DomConstructorHTMLEmbedElement;
pub const DomConstructorHTMLFieldSetElement = DomConstructor.DomConstructorHTMLFieldSetElement;
pub const DomConstructorHTMLFontElement = DomConstructor.DomConstructorHTMLFontElement;
pub const DomConstructorHTMLFormElement = DomConstructor.DomConstructorHTMLFormElement;
pub const DomConstructorHTMLFrameElement = DomConstructor.DomConstructorHTMLFrameElement;
pub const DomConstructorHTMLFrameSetElement = DomConstructor.DomConstructorHTMLFrameSetElement;
pub const DomConstructorHTMLGenericElement = DomConstructor.DomConstructorHTMLGenericElement;
pub const DomConstructorHTMLHeadElement = DomConstructor.DomConstructorHTMLHeadElement;
pub const DomConstructorHTMLHeadingElement = DomConstructor.DomConstructorHTMLHeadingElement;
pub const DomConstructorHTMLHRElement = DomConstructor.DomConstructorHTMLHRElement;
pub const DomConstructorHTMLHtmlElement = DomConstructor.DomConstructorHTMLHtmlElement;
pub const DomConstructorHTMLIFrameElement = DomConstructor.DomConstructorHTMLIFrameElement;
pub const DomConstructorHTMLImageElement = DomConstructor.DomConstructorHTMLImageElement;
pub const DomConstructorHTMLInputElement = DomConstructor.DomConstructorHTMLInputElement;
pub const DomConstructorHTMLIsIndexElement = DomConstructor.DomConstructorHTMLIsIndexElement;
pub const DomConstructorHTMLLabelElement = DomConstructor.DomConstructorHTMLLabelElement;
pub const DomConstructorHTMLLegendElement = DomConstructor.DomConstructorHTMLLegendElement;
pub const DomConstructorHTMLLIElement = DomConstructor.DomConstructorHTMLLIElement;
pub const DomConstructorHTMLLinkElement = DomConstructor.DomConstructorHTMLLinkElement;
pub const DomConstructorHTMLMapElement = DomConstructor.DomConstructorHTMLMapElement;
pub const DomConstructorHTMLMarqueeElement = DomConstructor.DomConstructorHTMLMarqueeElement;
pub const DomConstructorHTMLMetaElement = DomConstructor.DomConstructorHTMLMetaElement;
pub const DomConstructorHTMLModelessDialog = DomConstructor.DomConstructorHTMLModelessDialog;
pub const DomConstructorHTMLNamespaceInfo = DomConstructor.DomConstructorHTMLNamespaceInfo;
pub const DomConstructorHTMLNamespaceInfoCollection = DomConstructor.DomConstructorHTMLNamespaceInfoCollection;
pub const DomConstructorHTMLNextIdElement = DomConstructor.DomConstructorHTMLNextIdElement;
pub const DomConstructorHTMLNoShowElement = DomConstructor.DomConstructorHTMLNoShowElement;
pub const DomConstructorHTMLObjectElement = DomConstructor.DomConstructorHTMLObjectElement;
pub const DomConstructorHTMLOListElement = DomConstructor.DomConstructorHTMLOListElement;
pub const DomConstructorHTMLOptionElement = DomConstructor.DomConstructorHTMLOptionElement;
pub const DomConstructorHTMLParagraphElement = DomConstructor.DomConstructorHTMLParagraphElement;
pub const DomConstructorHTMLParamElement = DomConstructor.DomConstructorHTMLParamElement;
pub const DomConstructorHTMLPhraseElement = DomConstructor.DomConstructorHTMLPhraseElement;
pub const DomConstructorHTMLPluginsCollection = DomConstructor.DomConstructorHTMLPluginsCollection;
pub const DomConstructorHTMLPopup = DomConstructor.DomConstructorHTMLPopup;
pub const DomConstructorHTMLScriptElement = DomConstructor.DomConstructorHTMLScriptElement;
pub const DomConstructorHTMLSelectElement = DomConstructor.DomConstructorHTMLSelectElement;
pub const DomConstructorHTMLSpanElement = DomConstructor.DomConstructorHTMLSpanElement;
pub const DomConstructorHTMLStyleElement = DomConstructor.DomConstructorHTMLStyleElement;
pub const DomConstructorHTMLTableCaptionElement = DomConstructor.DomConstructorHTMLTableCaptionElement;
pub const DomConstructorHTMLTableCellElement = DomConstructor.DomConstructorHTMLTableCellElement;
pub const DomConstructorHTMLTableColElement = DomConstructor.DomConstructorHTMLTableColElement;
pub const DomConstructorHTMLTableElement = DomConstructor.DomConstructorHTMLTableElement;
pub const DomConstructorHTMLTableRowElement = DomConstructor.DomConstructorHTMLTableRowElement;
pub const DomConstructorHTMLTableSectionElement = DomConstructor.DomConstructorHTMLTableSectionElement;
pub const DomConstructorHTMLTextAreaElement = DomConstructor.DomConstructorHTMLTextAreaElement;
pub const DomConstructorHTMLTextElement = DomConstructor.DomConstructorHTMLTextElement;
pub const DomConstructorHTMLTitleElement = DomConstructor.DomConstructorHTMLTitleElement;
pub const DomConstructorHTMLUListElement = DomConstructor.DomConstructorHTMLUListElement;
pub const DomConstructorHTMLUnknownElement = DomConstructor.DomConstructorHTMLUnknownElement;
pub const DomConstructorImage = DomConstructor.DomConstructorImage;
pub const DomConstructorLocation = DomConstructor.DomConstructorLocation;
pub const DomConstructorNamedNodeMap = DomConstructor.DomConstructorNamedNodeMap;
pub const DomConstructorNavigator = DomConstructor.DomConstructorNavigator;
pub const DomConstructorNodeList = DomConstructor.DomConstructorNodeList;
pub const DomConstructorOption = DomConstructor.DomConstructorOption;
pub const DomConstructorScreen = DomConstructor.DomConstructorScreen;
pub const DomConstructorSelection = DomConstructor.DomConstructorSelection;
pub const DomConstructorStaticNodeList = DomConstructor.DomConstructorStaticNodeList;
pub const DomConstructorStorage = DomConstructor.DomConstructorStorage;
pub const DomConstructorStyleSheetList = DomConstructor.DomConstructorStyleSheetList;
pub const DomConstructorStyleSheetPage = DomConstructor.DomConstructorStyleSheetPage;
pub const DomConstructorStyleSheetPageList = DomConstructor.DomConstructorStyleSheetPageList;
pub const DomConstructorText = DomConstructor.DomConstructorText;
pub const DomConstructorTextRange = DomConstructor.DomConstructorTextRange;
pub const DomConstructorTextRangeCollection = DomConstructor.DomConstructorTextRangeCollection;
pub const DomConstructorTextRectangle = DomConstructor.DomConstructorTextRectangle;
pub const DomConstructorTextRectangleList = DomConstructor.DomConstructorTextRectangleList;
pub const DomConstructorWindow = DomConstructor.DomConstructorWindow;
pub const DomConstructorXDomainRequest = DomConstructor.DomConstructorXDomainRequest;
pub const DomConstructorXMLHttpRequest = DomConstructor.DomConstructorXMLHttpRequest;
pub const DomConstructorMax = DomConstructor.DomConstructorMax;
pub const DomConstructor_Max = DomConstructor.Max;

pub const styleTextTransform = extern enum(i32) {
    styleTextTransformNotSet = 0,
    styleTextTransformCapitalize = 1,
    styleTextTransformLowercase = 2,
    styleTextTransformUppercase = 3,
    styleTextTransformNone = 4,
    Max = 2147483647,
};
pub const styleTextTransformNotSet = styleTextTransform.styleTextTransformNotSet;
pub const styleTextTransformCapitalize = styleTextTransform.styleTextTransformCapitalize;
pub const styleTextTransformLowercase = styleTextTransform.styleTextTransformLowercase;
pub const styleTextTransformUppercase = styleTextTransform.styleTextTransformUppercase;
pub const styleTextTransformNone = styleTextTransform.styleTextTransformNone;
pub const styleTextTransform_Max = styleTextTransform.Max;

pub const styleDataRepeat = extern enum(i32) {
    styleDataRepeatNone = 0,
    styleDataRepeatInner = 1,
    Max = 2147483647,
};
pub const styleDataRepeatNone = styleDataRepeat.styleDataRepeatNone;
pub const styleDataRepeatInner = styleDataRepeat.styleDataRepeatInner;
pub const styleDataRepeat_Max = styleDataRepeat.Max;

pub const styleOverflow = extern enum(i32) {
    styleOverflowNotSet = 0,
    styleOverflowAuto = 1,
    styleOverflowHidden = 2,
    styleOverflowVisible = 3,
    styleOverflowScroll = 4,
    Max = 2147483647,
};
pub const styleOverflowNotSet = styleOverflow.styleOverflowNotSet;
pub const styleOverflowAuto = styleOverflow.styleOverflowAuto;
pub const styleOverflowHidden = styleOverflow.styleOverflowHidden;
pub const styleOverflowVisible = styleOverflow.styleOverflowVisible;
pub const styleOverflowScroll = styleOverflow.styleOverflowScroll;
pub const styleOverflow_Max = styleOverflow.Max;

pub const styleMsOverflowStyle = extern enum(i32) {
    styleMsOverflowStyleNotSet = 0,
    styleMsOverflowStyleAuto = 1,
    styleMsOverflowStyleNone = 2,
    styleMsOverflowStyleScrollbar = 3,
    styleMsOverflowStyleMsAutoHidingScrollbar = 4,
    Max = 2147483647,
};
pub const styleMsOverflowStyleNotSet = styleMsOverflowStyle.styleMsOverflowStyleNotSet;
pub const styleMsOverflowStyleAuto = styleMsOverflowStyle.styleMsOverflowStyleAuto;
pub const styleMsOverflowStyleNone = styleMsOverflowStyle.styleMsOverflowStyleNone;
pub const styleMsOverflowStyleScrollbar = styleMsOverflowStyle.styleMsOverflowStyleScrollbar;
pub const styleMsOverflowStyleMsAutoHidingScrollbar = styleMsOverflowStyle.styleMsOverflowStyleMsAutoHidingScrollbar;
pub const styleMsOverflowStyle_Max = styleMsOverflowStyle.Max;

pub const styleTableLayout = extern enum(i32) {
    styleTableLayoutNotSet = 0,
    styleTableLayoutAuto = 1,
    styleTableLayoutFixed = 2,
    Max = 2147483647,
};
pub const styleTableLayoutNotSet = styleTableLayout.styleTableLayoutNotSet;
pub const styleTableLayoutAuto = styleTableLayout.styleTableLayoutAuto;
pub const styleTableLayoutFixed = styleTableLayout.styleTableLayoutFixed;
pub const styleTableLayout_Max = styleTableLayout.Max;

pub const styleBorderCollapse = extern enum(i32) {
    styleBorderCollapseNotSet = 0,
    styleBorderCollapseSeparate = 1,
    styleBorderCollapseCollapse = 2,
    Max = 2147483647,
};
pub const styleBorderCollapseNotSet = styleBorderCollapse.styleBorderCollapseNotSet;
pub const styleBorderCollapseSeparate = styleBorderCollapse.styleBorderCollapseSeparate;
pub const styleBorderCollapseCollapse = styleBorderCollapse.styleBorderCollapseCollapse;
pub const styleBorderCollapse_Max = styleBorderCollapse.Max;

pub const styleCaptionSide = extern enum(i32) {
    styleCaptionSideNotSet = 0,
    styleCaptionSideTop = 1,
    styleCaptionSideBottom = 2,
    styleCaptionSideLeft = 3,
    styleCaptionSideRight = 4,
    Max = 2147483647,
};
pub const styleCaptionSideNotSet = styleCaptionSide.styleCaptionSideNotSet;
pub const styleCaptionSideTop = styleCaptionSide.styleCaptionSideTop;
pub const styleCaptionSideBottom = styleCaptionSide.styleCaptionSideBottom;
pub const styleCaptionSideLeft = styleCaptionSide.styleCaptionSideLeft;
pub const styleCaptionSideRight = styleCaptionSide.styleCaptionSideRight;
pub const styleCaptionSide_Max = styleCaptionSide.Max;

pub const styleEmptyCells = extern enum(i32) {
    styleEmptyCellsNotSet = 0,
    styleEmptyCellsShow = 1,
    styleEmptyCellsHide = 2,
    Max = 2147483647,
};
pub const styleEmptyCellsNotSet = styleEmptyCells.styleEmptyCellsNotSet;
pub const styleEmptyCellsShow = styleEmptyCells.styleEmptyCellsShow;
pub const styleEmptyCellsHide = styleEmptyCells.styleEmptyCellsHide;
pub const styleEmptyCells_Max = styleEmptyCells.Max;

pub const styleFontStyle = extern enum(i32) {
    styleFontStyleNotSet = 0,
    styleFontStyleItalic = 1,
    styleFontStyleOblique = 2,
    styleFontStyleNormal = 3,
    Max = 2147483647,
};
pub const styleFontStyleNotSet = styleFontStyle.styleFontStyleNotSet;
pub const styleFontStyleItalic = styleFontStyle.styleFontStyleItalic;
pub const styleFontStyleOblique = styleFontStyle.styleFontStyleOblique;
pub const styleFontStyleNormal = styleFontStyle.styleFontStyleNormal;
pub const styleFontStyle_Max = styleFontStyle.Max;

pub const styleFontVariant = extern enum(i32) {
    styleFontVariantNotSet = 0,
    styleFontVariantSmallCaps = 1,
    styleFontVariantNormal = 2,
    Max = 2147483647,
};
pub const styleFontVariantNotSet = styleFontVariant.styleFontVariantNotSet;
pub const styleFontVariantSmallCaps = styleFontVariant.styleFontVariantSmallCaps;
pub const styleFontVariantNormal = styleFontVariant.styleFontVariantNormal;
pub const styleFontVariant_Max = styleFontVariant.Max;

pub const styleBackgroundRepeat = extern enum(i32) {
    styleBackgroundRepeatRepeat = 0,
    styleBackgroundRepeatRepeatX = 1,
    styleBackgroundRepeatRepeatY = 2,
    styleBackgroundRepeatNoRepeat = 3,
    styleBackgroundRepeatNotSet = 4,
    Max = 2147483647,
};
pub const styleBackgroundRepeatRepeat = styleBackgroundRepeat.styleBackgroundRepeatRepeat;
pub const styleBackgroundRepeatRepeatX = styleBackgroundRepeat.styleBackgroundRepeatRepeatX;
pub const styleBackgroundRepeatRepeatY = styleBackgroundRepeat.styleBackgroundRepeatRepeatY;
pub const styleBackgroundRepeatNoRepeat = styleBackgroundRepeat.styleBackgroundRepeatNoRepeat;
pub const styleBackgroundRepeatNotSet = styleBackgroundRepeat.styleBackgroundRepeatNotSet;
pub const styleBackgroundRepeat_Max = styleBackgroundRepeat.Max;

pub const styleBackgroundAttachment = extern enum(i32) {
    styleBackgroundAttachmentFixed = 0,
    styleBackgroundAttachmentScroll = 1,
    styleBackgroundAttachmentNotSet = 2,
    Max = 2147483647,
};
pub const styleBackgroundAttachmentFixed = styleBackgroundAttachment.styleBackgroundAttachmentFixed;
pub const styleBackgroundAttachmentScroll = styleBackgroundAttachment.styleBackgroundAttachmentScroll;
pub const styleBackgroundAttachmentNotSet = styleBackgroundAttachment.styleBackgroundAttachmentNotSet;
pub const styleBackgroundAttachment_Max = styleBackgroundAttachment.Max;

pub const styleBackgroundAttachment3 = extern enum(i32) {
    styleBackgroundAttachment3Fixed = 0,
    styleBackgroundAttachment3Scroll = 1,
    styleBackgroundAttachment3Local = 2,
    styleBackgroundAttachment3NotSet = 3,
    Max = 2147483647,
};
pub const styleBackgroundAttachment3Fixed = styleBackgroundAttachment3.styleBackgroundAttachment3Fixed;
pub const styleBackgroundAttachment3Scroll = styleBackgroundAttachment3.styleBackgroundAttachment3Scroll;
pub const styleBackgroundAttachment3Local = styleBackgroundAttachment3.styleBackgroundAttachment3Local;
pub const styleBackgroundAttachment3NotSet = styleBackgroundAttachment3.styleBackgroundAttachment3NotSet;
pub const styleBackgroundAttachment3_Max = styleBackgroundAttachment3.Max;

pub const styleBackgroundClip = extern enum(i32) {
    styleBackgroundClipBorderBox = 0,
    styleBackgroundClipPaddingBox = 1,
    styleBackgroundClipContentBox = 2,
    styleBackgroundClipNotSet = 3,
    Max = 2147483647,
};
pub const styleBackgroundClipBorderBox = styleBackgroundClip.styleBackgroundClipBorderBox;
pub const styleBackgroundClipPaddingBox = styleBackgroundClip.styleBackgroundClipPaddingBox;
pub const styleBackgroundClipContentBox = styleBackgroundClip.styleBackgroundClipContentBox;
pub const styleBackgroundClipNotSet = styleBackgroundClip.styleBackgroundClipNotSet;
pub const styleBackgroundClip_Max = styleBackgroundClip.Max;

pub const styleBackgroundOrigin = extern enum(i32) {
    styleBackgroundOriginBorderBox = 0,
    styleBackgroundOriginPaddingBox = 1,
    styleBackgroundOriginContentBox = 2,
    styleBackgroundOriginNotSet = 3,
    Max = 2147483647,
};
pub const styleBackgroundOriginBorderBox = styleBackgroundOrigin.styleBackgroundOriginBorderBox;
pub const styleBackgroundOriginPaddingBox = styleBackgroundOrigin.styleBackgroundOriginPaddingBox;
pub const styleBackgroundOriginContentBox = styleBackgroundOrigin.styleBackgroundOriginContentBox;
pub const styleBackgroundOriginNotSet = styleBackgroundOrigin.styleBackgroundOriginNotSet;
pub const styleBackgroundOrigin_Max = styleBackgroundOrigin.Max;

pub const styleVerticalAlign = extern enum(i32) {
    styleVerticalAlignAuto = 0,
    styleVerticalAlignBaseline = 1,
    styleVerticalAlignSub = 2,
    styleVerticalAlignSuper = 3,
    styleVerticalAlignTop = 4,
    styleVerticalAlignTextTop = 5,
    styleVerticalAlignMiddle = 6,
    styleVerticalAlignBottom = 7,
    styleVerticalAlignTextBottom = 8,
    styleVerticalAlignInherit = 9,
    styleVerticalAlignNotSet = 10,
    Max = 2147483647,
};
pub const styleVerticalAlignAuto = styleVerticalAlign.styleVerticalAlignAuto;
pub const styleVerticalAlignBaseline = styleVerticalAlign.styleVerticalAlignBaseline;
pub const styleVerticalAlignSub = styleVerticalAlign.styleVerticalAlignSub;
pub const styleVerticalAlignSuper = styleVerticalAlign.styleVerticalAlignSuper;
pub const styleVerticalAlignTop = styleVerticalAlign.styleVerticalAlignTop;
pub const styleVerticalAlignTextTop = styleVerticalAlign.styleVerticalAlignTextTop;
pub const styleVerticalAlignMiddle = styleVerticalAlign.styleVerticalAlignMiddle;
pub const styleVerticalAlignBottom = styleVerticalAlign.styleVerticalAlignBottom;
pub const styleVerticalAlignTextBottom = styleVerticalAlign.styleVerticalAlignTextBottom;
pub const styleVerticalAlignInherit = styleVerticalAlign.styleVerticalAlignInherit;
pub const styleVerticalAlignNotSet = styleVerticalAlign.styleVerticalAlignNotSet;
pub const styleVerticalAlign_Max = styleVerticalAlign.Max;

pub const styleFontWeight = extern enum(i32) {
    styleFontWeightNotSet = 0,
    styleFontWeight100 = 1,
    styleFontWeight200 = 2,
    styleFontWeight300 = 3,
    styleFontWeight400 = 4,
    styleFontWeight500 = 5,
    styleFontWeight600 = 6,
    styleFontWeight700 = 7,
    styleFontWeight800 = 8,
    styleFontWeight900 = 9,
    styleFontWeightNormal = 10,
    styleFontWeightBold = 11,
    styleFontWeightBolder = 12,
    styleFontWeightLighter = 13,
    Max = 2147483647,
};
pub const styleFontWeightNotSet = styleFontWeight.styleFontWeightNotSet;
pub const styleFontWeight100 = styleFontWeight.styleFontWeight100;
pub const styleFontWeight200 = styleFontWeight.styleFontWeight200;
pub const styleFontWeight300 = styleFontWeight.styleFontWeight300;
pub const styleFontWeight400 = styleFontWeight.styleFontWeight400;
pub const styleFontWeight500 = styleFontWeight.styleFontWeight500;
pub const styleFontWeight600 = styleFontWeight.styleFontWeight600;
pub const styleFontWeight700 = styleFontWeight.styleFontWeight700;
pub const styleFontWeight800 = styleFontWeight.styleFontWeight800;
pub const styleFontWeight900 = styleFontWeight.styleFontWeight900;
pub const styleFontWeightNormal = styleFontWeight.styleFontWeightNormal;
pub const styleFontWeightBold = styleFontWeight.styleFontWeightBold;
pub const styleFontWeightBolder = styleFontWeight.styleFontWeightBolder;
pub const styleFontWeightLighter = styleFontWeight.styleFontWeightLighter;
pub const styleFontWeight_Max = styleFontWeight.Max;

pub const styleFontSize = extern enum(i32) {
    styleFontSizeXXSmall = 0,
    styleFontSizeXSmall = 1,
    styleFontSizeSmall = 2,
    styleFontSizeMedium = 3,
    styleFontSizeLarge = 4,
    styleFontSizeXLarge = 5,
    styleFontSizeXXLarge = 6,
    styleFontSizeSmaller = 7,
    styleFontSizeLarger = 8,
    Max = 2147483647,
};
pub const styleFontSizeXXSmall = styleFontSize.styleFontSizeXXSmall;
pub const styleFontSizeXSmall = styleFontSize.styleFontSizeXSmall;
pub const styleFontSizeSmall = styleFontSize.styleFontSizeSmall;
pub const styleFontSizeMedium = styleFontSize.styleFontSizeMedium;
pub const styleFontSizeLarge = styleFontSize.styleFontSizeLarge;
pub const styleFontSizeXLarge = styleFontSize.styleFontSizeXLarge;
pub const styleFontSizeXXLarge = styleFontSize.styleFontSizeXXLarge;
pub const styleFontSizeSmaller = styleFontSize.styleFontSizeSmaller;
pub const styleFontSizeLarger = styleFontSize.styleFontSizeLarger;
pub const styleFontSize_Max = styleFontSize.Max;

pub const styleZIndex = extern enum(i32) {
    styleZIndexAuto = -2147483647,
    Max = 2147483647,
};
pub const styleZIndexAuto = styleZIndex.styleZIndexAuto;
pub const styleZIndex_Max = styleZIndex.Max;

pub const styleWidowsOrphans = extern enum(i32) {
    styleWidowsOrphansNotSet = -2147483647,
    Max = 2147483647,
};
pub const styleWidowsOrphansNotSet = styleWidowsOrphans.styleWidowsOrphansNotSet;
pub const styleWidowsOrphans_Max = styleWidowsOrphans.Max;

pub const styleAuto = extern enum(i32) {
    styleAutoAuto = 0,
    Max = 2147483647,
};
pub const styleAutoAuto = styleAuto.styleAutoAuto;
pub const styleAuto_Max = styleAuto.Max;

pub const styleNone = extern enum(i32) {
    styleNoneNone = 0,
    Max = 2147483647,
};
pub const styleNoneNone = styleNone.styleNoneNone;
pub const styleNone_Max = styleNone.Max;

pub const styleNormal = extern enum(i32) {
    styleNormalNormal = 0,
    Max = 2147483647,
};
pub const styleNormalNormal = styleNormal.styleNormalNormal;
pub const styleNormal_Max = styleNormal.Max;

pub const styleBorderWidth = extern enum(i32) {
    styleBorderWidthThin = 0,
    styleBorderWidthMedium = 1,
    styleBorderWidthThick = 2,
    Max = 2147483647,
};
pub const styleBorderWidthThin = styleBorderWidth.styleBorderWidthThin;
pub const styleBorderWidthMedium = styleBorderWidth.styleBorderWidthMedium;
pub const styleBorderWidthThick = styleBorderWidth.styleBorderWidthThick;
pub const styleBorderWidth_Max = styleBorderWidth.Max;

pub const stylePosition = extern enum(i32) {
    stylePositionNotSet = 0,
    stylePositionstatic = 1,
    stylePositionrelative = 2,
    stylePositionabsolute = 3,
    stylePositionfixed = 4,
    stylePositionMsPage = 5,
    stylePositionMsDeviceFixed = 6,
    Max = 2147483647,
};
pub const stylePositionNotSet = stylePosition.stylePositionNotSet;
pub const stylePositionstatic = stylePosition.stylePositionstatic;
pub const stylePositionrelative = stylePosition.stylePositionrelative;
pub const stylePositionabsolute = stylePosition.stylePositionabsolute;
pub const stylePositionfixed = stylePosition.stylePositionfixed;
pub const stylePositionMsPage = stylePosition.stylePositionMsPage;
pub const stylePositionMsDeviceFixed = stylePosition.stylePositionMsDeviceFixed;
pub const stylePosition_Max = stylePosition.Max;

pub const styleBorderStyle = extern enum(i32) {
    styleBorderStyleNotSet = 0,
    styleBorderStyleDotted = 1,
    styleBorderStyleDashed = 2,
    styleBorderStyleSolid = 3,
    styleBorderStyleDouble = 4,
    styleBorderStyleGroove = 5,
    styleBorderStyleRidge = 6,
    styleBorderStyleInset = 7,
    styleBorderStyleOutset = 8,
    styleBorderStyleWindowInset = 9,
    styleBorderStyleNone = 10,
    styleBorderStyleHidden = 11,
    Max = 2147483647,
};
pub const styleBorderStyleNotSet = styleBorderStyle.styleBorderStyleNotSet;
pub const styleBorderStyleDotted = styleBorderStyle.styleBorderStyleDotted;
pub const styleBorderStyleDashed = styleBorderStyle.styleBorderStyleDashed;
pub const styleBorderStyleSolid = styleBorderStyle.styleBorderStyleSolid;
pub const styleBorderStyleDouble = styleBorderStyle.styleBorderStyleDouble;
pub const styleBorderStyleGroove = styleBorderStyle.styleBorderStyleGroove;
pub const styleBorderStyleRidge = styleBorderStyle.styleBorderStyleRidge;
pub const styleBorderStyleInset = styleBorderStyle.styleBorderStyleInset;
pub const styleBorderStyleOutset = styleBorderStyle.styleBorderStyleOutset;
pub const styleBorderStyleWindowInset = styleBorderStyle.styleBorderStyleWindowInset;
pub const styleBorderStyleNone = styleBorderStyle.styleBorderStyleNone;
pub const styleBorderStyleHidden = styleBorderStyle.styleBorderStyleHidden;
pub const styleBorderStyle_Max = styleBorderStyle.Max;

pub const styleOutlineStyle = extern enum(i32) {
    styleOutlineStyleNotSet = 0,
    styleOutlineStyleDotted = 1,
    styleOutlineStyleDashed = 2,
    styleOutlineStyleSolid = 3,
    styleOutlineStyleDouble = 4,
    styleOutlineStyleGroove = 5,
    styleOutlineStyleRidge = 6,
    styleOutlineStyleInset = 7,
    styleOutlineStyleOutset = 8,
    styleOutlineStyleWindowInset = 9,
    styleOutlineStyleNone = 10,
    Max = 2147483647,
};
pub const styleOutlineStyleNotSet = styleOutlineStyle.styleOutlineStyleNotSet;
pub const styleOutlineStyleDotted = styleOutlineStyle.styleOutlineStyleDotted;
pub const styleOutlineStyleDashed = styleOutlineStyle.styleOutlineStyleDashed;
pub const styleOutlineStyleSolid = styleOutlineStyle.styleOutlineStyleSolid;
pub const styleOutlineStyleDouble = styleOutlineStyle.styleOutlineStyleDouble;
pub const styleOutlineStyleGroove = styleOutlineStyle.styleOutlineStyleGroove;
pub const styleOutlineStyleRidge = styleOutlineStyle.styleOutlineStyleRidge;
pub const styleOutlineStyleInset = styleOutlineStyle.styleOutlineStyleInset;
pub const styleOutlineStyleOutset = styleOutlineStyle.styleOutlineStyleOutset;
pub const styleOutlineStyleWindowInset = styleOutlineStyle.styleOutlineStyleWindowInset;
pub const styleOutlineStyleNone = styleOutlineStyle.styleOutlineStyleNone;
pub const styleOutlineStyle_Max = styleOutlineStyle.Max;

pub const styleStyleFloat = extern enum(i32) {
    styleStyleFloatNotSet = 0,
    styleStyleFloatLeft = 1,
    styleStyleFloatRight = 2,
    styleStyleFloatNone = 3,
    Max = 2147483647,
};
pub const styleStyleFloatNotSet = styleStyleFloat.styleStyleFloatNotSet;
pub const styleStyleFloatLeft = styleStyleFloat.styleStyleFloatLeft;
pub const styleStyleFloatRight = styleStyleFloat.styleStyleFloatRight;
pub const styleStyleFloatNone = styleStyleFloat.styleStyleFloatNone;
pub const styleStyleFloat_Max = styleStyleFloat.Max;

pub const styleDisplay = extern enum(i32) {
    styleDisplayNotSet = 0,
    styleDisplayBlock = 1,
    styleDisplayInline = 2,
    styleDisplayListItem = 3,
    styleDisplayNone = 4,
    styleDisplayTableHeaderGroup = 5,
    styleDisplayTableFooterGroup = 6,
    styleDisplayInlineBlock = 7,
    styleDisplayTable = 8,
    styleDisplayInlineTable = 9,
    styleDisplayTableRow = 10,
    styleDisplayTableRowGroup = 11,
    styleDisplayTableColumn = 12,
    styleDisplayTableColumnGroup = 13,
    styleDisplayTableCell = 14,
    styleDisplayTableCaption = 15,
    styleDisplayRunIn = 16,
    styleDisplayRuby = 17,
    styleDisplayRubyBase = 18,
    styleDisplayRubyText = 19,
    styleDisplayRubyBaseContainer = 20,
    styleDisplayRubyTextContainer = 21,
    styleDisplayMsFlexbox = 22,
    styleDisplayMsInlineFlexbox = 23,
    styleDisplayMsGrid = 24,
    styleDisplayMsInlineGrid = 25,
    styleDisplayFlex = 26,
    styleDisplayInlineFlex = 27,
    styleDisplayWebkitBox = 28,
    styleDisplayWebkitInlineBox = 29,
    Max = 2147483647,
};
pub const styleDisplayNotSet = styleDisplay.styleDisplayNotSet;
pub const styleDisplayBlock = styleDisplay.styleDisplayBlock;
pub const styleDisplayInline = styleDisplay.styleDisplayInline;
pub const styleDisplayListItem = styleDisplay.styleDisplayListItem;
pub const styleDisplayNone = styleDisplay.styleDisplayNone;
pub const styleDisplayTableHeaderGroup = styleDisplay.styleDisplayTableHeaderGroup;
pub const styleDisplayTableFooterGroup = styleDisplay.styleDisplayTableFooterGroup;
pub const styleDisplayInlineBlock = styleDisplay.styleDisplayInlineBlock;
pub const styleDisplayTable = styleDisplay.styleDisplayTable;
pub const styleDisplayInlineTable = styleDisplay.styleDisplayInlineTable;
pub const styleDisplayTableRow = styleDisplay.styleDisplayTableRow;
pub const styleDisplayTableRowGroup = styleDisplay.styleDisplayTableRowGroup;
pub const styleDisplayTableColumn = styleDisplay.styleDisplayTableColumn;
pub const styleDisplayTableColumnGroup = styleDisplay.styleDisplayTableColumnGroup;
pub const styleDisplayTableCell = styleDisplay.styleDisplayTableCell;
pub const styleDisplayTableCaption = styleDisplay.styleDisplayTableCaption;
pub const styleDisplayRunIn = styleDisplay.styleDisplayRunIn;
pub const styleDisplayRuby = styleDisplay.styleDisplayRuby;
pub const styleDisplayRubyBase = styleDisplay.styleDisplayRubyBase;
pub const styleDisplayRubyText = styleDisplay.styleDisplayRubyText;
pub const styleDisplayRubyBaseContainer = styleDisplay.styleDisplayRubyBaseContainer;
pub const styleDisplayRubyTextContainer = styleDisplay.styleDisplayRubyTextContainer;
pub const styleDisplayMsFlexbox = styleDisplay.styleDisplayMsFlexbox;
pub const styleDisplayMsInlineFlexbox = styleDisplay.styleDisplayMsInlineFlexbox;
pub const styleDisplayMsGrid = styleDisplay.styleDisplayMsGrid;
pub const styleDisplayMsInlineGrid = styleDisplay.styleDisplayMsInlineGrid;
pub const styleDisplayFlex = styleDisplay.styleDisplayFlex;
pub const styleDisplayInlineFlex = styleDisplay.styleDisplayInlineFlex;
pub const styleDisplayWebkitBox = styleDisplay.styleDisplayWebkitBox;
pub const styleDisplayWebkitInlineBox = styleDisplay.styleDisplayWebkitInlineBox;
pub const styleDisplay_Max = styleDisplay.Max;

pub const styleVisibility = extern enum(i32) {
    styleVisibilityNotSet = 0,
    styleVisibilityInherit = 1,
    styleVisibilityVisible = 2,
    styleVisibilityHidden = 3,
    styleVisibilityCollapse = 4,
    Max = 2147483647,
};
pub const styleVisibilityNotSet = styleVisibility.styleVisibilityNotSet;
pub const styleVisibilityInherit = styleVisibility.styleVisibilityInherit;
pub const styleVisibilityVisible = styleVisibility.styleVisibilityVisible;
pub const styleVisibilityHidden = styleVisibility.styleVisibilityHidden;
pub const styleVisibilityCollapse = styleVisibility.styleVisibilityCollapse;
pub const styleVisibility_Max = styleVisibility.Max;

pub const styleListStyleType = extern enum(i32) {
    styleListStyleTypeNotSet = 0,
    styleListStyleTypeDisc = 1,
    styleListStyleTypeCircle = 2,
    styleListStyleTypeSquare = 3,
    styleListStyleTypeDecimal = 4,
    styleListStyleTypeLowerRoman = 5,
    styleListStyleTypeUpperRoman = 6,
    styleListStyleTypeLowerAlpha = 7,
    styleListStyleTypeUpperAlpha = 8,
    styleListStyleTypeNone = 9,
    styleListStyleTypeDecimalLeadingZero = 10,
    styleListStyleTypeGeorgian = 11,
    styleListStyleTypeArmenian = 12,
    styleListStyleTypeUpperLatin = 13,
    styleListStyleTypeLowerLatin = 14,
    styleListStyleTypeUpperGreek = 15,
    styleListStyleTypeLowerGreek = 16,
    Max = 2147483647,
};
pub const styleListStyleTypeNotSet = styleListStyleType.styleListStyleTypeNotSet;
pub const styleListStyleTypeDisc = styleListStyleType.styleListStyleTypeDisc;
pub const styleListStyleTypeCircle = styleListStyleType.styleListStyleTypeCircle;
pub const styleListStyleTypeSquare = styleListStyleType.styleListStyleTypeSquare;
pub const styleListStyleTypeDecimal = styleListStyleType.styleListStyleTypeDecimal;
pub const styleListStyleTypeLowerRoman = styleListStyleType.styleListStyleTypeLowerRoman;
pub const styleListStyleTypeUpperRoman = styleListStyleType.styleListStyleTypeUpperRoman;
pub const styleListStyleTypeLowerAlpha = styleListStyleType.styleListStyleTypeLowerAlpha;
pub const styleListStyleTypeUpperAlpha = styleListStyleType.styleListStyleTypeUpperAlpha;
pub const styleListStyleTypeNone = styleListStyleType.styleListStyleTypeNone;
pub const styleListStyleTypeDecimalLeadingZero = styleListStyleType.styleListStyleTypeDecimalLeadingZero;
pub const styleListStyleTypeGeorgian = styleListStyleType.styleListStyleTypeGeorgian;
pub const styleListStyleTypeArmenian = styleListStyleType.styleListStyleTypeArmenian;
pub const styleListStyleTypeUpperLatin = styleListStyleType.styleListStyleTypeUpperLatin;
pub const styleListStyleTypeLowerLatin = styleListStyleType.styleListStyleTypeLowerLatin;
pub const styleListStyleTypeUpperGreek = styleListStyleType.styleListStyleTypeUpperGreek;
pub const styleListStyleTypeLowerGreek = styleListStyleType.styleListStyleTypeLowerGreek;
pub const styleListStyleType_Max = styleListStyleType.Max;

pub const styleListStylePosition = extern enum(i32) {
    styleListStylePositionNotSet = 0,
    styleListStylePositionInside = 1,
    styleListStylePositionOutSide = 2,
    Max = 2147483647,
};
pub const styleListStylePositionNotSet = styleListStylePosition.styleListStylePositionNotSet;
pub const styleListStylePositionInside = styleListStylePosition.styleListStylePositionInside;
pub const styleListStylePositionOutSide = styleListStylePosition.styleListStylePositionOutSide;
pub const styleListStylePosition_Max = styleListStylePosition.Max;

pub const styleWhiteSpace = extern enum(i32) {
    styleWhiteSpaceNotSet = 0,
    styleWhiteSpaceNormal = 1,
    styleWhiteSpacePre = 2,
    styleWhiteSpaceNowrap = 3,
    styleWhiteSpacePreline = 4,
    styleWhiteSpacePrewrap = 5,
    Max = 2147483647,
};
pub const styleWhiteSpaceNotSet = styleWhiteSpace.styleWhiteSpaceNotSet;
pub const styleWhiteSpaceNormal = styleWhiteSpace.styleWhiteSpaceNormal;
pub const styleWhiteSpacePre = styleWhiteSpace.styleWhiteSpacePre;
pub const styleWhiteSpaceNowrap = styleWhiteSpace.styleWhiteSpaceNowrap;
pub const styleWhiteSpacePreline = styleWhiteSpace.styleWhiteSpacePreline;
pub const styleWhiteSpacePrewrap = styleWhiteSpace.styleWhiteSpacePrewrap;
pub const styleWhiteSpace_Max = styleWhiteSpace.Max;

pub const stylePageBreak = extern enum(i32) {
    stylePageBreakNotSet = 0,
    stylePageBreakAuto = 1,
    stylePageBreakAlways = 2,
    stylePageBreakLeft = 3,
    stylePageBreakRight = 4,
    stylePageBreakAvoid = 5,
    Max = 2147483647,
};
pub const stylePageBreakNotSet = stylePageBreak.stylePageBreakNotSet;
pub const stylePageBreakAuto = stylePageBreak.stylePageBreakAuto;
pub const stylePageBreakAlways = stylePageBreak.stylePageBreakAlways;
pub const stylePageBreakLeft = stylePageBreak.stylePageBreakLeft;
pub const stylePageBreakRight = stylePageBreak.stylePageBreakRight;
pub const stylePageBreakAvoid = stylePageBreak.stylePageBreakAvoid;
pub const stylePageBreak_Max = stylePageBreak.Max;

pub const stylePageBreakInside = extern enum(i32) {
    stylePageBreakInsideNotSet = 0,
    stylePageBreakInsideAuto = 1,
    stylePageBreakInsideAvoid = 2,
    Max = 2147483647,
};
pub const stylePageBreakInsideNotSet = stylePageBreakInside.stylePageBreakInsideNotSet;
pub const stylePageBreakInsideAuto = stylePageBreakInside.stylePageBreakInsideAuto;
pub const stylePageBreakInsideAvoid = stylePageBreakInside.stylePageBreakInsideAvoid;
pub const stylePageBreakInside_Max = stylePageBreakInside.Max;

pub const styleCursor = extern enum(i32) {
    styleCursorAuto = 0,
    styleCursorCrosshair = 1,
    styleCursorDefault = 2,
    styleCursorHand = 3,
    styleCursorMove = 4,
    styleCursorE_resize = 5,
    styleCursorNe_resize = 6,
    styleCursorNw_resize = 7,
    styleCursorN_resize = 8,
    styleCursorSe_resize = 9,
    styleCursorSw_resize = 10,
    styleCursorS_resize = 11,
    styleCursorW_resize = 12,
    styleCursorText = 13,
    styleCursorWait = 14,
    styleCursorHelp = 15,
    styleCursorPointer = 16,
    styleCursorProgress = 17,
    styleCursorNot_allowed = 18,
    styleCursorNo_drop = 19,
    styleCursorVertical_text = 20,
    styleCursorall_scroll = 21,
    styleCursorcol_resize = 22,
    styleCursorrow_resize = 23,
    styleCursorNone = 24,
    styleCursorContext_menu = 25,
    styleCursorEw_resize = 26,
    styleCursorNs_resize = 27,
    styleCursorNesw_resize = 28,
    styleCursorNwse_resize = 29,
    styleCursorCell = 30,
    styleCursorCopy = 31,
    styleCursorAlias = 32,
    styleCursorcustom = 33,
    styleCursorNotSet = 34,
    Max = 2147483647,
};
pub const styleCursorAuto = styleCursor.styleCursorAuto;
pub const styleCursorCrosshair = styleCursor.styleCursorCrosshair;
pub const styleCursorDefault = styleCursor.styleCursorDefault;
pub const styleCursorHand = styleCursor.styleCursorHand;
pub const styleCursorMove = styleCursor.styleCursorMove;
pub const styleCursorE_resize = styleCursor.styleCursorE_resize;
pub const styleCursorNe_resize = styleCursor.styleCursorNe_resize;
pub const styleCursorNw_resize = styleCursor.styleCursorNw_resize;
pub const styleCursorN_resize = styleCursor.styleCursorN_resize;
pub const styleCursorSe_resize = styleCursor.styleCursorSe_resize;
pub const styleCursorSw_resize = styleCursor.styleCursorSw_resize;
pub const styleCursorS_resize = styleCursor.styleCursorS_resize;
pub const styleCursorW_resize = styleCursor.styleCursorW_resize;
pub const styleCursorText = styleCursor.styleCursorText;
pub const styleCursorWait = styleCursor.styleCursorWait;
pub const styleCursorHelp = styleCursor.styleCursorHelp;
pub const styleCursorPointer = styleCursor.styleCursorPointer;
pub const styleCursorProgress = styleCursor.styleCursorProgress;
pub const styleCursorNot_allowed = styleCursor.styleCursorNot_allowed;
pub const styleCursorNo_drop = styleCursor.styleCursorNo_drop;
pub const styleCursorVertical_text = styleCursor.styleCursorVertical_text;
pub const styleCursorall_scroll = styleCursor.styleCursorall_scroll;
pub const styleCursorcol_resize = styleCursor.styleCursorcol_resize;
pub const styleCursorrow_resize = styleCursor.styleCursorrow_resize;
pub const styleCursorNone = styleCursor.styleCursorNone;
pub const styleCursorContext_menu = styleCursor.styleCursorContext_menu;
pub const styleCursorEw_resize = styleCursor.styleCursorEw_resize;
pub const styleCursorNs_resize = styleCursor.styleCursorNs_resize;
pub const styleCursorNesw_resize = styleCursor.styleCursorNesw_resize;
pub const styleCursorNwse_resize = styleCursor.styleCursorNwse_resize;
pub const styleCursorCell = styleCursor.styleCursorCell;
pub const styleCursorCopy = styleCursor.styleCursorCopy;
pub const styleCursorAlias = styleCursor.styleCursorAlias;
pub const styleCursorcustom = styleCursor.styleCursorcustom;
pub const styleCursorNotSet = styleCursor.styleCursorNotSet;
pub const styleCursor_Max = styleCursor.Max;

pub const styleDir = extern enum(i32) {
    styleDirNotSet = 0,
    styleDirLeftToRight = 1,
    styleDirRightToLeft = 2,
    styleDirInherit = 3,
    Max = 2147483647,
};
pub const styleDirNotSet = styleDir.styleDirNotSet;
pub const styleDirLeftToRight = styleDir.styleDirLeftToRight;
pub const styleDirRightToLeft = styleDir.styleDirRightToLeft;
pub const styleDirInherit = styleDir.styleDirInherit;
pub const styleDir_Max = styleDir.Max;

pub const styleBidi = extern enum(i32) {
    styleBidiNotSet = 0,
    styleBidiNormal = 1,
    styleBidiEmbed = 2,
    styleBidiOverride = 3,
    styleBidiInherit = 4,
    Max = 2147483647,
};
pub const styleBidiNotSet = styleBidi.styleBidiNotSet;
pub const styleBidiNormal = styleBidi.styleBidiNormal;
pub const styleBidiEmbed = styleBidi.styleBidiEmbed;
pub const styleBidiOverride = styleBidi.styleBidiOverride;
pub const styleBidiInherit = styleBidi.styleBidiInherit;
pub const styleBidi_Max = styleBidi.Max;

pub const styleImeMode = extern enum(i32) {
    styleImeModeAuto = 0,
    styleImeModeActive = 1,
    styleImeModeInactive = 2,
    styleImeModeDisabled = 3,
    styleImeModeNotSet = 4,
    Max = 2147483647,
};
pub const styleImeModeAuto = styleImeMode.styleImeModeAuto;
pub const styleImeModeActive = styleImeMode.styleImeModeActive;
pub const styleImeModeInactive = styleImeMode.styleImeModeInactive;
pub const styleImeModeDisabled = styleImeMode.styleImeModeDisabled;
pub const styleImeModeNotSet = styleImeMode.styleImeModeNotSet;
pub const styleImeMode_Max = styleImeMode.Max;

pub const styleRubyAlign = extern enum(i32) {
    styleRubyAlignNotSet = 0,
    styleRubyAlignAuto = 1,
    styleRubyAlignLeft = 2,
    styleRubyAlignCenter = 3,
    styleRubyAlignRight = 4,
    styleRubyAlignDistributeLetter = 5,
    styleRubyAlignDistributeSpace = 6,
    styleRubyAlignLineEdge = 7,
    Max = 2147483647,
};
pub const styleRubyAlignNotSet = styleRubyAlign.styleRubyAlignNotSet;
pub const styleRubyAlignAuto = styleRubyAlign.styleRubyAlignAuto;
pub const styleRubyAlignLeft = styleRubyAlign.styleRubyAlignLeft;
pub const styleRubyAlignCenter = styleRubyAlign.styleRubyAlignCenter;
pub const styleRubyAlignRight = styleRubyAlign.styleRubyAlignRight;
pub const styleRubyAlignDistributeLetter = styleRubyAlign.styleRubyAlignDistributeLetter;
pub const styleRubyAlignDistributeSpace = styleRubyAlign.styleRubyAlignDistributeSpace;
pub const styleRubyAlignLineEdge = styleRubyAlign.styleRubyAlignLineEdge;
pub const styleRubyAlign_Max = styleRubyAlign.Max;

pub const styleRubyPosition = extern enum(i32) {
    styleRubyPositionNotSet = 0,
    styleRubyPositionAbove = 1,
    styleRubyPositionInline = 2,
    Max = 2147483647,
};
pub const styleRubyPositionNotSet = styleRubyPosition.styleRubyPositionNotSet;
pub const styleRubyPositionAbove = styleRubyPosition.styleRubyPositionAbove;
pub const styleRubyPositionInline = styleRubyPosition.styleRubyPositionInline;
pub const styleRubyPosition_Max = styleRubyPosition.Max;

pub const styleRubyOverhang = extern enum(i32) {
    styleRubyOverhangNotSet = 0,
    styleRubyOverhangAuto = 1,
    styleRubyOverhangWhitespace = 2,
    styleRubyOverhangNone = 3,
    Max = 2147483647,
};
pub const styleRubyOverhangNotSet = styleRubyOverhang.styleRubyOverhangNotSet;
pub const styleRubyOverhangAuto = styleRubyOverhang.styleRubyOverhangAuto;
pub const styleRubyOverhangWhitespace = styleRubyOverhang.styleRubyOverhangWhitespace;
pub const styleRubyOverhangNone = styleRubyOverhang.styleRubyOverhangNone;
pub const styleRubyOverhang_Max = styleRubyOverhang.Max;

pub const styleLayoutGridChar = extern enum(i32) {
    styleLayoutGridCharNotSet = 0,
    styleLayoutGridCharAuto = 1,
    styleLayoutGridCharNone = 2,
    Max = 2147483647,
};
pub const styleLayoutGridCharNotSet = styleLayoutGridChar.styleLayoutGridCharNotSet;
pub const styleLayoutGridCharAuto = styleLayoutGridChar.styleLayoutGridCharAuto;
pub const styleLayoutGridCharNone = styleLayoutGridChar.styleLayoutGridCharNone;
pub const styleLayoutGridChar_Max = styleLayoutGridChar.Max;

pub const styleLayoutGridLine = extern enum(i32) {
    styleLayoutGridLineNotSet = 0,
    styleLayoutGridLineAuto = 1,
    styleLayoutGridLineNone = 2,
    Max = 2147483647,
};
pub const styleLayoutGridLineNotSet = styleLayoutGridLine.styleLayoutGridLineNotSet;
pub const styleLayoutGridLineAuto = styleLayoutGridLine.styleLayoutGridLineAuto;
pub const styleLayoutGridLineNone = styleLayoutGridLine.styleLayoutGridLineNone;
pub const styleLayoutGridLine_Max = styleLayoutGridLine.Max;

pub const styleLayoutGridMode = extern enum(i32) {
    styleLayoutGridModeNotSet = 0,
    styleLayoutGridModeChar = 1,
    styleLayoutGridModeLine = 2,
    styleLayoutGridModeBoth = 3,
    styleLayoutGridModeNone = 4,
    Max = 2147483647,
};
pub const styleLayoutGridModeNotSet = styleLayoutGridMode.styleLayoutGridModeNotSet;
pub const styleLayoutGridModeChar = styleLayoutGridMode.styleLayoutGridModeChar;
pub const styleLayoutGridModeLine = styleLayoutGridMode.styleLayoutGridModeLine;
pub const styleLayoutGridModeBoth = styleLayoutGridMode.styleLayoutGridModeBoth;
pub const styleLayoutGridModeNone = styleLayoutGridMode.styleLayoutGridModeNone;
pub const styleLayoutGridMode_Max = styleLayoutGridMode.Max;

pub const styleLayoutGridType = extern enum(i32) {
    styleLayoutGridTypeNotSet = 0,
    styleLayoutGridTypeLoose = 1,
    styleLayoutGridTypeStrict = 2,
    styleLayoutGridTypeFixed = 3,
    Max = 2147483647,
};
pub const styleLayoutGridTypeNotSet = styleLayoutGridType.styleLayoutGridTypeNotSet;
pub const styleLayoutGridTypeLoose = styleLayoutGridType.styleLayoutGridTypeLoose;
pub const styleLayoutGridTypeStrict = styleLayoutGridType.styleLayoutGridTypeStrict;
pub const styleLayoutGridTypeFixed = styleLayoutGridType.styleLayoutGridTypeFixed;
pub const styleLayoutGridType_Max = styleLayoutGridType.Max;

pub const styleLineBreak = extern enum(i32) {
    styleLineBreakNotSet = 0,
    styleLineBreakNormal = 1,
    styleLineBreakStrict = 2,
    Max = 2147483647,
};
pub const styleLineBreakNotSet = styleLineBreak.styleLineBreakNotSet;
pub const styleLineBreakNormal = styleLineBreak.styleLineBreakNormal;
pub const styleLineBreakStrict = styleLineBreak.styleLineBreakStrict;
pub const styleLineBreak_Max = styleLineBreak.Max;

pub const styleWordBreak = extern enum(i32) {
    styleWordBreakNotSet = 0,
    styleWordBreakNormal = 1,
    styleWordBreakBreakAll = 2,
    styleWordBreakKeepAll = 3,
    Max = 2147483647,
};
pub const styleWordBreakNotSet = styleWordBreak.styleWordBreakNotSet;
pub const styleWordBreakNormal = styleWordBreak.styleWordBreakNormal;
pub const styleWordBreakBreakAll = styleWordBreak.styleWordBreakBreakAll;
pub const styleWordBreakKeepAll = styleWordBreak.styleWordBreakKeepAll;
pub const styleWordBreak_Max = styleWordBreak.Max;

pub const styleWordWrap = extern enum(i32) {
    styleWordWrapNotSet = 0,
    styleWordWrapOff = 1,
    styleWordWrapOn = 2,
    Max = 2147483647,
};
pub const styleWordWrapNotSet = styleWordWrap.styleWordWrapNotSet;
pub const styleWordWrapOff = styleWordWrap.styleWordWrapOff;
pub const styleWordWrapOn = styleWordWrap.styleWordWrapOn;
pub const styleWordWrap_Max = styleWordWrap.Max;

pub const styleTextJustify = extern enum(i32) {
    styleTextJustifyNotSet = 0,
    styleTextJustifyInterWord = 1,
    styleTextJustifyNewspaper = 2,
    styleTextJustifyDistribute = 3,
    styleTextJustifyDistributeAllLines = 4,
    styleTextJustifyInterIdeograph = 5,
    styleTextJustifyInterCluster = 6,
    styleTextJustifyKashida = 7,
    styleTextJustifyAuto = 8,
    Max = 2147483647,
};
pub const styleTextJustifyNotSet = styleTextJustify.styleTextJustifyNotSet;
pub const styleTextJustifyInterWord = styleTextJustify.styleTextJustifyInterWord;
pub const styleTextJustifyNewspaper = styleTextJustify.styleTextJustifyNewspaper;
pub const styleTextJustifyDistribute = styleTextJustify.styleTextJustifyDistribute;
pub const styleTextJustifyDistributeAllLines = styleTextJustify.styleTextJustifyDistributeAllLines;
pub const styleTextJustifyInterIdeograph = styleTextJustify.styleTextJustifyInterIdeograph;
pub const styleTextJustifyInterCluster = styleTextJustify.styleTextJustifyInterCluster;
pub const styleTextJustifyKashida = styleTextJustify.styleTextJustifyKashida;
pub const styleTextJustifyAuto = styleTextJustify.styleTextJustifyAuto;
pub const styleTextJustify_Max = styleTextJustify.Max;

pub const styleTextAlignLast = extern enum(i32) {
    styleTextAlignLastNotSet = 0,
    styleTextAlignLastLeft = 1,
    styleTextAlignLastCenter = 2,
    styleTextAlignLastRight = 3,
    styleTextAlignLastJustify = 4,
    styleTextAlignLastAuto = 5,
    Max = 2147483647,
};
pub const styleTextAlignLastNotSet = styleTextAlignLast.styleTextAlignLastNotSet;
pub const styleTextAlignLastLeft = styleTextAlignLast.styleTextAlignLastLeft;
pub const styleTextAlignLastCenter = styleTextAlignLast.styleTextAlignLastCenter;
pub const styleTextAlignLastRight = styleTextAlignLast.styleTextAlignLastRight;
pub const styleTextAlignLastJustify = styleTextAlignLast.styleTextAlignLastJustify;
pub const styleTextAlignLastAuto = styleTextAlignLast.styleTextAlignLastAuto;
pub const styleTextAlignLast_Max = styleTextAlignLast.Max;

pub const styleTextJustifyTrim = extern enum(i32) {
    styleTextJustifyTrimNotSet = 0,
    styleTextJustifyTrimNone = 1,
    styleTextJustifyTrimPunctuation = 2,
    styleTextJustifyTrimPunctAndKana = 3,
    Max = 2147483647,
};
pub const styleTextJustifyTrimNotSet = styleTextJustifyTrim.styleTextJustifyTrimNotSet;
pub const styleTextJustifyTrimNone = styleTextJustifyTrim.styleTextJustifyTrimNone;
pub const styleTextJustifyTrimPunctuation = styleTextJustifyTrim.styleTextJustifyTrimPunctuation;
pub const styleTextJustifyTrimPunctAndKana = styleTextJustifyTrim.styleTextJustifyTrimPunctAndKana;
pub const styleTextJustifyTrim_Max = styleTextJustifyTrim.Max;

pub const styleAccelerator = extern enum(i32) {
    styleAcceleratorFalse = 0,
    styleAcceleratorTrue = 1,
    Max = 2147483647,
};
pub const styleAcceleratorFalse = styleAccelerator.styleAcceleratorFalse;
pub const styleAcceleratorTrue = styleAccelerator.styleAcceleratorTrue;
pub const styleAccelerator_Max = styleAccelerator.Max;

pub const styleLayoutFlow = extern enum(i32) {
    styleLayoutFlowHorizontal = 0,
    styleLayoutFlowVerticalIdeographic = 1,
    styleLayoutFlowNotSet = 2,
    Max = 2147483647,
};
pub const styleLayoutFlowHorizontal = styleLayoutFlow.styleLayoutFlowHorizontal;
pub const styleLayoutFlowVerticalIdeographic = styleLayoutFlow.styleLayoutFlowVerticalIdeographic;
pub const styleLayoutFlowNotSet = styleLayoutFlow.styleLayoutFlowNotSet;
pub const styleLayoutFlow_Max = styleLayoutFlow.Max;

pub const styleBlockProgression = extern enum(i32) {
    styleBlockProgressionTb = 0,
    styleBlockProgressionRl = 1,
    styleBlockProgressionBt = 2,
    styleBlockProgressionLr = 3,
    styleBlockProgressionNotSet = 4,
    Max = 2147483647,
};
pub const styleBlockProgressionTb = styleBlockProgression.styleBlockProgressionTb;
pub const styleBlockProgressionRl = styleBlockProgression.styleBlockProgressionRl;
pub const styleBlockProgressionBt = styleBlockProgression.styleBlockProgressionBt;
pub const styleBlockProgressionLr = styleBlockProgression.styleBlockProgressionLr;
pub const styleBlockProgressionNotSet = styleBlockProgression.styleBlockProgressionNotSet;
pub const styleBlockProgression_Max = styleBlockProgression.Max;

pub const styleWritingMode = extern enum(i32) {
    styleWritingModeLrtb = 0,
    styleWritingModeTbrl = 1,
    styleWritingModeRltb = 2,
    styleWritingModeBtrl = 3,
    styleWritingModeNotSet = 4,
    styleWritingModeTblr = 5,
    styleWritingModeBtlr = 6,
    styleWritingModeLrbt = 7,
    styleWritingModeRlbt = 8,
    styleWritingModeLr = 9,
    styleWritingModeRl = 10,
    styleWritingModeTb = 11,
    Max = 2147483647,
};
pub const styleWritingModeLrtb = styleWritingMode.styleWritingModeLrtb;
pub const styleWritingModeTbrl = styleWritingMode.styleWritingModeTbrl;
pub const styleWritingModeRltb = styleWritingMode.styleWritingModeRltb;
pub const styleWritingModeBtrl = styleWritingMode.styleWritingModeBtrl;
pub const styleWritingModeNotSet = styleWritingMode.styleWritingModeNotSet;
pub const styleWritingModeTblr = styleWritingMode.styleWritingModeTblr;
pub const styleWritingModeBtlr = styleWritingMode.styleWritingModeBtlr;
pub const styleWritingModeLrbt = styleWritingMode.styleWritingModeLrbt;
pub const styleWritingModeRlbt = styleWritingMode.styleWritingModeRlbt;
pub const styleWritingModeLr = styleWritingMode.styleWritingModeLr;
pub const styleWritingModeRl = styleWritingMode.styleWritingModeRl;
pub const styleWritingModeTb = styleWritingMode.styleWritingModeTb;
pub const styleWritingMode_Max = styleWritingMode.Max;

pub const styleBool = extern enum(i32) {
    styleBoolFalse = 0,
    styleBoolTrue = 1,
    Max = 2147483647,
};
pub const styleBoolFalse = styleBool.styleBoolFalse;
pub const styleBoolTrue = styleBool.styleBoolTrue;
pub const styleBool_Max = styleBool.Max;

pub const styleTextUnderlinePosition = extern enum(i32) {
    styleTextUnderlinePositionBelow = 0,
    styleTextUnderlinePositionAbove = 1,
    styleTextUnderlinePositionAuto = 2,
    styleTextUnderlinePositionNotSet = 3,
    Max = 2147483647,
};
pub const styleTextUnderlinePositionBelow = styleTextUnderlinePosition.styleTextUnderlinePositionBelow;
pub const styleTextUnderlinePositionAbove = styleTextUnderlinePosition.styleTextUnderlinePositionAbove;
pub const styleTextUnderlinePositionAuto = styleTextUnderlinePosition.styleTextUnderlinePositionAuto;
pub const styleTextUnderlinePositionNotSet = styleTextUnderlinePosition.styleTextUnderlinePositionNotSet;
pub const styleTextUnderlinePosition_Max = styleTextUnderlinePosition.Max;

pub const styleTextOverflow = extern enum(i32) {
    styleTextOverflowClip = 0,
    styleTextOverflowEllipsis = 1,
    styleTextOverflowNotSet = 2,
    Max = 2147483647,
};
pub const styleTextOverflowClip = styleTextOverflow.styleTextOverflowClip;
pub const styleTextOverflowEllipsis = styleTextOverflow.styleTextOverflowEllipsis;
pub const styleTextOverflowNotSet = styleTextOverflow.styleTextOverflowNotSet;
pub const styleTextOverflow_Max = styleTextOverflow.Max;

pub const styleInterpolation = extern enum(i32) {
    styleInterpolationNotSet = 0,
    styleInterpolationNN = 1,
    styleInterpolationBCH = 2,
    Max = 2147483647,
};
pub const styleInterpolationNotSet = styleInterpolation.styleInterpolationNotSet;
pub const styleInterpolationNN = styleInterpolation.styleInterpolationNN;
pub const styleInterpolationBCH = styleInterpolation.styleInterpolationBCH;
pub const styleInterpolation_Max = styleInterpolation.Max;

pub const styleBoxSizing = extern enum(i32) {
    styleBoxSizingNotSet = 0,
    styleBoxSizingContentBox = 1,
    styleBoxSizingBorderBox = 2,
    Max = 2147483647,
};
pub const styleBoxSizingNotSet = styleBoxSizing.styleBoxSizingNotSet;
pub const styleBoxSizingContentBox = styleBoxSizing.styleBoxSizingContentBox;
pub const styleBoxSizingBorderBox = styleBoxSizing.styleBoxSizingBorderBox;
pub const styleBoxSizing_Max = styleBoxSizing.Max;

pub const styleFlex = extern enum(i32) {
    styleFlexNone = 0,
    styleFlexNotSet = 1,
    Max = 2147483647,
};
pub const styleFlexNone = styleFlex.styleFlexNone;
pub const styleFlexNotSet = styleFlex.styleFlexNotSet;
pub const styleFlex_Max = styleFlex.Max;

pub const styleFlexBasis = extern enum(i32) {
    styleFlexBasisAuto = 0,
    styleFlexBasisNotSet = 1,
    Max = 2147483647,
};
pub const styleFlexBasisAuto = styleFlexBasis.styleFlexBasisAuto;
pub const styleFlexBasisNotSet = styleFlexBasis.styleFlexBasisNotSet;
pub const styleFlexBasis_Max = styleFlexBasis.Max;

pub const styleFlexDirection = extern enum(i32) {
    styleFlexDirectionRow = 0,
    styleFlexDirectionRowReverse = 1,
    styleFlexDirectionColumn = 2,
    styleFlexDirectionColumnReverse = 3,
    styleFlexDirectionNotSet = 4,
    Max = 2147483647,
};
pub const styleFlexDirectionRow = styleFlexDirection.styleFlexDirectionRow;
pub const styleFlexDirectionRowReverse = styleFlexDirection.styleFlexDirectionRowReverse;
pub const styleFlexDirectionColumn = styleFlexDirection.styleFlexDirectionColumn;
pub const styleFlexDirectionColumnReverse = styleFlexDirection.styleFlexDirectionColumnReverse;
pub const styleFlexDirectionNotSet = styleFlexDirection.styleFlexDirectionNotSet;
pub const styleFlexDirection_Max = styleFlexDirection.Max;

pub const styleWebkitBoxOrient = extern enum(i32) {
    styleWebkitBoxOrientHorizontal = 0,
    styleWebkitBoxOrientInlineAxis = 1,
    styleWebkitBoxOrientVertical = 2,
    styleWebkitBoxOrientBlockAxis = 3,
    styleWebkitBoxOrientNotSet = 4,
    Max = 2147483647,
};
pub const styleWebkitBoxOrientHorizontal = styleWebkitBoxOrient.styleWebkitBoxOrientHorizontal;
pub const styleWebkitBoxOrientInlineAxis = styleWebkitBoxOrient.styleWebkitBoxOrientInlineAxis;
pub const styleWebkitBoxOrientVertical = styleWebkitBoxOrient.styleWebkitBoxOrientVertical;
pub const styleWebkitBoxOrientBlockAxis = styleWebkitBoxOrient.styleWebkitBoxOrientBlockAxis;
pub const styleWebkitBoxOrientNotSet = styleWebkitBoxOrient.styleWebkitBoxOrientNotSet;
pub const styleWebkitBoxOrient_Max = styleWebkitBoxOrient.Max;

pub const styleWebkitBoxDirection = extern enum(i32) {
    styleWebkitBoxDirectionNormal = 0,
    styleWebkitBoxDirectionReverse = 1,
    styleWebkitBoxDirectionNotSet = 2,
    Max = 2147483647,
};
pub const styleWebkitBoxDirectionNormal = styleWebkitBoxDirection.styleWebkitBoxDirectionNormal;
pub const styleWebkitBoxDirectionReverse = styleWebkitBoxDirection.styleWebkitBoxDirectionReverse;
pub const styleWebkitBoxDirectionNotSet = styleWebkitBoxDirection.styleWebkitBoxDirectionNotSet;
pub const styleWebkitBoxDirection_Max = styleWebkitBoxDirection.Max;

pub const styleFlexWrap = extern enum(i32) {
    styleFlexWrapNowrap = 0,
    styleFlexWrapWrap = 1,
    styleFlexWrapWrapReverse = 2,
    styleFlexWrapNotSet = 3,
    Max = 2147483647,
};
pub const styleFlexWrapNowrap = styleFlexWrap.styleFlexWrapNowrap;
pub const styleFlexWrapWrap = styleFlexWrap.styleFlexWrapWrap;
pub const styleFlexWrapWrapReverse = styleFlexWrap.styleFlexWrapWrapReverse;
pub const styleFlexWrapNotSet = styleFlexWrap.styleFlexWrapNotSet;
pub const styleFlexWrap_Max = styleFlexWrap.Max;

pub const styleAlignItems = extern enum(i32) {
    styleAlignItemsFlexStart = 0,
    styleAlignItemsFlexEnd = 1,
    styleAlignItemsCenter = 2,
    styleAlignItemsBaseline = 3,
    styleAlignItemsStretch = 4,
    styleAlignItemsNotSet = 5,
    Max = 2147483647,
};
pub const styleAlignItemsFlexStart = styleAlignItems.styleAlignItemsFlexStart;
pub const styleAlignItemsFlexEnd = styleAlignItems.styleAlignItemsFlexEnd;
pub const styleAlignItemsCenter = styleAlignItems.styleAlignItemsCenter;
pub const styleAlignItemsBaseline = styleAlignItems.styleAlignItemsBaseline;
pub const styleAlignItemsStretch = styleAlignItems.styleAlignItemsStretch;
pub const styleAlignItemsNotSet = styleAlignItems.styleAlignItemsNotSet;
pub const styleAlignItems_Max = styleAlignItems.Max;

pub const styleMsFlexAlign = extern enum(i32) {
    styleMsFlexAlignStart = 0,
    styleMsFlexAlignEnd = 1,
    styleMsFlexAlignCenter = 2,
    styleMsFlexAlignBaseline = 3,
    styleMsFlexAlignStretch = 4,
    styleMsFlexAlignNotSet = 5,
    Max = 2147483647,
};
pub const styleMsFlexAlignStart = styleMsFlexAlign.styleMsFlexAlignStart;
pub const styleMsFlexAlignEnd = styleMsFlexAlign.styleMsFlexAlignEnd;
pub const styleMsFlexAlignCenter = styleMsFlexAlign.styleMsFlexAlignCenter;
pub const styleMsFlexAlignBaseline = styleMsFlexAlign.styleMsFlexAlignBaseline;
pub const styleMsFlexAlignStretch = styleMsFlexAlign.styleMsFlexAlignStretch;
pub const styleMsFlexAlignNotSet = styleMsFlexAlign.styleMsFlexAlignNotSet;
pub const styleMsFlexAlign_Max = styleMsFlexAlign.Max;

pub const styleMsFlexItemAlign = extern enum(i32) {
    styleMsFlexItemAlignStart = 0,
    styleMsFlexItemAlignEnd = 1,
    styleMsFlexItemAlignCenter = 2,
    styleMsFlexItemAlignBaseline = 3,
    styleMsFlexItemAlignStretch = 4,
    styleMsFlexItemAlignAuto = 5,
    styleMsFlexItemAlignNotSet = 6,
    Max = 2147483647,
};
pub const styleMsFlexItemAlignStart = styleMsFlexItemAlign.styleMsFlexItemAlignStart;
pub const styleMsFlexItemAlignEnd = styleMsFlexItemAlign.styleMsFlexItemAlignEnd;
pub const styleMsFlexItemAlignCenter = styleMsFlexItemAlign.styleMsFlexItemAlignCenter;
pub const styleMsFlexItemAlignBaseline = styleMsFlexItemAlign.styleMsFlexItemAlignBaseline;
pub const styleMsFlexItemAlignStretch = styleMsFlexItemAlign.styleMsFlexItemAlignStretch;
pub const styleMsFlexItemAlignAuto = styleMsFlexItemAlign.styleMsFlexItemAlignAuto;
pub const styleMsFlexItemAlignNotSet = styleMsFlexItemAlign.styleMsFlexItemAlignNotSet;
pub const styleMsFlexItemAlign_Max = styleMsFlexItemAlign.Max;

pub const styleAlignSelf = extern enum(i32) {
    styleAlignSelfFlexStart = 0,
    styleAlignSelfFlexEnd = 1,
    styleAlignSelfCenter = 2,
    styleAlignSelfBaseline = 3,
    styleAlignSelfStretch = 4,
    styleAlignSelfAuto = 5,
    styleAlignSelfNotSet = 6,
    Max = 2147483647,
};
pub const styleAlignSelfFlexStart = styleAlignSelf.styleAlignSelfFlexStart;
pub const styleAlignSelfFlexEnd = styleAlignSelf.styleAlignSelfFlexEnd;
pub const styleAlignSelfCenter = styleAlignSelf.styleAlignSelfCenter;
pub const styleAlignSelfBaseline = styleAlignSelf.styleAlignSelfBaseline;
pub const styleAlignSelfStretch = styleAlignSelf.styleAlignSelfStretch;
pub const styleAlignSelfAuto = styleAlignSelf.styleAlignSelfAuto;
pub const styleAlignSelfNotSet = styleAlignSelf.styleAlignSelfNotSet;
pub const styleAlignSelf_Max = styleAlignSelf.Max;

pub const styleJustifyContent = extern enum(i32) {
    styleJustifyContentFlexStart = 0,
    styleJustifyContentFlexEnd = 1,
    styleJustifyContentCenter = 2,
    styleJustifyContentSpaceBetween = 3,
    styleJustifyContentSpaceAround = 4,
    styleJustifyContentNotSet = 5,
    Max = 2147483647,
};
pub const styleJustifyContentFlexStart = styleJustifyContent.styleJustifyContentFlexStart;
pub const styleJustifyContentFlexEnd = styleJustifyContent.styleJustifyContentFlexEnd;
pub const styleJustifyContentCenter = styleJustifyContent.styleJustifyContentCenter;
pub const styleJustifyContentSpaceBetween = styleJustifyContent.styleJustifyContentSpaceBetween;
pub const styleJustifyContentSpaceAround = styleJustifyContent.styleJustifyContentSpaceAround;
pub const styleJustifyContentNotSet = styleJustifyContent.styleJustifyContentNotSet;
pub const styleJustifyContent_Max = styleJustifyContent.Max;

pub const styleMsFlexPack = extern enum(i32) {
    styleMsFlexPackStart = 0,
    styleMsFlexPackEnd = 1,
    styleMsFlexPackCenter = 2,
    styleMsFlexPackJustify = 3,
    styleMsFlexPackDistribute = 4,
    styleMsFlexPackNotSet = 5,
    Max = 2147483647,
};
pub const styleMsFlexPackStart = styleMsFlexPack.styleMsFlexPackStart;
pub const styleMsFlexPackEnd = styleMsFlexPack.styleMsFlexPackEnd;
pub const styleMsFlexPackCenter = styleMsFlexPack.styleMsFlexPackCenter;
pub const styleMsFlexPackJustify = styleMsFlexPack.styleMsFlexPackJustify;
pub const styleMsFlexPackDistribute = styleMsFlexPack.styleMsFlexPackDistribute;
pub const styleMsFlexPackNotSet = styleMsFlexPack.styleMsFlexPackNotSet;
pub const styleMsFlexPack_Max = styleMsFlexPack.Max;

pub const styleWebkitBoxPack = extern enum(i32) {
    styleWebkitBoxPackStart = 0,
    styleWebkitBoxPackEnd = 1,
    styleWebkitBoxPackCenter = 2,
    styleWebkitBoxPackJustify = 3,
    styleWebkitBoxPackNotSet = 5,
    Max = 2147483647,
};
pub const styleWebkitBoxPackStart = styleWebkitBoxPack.styleWebkitBoxPackStart;
pub const styleWebkitBoxPackEnd = styleWebkitBoxPack.styleWebkitBoxPackEnd;
pub const styleWebkitBoxPackCenter = styleWebkitBoxPack.styleWebkitBoxPackCenter;
pub const styleWebkitBoxPackJustify = styleWebkitBoxPack.styleWebkitBoxPackJustify;
pub const styleWebkitBoxPackNotSet = styleWebkitBoxPack.styleWebkitBoxPackNotSet;
pub const styleWebkitBoxPack_Max = styleWebkitBoxPack.Max;

pub const styleMsFlexLinePack = extern enum(i32) {
    styleMsFlexLinePackStart = 0,
    styleMsFlexLinePackEnd = 1,
    styleMsFlexLinePackCenter = 2,
    styleMsFlexLinePackJustify = 3,
    styleMsFlexLinePackDistribute = 4,
    styleMsFlexLinePackStretch = 5,
    styleMsFlexLinePackNotSet = 6,
    Max = 2147483647,
};
pub const styleMsFlexLinePackStart = styleMsFlexLinePack.styleMsFlexLinePackStart;
pub const styleMsFlexLinePackEnd = styleMsFlexLinePack.styleMsFlexLinePackEnd;
pub const styleMsFlexLinePackCenter = styleMsFlexLinePack.styleMsFlexLinePackCenter;
pub const styleMsFlexLinePackJustify = styleMsFlexLinePack.styleMsFlexLinePackJustify;
pub const styleMsFlexLinePackDistribute = styleMsFlexLinePack.styleMsFlexLinePackDistribute;
pub const styleMsFlexLinePackStretch = styleMsFlexLinePack.styleMsFlexLinePackStretch;
pub const styleMsFlexLinePackNotSet = styleMsFlexLinePack.styleMsFlexLinePackNotSet;
pub const styleMsFlexLinePack_Max = styleMsFlexLinePack.Max;

pub const styleAlignContent = extern enum(i32) {
    styleAlignContentFlexStart = 0,
    styleAlignContentFlexEnd = 1,
    styleAlignContentCenter = 2,
    styleAlignContentSpaceBetween = 3,
    styleAlignContentSpaceAround = 4,
    styleAlignContentStretch = 5,
    styleAlignContentNotSet = 6,
    Max = 2147483647,
};
pub const styleAlignContentFlexStart = styleAlignContent.styleAlignContentFlexStart;
pub const styleAlignContentFlexEnd = styleAlignContent.styleAlignContentFlexEnd;
pub const styleAlignContentCenter = styleAlignContent.styleAlignContentCenter;
pub const styleAlignContentSpaceBetween = styleAlignContent.styleAlignContentSpaceBetween;
pub const styleAlignContentSpaceAround = styleAlignContent.styleAlignContentSpaceAround;
pub const styleAlignContentStretch = styleAlignContent.styleAlignContentStretch;
pub const styleAlignContentNotSet = styleAlignContent.styleAlignContentNotSet;
pub const styleAlignContent_Max = styleAlignContent.Max;

pub const styleColumnFill = extern enum(i32) {
    styleColumnFillAuto = 0,
    styleColumnFillBalance = 1,
    styleColumnFillNotSet = 2,
    Max = 2147483647,
};
pub const styleColumnFillAuto = styleColumnFill.styleColumnFillAuto;
pub const styleColumnFillBalance = styleColumnFill.styleColumnFillBalance;
pub const styleColumnFillNotSet = styleColumnFill.styleColumnFillNotSet;
pub const styleColumnFill_Max = styleColumnFill.Max;

pub const styleColumnSpan = extern enum(i32) {
    styleColumnSpanNone = 0,
    styleColumnSpanAll = 1,
    styleColumnSpanOne = 2,
    styleColumnSpanNotSet = 3,
    Max = 2147483647,
};
pub const styleColumnSpanNone = styleColumnSpan.styleColumnSpanNone;
pub const styleColumnSpanAll = styleColumnSpan.styleColumnSpanAll;
pub const styleColumnSpanOne = styleColumnSpan.styleColumnSpanOne;
pub const styleColumnSpanNotSet = styleColumnSpan.styleColumnSpanNotSet;
pub const styleColumnSpan_Max = styleColumnSpan.Max;

pub const styleBreak = extern enum(i32) {
    styleBreakNotSet = 0,
    styleBreakAuto = 1,
    styleBreakAlways = 2,
    styleBreakAvoid = 3,
    styleBreakLeft = 4,
    styleBreakRight = 5,
    styleBreakPage = 6,
    styleBreakColumn = 7,
    styleBreakAvoidPage = 8,
    styleBreakAvoidColumn = 9,
    Max = 2147483647,
};
pub const styleBreakNotSet = styleBreak.styleBreakNotSet;
pub const styleBreakAuto = styleBreak.styleBreakAuto;
pub const styleBreakAlways = styleBreak.styleBreakAlways;
pub const styleBreakAvoid = styleBreak.styleBreakAvoid;
pub const styleBreakLeft = styleBreak.styleBreakLeft;
pub const styleBreakRight = styleBreak.styleBreakRight;
pub const styleBreakPage = styleBreak.styleBreakPage;
pub const styleBreakColumn = styleBreak.styleBreakColumn;
pub const styleBreakAvoidPage = styleBreak.styleBreakAvoidPage;
pub const styleBreakAvoidColumn = styleBreak.styleBreakAvoidColumn;
pub const styleBreak_Max = styleBreak.Max;

pub const styleBreakInside = extern enum(i32) {
    styleBreakInsideNotSet = 0,
    styleBreakInsideAuto = 1,
    styleBreakInsideAvoid = 2,
    styleBreakInsideAvoidPage = 3,
    styleBreakInsideAvoidColumn = 4,
    Max = 2147483647,
};
pub const styleBreakInsideNotSet = styleBreakInside.styleBreakInsideNotSet;
pub const styleBreakInsideAuto = styleBreakInside.styleBreakInsideAuto;
pub const styleBreakInsideAvoid = styleBreakInside.styleBreakInsideAvoid;
pub const styleBreakInsideAvoidPage = styleBreakInside.styleBreakInsideAvoidPage;
pub const styleBreakInsideAvoidColumn = styleBreakInside.styleBreakInsideAvoidColumn;
pub const styleBreakInside_Max = styleBreakInside.Max;

pub const styleMsScrollChaining = extern enum(i32) {
    styleMsScrollChainingNotSet = 0,
    styleMsScrollChainingNone = 1,
    styleMsScrollChainingChained = 2,
    Max = 2147483647,
};
pub const styleMsScrollChainingNotSet = styleMsScrollChaining.styleMsScrollChainingNotSet;
pub const styleMsScrollChainingNone = styleMsScrollChaining.styleMsScrollChainingNone;
pub const styleMsScrollChainingChained = styleMsScrollChaining.styleMsScrollChainingChained;
pub const styleMsScrollChaining_Max = styleMsScrollChaining.Max;

pub const styleMsContentZooming = extern enum(i32) {
    styleMsContentZoomingNotSet = 0,
    styleMsContentZoomingNone = 1,
    styleMsContentZoomingZoom = 2,
    Max = 2147483647,
};
pub const styleMsContentZoomingNotSet = styleMsContentZooming.styleMsContentZoomingNotSet;
pub const styleMsContentZoomingNone = styleMsContentZooming.styleMsContentZoomingNone;
pub const styleMsContentZoomingZoom = styleMsContentZooming.styleMsContentZoomingZoom;
pub const styleMsContentZooming_Max = styleMsContentZooming.Max;

pub const styleMsContentZoomSnapType = extern enum(i32) {
    styleMsContentZoomSnapTypeNotSet = 0,
    styleMsContentZoomSnapTypeNone = 1,
    styleMsContentZoomSnapTypeMandatory = 2,
    styleMsContentZoomSnapTypeProximity = 3,
    Max = 2147483647,
};
pub const styleMsContentZoomSnapTypeNotSet = styleMsContentZoomSnapType.styleMsContentZoomSnapTypeNotSet;
pub const styleMsContentZoomSnapTypeNone = styleMsContentZoomSnapType.styleMsContentZoomSnapTypeNone;
pub const styleMsContentZoomSnapTypeMandatory = styleMsContentZoomSnapType.styleMsContentZoomSnapTypeMandatory;
pub const styleMsContentZoomSnapTypeProximity = styleMsContentZoomSnapType.styleMsContentZoomSnapTypeProximity;
pub const styleMsContentZoomSnapType_Max = styleMsContentZoomSnapType.Max;

pub const styleMsScrollRails = extern enum(i32) {
    styleMsScrollRailsNotSet = 0,
    styleMsScrollRailsNone = 1,
    styleMsScrollRailsRailed = 2,
    Max = 2147483647,
};
pub const styleMsScrollRailsNotSet = styleMsScrollRails.styleMsScrollRailsNotSet;
pub const styleMsScrollRailsNone = styleMsScrollRails.styleMsScrollRailsNone;
pub const styleMsScrollRailsRailed = styleMsScrollRails.styleMsScrollRailsRailed;
pub const styleMsScrollRails_Max = styleMsScrollRails.Max;

pub const styleMsContentZoomChaining = extern enum(i32) {
    styleMsContentZoomChainingNotSet = 0,
    styleMsContentZoomChainingNone = 1,
    styleMsContentZoomChainingChained = 2,
    Max = 2147483647,
};
pub const styleMsContentZoomChainingNotSet = styleMsContentZoomChaining.styleMsContentZoomChainingNotSet;
pub const styleMsContentZoomChainingNone = styleMsContentZoomChaining.styleMsContentZoomChainingNone;
pub const styleMsContentZoomChainingChained = styleMsContentZoomChaining.styleMsContentZoomChainingChained;
pub const styleMsContentZoomChaining_Max = styleMsContentZoomChaining.Max;

pub const styleMsScrollSnapType = extern enum(i32) {
    styleMsScrollSnapTypeNotSet = 0,
    styleMsScrollSnapTypeNone = 1,
    styleMsScrollSnapTypeMandatory = 2,
    styleMsScrollSnapTypeProximity = 3,
    Max = 2147483647,
};
pub const styleMsScrollSnapTypeNotSet = styleMsScrollSnapType.styleMsScrollSnapTypeNotSet;
pub const styleMsScrollSnapTypeNone = styleMsScrollSnapType.styleMsScrollSnapTypeNone;
pub const styleMsScrollSnapTypeMandatory = styleMsScrollSnapType.styleMsScrollSnapTypeMandatory;
pub const styleMsScrollSnapTypeProximity = styleMsScrollSnapType.styleMsScrollSnapTypeProximity;
pub const styleMsScrollSnapType_Max = styleMsScrollSnapType.Max;

pub const styleGridColumn = extern enum(i32) {
    styleGridColumnNotSet = 0,
    Max = 2147483647,
};
pub const styleGridColumnNotSet = styleGridColumn.styleGridColumnNotSet;
pub const styleGridColumn_Max = styleGridColumn.Max;

pub const styleGridColumnAlign = extern enum(i32) {
    styleGridColumnAlignCenter = 0,
    styleGridColumnAlignEnd = 1,
    styleGridColumnAlignStart = 2,
    styleGridColumnAlignStretch = 3,
    styleGridColumnAlignNotSet = 4,
    Max = 2147483647,
};
pub const styleGridColumnAlignCenter = styleGridColumnAlign.styleGridColumnAlignCenter;
pub const styleGridColumnAlignEnd = styleGridColumnAlign.styleGridColumnAlignEnd;
pub const styleGridColumnAlignStart = styleGridColumnAlign.styleGridColumnAlignStart;
pub const styleGridColumnAlignStretch = styleGridColumnAlign.styleGridColumnAlignStretch;
pub const styleGridColumnAlignNotSet = styleGridColumnAlign.styleGridColumnAlignNotSet;
pub const styleGridColumnAlign_Max = styleGridColumnAlign.Max;

pub const styleGridColumnSpan = extern enum(i32) {
    styleGridColumnSpanNotSet = 0,
    Max = 2147483647,
};
pub const styleGridColumnSpanNotSet = styleGridColumnSpan.styleGridColumnSpanNotSet;
pub const styleGridColumnSpan_Max = styleGridColumnSpan.Max;

pub const styleGridRow = extern enum(i32) {
    styleGridRowNotSet = 0,
    Max = 2147483647,
};
pub const styleGridRowNotSet = styleGridRow.styleGridRowNotSet;
pub const styleGridRow_Max = styleGridRow.Max;

pub const styleGridRowAlign = extern enum(i32) {
    styleGridRowAlignCenter = 0,
    styleGridRowAlignEnd = 1,
    styleGridRowAlignStart = 2,
    styleGridRowAlignStretch = 3,
    styleGridRowAlignNotSet = 4,
    Max = 2147483647,
};
pub const styleGridRowAlignCenter = styleGridRowAlign.styleGridRowAlignCenter;
pub const styleGridRowAlignEnd = styleGridRowAlign.styleGridRowAlignEnd;
pub const styleGridRowAlignStart = styleGridRowAlign.styleGridRowAlignStart;
pub const styleGridRowAlignStretch = styleGridRowAlign.styleGridRowAlignStretch;
pub const styleGridRowAlignNotSet = styleGridRowAlign.styleGridRowAlignNotSet;
pub const styleGridRowAlign_Max = styleGridRowAlign.Max;

pub const styleGridRowSpan = extern enum(i32) {
    styleGridRowSpanNotSet = 0,
    Max = 2147483647,
};
pub const styleGridRowSpanNotSet = styleGridRowSpan.styleGridRowSpanNotSet;
pub const styleGridRowSpan_Max = styleGridRowSpan.Max;

pub const styleWrapThrough = extern enum(i32) {
    styleWrapThroughNotSet = 0,
    styleWrapThroughWrap = 1,
    styleWrapThroughNone = 2,
    Max = 2147483647,
};
pub const styleWrapThroughNotSet = styleWrapThrough.styleWrapThroughNotSet;
pub const styleWrapThroughWrap = styleWrapThrough.styleWrapThroughWrap;
pub const styleWrapThroughNone = styleWrapThrough.styleWrapThroughNone;
pub const styleWrapThrough_Max = styleWrapThrough.Max;

pub const styleWrapFlow = extern enum(i32) {
    styleWrapFlowNotSet = 0,
    styleWrapFlowAuto = 1,
    styleWrapFlowBoth = 2,
    styleWrapFlowStart = 3,
    styleWrapFlowEnd = 4,
    styleWrapFlowClear = 5,
    styleWrapFlowMinimum = 6,
    styleWrapFlowMaximum = 7,
    Max = 2147483647,
};
pub const styleWrapFlowNotSet = styleWrapFlow.styleWrapFlowNotSet;
pub const styleWrapFlowAuto = styleWrapFlow.styleWrapFlowAuto;
pub const styleWrapFlowBoth = styleWrapFlow.styleWrapFlowBoth;
pub const styleWrapFlowStart = styleWrapFlow.styleWrapFlowStart;
pub const styleWrapFlowEnd = styleWrapFlow.styleWrapFlowEnd;
pub const styleWrapFlowClear = styleWrapFlow.styleWrapFlowClear;
pub const styleWrapFlowMinimum = styleWrapFlow.styleWrapFlowMinimum;
pub const styleWrapFlowMaximum = styleWrapFlow.styleWrapFlowMaximum;
pub const styleWrapFlow_Max = styleWrapFlow.Max;

pub const styleAlignmentBaseline = extern enum(i32) {
    styleAlignmentBaselineNotSet = 0,
    styleAlignmentBaselineAfterEdge = 1,
    styleAlignmentBaselineAlphabetic = 2,
    styleAlignmentBaselineAuto = 3,
    styleAlignmentBaselineBaseline = 4,
    styleAlignmentBaselineBeforeEdge = 5,
    styleAlignmentBaselineCentral = 6,
    styleAlignmentBaselineHanging = 7,
    styleAlignmentBaselineMathematical = 8,
    styleAlignmentBaselineMiddle = 9,
    styleAlignmentBaselineTextAfterEdge = 10,
    styleAlignmentBaselineTextBeforeEdge = 11,
    styleAlignmentBaselineIdeographic = 12,
    Max = 2147483647,
};
pub const styleAlignmentBaselineNotSet = styleAlignmentBaseline.styleAlignmentBaselineNotSet;
pub const styleAlignmentBaselineAfterEdge = styleAlignmentBaseline.styleAlignmentBaselineAfterEdge;
pub const styleAlignmentBaselineAlphabetic = styleAlignmentBaseline.styleAlignmentBaselineAlphabetic;
pub const styleAlignmentBaselineAuto = styleAlignmentBaseline.styleAlignmentBaselineAuto;
pub const styleAlignmentBaselineBaseline = styleAlignmentBaseline.styleAlignmentBaselineBaseline;
pub const styleAlignmentBaselineBeforeEdge = styleAlignmentBaseline.styleAlignmentBaselineBeforeEdge;
pub const styleAlignmentBaselineCentral = styleAlignmentBaseline.styleAlignmentBaselineCentral;
pub const styleAlignmentBaselineHanging = styleAlignmentBaseline.styleAlignmentBaselineHanging;
pub const styleAlignmentBaselineMathematical = styleAlignmentBaseline.styleAlignmentBaselineMathematical;
pub const styleAlignmentBaselineMiddle = styleAlignmentBaseline.styleAlignmentBaselineMiddle;
pub const styleAlignmentBaselineTextAfterEdge = styleAlignmentBaseline.styleAlignmentBaselineTextAfterEdge;
pub const styleAlignmentBaselineTextBeforeEdge = styleAlignmentBaseline.styleAlignmentBaselineTextBeforeEdge;
pub const styleAlignmentBaselineIdeographic = styleAlignmentBaseline.styleAlignmentBaselineIdeographic;
pub const styleAlignmentBaseline_Max = styleAlignmentBaseline.Max;

pub const styleBaselineShift = extern enum(i32) {
    styleBaselineShiftBaseline = 0,
    styleBaselineShiftSub = 1,
    styleBaselineShiftSuper = 2,
    Max = 2147483647,
};
pub const styleBaselineShiftBaseline = styleBaselineShift.styleBaselineShiftBaseline;
pub const styleBaselineShiftSub = styleBaselineShift.styleBaselineShiftSub;
pub const styleBaselineShiftSuper = styleBaselineShift.styleBaselineShiftSuper;
pub const styleBaselineShift_Max = styleBaselineShift.Max;

pub const styleClipRule = extern enum(i32) {
    styleClipRuleNotSet = 0,
    styleClipRuleNonZero = 1,
    styleClipRuleEvenOdd = 2,
    Max = 2147483647,
};
pub const styleClipRuleNotSet = styleClipRule.styleClipRuleNotSet;
pub const styleClipRuleNonZero = styleClipRule.styleClipRuleNonZero;
pub const styleClipRuleEvenOdd = styleClipRule.styleClipRuleEvenOdd;
pub const styleClipRule_Max = styleClipRule.Max;

pub const styleDominantBaseline = extern enum(i32) {
    styleDominantBaselineNotSet = 0,
    styleDominantBaselineAlphabetic = 1,
    styleDominantBaselineAuto = 2,
    styleDominantBaselineCentral = 3,
    styleDominantBaselineHanging = 4,
    styleDominantBaselineIdeographic = 5,
    styleDominantBaselineMathematical = 6,
    styleDominantBaselineMiddle = 7,
    styleDominantBaselineNoChange = 8,
    styleDominantBaselineResetSize = 9,
    styleDominantBaselineTextAfterEdge = 10,
    styleDominantBaselineTextBeforeEdge = 11,
    styleDominantBaselineUseScript = 12,
    Max = 2147483647,
};
pub const styleDominantBaselineNotSet = styleDominantBaseline.styleDominantBaselineNotSet;
pub const styleDominantBaselineAlphabetic = styleDominantBaseline.styleDominantBaselineAlphabetic;
pub const styleDominantBaselineAuto = styleDominantBaseline.styleDominantBaselineAuto;
pub const styleDominantBaselineCentral = styleDominantBaseline.styleDominantBaselineCentral;
pub const styleDominantBaselineHanging = styleDominantBaseline.styleDominantBaselineHanging;
pub const styleDominantBaselineIdeographic = styleDominantBaseline.styleDominantBaselineIdeographic;
pub const styleDominantBaselineMathematical = styleDominantBaseline.styleDominantBaselineMathematical;
pub const styleDominantBaselineMiddle = styleDominantBaseline.styleDominantBaselineMiddle;
pub const styleDominantBaselineNoChange = styleDominantBaseline.styleDominantBaselineNoChange;
pub const styleDominantBaselineResetSize = styleDominantBaseline.styleDominantBaselineResetSize;
pub const styleDominantBaselineTextAfterEdge = styleDominantBaseline.styleDominantBaselineTextAfterEdge;
pub const styleDominantBaselineTextBeforeEdge = styleDominantBaseline.styleDominantBaselineTextBeforeEdge;
pub const styleDominantBaselineUseScript = styleDominantBaseline.styleDominantBaselineUseScript;
pub const styleDominantBaseline_Max = styleDominantBaseline.Max;

pub const styleFillRule = extern enum(i32) {
    styleFillRuleNotSet = 0,
    styleFillRuleNonZero = 1,
    styleFillRuleEvenOdd = 2,
    Max = 2147483647,
};
pub const styleFillRuleNotSet = styleFillRule.styleFillRuleNotSet;
pub const styleFillRuleNonZero = styleFillRule.styleFillRuleNonZero;
pub const styleFillRuleEvenOdd = styleFillRule.styleFillRuleEvenOdd;
pub const styleFillRule_Max = styleFillRule.Max;

pub const styleFontStretch = extern enum(i32) {
    styleFontStretchNotSet = 0,
    styleFontStretchWider = 1,
    styleFontStretchNarrower = 2,
    styleFontStretchUltraCondensed = 3,
    styleFontStretchExtraCondensed = 4,
    styleFontStretchCondensed = 5,
    styleFontStretchSemiCondensed = 6,
    styleFontStretchNormal = 7,
    styleFontStretchSemiExpanded = 8,
    styleFontStretchExpanded = 9,
    styleFontStretchExtraExpanded = 10,
    styleFontStretchUltraExpanded = 11,
    Max = 2147483647,
};
pub const styleFontStretchNotSet = styleFontStretch.styleFontStretchNotSet;
pub const styleFontStretchWider = styleFontStretch.styleFontStretchWider;
pub const styleFontStretchNarrower = styleFontStretch.styleFontStretchNarrower;
pub const styleFontStretchUltraCondensed = styleFontStretch.styleFontStretchUltraCondensed;
pub const styleFontStretchExtraCondensed = styleFontStretch.styleFontStretchExtraCondensed;
pub const styleFontStretchCondensed = styleFontStretch.styleFontStretchCondensed;
pub const styleFontStretchSemiCondensed = styleFontStretch.styleFontStretchSemiCondensed;
pub const styleFontStretchNormal = styleFontStretch.styleFontStretchNormal;
pub const styleFontStretchSemiExpanded = styleFontStretch.styleFontStretchSemiExpanded;
pub const styleFontStretchExpanded = styleFontStretch.styleFontStretchExpanded;
pub const styleFontStretchExtraExpanded = styleFontStretch.styleFontStretchExtraExpanded;
pub const styleFontStretchUltraExpanded = styleFontStretch.styleFontStretchUltraExpanded;
pub const styleFontStretch_Max = styleFontStretch.Max;

pub const stylePointerEvents = extern enum(i32) {
    stylePointerEventsNotSet = 0,
    stylePointerEventsVisiblePainted = 1,
    stylePointerEventsVisibleFill = 2,
    stylePointerEventsVisibleStroke = 3,
    stylePointerEventsVisible = 4,
    stylePointerEventsPainted = 5,
    stylePointerEventsFill = 6,
    stylePointerEventsStroke = 7,
    stylePointerEventsAll = 8,
    stylePointerEventsNone = 9,
    stylePointerEventsInitial = 10,
    stylePointerEventsAuto = 11,
    Max = 2147483647,
};
pub const stylePointerEventsNotSet = stylePointerEvents.stylePointerEventsNotSet;
pub const stylePointerEventsVisiblePainted = stylePointerEvents.stylePointerEventsVisiblePainted;
pub const stylePointerEventsVisibleFill = stylePointerEvents.stylePointerEventsVisibleFill;
pub const stylePointerEventsVisibleStroke = stylePointerEvents.stylePointerEventsVisibleStroke;
pub const stylePointerEventsVisible = stylePointerEvents.stylePointerEventsVisible;
pub const stylePointerEventsPainted = stylePointerEvents.stylePointerEventsPainted;
pub const stylePointerEventsFill = stylePointerEvents.stylePointerEventsFill;
pub const stylePointerEventsStroke = stylePointerEvents.stylePointerEventsStroke;
pub const stylePointerEventsAll = stylePointerEvents.stylePointerEventsAll;
pub const stylePointerEventsNone = stylePointerEvents.stylePointerEventsNone;
pub const stylePointerEventsInitial = stylePointerEvents.stylePointerEventsInitial;
pub const stylePointerEventsAuto = stylePointerEvents.stylePointerEventsAuto;
pub const stylePointerEvents_Max = stylePointerEvents.Max;

pub const styleEnableBackground = extern enum(i32) {
    styleEnableBackgroundNotSet = 0,
    styleEnableBackgroundAccumulate = 1,
    styleEnableBackgroundNew = 2,
    styleEnableBackgroundInherit = 3,
    Max = 2147483647,
};
pub const styleEnableBackgroundNotSet = styleEnableBackground.styleEnableBackgroundNotSet;
pub const styleEnableBackgroundAccumulate = styleEnableBackground.styleEnableBackgroundAccumulate;
pub const styleEnableBackgroundNew = styleEnableBackground.styleEnableBackgroundNew;
pub const styleEnableBackgroundInherit = styleEnableBackground.styleEnableBackgroundInherit;
pub const styleEnableBackground_Max = styleEnableBackground.Max;

pub const styleStrokeLinecap = extern enum(i32) {
    styleStrokeLinecapNotSet = 0,
    styleStrokeLinecapButt = 1,
    styleStrokeLinecapRound = 2,
    styleStrokeLinecapSquare = 3,
    Max = 2147483647,
};
pub const styleStrokeLinecapNotSet = styleStrokeLinecap.styleStrokeLinecapNotSet;
pub const styleStrokeLinecapButt = styleStrokeLinecap.styleStrokeLinecapButt;
pub const styleStrokeLinecapRound = styleStrokeLinecap.styleStrokeLinecapRound;
pub const styleStrokeLinecapSquare = styleStrokeLinecap.styleStrokeLinecapSquare;
pub const styleStrokeLinecap_Max = styleStrokeLinecap.Max;

pub const styleStrokeLinejoin = extern enum(i32) {
    styleStrokeLinejoinNotSet = 0,
    styleStrokeLinejoinMiter = 1,
    styleStrokeLinejoinRound = 2,
    styleStrokeLinejoinBevel = 3,
    Max = 2147483647,
};
pub const styleStrokeLinejoinNotSet = styleStrokeLinejoin.styleStrokeLinejoinNotSet;
pub const styleStrokeLinejoinMiter = styleStrokeLinejoin.styleStrokeLinejoinMiter;
pub const styleStrokeLinejoinRound = styleStrokeLinejoin.styleStrokeLinejoinRound;
pub const styleStrokeLinejoinBevel = styleStrokeLinejoin.styleStrokeLinejoinBevel;
pub const styleStrokeLinejoin_Max = styleStrokeLinejoin.Max;

pub const styleTextAnchor = extern enum(i32) {
    styleTextAnchorNotSet = 0,
    styleTextAnchorStart = 1,
    styleTextAnchorMiddle = 2,
    styleTextAnchorEnd = 3,
    Max = 2147483647,
};
pub const styleTextAnchorNotSet = styleTextAnchor.styleTextAnchorNotSet;
pub const styleTextAnchorStart = styleTextAnchor.styleTextAnchorStart;
pub const styleTextAnchorMiddle = styleTextAnchor.styleTextAnchorMiddle;
pub const styleTextAnchorEnd = styleTextAnchor.styleTextAnchorEnd;
pub const styleTextAnchor_Max = styleTextAnchor.Max;

pub const styleAttrType = extern enum(i32) {
    styleAttrTypeString = 0,
    styleAttrTypeColor = 1,
    styleAttrTypeUrl = 2,
    styleAttrTypeInteger = 3,
    styleAttrTypeNumber = 4,
    styleAttrTypeLength = 5,
    styleAttrTypePx = 6,
    styleAttrTypeEm = 7,
    styleAttrTypeEx = 8,
    styleAttrTypeIn = 9,
    styleAttrTypeCm = 10,
    styleAttrTypeMm = 11,
    styleAttrTypePt = 12,
    styleAttrTypePc = 13,
    styleAttrTypeRem = 14,
    styleAttrTypeCh = 15,
    styleAttrTypeVh = 16,
    styleAttrTypeVw = 17,
    styleAttrTypeVmin = 18,
    styleAttrTypePercentage = 19,
    styleAttrTypeAngle = 20,
    styleAttrTypeDeg = 21,
    styleAttrTypeRad = 22,
    styleAttrTypeGrad = 23,
    styleAttrTypeTime = 24,
    styleAttrTypeS = 25,
    styleAttrTypeMs = 26,
    Max = 2147483647,
};
pub const styleAttrTypeString = styleAttrType.styleAttrTypeString;
pub const styleAttrTypeColor = styleAttrType.styleAttrTypeColor;
pub const styleAttrTypeUrl = styleAttrType.styleAttrTypeUrl;
pub const styleAttrTypeInteger = styleAttrType.styleAttrTypeInteger;
pub const styleAttrTypeNumber = styleAttrType.styleAttrTypeNumber;
pub const styleAttrTypeLength = styleAttrType.styleAttrTypeLength;
pub const styleAttrTypePx = styleAttrType.styleAttrTypePx;
pub const styleAttrTypeEm = styleAttrType.styleAttrTypeEm;
pub const styleAttrTypeEx = styleAttrType.styleAttrTypeEx;
pub const styleAttrTypeIn = styleAttrType.styleAttrTypeIn;
pub const styleAttrTypeCm = styleAttrType.styleAttrTypeCm;
pub const styleAttrTypeMm = styleAttrType.styleAttrTypeMm;
pub const styleAttrTypePt = styleAttrType.styleAttrTypePt;
pub const styleAttrTypePc = styleAttrType.styleAttrTypePc;
pub const styleAttrTypeRem = styleAttrType.styleAttrTypeRem;
pub const styleAttrTypeCh = styleAttrType.styleAttrTypeCh;
pub const styleAttrTypeVh = styleAttrType.styleAttrTypeVh;
pub const styleAttrTypeVw = styleAttrType.styleAttrTypeVw;
pub const styleAttrTypeVmin = styleAttrType.styleAttrTypeVmin;
pub const styleAttrTypePercentage = styleAttrType.styleAttrTypePercentage;
pub const styleAttrTypeAngle = styleAttrType.styleAttrTypeAngle;
pub const styleAttrTypeDeg = styleAttrType.styleAttrTypeDeg;
pub const styleAttrTypeRad = styleAttrType.styleAttrTypeRad;
pub const styleAttrTypeGrad = styleAttrType.styleAttrTypeGrad;
pub const styleAttrTypeTime = styleAttrType.styleAttrTypeTime;
pub const styleAttrTypeS = styleAttrType.styleAttrTypeS;
pub const styleAttrTypeMs = styleAttrType.styleAttrTypeMs;
pub const styleAttrType_Max = styleAttrType.Max;

pub const styleInitialColor = extern enum(i32) {
    styleInitialColorNoInitial = 0,
    styleInitialColorColorProperty = 1,
    styleInitialColorTransparent = 2,
    styleInitialColorInvert = 3,
    Max = 2147483647,
};
pub const styleInitialColorNoInitial = styleInitialColor.styleInitialColorNoInitial;
pub const styleInitialColorColorProperty = styleInitialColor.styleInitialColorColorProperty;
pub const styleInitialColorTransparent = styleInitialColor.styleInitialColorTransparent;
pub const styleInitialColorInvert = styleInitialColor.styleInitialColorInvert;
pub const styleInitialColor_Max = styleInitialColor.Max;

pub const styleInitialString = extern enum(i32) {
    styleInitialStringNoInitial = 0,
    styleInitialStringNone = 1,
    styleInitialStringAuto = 2,
    styleInitialStringNormal = 3,
    Max = 2147483647,
};
pub const styleInitialStringNoInitial = styleInitialString.styleInitialStringNoInitial;
pub const styleInitialStringNone = styleInitialString.styleInitialStringNone;
pub const styleInitialStringAuto = styleInitialString.styleInitialStringAuto;
pub const styleInitialStringNormal = styleInitialString.styleInitialStringNormal;
pub const styleInitialString_Max = styleInitialString.Max;

pub const styleTransformOriginX = extern enum(i32) {
    styleTransformOriginXNotSet = 0,
    styleTransformOriginXLeft = 1,
    styleTransformOriginXCenter = 2,
    styleTransformOriginXRight = 3,
    Max = 2147483647,
};
pub const styleTransformOriginXNotSet = styleTransformOriginX.styleTransformOriginXNotSet;
pub const styleTransformOriginXLeft = styleTransformOriginX.styleTransformOriginXLeft;
pub const styleTransformOriginXCenter = styleTransformOriginX.styleTransformOriginXCenter;
pub const styleTransformOriginXRight = styleTransformOriginX.styleTransformOriginXRight;
pub const styleTransformOriginX_Max = styleTransformOriginX.Max;

pub const styleTransformOriginY = extern enum(i32) {
    styleTransformOriginYNotSet = 0,
    styleTransformOriginYTop = 1,
    styleTransformOriginYCenter = 2,
    styleTransformOriginYBottom = 3,
    Max = 2147483647,
};
pub const styleTransformOriginYNotSet = styleTransformOriginY.styleTransformOriginYNotSet;
pub const styleTransformOriginYTop = styleTransformOriginY.styleTransformOriginYTop;
pub const styleTransformOriginYCenter = styleTransformOriginY.styleTransformOriginYCenter;
pub const styleTransformOriginYBottom = styleTransformOriginY.styleTransformOriginYBottom;
pub const styleTransformOriginY_Max = styleTransformOriginY.Max;

pub const stylePerspectiveOriginX = extern enum(i32) {
    stylePerspectiveOriginXNotSet = 0,
    stylePerspectiveOriginXLeft = 1,
    stylePerspectiveOriginXCenter = 2,
    stylePerspectiveOriginXRight = 3,
    Max = 2147483647,
};
pub const stylePerspectiveOriginXNotSet = stylePerspectiveOriginX.stylePerspectiveOriginXNotSet;
pub const stylePerspectiveOriginXLeft = stylePerspectiveOriginX.stylePerspectiveOriginXLeft;
pub const stylePerspectiveOriginXCenter = stylePerspectiveOriginX.stylePerspectiveOriginXCenter;
pub const stylePerspectiveOriginXRight = stylePerspectiveOriginX.stylePerspectiveOriginXRight;
pub const stylePerspectiveOriginX_Max = stylePerspectiveOriginX.Max;

pub const stylePerspectiveOriginY = extern enum(i32) {
    stylePerspectiveOriginYNotSet = 0,
    stylePerspectiveOriginYTop = 1,
    stylePerspectiveOriginYCenter = 2,
    stylePerspectiveOriginYBottom = 3,
    Max = 2147483647,
};
pub const stylePerspectiveOriginYNotSet = stylePerspectiveOriginY.stylePerspectiveOriginYNotSet;
pub const stylePerspectiveOriginYTop = stylePerspectiveOriginY.stylePerspectiveOriginYTop;
pub const stylePerspectiveOriginYCenter = stylePerspectiveOriginY.stylePerspectiveOriginYCenter;
pub const stylePerspectiveOriginYBottom = stylePerspectiveOriginY.stylePerspectiveOriginYBottom;
pub const stylePerspectiveOriginY_Max = stylePerspectiveOriginY.Max;

pub const styleTransformStyle = extern enum(i32) {
    styleTransformStyleFlat = 0,
    styleTransformStylePreserve3D = 1,
    styleTransformStyleNotSet = 2,
    Max = 2147483647,
};
pub const styleTransformStyleFlat = styleTransformStyle.styleTransformStyleFlat;
pub const styleTransformStylePreserve3D = styleTransformStyle.styleTransformStylePreserve3D;
pub const styleTransformStyleNotSet = styleTransformStyle.styleTransformStyleNotSet;
pub const styleTransformStyle_Max = styleTransformStyle.Max;

pub const styleBackfaceVisibility = extern enum(i32) {
    styleBackfaceVisibilityVisible = 0,
    styleBackfaceVisibilityHidden = 1,
    styleBackfaceVisibilityNotSet = 2,
    Max = 2147483647,
};
pub const styleBackfaceVisibilityVisible = styleBackfaceVisibility.styleBackfaceVisibilityVisible;
pub const styleBackfaceVisibilityHidden = styleBackfaceVisibility.styleBackfaceVisibilityHidden;
pub const styleBackfaceVisibilityNotSet = styleBackfaceVisibility.styleBackfaceVisibilityNotSet;
pub const styleBackfaceVisibility_Max = styleBackfaceVisibility.Max;

pub const styleTextSizeAdjust = extern enum(i32) {
    styleTextSizeAdjustNone = 0,
    styleTextSizeAdjustAuto = 1,
    Max = 2147483647,
};
pub const styleTextSizeAdjustNone = styleTextSizeAdjust.styleTextSizeAdjustNone;
pub const styleTextSizeAdjustAuto = styleTextSizeAdjust.styleTextSizeAdjustAuto;
pub const styleTextSizeAdjust_Max = styleTextSizeAdjust.Max;

pub const styleColorInterpolationFilters = extern enum(i32) {
    styleColorInterpolationFiltersAuto = 0,
    styleColorInterpolationFiltersSRgb = 1,
    styleColorInterpolationFiltersLinearRgb = 2,
    styleColorInterpolationFiltersNotSet = 3,
    Max = 2147483647,
};
pub const styleColorInterpolationFiltersAuto = styleColorInterpolationFilters.styleColorInterpolationFiltersAuto;
pub const styleColorInterpolationFiltersSRgb = styleColorInterpolationFilters.styleColorInterpolationFiltersSRgb;
pub const styleColorInterpolationFiltersLinearRgb = styleColorInterpolationFilters.styleColorInterpolationFiltersLinearRgb;
pub const styleColorInterpolationFiltersNotSet = styleColorInterpolationFilters.styleColorInterpolationFiltersNotSet;
pub const styleColorInterpolationFilters_Max = styleColorInterpolationFilters.Max;

pub const styleHyphens = extern enum(i32) {
    styleHyphensNone = 0,
    styleHyphensManual = 1,
    styleHyphensAuto = 2,
    styleHyphensNotSet = 3,
    Max = 2147483647,
};
pub const styleHyphensNone = styleHyphens.styleHyphensNone;
pub const styleHyphensManual = styleHyphens.styleHyphensManual;
pub const styleHyphensAuto = styleHyphens.styleHyphensAuto;
pub const styleHyphensNotSet = styleHyphens.styleHyphensNotSet;
pub const styleHyphens_Max = styleHyphens.Max;

pub const styleHyphenateLimitLines = extern enum(i32) {
    styleHyphenateLimitLinesNoLimit = 0,
    Max = 2147483647,
};
pub const styleHyphenateLimitLinesNoLimit = styleHyphenateLimitLines.styleHyphenateLimitLinesNoLimit;
pub const styleHyphenateLimitLines_Max = styleHyphenateLimitLines.Max;

pub const styleMsAnimationPlayState = extern enum(i32) {
    styleMsAnimationPlayStateRunning = 0,
    styleMsAnimationPlayStatePaused = 1,
    styleMsAnimationPlayStateNotSet = 2,
    Max = 2147483647,
};
pub const styleMsAnimationPlayStateRunning = styleMsAnimationPlayState.styleMsAnimationPlayStateRunning;
pub const styleMsAnimationPlayStatePaused = styleMsAnimationPlayState.styleMsAnimationPlayStatePaused;
pub const styleMsAnimationPlayStateNotSet = styleMsAnimationPlayState.styleMsAnimationPlayStateNotSet;
pub const styleMsAnimationPlayState_Max = styleMsAnimationPlayState.Max;

pub const styleMsAnimationDirection = extern enum(i32) {
    styleMsAnimationDirectionNormal = 0,
    styleMsAnimationDirectionAlternate = 1,
    styleMsAnimationDirectionReverse = 2,
    styleMsAnimationDirectionAlternateReverse = 3,
    styleMsAnimationDirectionNotSet = 4,
    Max = 2147483647,
};
pub const styleMsAnimationDirectionNormal = styleMsAnimationDirection.styleMsAnimationDirectionNormal;
pub const styleMsAnimationDirectionAlternate = styleMsAnimationDirection.styleMsAnimationDirectionAlternate;
pub const styleMsAnimationDirectionReverse = styleMsAnimationDirection.styleMsAnimationDirectionReverse;
pub const styleMsAnimationDirectionAlternateReverse = styleMsAnimationDirection.styleMsAnimationDirectionAlternateReverse;
pub const styleMsAnimationDirectionNotSet = styleMsAnimationDirection.styleMsAnimationDirectionNotSet;
pub const styleMsAnimationDirection_Max = styleMsAnimationDirection.Max;

pub const styleMsAnimationFillMode = extern enum(i32) {
    styleMsAnimationFillModeNone = 0,
    styleMsAnimationFillModeForwards = 1,
    styleMsAnimationFillModeBackwards = 2,
    styleMsAnimationFillModeBoth = 3,
    styleMsAnimationFillModeNotSet = 4,
    Max = 2147483647,
};
pub const styleMsAnimationFillModeNone = styleMsAnimationFillMode.styleMsAnimationFillModeNone;
pub const styleMsAnimationFillModeForwards = styleMsAnimationFillMode.styleMsAnimationFillModeForwards;
pub const styleMsAnimationFillModeBackwards = styleMsAnimationFillMode.styleMsAnimationFillModeBackwards;
pub const styleMsAnimationFillModeBoth = styleMsAnimationFillMode.styleMsAnimationFillModeBoth;
pub const styleMsAnimationFillModeNotSet = styleMsAnimationFillMode.styleMsAnimationFillModeNotSet;
pub const styleMsAnimationFillMode_Max = styleMsAnimationFillMode.Max;

pub const styleMsHighContrastAdjust = extern enum(i32) {
    styleMsHighContrastAdjustNotSet = 0,
    styleMsHighContrastAdjustAuto = 1,
    styleMsHighContrastAdjustNone = 2,
    Max = 2147483647,
};
pub const styleMsHighContrastAdjustNotSet = styleMsHighContrastAdjust.styleMsHighContrastAdjustNotSet;
pub const styleMsHighContrastAdjustAuto = styleMsHighContrastAdjust.styleMsHighContrastAdjustAuto;
pub const styleMsHighContrastAdjustNone = styleMsHighContrastAdjust.styleMsHighContrastAdjustNone;
pub const styleMsHighContrastAdjust_Max = styleMsHighContrastAdjust.Max;

pub const styleMsUserSelect = extern enum(i32) {
    styleMsUserSelectAuto = 0,
    styleMsUserSelectText = 1,
    styleMsUserSelectElement = 2,
    styleMsUserSelectNone = 3,
    styleMsUserSelectNotSet = 4,
    Max = 2147483647,
};
pub const styleMsUserSelectAuto = styleMsUserSelect.styleMsUserSelectAuto;
pub const styleMsUserSelectText = styleMsUserSelect.styleMsUserSelectText;
pub const styleMsUserSelectElement = styleMsUserSelect.styleMsUserSelectElement;
pub const styleMsUserSelectNone = styleMsUserSelect.styleMsUserSelectNone;
pub const styleMsUserSelectNotSet = styleMsUserSelect.styleMsUserSelectNotSet;
pub const styleMsUserSelect_Max = styleMsUserSelect.Max;

pub const styleMsTouchAction = extern enum(i32) {
    styleMsTouchActionNotSet = -1,
    styleMsTouchActionNone = 0,
    styleMsTouchActionAuto = 1,
    styleMsTouchActionManipulation = 2,
    styleMsTouchActionDoubleTapZoom = 4,
    styleMsTouchActionPanX = 8,
    styleMsTouchActionPanY = 16,
    styleMsTouchActionPinchZoom = 32,
    styleMsTouchActionCrossSlideX = 64,
    styleMsTouchActionCrossSlideY = 128,
    Max = 2147483647,
};
pub const styleMsTouchActionNotSet = styleMsTouchAction.styleMsTouchActionNotSet;
pub const styleMsTouchActionNone = styleMsTouchAction.styleMsTouchActionNone;
pub const styleMsTouchActionAuto = styleMsTouchAction.styleMsTouchActionAuto;
pub const styleMsTouchActionManipulation = styleMsTouchAction.styleMsTouchActionManipulation;
pub const styleMsTouchActionDoubleTapZoom = styleMsTouchAction.styleMsTouchActionDoubleTapZoom;
pub const styleMsTouchActionPanX = styleMsTouchAction.styleMsTouchActionPanX;
pub const styleMsTouchActionPanY = styleMsTouchAction.styleMsTouchActionPanY;
pub const styleMsTouchActionPinchZoom = styleMsTouchAction.styleMsTouchActionPinchZoom;
pub const styleMsTouchActionCrossSlideX = styleMsTouchAction.styleMsTouchActionCrossSlideX;
pub const styleMsTouchActionCrossSlideY = styleMsTouchAction.styleMsTouchActionCrossSlideY;
pub const styleMsTouchAction_Max = styleMsTouchAction.Max;

pub const styleMsTouchSelect = extern enum(i32) {
    styleMsTouchSelectGrippers = 0,
    styleMsTouchSelectNone = 1,
    styleMsTouchSelectNotSet = 2,
    Max = 2147483647,
};
pub const styleMsTouchSelectGrippers = styleMsTouchSelect.styleMsTouchSelectGrippers;
pub const styleMsTouchSelectNone = styleMsTouchSelect.styleMsTouchSelectNone;
pub const styleMsTouchSelectNotSet = styleMsTouchSelect.styleMsTouchSelectNotSet;
pub const styleMsTouchSelect_Max = styleMsTouchSelect.Max;

pub const styleMsScrollTranslation = extern enum(i32) {
    styleMsScrollTranslationNotSet = 0,
    styleMsScrollTranslationNone = 1,
    styleMsScrollTranslationVtoH = 2,
    Max = 2147483647,
};
pub const styleMsScrollTranslationNotSet = styleMsScrollTranslation.styleMsScrollTranslationNotSet;
pub const styleMsScrollTranslationNone = styleMsScrollTranslation.styleMsScrollTranslationNone;
pub const styleMsScrollTranslationVtoH = styleMsScrollTranslation.styleMsScrollTranslationVtoH;
pub const styleMsScrollTranslation_Max = styleMsScrollTranslation.Max;

pub const styleBorderImageRepeat = extern enum(i32) {
    styleBorderImageRepeatStretch = 0,
    styleBorderImageRepeatRepeat = 1,
    styleBorderImageRepeatRound = 2,
    styleBorderImageRepeatSpace = 3,
    styleBorderImageRepeatNotSet = 4,
    Max = 2147483647,
};
pub const styleBorderImageRepeatStretch = styleBorderImageRepeat.styleBorderImageRepeatStretch;
pub const styleBorderImageRepeatRepeat = styleBorderImageRepeat.styleBorderImageRepeatRepeat;
pub const styleBorderImageRepeatRound = styleBorderImageRepeat.styleBorderImageRepeatRound;
pub const styleBorderImageRepeatSpace = styleBorderImageRepeat.styleBorderImageRepeatSpace;
pub const styleBorderImageRepeatNotSet = styleBorderImageRepeat.styleBorderImageRepeatNotSet;
pub const styleBorderImageRepeat_Max = styleBorderImageRepeat.Max;

pub const styleBorderImageSliceFill = extern enum(i32) {
    styleBorderImageSliceFillNotSet = 0,
    styleBorderImageSliceFillFill = 1,
    Max = 2147483647,
};
pub const styleBorderImageSliceFillNotSet = styleBorderImageSliceFill.styleBorderImageSliceFillNotSet;
pub const styleBorderImageSliceFillFill = styleBorderImageSliceFill.styleBorderImageSliceFillFill;
pub const styleBorderImageSliceFill_Max = styleBorderImageSliceFill.Max;

pub const styleMsImeAlign = extern enum(i32) {
    styleMsImeAlignAuto = 0,
    styleMsImeAlignAfter = 1,
    styleMsImeAlignNotSet = 2,
    Max = 2147483647,
};
pub const styleMsImeAlignAuto = styleMsImeAlign.styleMsImeAlignAuto;
pub const styleMsImeAlignAfter = styleMsImeAlign.styleMsImeAlignAfter;
pub const styleMsImeAlignNotSet = styleMsImeAlign.styleMsImeAlignNotSet;
pub const styleMsImeAlign_Max = styleMsImeAlign.Max;

pub const styleMsTextCombineHorizontal = extern enum(i32) {
    styleMsTextCombineHorizontalNone = 0,
    styleMsTextCombineHorizontalAll = 1,
    styleMsTextCombineHorizontalDigits = 2,
    styleMsTextCombineHorizontalNotSet = 3,
    Max = 2147483647,
};
pub const styleMsTextCombineHorizontalNone = styleMsTextCombineHorizontal.styleMsTextCombineHorizontalNone;
pub const styleMsTextCombineHorizontalAll = styleMsTextCombineHorizontal.styleMsTextCombineHorizontalAll;
pub const styleMsTextCombineHorizontalDigits = styleMsTextCombineHorizontal.styleMsTextCombineHorizontalDigits;
pub const styleMsTextCombineHorizontalNotSet = styleMsTextCombineHorizontal.styleMsTextCombineHorizontalNotSet;
pub const styleMsTextCombineHorizontal_Max = styleMsTextCombineHorizontal.Max;

pub const styleWebkitAppearance = extern enum(i32) {
    styleWebkitAppearanceNone = 0,
    styleWebkitAppearanceCapsLockIndicator = 1,
    styleWebkitAppearanceButton = 2,
    styleWebkitAppearanceButtonBevel = 3,
    styleWebkitAppearanceCaret = 4,
    styleWebkitAppearanceCheckbox = 5,
    styleWebkitAppearanceDefaultButton = 6,
    styleWebkitAppearanceListbox = 7,
    styleWebkitAppearanceListitem = 8,
    styleWebkitAppearanceMediaFullscreenButton = 9,
    styleWebkitAppearanceMediaMuteButton = 10,
    styleWebkitAppearanceMediaPlayButton = 11,
    styleWebkitAppearanceMediaSeekBackButton = 12,
    styleWebkitAppearanceMediaSeekForwardButton = 13,
    styleWebkitAppearanceMediaSlider = 14,
    styleWebkitAppearanceMediaSliderthumb = 15,
    styleWebkitAppearanceMenulist = 16,
    styleWebkitAppearanceMenulistButton = 17,
    styleWebkitAppearanceMenulistText = 18,
    styleWebkitAppearanceMenulistTextfield = 19,
    styleWebkitAppearancePushButton = 20,
    styleWebkitAppearanceRadio = 21,
    styleWebkitAppearanceSearchfield = 22,
    styleWebkitAppearanceSearchfieldCancelButton = 23,
    styleWebkitAppearanceSearchfieldDecoration = 24,
    styleWebkitAppearanceSearchfieldResultsButton = 25,
    styleWebkitAppearanceSearchfieldResultsDecoration = 26,
    styleWebkitAppearanceSliderHorizontal = 27,
    styleWebkitAppearanceSliderVertical = 28,
    styleWebkitAppearanceSliderthumbHorizontal = 29,
    styleWebkitAppearanceSliderthumbVertical = 30,
    styleWebkitAppearanceSquareButton = 31,
    styleWebkitAppearanceTextarea = 32,
    styleWebkitAppearanceTextfield = 33,
    styleWebkitAppearanceNotSet = 34,
    Max = 2147483647,
};
pub const styleWebkitAppearanceNone = styleWebkitAppearance.styleWebkitAppearanceNone;
pub const styleWebkitAppearanceCapsLockIndicator = styleWebkitAppearance.styleWebkitAppearanceCapsLockIndicator;
pub const styleWebkitAppearanceButton = styleWebkitAppearance.styleWebkitAppearanceButton;
pub const styleWebkitAppearanceButtonBevel = styleWebkitAppearance.styleWebkitAppearanceButtonBevel;
pub const styleWebkitAppearanceCaret = styleWebkitAppearance.styleWebkitAppearanceCaret;
pub const styleWebkitAppearanceCheckbox = styleWebkitAppearance.styleWebkitAppearanceCheckbox;
pub const styleWebkitAppearanceDefaultButton = styleWebkitAppearance.styleWebkitAppearanceDefaultButton;
pub const styleWebkitAppearanceListbox = styleWebkitAppearance.styleWebkitAppearanceListbox;
pub const styleWebkitAppearanceListitem = styleWebkitAppearance.styleWebkitAppearanceListitem;
pub const styleWebkitAppearanceMediaFullscreenButton = styleWebkitAppearance.styleWebkitAppearanceMediaFullscreenButton;
pub const styleWebkitAppearanceMediaMuteButton = styleWebkitAppearance.styleWebkitAppearanceMediaMuteButton;
pub const styleWebkitAppearanceMediaPlayButton = styleWebkitAppearance.styleWebkitAppearanceMediaPlayButton;
pub const styleWebkitAppearanceMediaSeekBackButton = styleWebkitAppearance.styleWebkitAppearanceMediaSeekBackButton;
pub const styleWebkitAppearanceMediaSeekForwardButton = styleWebkitAppearance.styleWebkitAppearanceMediaSeekForwardButton;
pub const styleWebkitAppearanceMediaSlider = styleWebkitAppearance.styleWebkitAppearanceMediaSlider;
pub const styleWebkitAppearanceMediaSliderthumb = styleWebkitAppearance.styleWebkitAppearanceMediaSliderthumb;
pub const styleWebkitAppearanceMenulist = styleWebkitAppearance.styleWebkitAppearanceMenulist;
pub const styleWebkitAppearanceMenulistButton = styleWebkitAppearance.styleWebkitAppearanceMenulistButton;
pub const styleWebkitAppearanceMenulistText = styleWebkitAppearance.styleWebkitAppearanceMenulistText;
pub const styleWebkitAppearanceMenulistTextfield = styleWebkitAppearance.styleWebkitAppearanceMenulistTextfield;
pub const styleWebkitAppearancePushButton = styleWebkitAppearance.styleWebkitAppearancePushButton;
pub const styleWebkitAppearanceRadio = styleWebkitAppearance.styleWebkitAppearanceRadio;
pub const styleWebkitAppearanceSearchfield = styleWebkitAppearance.styleWebkitAppearanceSearchfield;
pub const styleWebkitAppearanceSearchfieldCancelButton = styleWebkitAppearance.styleWebkitAppearanceSearchfieldCancelButton;
pub const styleWebkitAppearanceSearchfieldDecoration = styleWebkitAppearance.styleWebkitAppearanceSearchfieldDecoration;
pub const styleWebkitAppearanceSearchfieldResultsButton = styleWebkitAppearance.styleWebkitAppearanceSearchfieldResultsButton;
pub const styleWebkitAppearanceSearchfieldResultsDecoration = styleWebkitAppearance.styleWebkitAppearanceSearchfieldResultsDecoration;
pub const styleWebkitAppearanceSliderHorizontal = styleWebkitAppearance.styleWebkitAppearanceSliderHorizontal;
pub const styleWebkitAppearanceSliderVertical = styleWebkitAppearance.styleWebkitAppearanceSliderVertical;
pub const styleWebkitAppearanceSliderthumbHorizontal = styleWebkitAppearance.styleWebkitAppearanceSliderthumbHorizontal;
pub const styleWebkitAppearanceSliderthumbVertical = styleWebkitAppearance.styleWebkitAppearanceSliderthumbVertical;
pub const styleWebkitAppearanceSquareButton = styleWebkitAppearance.styleWebkitAppearanceSquareButton;
pub const styleWebkitAppearanceTextarea = styleWebkitAppearance.styleWebkitAppearanceTextarea;
pub const styleWebkitAppearanceTextfield = styleWebkitAppearance.styleWebkitAppearanceTextfield;
pub const styleWebkitAppearanceNotSet = styleWebkitAppearance.styleWebkitAppearanceNotSet;
pub const styleWebkitAppearance_Max = styleWebkitAppearance.Max;

pub const styleViewportSize = extern enum(i32) {
    styleViewportSizeAuto = 0,
    styleViewportSizeDeviceWidth = 1,
    styleViewportSizeDeviceHeight = 2,
    Max = 2147483647,
};
pub const styleViewportSizeAuto = styleViewportSize.styleViewportSizeAuto;
pub const styleViewportSizeDeviceWidth = styleViewportSize.styleViewportSizeDeviceWidth;
pub const styleViewportSizeDeviceHeight = styleViewportSize.styleViewportSizeDeviceHeight;
pub const styleViewportSize_Max = styleViewportSize.Max;

pub const styleUserZoom = extern enum(i32) {
    styleUserZoomNotSet = 0,
    styleUserZoomZoom = 1,
    styleUserZoomFixed = 2,
    Max = 2147483647,
};
pub const styleUserZoomNotSet = styleUserZoom.styleUserZoomNotSet;
pub const styleUserZoomZoom = styleUserZoom.styleUserZoomZoom;
pub const styleUserZoomFixed = styleUserZoom.styleUserZoomFixed;
pub const styleUserZoom_Max = styleUserZoom.Max;

pub const styleTextLineThroughStyle = extern enum(i32) {
    styleTextLineThroughStyleUndefined = 0,
    styleTextLineThroughStyleSingle = 1,
    styleTextLineThroughStyleDouble = 2,
    Max = 2147483647,
};
pub const styleTextLineThroughStyleUndefined = styleTextLineThroughStyle.styleTextLineThroughStyleUndefined;
pub const styleTextLineThroughStyleSingle = styleTextLineThroughStyle.styleTextLineThroughStyleSingle;
pub const styleTextLineThroughStyleDouble = styleTextLineThroughStyle.styleTextLineThroughStyleDouble;
pub const styleTextLineThroughStyle_Max = styleTextLineThroughStyle.Max;

pub const styleTextUnderlineStyle = extern enum(i32) {
    styleTextUnderlineStyleUndefined = 0,
    styleTextUnderlineStyleSingle = 1,
    styleTextUnderlineStyleDouble = 2,
    styleTextUnderlineStyleWords = 3,
    styleTextUnderlineStyleDotted = 4,
    styleTextUnderlineStyleThick = 5,
    styleTextUnderlineStyleDash = 6,
    styleTextUnderlineStyleDotDash = 7,
    styleTextUnderlineStyleDotDotDash = 8,
    styleTextUnderlineStyleWave = 9,
    styleTextUnderlineStyleSingleAccounting = 10,
    styleTextUnderlineStyleDoubleAccounting = 11,
    styleTextUnderlineStyleThickDash = 12,
    Max = 2147483647,
};
pub const styleTextUnderlineStyleUndefined = styleTextUnderlineStyle.styleTextUnderlineStyleUndefined;
pub const styleTextUnderlineStyleSingle = styleTextUnderlineStyle.styleTextUnderlineStyleSingle;
pub const styleTextUnderlineStyleDouble = styleTextUnderlineStyle.styleTextUnderlineStyleDouble;
pub const styleTextUnderlineStyleWords = styleTextUnderlineStyle.styleTextUnderlineStyleWords;
pub const styleTextUnderlineStyleDotted = styleTextUnderlineStyle.styleTextUnderlineStyleDotted;
pub const styleTextUnderlineStyleThick = styleTextUnderlineStyle.styleTextUnderlineStyleThick;
pub const styleTextUnderlineStyleDash = styleTextUnderlineStyle.styleTextUnderlineStyleDash;
pub const styleTextUnderlineStyleDotDash = styleTextUnderlineStyle.styleTextUnderlineStyleDotDash;
pub const styleTextUnderlineStyleDotDotDash = styleTextUnderlineStyle.styleTextUnderlineStyleDotDotDash;
pub const styleTextUnderlineStyleWave = styleTextUnderlineStyle.styleTextUnderlineStyleWave;
pub const styleTextUnderlineStyleSingleAccounting = styleTextUnderlineStyle.styleTextUnderlineStyleSingleAccounting;
pub const styleTextUnderlineStyleDoubleAccounting = styleTextUnderlineStyle.styleTextUnderlineStyleDoubleAccounting;
pub const styleTextUnderlineStyleThickDash = styleTextUnderlineStyle.styleTextUnderlineStyleThickDash;
pub const styleTextUnderlineStyle_Max = styleTextUnderlineStyle.Max;

pub const styleTextEffect = extern enum(i32) {
    styleTextEffectNone = 0,
    styleTextEffectEmboss = 1,
    styleTextEffectEngrave = 2,
    styleTextEffectOutline = 3,
    Max = 2147483647,
};
pub const styleTextEffectNone = styleTextEffect.styleTextEffectNone;
pub const styleTextEffectEmboss = styleTextEffect.styleTextEffectEmboss;
pub const styleTextEffectEngrave = styleTextEffect.styleTextEffectEngrave;
pub const styleTextEffectOutline = styleTextEffect.styleTextEffectOutline;
pub const styleTextEffect_Max = styleTextEffect.Max;

pub const styleDefaultTextSelection = extern enum(i32) {
    styleDefaultTextSelectionFalse = 0,
    styleDefaultTextSelectionTrue = 1,
    Max = 2147483647,
};
pub const styleDefaultTextSelectionFalse = styleDefaultTextSelection.styleDefaultTextSelectionFalse;
pub const styleDefaultTextSelectionTrue = styleDefaultTextSelection.styleDefaultTextSelectionTrue;
pub const styleDefaultTextSelection_Max = styleDefaultTextSelection.Max;

pub const styleTextDecoration = extern enum(i32) {
    styleTextDecorationNone = 0,
    styleTextDecorationUnderline = 1,
    styleTextDecorationOverline = 2,
    styleTextDecorationLineThrough = 3,
    styleTextDecorationBlink = 4,
    Max = 2147483647,
};
pub const styleTextDecorationNone = styleTextDecoration.styleTextDecorationNone;
pub const styleTextDecorationUnderline = styleTextDecoration.styleTextDecorationUnderline;
pub const styleTextDecorationOverline = styleTextDecoration.styleTextDecorationOverline;
pub const styleTextDecorationLineThrough = styleTextDecoration.styleTextDecorationLineThrough;
pub const styleTextDecorationBlink = styleTextDecoration.styleTextDecorationBlink;
pub const styleTextDecoration_Max = styleTextDecoration.Max;

pub const textDecoration = extern enum(i32) {
    textDecorationNone = 0,
    textDecorationUnderline = 1,
    textDecorationOverline = 2,
    textDecorationLineThrough = 3,
    textDecorationBlink = 4,
    Max = 2147483647,
};
pub const textDecorationNone = textDecoration.textDecorationNone;
pub const textDecorationUnderline = textDecoration.textDecorationUnderline;
pub const textDecorationOverline = textDecoration.textDecorationOverline;
pub const textDecorationLineThrough = textDecoration.textDecorationLineThrough;
pub const textDecorationBlink = textDecoration.textDecorationBlink;
pub const textDecoration_Max = textDecoration.Max;

pub const htmlListType = extern enum(i32) {
    htmlListTypeNotSet = 0,
    htmlListTypeLargeAlpha = 1,
    htmlListTypeSmallAlpha = 2,
    htmlListTypeLargeRoman = 3,
    htmlListTypeSmallRoman = 4,
    htmlListTypeNumbers = 5,
    htmlListTypeDisc = 6,
    htmlListTypeCircle = 7,
    htmlListTypeSquare = 8,
    Max = 2147483647,
};
pub const htmlListTypeNotSet = htmlListType.htmlListTypeNotSet;
pub const htmlListTypeLargeAlpha = htmlListType.htmlListTypeLargeAlpha;
pub const htmlListTypeSmallAlpha = htmlListType.htmlListTypeSmallAlpha;
pub const htmlListTypeLargeRoman = htmlListType.htmlListTypeLargeRoman;
pub const htmlListTypeSmallRoman = htmlListType.htmlListTypeSmallRoman;
pub const htmlListTypeNumbers = htmlListType.htmlListTypeNumbers;
pub const htmlListTypeDisc = htmlListType.htmlListTypeDisc;
pub const htmlListTypeCircle = htmlListType.htmlListTypeCircle;
pub const htmlListTypeSquare = htmlListType.htmlListTypeSquare;
pub const htmlListType_Max = htmlListType.Max;

pub const htmlMethod = extern enum(i32) {
    htmlMethodNotSet = 0,
    htmlMethodGet = 1,
    htmlMethodPost = 2,
    Max = 2147483647,
};
pub const htmlMethodNotSet = htmlMethod.htmlMethodNotSet;
pub const htmlMethodGet = htmlMethod.htmlMethodGet;
pub const htmlMethodPost = htmlMethod.htmlMethodPost;
pub const htmlMethod_Max = htmlMethod.Max;

pub const htmlWrap = extern enum(i32) {
    htmlWrapOff = 1,
    htmlWrapSoft = 2,
    htmlWrapHard = 3,
    Max = 2147483647,
};
pub const htmlWrapOff = htmlWrap.htmlWrapOff;
pub const htmlWrapSoft = htmlWrap.htmlWrapSoft;
pub const htmlWrapHard = htmlWrap.htmlWrapHard;
pub const htmlWrap_Max = htmlWrap.Max;

pub const htmlDir = extern enum(i32) {
    htmlDirNotSet = 0,
    htmlDirLeftToRight = 1,
    htmlDirRightToLeft = 2,
    Max = 2147483647,
};
pub const htmlDirNotSet = htmlDir.htmlDirNotSet;
pub const htmlDirLeftToRight = htmlDir.htmlDirLeftToRight;
pub const htmlDirRightToLeft = htmlDir.htmlDirRightToLeft;
pub const htmlDir_Max = htmlDir.Max;

pub const htmlEditable = extern enum(i32) {
    htmlEditableInherit = 0,
    htmlEditableTrue = 1,
    htmlEditableFalse = 2,
    Max = 2147483647,
};
pub const htmlEditableInherit = htmlEditable.htmlEditableInherit;
pub const htmlEditableTrue = htmlEditable.htmlEditableTrue;
pub const htmlEditableFalse = htmlEditable.htmlEditableFalse;
pub const htmlEditable_Max = htmlEditable.Max;

pub const htmlInput = extern enum(i32) {
    htmlInputNotSet = 0,
    htmlInputButton = 1,
    htmlInputCheckbox = 2,
    htmlInputFile = 3,
    htmlInputHidden = 4,
    htmlInputImage = 5,
    htmlInputPassword = 6,
    htmlInputRadio = 7,
    htmlInputReset = 8,
    htmlInputSelectOne = 9,
    htmlInputSelectMultiple = 10,
    htmlInputSubmit = 11,
    htmlInputText = 12,
    htmlInputTextarea = 13,
    htmlInputRichtext = 14,
    htmlInputRange = 15,
    htmlInputUrl = 16,
    htmlInputEmail = 17,
    htmlInputNumber = 18,
    htmlInputTel = 19,
    htmlInputSearch = 20,
    Max = 2147483647,
};
pub const htmlInputNotSet = htmlInput.htmlInputNotSet;
pub const htmlInputButton = htmlInput.htmlInputButton;
pub const htmlInputCheckbox = htmlInput.htmlInputCheckbox;
pub const htmlInputFile = htmlInput.htmlInputFile;
pub const htmlInputHidden = htmlInput.htmlInputHidden;
pub const htmlInputImage = htmlInput.htmlInputImage;
pub const htmlInputPassword = htmlInput.htmlInputPassword;
pub const htmlInputRadio = htmlInput.htmlInputRadio;
pub const htmlInputReset = htmlInput.htmlInputReset;
pub const htmlInputSelectOne = htmlInput.htmlInputSelectOne;
pub const htmlInputSelectMultiple = htmlInput.htmlInputSelectMultiple;
pub const htmlInputSubmit = htmlInput.htmlInputSubmit;
pub const htmlInputText = htmlInput.htmlInputText;
pub const htmlInputTextarea = htmlInput.htmlInputTextarea;
pub const htmlInputRichtext = htmlInput.htmlInputRichtext;
pub const htmlInputRange = htmlInput.htmlInputRange;
pub const htmlInputUrl = htmlInput.htmlInputUrl;
pub const htmlInputEmail = htmlInput.htmlInputEmail;
pub const htmlInputNumber = htmlInput.htmlInputNumber;
pub const htmlInputTel = htmlInput.htmlInputTel;
pub const htmlInputSearch = htmlInput.htmlInputSearch;
pub const htmlInput_Max = htmlInput.Max;

pub const htmlSpellCheck = extern enum(i32) {
    htmlSpellCheckNotSet = 0,
    htmlSpellCheckTrue = 1,
    htmlSpellCheckFalse = 2,
    htmlSpellCheckDefault = 3,
    Max = 2147483647,
};
pub const htmlSpellCheckNotSet = htmlSpellCheck.htmlSpellCheckNotSet;
pub const htmlSpellCheckTrue = htmlSpellCheck.htmlSpellCheckTrue;
pub const htmlSpellCheckFalse = htmlSpellCheck.htmlSpellCheckFalse;
pub const htmlSpellCheckDefault = htmlSpellCheck.htmlSpellCheckDefault;
pub const htmlSpellCheck_Max = htmlSpellCheck.Max;

pub const htmlEncoding = extern enum(i32) {
    htmlEncodingURL = 0,
    htmlEncodingMultipart = 1,
    htmlEncodingText = 2,
    Max = 2147483647,
};
pub const htmlEncodingURL = htmlEncoding.htmlEncodingURL;
pub const htmlEncodingMultipart = htmlEncoding.htmlEncodingMultipart;
pub const htmlEncodingText = htmlEncoding.htmlEncodingText;
pub const htmlEncoding_Max = htmlEncoding.Max;

pub const htmlAdjacency = extern enum(i32) {
    htmlAdjacencyBeforeBegin = 1,
    htmlAdjacencyAfterBegin = 2,
    htmlAdjacencyBeforeEnd = 3,
    htmlAdjacencyAfterEnd = 4,
    Max = 2147483647,
};
pub const htmlAdjacencyBeforeBegin = htmlAdjacency.htmlAdjacencyBeforeBegin;
pub const htmlAdjacencyAfterBegin = htmlAdjacency.htmlAdjacencyAfterBegin;
pub const htmlAdjacencyBeforeEnd = htmlAdjacency.htmlAdjacencyBeforeEnd;
pub const htmlAdjacencyAfterEnd = htmlAdjacency.htmlAdjacencyAfterEnd;
pub const htmlAdjacency_Max = htmlAdjacency.Max;

pub const htmlTabIndex = extern enum(i32) {
    htmlTabIndexNotSet = -32768,
    Max = 2147483647,
};
pub const htmlTabIndexNotSet = htmlTabIndex.htmlTabIndexNotSet;
pub const htmlTabIndex_Max = htmlTabIndex.Max;

pub const htmlComponent = extern enum(i32) {
    htmlComponentClient = 0,
    htmlComponentSbLeft = 1,
    htmlComponentSbPageLeft = 2,
    htmlComponentSbHThumb = 3,
    htmlComponentSbPageRight = 4,
    htmlComponentSbRight = 5,
    htmlComponentSbUp = 6,
    htmlComponentSbPageUp = 7,
    htmlComponentSbVThumb = 8,
    htmlComponentSbPageDown = 9,
    htmlComponentSbDown = 10,
    htmlComponentSbLeft2 = 11,
    htmlComponentSbPageLeft2 = 12,
    htmlComponentSbRight2 = 13,
    htmlComponentSbPageRight2 = 14,
    htmlComponentSbUp2 = 15,
    htmlComponentSbPageUp2 = 16,
    htmlComponentSbDown2 = 17,
    htmlComponentSbPageDown2 = 18,
    htmlComponentSbTop = 19,
    htmlComponentSbBottom = 20,
    htmlComponentOutside = 21,
    htmlComponentGHTopLeft = 22,
    htmlComponentGHLeft = 23,
    htmlComponentGHTop = 24,
    htmlComponentGHBottomLeft = 25,
    htmlComponentGHTopRight = 26,
    htmlComponentGHBottom = 27,
    htmlComponentGHRight = 28,
    htmlComponentGHBottomRight = 29,
    Max = 2147483647,
};
pub const htmlComponentClient = htmlComponent.htmlComponentClient;
pub const htmlComponentSbLeft = htmlComponent.htmlComponentSbLeft;
pub const htmlComponentSbPageLeft = htmlComponent.htmlComponentSbPageLeft;
pub const htmlComponentSbHThumb = htmlComponent.htmlComponentSbHThumb;
pub const htmlComponentSbPageRight = htmlComponent.htmlComponentSbPageRight;
pub const htmlComponentSbRight = htmlComponent.htmlComponentSbRight;
pub const htmlComponentSbUp = htmlComponent.htmlComponentSbUp;
pub const htmlComponentSbPageUp = htmlComponent.htmlComponentSbPageUp;
pub const htmlComponentSbVThumb = htmlComponent.htmlComponentSbVThumb;
pub const htmlComponentSbPageDown = htmlComponent.htmlComponentSbPageDown;
pub const htmlComponentSbDown = htmlComponent.htmlComponentSbDown;
pub const htmlComponentSbLeft2 = htmlComponent.htmlComponentSbLeft2;
pub const htmlComponentSbPageLeft2 = htmlComponent.htmlComponentSbPageLeft2;
pub const htmlComponentSbRight2 = htmlComponent.htmlComponentSbRight2;
pub const htmlComponentSbPageRight2 = htmlComponent.htmlComponentSbPageRight2;
pub const htmlComponentSbUp2 = htmlComponent.htmlComponentSbUp2;
pub const htmlComponentSbPageUp2 = htmlComponent.htmlComponentSbPageUp2;
pub const htmlComponentSbDown2 = htmlComponent.htmlComponentSbDown2;
pub const htmlComponentSbPageDown2 = htmlComponent.htmlComponentSbPageDown2;
pub const htmlComponentSbTop = htmlComponent.htmlComponentSbTop;
pub const htmlComponentSbBottom = htmlComponent.htmlComponentSbBottom;
pub const htmlComponentOutside = htmlComponent.htmlComponentOutside;
pub const htmlComponentGHTopLeft = htmlComponent.htmlComponentGHTopLeft;
pub const htmlComponentGHLeft = htmlComponent.htmlComponentGHLeft;
pub const htmlComponentGHTop = htmlComponent.htmlComponentGHTop;
pub const htmlComponentGHBottomLeft = htmlComponent.htmlComponentGHBottomLeft;
pub const htmlComponentGHTopRight = htmlComponent.htmlComponentGHTopRight;
pub const htmlComponentGHBottom = htmlComponent.htmlComponentGHBottom;
pub const htmlComponentGHRight = htmlComponent.htmlComponentGHRight;
pub const htmlComponentGHBottomRight = htmlComponent.htmlComponentGHBottomRight;
pub const htmlComponent_Max = htmlComponent.Max;

pub const htmlApplyLocation = extern enum(i32) {
    htmlApplyLocationInside = 0,
    htmlApplyLocationOutside = 1,
    Max = 2147483647,
};
pub const htmlApplyLocationInside = htmlApplyLocation.htmlApplyLocationInside;
pub const htmlApplyLocationOutside = htmlApplyLocation.htmlApplyLocationOutside;
pub const htmlApplyLocation_Max = htmlApplyLocation.Max;

pub const htmlGlyphMode = extern enum(i32) {
    htmlGlyphModeNone = 0,
    htmlGlyphModeBegin = 1,
    htmlGlyphModeEnd = 2,
    htmlGlyphModeBoth = 3,
    Max = 2147483647,
};
pub const htmlGlyphModeNone = htmlGlyphMode.htmlGlyphModeNone;
pub const htmlGlyphModeBegin = htmlGlyphMode.htmlGlyphModeBegin;
pub const htmlGlyphModeEnd = htmlGlyphMode.htmlGlyphModeEnd;
pub const htmlGlyphModeBoth = htmlGlyphMode.htmlGlyphModeBoth;
pub const htmlGlyphMode_Max = htmlGlyphMode.Max;

pub const htmlDraggable = extern enum(i32) {
    htmlDraggableAuto = 0,
    htmlDraggableTrue = 1,
    htmlDraggableFalse = 2,
    Max = 2147483647,
};
pub const htmlDraggableAuto = htmlDraggable.htmlDraggableAuto;
pub const htmlDraggableTrue = htmlDraggable.htmlDraggableTrue;
pub const htmlDraggableFalse = htmlDraggable.htmlDraggableFalse;
pub const htmlDraggable_Max = htmlDraggable.Max;

pub const htmlUnit = extern enum(i32) {
    htmlUnitCharacter = 1,
    htmlUnitWord = 2,
    htmlUnitSentence = 3,
    htmlUnitTextEdit = 6,
    Max = 2147483647,
};
pub const htmlUnitCharacter = htmlUnit.htmlUnitCharacter;
pub const htmlUnitWord = htmlUnit.htmlUnitWord;
pub const htmlUnitSentence = htmlUnit.htmlUnitSentence;
pub const htmlUnitTextEdit = htmlUnit.htmlUnitTextEdit;
pub const htmlUnit_Max = htmlUnit.Max;

pub const htmlEndPoints = extern enum(i32) {
    htmlEndPointsStartToStart = 1,
    htmlEndPointsStartToEnd = 2,
    htmlEndPointsEndToStart = 3,
    htmlEndPointsEndToEnd = 4,
    Max = 2147483647,
};
pub const htmlEndPointsStartToStart = htmlEndPoints.htmlEndPointsStartToStart;
pub const htmlEndPointsStartToEnd = htmlEndPoints.htmlEndPointsStartToEnd;
pub const htmlEndPointsEndToStart = htmlEndPoints.htmlEndPointsEndToStart;
pub const htmlEndPointsEndToEnd = htmlEndPoints.htmlEndPointsEndToEnd;
pub const htmlEndPoints_Max = htmlEndPoints.Max;

pub const htmlDirection = extern enum(i32) {
    htmlDirectionForward = 99999,
    htmlDirectionBackward = -99999,
    Max = 2147483647,
};
pub const htmlDirectionForward = htmlDirection.htmlDirectionForward;
pub const htmlDirectionBackward = htmlDirection.htmlDirectionBackward;
pub const htmlDirection_Max = htmlDirection.Max;

pub const htmlStart = extern enum(i32) {
    htmlStartfileopen = 0,
    htmlStartmouseover = 1,
    Max = 2147483647,
};
pub const htmlStartfileopen = htmlStart.htmlStartfileopen;
pub const htmlStartmouseover = htmlStart.htmlStartmouseover;
pub const htmlStart_Max = htmlStart.Max;

pub const bodyScroll = extern enum(i32) {
    bodyScrollyes = 1,
    bodyScrollno = 2,
    bodyScrollauto = 4,
    bodyScrolldefault = 3,
    Max = 2147483647,
};
pub const bodyScrollyes = bodyScroll.bodyScrollyes;
pub const bodyScrollno = bodyScroll.bodyScrollno;
pub const bodyScrollauto = bodyScroll.bodyScrollauto;
pub const bodyScrolldefault = bodyScroll.bodyScrolldefault;
pub const bodyScroll_Max = bodyScroll.Max;

pub const htmlSelectType = extern enum(i32) {
    htmlSelectTypeSelectOne = 1,
    htmlSelectTypeSelectMultiple = 2,
    Max = 2147483647,
};
pub const htmlSelectTypeSelectOne = htmlSelectType.htmlSelectTypeSelectOne;
pub const htmlSelectTypeSelectMultiple = htmlSelectType.htmlSelectTypeSelectMultiple;
pub const htmlSelectType_Max = htmlSelectType.Max;

pub const htmlSelectExFlag = extern enum(i32) {
    htmlSelectExFlagNone = 0,
    htmlSelectExFlagHideSelectionInDesign = 1,
    Max = 2147483647,
};
pub const htmlSelectExFlagNone = htmlSelectExFlag.htmlSelectExFlagNone;
pub const htmlSelectExFlagHideSelectionInDesign = htmlSelectExFlag.htmlSelectExFlagHideSelectionInDesign;
pub const htmlSelectExFlag_Max = htmlSelectExFlag.Max;

pub const htmlSelection = extern enum(i32) {
    htmlSelectionNone = 0,
    htmlSelectionText = 1,
    htmlSelectionControl = 2,
    htmlSelectionTable = 3,
    Max = 2147483647,
};
pub const htmlSelectionNone = htmlSelection.htmlSelectionNone;
pub const htmlSelectionText = htmlSelection.htmlSelectionText;
pub const htmlSelectionControl = htmlSelection.htmlSelectionControl;
pub const htmlSelectionTable = htmlSelection.htmlSelectionTable;
pub const htmlSelection_Max = htmlSelection.Max;

pub const htmlMarqueeBehavior = extern enum(i32) {
    htmlMarqueeBehaviorscroll = 1,
    htmlMarqueeBehaviorslide = 2,
    htmlMarqueeBehavioralternate = 3,
    Max = 2147483647,
};
pub const htmlMarqueeBehaviorscroll = htmlMarqueeBehavior.htmlMarqueeBehaviorscroll;
pub const htmlMarqueeBehaviorslide = htmlMarqueeBehavior.htmlMarqueeBehaviorslide;
pub const htmlMarqueeBehavioralternate = htmlMarqueeBehavior.htmlMarqueeBehavioralternate;
pub const htmlMarqueeBehavior_Max = htmlMarqueeBehavior.Max;

pub const htmlMarqueeDirection = extern enum(i32) {
    htmlMarqueeDirectionleft = 1,
    htmlMarqueeDirectionright = 3,
    htmlMarqueeDirectionup = 5,
    htmlMarqueeDirectiondown = 7,
    Max = 2147483647,
};
pub const htmlMarqueeDirectionleft = htmlMarqueeDirection.htmlMarqueeDirectionleft;
pub const htmlMarqueeDirectionright = htmlMarqueeDirection.htmlMarqueeDirectionright;
pub const htmlMarqueeDirectionup = htmlMarqueeDirection.htmlMarqueeDirectionup;
pub const htmlMarqueeDirectiondown = htmlMarqueeDirection.htmlMarqueeDirectiondown;
pub const htmlMarqueeDirection_Max = htmlMarqueeDirection.Max;

pub const htmlPersistState = extern enum(i32) {
    htmlPersistStateNormal = 0,
    htmlPersistStateFavorite = 1,
    htmlPersistStateHistory = 2,
    htmlPersistStateSnapshot = 3,
    htmlPersistStateUserData = 4,
    Max = 2147483647,
};
pub const htmlPersistStateNormal = htmlPersistState.htmlPersistStateNormal;
pub const htmlPersistStateFavorite = htmlPersistState.htmlPersistStateFavorite;
pub const htmlPersistStateHistory = htmlPersistState.htmlPersistStateHistory;
pub const htmlPersistStateSnapshot = htmlPersistState.htmlPersistStateSnapshot;
pub const htmlPersistStateUserData = htmlPersistState.htmlPersistStateUserData;
pub const htmlPersistState_Max = htmlPersistState.Max;

pub const htmlDropEffect = extern enum(i32) {
    htmlDropEffectCopy = 0,
    htmlDropEffectLink = 1,
    htmlDropEffectMove = 2,
    htmlDropEffectNone = 3,
    Max = 2147483647,
};
pub const htmlDropEffectCopy = htmlDropEffect.htmlDropEffectCopy;
pub const htmlDropEffectLink = htmlDropEffect.htmlDropEffectLink;
pub const htmlDropEffectMove = htmlDropEffect.htmlDropEffectMove;
pub const htmlDropEffectNone = htmlDropEffect.htmlDropEffectNone;
pub const htmlDropEffect_Max = htmlDropEffect.Max;

pub const htmlEffectAllowed = extern enum(i32) {
    htmlEffectAllowedCopy = 0,
    htmlEffectAllowedLink = 1,
    htmlEffectAllowedMove = 2,
    htmlEffectAllowedCopyLink = 3,
    htmlEffectAllowedCopyMove = 4,
    htmlEffectAllowedLinkMove = 5,
    htmlEffectAllowedAll = 6,
    htmlEffectAllowedNone = 7,
    htmlEffectAllowedUninitialized = 8,
    Max = 2147483647,
};
pub const htmlEffectAllowedCopy = htmlEffectAllowed.htmlEffectAllowedCopy;
pub const htmlEffectAllowedLink = htmlEffectAllowed.htmlEffectAllowedLink;
pub const htmlEffectAllowedMove = htmlEffectAllowed.htmlEffectAllowedMove;
pub const htmlEffectAllowedCopyLink = htmlEffectAllowed.htmlEffectAllowedCopyLink;
pub const htmlEffectAllowedCopyMove = htmlEffectAllowed.htmlEffectAllowedCopyMove;
pub const htmlEffectAllowedLinkMove = htmlEffectAllowed.htmlEffectAllowedLinkMove;
pub const htmlEffectAllowedAll = htmlEffectAllowed.htmlEffectAllowedAll;
pub const htmlEffectAllowedNone = htmlEffectAllowed.htmlEffectAllowedNone;
pub const htmlEffectAllowedUninitialized = htmlEffectAllowed.htmlEffectAllowedUninitialized;
pub const htmlEffectAllowed_Max = htmlEffectAllowed.Max;

pub const htmlCompatMode = extern enum(i32) {
    htmlCompatModeBackCompat = 0,
    htmlCompatModeCSS1Compat = 1,
    Max = 2147483647,
};
pub const htmlCompatModeBackCompat = htmlCompatMode.htmlCompatModeBackCompat;
pub const htmlCompatModeCSS1Compat = htmlCompatMode.htmlCompatModeCSS1Compat;
pub const htmlCompatMode_Max = htmlCompatMode.Max;

pub const BoolValue = extern enum(i32) {
    True = 1,
    False = 0,
    Max = 2147483647,
};
pub const True = BoolValue.True;
pub const False = BoolValue.False;
pub const BoolValue_Max = BoolValue.Max;

pub const htmlCaptionAlign = extern enum(i32) {
    htmlCaptionAlignNotSet = 0,
    htmlCaptionAlignLeft = 1,
    htmlCaptionAlignCenter = 2,
    htmlCaptionAlignRight = 3,
    htmlCaptionAlignJustify = 4,
    htmlCaptionAlignTop = 5,
    htmlCaptionAlignBottom = 6,
    Max = 2147483647,
};
pub const htmlCaptionAlignNotSet = htmlCaptionAlign.htmlCaptionAlignNotSet;
pub const htmlCaptionAlignLeft = htmlCaptionAlign.htmlCaptionAlignLeft;
pub const htmlCaptionAlignCenter = htmlCaptionAlign.htmlCaptionAlignCenter;
pub const htmlCaptionAlignRight = htmlCaptionAlign.htmlCaptionAlignRight;
pub const htmlCaptionAlignJustify = htmlCaptionAlign.htmlCaptionAlignJustify;
pub const htmlCaptionAlignTop = htmlCaptionAlign.htmlCaptionAlignTop;
pub const htmlCaptionAlignBottom = htmlCaptionAlign.htmlCaptionAlignBottom;
pub const htmlCaptionAlign_Max = htmlCaptionAlign.Max;

pub const htmlCaptionVAlign = extern enum(i32) {
    htmlCaptionVAlignNotSet = 0,
    htmlCaptionVAlignTop = 1,
    htmlCaptionVAlignBottom = 2,
    Max = 2147483647,
};
pub const htmlCaptionVAlignNotSet = htmlCaptionVAlign.htmlCaptionVAlignNotSet;
pub const htmlCaptionVAlignTop = htmlCaptionVAlign.htmlCaptionVAlignTop;
pub const htmlCaptionVAlignBottom = htmlCaptionVAlign.htmlCaptionVAlignBottom;
pub const htmlCaptionVAlign_Max = htmlCaptionVAlign.Max;

pub const htmlFrame = extern enum(i32) {
    htmlFrameNotSet = 0,
    htmlFramevoid = 1,
    htmlFrameabove = 2,
    htmlFramebelow = 3,
    htmlFramehsides = 4,
    htmlFramelhs = 5,
    htmlFramerhs = 6,
    htmlFramevsides = 7,
    htmlFramebox = 8,
    htmlFrameborder = 9,
    Max = 2147483647,
};
pub const htmlFrameNotSet = htmlFrame.htmlFrameNotSet;
pub const htmlFramevoid = htmlFrame.htmlFramevoid;
pub const htmlFrameabove = htmlFrame.htmlFrameabove;
pub const htmlFramebelow = htmlFrame.htmlFramebelow;
pub const htmlFramehsides = htmlFrame.htmlFramehsides;
pub const htmlFramelhs = htmlFrame.htmlFramelhs;
pub const htmlFramerhs = htmlFrame.htmlFramerhs;
pub const htmlFramevsides = htmlFrame.htmlFramevsides;
pub const htmlFramebox = htmlFrame.htmlFramebox;
pub const htmlFrameborder = htmlFrame.htmlFrameborder;
pub const htmlFrame_Max = htmlFrame.Max;

pub const htmlRules = extern enum(i32) {
    htmlRulesNotSet = 0,
    htmlRulesnone = 1,
    htmlRulesgroups = 2,
    htmlRulesrows = 3,
    htmlRulescols = 4,
    htmlRulesall = 5,
    Max = 2147483647,
};
pub const htmlRulesNotSet = htmlRules.htmlRulesNotSet;
pub const htmlRulesnone = htmlRules.htmlRulesnone;
pub const htmlRulesgroups = htmlRules.htmlRulesgroups;
pub const htmlRulesrows = htmlRules.htmlRulesrows;
pub const htmlRulescols = htmlRules.htmlRulescols;
pub const htmlRulesall = htmlRules.htmlRulesall;
pub const htmlRules_Max = htmlRules.Max;

pub const htmlCellAlign = extern enum(i32) {
    htmlCellAlignNotSet = 0,
    htmlCellAlignLeft = 1,
    htmlCellAlignCenter = 2,
    htmlCellAlignRight = 3,
    htmlCellAlignMiddle = 2,
    Max = 2147483647,
};
pub const htmlCellAlignNotSet = htmlCellAlign.htmlCellAlignNotSet;
pub const htmlCellAlignLeft = htmlCellAlign.htmlCellAlignLeft;
pub const htmlCellAlignCenter = htmlCellAlign.htmlCellAlignCenter;
pub const htmlCellAlignRight = htmlCellAlign.htmlCellAlignRight;
pub const htmlCellAlignMiddle = htmlCellAlign.htmlCellAlignMiddle;
pub const htmlCellAlign_Max = htmlCellAlign.Max;

pub const htmlCellVAlign = extern enum(i32) {
    htmlCellVAlignNotSet = 0,
    htmlCellVAlignTop = 1,
    htmlCellVAlignMiddle = 2,
    htmlCellVAlignBottom = 3,
    htmlCellVAlignBaseline = 4,
    htmlCellVAlignCenter = 2,
    Max = 2147483647,
};
pub const htmlCellVAlignNotSet = htmlCellVAlign.htmlCellVAlignNotSet;
pub const htmlCellVAlignTop = htmlCellVAlign.htmlCellVAlignTop;
pub const htmlCellVAlignMiddle = htmlCellVAlign.htmlCellVAlignMiddle;
pub const htmlCellVAlignBottom = htmlCellVAlign.htmlCellVAlignBottom;
pub const htmlCellVAlignBaseline = htmlCellVAlign.htmlCellVAlignBaseline;
pub const htmlCellVAlignCenter = htmlCellVAlign.htmlCellVAlignCenter;
pub const htmlCellVAlign_Max = htmlCellVAlign.Max;

pub const frameScrolling = extern enum(i32) {
    frameScrollingyes = 1,
    frameScrollingno = 2,
    frameScrollingauto = 4,
    Max = 2147483647,
};
pub const frameScrollingyes = frameScrolling.frameScrollingyes;
pub const frameScrollingno = frameScrolling.frameScrollingno;
pub const frameScrollingauto = frameScrolling.frameScrollingauto;
pub const frameScrolling_Max = frameScrolling.Max;

pub const sandboxAllow = extern enum(i32) {
    sandboxAllowScripts = 0,
    sandboxAllowSameOrigin = 1,
    sandboxAllowTopNavigation = 2,
    sandboxAllowForms = 3,
    sandboxAllowPopups = 4,
    Max = 2147483647,
};
pub const sandboxAllowScripts = sandboxAllow.sandboxAllowScripts;
pub const sandboxAllowSameOrigin = sandboxAllow.sandboxAllowSameOrigin;
pub const sandboxAllowTopNavigation = sandboxAllow.sandboxAllowTopNavigation;
pub const sandboxAllowForms = sandboxAllow.sandboxAllowForms;
pub const sandboxAllowPopups = sandboxAllow.sandboxAllowPopups;
pub const sandboxAllow_Max = sandboxAllow.Max;

pub const svgAngleType = extern enum(i32) {
    SVG_ANGLETYPE_UNKNOWN = 0,
    SVG_ANGLETYPE_UNSPECIFIED = 1,
    SVG_ANGLETYPE_DEG = 2,
    SVG_ANGLETYPE_RAD = 3,
    SVG_ANGLETYPE_GRAD = 4,
    Max = 2147483647,
};
pub const SVG_ANGLETYPE_UNKNOWN = svgAngleType.SVG_ANGLETYPE_UNKNOWN;
pub const SVG_ANGLETYPE_UNSPECIFIED = svgAngleType.SVG_ANGLETYPE_UNSPECIFIED;
pub const SVG_ANGLETYPE_DEG = svgAngleType.SVG_ANGLETYPE_DEG;
pub const SVG_ANGLETYPE_RAD = svgAngleType.SVG_ANGLETYPE_RAD;
pub const SVG_ANGLETYPE_GRAD = svgAngleType.SVG_ANGLETYPE_GRAD;
pub const svgAngleType_Max = svgAngleType.Max;

pub const svgExternalResourcesRequired = extern enum(i32) {
    svgExternalResourcesRequiredFalse = 0,
    svgExternalResourcesRequiredTrue = 1,
    Max = 2147483647,
};
pub const svgExternalResourcesRequiredFalse = svgExternalResourcesRequired.svgExternalResourcesRequiredFalse;
pub const svgExternalResourcesRequiredTrue = svgExternalResourcesRequired.svgExternalResourcesRequiredTrue;
pub const svgExternalResourcesRequired_Max = svgExternalResourcesRequired.Max;

pub const svgFocusable = extern enum(i32) {
    svgFocusableNotSet = 0,
    svgFocusableAuto = 1,
    svgFocusableTrue = 2,
    svgFocusableFalse = 3,
    Max = 2147483647,
};
pub const svgFocusableNotSet = svgFocusable.svgFocusableNotSet;
pub const svgFocusableAuto = svgFocusable.svgFocusableAuto;
pub const svgFocusableTrue = svgFocusable.svgFocusableTrue;
pub const svgFocusableFalse = svgFocusable.svgFocusableFalse;
pub const svgFocusable_Max = svgFocusable.Max;

pub const svgLengthType = extern enum(i32) {
    SVG_LENGTHTYPE_UNKNOWN = 0,
    SVG_LENGTHTYPE_NUMBER = 1,
    SVG_LENGTHTYPE_PERCENTAGE = 2,
    SVG_LENGTHTYPE_EMS = 3,
    SVG_LENGTHTYPE_EXS = 4,
    SVG_LENGTHTYPE_PX = 5,
    SVG_LENGTHTYPE_CM = 6,
    SVG_LENGTHTYPE_MM = 7,
    SVG_LENGTHTYPE_IN = 8,
    SVG_LENGTHTYPE_PT = 9,
    SVG_LENGTHTYPE_PC = 10,
    Max = 2147483647,
};
pub const SVG_LENGTHTYPE_UNKNOWN = svgLengthType.SVG_LENGTHTYPE_UNKNOWN;
pub const SVG_LENGTHTYPE_NUMBER = svgLengthType.SVG_LENGTHTYPE_NUMBER;
pub const SVG_LENGTHTYPE_PERCENTAGE = svgLengthType.SVG_LENGTHTYPE_PERCENTAGE;
pub const SVG_LENGTHTYPE_EMS = svgLengthType.SVG_LENGTHTYPE_EMS;
pub const SVG_LENGTHTYPE_EXS = svgLengthType.SVG_LENGTHTYPE_EXS;
pub const SVG_LENGTHTYPE_PX = svgLengthType.SVG_LENGTHTYPE_PX;
pub const SVG_LENGTHTYPE_CM = svgLengthType.SVG_LENGTHTYPE_CM;
pub const SVG_LENGTHTYPE_MM = svgLengthType.SVG_LENGTHTYPE_MM;
pub const SVG_LENGTHTYPE_IN = svgLengthType.SVG_LENGTHTYPE_IN;
pub const SVG_LENGTHTYPE_PT = svgLengthType.SVG_LENGTHTYPE_PT;
pub const SVG_LENGTHTYPE_PC = svgLengthType.SVG_LENGTHTYPE_PC;
pub const svgLengthType_Max = svgLengthType.Max;

pub const svgPathSegType = extern enum(i32) {
    PATHSEG_UNKNOWN = 0,
    PATHSEG_CLOSEPATH = 1,
    PATHSEG_MOVETO_ABS = 2,
    PATHSEG_MOVETO_REL = 3,
    PATHSEG_LINETO_ABS = 4,
    PATHSEG_LINETO_REL = 5,
    PATHSEG_CURVETO_CUBIC_ABS = 6,
    PATHSEG_CURVETO_CUBIC_REL = 7,
    PATHSEG_CURVETO_QUADRATIC_ABS = 8,
    PATHSEG_CURVETO_QUADRATIC_REL = 9,
    PATHSEG_ARC_ABS = 10,
    PATHSEG_ARC_REL = 11,
    PATHSEG_LINETO_HORIZONTAL_ABS = 12,
    PATHSEG_LINETO_HORIZONTAL_REL = 13,
    PATHSEG_LINETO_VERTICAL_ABS = 14,
    PATHSEG_LINETO_VERTICAL_REL = 15,
    PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16,
    PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17,
    PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18,
    PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19,
    Max = 2147483647,
};
pub const PATHSEG_UNKNOWN = svgPathSegType.PATHSEG_UNKNOWN;
pub const PATHSEG_CLOSEPATH = svgPathSegType.PATHSEG_CLOSEPATH;
pub const PATHSEG_MOVETO_ABS = svgPathSegType.PATHSEG_MOVETO_ABS;
pub const PATHSEG_MOVETO_REL = svgPathSegType.PATHSEG_MOVETO_REL;
pub const PATHSEG_LINETO_ABS = svgPathSegType.PATHSEG_LINETO_ABS;
pub const PATHSEG_LINETO_REL = svgPathSegType.PATHSEG_LINETO_REL;
pub const PATHSEG_CURVETO_CUBIC_ABS = svgPathSegType.PATHSEG_CURVETO_CUBIC_ABS;
pub const PATHSEG_CURVETO_CUBIC_REL = svgPathSegType.PATHSEG_CURVETO_CUBIC_REL;
pub const PATHSEG_CURVETO_QUADRATIC_ABS = svgPathSegType.PATHSEG_CURVETO_QUADRATIC_ABS;
pub const PATHSEG_CURVETO_QUADRATIC_REL = svgPathSegType.PATHSEG_CURVETO_QUADRATIC_REL;
pub const PATHSEG_ARC_ABS = svgPathSegType.PATHSEG_ARC_ABS;
pub const PATHSEG_ARC_REL = svgPathSegType.PATHSEG_ARC_REL;
pub const PATHSEG_LINETO_HORIZONTAL_ABS = svgPathSegType.PATHSEG_LINETO_HORIZONTAL_ABS;
pub const PATHSEG_LINETO_HORIZONTAL_REL = svgPathSegType.PATHSEG_LINETO_HORIZONTAL_REL;
pub const PATHSEG_LINETO_VERTICAL_ABS = svgPathSegType.PATHSEG_LINETO_VERTICAL_ABS;
pub const PATHSEG_LINETO_VERTICAL_REL = svgPathSegType.PATHSEG_LINETO_VERTICAL_REL;
pub const PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = svgPathSegType.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
pub const PATHSEG_CURVETO_CUBIC_SMOOTH_REL = svgPathSegType.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
pub const PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = svgPathSegType.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
pub const PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = svgPathSegType.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
pub const svgPathSegType_Max = svgPathSegType.Max;

pub const svgTransformType = extern enum(i32) {
    SVG_TRANSFORM_UNKNOWN = 0,
    SVG_TRANSFORM_MATRIX = 1,
    SVG_TRANSFORM_TRANSLATE = 2,
    SVG_TRANSFORM_SCALE = 3,
    SVG_TRANSFORM_ROTATE = 4,
    SVG_TRANSFORM_SKEWX = 5,
    SVG_TRANSFORM_SKEWY = 6,
    Max = 2147483647,
};
pub const SVG_TRANSFORM_UNKNOWN = svgTransformType.SVG_TRANSFORM_UNKNOWN;
pub const SVG_TRANSFORM_MATRIX = svgTransformType.SVG_TRANSFORM_MATRIX;
pub const SVG_TRANSFORM_TRANSLATE = svgTransformType.SVG_TRANSFORM_TRANSLATE;
pub const SVG_TRANSFORM_SCALE = svgTransformType.SVG_TRANSFORM_SCALE;
pub const SVG_TRANSFORM_ROTATE = svgTransformType.SVG_TRANSFORM_ROTATE;
pub const SVG_TRANSFORM_SKEWX = svgTransformType.SVG_TRANSFORM_SKEWX;
pub const SVG_TRANSFORM_SKEWY = svgTransformType.SVG_TRANSFORM_SKEWY;
pub const svgTransformType_Max = svgTransformType.Max;

pub const svgPreserveAspectRatioAlignType = extern enum(i32) {
    SVG_PRESERVEASPECTRATIO_UNKNOWN = 0,
    SVG_PRESERVEASPECTRATIO_NONE = 1,
    SVG_PRESERVEASPECTRATIO_XMINYMIN = 2,
    SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3,
    SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4,
    SVG_PRESERVEASPECTRATIO_XMINYMID = 5,
    SVG_PRESERVEASPECTRATIO_XMIDYMID = 6,
    SVG_PRESERVEASPECTRATIO_XMAXYMID = 7,
    SVG_PRESERVEASPECTRATIO_XMINYMAX = 8,
    SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9,
    SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10,
    Max = 2147483647,
};
pub const SVG_PRESERVEASPECTRATIO_UNKNOWN = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_UNKNOWN;
pub const SVG_PRESERVEASPECTRATIO_NONE = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_NONE;
pub const SVG_PRESERVEASPECTRATIO_XMINYMIN = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMINYMIN;
pub const SVG_PRESERVEASPECTRATIO_XMIDYMIN = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMIDYMIN;
pub const SVG_PRESERVEASPECTRATIO_XMAXYMIN = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMAXYMIN;
pub const SVG_PRESERVEASPECTRATIO_XMINYMID = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMINYMID;
pub const SVG_PRESERVEASPECTRATIO_XMIDYMID = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMIDYMID;
pub const SVG_PRESERVEASPECTRATIO_XMAXYMID = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMAXYMID;
pub const SVG_PRESERVEASPECTRATIO_XMINYMAX = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMINYMAX;
pub const SVG_PRESERVEASPECTRATIO_XMIDYMAX = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMIDYMAX;
pub const SVG_PRESERVEASPECTRATIO_XMAXYMAX = svgPreserveAspectRatioAlignType.SVG_PRESERVEASPECTRATIO_XMAXYMAX;
pub const svgPreserveAspectRatioAlignType_Max = svgPreserveAspectRatioAlignType.Max;

pub const svgPreserveAspectMeetOrSliceType = extern enum(i32) {
    SVG_MEETORSLICE_UNKNOWN = 0,
    SVG_MEETORSLICE_MEET = 1,
    SVG_MEETORSLICE_SLICE = 2,
    Max = 2147483647,
};
pub const SVG_MEETORSLICE_UNKNOWN = svgPreserveAspectMeetOrSliceType.SVG_MEETORSLICE_UNKNOWN;
pub const SVG_MEETORSLICE_MEET = svgPreserveAspectMeetOrSliceType.SVG_MEETORSLICE_MEET;
pub const SVG_MEETORSLICE_SLICE = svgPreserveAspectMeetOrSliceType.SVG_MEETORSLICE_SLICE;
pub const svgPreserveAspectMeetOrSliceType_Max = svgPreserveAspectMeetOrSliceType.Max;

pub const svgUnitTypes = extern enum(i32) {
    SVG_UNITTYPE_UNKNOWN = 0,
    SVG_UNITTYPE_USERSPACEONUSE = 1,
    SVG_UNITTYPE_OBJECTBOUNDINGBOX = 2,
    Max = 2147483647,
};
pub const SVG_UNITTYPE_UNKNOWN = svgUnitTypes.SVG_UNITTYPE_UNKNOWN;
pub const SVG_UNITTYPE_USERSPACEONUSE = svgUnitTypes.SVG_UNITTYPE_USERSPACEONUSE;
pub const SVG_UNITTYPE_OBJECTBOUNDINGBOX = svgUnitTypes.SVG_UNITTYPE_OBJECTBOUNDINGBOX;
pub const svgUnitTypes_Max = svgUnitTypes.Max;

pub const svgSpreadMethod = extern enum(i32) {
    SVG_SPREADMETHOD_UNKNOWN = 0,
    SVG_SPREADMETHOD_PAD = 1,
    SVG_SPREADMETHOD_REFLECT = 2,
    SVG_SPREADMETHOD_REPEAT = 3,
    Max = 2147483647,
};
pub const SVG_SPREADMETHOD_UNKNOWN = svgSpreadMethod.SVG_SPREADMETHOD_UNKNOWN;
pub const SVG_SPREADMETHOD_PAD = svgSpreadMethod.SVG_SPREADMETHOD_PAD;
pub const SVG_SPREADMETHOD_REFLECT = svgSpreadMethod.SVG_SPREADMETHOD_REFLECT;
pub const SVG_SPREADMETHOD_REPEAT = svgSpreadMethod.SVG_SPREADMETHOD_REPEAT;
pub const svgSpreadMethod_Max = svgSpreadMethod.Max;

pub const svgFeblendMode = extern enum(i32) {
    SVG_FEBLEND_MODE_UNKNOWN = 0,
    SVG_FEBLEND_MODE_NORMAL = 1,
    SVG_FEBLEND_MODE_MULTIPLY = 2,
    SVG_FEBLEND_MODE_SCREEN = 3,
    SVG_FEBLEND_MODE_DARKEN = 4,
    SVG_FEBLEND_MODE_LIGHTEN = 5,
    Max = 2147483647,
};
pub const SVG_FEBLEND_MODE_UNKNOWN = svgFeblendMode.SVG_FEBLEND_MODE_UNKNOWN;
pub const SVG_FEBLEND_MODE_NORMAL = svgFeblendMode.SVG_FEBLEND_MODE_NORMAL;
pub const SVG_FEBLEND_MODE_MULTIPLY = svgFeblendMode.SVG_FEBLEND_MODE_MULTIPLY;
pub const SVG_FEBLEND_MODE_SCREEN = svgFeblendMode.SVG_FEBLEND_MODE_SCREEN;
pub const SVG_FEBLEND_MODE_DARKEN = svgFeblendMode.SVG_FEBLEND_MODE_DARKEN;
pub const SVG_FEBLEND_MODE_LIGHTEN = svgFeblendMode.SVG_FEBLEND_MODE_LIGHTEN;
pub const svgFeblendMode_Max = svgFeblendMode.Max;

pub const svgFecolormatrixType = extern enum(i32) {
    SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0,
    SVG_FECOLORMATRIX_TYPE_MATRIX = 1,
    SVG_FECOLORMATRIX_TYPE_SATURATE = 2,
    SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3,
    SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4,
    Max = 2147483647,
};
pub const SVG_FECOLORMATRIX_TYPE_UNKNOWN = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_UNKNOWN;
pub const SVG_FECOLORMATRIX_TYPE_MATRIX = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_MATRIX;
pub const SVG_FECOLORMATRIX_TYPE_SATURATE = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_SATURATE;
pub const SVG_FECOLORMATRIX_TYPE_HUEROTATE = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_HUEROTATE;
pub const SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = svgFecolormatrixType.SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA;
pub const svgFecolormatrixType_Max = svgFecolormatrixType.Max;

pub const svgFecomponenttransferType = extern enum(i32) {
    SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = 0,
    SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = 1,
    SVG_FECOMPONENTTRANSFER_TYPE_TABLE = 2,
    SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = 3,
    SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = 4,
    SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = 5,
    Max = 2147483647,
};
pub const SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN;
pub const SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY;
pub const SVG_FECOMPONENTTRANSFER_TYPE_TABLE = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_TABLE;
pub const SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE;
pub const SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_LINEAR;
pub const SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = svgFecomponenttransferType.SVG_FECOMPONENTTRANSFER_TYPE_GAMMA;
pub const svgFecomponenttransferType_Max = svgFecomponenttransferType.Max;

pub const svgFecompositeOperator = extern enum(i32) {
    SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0,
    SVG_FECOMPOSITE_OPERATOR_OVER = 1,
    SVG_FECOMPOSITE_OPERATOR_IN = 2,
    SVG_FECOMPOSITE_OPERATOR_OUT = 3,
    SVG_FECOMPOSITE_OPERATOR_ATOP = 4,
    SVG_FECOMPOSITE_OPERATOR_XOR = 5,
    SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6,
    Max = 2147483647,
};
pub const SVG_FECOMPOSITE_OPERATOR_UNKNOWN = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_UNKNOWN;
pub const SVG_FECOMPOSITE_OPERATOR_OVER = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_OVER;
pub const SVG_FECOMPOSITE_OPERATOR_IN = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_IN;
pub const SVG_FECOMPOSITE_OPERATOR_OUT = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_OUT;
pub const SVG_FECOMPOSITE_OPERATOR_ATOP = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_ATOP;
pub const SVG_FECOMPOSITE_OPERATOR_XOR = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_XOR;
pub const SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = svgFecompositeOperator.SVG_FECOMPOSITE_OPERATOR_ARITHMETIC;
pub const svgFecompositeOperator_Max = svgFecompositeOperator.Max;

pub const svgEdgemode = extern enum(i32) {
    SVG_EDGEMODE_UNKNOWN = 0,
    SVG_EDGEMODE_DUPLICATE = 1,
    SVG_EDGEMODE_WRAP = 2,
    SVG_EDGEMODE_NONE = 3,
    Max = 2147483647,
};
pub const SVG_EDGEMODE_UNKNOWN = svgEdgemode.SVG_EDGEMODE_UNKNOWN;
pub const SVG_EDGEMODE_DUPLICATE = svgEdgemode.SVG_EDGEMODE_DUPLICATE;
pub const SVG_EDGEMODE_WRAP = svgEdgemode.SVG_EDGEMODE_WRAP;
pub const SVG_EDGEMODE_NONE = svgEdgemode.SVG_EDGEMODE_NONE;
pub const svgEdgemode_Max = svgEdgemode.Max;

pub const svgPreserveAlpha = extern enum(i32) {
    SVG_PRESERVEALPHA_FALSE = 0,
    SVG_PRESERVEALPHA_TRUE = 1,
    Max = 2147483647,
};
pub const SVG_PRESERVEALPHA_FALSE = svgPreserveAlpha.SVG_PRESERVEALPHA_FALSE;
pub const SVG_PRESERVEALPHA_TRUE = svgPreserveAlpha.SVG_PRESERVEALPHA_TRUE;
pub const svgPreserveAlpha_Max = svgPreserveAlpha.Max;

pub const svgChannel = extern enum(i32) {
    SVG_CHANNEL_UNKNOWN = 0,
    SVG_CHANNEL_R = 1,
    SVG_CHANNEL_G = 2,
    SVG_CHANNEL_B = 3,
    SVG_CHANNEL_A = 4,
    Max = 2147483647,
};
pub const SVG_CHANNEL_UNKNOWN = svgChannel.SVG_CHANNEL_UNKNOWN;
pub const SVG_CHANNEL_R = svgChannel.SVG_CHANNEL_R;
pub const SVG_CHANNEL_G = svgChannel.SVG_CHANNEL_G;
pub const SVG_CHANNEL_B = svgChannel.SVG_CHANNEL_B;
pub const SVG_CHANNEL_A = svgChannel.SVG_CHANNEL_A;
pub const svgChannel_Max = svgChannel.Max;

pub const svgMorphologyOperator = extern enum(i32) {
    SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0,
    SVG_MORPHOLOGY_OPERATOR_ERODE = 1,
    SVG_MORPHOLOGY_OPERATOR_DILATE = 2,
    Max = 2147483647,
};
pub const SVG_MORPHOLOGY_OPERATOR_UNKNOWN = svgMorphologyOperator.SVG_MORPHOLOGY_OPERATOR_UNKNOWN;
pub const SVG_MORPHOLOGY_OPERATOR_ERODE = svgMorphologyOperator.SVG_MORPHOLOGY_OPERATOR_ERODE;
pub const SVG_MORPHOLOGY_OPERATOR_DILATE = svgMorphologyOperator.SVG_MORPHOLOGY_OPERATOR_DILATE;
pub const svgMorphologyOperator_Max = svgMorphologyOperator.Max;

pub const svgTurbulenceType = extern enum(i32) {
    SVG_TURBULENCE_TYPE_UNKNOWN = 0,
    SVG_TURBULENCE_TYPE_FACTALNOISE = 1,
    SVG_TURBULENCE_TYPE_TURBULENCE = 2,
    Max = 2147483647,
};
pub const SVG_TURBULENCE_TYPE_UNKNOWN = svgTurbulenceType.SVG_TURBULENCE_TYPE_UNKNOWN;
pub const SVG_TURBULENCE_TYPE_FACTALNOISE = svgTurbulenceType.SVG_TURBULENCE_TYPE_FACTALNOISE;
pub const SVG_TURBULENCE_TYPE_TURBULENCE = svgTurbulenceType.SVG_TURBULENCE_TYPE_TURBULENCE;
pub const svgTurbulenceType_Max = svgTurbulenceType.Max;

pub const svgStitchtype = extern enum(i32) {
    SVG_STITCHTYPE_UNKNOWN = 0,
    SVG_STITCHTYPE_STITCH = 1,
    SVG_STITCHTYPE_NOSTITCH = 2,
    Max = 2147483647,
};
pub const SVG_STITCHTYPE_UNKNOWN = svgStitchtype.SVG_STITCHTYPE_UNKNOWN;
pub const SVG_STITCHTYPE_STITCH = svgStitchtype.SVG_STITCHTYPE_STITCH;
pub const SVG_STITCHTYPE_NOSTITCH = svgStitchtype.SVG_STITCHTYPE_NOSTITCH;
pub const svgStitchtype_Max = svgStitchtype.Max;

pub const svgMarkerUnits = extern enum(i32) {
    SVG_MARKERUNITS_UNKNOWN = 0,
    SVG_MARKERUNITS_USERSPACEONUSE = 1,
    SVG_MARKERUNITS_STROKEWIDTH = 2,
    Max = 2147483647,
};
pub const SVG_MARKERUNITS_UNKNOWN = svgMarkerUnits.SVG_MARKERUNITS_UNKNOWN;
pub const SVG_MARKERUNITS_USERSPACEONUSE = svgMarkerUnits.SVG_MARKERUNITS_USERSPACEONUSE;
pub const SVG_MARKERUNITS_STROKEWIDTH = svgMarkerUnits.SVG_MARKERUNITS_STROKEWIDTH;
pub const svgMarkerUnits_Max = svgMarkerUnits.Max;

pub const svgMarkerOrient = extern enum(i32) {
    SVG_MARKER_ORIENT_UNKNOWN = 0,
    SVG_MARKER_ORIENT_AUTO = 1,
    SVG_MARKER_ORIENT_ANGLE = 2,
    Max = 2147483647,
};
pub const SVG_MARKER_ORIENT_UNKNOWN = svgMarkerOrient.SVG_MARKER_ORIENT_UNKNOWN;
pub const SVG_MARKER_ORIENT_AUTO = svgMarkerOrient.SVG_MARKER_ORIENT_AUTO;
pub const SVG_MARKER_ORIENT_ANGLE = svgMarkerOrient.SVG_MARKER_ORIENT_ANGLE;
pub const svgMarkerOrient_Max = svgMarkerOrient.Max;

pub const svgMarkerOrientAttribute = extern enum(i32) {
    svgMarkerOrientAttributeAuto = 0,
    Max = 2147483647,
};
pub const svgMarkerOrientAttributeAuto = svgMarkerOrientAttribute.svgMarkerOrientAttributeAuto;
pub const svgMarkerOrientAttribute_Max = svgMarkerOrientAttribute.Max;

pub const htmlMediaNetworkState = extern enum(i32) {
    htmlMediaNetworkStateEmpty = 0,
    htmlMediaNetworkStateIdle = 1,
    htmlMediaNetworkStateLoading = 2,
    htmlMediaNetworkStateNoSource = 3,
    Max = 2147483647,
};
pub const htmlMediaNetworkStateEmpty = htmlMediaNetworkState.htmlMediaNetworkStateEmpty;
pub const htmlMediaNetworkStateIdle = htmlMediaNetworkState.htmlMediaNetworkStateIdle;
pub const htmlMediaNetworkStateLoading = htmlMediaNetworkState.htmlMediaNetworkStateLoading;
pub const htmlMediaNetworkStateNoSource = htmlMediaNetworkState.htmlMediaNetworkStateNoSource;
pub const htmlMediaNetworkState_Max = htmlMediaNetworkState.Max;

pub const htmlMediaReadyState = extern enum(i32) {
    htmlMediaReadyStateHaveNothing = 0,
    htmlMediaReadyStateHaveMetadata = 1,
    htmlMediaReadyStateHaveCurrentData = 2,
    htmlMediaReadyStateHaveFutureData = 3,
    htmlMediaReadyStateHaveEnoughData = 4,
    Max = 2147483647,
};
pub const htmlMediaReadyStateHaveNothing = htmlMediaReadyState.htmlMediaReadyStateHaveNothing;
pub const htmlMediaReadyStateHaveMetadata = htmlMediaReadyState.htmlMediaReadyStateHaveMetadata;
pub const htmlMediaReadyStateHaveCurrentData = htmlMediaReadyState.htmlMediaReadyStateHaveCurrentData;
pub const htmlMediaReadyStateHaveFutureData = htmlMediaReadyState.htmlMediaReadyStateHaveFutureData;
pub const htmlMediaReadyStateHaveEnoughData = htmlMediaReadyState.htmlMediaReadyStateHaveEnoughData;
pub const htmlMediaReadyState_Max = htmlMediaReadyState.Max;

pub const htmlMediaErr = extern enum(i32) {
    htmlMediaErrAborted = 0,
    htmlMediaErrNetwork = 1,
    htmlMediaErrDecode = 2,
    htmlMediaErrSrcNotSupported = 3,
    Max = 2147483647,
};
pub const htmlMediaErrAborted = htmlMediaErr.htmlMediaErrAborted;
pub const htmlMediaErrNetwork = htmlMediaErr.htmlMediaErrNetwork;
pub const htmlMediaErrDecode = htmlMediaErr.htmlMediaErrDecode;
pub const htmlMediaErrSrcNotSupported = htmlMediaErr.htmlMediaErrSrcNotSupported;
pub const htmlMediaErr_Max = htmlMediaErr.Max;

pub const lengthAdjust = extern enum(i32) {
    LENGTHADJUST_UNKNOWN = 0,
    LENGTHADJUST_SPACING = 1,
    LENGTHADJUST_SPACINGANDGLYPHS = 2,
    Max = 2147483647,
};
pub const LENGTHADJUST_UNKNOWN = lengthAdjust.LENGTHADJUST_UNKNOWN;
pub const LENGTHADJUST_SPACING = lengthAdjust.LENGTHADJUST_SPACING;
pub const LENGTHADJUST_SPACINGANDGLYPHS = lengthAdjust.LENGTHADJUST_SPACINGANDGLYPHS;
pub const lengthAdjust_Max = lengthAdjust.Max;

pub const textpathMethodtype = extern enum(i32) {
    TEXTPATH_METHODTYPE_UNKNOWN = 0,
    TEXTPATH_METHODTYPE_ALIGN = 1,
    TEXTPATH_METHODTYPE_STRETCH = 2,
    Max = 2147483647,
};
pub const TEXTPATH_METHODTYPE_UNKNOWN = textpathMethodtype.TEXTPATH_METHODTYPE_UNKNOWN;
pub const TEXTPATH_METHODTYPE_ALIGN = textpathMethodtype.TEXTPATH_METHODTYPE_ALIGN;
pub const TEXTPATH_METHODTYPE_STRETCH = textpathMethodtype.TEXTPATH_METHODTYPE_STRETCH;
pub const textpathMethodtype_Max = textpathMethodtype.Max;

pub const textpathSpacingtype = extern enum(i32) {
    TEXTPATH_SPACINGTYPE_UNKNOWN = 0,
    TEXTPATH_SPACINGTYPE_AUTO = 1,
    TEXTPATH_SPACINGTYPE_EXACT = 2,
    Max = 2147483647,
};
pub const TEXTPATH_SPACINGTYPE_UNKNOWN = textpathSpacingtype.TEXTPATH_SPACINGTYPE_UNKNOWN;
pub const TEXTPATH_SPACINGTYPE_AUTO = textpathSpacingtype.TEXTPATH_SPACINGTYPE_AUTO;
pub const TEXTPATH_SPACINGTYPE_EXACT = textpathSpacingtype.TEXTPATH_SPACINGTYPE_EXACT;
pub const textpathSpacingtype_Max = textpathSpacingtype.Max;

pub const ELEMENT_CORNER = extern enum(i32) {
    NONE = 0,
    TOP = 1,
    LEFT = 2,
    BOTTOM = 3,
    RIGHT = 4,
    TOPLEFT = 5,
    TOPRIGHT = 6,
    BOTTOMLEFT = 7,
    BOTTOMRIGHT = 8,
    Max = 2147483647,
};
pub const ELEMENT_CORNER_NONE = ELEMENT_CORNER.NONE;
pub const ELEMENT_CORNER_TOP = ELEMENT_CORNER.TOP;
pub const ELEMENT_CORNER_LEFT = ELEMENT_CORNER.LEFT;
pub const ELEMENT_CORNER_BOTTOM = ELEMENT_CORNER.BOTTOM;
pub const ELEMENT_CORNER_RIGHT = ELEMENT_CORNER.RIGHT;
pub const ELEMENT_CORNER_TOPLEFT = ELEMENT_CORNER.TOPLEFT;
pub const ELEMENT_CORNER_TOPRIGHT = ELEMENT_CORNER.TOPRIGHT;
pub const ELEMENT_CORNER_BOTTOMLEFT = ELEMENT_CORNER.BOTTOMLEFT;
pub const ELEMENT_CORNER_BOTTOMRIGHT = ELEMENT_CORNER.BOTTOMRIGHT;
pub const ELEMENT_CORNER_Max = ELEMENT_CORNER.Max;

pub const SECUREURLHOSTVALIDATE_FLAGS = extern enum(i32) {
    SUHV_PROMPTBEFORENO = 1,
    SUHV_SILENTYES = 2,
    SUHV_UNSECURESOURCE = 4,
    Max = 2147483647,
};
pub const SUHV_PROMPTBEFORENO = SECUREURLHOSTVALIDATE_FLAGS.SUHV_PROMPTBEFORENO;
pub const SUHV_SILENTYES = SECUREURLHOSTVALIDATE_FLAGS.SUHV_SILENTYES;
pub const SUHV_UNSECURESOURCE = SECUREURLHOSTVALIDATE_FLAGS.SUHV_UNSECURESOURCE;
pub const SECUREURLHOSTVALIDATE_FLAGS_Max = SECUREURLHOSTVALIDATE_FLAGS.Max;

pub const POINTER_GRAVITY = extern enum(i32) {
    Left = 0,
    Right = 1,
    Max = 2147483647,
};
pub const POINTER_GRAVITY_Left = POINTER_GRAVITY.Left;
pub const POINTER_GRAVITY_Right = POINTER_GRAVITY.Right;
pub const POINTER_GRAVITY_Max = POINTER_GRAVITY.Max;

pub const ELEMENT_ADJACENCY = extern enum(i32) {
    ELEM_ADJ_BeforeBegin = 0,
    ELEM_ADJ_AfterBegin = 1,
    ELEM_ADJ_BeforeEnd = 2,
    ELEM_ADJ_AfterEnd = 3,
    Max = 2147483647,
};
pub const ELEM_ADJ_BeforeBegin = ELEMENT_ADJACENCY.ELEM_ADJ_BeforeBegin;
pub const ELEM_ADJ_AfterBegin = ELEMENT_ADJACENCY.ELEM_ADJ_AfterBegin;
pub const ELEM_ADJ_BeforeEnd = ELEMENT_ADJACENCY.ELEM_ADJ_BeforeEnd;
pub const ELEM_ADJ_AfterEnd = ELEMENT_ADJACENCY.ELEM_ADJ_AfterEnd;
pub const ELEMENT_ADJACENCY_Max = ELEMENT_ADJACENCY.Max;

pub const MARKUP_CONTEXT_TYPE = extern enum(i32) {
    CONTEXT_TYPE_None = 0,
    CONTEXT_TYPE_Text = 1,
    CONTEXT_TYPE_EnterScope = 2,
    CONTEXT_TYPE_ExitScope = 3,
    CONTEXT_TYPE_NoScope = 4,
    Max = 2147483647,
};
pub const CONTEXT_TYPE_None = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_None;
pub const CONTEXT_TYPE_Text = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_Text;
pub const CONTEXT_TYPE_EnterScope = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_EnterScope;
pub const CONTEXT_TYPE_ExitScope = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_ExitScope;
pub const CONTEXT_TYPE_NoScope = MARKUP_CONTEXT_TYPE.CONTEXT_TYPE_NoScope;
pub const MARKUP_CONTEXT_TYPE_Max = MARKUP_CONTEXT_TYPE.Max;

pub const FINDTEXT_FLAGS = extern enum(i32) {
    FINDTEXT_BACKWARDS = 1,
    FINDTEXT_WHOLEWORD = 2,
    FINDTEXT_MATCHCASE = 4,
    FINDTEXT_RAW = 131072,
    FINDTEXT_MATCHREPEATEDWHITESPACE = 262144,
    FINDTEXT_MATCHDIAC = 536870912,
    FINDTEXT_MATCHKASHIDA = 1073741824,
    FINDTEXT_MATCHALEFHAMZA = -2147483648,
    Max = 2147483647,
};
pub const FINDTEXT_BACKWARDS = FINDTEXT_FLAGS.FINDTEXT_BACKWARDS;
pub const FINDTEXT_WHOLEWORD = FINDTEXT_FLAGS.FINDTEXT_WHOLEWORD;
pub const FINDTEXT_MATCHCASE = FINDTEXT_FLAGS.FINDTEXT_MATCHCASE;
pub const FINDTEXT_RAW = FINDTEXT_FLAGS.FINDTEXT_RAW;
pub const FINDTEXT_MATCHREPEATEDWHITESPACE = FINDTEXT_FLAGS.FINDTEXT_MATCHREPEATEDWHITESPACE;
pub const FINDTEXT_MATCHDIAC = FINDTEXT_FLAGS.FINDTEXT_MATCHDIAC;
pub const FINDTEXT_MATCHKASHIDA = FINDTEXT_FLAGS.FINDTEXT_MATCHKASHIDA;
pub const FINDTEXT_MATCHALEFHAMZA = FINDTEXT_FLAGS.FINDTEXT_MATCHALEFHAMZA;
pub const FINDTEXT_FLAGS_Max = FINDTEXT_FLAGS.Max;

pub const MOVEUNIT_ACTION = extern enum(i32) {
    MOVEUNIT_PREVCHAR = 0,
    MOVEUNIT_NEXTCHAR = 1,
    MOVEUNIT_PREVCLUSTERBEGIN = 2,
    MOVEUNIT_NEXTCLUSTERBEGIN = 3,
    MOVEUNIT_PREVCLUSTEREND = 4,
    MOVEUNIT_NEXTCLUSTEREND = 5,
    MOVEUNIT_PREVWORDBEGIN = 6,
    MOVEUNIT_NEXTWORDBEGIN = 7,
    MOVEUNIT_PREVWORDEND = 8,
    MOVEUNIT_NEXTWORDEND = 9,
    MOVEUNIT_PREVPROOFWORD = 10,
    MOVEUNIT_NEXTPROOFWORD = 11,
    MOVEUNIT_NEXTURLBEGIN = 12,
    MOVEUNIT_PREVURLBEGIN = 13,
    MOVEUNIT_NEXTURLEND = 14,
    MOVEUNIT_PREVURLEND = 15,
    MOVEUNIT_PREVSENTENCE = 16,
    MOVEUNIT_NEXTSENTENCE = 17,
    MOVEUNIT_PREVBLOCK = 18,
    MOVEUNIT_NEXTBLOCK = 19,
    Max = 2147483647,
};
pub const MOVEUNIT_PREVCHAR = MOVEUNIT_ACTION.MOVEUNIT_PREVCHAR;
pub const MOVEUNIT_NEXTCHAR = MOVEUNIT_ACTION.MOVEUNIT_NEXTCHAR;
pub const MOVEUNIT_PREVCLUSTERBEGIN = MOVEUNIT_ACTION.MOVEUNIT_PREVCLUSTERBEGIN;
pub const MOVEUNIT_NEXTCLUSTERBEGIN = MOVEUNIT_ACTION.MOVEUNIT_NEXTCLUSTERBEGIN;
pub const MOVEUNIT_PREVCLUSTEREND = MOVEUNIT_ACTION.MOVEUNIT_PREVCLUSTEREND;
pub const MOVEUNIT_NEXTCLUSTEREND = MOVEUNIT_ACTION.MOVEUNIT_NEXTCLUSTEREND;
pub const MOVEUNIT_PREVWORDBEGIN = MOVEUNIT_ACTION.MOVEUNIT_PREVWORDBEGIN;
pub const MOVEUNIT_NEXTWORDBEGIN = MOVEUNIT_ACTION.MOVEUNIT_NEXTWORDBEGIN;
pub const MOVEUNIT_PREVWORDEND = MOVEUNIT_ACTION.MOVEUNIT_PREVWORDEND;
pub const MOVEUNIT_NEXTWORDEND = MOVEUNIT_ACTION.MOVEUNIT_NEXTWORDEND;
pub const MOVEUNIT_PREVPROOFWORD = MOVEUNIT_ACTION.MOVEUNIT_PREVPROOFWORD;
pub const MOVEUNIT_NEXTPROOFWORD = MOVEUNIT_ACTION.MOVEUNIT_NEXTPROOFWORD;
pub const MOVEUNIT_NEXTURLBEGIN = MOVEUNIT_ACTION.MOVEUNIT_NEXTURLBEGIN;
pub const MOVEUNIT_PREVURLBEGIN = MOVEUNIT_ACTION.MOVEUNIT_PREVURLBEGIN;
pub const MOVEUNIT_NEXTURLEND = MOVEUNIT_ACTION.MOVEUNIT_NEXTURLEND;
pub const MOVEUNIT_PREVURLEND = MOVEUNIT_ACTION.MOVEUNIT_PREVURLEND;
pub const MOVEUNIT_PREVSENTENCE = MOVEUNIT_ACTION.MOVEUNIT_PREVSENTENCE;
pub const MOVEUNIT_NEXTSENTENCE = MOVEUNIT_ACTION.MOVEUNIT_NEXTSENTENCE;
pub const MOVEUNIT_PREVBLOCK = MOVEUNIT_ACTION.MOVEUNIT_PREVBLOCK;
pub const MOVEUNIT_NEXTBLOCK = MOVEUNIT_ACTION.MOVEUNIT_NEXTBLOCK;
pub const MOVEUNIT_ACTION_Max = MOVEUNIT_ACTION.Max;

pub const PARSE_FLAGS = extern enum(i32) {
    PARSE_ABSOLUTIFYIE40URLS = 1,
    PARSE_DISABLEVML = 2,
    Max = 2147483647,
};
pub const PARSE_ABSOLUTIFYIE40URLS = PARSE_FLAGS.PARSE_ABSOLUTIFYIE40URLS;
pub const PARSE_DISABLEVML = PARSE_FLAGS.PARSE_DISABLEVML;
pub const PARSE_FLAGS_Max = PARSE_FLAGS.Max;

pub const ELEMENT_TAG_ID = extern enum(i32) {
    TAGID_NULL = 0,
    TAGID_UNKNOWN = 1,
    TAGID_A = 2,
    TAGID_ACRONYM = 3,
    TAGID_ADDRESS = 4,
    TAGID_APPLET = 5,
    TAGID_AREA = 6,
    TAGID_B = 7,
    TAGID_BASE = 8,
    TAGID_BASEFONT = 9,
    TAGID_BDO = 10,
    TAGID_BGSOUND = 11,
    TAGID_BIG = 12,
    TAGID_BLINK = 13,
    TAGID_BLOCKQUOTE = 14,
    TAGID_BODY = 15,
    TAGID_BR = 16,
    TAGID_BUTTON = 17,
    TAGID_CAPTION = 18,
    TAGID_CENTER = 19,
    TAGID_CITE = 20,
    TAGID_CODE = 21,
    TAGID_COL = 22,
    TAGID_COLGROUP = 23,
    TAGID_COMMENT = 24,
    TAGID_COMMENT_RAW = 25,
    TAGID_DD = 26,
    TAGID_DEL = 27,
    TAGID_DFN = 28,
    TAGID_DIR = 29,
    TAGID_DIV = 30,
    TAGID_DL = 31,
    TAGID_DT = 32,
    TAGID_EM = 33,
    TAGID_EMBED = 34,
    TAGID_FIELDSET = 35,
    TAGID_FONT = 36,
    TAGID_FORM = 37,
    TAGID_FRAME = 38,
    TAGID_FRAMESET = 39,
    TAGID_GENERIC = 40,
    TAGID_H1 = 41,
    TAGID_H2 = 42,
    TAGID_H3 = 43,
    TAGID_H4 = 44,
    TAGID_H5 = 45,
    TAGID_H6 = 46,
    TAGID_HEAD = 47,
    TAGID_HR = 48,
    TAGID_HTML = 49,
    TAGID_I = 50,
    TAGID_IFRAME = 51,
    TAGID_IMG = 52,
    TAGID_INPUT = 53,
    TAGID_INS = 54,
    TAGID_KBD = 55,
    TAGID_LABEL = 56,
    TAGID_LEGEND = 57,
    TAGID_LI = 58,
    TAGID_LINK = 59,
    TAGID_LISTING = 60,
    TAGID_MAP = 61,
    TAGID_MARQUEE = 62,
    TAGID_MENU = 63,
    TAGID_META = 64,
    TAGID_NEXTID = 65,
    TAGID_NOBR = 66,
    TAGID_NOEMBED = 67,
    TAGID_NOFRAMES = 68,
    TAGID_NOSCRIPT = 69,
    TAGID_OBJECT = 70,
    TAGID_OL = 71,
    TAGID_OPTION = 72,
    TAGID_P = 73,
    TAGID_PARAM = 74,
    TAGID_PLAINTEXT = 75,
    TAGID_PRE = 76,
    TAGID_Q = 77,
    TAGID_RP = 78,
    TAGID_RT = 79,
    TAGID_RUBY = 80,
    TAGID_S = 81,
    TAGID_SAMP = 82,
    TAGID_SCRIPT = 83,
    TAGID_SELECT = 84,
    TAGID_SMALL = 85,
    TAGID_SPAN = 86,
    TAGID_STRIKE = 87,
    TAGID_STRONG = 88,
    TAGID_STYLE = 89,
    TAGID_SUB = 90,
    TAGID_SUP = 91,
    TAGID_TABLE = 92,
    TAGID_TBODY = 93,
    TAGID_TC = 94,
    TAGID_TD = 95,
    TAGID_TEXTAREA = 96,
    TAGID_TFOOT = 97,
    TAGID_TH = 98,
    TAGID_THEAD = 99,
    TAGID_TITLE = 100,
    TAGID_TR = 101,
    TAGID_TT = 102,
    TAGID_U = 103,
    TAGID_UL = 104,
    TAGID_VAR = 105,
    TAGID_WBR = 106,
    TAGID_XMP = 107,
    TAGID_ROOT = 108,
    TAGID_OPTGROUP = 109,
    TAGID_ABBR = 110,
    TAGID_SVG_A = 111,
    TAGID_SVG_ALTGLYPH = 112,
    TAGID_SVG_ALTGLYPHDEF = 113,
    TAGID_SVG_ALTGLYPHITEM = 114,
    TAGID_SVG_ANIMATE = 115,
    TAGID_SVG_ANIMATECOLOR = 116,
    TAGID_SVG_ANIMATEMOTION = 117,
    TAGID_SVG_ANIMATETRANSFORM = 118,
    TAGID_SVG_CIRCLE = 119,
    TAGID_SVG_CLIPPATH = 120,
    TAGID_SVG_COLOR_PROFILE = 121,
    TAGID_SVG_CURSOR = 122,
    TAGID_SVG_DEFINITION_SRC = 123,
    TAGID_SVG_DEFS = 124,
    TAGID_SVG_DESC = 125,
    TAGID_SVG_ELLIPSE = 126,
    TAGID_SVG_FEBLEND = 127,
    TAGID_SVG_FECOLORMATRIX = 128,
    TAGID_SVG_FECOMPONENTTRANSFER = 129,
    TAGID_SVG_FECOMPOSITE = 130,
    TAGID_SVG_FECONVOLVEMATRIX = 131,
    TAGID_SVG_FEDIFFUSELIGHTING = 132,
    TAGID_SVG_FEDISPLACEMENTMAP = 133,
    TAGID_SVG_FEDISTANTLIGHT = 134,
    TAGID_SVG_FEFLOOD = 135,
    TAGID_SVG_FEFUNCA = 136,
    TAGID_SVG_FEFUNCB = 137,
    TAGID_SVG_FEFUNCG = 138,
    TAGID_SVG_FEFUNCR = 139,
    TAGID_SVG_FEGAUSSIANBLUR = 140,
    TAGID_SVG_FEIMAGE = 141,
    TAGID_SVG_FEMERGE = 142,
    TAGID_SVG_FEMERGENODE = 143,
    TAGID_SVG_FEMORPHOLOGY = 144,
    TAGID_SVG_FEOFFSET = 145,
    TAGID_SVG_FEPOINTLIGHT = 146,
    TAGID_SVG_FESPECULARLIGHTING = 147,
    TAGID_SVG_FESPOTLIGHT = 148,
    TAGID_SVG_FETILE = 149,
    TAGID_SVG_FETURBULENCE = 150,
    TAGID_SVG_FILTER = 151,
    TAGID_SVG_FONT = 152,
    TAGID_SVG_FONT_FACE = 153,
    TAGID_SVG_FONT_FACE_FORMAT = 154,
    TAGID_SVG_FONT_FACE_NAME = 155,
    TAGID_SVG_FONT_FACE_SRC = 156,
    TAGID_SVG_FONT_FACE_URI = 157,
    TAGID_SVG_FOREIGNOBJECT = 158,
    TAGID_SVG_G = 159,
    TAGID_SVG_GLYPH = 160,
    TAGID_SVG_GLYPHREF = 161,
    TAGID_SVG_HKERN = 162,
    TAGID_SVG_IMAGE = 163,
    TAGID_SVG_LINE = 164,
    TAGID_SVG_LINEARGRADIENT = 165,
    TAGID_SVG_MARKER = 166,
    TAGID_SVG_MASK = 167,
    TAGID_SVG_METADATA = 168,
    TAGID_SVG_MISSING_GLYPH = 169,
    TAGID_SVG_MPATH = 170,
    TAGID_SVG_PATH = 171,
    TAGID_SVG_PATTERN = 172,
    TAGID_SVG_POLYGON = 173,
    TAGID_SVG_POLYLINE = 174,
    TAGID_SVG_RADIALGRADIENT = 175,
    TAGID_SVG_RECT = 176,
    TAGID_SVG_SCRIPT = 177,
    TAGID_SVG_SET = 178,
    TAGID_SVG_STOP = 179,
    TAGID_SVG_STYLE = 180,
    TAGID_SVG_SVG = 181,
    TAGID_SVG_SWITCH = 182,
    TAGID_SVG_SYMBOL = 183,
    TAGID_SVG_TEXT = 184,
    TAGID_SVG_TEXTPATH = 185,
    TAGID_SVG_TITLE = 186,
    TAGID_SVG_TREF = 187,
    TAGID_SVG_TSPAN = 188,
    TAGID_SVG_USE = 189,
    TAGID_SVG_VIEW = 190,
    TAGID_SVG_VKERN = 191,
    TAGID_AUDIO = 192,
    TAGID_SOURCE = 193,
    TAGID_VIDEO = 194,
    TAGID_CANVAS = 195,
    TAGID_DOCTYPE = 196,
    TAGID_KEYGEN = 197,
    TAGID_PROCESSINGINSTRUCTION = 198,
    TAGID_ARTICLE = 199,
    TAGID_ASIDE = 200,
    TAGID_FIGCAPTION = 201,
    TAGID_FIGURE = 202,
    TAGID_FOOTER = 203,
    TAGID_HEADER = 204,
    TAGID_HGROUP = 205,
    TAGID_MARK = 206,
    TAGID_NAV = 207,
    TAGID_SECTION = 208,
    TAGID_PROGRESS = 209,
    TAGID_MATHML_ANNOTATION_XML = 210,
    TAGID_MATHML_MATH = 211,
    TAGID_MATHML_MI = 212,
    TAGID_MATHML_MN = 213,
    TAGID_MATHML_MO = 214,
    TAGID_MATHML_MS = 215,
    TAGID_MATHML_MTEXT = 216,
    TAGID_DATALIST = 217,
    TAGID_TRACK = 218,
    TAGID_ISINDEX = 219,
    TAGID_COMMAND = 220,
    TAGID_DETAILS = 221,
    TAGID_SUMMARY = 222,
    TAGID_X_MS_WEBVIEW = 223,
    TAGID_COUNT = 224,
    TAGID_LAST_PREDEFINED = 10000,
    Max = 2147483647,
};
pub const TAGID_NULL = ELEMENT_TAG_ID.TAGID_NULL;
pub const TAGID_UNKNOWN = ELEMENT_TAG_ID.TAGID_UNKNOWN;
pub const TAGID_A = ELEMENT_TAG_ID.TAGID_A;
pub const TAGID_ACRONYM = ELEMENT_TAG_ID.TAGID_ACRONYM;
pub const TAGID_ADDRESS = ELEMENT_TAG_ID.TAGID_ADDRESS;
pub const TAGID_APPLET = ELEMENT_TAG_ID.TAGID_APPLET;
pub const TAGID_AREA = ELEMENT_TAG_ID.TAGID_AREA;
pub const TAGID_B = ELEMENT_TAG_ID.TAGID_B;
pub const TAGID_BASE = ELEMENT_TAG_ID.TAGID_BASE;
pub const TAGID_BASEFONT = ELEMENT_TAG_ID.TAGID_BASEFONT;
pub const TAGID_BDO = ELEMENT_TAG_ID.TAGID_BDO;
pub const TAGID_BGSOUND = ELEMENT_TAG_ID.TAGID_BGSOUND;
pub const TAGID_BIG = ELEMENT_TAG_ID.TAGID_BIG;
pub const TAGID_BLINK = ELEMENT_TAG_ID.TAGID_BLINK;
pub const TAGID_BLOCKQUOTE = ELEMENT_TAG_ID.TAGID_BLOCKQUOTE;
pub const TAGID_BODY = ELEMENT_TAG_ID.TAGID_BODY;
pub const TAGID_BR = ELEMENT_TAG_ID.TAGID_BR;
pub const TAGID_BUTTON = ELEMENT_TAG_ID.TAGID_BUTTON;
pub const TAGID_CAPTION = ELEMENT_TAG_ID.TAGID_CAPTION;
pub const TAGID_CENTER = ELEMENT_TAG_ID.TAGID_CENTER;
pub const TAGID_CITE = ELEMENT_TAG_ID.TAGID_CITE;
pub const TAGID_CODE = ELEMENT_TAG_ID.TAGID_CODE;
pub const TAGID_COL = ELEMENT_TAG_ID.TAGID_COL;
pub const TAGID_COLGROUP = ELEMENT_TAG_ID.TAGID_COLGROUP;
pub const TAGID_COMMENT = ELEMENT_TAG_ID.TAGID_COMMENT;
pub const TAGID_COMMENT_RAW = ELEMENT_TAG_ID.TAGID_COMMENT_RAW;
pub const TAGID_DD = ELEMENT_TAG_ID.TAGID_DD;
pub const TAGID_DEL = ELEMENT_TAG_ID.TAGID_DEL;
pub const TAGID_DFN = ELEMENT_TAG_ID.TAGID_DFN;
pub const TAGID_DIR = ELEMENT_TAG_ID.TAGID_DIR;
pub const TAGID_DIV = ELEMENT_TAG_ID.TAGID_DIV;
pub const TAGID_DL = ELEMENT_TAG_ID.TAGID_DL;
pub const TAGID_DT = ELEMENT_TAG_ID.TAGID_DT;
pub const TAGID_EM = ELEMENT_TAG_ID.TAGID_EM;
pub const TAGID_EMBED = ELEMENT_TAG_ID.TAGID_EMBED;
pub const TAGID_FIELDSET = ELEMENT_TAG_ID.TAGID_FIELDSET;
pub const TAGID_FONT = ELEMENT_TAG_ID.TAGID_FONT;
pub const TAGID_FORM = ELEMENT_TAG_ID.TAGID_FORM;
pub const TAGID_FRAME = ELEMENT_TAG_ID.TAGID_FRAME;
pub const TAGID_FRAMESET = ELEMENT_TAG_ID.TAGID_FRAMESET;
pub const TAGID_GENERIC = ELEMENT_TAG_ID.TAGID_GENERIC;
pub const TAGID_H1 = ELEMENT_TAG_ID.TAGID_H1;
pub const TAGID_H2 = ELEMENT_TAG_ID.TAGID_H2;
pub const TAGID_H3 = ELEMENT_TAG_ID.TAGID_H3;
pub const TAGID_H4 = ELEMENT_TAG_ID.TAGID_H4;
pub const TAGID_H5 = ELEMENT_TAG_ID.TAGID_H5;
pub const TAGID_H6 = ELEMENT_TAG_ID.TAGID_H6;
pub const TAGID_HEAD = ELEMENT_TAG_ID.TAGID_HEAD;
pub const TAGID_HR = ELEMENT_TAG_ID.TAGID_HR;
pub const TAGID_HTML = ELEMENT_TAG_ID.TAGID_HTML;
pub const TAGID_I = ELEMENT_TAG_ID.TAGID_I;
pub const TAGID_IFRAME = ELEMENT_TAG_ID.TAGID_IFRAME;
pub const TAGID_IMG = ELEMENT_TAG_ID.TAGID_IMG;
pub const TAGID_INPUT = ELEMENT_TAG_ID.TAGID_INPUT;
pub const TAGID_INS = ELEMENT_TAG_ID.TAGID_INS;
pub const TAGID_KBD = ELEMENT_TAG_ID.TAGID_KBD;
pub const TAGID_LABEL = ELEMENT_TAG_ID.TAGID_LABEL;
pub const TAGID_LEGEND = ELEMENT_TAG_ID.TAGID_LEGEND;
pub const TAGID_LI = ELEMENT_TAG_ID.TAGID_LI;
pub const TAGID_LINK = ELEMENT_TAG_ID.TAGID_LINK;
pub const TAGID_LISTING = ELEMENT_TAG_ID.TAGID_LISTING;
pub const TAGID_MAP = ELEMENT_TAG_ID.TAGID_MAP;
pub const TAGID_MARQUEE = ELEMENT_TAG_ID.TAGID_MARQUEE;
pub const TAGID_MENU = ELEMENT_TAG_ID.TAGID_MENU;
pub const TAGID_META = ELEMENT_TAG_ID.TAGID_META;
pub const TAGID_NEXTID = ELEMENT_TAG_ID.TAGID_NEXTID;
pub const TAGID_NOBR = ELEMENT_TAG_ID.TAGID_NOBR;
pub const TAGID_NOEMBED = ELEMENT_TAG_ID.TAGID_NOEMBED;
pub const TAGID_NOFRAMES = ELEMENT_TAG_ID.TAGID_NOFRAMES;
pub const TAGID_NOSCRIPT = ELEMENT_TAG_ID.TAGID_NOSCRIPT;
pub const TAGID_OBJECT = ELEMENT_TAG_ID.TAGID_OBJECT;
pub const TAGID_OL = ELEMENT_TAG_ID.TAGID_OL;
pub const TAGID_OPTION = ELEMENT_TAG_ID.TAGID_OPTION;
pub const TAGID_P = ELEMENT_TAG_ID.TAGID_P;
pub const TAGID_PARAM = ELEMENT_TAG_ID.TAGID_PARAM;
pub const TAGID_PLAINTEXT = ELEMENT_TAG_ID.TAGID_PLAINTEXT;
pub const TAGID_PRE = ELEMENT_TAG_ID.TAGID_PRE;
pub const TAGID_Q = ELEMENT_TAG_ID.TAGID_Q;
pub const TAGID_RP = ELEMENT_TAG_ID.TAGID_RP;
pub const TAGID_RT = ELEMENT_TAG_ID.TAGID_RT;
pub const TAGID_RUBY = ELEMENT_TAG_ID.TAGID_RUBY;
pub const TAGID_S = ELEMENT_TAG_ID.TAGID_S;
pub const TAGID_SAMP = ELEMENT_TAG_ID.TAGID_SAMP;
pub const TAGID_SCRIPT = ELEMENT_TAG_ID.TAGID_SCRIPT;
pub const TAGID_SELECT = ELEMENT_TAG_ID.TAGID_SELECT;
pub const TAGID_SMALL = ELEMENT_TAG_ID.TAGID_SMALL;
pub const TAGID_SPAN = ELEMENT_TAG_ID.TAGID_SPAN;
pub const TAGID_STRIKE = ELEMENT_TAG_ID.TAGID_STRIKE;
pub const TAGID_STRONG = ELEMENT_TAG_ID.TAGID_STRONG;
pub const TAGID_STYLE = ELEMENT_TAG_ID.TAGID_STYLE;
pub const TAGID_SUB = ELEMENT_TAG_ID.TAGID_SUB;
pub const TAGID_SUP = ELEMENT_TAG_ID.TAGID_SUP;
pub const TAGID_TABLE = ELEMENT_TAG_ID.TAGID_TABLE;
pub const TAGID_TBODY = ELEMENT_TAG_ID.TAGID_TBODY;
pub const TAGID_TC = ELEMENT_TAG_ID.TAGID_TC;
pub const TAGID_TD = ELEMENT_TAG_ID.TAGID_TD;
pub const TAGID_TEXTAREA = ELEMENT_TAG_ID.TAGID_TEXTAREA;
pub const TAGID_TFOOT = ELEMENT_TAG_ID.TAGID_TFOOT;
pub const TAGID_TH = ELEMENT_TAG_ID.TAGID_TH;
pub const TAGID_THEAD = ELEMENT_TAG_ID.TAGID_THEAD;
pub const TAGID_TITLE = ELEMENT_TAG_ID.TAGID_TITLE;
pub const TAGID_TR = ELEMENT_TAG_ID.TAGID_TR;
pub const TAGID_TT = ELEMENT_TAG_ID.TAGID_TT;
pub const TAGID_U = ELEMENT_TAG_ID.TAGID_U;
pub const TAGID_UL = ELEMENT_TAG_ID.TAGID_UL;
pub const TAGID_VAR = ELEMENT_TAG_ID.TAGID_VAR;
pub const TAGID_WBR = ELEMENT_TAG_ID.TAGID_WBR;
pub const TAGID_XMP = ELEMENT_TAG_ID.TAGID_XMP;
pub const TAGID_ROOT = ELEMENT_TAG_ID.TAGID_ROOT;
pub const TAGID_OPTGROUP = ELEMENT_TAG_ID.TAGID_OPTGROUP;
pub const TAGID_ABBR = ELEMENT_TAG_ID.TAGID_ABBR;
pub const TAGID_SVG_A = ELEMENT_TAG_ID.TAGID_SVG_A;
pub const TAGID_SVG_ALTGLYPH = ELEMENT_TAG_ID.TAGID_SVG_ALTGLYPH;
pub const TAGID_SVG_ALTGLYPHDEF = ELEMENT_TAG_ID.TAGID_SVG_ALTGLYPHDEF;
pub const TAGID_SVG_ALTGLYPHITEM = ELEMENT_TAG_ID.TAGID_SVG_ALTGLYPHITEM;
pub const TAGID_SVG_ANIMATE = ELEMENT_TAG_ID.TAGID_SVG_ANIMATE;
pub const TAGID_SVG_ANIMATECOLOR = ELEMENT_TAG_ID.TAGID_SVG_ANIMATECOLOR;
pub const TAGID_SVG_ANIMATEMOTION = ELEMENT_TAG_ID.TAGID_SVG_ANIMATEMOTION;
pub const TAGID_SVG_ANIMATETRANSFORM = ELEMENT_TAG_ID.TAGID_SVG_ANIMATETRANSFORM;
pub const TAGID_SVG_CIRCLE = ELEMENT_TAG_ID.TAGID_SVG_CIRCLE;
pub const TAGID_SVG_CLIPPATH = ELEMENT_TAG_ID.TAGID_SVG_CLIPPATH;
pub const TAGID_SVG_COLOR_PROFILE = ELEMENT_TAG_ID.TAGID_SVG_COLOR_PROFILE;
pub const TAGID_SVG_CURSOR = ELEMENT_TAG_ID.TAGID_SVG_CURSOR;
pub const TAGID_SVG_DEFINITION_SRC = ELEMENT_TAG_ID.TAGID_SVG_DEFINITION_SRC;
pub const TAGID_SVG_DEFS = ELEMENT_TAG_ID.TAGID_SVG_DEFS;
pub const TAGID_SVG_DESC = ELEMENT_TAG_ID.TAGID_SVG_DESC;
pub const TAGID_SVG_ELLIPSE = ELEMENT_TAG_ID.TAGID_SVG_ELLIPSE;
pub const TAGID_SVG_FEBLEND = ELEMENT_TAG_ID.TAGID_SVG_FEBLEND;
pub const TAGID_SVG_FECOLORMATRIX = ELEMENT_TAG_ID.TAGID_SVG_FECOLORMATRIX;
pub const TAGID_SVG_FECOMPONENTTRANSFER = ELEMENT_TAG_ID.TAGID_SVG_FECOMPONENTTRANSFER;
pub const TAGID_SVG_FECOMPOSITE = ELEMENT_TAG_ID.TAGID_SVG_FECOMPOSITE;
pub const TAGID_SVG_FECONVOLVEMATRIX = ELEMENT_TAG_ID.TAGID_SVG_FECONVOLVEMATRIX;
pub const TAGID_SVG_FEDIFFUSELIGHTING = ELEMENT_TAG_ID.TAGID_SVG_FEDIFFUSELIGHTING;
pub const TAGID_SVG_FEDISPLACEMENTMAP = ELEMENT_TAG_ID.TAGID_SVG_FEDISPLACEMENTMAP;
pub const TAGID_SVG_FEDISTANTLIGHT = ELEMENT_TAG_ID.TAGID_SVG_FEDISTANTLIGHT;
pub const TAGID_SVG_FEFLOOD = ELEMENT_TAG_ID.TAGID_SVG_FEFLOOD;
pub const TAGID_SVG_FEFUNCA = ELEMENT_TAG_ID.TAGID_SVG_FEFUNCA;
pub const TAGID_SVG_FEFUNCB = ELEMENT_TAG_ID.TAGID_SVG_FEFUNCB;
pub const TAGID_SVG_FEFUNCG = ELEMENT_TAG_ID.TAGID_SVG_FEFUNCG;
pub const TAGID_SVG_FEFUNCR = ELEMENT_TAG_ID.TAGID_SVG_FEFUNCR;
pub const TAGID_SVG_FEGAUSSIANBLUR = ELEMENT_TAG_ID.TAGID_SVG_FEGAUSSIANBLUR;
pub const TAGID_SVG_FEIMAGE = ELEMENT_TAG_ID.TAGID_SVG_FEIMAGE;
pub const TAGID_SVG_FEMERGE = ELEMENT_TAG_ID.TAGID_SVG_FEMERGE;
pub const TAGID_SVG_FEMERGENODE = ELEMENT_TAG_ID.TAGID_SVG_FEMERGENODE;
pub const TAGID_SVG_FEMORPHOLOGY = ELEMENT_TAG_ID.TAGID_SVG_FEMORPHOLOGY;
pub const TAGID_SVG_FEOFFSET = ELEMENT_TAG_ID.TAGID_SVG_FEOFFSET;
pub const TAGID_SVG_FEPOINTLIGHT = ELEMENT_TAG_ID.TAGID_SVG_FEPOINTLIGHT;
pub const TAGID_SVG_FESPECULARLIGHTING = ELEMENT_TAG_ID.TAGID_SVG_FESPECULARLIGHTING;
pub const TAGID_SVG_FESPOTLIGHT = ELEMENT_TAG_ID.TAGID_SVG_FESPOTLIGHT;
pub const TAGID_SVG_FETILE = ELEMENT_TAG_ID.TAGID_SVG_FETILE;
pub const TAGID_SVG_FETURBULENCE = ELEMENT_TAG_ID.TAGID_SVG_FETURBULENCE;
pub const TAGID_SVG_FILTER = ELEMENT_TAG_ID.TAGID_SVG_FILTER;
pub const TAGID_SVG_FONT = ELEMENT_TAG_ID.TAGID_SVG_FONT;
pub const TAGID_SVG_FONT_FACE = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE;
pub const TAGID_SVG_FONT_FACE_FORMAT = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE_FORMAT;
pub const TAGID_SVG_FONT_FACE_NAME = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE_NAME;
pub const TAGID_SVG_FONT_FACE_SRC = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE_SRC;
pub const TAGID_SVG_FONT_FACE_URI = ELEMENT_TAG_ID.TAGID_SVG_FONT_FACE_URI;
pub const TAGID_SVG_FOREIGNOBJECT = ELEMENT_TAG_ID.TAGID_SVG_FOREIGNOBJECT;
pub const TAGID_SVG_G = ELEMENT_TAG_ID.TAGID_SVG_G;
pub const TAGID_SVG_GLYPH = ELEMENT_TAG_ID.TAGID_SVG_GLYPH;
pub const TAGID_SVG_GLYPHREF = ELEMENT_TAG_ID.TAGID_SVG_GLYPHREF;
pub const TAGID_SVG_HKERN = ELEMENT_TAG_ID.TAGID_SVG_HKERN;
pub const TAGID_SVG_IMAGE = ELEMENT_TAG_ID.TAGID_SVG_IMAGE;
pub const TAGID_SVG_LINE = ELEMENT_TAG_ID.TAGID_SVG_LINE;
pub const TAGID_SVG_LINEARGRADIENT = ELEMENT_TAG_ID.TAGID_SVG_LINEARGRADIENT;
pub const TAGID_SVG_MARKER = ELEMENT_TAG_ID.TAGID_SVG_MARKER;
pub const TAGID_SVG_MASK = ELEMENT_TAG_ID.TAGID_SVG_MASK;
pub const TAGID_SVG_METADATA = ELEMENT_TAG_ID.TAGID_SVG_METADATA;
pub const TAGID_SVG_MISSING_GLYPH = ELEMENT_TAG_ID.TAGID_SVG_MISSING_GLYPH;
pub const TAGID_SVG_MPATH = ELEMENT_TAG_ID.TAGID_SVG_MPATH;
pub const TAGID_SVG_PATH = ELEMENT_TAG_ID.TAGID_SVG_PATH;
pub const TAGID_SVG_PATTERN = ELEMENT_TAG_ID.TAGID_SVG_PATTERN;
pub const TAGID_SVG_POLYGON = ELEMENT_TAG_ID.TAGID_SVG_POLYGON;
pub const TAGID_SVG_POLYLINE = ELEMENT_TAG_ID.TAGID_SVG_POLYLINE;
pub const TAGID_SVG_RADIALGRADIENT = ELEMENT_TAG_ID.TAGID_SVG_RADIALGRADIENT;
pub const TAGID_SVG_RECT = ELEMENT_TAG_ID.TAGID_SVG_RECT;
pub const TAGID_SVG_SCRIPT = ELEMENT_TAG_ID.TAGID_SVG_SCRIPT;
pub const TAGID_SVG_SET = ELEMENT_TAG_ID.TAGID_SVG_SET;
pub const TAGID_SVG_STOP = ELEMENT_TAG_ID.TAGID_SVG_STOP;
pub const TAGID_SVG_STYLE = ELEMENT_TAG_ID.TAGID_SVG_STYLE;
pub const TAGID_SVG_SVG = ELEMENT_TAG_ID.TAGID_SVG_SVG;
pub const TAGID_SVG_SWITCH = ELEMENT_TAG_ID.TAGID_SVG_SWITCH;
pub const TAGID_SVG_SYMBOL = ELEMENT_TAG_ID.TAGID_SVG_SYMBOL;
pub const TAGID_SVG_TEXT = ELEMENT_TAG_ID.TAGID_SVG_TEXT;
pub const TAGID_SVG_TEXTPATH = ELEMENT_TAG_ID.TAGID_SVG_TEXTPATH;
pub const TAGID_SVG_TITLE = ELEMENT_TAG_ID.TAGID_SVG_TITLE;
pub const TAGID_SVG_TREF = ELEMENT_TAG_ID.TAGID_SVG_TREF;
pub const TAGID_SVG_TSPAN = ELEMENT_TAG_ID.TAGID_SVG_TSPAN;
pub const TAGID_SVG_USE = ELEMENT_TAG_ID.TAGID_SVG_USE;
pub const TAGID_SVG_VIEW = ELEMENT_TAG_ID.TAGID_SVG_VIEW;
pub const TAGID_SVG_VKERN = ELEMENT_TAG_ID.TAGID_SVG_VKERN;
pub const TAGID_AUDIO = ELEMENT_TAG_ID.TAGID_AUDIO;
pub const TAGID_SOURCE = ELEMENT_TAG_ID.TAGID_SOURCE;
pub const TAGID_VIDEO = ELEMENT_TAG_ID.TAGID_VIDEO;
pub const TAGID_CANVAS = ELEMENT_TAG_ID.TAGID_CANVAS;
pub const TAGID_DOCTYPE = ELEMENT_TAG_ID.TAGID_DOCTYPE;
pub const TAGID_KEYGEN = ELEMENT_TAG_ID.TAGID_KEYGEN;
pub const TAGID_PROCESSINGINSTRUCTION = ELEMENT_TAG_ID.TAGID_PROCESSINGINSTRUCTION;
pub const TAGID_ARTICLE = ELEMENT_TAG_ID.TAGID_ARTICLE;
pub const TAGID_ASIDE = ELEMENT_TAG_ID.TAGID_ASIDE;
pub const TAGID_FIGCAPTION = ELEMENT_TAG_ID.TAGID_FIGCAPTION;
pub const TAGID_FIGURE = ELEMENT_TAG_ID.TAGID_FIGURE;
pub const TAGID_FOOTER = ELEMENT_TAG_ID.TAGID_FOOTER;
pub const TAGID_HEADER = ELEMENT_TAG_ID.TAGID_HEADER;
pub const TAGID_HGROUP = ELEMENT_TAG_ID.TAGID_HGROUP;
pub const TAGID_MARK = ELEMENT_TAG_ID.TAGID_MARK;
pub const TAGID_NAV = ELEMENT_TAG_ID.TAGID_NAV;
pub const TAGID_SECTION = ELEMENT_TAG_ID.TAGID_SECTION;
pub const TAGID_PROGRESS = ELEMENT_TAG_ID.TAGID_PROGRESS;
pub const TAGID_MATHML_ANNOTATION_XML = ELEMENT_TAG_ID.TAGID_MATHML_ANNOTATION_XML;
pub const TAGID_MATHML_MATH = ELEMENT_TAG_ID.TAGID_MATHML_MATH;
pub const TAGID_MATHML_MI = ELEMENT_TAG_ID.TAGID_MATHML_MI;
pub const TAGID_MATHML_MN = ELEMENT_TAG_ID.TAGID_MATHML_MN;
pub const TAGID_MATHML_MO = ELEMENT_TAG_ID.TAGID_MATHML_MO;
pub const TAGID_MATHML_MS = ELEMENT_TAG_ID.TAGID_MATHML_MS;
pub const TAGID_MATHML_MTEXT = ELEMENT_TAG_ID.TAGID_MATHML_MTEXT;
pub const TAGID_DATALIST = ELEMENT_TAG_ID.TAGID_DATALIST;
pub const TAGID_TRACK = ELEMENT_TAG_ID.TAGID_TRACK;
pub const TAGID_ISINDEX = ELEMENT_TAG_ID.TAGID_ISINDEX;
pub const TAGID_COMMAND = ELEMENT_TAG_ID.TAGID_COMMAND;
pub const TAGID_DETAILS = ELEMENT_TAG_ID.TAGID_DETAILS;
pub const TAGID_SUMMARY = ELEMENT_TAG_ID.TAGID_SUMMARY;
pub const TAGID_X_MS_WEBVIEW = ELEMENT_TAG_ID.TAGID_X_MS_WEBVIEW;
pub const TAGID_COUNT = ELEMENT_TAG_ID.TAGID_COUNT;
pub const TAGID_LAST_PREDEFINED = ELEMENT_TAG_ID.TAGID_LAST_PREDEFINED;
pub const ELEMENT_TAG_ID_Max = ELEMENT_TAG_ID.Max;

pub const SELECTION_TYPE = extern enum(i32) {
    None = 0,
    Caret = 1,
    Text = 2,
    Control = 3,
    Max = 2147483647,
};
pub const SELECTION_TYPE_None = SELECTION_TYPE.None;
pub const SELECTION_TYPE_Caret = SELECTION_TYPE.Caret;
pub const SELECTION_TYPE_Text = SELECTION_TYPE.Text;
pub const SELECTION_TYPE_Control = SELECTION_TYPE.Control;
pub const SELECTION_TYPE_Max = SELECTION_TYPE.Max;

pub const SAVE_SEGMENTS_FLAGS = extern enum(i32) {
    SAVE_SEGMENTS_NoIE4SelectionCompat = 1,
    Max = 2147483647,
};
pub const SAVE_SEGMENTS_NoIE4SelectionCompat = SAVE_SEGMENTS_FLAGS.SAVE_SEGMENTS_NoIE4SelectionCompat;
pub const SAVE_SEGMENTS_FLAGS_Max = SAVE_SEGMENTS_FLAGS.Max;

pub const CARET_DIRECTION = extern enum(i32) {
    INDETERMINATE = 0,
    SAME = 1,
    BACKWARD = 2,
    FORWARD = 3,
    Max = 2147483647,
};
pub const CARET_DIRECTION_INDETERMINATE = CARET_DIRECTION.INDETERMINATE;
pub const CARET_DIRECTION_SAME = CARET_DIRECTION.SAME;
pub const CARET_DIRECTION_BACKWARD = CARET_DIRECTION.BACKWARD;
pub const CARET_DIRECTION_FORWARD = CARET_DIRECTION.FORWARD;
pub const CARET_DIRECTION_Max = CARET_DIRECTION.Max;

pub const LINE_DIRECTION = extern enum(i32) {
    RightToLeft = 1,
    LeftToRight = 2,
    Max = 2147483647,
};
pub const LINE_DIRECTION_RightToLeft = LINE_DIRECTION.RightToLeft;
pub const LINE_DIRECTION_LeftToRight = LINE_DIRECTION.LeftToRight;
pub const LINE_DIRECTION_Max = LINE_DIRECTION.Max;

pub const HT_OPTIONS = extern enum(i32) {
    HT_OPT_AllowAfterEOL = 1,
    Max = 2147483647,
};
pub const HT_OPT_AllowAfterEOL = HT_OPTIONS.HT_OPT_AllowAfterEOL;
pub const HT_OPTIONS_Max = HT_OPTIONS.Max;

pub const HT_RESULTS = extern enum(i32) {
    Glyph = 1,
    Max = 2147483647,
};
pub const HT_RESULTS_Glyph = HT_RESULTS.Glyph;
pub const HT_RESULTS_Max = HT_RESULTS.Max;

pub const DISPLAY_MOVEUNIT = extern enum(i32) {
    PreviousLine = 1,
    NextLine = 2,
    CurrentLineStart = 3,
    CurrentLineEnd = 4,
    TopOfWindow = 5,
    BottomOfWindow = 6,
    Max = 2147483647,
};
pub const DISPLAY_MOVEUNIT_PreviousLine = DISPLAY_MOVEUNIT.PreviousLine;
pub const DISPLAY_MOVEUNIT_NextLine = DISPLAY_MOVEUNIT.NextLine;
pub const DISPLAY_MOVEUNIT_CurrentLineStart = DISPLAY_MOVEUNIT.CurrentLineStart;
pub const DISPLAY_MOVEUNIT_CurrentLineEnd = DISPLAY_MOVEUNIT.CurrentLineEnd;
pub const DISPLAY_MOVEUNIT_TopOfWindow = DISPLAY_MOVEUNIT.TopOfWindow;
pub const DISPLAY_MOVEUNIT_BottomOfWindow = DISPLAY_MOVEUNIT.BottomOfWindow;
pub const DISPLAY_MOVEUNIT_Max = DISPLAY_MOVEUNIT.Max;

pub const DISPLAY_GRAVITY = extern enum(i32) {
    PreviousLine = 1,
    NextLine = 2,
    Max = 2147483647,
};
pub const DISPLAY_GRAVITY_PreviousLine = DISPLAY_GRAVITY.PreviousLine;
pub const DISPLAY_GRAVITY_NextLine = DISPLAY_GRAVITY.NextLine;
pub const DISPLAY_GRAVITY_Max = DISPLAY_GRAVITY.Max;

pub const DISPLAY_BREAK = extern enum(i32) {
    None = 0,
    Block = 1,
    Break = 2,
    Max = 2147483647,
};
pub const DISPLAY_BREAK_None = DISPLAY_BREAK.None;
pub const DISPLAY_BREAK_Block = DISPLAY_BREAK.Block;
pub const DISPLAY_BREAK_Break = DISPLAY_BREAK.Break;
pub const DISPLAY_BREAK_Max = DISPLAY_BREAK.Max;

pub const COORD_SYSTEM = extern enum(i32) {
    GLOBAL = 0,
    PARENT = 1,
    CONTAINER = 2,
    CONTENT = 3,
    FRAME = 4,
    CLIENT = 5,
    Max = 2147483647,
};
pub const COORD_SYSTEM_GLOBAL = COORD_SYSTEM.GLOBAL;
pub const COORD_SYSTEM_PARENT = COORD_SYSTEM.PARENT;
pub const COORD_SYSTEM_CONTAINER = COORD_SYSTEM.CONTAINER;
pub const COORD_SYSTEM_CONTENT = COORD_SYSTEM.CONTENT;
pub const COORD_SYSTEM_FRAME = COORD_SYSTEM.FRAME;
pub const COORD_SYSTEM_CLIENT = COORD_SYSTEM.CLIENT;
pub const COORD_SYSTEM_Max = COORD_SYSTEM.Max;

pub const DEV_CONSOLE_MESSAGE_LEVEL = extern enum(i32) {
    DCML_INFORMATIONAL = 0,
    DCML_WARNING = 1,
    DCML_ERROR = 2,
    Max = 2147483647,
};
pub const DCML_INFORMATIONAL = DEV_CONSOLE_MESSAGE_LEVEL.DCML_INFORMATIONAL;
pub const DCML_WARNING = DEV_CONSOLE_MESSAGE_LEVEL.DCML_WARNING;
pub const DCML_ERROR = DEV_CONSOLE_MESSAGE_LEVEL.DCML_ERROR;
pub const DEV_CONSOLE_MESSAGE_LEVEL_Max = DEV_CONSOLE_MESSAGE_LEVEL.Max;

pub const DOM_EVENT_PHASE = extern enum(i32) {
    DEP_CAPTURING_PHASE = 1,
    DEP_AT_TARGET = 2,
    DEP_BUBBLING_PHASE = 3,
    Max = 2147483647,
};
pub const DEP_CAPTURING_PHASE = DOM_EVENT_PHASE.DEP_CAPTURING_PHASE;
pub const DEP_AT_TARGET = DOM_EVENT_PHASE.DEP_AT_TARGET;
pub const DEP_BUBBLING_PHASE = DOM_EVENT_PHASE.DEP_BUBBLING_PHASE;
pub const DOM_EVENT_PHASE_Max = DOM_EVENT_PHASE.Max;

pub const SCRIPT_TIMER_TYPE = extern enum(i32) {
    STT_TIMEOUT = 0,
    STT_INTERVAL = 1,
    STT_IMMEDIATE = 2,
    STT_ANIMATION_FRAME = 3,
    Max = 2147483647,
};
pub const STT_TIMEOUT = SCRIPT_TIMER_TYPE.STT_TIMEOUT;
pub const STT_INTERVAL = SCRIPT_TIMER_TYPE.STT_INTERVAL;
pub const STT_IMMEDIATE = SCRIPT_TIMER_TYPE.STT_IMMEDIATE;
pub const STT_ANIMATION_FRAME = SCRIPT_TIMER_TYPE.STT_ANIMATION_FRAME;
pub const SCRIPT_TIMER_TYPE_Max = SCRIPT_TIMER_TYPE.Max;

pub const HTML_PAINTER = extern enum(i32) {
    HTMLPAINTER_OPAQUE = 1,
    HTMLPAINTER_TRANSPARENT = 2,
    HTMLPAINTER_ALPHA = 4,
    HTMLPAINTER_COMPLEX = 8,
    HTMLPAINTER_OVERLAY = 16,
    HTMLPAINTER_HITTEST = 32,
    HTMLPAINTER_SURFACE = 256,
    HTMLPAINTER_3DSURFACE = 512,
    HTMLPAINTER_NOBAND = 1024,
    HTMLPAINTER_NODC = 4096,
    HTMLPAINTER_NOPHYSICALCLIP = 8192,
    HTMLPAINTER_NOSAVEDC = 16384,
    HTMLPAINTER_SUPPORTS_XFORM = 32768,
    HTMLPAINTER_EXPAND = 65536,
    HTMLPAINTER_NOSCROLLBITS = 131072,
    Max = 2147483647,
};
pub const HTMLPAINTER_OPAQUE = HTML_PAINTER.HTMLPAINTER_OPAQUE;
pub const HTMLPAINTER_TRANSPARENT = HTML_PAINTER.HTMLPAINTER_TRANSPARENT;
pub const HTMLPAINTER_ALPHA = HTML_PAINTER.HTMLPAINTER_ALPHA;
pub const HTMLPAINTER_COMPLEX = HTML_PAINTER.HTMLPAINTER_COMPLEX;
pub const HTMLPAINTER_OVERLAY = HTML_PAINTER.HTMLPAINTER_OVERLAY;
pub const HTMLPAINTER_HITTEST = HTML_PAINTER.HTMLPAINTER_HITTEST;
pub const HTMLPAINTER_SURFACE = HTML_PAINTER.HTMLPAINTER_SURFACE;
pub const HTMLPAINTER_3DSURFACE = HTML_PAINTER.HTMLPAINTER_3DSURFACE;
pub const HTMLPAINTER_NOBAND = HTML_PAINTER.HTMLPAINTER_NOBAND;
pub const HTMLPAINTER_NODC = HTML_PAINTER.HTMLPAINTER_NODC;
pub const HTMLPAINTER_NOPHYSICALCLIP = HTML_PAINTER.HTMLPAINTER_NOPHYSICALCLIP;
pub const HTMLPAINTER_NOSAVEDC = HTML_PAINTER.HTMLPAINTER_NOSAVEDC;
pub const HTMLPAINTER_SUPPORTS_XFORM = HTML_PAINTER.HTMLPAINTER_SUPPORTS_XFORM;
pub const HTMLPAINTER_EXPAND = HTML_PAINTER.HTMLPAINTER_EXPAND;
pub const HTMLPAINTER_NOSCROLLBITS = HTML_PAINTER.HTMLPAINTER_NOSCROLLBITS;
pub const HTML_PAINTER_Max = HTML_PAINTER.Max;

pub const HTML_PAINT_ZORDER = extern enum(i32) {
    HTMLPAINT_ZORDER_NONE = 0,
    HTMLPAINT_ZORDER_REPLACE_ALL = 1,
    HTMLPAINT_ZORDER_REPLACE_CONTENT = 2,
    HTMLPAINT_ZORDER_REPLACE_BACKGROUND = 3,
    HTMLPAINT_ZORDER_BELOW_CONTENT = 4,
    HTMLPAINT_ZORDER_BELOW_FLOW = 5,
    HTMLPAINT_ZORDER_ABOVE_FLOW = 6,
    HTMLPAINT_ZORDER_ABOVE_CONTENT = 7,
    HTMLPAINT_ZORDER_WINDOW_TOP = 8,
    Max = 2147483647,
};
pub const HTMLPAINT_ZORDER_NONE = HTML_PAINT_ZORDER.HTMLPAINT_ZORDER_NONE;
pub const HTMLPAINT_ZORDER_REPLACE_ALL = HTML_PAINT_ZORDER.HTMLPAINT_ZORDER_REPLACE_ALL;
pub const HTMLPAINT_ZORDER_REPLACE_CONTENT = HTML_PAINT_ZORDER.HTMLPAINT_ZORDER_REPLACE_CONTENT;
pub const HTMLPAINT_ZORDER_REPLACE_BACKGROUND = HTML_PAINT_ZORDER.HTMLPAINT_ZORDER_REPLACE_BACKGROUND;
pub const HTMLPAINT_ZORDER_BELOW_CONTENT = HTML_PAINT_ZORDER.HTMLPAINT_ZORDER_BELOW_CONTENT;
pub const HTMLPAINT_ZORDER_BELOW_FLOW = HTML_PAINT_ZORDER.HTMLPAINT_ZORDER_BELOW_FLOW;
pub const HTMLPAINT_ZORDER_ABOVE_FLOW = HTML_PAINT_ZORDER.HTMLPAINT_ZORDER_ABOVE_FLOW;
pub const HTMLPAINT_ZORDER_ABOVE_CONTENT = HTML_PAINT_ZORDER.HTMLPAINT_ZORDER_ABOVE_CONTENT;
pub const HTMLPAINT_ZORDER_WINDOW_TOP = HTML_PAINT_ZORDER.HTMLPAINT_ZORDER_WINDOW_TOP;
pub const HTML_PAINT_ZORDER_Max = HTML_PAINT_ZORDER.Max;

pub const HTML_PAINT_DRAW_FLAGS = extern enum(i32) {
    HTMLPAINT_DRAW_UPDATEREGION = 1,
    HTMLPAINT_DRAW_USE_XFORM = 2,
    Max = 2147483647,
};
pub const HTMLPAINT_DRAW_UPDATEREGION = HTML_PAINT_DRAW_FLAGS.HTMLPAINT_DRAW_UPDATEREGION;
pub const HTMLPAINT_DRAW_USE_XFORM = HTML_PAINT_DRAW_FLAGS.HTMLPAINT_DRAW_USE_XFORM;
pub const HTML_PAINT_DRAW_FLAGS_Max = HTML_PAINT_DRAW_FLAGS.Max;

pub const HTML_PAINT_EVENT_FLAGS = extern enum(i32) {
    HTMLPAINT_EVENT_TARGET = 1,
    HTMLPAINT_EVENT_SETCURSOR = 2,
    Max = 2147483647,
};
pub const HTMLPAINT_EVENT_TARGET = HTML_PAINT_EVENT_FLAGS.HTMLPAINT_EVENT_TARGET;
pub const HTMLPAINT_EVENT_SETCURSOR = HTML_PAINT_EVENT_FLAGS.HTMLPAINT_EVENT_SETCURSOR;
pub const HTML_PAINT_EVENT_FLAGS_Max = HTML_PAINT_EVENT_FLAGS.Max;

pub const HTML_PAINT_DRAW_INFO_FLAGS = extern enum(i32) {
    HTMLPAINT_DRAWINFO_VIEWPORT = 1,
    HTMLPAINT_DRAWINFO_UPDATEREGION = 2,
    HTMLPAINT_DRAWINFO_XFORM = 4,
    Max = 2147483647,
};
pub const HTMLPAINT_DRAWINFO_VIEWPORT = HTML_PAINT_DRAW_INFO_FLAGS.HTMLPAINT_DRAWINFO_VIEWPORT;
pub const HTMLPAINT_DRAWINFO_UPDATEREGION = HTML_PAINT_DRAW_INFO_FLAGS.HTMLPAINT_DRAWINFO_UPDATEREGION;
pub const HTMLPAINT_DRAWINFO_XFORM = HTML_PAINT_DRAW_INFO_FLAGS.HTMLPAINT_DRAWINFO_XFORM;
pub const HTML_PAINT_DRAW_INFO_FLAGS_Max = HTML_PAINT_DRAW_INFO_FLAGS.Max;

pub const HTML_PAINTER_INFO = extern struct {
    lFlags: i32,
    lZOrder: i32,
    iidDrawObject: Guid,
    rcExpand: RECT,
};

pub const HTML_PAINT_XFORM = extern struct {
    eM11: f32,
    eM12: f32,
    eM21: f32,
    eM22: f32,
    eDx: f32,
    eDy: f32,
};

pub const HTML_PAINT_DRAW_INFO = extern struct {
    rcViewport: RECT,
    hrgnUpdate: HRGN,
    xform: HTML_PAINT_XFORM,
};

pub const HTMLDlgFlag = extern enum(i32) {
    HTMLDlgFlagNo = 0,
    HTMLDlgFlagOff = 0,
    HTMLDlgFlag0 = 0,
    HTMLDlgFlagYes = 1,
    HTMLDlgFlagOn = 1,
    HTMLDlgFlag1 = 1,
    HTMLDlgFlagNotSet = -1,
    Max = 2147483647,
};
pub const HTMLDlgFlagNo = HTMLDlgFlag.HTMLDlgFlagNo;
pub const HTMLDlgFlagOff = HTMLDlgFlag.HTMLDlgFlagOff;
pub const HTMLDlgFlag0 = HTMLDlgFlag.HTMLDlgFlag0;
pub const HTMLDlgFlagYes = HTMLDlgFlag.HTMLDlgFlagYes;
pub const HTMLDlgFlagOn = HTMLDlgFlag.HTMLDlgFlagOn;
pub const HTMLDlgFlag1 = HTMLDlgFlag.HTMLDlgFlag1;
pub const HTMLDlgFlagNotSet = HTMLDlgFlag.HTMLDlgFlagNotSet;
pub const HTMLDlgFlag_Max = HTMLDlgFlag.Max;

pub const HTMLDlgBorder = extern enum(i32) {
    HTMLDlgBorderThin = 0,
    HTMLDlgBorderThick = 262144,
    Max = 2147483647,
};
pub const HTMLDlgBorderThin = HTMLDlgBorder.HTMLDlgBorderThin;
pub const HTMLDlgBorderThick = HTMLDlgBorder.HTMLDlgBorderThick;
pub const HTMLDlgBorder_Max = HTMLDlgBorder.Max;

pub const HTMLDlgEdge = extern enum(i32) {
    HTMLDlgEdgeSunken = 0,
    HTMLDlgEdgeRaised = 16,
    Max = 2147483647,
};
pub const HTMLDlgEdgeSunken = HTMLDlgEdge.HTMLDlgEdgeSunken;
pub const HTMLDlgEdgeRaised = HTMLDlgEdge.HTMLDlgEdgeRaised;
pub const HTMLDlgEdge_Max = HTMLDlgEdge.Max;

pub const HTMLDlgCenter = extern enum(i32) {
    HTMLDlgCenterNo = 0,
    HTMLDlgCenterOff = 0,
    HTMLDlgCenter0 = 0,
    HTMLDlgCenterYes = 1,
    HTMLDlgCenterOn = 1,
    HTMLDlgCenter1 = 1,
    HTMLDlgCenterParent = 1,
    HTMLDlgCenterDesktop = 2,
    Max = 2147483647,
};
pub const HTMLDlgCenterNo = HTMLDlgCenter.HTMLDlgCenterNo;
pub const HTMLDlgCenterOff = HTMLDlgCenter.HTMLDlgCenterOff;
pub const HTMLDlgCenter0 = HTMLDlgCenter.HTMLDlgCenter0;
pub const HTMLDlgCenterYes = HTMLDlgCenter.HTMLDlgCenterYes;
pub const HTMLDlgCenterOn = HTMLDlgCenter.HTMLDlgCenterOn;
pub const HTMLDlgCenter1 = HTMLDlgCenter.HTMLDlgCenter1;
pub const HTMLDlgCenterParent = HTMLDlgCenter.HTMLDlgCenterParent;
pub const HTMLDlgCenterDesktop = HTMLDlgCenter.HTMLDlgCenterDesktop;
pub const HTMLDlgCenter_Max = HTMLDlgCenter.Max;

pub const HTMLAppFlag = extern enum(i32) {
    HTMLAppFlagNo = 0,
    HTMLAppFlagOff = 0,
    HTMLAppFlag0 = 0,
    HTMLAppFlagYes = 1,
    HTMLAppFlagOn = 1,
    HTMLAppFlag1 = 1,
    Max = 2147483647,
};
pub const HTMLAppFlagNo = HTMLAppFlag.HTMLAppFlagNo;
pub const HTMLAppFlagOff = HTMLAppFlag.HTMLAppFlagOff;
pub const HTMLAppFlag0 = HTMLAppFlag.HTMLAppFlag0;
pub const HTMLAppFlagYes = HTMLAppFlag.HTMLAppFlagYes;
pub const HTMLAppFlagOn = HTMLAppFlag.HTMLAppFlagOn;
pub const HTMLAppFlag1 = HTMLAppFlag.HTMLAppFlag1;
pub const HTMLAppFlag_Max = HTMLAppFlag.Max;

pub const HTMLMinimizeFlag = extern enum(i32) {
    HTMLMinimizeFlagNo = 0,
    HTMLMinimizeFlagYes = 131072,
    Max = 2147483647,
};
pub const HTMLMinimizeFlagNo = HTMLMinimizeFlag.HTMLMinimizeFlagNo;
pub const HTMLMinimizeFlagYes = HTMLMinimizeFlag.HTMLMinimizeFlagYes;
pub const HTMLMinimizeFlag_Max = HTMLMinimizeFlag.Max;

pub const HTMLMaximizeFlag = extern enum(i32) {
    HTMLMaximizeFlagNo = 0,
    HTMLMaximizeFlagYes = 65536,
    Max = 2147483647,
};
pub const HTMLMaximizeFlagNo = HTMLMaximizeFlag.HTMLMaximizeFlagNo;
pub const HTMLMaximizeFlagYes = HTMLMaximizeFlag.HTMLMaximizeFlagYes;
pub const HTMLMaximizeFlag_Max = HTMLMaximizeFlag.Max;

pub const HTMLCaptionFlag = extern enum(i32) {
    HTMLCaptionFlagNo = 0,
    HTMLCaptionFlagYes = 12582912,
    Max = 2147483647,
};
pub const HTMLCaptionFlagNo = HTMLCaptionFlag.HTMLCaptionFlagNo;
pub const HTMLCaptionFlagYes = HTMLCaptionFlag.HTMLCaptionFlagYes;
pub const HTMLCaptionFlag_Max = HTMLCaptionFlag.Max;

pub const HTMLSysMenuFlag = extern enum(i32) {
    HTMLSysMenuFlagNo = 0,
    HTMLSysMenuFlagYes = 524288,
    Max = 2147483647,
};
pub const HTMLSysMenuFlagNo = HTMLSysMenuFlag.HTMLSysMenuFlagNo;
pub const HTMLSysMenuFlagYes = HTMLSysMenuFlag.HTMLSysMenuFlagYes;
pub const HTMLSysMenuFlag_Max = HTMLSysMenuFlag.Max;

pub const HTMLBorder = extern enum(i32) {
    HTMLBorderNone = 0,
    HTMLBorderThick = 262144,
    HTMLBorderDialog = 4194304,
    HTMLBorderThin = 8388608,
    Max = 2147483647,
};
pub const HTMLBorderNone = HTMLBorder.HTMLBorderNone;
pub const HTMLBorderThick = HTMLBorder.HTMLBorderThick;
pub const HTMLBorderDialog = HTMLBorder.HTMLBorderDialog;
pub const HTMLBorderThin = HTMLBorder.HTMLBorderThin;
pub const HTMLBorder_Max = HTMLBorder.Max;

pub const HTMLBorderStyle = extern enum(i32) {
    HTMLBorderStyleNormal = 0,
    HTMLBorderStyleRaised = 256,
    HTMLBorderStyleSunken = 512,
    HTMLBorderStylecombined = 768,
    HTMLBorderStyleStatic = 131072,
    Max = 2147483647,
};
pub const HTMLBorderStyleNormal = HTMLBorderStyle.HTMLBorderStyleNormal;
pub const HTMLBorderStyleRaised = HTMLBorderStyle.HTMLBorderStyleRaised;
pub const HTMLBorderStyleSunken = HTMLBorderStyle.HTMLBorderStyleSunken;
pub const HTMLBorderStylecombined = HTMLBorderStyle.HTMLBorderStylecombined;
pub const HTMLBorderStyleStatic = HTMLBorderStyle.HTMLBorderStyleStatic;
pub const HTMLBorderStyle_Max = HTMLBorderStyle.Max;

pub const HTMLWindowState = extern enum(i32) {
    HTMLWindowStateNormal = 1,
    HTMLWindowStateMaximize = 3,
    HTMLWindowStateMinimize = 6,
    Max = 2147483647,
};
pub const HTMLWindowStateNormal = HTMLWindowState.HTMLWindowStateNormal;
pub const HTMLWindowStateMaximize = HTMLWindowState.HTMLWindowStateMaximize;
pub const HTMLWindowStateMinimize = HTMLWindowState.HTMLWindowStateMinimize;
pub const HTMLWindowState_Max = HTMLWindowState.Max;

pub const BEHAVIOR_EVENT = extern enum(i32) {
    BEHAVIOREVENT_FIRST = 0,
    BEHAVIOREVENT_CONTENTREADY = 0,
    BEHAVIOREVENT_DOCUMENTREADY = 1,
    BEHAVIOREVENT_APPLYSTYLE = 2,
    BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE = 3,
    BEHAVIOREVENT_CONTENTSAVE = 4,
    BEHAVIOREVENT_LAST = 4,
    Max = 2147483647,
};
pub const BEHAVIOREVENT_FIRST = BEHAVIOR_EVENT.BEHAVIOREVENT_FIRST;
pub const BEHAVIOREVENT_CONTENTREADY = BEHAVIOR_EVENT.BEHAVIOREVENT_CONTENTREADY;
pub const BEHAVIOREVENT_DOCUMENTREADY = BEHAVIOR_EVENT.BEHAVIOREVENT_DOCUMENTREADY;
pub const BEHAVIOREVENT_APPLYSTYLE = BEHAVIOR_EVENT.BEHAVIOREVENT_APPLYSTYLE;
pub const BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE = BEHAVIOR_EVENT.BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE;
pub const BEHAVIOREVENT_CONTENTSAVE = BEHAVIOR_EVENT.BEHAVIOREVENT_CONTENTSAVE;
pub const BEHAVIOREVENT_LAST = BEHAVIOR_EVENT.BEHAVIOREVENT_LAST;
pub const BEHAVIOR_EVENT_Max = BEHAVIOR_EVENT.Max;

pub const BEHAVIOR_EVENT_FLAGS = extern enum(i32) {
    BEHAVIOREVENTFLAGS_BUBBLE = 1,
    BEHAVIOREVENTFLAGS_STANDARDADDITIVE = 2,
    Max = 2147483647,
};
pub const BEHAVIOREVENTFLAGS_BUBBLE = BEHAVIOR_EVENT_FLAGS.BEHAVIOREVENTFLAGS_BUBBLE;
pub const BEHAVIOREVENTFLAGS_STANDARDADDITIVE = BEHAVIOR_EVENT_FLAGS.BEHAVIOREVENTFLAGS_STANDARDADDITIVE;
pub const BEHAVIOR_EVENT_FLAGS_Max = BEHAVIOR_EVENT_FLAGS.Max;

pub const BEHAVIOR_RENDER_INFO = extern enum(i32) {
    BEHAVIORRENDERINFO_BEFOREBACKGROUND = 1,
    BEHAVIORRENDERINFO_AFTERBACKGROUND = 2,
    BEHAVIORRENDERINFO_BEFORECONTENT = 4,
    BEHAVIORRENDERINFO_AFTERCONTENT = 8,
    BEHAVIORRENDERINFO_AFTERFOREGROUND = 32,
    BEHAVIORRENDERINFO_ABOVECONTENT = 40,
    BEHAVIORRENDERINFO_ALLLAYERS = 255,
    BEHAVIORRENDERINFO_DISABLEBACKGROUND = 256,
    BEHAVIORRENDERINFO_DISABLENEGATIVEZ = 512,
    BEHAVIORRENDERINFO_DISABLECONTENT = 1024,
    BEHAVIORRENDERINFO_DISABLEPOSITIVEZ = 2048,
    BEHAVIORRENDERINFO_DISABLEALLLAYERS = 3840,
    BEHAVIORRENDERINFO_HITTESTING = 4096,
    BEHAVIORRENDERINFO_SURFACE = 1048576,
    BEHAVIORRENDERINFO_3DSURFACE = 2097152,
    Max = 2147483647,
};
pub const BEHAVIORRENDERINFO_BEFOREBACKGROUND = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_BEFOREBACKGROUND;
pub const BEHAVIORRENDERINFO_AFTERBACKGROUND = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_AFTERBACKGROUND;
pub const BEHAVIORRENDERINFO_BEFORECONTENT = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_BEFORECONTENT;
pub const BEHAVIORRENDERINFO_AFTERCONTENT = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_AFTERCONTENT;
pub const BEHAVIORRENDERINFO_AFTERFOREGROUND = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_AFTERFOREGROUND;
pub const BEHAVIORRENDERINFO_ABOVECONTENT = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_ABOVECONTENT;
pub const BEHAVIORRENDERINFO_ALLLAYERS = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_ALLLAYERS;
pub const BEHAVIORRENDERINFO_DISABLEBACKGROUND = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_DISABLEBACKGROUND;
pub const BEHAVIORRENDERINFO_DISABLENEGATIVEZ = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_DISABLENEGATIVEZ;
pub const BEHAVIORRENDERINFO_DISABLECONTENT = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_DISABLECONTENT;
pub const BEHAVIORRENDERINFO_DISABLEPOSITIVEZ = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_DISABLEPOSITIVEZ;
pub const BEHAVIORRENDERINFO_DISABLEALLLAYERS = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_DISABLEALLLAYERS;
pub const BEHAVIORRENDERINFO_HITTESTING = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_HITTESTING;
pub const BEHAVIORRENDERINFO_SURFACE = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_SURFACE;
pub const BEHAVIORRENDERINFO_3DSURFACE = BEHAVIOR_RENDER_INFO.BEHAVIORRENDERINFO_3DSURFACE;
pub const BEHAVIOR_RENDER_INFO_Max = BEHAVIOR_RENDER_INFO.Max;

pub const BEHAVIOR_RELATION = extern enum(i32) {
    BEHAVIOR_FIRSTRELATION = 0,
    BEHAVIOR_SAMEELEMENT = 0,
    BEHAVIOR_PARENT = 1,
    BEHAVIOR_CHILD = 2,
    BEHAVIOR_SIBLING = 3,
    BEHAVIOR_LASTRELATION = 3,
    Max = 2147483647,
};
pub const BEHAVIOR_FIRSTRELATION = BEHAVIOR_RELATION.BEHAVIOR_FIRSTRELATION;
pub const BEHAVIOR_SAMEELEMENT = BEHAVIOR_RELATION.BEHAVIOR_SAMEELEMENT;
pub const BEHAVIOR_PARENT = BEHAVIOR_RELATION.BEHAVIOR_PARENT;
pub const BEHAVIOR_CHILD = BEHAVIOR_RELATION.BEHAVIOR_CHILD;
pub const BEHAVIOR_SIBLING = BEHAVIOR_RELATION.BEHAVIOR_SIBLING;
pub const BEHAVIOR_LASTRELATION = BEHAVIOR_RELATION.BEHAVIOR_LASTRELATION;
pub const BEHAVIOR_RELATION_Max = BEHAVIOR_RELATION.Max;

pub const BEHAVIOR_LAYOUT_INFO = extern enum(i32) {
    BEHAVIORLAYOUTINFO_FULLDELEGATION = 1,
    BEHAVIORLAYOUTINFO_MODIFYNATURAL = 2,
    BEHAVIORLAYOUTINFO_MAPSIZE = 4,
    Max = 2147483647,
};
pub const BEHAVIORLAYOUTINFO_FULLDELEGATION = BEHAVIOR_LAYOUT_INFO.BEHAVIORLAYOUTINFO_FULLDELEGATION;
pub const BEHAVIORLAYOUTINFO_MODIFYNATURAL = BEHAVIOR_LAYOUT_INFO.BEHAVIORLAYOUTINFO_MODIFYNATURAL;
pub const BEHAVIORLAYOUTINFO_MAPSIZE = BEHAVIOR_LAYOUT_INFO.BEHAVIORLAYOUTINFO_MAPSIZE;
pub const BEHAVIOR_LAYOUT_INFO_Max = BEHAVIOR_LAYOUT_INFO.Max;

pub const BEHAVIOR_LAYOUT_MODE = extern enum(i32) {
    BEHAVIORLAYOUTMODE_NATURAL = 1,
    BEHAVIORLAYOUTMODE_MINWIDTH = 2,
    BEHAVIORLAYOUTMODE_MAXWIDTH = 4,
    BEHAVIORLAYOUTMODE_MEDIA_RESOLUTION = 16384,
    BEHAVIORLAYOUTMODE_FINAL_PERCENT = 32768,
    Max = 2147483647,
};
pub const BEHAVIORLAYOUTMODE_NATURAL = BEHAVIOR_LAYOUT_MODE.BEHAVIORLAYOUTMODE_NATURAL;
pub const BEHAVIORLAYOUTMODE_MINWIDTH = BEHAVIOR_LAYOUT_MODE.BEHAVIORLAYOUTMODE_MINWIDTH;
pub const BEHAVIORLAYOUTMODE_MAXWIDTH = BEHAVIOR_LAYOUT_MODE.BEHAVIORLAYOUTMODE_MAXWIDTH;
pub const BEHAVIORLAYOUTMODE_MEDIA_RESOLUTION = BEHAVIOR_LAYOUT_MODE.BEHAVIORLAYOUTMODE_MEDIA_RESOLUTION;
pub const BEHAVIORLAYOUTMODE_FINAL_PERCENT = BEHAVIOR_LAYOUT_MODE.BEHAVIORLAYOUTMODE_FINAL_PERCENT;
pub const BEHAVIOR_LAYOUT_MODE_Max = BEHAVIOR_LAYOUT_MODE.Max;

pub const ELEMENTDESCRIPTOR_FLAGS = extern enum(i32) {
    ELEMENTDESCRIPTORFLAGS_LITERAL = 1,
    ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL = 2,
    Max = 2147483647,
};
pub const ELEMENTDESCRIPTORFLAGS_LITERAL = ELEMENTDESCRIPTOR_FLAGS.ELEMENTDESCRIPTORFLAGS_LITERAL;
pub const ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL = ELEMENTDESCRIPTOR_FLAGS.ELEMENTDESCRIPTORFLAGS_NESTED_LITERAL;
pub const ELEMENTDESCRIPTOR_FLAGS_Max = ELEMENTDESCRIPTOR_FLAGS.Max;

pub const ELEMENTNAMESPACE_FLAGS = extern enum(i32) {
    ELEMENTNAMESPACEFLAGS_ALLOWANYTAG = 1,
    ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS = 2,
    Max = 2147483647,
};
pub const ELEMENTNAMESPACEFLAGS_ALLOWANYTAG = ELEMENTNAMESPACE_FLAGS.ELEMENTNAMESPACEFLAGS_ALLOWANYTAG;
pub const ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS = ELEMENTNAMESPACE_FLAGS.ELEMENTNAMESPACEFLAGS_QUERYFORUNKNOWNTAGS;
pub const ELEMENTNAMESPACE_FLAGS_Max = ELEMENTNAMESPACE_FLAGS.Max;

pub const VIEW_OBJECT_ALPHA_MODE = extern enum(i32) {
    IGNORE = 0,
    PREMULTIPLIED = 1,
    Max = 2147483647,
};
pub const VIEW_OBJECT_ALPHA_MODE_IGNORE = VIEW_OBJECT_ALPHA_MODE.IGNORE;
pub const VIEW_OBJECT_ALPHA_MODE_PREMULTIPLIED = VIEW_OBJECT_ALPHA_MODE.PREMULTIPLIED;
pub const VIEW_OBJECT_ALPHA_MODE_Max = VIEW_OBJECT_ALPHA_MODE.Max;

pub const VIEW_OBJECT_COMPOSITION_MODE = extern enum(i32) {
    LEGACY = 0,
    SURFACEPRESENTER = 1,
    Max = 2147483647,
};
pub const VIEW_OBJECT_COMPOSITION_MODE_LEGACY = VIEW_OBJECT_COMPOSITION_MODE.LEGACY;
pub const VIEW_OBJECT_COMPOSITION_MODE_SURFACEPRESENTER = VIEW_OBJECT_COMPOSITION_MODE.SURFACEPRESENTER;
pub const VIEW_OBJECT_COMPOSITION_MODE_Max = VIEW_OBJECT_COMPOSITION_MODE.Max;

const IID_IHTMLEventObj_Value = @import("../zig.zig").Guid.initString("3050F32D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEventObj = &IID_IHTMLEventObj_Value;
pub const IHTMLEventObj = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_srcElement: fn(
            self: *const IHTMLEventObj,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_altKey: fn(
            self: *const IHTMLEventObj,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ctrlKey: fn(
            self: *const IHTMLEventObj,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shiftKey: fn(
            self: *const IHTMLEventObj,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_returnValue: fn(
            self: *const IHTMLEventObj,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_returnValue: fn(
            self: *const IHTMLEventObj,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cancelBubble: fn(
            self: *const IHTMLEventObj,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cancelBubble: fn(
            self: *const IHTMLEventObj,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fromElement: fn(
            self: *const IHTMLEventObj,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_toElement: fn(
            self: *const IHTMLEventObj,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_keyCode: fn(
            self: *const IHTMLEventObj,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_keyCode: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_button: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLEventObj,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_qualifier: fn(
            self: *const IHTMLEventObj,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_reason: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientX: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientY: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetX: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetY: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenX: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenY: fn(
            self: *const IHTMLEventObj,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_srcFilter: fn(
            self: *const IHTMLEventObj,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_srcElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_srcElement(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_altKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_altKey(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_ctrlKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_ctrlKey(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_shiftKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_shiftKey(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_put_returnValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).put_returnValue(@ptrCast(*const IHTMLEventObj, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_returnValue(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_returnValue(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_put_cancelBubble(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).put_cancelBubble(@ptrCast(*const IHTMLEventObj, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_cancelBubble(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_cancelBubble(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_fromElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_fromElement(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_toElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_toElement(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_put_keyCode(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).put_keyCode(@ptrCast(*const IHTMLEventObj, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_keyCode(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_keyCode(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_button(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_button(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_type(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_qualifier(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_qualifier(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_reason(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_reason(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_x(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_x(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_y(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_y(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_clientX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_clientX(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_clientY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_clientY(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_offsetX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_offsetX(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_offsetY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_offsetY(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_screenX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_screenX(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_screenY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_screenY(@ptrCast(*const IHTMLEventObj, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj_get_srcFilter(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj.VTable, self.vtable).get_srcFilter(@ptrCast(*const IHTMLEventObj, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSite_Value = @import("../zig.zig").Guid.initString("3050F427-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorSite = &IID_IElementBehaviorSite_Value;
pub const IElementBehaviorSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetElement: fn(
            self: *const IElementBehaviorSite,
            ppElement: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterNotification: fn(
            self: *const IElementBehaviorSite,
            lEvent: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSite_GetElement(self: *const T, ppElement: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSite.VTable, self.vtable).GetElement(@ptrCast(*const IElementBehaviorSite, self), ppElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSite_RegisterNotification(self: *const T, lEvent: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSite.VTable, self.vtable).RegisterNotification(@ptrCast(*const IElementBehaviorSite, self), lEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehavior_Value = @import("../zig.zig").Guid.initString("3050F425-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehavior = &IID_IElementBehavior_Value;
pub const IElementBehavior = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IElementBehavior,
            pBehaviorSite: *IElementBehaviorSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Notify: fn(
            self: *const IElementBehavior,
            lEvent: i32,
            pVar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const IElementBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehavior_Init(self: *const T, pBehaviorSite: *IElementBehaviorSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehavior.VTable, self.vtable).Init(@ptrCast(*const IElementBehavior, self), pBehaviorSite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehavior_Notify(self: *const T, lEvent: i32, pVar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehavior.VTable, self.vtable).Notify(@ptrCast(*const IElementBehavior, self), lEvent, pVar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehavior_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehavior.VTable, self.vtable).Detach(@ptrCast(*const IElementBehavior, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorFactory_Value = @import("../zig.zig").Guid.initString("3050F429-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorFactory = &IID_IElementBehaviorFactory_Value;
pub const IElementBehaviorFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FindBehavior: fn(
            self: *const IElementBehaviorFactory,
            bstrBehavior: BSTR,
            bstrBehaviorUrl: BSTR,
            pSite: *IElementBehaviorSite,
            ppBehavior: **IElementBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorFactory_FindBehavior(self: *const T, bstrBehavior: BSTR, bstrBehaviorUrl: BSTR, pSite: *IElementBehaviorSite, ppBehavior: **IElementBehavior) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorFactory.VTable, self.vtable).FindBehavior(@ptrCast(*const IElementBehaviorFactory, self), bstrBehavior, bstrBehaviorUrl, pSite, ppBehavior);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteOM_Value = @import("../zig.zig").Guid.initString("3050F489-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorSiteOM = &IID_IElementBehaviorSiteOM_Value;
pub const IElementBehaviorSiteOM = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RegisterEvent: fn(
            self: *const IElementBehaviorSiteOM,
            pchEvent: PWSTR,
            lFlags: i32,
            plCookie: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCookie: fn(
            self: *const IElementBehaviorSiteOM,
            pchEvent: PWSTR,
            plCookie: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FireEvent: fn(
            self: *const IElementBehaviorSiteOM,
            lCookie: i32,
            pEventObject: *IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateEventObject: fn(
            self: *const IElementBehaviorSiteOM,
            ppEventObject: **IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterName: fn(
            self: *const IElementBehaviorSiteOM,
            pchName: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterUrn: fn(
            self: *const IElementBehaviorSiteOM,
            pchUrn: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_RegisterEvent(self: *const T, pchEvent: PWSTR, lFlags: i32, plCookie: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).RegisterEvent(@ptrCast(*const IElementBehaviorSiteOM, self), pchEvent, lFlags, plCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_GetEventCookie(self: *const T, pchEvent: PWSTR, plCookie: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).GetEventCookie(@ptrCast(*const IElementBehaviorSiteOM, self), pchEvent, plCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_FireEvent(self: *const T, lCookie: i32, pEventObject: *IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).FireEvent(@ptrCast(*const IElementBehaviorSiteOM, self), lCookie, pEventObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_CreateEventObject(self: *const T, ppEventObject: **IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).CreateEventObject(@ptrCast(*const IElementBehaviorSiteOM, self), ppEventObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_RegisterName(self: *const T, pchName: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).RegisterName(@ptrCast(*const IElementBehaviorSiteOM, self), pchName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM_RegisterUrn(self: *const T, pchUrn: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM.VTable, self.vtable).RegisterUrn(@ptrCast(*const IElementBehaviorSiteOM, self), pchUrn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorRender_Value = @import("../zig.zig").Guid.initString("3050F4AA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorRender = &IID_IElementBehaviorRender_Value;
pub const IElementBehaviorRender = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Draw: fn(
            self: *const IElementBehaviorRender,
            hdc: HDC,
            lLayer: i32,
            pRect: *RECT,
            pReserved: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRenderInfo: fn(
            self: *const IElementBehaviorRender,
            plRenderInfo: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HitTestPoint: fn(
            self: *const IElementBehaviorRender,
            pPoint: *POINT,
            pReserved: *IUnknown,
            pbHit: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorRender_Draw(self: *const T, hdc: HDC, lLayer: i32, pRect: *RECT, pReserved: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorRender.VTable, self.vtable).Draw(@ptrCast(*const IElementBehaviorRender, self), hdc, lLayer, pRect, pReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorRender_GetRenderInfo(self: *const T, plRenderInfo: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorRender.VTable, self.vtable).GetRenderInfo(@ptrCast(*const IElementBehaviorRender, self), plRenderInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorRender_HitTestPoint(self: *const T, pPoint: *POINT, pReserved: *IUnknown, pbHit: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorRender.VTable, self.vtable).HitTestPoint(@ptrCast(*const IElementBehaviorRender, self), pPoint, pReserved, pbHit);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteRender_Value = @import("../zig.zig").Guid.initString("3050F4A7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorSiteRender = &IID_IElementBehaviorSiteRender_Value;
pub const IElementBehaviorSiteRender = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Invalidate: fn(
            self: *const IElementBehaviorSiteRender,
            pRect: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateRenderInfo: fn(
            self: *const IElementBehaviorSiteRender,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateStyle: fn(
            self: *const IElementBehaviorSiteRender,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteRender_Invalidate(self: *const T, pRect: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteRender.VTable, self.vtable).Invalidate(@ptrCast(*const IElementBehaviorSiteRender, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteRender_InvalidateRenderInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteRender.VTable, self.vtable).InvalidateRenderInfo(@ptrCast(*const IElementBehaviorSiteRender, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteRender_InvalidateStyle(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteRender.VTable, self.vtable).InvalidateStyle(@ptrCast(*const IElementBehaviorSiteRender, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMEvent_Value = @import("../zig.zig").Guid.initString("305104BA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMEvent = &IID_IDOMEvent_Value;
pub const IDOMEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_bubbles: fn(
            self: *const IDOMEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cancelable: fn(
            self: *const IDOMEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentTarget: fn(
            self: *const IDOMEvent,
            p: **IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultPrevented: fn(
            self: *const IDOMEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_eventPhase: fn(
            self: *const IDOMEvent,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_target: fn(
            self: *const IDOMEvent,
            p: **IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_timeStamp: fn(
            self: *const IDOMEvent,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IDOMEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initEvent: fn(
            self: *const IDOMEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        preventDefault: fn(
            self: *const IDOMEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stopPropagation: fn(
            self: *const IDOMEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stopImmediatePropagation: fn(
            self: *const IDOMEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isTrusted: fn(
            self: *const IDOMEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cancelBubble: fn(
            self: *const IDOMEvent,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cancelBubble: fn(
            self: *const IDOMEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_srcElement: fn(
            self: *const IDOMEvent,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_bubbles(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_bubbles(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_cancelable(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_cancelable(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_currentTarget(self: *const T, p: **IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_currentTarget(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_defaultPrevented(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_defaultPrevented(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_eventPhase(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_eventPhase(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_target(self: *const T, p: **IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_target(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_timeStamp(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_timeStamp(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_type(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_initEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).initEvent(@ptrCast(*const IDOMEvent, self), eventType, canBubble, cancelable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_preventDefault(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).preventDefault(@ptrCast(*const IDOMEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_stopPropagation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).stopPropagation(@ptrCast(*const IDOMEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_stopImmediatePropagation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).stopImmediatePropagation(@ptrCast(*const IDOMEvent, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_isTrusted(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_isTrusted(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_put_cancelBubble(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).put_cancelBubble(@ptrCast(*const IDOMEvent, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_cancelBubble(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_cancelBubble(@ptrCast(*const IDOMEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEvent_get_srcElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEvent.VTable, self.vtable).get_srcElement(@ptrCast(*const IDOMEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMConstructor_Value = @import("../zig.zig").Guid.initString("3051049B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMConstructor = &IID_IHTMLDOMConstructor_Value;
pub const IHTMLDOMConstructor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_constructor: fn(
            self: *const IHTMLDOMConstructor,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupGetter: fn(
            self: *const IHTMLDOMConstructor,
            propname: BSTR,
            ppDispHandler: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LookupSetter: fn(
            self: *const IHTMLDOMConstructor,
            propname: BSTR,
            ppDispHandler: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineGetter: fn(
            self: *const IHTMLDOMConstructor,
            propname: BSTR,
            pdispHandler: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineSetter: fn(
            self: *const IHTMLDOMConstructor,
            propname: BSTR,
            pdispHandler: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_get_constructor(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).get_constructor(@ptrCast(*const IHTMLDOMConstructor, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_LookupGetter(self: *const T, propname: BSTR, ppDispHandler: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).LookupGetter(@ptrCast(*const IHTMLDOMConstructor, self), propname, ppDispHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_LookupSetter(self: *const T, propname: BSTR, ppDispHandler: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).LookupSetter(@ptrCast(*const IHTMLDOMConstructor, self), propname, ppDispHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_DefineGetter(self: *const T, propname: BSTR, pdispHandler: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).DefineGetter(@ptrCast(*const IHTMLDOMConstructor, self), propname, pdispHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructor_DefineSetter(self: *const T, propname: BSTR, pdispHandler: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructor.VTable, self.vtable).DefineSetter(@ptrCast(*const IHTMLDOMConstructor, self), propname, pdispHandler);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRule_Value = @import("../zig.zig").Guid.initString("3050F357-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetRule = &IID_IHTMLStyleSheetRule_Value;
pub const IHTMLStyleSheetRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_selectorText: fn(
            self: *const IHTMLStyleSheetRule,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectorText: fn(
            self: *const IHTMLStyleSheetRule,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_style: fn(
            self: *const IHTMLStyleSheetRule,
            p: **IHTMLRuleStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readOnly: fn(
            self: *const IHTMLStyleSheetRule,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule_put_selectorText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule.VTable, self.vtable).put_selectorText(@ptrCast(*const IHTMLStyleSheetRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule_get_selectorText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule.VTable, self.vtable).get_selectorText(@ptrCast(*const IHTMLStyleSheetRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule_get_style(self: *const T, p: **IHTMLRuleStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule.VTable, self.vtable).get_style(@ptrCast(*const IHTMLStyleSheetRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule_get_readOnly(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLStyleSheetRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSStyleDeclaration_Value = @import("../zig.zig").Guid.initString("30510740-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCSSStyleDeclaration = &IID_IHTMLCSSStyleDeclaration_Value;
pub const IHTMLCSSStyleDeclaration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPropertyValue: fn(
            self: *const IHTMLCSSStyleDeclaration,
            bstrPropertyName: BSTR,
            pbstrPropertyValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPropertyPriority: fn(
            self: *const IHTMLCSSStyleDeclaration,
            bstrPropertyName: BSTR,
            pbstrPropertyPriority: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeProperty: fn(
            self: *const IHTMLCSSStyleDeclaration,
            bstrPropertyName: BSTR,
            pbstrPropertyValue: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setProperty: fn(
            self: *const IHTMLCSSStyleDeclaration,
            bstrPropertyName: BSTR,
            pvarPropertyValue: *VARIANT,
            pvarPropertyPriority: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLCSSStyleDeclaration,
            index: i32,
            pbstrPropertyName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontFamily: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontFamily: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontVariant: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontVariant: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontWeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontWeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontSize: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontSize: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_font: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_font: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_color: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_color: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_background: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_background: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundImage: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundImage: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundAttachment: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundAttachment: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundPosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundPositionX: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPositionX: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundPositionY: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPositionY: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wordSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_letterSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_letterSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecoration: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecoration: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_verticalAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_verticalAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textTransform: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textTransform: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textIndent: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textIndent: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lineHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_margin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_margin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_padding: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_padding: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeftColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRightWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeftWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRightStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeftStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_styleFloat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_styleFloat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clear: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clear: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_display: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_display: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_visibility: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_visibility: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStyleType: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyleType: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStylePosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStylePosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStyleImage: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyleImage: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_whiteSpace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_whiteSpace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_top: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_top: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_left: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_left: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_zIndex: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_zIndex: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_overflow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageBreakBefore: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakBefore: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageBreakAfter: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakAfter: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cssText: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cssText: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cursor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cursor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clip: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clip: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_filter: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_filter: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_tableLayout: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tableLayout: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderCollapse: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderCollapse: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_direction: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_direction: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_behavior: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_behavior: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_position: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_position: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_unicodeBidi: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unicodeBidi: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_right: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_right: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_imeMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imeMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rubyAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyAlign: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rubyPosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyPosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rubyOverhang: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyOverhang: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridChar: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridChar: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridLine: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridLine: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridType: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridType: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGrid: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGrid: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAutospace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAutospace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wordBreak: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordBreak: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lineBreak: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineBreak: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textJustify: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textJustify: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textJustifyTrim: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textJustifyTrim: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textKashida: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textKashida: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_overflowX: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflowX: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_overflowY: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflowY: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_accelerator: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accelerator: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutFlow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutFlow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_zoom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_zoom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wordWrap: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordWrap: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textUnderlinePosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textUnderlinePosition: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarBaseColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarBaseColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarFaceColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarFaceColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbar3dLightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbar3dLightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarShadowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarShadowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarHighlightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarHighlightColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarDarkShadowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarDarkShadowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarArrowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarArrowColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarTrackColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarTrackColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_writingMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_writingMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAlignLast: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAlignLast: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textKashidaSpace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textKashidaSpace: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textOverflow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textOverflow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_minHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_minHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msInterpolationMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msInterpolationMode: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maxHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxHeight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_minWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_minWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maxWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_content: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_content: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_captionSide: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_captionSide: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_counterIncrement: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_counterIncrement: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_counterReset: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_counterReset: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outlineWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outlineStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineStyle: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outlineColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_boxSizing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boxSizing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderSpacing: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_orphans: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_orphans: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_widows: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_widows: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageBreakInside: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakInside: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_emptyCells: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_emptyCells: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msBlockProgression: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msBlockProgression: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_quotes: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_quotes: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alignmentBaseline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alignmentBaseline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_baselineShift: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baselineShift: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dominantBaseline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dominantBaseline: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontStretch: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontStretch: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_opacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_opacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clipPath: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipPath: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clipRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fill: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fill: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fillOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fillOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fillRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fillRule: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_kerning: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_kerning: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marker: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marker: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_markerEnd: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_markerEnd: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_markerMid: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_markerMid: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_markerStart: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_markerStart: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_mask: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_mask: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pointerEvents: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pointerEvents: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_stopColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_stopColor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_stopOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_stopOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_stroke: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_stroke: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_strokeDasharray: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_strokeDasharray: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_strokeDashoffset: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_strokeDashoffset: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_strokeLinecap: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_strokeLinecap: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_strokeLinejoin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_strokeLinejoin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_strokeMiterlimit: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_strokeMiterlimit: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_strokeOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_strokeOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_strokeWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_strokeWidth: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAnchor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAnchor: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_glyphOrientationHorizontal: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_glyphOrientationHorizontal: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_glyphOrientationVertical: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_glyphOrientationVertical: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopLeftRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopLeftRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopRightRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopRightRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomRightRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomRightRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomLeftRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomLeftRadius: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clipTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipTop: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clipRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipRight: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipBottom: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clipLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipLeft: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cssFloat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cssFloat: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundClip: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundClip: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundSize: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundSize: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_boxShadow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boxShadow: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTransform: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTransform: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTransformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTransformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_length(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_parentRule(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_parentRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_getPropertyValue(self: *const T, bstrPropertyName: BSTR, pbstrPropertyValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).getPropertyValue(@ptrCast(*const IHTMLCSSStyleDeclaration, self), bstrPropertyName, pbstrPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_getPropertyPriority(self: *const T, bstrPropertyName: BSTR, pbstrPropertyPriority: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).getPropertyPriority(@ptrCast(*const IHTMLCSSStyleDeclaration, self), bstrPropertyName, pbstrPropertyPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_removeProperty(self: *const T, bstrPropertyName: BSTR, pbstrPropertyValue: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).removeProperty(@ptrCast(*const IHTMLCSSStyleDeclaration, self), bstrPropertyName, pbstrPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_setProperty(self: *const T, bstrPropertyName: BSTR, pvarPropertyValue: *VARIANT, pvarPropertyPriority: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).setProperty(@ptrCast(*const IHTMLCSSStyleDeclaration, self), bstrPropertyName, pvarPropertyValue, pvarPropertyPriority);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_item(self: *const T, index: i32, pbstrPropertyName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).item(@ptrCast(*const IHTMLCSSStyleDeclaration, self), index, pbstrPropertyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontFamily(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontFamily(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontFamily(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontFamily(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontVariant(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontVariant(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontVariant(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontVariant(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontWeight(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontWeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontWeight(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontSize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontSize(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontSize(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_font(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_font(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_font(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_font(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_color(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_color(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_color(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_background(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_background(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_background(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_background(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundImage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundImage(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundImage(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundRepeat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundRepeat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundAttachment(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundAttachment(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundAttachment(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundAttachment(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundPosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundPosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundPosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundPosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundPositionX(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundPositionX(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundPositionX(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundPositionX(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundPositionY(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundPositionY(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundPositionY(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundPositionY(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_wordSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_wordSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_wordSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_wordSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_letterSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_letterSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_letterSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_letterSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textDecoration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textDecoration(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textDecoration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_verticalAlign(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_verticalAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_verticalAlign(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_verticalAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textTransform(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textTransform(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textTransform(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textTransform(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textIndent(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textIndent(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textIndent(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textIndent(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_lineHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_lineHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_lineHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_lineHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marginTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marginTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marginTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marginTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marginRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marginRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marginRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marginRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marginBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marginBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marginBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marginBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marginLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marginLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marginLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marginLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_margin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_margin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_margin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_margin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_paddingTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_paddingTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_paddingTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_paddingTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_paddingRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_paddingRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_paddingRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_paddingRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_paddingBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_paddingBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_paddingBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_paddingBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_paddingLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_paddingLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_paddingLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_paddingLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_padding(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_padding(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_padding(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_padding(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_border(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_border(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_border(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_border(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTop(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTop(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRight(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRight(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottom(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottom(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderLeft(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderLeft(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderColor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderColor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderLeftColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderLeftColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderLeftColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderLeftColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderWidth(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderWidth(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRightWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRightWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRightWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRightWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderLeftWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderLeftWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderLeftWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderLeftWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRightStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRightStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRightStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRightStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderLeftStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderLeftStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderLeftStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderLeftStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_width(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_width(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_height(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_height(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_styleFloat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_styleFloat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_styleFloat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_styleFloat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clear(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clear(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_display(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_display(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_display(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_display(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_visibility(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_visibility(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_visibility(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_visibility(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_listStyleType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_listStyleType(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_listStyleType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_listStyleType(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_listStylePosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_listStylePosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_listStylePosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_listStylePosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_listStyleImage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_listStyleImage(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_listStyleImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_listStyleImage(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_listStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_listStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_listStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_listStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_whiteSpace(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_whiteSpace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_whiteSpace(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_whiteSpace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_top(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_top(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_top(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_top(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_left(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_left(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_left(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_left(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_zIndex(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_zIndex(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_zIndex(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_zIndex(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_overflow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_overflow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_overflow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_overflow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_pageBreakBefore(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_pageBreakBefore(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_pageBreakBefore(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_pageBreakBefore(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_pageBreakAfter(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_pageBreakAfter(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_pageBreakAfter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_pageBreakAfter(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_cssText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_cssText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_cursor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_cursor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_cursor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_cursor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clip(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clip(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clip(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clip(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_filter(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_filter(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_filter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_filter(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_tableLayout(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_tableLayout(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_tableLayout(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_tableLayout(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderCollapse(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderCollapse(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderCollapse(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderCollapse(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_direction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_direction(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_direction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_behavior(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_behavior(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_behavior(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_position(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_position(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_position(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_position(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_unicodeBidi(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_unicodeBidi(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_unicodeBidi(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_unicodeBidi(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_bottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_bottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_bottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_right(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_right(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_right(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_right(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_imeMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_imeMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_imeMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_imeMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_rubyAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_rubyAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_rubyAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_rubyAlign(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_rubyPosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_rubyPosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_rubyPosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_rubyPosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_rubyOverhang(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_rubyOverhang(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_rubyOverhang(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_rubyOverhang(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGridChar(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGridChar(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGridChar(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGridChar(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGridLine(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGridLine(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGridLine(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGridLine(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGridMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGridMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGridMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGridMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGridType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGridType(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGridType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGridType(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutGrid(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutGrid(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutGrid(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutGrid(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textAutospace(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textAutospace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textAutospace(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textAutospace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_wordBreak(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_wordBreak(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_wordBreak(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_wordBreak(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_lineBreak(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_lineBreak(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_lineBreak(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_lineBreak(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textJustify(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textJustify(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textJustify(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textJustify(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textJustifyTrim(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textJustifyTrim(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textJustifyTrim(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textJustifyTrim(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textKashida(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textKashida(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textKashida(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textKashida(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_overflowX(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_overflowX(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_overflowX(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_overflowX(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_overflowY(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_overflowY(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_overflowY(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_overflowY(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_accelerator(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_accelerator(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_accelerator(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_accelerator(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_layoutFlow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_layoutFlow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_layoutFlow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_layoutFlow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_zoom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_zoom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_zoom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_zoom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_wordWrap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_wordWrap(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_wordWrap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_wordWrap(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textUnderlinePosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textUnderlinePosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textUnderlinePosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textUnderlinePosition(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarBaseColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarBaseColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarBaseColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarBaseColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarFaceColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarFaceColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarFaceColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarFaceColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbar3dLightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbar3dLightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbar3dLightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbar3dLightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarShadowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarShadowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarShadowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarHighlightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarHighlightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarHighlightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarHighlightColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarDarkShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarDarkShadowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarDarkShadowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarDarkShadowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarArrowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarArrowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarArrowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarArrowColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_scrollbarTrackColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_scrollbarTrackColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_scrollbarTrackColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_scrollbarTrackColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_writingMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_writingMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_writingMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_writingMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textAlignLast(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textAlignLast(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textAlignLast(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textAlignLast(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textKashidaSpace(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textKashidaSpace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textKashidaSpace(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textKashidaSpace(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textOverflow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textOverflow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textOverflow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textOverflow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_minHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_minHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_minHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_minHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_msInterpolationMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_msInterpolationMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_msInterpolationMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_msInterpolationMode(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_maxHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_maxHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_maxHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_maxHeight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_minWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_minWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_minWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_minWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_maxWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_maxWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_maxWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_maxWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_content(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_content(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_content(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_content(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_captionSide(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_captionSide(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_captionSide(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_captionSide(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_counterIncrement(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_counterIncrement(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_counterIncrement(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_counterIncrement(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_counterReset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_counterReset(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_counterReset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_counterReset(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_outline(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_outline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_outline(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_outline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_outlineWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_outlineWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_outlineWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_outlineWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_outlineStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_outlineStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_outlineStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_outlineStyle(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_outlineColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_outlineColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_outlineColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_outlineColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_boxSizing(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_boxSizing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_boxSizing(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_boxSizing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderSpacing(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderSpacing(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderSpacing(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_orphans(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_orphans(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_orphans(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_orphans(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_widows(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_widows(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_widows(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_widows(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_pageBreakInside(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_pageBreakInside(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_pageBreakInside(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_pageBreakInside(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_emptyCells(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_emptyCells(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_emptyCells(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_emptyCells(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_msBlockProgression(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_msBlockProgression(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_msBlockProgression(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_msBlockProgression(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_quotes(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_quotes(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_quotes(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_quotes(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_alignmentBaseline(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_alignmentBaseline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_alignmentBaseline(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_alignmentBaseline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_baselineShift(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_baselineShift(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_baselineShift(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_baselineShift(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_dominantBaseline(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_dominantBaseline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_dominantBaseline(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_dominantBaseline(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontSizeAdjust(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontSizeAdjust(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fontStretch(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fontStretch(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fontStretch(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fontStretch(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_opacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_opacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_opacity(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_opacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipPath(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipPath(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipPath(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipPath(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipRule(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipRule(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fill(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fill(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fill(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fill(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fillOpacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fillOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fillOpacity(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fillOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_fillRule(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_fillRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_fillRule(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_fillRule(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_kerning(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_kerning(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_kerning(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_kerning(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_marker(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_marker(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_marker(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_marker(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_markerEnd(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_markerEnd(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_markerEnd(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_markerEnd(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_markerMid(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_markerMid(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_markerMid(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_markerMid(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_markerStart(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_markerStart(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_markerStart(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_markerStart(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_mask(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_mask(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_mask(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_mask(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_pointerEvents(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_pointerEvents(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_pointerEvents(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_pointerEvents(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_stopColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_stopColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_stopColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_stopColor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_stopOpacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_stopOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_stopOpacity(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_stopOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_stroke(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_stroke(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_stroke(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_stroke(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeDasharray(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeDasharray(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeDasharray(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeDasharray(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeDashoffset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeDashoffset(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeDashoffset(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeDashoffset(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeLinecap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeLinecap(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeLinecap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeLinecap(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeLinejoin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeLinejoin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeLinejoin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeLinejoin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeMiterlimit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeMiterlimit(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeMiterlimit(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeMiterlimit(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeOpacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeOpacity(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_strokeWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_strokeWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_strokeWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_strokeWidth(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_textAnchor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_textAnchor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_textAnchor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_textAnchor(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_glyphOrientationHorizontal(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_glyphOrientationHorizontal(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_glyphOrientationHorizontal(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_glyphOrientationHorizontal(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_glyphOrientationVertical(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_glyphOrientationVertical(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_glyphOrientationVertical(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_glyphOrientationVertical(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderRadius(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderRadius(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopLeftRadius(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopLeftRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopLeftRadius(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopLeftRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderTopRightRadius(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderTopRightRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderTopRightRadius(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderTopRightRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomRightRadius(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomRightRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomRightRadius(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomRightRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_borderBottomLeftRadius(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_borderBottomLeftRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_borderBottomLeftRadius(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_borderBottomLeftRadius(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipTop(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipRight(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipBottom(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_clipLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_clipLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_clipLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_clipLeft(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_cssFloat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_cssFloat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_cssFloat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_cssFloat(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundClip(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundClip(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundClip(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundClip(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundOrigin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundOrigin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_backgroundSize(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_backgroundSize(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_backgroundSize(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_backgroundSize(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_boxShadow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_boxShadow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_boxShadow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_boxShadow(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_msTransform(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_msTransform(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_msTransform(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_msTransform(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_put_msTransformOrigin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).put_msTransformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration_get_msTransformOrigin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration.VTable, self.vtable).get_msTransformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSStyleDeclaration2_Value = @import("../zig.zig").Guid.initString("305107D1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCSSStyleDeclaration2 = &IID_IHTMLCSSStyleDeclaration2_Value;
pub const IHTMLCSSStyleDeclaration2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_msScrollChaining: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollChaining: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msContentZooming: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msContentZooming: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msContentZoomSnapType: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msContentZoomSnapType: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollRails: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollRails: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msContentZoomChaining: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msContentZoomChaining: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollSnapType: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollSnapType: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msContentZoomLimit: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msContentZoomLimit: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msContentZoomSnap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msContentZoomSnap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msContentZoomSnapPoints: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msContentZoomSnapPoints: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msContentZoomLimitMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msContentZoomLimitMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msContentZoomLimitMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msContentZoomLimitMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollSnapX: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollSnapX: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollSnapY: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollSnapY: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollSnapPointsX: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollSnapPointsX: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollSnapPointsY: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollSnapPointsY: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msGridColumn: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msGridColumn: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msGridColumnAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msGridColumnAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msGridColumns: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msGridColumns: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msGridColumnSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msGridColumnSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msGridRow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msGridRow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msGridRowAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msGridRowAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msGridRows: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msGridRows: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msGridRowSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msGridRowSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msWrapThrough: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msWrapThrough: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msWrapMargin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msWrapMargin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msWrapFlow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msWrapFlow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msAnimationName: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msAnimationName: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msAnimationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msAnimationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msAnimationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msAnimationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msAnimationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msAnimationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msAnimationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msAnimationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msAnimationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msAnimationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msAnimationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msAnimationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msAnimation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msAnimation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msAnimationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msAnimationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_colorInterpolationFilters: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_colorInterpolationFilters: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columnCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columnCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columnWidth: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columnWidth: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columnGap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columnGap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columnFill: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columnFill: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columnSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columnSpan: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columns: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columns: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columnRule: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columnRule: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columnRuleColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columnRuleColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columnRuleStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columnRuleStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_columnRuleWidth: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_columnRuleWidth: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_breakBefore: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_breakBefore: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_breakAfter: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_breakAfter: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_breakInside: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_breakInside: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_floodColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_floodColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_floodOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_floodOpacity: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lightingColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lightingColor: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollLimitXMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollLimitXMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollLimitYMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollLimitYMin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollLimitXMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollLimitXMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollLimitYMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollLimitYMax: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollLimit: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollLimit: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textShadow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textShadow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlowFrom: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlowFrom: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlowInto: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlowInto: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msHyphens: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msHyphens: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msHyphenateLimitZone: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msHyphenateLimitZone: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msHyphenateLimitChars: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msHyphenateLimitChars: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msHyphenateLimitLines: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msHyphenateLimitLines: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msHighContrastAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msHighContrastAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_enableBackground: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_enableBackground: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFontFeatureSettings: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFontFeatureSettings: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msUserSelect: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msUserSelect: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msOverflowStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msOverflowStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTransformStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTransformStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msBackfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msBackfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msPerspective: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msPerspective: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msPerspectiveOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msPerspectiveOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTransitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTransitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTransitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTransitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTransitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTransitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTransitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTransitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTransition: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTransition: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTouchAction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTouchAction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msScrollTranslation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msScrollTranslation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlex: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlex: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexPositive: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexPositive: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexNegative: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexNegative: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexPreferredSize: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexPreferredSize: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexFlow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexFlow: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexWrap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexWrap: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexItemAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexItemAlign: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexPack: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexPack: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexLinePack: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexLinePack: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msFlexOrder: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFlexOrder: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTouchSelect: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTouchSelect: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_transform: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_transform: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_transformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_transformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_transformStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_transformStyle: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_perspective: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_perspective: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_perspectiveOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_perspectiveOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_transitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_transitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_transitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_transitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_transitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_transitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_transitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_transitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_transition: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_transition: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontFeatureSettings: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontFeatureSettings: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animationName: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animationName: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animation: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollChaining(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollChaining(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollChaining(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollChaining(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZooming(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZooming(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZooming(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZooming(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomSnapType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomSnapType(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomSnapType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomSnapType(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollRails(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollRails(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollRails(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollRails(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomChaining(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomChaining(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomChaining(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomChaining(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapType(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapType(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomLimit(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomLimit(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomLimit(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomLimit(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomSnap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomSnap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomSnap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomSnap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomSnapPoints(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomSnapPoints(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomSnapPoints(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomSnapPoints(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomLimitMin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomLimitMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomLimitMin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomLimitMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msContentZoomLimitMax(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msContentZoomLimitMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msContentZoomLimitMax(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msContentZoomLimitMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapX(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapX(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapX(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapX(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapY(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapY(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapY(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapY(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapPointsX(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapPointsX(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapPointsX(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapPointsX(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollSnapPointsY(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollSnapPointsY(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollSnapPointsY(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollSnapPointsY(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridColumn(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridColumn(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridColumn(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridColumn(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridColumnAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridColumnAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridColumnAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridColumnAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridColumns(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridColumns(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridColumns(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridColumns(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridColumnSpan(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridColumnSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridColumnSpan(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridColumnSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridRow(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridRow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridRow(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridRow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridRowAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridRowAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridRowAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridRowAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridRows(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridRows(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridRows(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridRows(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msGridRowSpan(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msGridRowSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msGridRowSpan(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msGridRowSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msWrapThrough(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msWrapThrough(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msWrapThrough(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msWrapThrough(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msWrapMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msWrapMargin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msWrapMargin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msWrapMargin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msWrapFlow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msWrapFlow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msWrapFlow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msWrapFlow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationName(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationName(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationName(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationDuration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationDuration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationTimingFunction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationTimingFunction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationDelay(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationDelay(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationDirection(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationDirection(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationPlayState(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationPlayState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationIterationCount(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationIterationCount(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimation(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimation(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msAnimationFillMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msAnimationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msAnimationFillMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msAnimationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_colorInterpolationFilters(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_colorInterpolationFilters(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_colorInterpolationFilters(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_colorInterpolationFilters(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnCount(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnCount(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnWidth(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnWidth(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnGap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnGap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnGap(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnGap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnFill(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnFill(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnFill(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnFill(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnSpan(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnSpan(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnSpan(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columns(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columns(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columns(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columns(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnRule(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnRule(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnRule(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnRule(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnRuleColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnRuleColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnRuleColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnRuleColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnRuleStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnRuleStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnRuleStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnRuleStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_columnRuleWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_columnRuleWidth(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_columnRuleWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_columnRuleWidth(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_breakBefore(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_breakBefore(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_breakBefore(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_breakBefore(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_breakAfter(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_breakAfter(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_breakAfter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_breakAfter(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_breakInside(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_breakInside(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_breakInside(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_breakInside(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_floodColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_floodColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_floodColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_floodColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_floodOpacity(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_floodOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_floodOpacity(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_floodOpacity(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_lightingColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_lightingColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_lightingColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_lightingColor(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimitXMin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimitXMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimitXMin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimitXMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimitYMin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimitYMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimitYMin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimitYMin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimitXMax(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimitXMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimitXMax(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimitXMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimitYMax(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimitYMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimitYMax(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimitYMax(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollLimit(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollLimit(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollLimit(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollLimit(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_textShadow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_textShadow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_textShadow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_textShadow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlowFrom(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlowFrom(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlowFrom(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlowFrom(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlowInto(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlowInto(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlowInto(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlowInto(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHyphens(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHyphens(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHyphens(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHyphens(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHyphenateLimitZone(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHyphenateLimitZone(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHyphenateLimitZone(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHyphenateLimitZone(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHyphenateLimitChars(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHyphenateLimitChars(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHyphenateLimitChars(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHyphenateLimitChars(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHyphenateLimitLines(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHyphenateLimitLines(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHyphenateLimitLines(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHyphenateLimitLines(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msHighContrastAdjust(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msHighContrastAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msHighContrastAdjust(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msHighContrastAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_enableBackground(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_enableBackground(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_enableBackground(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_enableBackground(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFontFeatureSettings(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFontFeatureSettings(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFontFeatureSettings(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFontFeatureSettings(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msUserSelect(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msUserSelect(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msUserSelect(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msUserSelect(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msOverflowStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msOverflowStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msOverflowStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msOverflowStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransformStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransformStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransformStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransformStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msBackfaceVisibility(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msBackfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msBackfaceVisibility(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msBackfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msPerspective(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msPerspective(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msPerspective(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msPerspective(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msPerspectiveOrigin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msPerspectiveOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msPerspectiveOrigin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msPerspectiveOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransitionProperty(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransitionProperty(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransitionDuration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransitionDuration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransitionTimingFunction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransitionTimingFunction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransitionDelay(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransitionDelay(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTransition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTransition(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTransition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTransition(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTouchAction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTouchAction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTouchAction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTouchAction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msScrollTranslation(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msScrollTranslation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msScrollTranslation(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msScrollTranslation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlex(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlex(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlex(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlex(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexPositive(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexPositive(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexPositive(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexPositive(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexNegative(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexNegative(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexNegative(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexNegative(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexPreferredSize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexPreferredSize(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexPreferredSize(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexPreferredSize(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexFlow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexFlow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexFlow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexFlow(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexDirection(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexDirection(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexWrap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexWrap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexWrap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexWrap(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexItemAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexItemAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexItemAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexItemAlign(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexPack(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexPack(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexPack(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexPack(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexLinePack(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexLinePack(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexLinePack(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexLinePack(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msFlexOrder(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msFlexOrder(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msFlexOrder(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msFlexOrder(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_msTouchSelect(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_msTouchSelect(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_msTouchSelect(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_msTouchSelect(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transform(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transform(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transform(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transform(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transformOrigin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transformOrigin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transformStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transformStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transformStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transformStyle(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_backfaceVisibility(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_backfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_backfaceVisibility(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_backfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_perspective(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_perspective(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_perspective(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_perspective(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_perspectiveOrigin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_perspectiveOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_perspectiveOrigin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_perspectiveOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transitionProperty(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transitionProperty(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transitionDuration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transitionDuration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transitionTimingFunction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transitionTimingFunction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transitionDelay(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transitionDelay(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_transition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_transition(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_transition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_transition(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_fontFeatureSettings(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_fontFeatureSettings(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_fontFeatureSettings(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_fontFeatureSettings(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationName(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationName(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationName(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationDuration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationDuration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationTimingFunction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationTimingFunction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationDelay(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationDelay(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationDirection(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationDirection(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationPlayState(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationPlayState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationIterationCount(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationIterationCount(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animation(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animation(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animation(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_put_animationFillMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).put_animationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration2_get_animationFillMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration2.VTable, self.vtable).get_animationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSStyleDeclaration3_Value = @import("../zig.zig").Guid.initString("3051085C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCSSStyleDeclaration3 = &IID_IHTMLCSSStyleDeclaration3_Value;
pub const IHTMLCSSStyleDeclaration3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_flex: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_flex: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_flexDirection: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_flexDirection: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_flexWrap: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_flexWrap: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_flexFlow: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_flexFlow: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_flexGrow: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_flexGrow: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_flexShrink: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_flexShrink: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_flexBasis: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_flexBasis: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_justifyContent: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_justifyContent: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alignItems: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alignItems: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alignSelf: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alignSelf: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alignContent: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alignContent: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderImage: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderImage: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderImageSource: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderImageSource: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderImageSlice: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderImageSlice: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderImageWidth: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderImageWidth: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderImageOutset: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderImageOutset: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderImageRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderImageRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msImeAlign: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msImeAlign: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTextCombineHorizontal: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTextCombineHorizontal: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_touchAction: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_touchAction: fn(
            self: *const IHTMLCSSStyleDeclaration3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flex(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flex(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flex(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flex(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexDirection(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexDirection(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexDirection(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexDirection(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexWrap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexWrap(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexWrap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexWrap(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexFlow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexFlow(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexFlow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexFlow(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexGrow(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexGrow(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexGrow(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexGrow(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexShrink(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexShrink(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexShrink(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexShrink(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_flexBasis(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_flexBasis(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_flexBasis(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_flexBasis(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_justifyContent(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_justifyContent(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_justifyContent(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_justifyContent(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_alignItems(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_alignItems(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_alignItems(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_alignItems(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_alignSelf(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_alignSelf(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_alignSelf(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_alignSelf(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_alignContent(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_alignContent(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_alignContent(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_alignContent(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImage(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImage(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageSource(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageSource(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageSource(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageSource(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageSlice(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageSlice(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageSlice(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageSlice(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageWidth(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageWidth(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageWidth(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageWidth(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageOutset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageOutset(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageOutset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageOutset(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_borderImageRepeat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_borderImageRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_borderImageRepeat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_borderImageRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_msImeAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_msImeAlign(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_msImeAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_msImeAlign(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_msTextCombineHorizontal(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_msTextCombineHorizontal(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_msTextCombineHorizontal(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_msTextCombineHorizontal(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_put_touchAction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).put_touchAction(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration3_get_touchAction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration3.VTable, self.vtable).get_touchAction(@ptrCast(*const IHTMLCSSStyleDeclaration3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSStyleDeclaration4_Value = @import("../zig.zig").Guid.initString("D6100F3B-27C8-4132-AFEA-F0E4B1E00060");
pub const IID_IHTMLCSSStyleDeclaration4 = &IID_IHTMLCSSStyleDeclaration4_Value;
pub const IHTMLCSSStyleDeclaration4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_webkitAppearance: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAppearance: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitUserSelect: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitUserSelect: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBoxAlign: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBoxAlign: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBoxOrdinalGroup: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBoxOrdinalGroup: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBoxPack: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBoxPack: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBoxFlex: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBoxFlex: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBoxOrient: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBoxOrient: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBoxDirection: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBoxDirection: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitTransform: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitTransform: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundSize: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundSize: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackfaceVisibility: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitAnimation: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAnimation: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitTransition: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitTransition: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitAnimationName: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAnimationName: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitAnimationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAnimationDuration: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitAnimationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAnimationTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitAnimationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAnimationDelay: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitAnimationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAnimationIterationCount: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitAnimationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAnimationDirection: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitAnimationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAnimationPlayState: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitTransitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitTransitionProperty: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitTransitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitTransitionDuration: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitTransitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitTransitionTimingFunction: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitTransitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitTransitionDelay: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundAttachment: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundAttachment: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundColor: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundColor: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundClip: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundClip: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundImage: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundImage: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundPosition: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundPosition: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundPositionX: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundPositionX: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackgroundPositionY: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackgroundPositionY: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBackground: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBackground: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitTransformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitTransformOrigin: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msTextSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msTextSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitTextSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitTextSizeAdjust: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBorderImage: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBorderImage: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBorderImageSource: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBorderImageSource: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBorderImageSlice: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBorderImageSlice: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBorderImageWidth: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBorderImageWidth: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBorderImageOutset: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBorderImageOutset: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBorderImageRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBorderImageRepeat: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitBoxSizing: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitBoxSizing: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_webkitAnimationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_webkitAnimationFillMode: fn(
            self: *const IHTMLCSSStyleDeclaration4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAppearance(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAppearance(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAppearance(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAppearance(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitUserSelect(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitUserSelect(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitUserSelect(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitUserSelect(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxAlign(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxAlign(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxOrdinalGroup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxOrdinalGroup(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxOrdinalGroup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxOrdinalGroup(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxPack(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxPack(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxPack(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxPack(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxFlex(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxFlex(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxFlex(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxFlex(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxOrient(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxOrient(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxOrient(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxOrient(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxDirection(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxDirection(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxDirection(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxDirection(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransform(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransform(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransform(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransform(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundSize(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundSize(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundSize(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundSize(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackfaceVisibility(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackfaceVisibility(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackfaceVisibility(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimation(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimation(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimation(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimation(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransition(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransition(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationName(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationName(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationName(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationDuration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationDuration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationDuration(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationTimingFunction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationTimingFunction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationDelay(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationDelay(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationDelay(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationIterationCount(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationIterationCount(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationIterationCount(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationDirection(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationDirection(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationDirection(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationPlayState(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationPlayState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationPlayState(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransitionProperty(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransitionProperty(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransitionProperty(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransitionDuration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransitionDuration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransitionDuration(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransitionTimingFunction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransitionTimingFunction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransitionTimingFunction(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransitionDelay(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransitionDelay(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransitionDelay(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundAttachment(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundAttachment(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundAttachment(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundAttachment(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundColor(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundColor(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundClip(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundClip(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundClip(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundClip(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundImage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundImage(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundImage(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundRepeat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundRepeat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundOrigin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundOrigin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundPosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundPosition(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundPosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundPosition(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundPositionX(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundPositionX(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundPositionX(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundPositionX(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackgroundPositionY(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackgroundPositionY(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackgroundPositionY(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackgroundPositionY(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBackground(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBackground(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBackground(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBackground(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTransformOrigin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTransformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTransformOrigin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTransformOrigin(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_msTextSizeAdjust(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_msTextSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_msTextSizeAdjust(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_msTextSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitTextSizeAdjust(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitTextSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitTextSizeAdjust(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitTextSizeAdjust(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImage(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImage(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageSource(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageSource(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageSource(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageSource(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageSlice(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageSlice(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageSlice(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageSlice(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageWidth(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageWidth(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageWidth(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageWidth(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageOutset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageOutset(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageOutset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageOutset(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBorderImageRepeat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBorderImageRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBorderImageRepeat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBorderImageRepeat(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitBoxSizing(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitBoxSizing(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitBoxSizing(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitBoxSizing(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_put_webkitAnimationFillMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).put_webkitAnimationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSStyleDeclaration4_get_webkitAnimationFillMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSStyleDeclaration4.VTable, self.vtable).get_webkitAnimationFillMode(@ptrCast(*const IHTMLCSSStyleDeclaration4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleEnabled_Value = @import("../zig.zig").Guid.initString("305104C2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleEnabled = &IID_IHTMLStyleEnabled_Value;
pub const IHTMLStyleEnabled = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        msGetPropertyEnabled: fn(
            self: *const IHTMLStyleEnabled,
            name: BSTR,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msPutPropertyEnabled: fn(
            self: *const IHTMLStyleEnabled,
            name: BSTR,
            b: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleEnabled_msGetPropertyEnabled(self: *const T, name: BSTR, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleEnabled.VTable, self.vtable).msGetPropertyEnabled(@ptrCast(*const IHTMLStyleEnabled, self), name, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleEnabled_msPutPropertyEnabled(self: *const T, name: BSTR, b: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleEnabled.VTable, self.vtable).msPutPropertyEnabled(@ptrCast(*const IHTMLStyleEnabled, self), name, b);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSStyleDeclaration_Value = @import("../zig.zig").Guid.initString("3059009A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLCSSStyleDeclaration = &IID_DispHTMLCSSStyleDeclaration_Value;
pub const DispHTMLCSSStyleDeclaration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle_Value = @import("../zig.zig").Guid.initString("3050F25E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyle = &IID_IHTMLStyle_Value;
pub const IHTMLStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_fontFamily: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontFamily: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontStyle: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontStyle: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontVariant: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontVariant: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontWeight: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontWeight: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontSize: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontSize: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_font: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_font: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_color: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_color: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_background: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_background: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundColor: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundImage: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundImage: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundRepeat: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundRepeat: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundAttachment: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundAttachment: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundPosition: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPosition: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundPositionX: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPositionX: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundPositionY: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPositionY: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wordSpacing: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordSpacing: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_letterSpacing: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_letterSpacing: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecoration: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecoration: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationNone: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationNone: fn(
            self: *const IHTMLStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationUnderline: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationUnderline: fn(
            self: *const IHTMLStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationOverline: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationOverline: fn(
            self: *const IHTMLStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationLineThrough: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationLineThrough: fn(
            self: *const IHTMLStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationBlink: fn(
            self: *const IHTMLStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationBlink: fn(
            self: *const IHTMLStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_verticalAlign: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_verticalAlign: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textTransform: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textTransform: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAlign: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAlign: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textIndent: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textIndent: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lineHeight: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineHeight: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginTop: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginTop: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginRight: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginRight: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginBottom: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginBottom: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginLeft: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginLeft: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_margin: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_margin: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingTop: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingTop: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingRight: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingRight: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingBottom: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingBottom: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingLeft: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingLeft: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_padding: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_padding: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTop: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTop: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRight: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRight: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottom: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottom: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeft: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeft: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColor: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColor: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopColor: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRightColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightColor: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomColor: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeftColor: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftColor: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderWidth: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderWidth: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopWidth: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopWidth: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRightWidth: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightWidth: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomWidth: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomWidth: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeftWidth: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftWidth: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderStyle: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderStyle: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopStyle: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopStyle: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRightStyle: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightStyle: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomStyle: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomStyle: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeftStyle: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftStyle: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_styleFloat: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_styleFloat: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clear: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clear: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_display: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_display: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_visibility: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_visibility: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStyleType: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyleType: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStylePosition: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStylePosition: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStyleImage: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyleImage: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStyle: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyle: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_whiteSpace: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_whiteSpace: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_top: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_top: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_left: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_left: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_position: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_zIndex: fn(
            self: *const IHTMLStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_zIndex: fn(
            self: *const IHTMLStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_overflow: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflow: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageBreakBefore: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakBefore: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageBreakAfter: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakAfter: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cssText: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cssText: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelTop: fn(
            self: *const IHTMLStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelTop: fn(
            self: *const IHTMLStyle,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelLeft: fn(
            self: *const IHTMLStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelLeft: fn(
            self: *const IHTMLStyle,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelWidth: fn(
            self: *const IHTMLStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelWidth: fn(
            self: *const IHTMLStyle,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelHeight: fn(
            self: *const IHTMLStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelHeight: fn(
            self: *const IHTMLStyle,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_posTop: fn(
            self: *const IHTMLStyle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_posTop: fn(
            self: *const IHTMLStyle,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_posLeft: fn(
            self: *const IHTMLStyle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_posLeft: fn(
            self: *const IHTMLStyle,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_posWidth: fn(
            self: *const IHTMLStyle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_posWidth: fn(
            self: *const IHTMLStyle,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_posHeight: fn(
            self: *const IHTMLStyle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_posHeight: fn(
            self: *const IHTMLStyle,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cursor: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cursor: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clip: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clip: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_filter: fn(
            self: *const IHTMLStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_filter: fn(
            self: *const IHTMLStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLStyle,
            strAttributeName: BSTR,
            AttributeValue: VARIANT,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLStyle,
            strAttributeName: BSTR,
            lFlags: i32,
            AttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLStyle,
            strAttributeName: BSTR,
            lFlags: i32,
            pfSuccess: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLStyle,
            String: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontFamily(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontFamily(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontFamily(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontFamily(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontVariant(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontVariant(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontVariant(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontVariant(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontWeight(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontWeight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontWeight(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_fontSize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_fontSize(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_fontSize(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_font(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_font(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_font(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_font(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_color(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_color(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_color(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_background(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_background(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_background(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_background(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundImage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundImage(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundImage(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundRepeat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundRepeat(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundRepeat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundRepeat(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundAttachment(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundAttachment(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundAttachment(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundAttachment(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundPosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundPosition(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundPosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundPosition(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundPositionX(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundPositionX(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundPositionX(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundPositionX(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_backgroundPositionY(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_backgroundPositionY(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_backgroundPositionY(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_backgroundPositionY(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_wordSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_wordSpacing(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_wordSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_wordSpacing(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_letterSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_letterSpacing(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_letterSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_letterSpacing(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecoration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecoration(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecoration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationNone(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationNone(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationNone(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationNone(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationUnderline(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationUnderline(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationUnderline(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationUnderline(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationOverline(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationOverline(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationOverline(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationOverline(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationLineThrough(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationLineThrough(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationLineThrough(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationLineThrough(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textDecorationBlink(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textDecorationBlink(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textDecorationBlink(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textDecorationBlink(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_verticalAlign(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_verticalAlign(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_verticalAlign(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_verticalAlign(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textTransform(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textTransform(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textTransform(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textTransform(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textAlign(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textAlign(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_textIndent(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_textIndent(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_textIndent(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_textIndent(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_lineHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_lineHeight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_lineHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_lineHeight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_marginTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_marginTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_marginTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_marginTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_marginRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_marginRight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_marginRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_marginRight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_marginBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_marginBottom(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_marginBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_marginBottom(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_marginLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_marginLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_marginLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_marginLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_margin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_margin(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_margin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_margin(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_paddingTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_paddingTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_paddingTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_paddingTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_paddingRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_paddingRight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_paddingRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_paddingRight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_paddingBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_paddingBottom(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_paddingBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_paddingBottom(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_paddingLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_paddingLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_paddingLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_paddingLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_padding(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_padding(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_padding(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_padding(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_border(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_border(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_border(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_border(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderTop(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderTop(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderRight(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderRight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderRight(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderRight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderBottom(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderBottom(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderBottom(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderBottom(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderLeft(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderLeft(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderColor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderColor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderTopColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderTopColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderTopColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderTopColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderRightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderRightColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderRightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderRightColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderBottomColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderBottomColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderBottomColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderBottomColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderLeftColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderLeftColor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderLeftColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderLeftColor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderWidth(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderWidth(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderTopWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderTopWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderTopWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderTopWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderRightWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderRightWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderRightWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderRightWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderBottomWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderBottomWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderBottomWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderBottomWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderLeftWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderLeftWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderLeftWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderLeftWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderTopStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderTopStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderTopStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderTopStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderRightStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderRightStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderRightStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderRightStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderBottomStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderBottomStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderBottomStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderBottomStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_borderLeftStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_borderLeftStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_borderLeftStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_borderLeftStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_width(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_width(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_height(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_height(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_styleFloat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_styleFloat(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_styleFloat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_styleFloat(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_clear(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_clear(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_display(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_display(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_display(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_display(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_visibility(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_visibility(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_visibility(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_visibility(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_listStyleType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_listStyleType(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_listStyleType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_listStyleType(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_listStylePosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_listStylePosition(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_listStylePosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_listStylePosition(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_listStyleImage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_listStyleImage(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_listStyleImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_listStyleImage(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_listStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_listStyle(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_listStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_listStyle(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_whiteSpace(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_whiteSpace(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_whiteSpace(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_whiteSpace(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_top(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_top(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_top(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_top(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_left(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_left(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_left(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_left(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_position(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_position(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_zIndex(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_zIndex(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_zIndex(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_zIndex(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_overflow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_overflow(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_overflow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_overflow(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pageBreakBefore(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pageBreakBefore(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pageBreakBefore(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pageBreakBefore(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pageBreakAfter(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pageBreakAfter(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pageBreakAfter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pageBreakAfter(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_cssText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_cssText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pixelTop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pixelTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pixelTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pixelTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pixelLeft(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pixelLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pixelLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pixelLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pixelWidth(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pixelWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pixelWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pixelWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_pixelHeight(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_pixelHeight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_pixelHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_pixelHeight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_posTop(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_posTop(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_posTop(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_posTop(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_posLeft(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_posLeft(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_posLeft(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_posLeft(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_posWidth(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_posWidth(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_posWidth(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_posWidth(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_posHeight(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_posHeight(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_posHeight(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_posHeight(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_cursor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_cursor(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_cursor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_cursor(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_clip(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_clip(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_clip(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_clip(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_put_filter(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).put_filter(@ptrCast(*const IHTMLStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_get_filter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).get_filter(@ptrCast(*const IHTMLStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_setAttribute(self: *const T, strAttributeName: BSTR, AttributeValue: VARIANT, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLStyle, self), strAttributeName, AttributeValue, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_getAttribute(self: *const T, strAttributeName: BSTR, lFlags: i32, AttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLStyle, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_removeAttribute(self: *const T, strAttributeName: BSTR, lFlags: i32, pfSuccess: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLStyle, self), strAttributeName, lFlags, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle_toString(self: *const T, String: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle.VTable, self.vtable).toString(@ptrCast(*const IHTMLStyle, self), String);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle2_Value = @import("../zig.zig").Guid.initString("3050F4A2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyle2 = &IID_IHTMLStyle2_Value;
pub const IHTMLStyle2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_tableLayout: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tableLayout: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderCollapse: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderCollapse: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_direction: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_direction: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_behavior: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_behavior: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setExpression: fn(
            self: *const IHTMLStyle2,
            propname: BSTR,
            expression: BSTR,
            language: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getExpression: fn(
            self: *const IHTMLStyle2,
            propname: BSTR,
            expression: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeExpression: fn(
            self: *const IHTMLStyle2,
            propname: BSTR,
            pfSuccess: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_position: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_position: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_unicodeBidi: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unicodeBidi: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bottom: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bottom: fn(
            self: *const IHTMLStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_right: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_right: fn(
            self: *const IHTMLStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelBottom: fn(
            self: *const IHTMLStyle2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelBottom: fn(
            self: *const IHTMLStyle2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelRight: fn(
            self: *const IHTMLStyle2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelRight: fn(
            self: *const IHTMLStyle2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_posBottom: fn(
            self: *const IHTMLStyle2,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_posBottom: fn(
            self: *const IHTMLStyle2,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_posRight: fn(
            self: *const IHTMLStyle2,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_posRight: fn(
            self: *const IHTMLStyle2,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_imeMode: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imeMode: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rubyAlign: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyAlign: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rubyPosition: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyPosition: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rubyOverhang: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyOverhang: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridChar: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridChar: fn(
            self: *const IHTMLStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridLine: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridLine: fn(
            self: *const IHTMLStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridMode: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridMode: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridType: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridType: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGrid: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGrid: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wordBreak: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordBreak: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lineBreak: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineBreak: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textJustify: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textJustify: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textJustifyTrim: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textJustifyTrim: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textKashida: fn(
            self: *const IHTMLStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textKashida: fn(
            self: *const IHTMLStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAutospace: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAutospace: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_overflowX: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflowX: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_overflowY: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflowY: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_accelerator: fn(
            self: *const IHTMLStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accelerator: fn(
            self: *const IHTMLStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_tableLayout(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_tableLayout(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_tableLayout(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_tableLayout(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_borderCollapse(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_borderCollapse(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_borderCollapse(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_borderCollapse(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_direction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_direction(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_direction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_behavior(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_behavior(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_behavior(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_setExpression(self: *const T, propname: BSTR, expression: BSTR, language: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).setExpression(@ptrCast(*const IHTMLStyle2, self), propname, expression, language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_getExpression(self: *const T, propname: BSTR, expression: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).getExpression(@ptrCast(*const IHTMLStyle2, self), propname, expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_removeExpression(self: *const T, propname: BSTR, pfSuccess: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).removeExpression(@ptrCast(*const IHTMLStyle2, self), propname, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_position(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_position(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_position(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_position(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_unicodeBidi(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_unicodeBidi(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_unicodeBidi(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_unicodeBidi(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_bottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_bottom(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_bottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_right(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_right(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_right(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_right(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_pixelBottom(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_pixelBottom(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_pixelBottom(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_pixelBottom(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_pixelRight(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_pixelRight(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_pixelRight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_pixelRight(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_posBottom(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_posBottom(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_posBottom(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_posBottom(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_posRight(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_posRight(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_posRight(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_posRight(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_imeMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_imeMode(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_imeMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_imeMode(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_rubyAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_rubyAlign(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_rubyAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_rubyAlign(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_rubyPosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_rubyPosition(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_rubyPosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_rubyPosition(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_rubyOverhang(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_rubyOverhang(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_rubyOverhang(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_rubyOverhang(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGridChar(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGridChar(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGridChar(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGridChar(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGridLine(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGridLine(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGridLine(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGridLine(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGridMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGridMode(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGridMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGridMode(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGridType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGridType(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGridType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGridType(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_layoutGrid(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_layoutGrid(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_layoutGrid(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_layoutGrid(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_wordBreak(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_wordBreak(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_wordBreak(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_wordBreak(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_lineBreak(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_lineBreak(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_lineBreak(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_lineBreak(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_textJustify(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_textJustify(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_textJustify(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_textJustify(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_textJustifyTrim(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_textJustifyTrim(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_textJustifyTrim(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_textJustifyTrim(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_textKashida(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_textKashida(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_textKashida(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_textKashida(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_textAutospace(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_textAutospace(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_textAutospace(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_textAutospace(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_overflowX(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_overflowX(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_overflowX(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_overflowX(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_overflowY(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_overflowY(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_overflowY(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_overflowY(@ptrCast(*const IHTMLStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_put_accelerator(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).put_accelerator(@ptrCast(*const IHTMLStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle2_get_accelerator(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle2.VTable, self.vtable).get_accelerator(@ptrCast(*const IHTMLStyle2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle3_Value = @import("../zig.zig").Guid.initString("3050F656-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyle3 = &IID_IHTMLStyle3_Value;
pub const IHTMLStyle3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_layoutFlow: fn(
            self: *const IHTMLStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutFlow: fn(
            self: *const IHTMLStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_zoom: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_zoom: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wordWrap: fn(
            self: *const IHTMLStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordWrap: fn(
            self: *const IHTMLStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textUnderlinePosition: fn(
            self: *const IHTMLStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textUnderlinePosition: fn(
            self: *const IHTMLStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarBaseColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarBaseColor: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarFaceColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarFaceColor: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbar3dLightColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbar3dLightColor: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarShadowColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarShadowColor: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarHighlightColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarHighlightColor: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarDarkShadowColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarDarkShadowColor: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarArrowColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarArrowColor: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarTrackColor: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarTrackColor: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_writingMode: fn(
            self: *const IHTMLStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_writingMode: fn(
            self: *const IHTMLStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAlignLast: fn(
            self: *const IHTMLStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAlignLast: fn(
            self: *const IHTMLStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textKashidaSpace: fn(
            self: *const IHTMLStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textKashidaSpace: fn(
            self: *const IHTMLStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_layoutFlow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_layoutFlow(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_layoutFlow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_layoutFlow(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_zoom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_zoom(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_zoom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_zoom(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_wordWrap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_wordWrap(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_wordWrap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_wordWrap(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_textUnderlinePosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_textUnderlinePosition(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_textUnderlinePosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_textUnderlinePosition(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarBaseColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarBaseColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarBaseColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarBaseColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarFaceColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarFaceColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarFaceColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarFaceColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbar3dLightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbar3dLightColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbar3dLightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbar3dLightColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarShadowColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarShadowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarShadowColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarHighlightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarHighlightColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarHighlightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarHighlightColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarDarkShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarDarkShadowColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarDarkShadowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarDarkShadowColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarArrowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarArrowColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarArrowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarArrowColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_scrollbarTrackColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_scrollbarTrackColor(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_scrollbarTrackColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_scrollbarTrackColor(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_writingMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_writingMode(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_writingMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_writingMode(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_textAlignLast(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_textAlignLast(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_textAlignLast(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_textAlignLast(@ptrCast(*const IHTMLStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_put_textKashidaSpace(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).put_textKashidaSpace(@ptrCast(*const IHTMLStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle3_get_textKashidaSpace(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle3.VTable, self.vtable).get_textKashidaSpace(@ptrCast(*const IHTMLStyle3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle4_Value = @import("../zig.zig").Guid.initString("3050F816-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyle4 = &IID_IHTMLStyle4_Value;
pub const IHTMLStyle4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_textOverflow: fn(
            self: *const IHTMLStyle4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textOverflow: fn(
            self: *const IHTMLStyle4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_minHeight: fn(
            self: *const IHTMLStyle4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_minHeight: fn(
            self: *const IHTMLStyle4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle4_put_textOverflow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle4.VTable, self.vtable).put_textOverflow(@ptrCast(*const IHTMLStyle4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle4_get_textOverflow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle4.VTable, self.vtable).get_textOverflow(@ptrCast(*const IHTMLStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle4_put_minHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle4.VTable, self.vtable).put_minHeight(@ptrCast(*const IHTMLStyle4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle4_get_minHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle4.VTable, self.vtable).get_minHeight(@ptrCast(*const IHTMLStyle4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle5_Value = @import("../zig.zig").Guid.initString("3050F33A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyle5 = &IID_IHTMLStyle5_Value;
pub const IHTMLStyle5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_msInterpolationMode: fn(
            self: *const IHTMLStyle5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msInterpolationMode: fn(
            self: *const IHTMLStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maxHeight: fn(
            self: *const IHTMLStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxHeight: fn(
            self: *const IHTMLStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_minWidth: fn(
            self: *const IHTMLStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_minWidth: fn(
            self: *const IHTMLStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maxWidth: fn(
            self: *const IHTMLStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxWidth: fn(
            self: *const IHTMLStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_put_msInterpolationMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).put_msInterpolationMode(@ptrCast(*const IHTMLStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_get_msInterpolationMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).get_msInterpolationMode(@ptrCast(*const IHTMLStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_put_maxHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).put_maxHeight(@ptrCast(*const IHTMLStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_get_maxHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).get_maxHeight(@ptrCast(*const IHTMLStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_put_minWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).put_minWidth(@ptrCast(*const IHTMLStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_get_minWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).get_minWidth(@ptrCast(*const IHTMLStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_put_maxWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).put_maxWidth(@ptrCast(*const IHTMLStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle5_get_maxWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle5.VTable, self.vtable).get_maxWidth(@ptrCast(*const IHTMLStyle5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyle6_Value = @import("../zig.zig").Guid.initString("30510480-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyle6 = &IID_IHTMLStyle6_Value;
pub const IHTMLStyle6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_content: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_content: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_captionSide: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_captionSide: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_counterIncrement: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_counterIncrement: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_counterReset: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_counterReset: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outline: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outline: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outlineWidth: fn(
            self: *const IHTMLStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineWidth: fn(
            self: *const IHTMLStyle6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outlineStyle: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineStyle: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outlineColor: fn(
            self: *const IHTMLStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineColor: fn(
            self: *const IHTMLStyle6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_boxSizing: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boxSizing: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderSpacing: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderSpacing: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_orphans: fn(
            self: *const IHTMLStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_orphans: fn(
            self: *const IHTMLStyle6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_widows: fn(
            self: *const IHTMLStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_widows: fn(
            self: *const IHTMLStyle6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageBreakInside: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakInside: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_emptyCells: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_emptyCells: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msBlockProgression: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msBlockProgression: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_quotes: fn(
            self: *const IHTMLStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_quotes: fn(
            self: *const IHTMLStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_content(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_content(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_content(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_content(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_captionSide(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_captionSide(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_captionSide(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_captionSide(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_counterIncrement(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_counterIncrement(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_counterIncrement(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_counterIncrement(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_counterReset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_counterReset(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_counterReset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_counterReset(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_outline(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_outline(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_outline(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_outline(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_outlineWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_outlineWidth(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_outlineWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_outlineWidth(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_outlineStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_outlineStyle(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_outlineStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_outlineStyle(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_outlineColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_outlineColor(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_outlineColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_outlineColor(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_boxSizing(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_boxSizing(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_boxSizing(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_boxSizing(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_borderSpacing(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_borderSpacing(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_borderSpacing(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_borderSpacing(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_orphans(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_orphans(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_orphans(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_orphans(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_widows(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_widows(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_widows(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_widows(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_pageBreakInside(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_pageBreakInside(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_pageBreakInside(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_pageBreakInside(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_emptyCells(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_emptyCells(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_emptyCells(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_emptyCells(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_msBlockProgression(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_msBlockProgression(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_msBlockProgression(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_msBlockProgression(@ptrCast(*const IHTMLStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_put_quotes(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).put_quotes(@ptrCast(*const IHTMLStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyle6_get_quotes(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyle6.VTable, self.vtable).get_quotes(@ptrCast(*const IHTMLStyle6, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle_Value = @import("../zig.zig").Guid.initString("3050F3CF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRuleStyle = &IID_IHTMLRuleStyle_Value;
pub const IHTMLRuleStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_fontFamily: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontFamily: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontStyle: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontStyle: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontVariant: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontVariant: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontWeight: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontWeight: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fontSize: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontSize: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_font: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_font: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_color: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_color: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_background: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_background: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundColor: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundImage: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundImage: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundRepeat: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundRepeat: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundAttachment: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundAttachment: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundPosition: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPosition: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundPositionX: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPositionX: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_backgroundPositionY: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPositionY: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wordSpacing: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordSpacing: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_letterSpacing: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_letterSpacing: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecoration: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecoration: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationNone: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationNone: fn(
            self: *const IHTMLRuleStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationUnderline: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationUnderline: fn(
            self: *const IHTMLRuleStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationOverline: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationOverline: fn(
            self: *const IHTMLRuleStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationLineThrough: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationLineThrough: fn(
            self: *const IHTMLRuleStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationBlink: fn(
            self: *const IHTMLRuleStyle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationBlink: fn(
            self: *const IHTMLRuleStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_verticalAlign: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_verticalAlign: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textTransform: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textTransform: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAlign: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAlign: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textIndent: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textIndent: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lineHeight: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineHeight: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginTop: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginTop: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginRight: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginRight: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginBottom: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginBottom: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginLeft: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginLeft: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_margin: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_margin: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingTop: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingTop: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingRight: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingRight: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingBottom: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingBottom: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_paddingLeft: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingLeft: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_padding: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_padding: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTop: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTop: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRight: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRight: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottom: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottom: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeft: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeft: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColor: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColor: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopColor: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRightColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightColor: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomColor: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeftColor: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftColor: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderWidth: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderWidth: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopWidth: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopWidth: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRightWidth: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightWidth: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomWidth: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomWidth: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeftWidth: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftWidth: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderStyle: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderStyle: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderTopStyle: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopStyle: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderRightStyle: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightStyle: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderBottomStyle: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomStyle: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderLeftStyle: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftStyle: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_styleFloat: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_styleFloat: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clear: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clear: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_display: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_display: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_visibility: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_visibility: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStyleType: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyleType: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStylePosition: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStylePosition: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStyleImage: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyleImage: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_listStyle: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyle: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_whiteSpace: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_whiteSpace: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_top: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_top: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_left: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_left: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_position: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_zIndex: fn(
            self: *const IHTMLRuleStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_zIndex: fn(
            self: *const IHTMLRuleStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_overflow: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflow: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageBreakBefore: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakBefore: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageBreakAfter: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakAfter: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cssText: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cssText: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cursor: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cursor: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clip: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clip: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_filter: fn(
            self: *const IHTMLRuleStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_filter: fn(
            self: *const IHTMLRuleStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLRuleStyle,
            strAttributeName: BSTR,
            AttributeValue: VARIANT,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLRuleStyle,
            strAttributeName: BSTR,
            lFlags: i32,
            AttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLRuleStyle,
            strAttributeName: BSTR,
            lFlags: i32,
            pfSuccess: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontFamily(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontFamily(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontFamily(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontFamily(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontVariant(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontVariant(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontVariant(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontVariant(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontWeight(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontWeight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontWeight(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_fontSize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_fontSize(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_fontSize(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_font(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_font(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_font(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_font(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_color(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_color(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_color(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_background(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_background(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_background(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_background(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundImage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundImage(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundImage(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundRepeat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundRepeat(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundRepeat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundRepeat(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundAttachment(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundAttachment(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundAttachment(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundAttachment(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundPosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundPosition(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundPosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundPosition(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundPositionX(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundPositionX(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundPositionX(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundPositionX(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_backgroundPositionY(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_backgroundPositionY(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_backgroundPositionY(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_backgroundPositionY(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_wordSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_wordSpacing(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_wordSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_wordSpacing(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_letterSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_letterSpacing(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_letterSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_letterSpacing(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecoration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecoration(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecoration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationNone(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationNone(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationNone(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationNone(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationUnderline(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationUnderline(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationUnderline(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationUnderline(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationOverline(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationOverline(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationOverline(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationOverline(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationLineThrough(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationLineThrough(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationLineThrough(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationLineThrough(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textDecorationBlink(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textDecorationBlink(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textDecorationBlink(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textDecorationBlink(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_verticalAlign(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_verticalAlign(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_verticalAlign(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_verticalAlign(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textTransform(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textTransform(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textTransform(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textTransform(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textAlign(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textAlign(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_textIndent(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_textIndent(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_textIndent(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_textIndent(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_lineHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_lineHeight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_lineHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_lineHeight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_marginTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_marginTop(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_marginTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_marginTop(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_marginRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_marginRight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_marginRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_marginRight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_marginBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_marginBottom(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_marginBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_marginBottom(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_marginLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_marginLeft(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_marginLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_marginLeft(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_margin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_margin(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_margin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_margin(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_paddingTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_paddingTop(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_paddingTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_paddingTop(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_paddingRight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_paddingRight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_paddingRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_paddingRight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_paddingBottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_paddingBottom(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_paddingBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_paddingBottom(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_paddingLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_paddingLeft(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_paddingLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_paddingLeft(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_padding(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_padding(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_padding(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_padding(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_border(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_border(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_border(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_border(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderTop(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderTop(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderTop(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderTop(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderRight(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderRight(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderRight(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderRight(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderBottom(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderBottom(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderBottom(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderBottom(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderLeft(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderLeft(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderLeft(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderLeft(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderColor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderColor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderTopColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderTopColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderTopColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderTopColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderRightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderRightColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderRightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderRightColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderBottomColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderBottomColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderBottomColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderBottomColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderLeftColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderLeftColor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderLeftColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderLeftColor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderWidth(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderWidth(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderTopWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderTopWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderTopWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderTopWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderRightWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderRightWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderRightWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderRightWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderBottomWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderBottomWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderBottomWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderBottomWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderLeftWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderLeftWidth(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderLeftWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderLeftWidth(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderTopStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderTopStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderTopStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderTopStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderRightStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderRightStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderRightStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderRightStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderBottomStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderBottomStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderBottomStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderBottomStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_borderLeftStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_borderLeftStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_borderLeftStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_borderLeftStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_width(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_width(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_height(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_height(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_styleFloat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_styleFloat(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_styleFloat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_styleFloat(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_clear(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_clear(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_display(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_display(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_display(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_display(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_visibility(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_visibility(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_visibility(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_visibility(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_listStyleType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_listStyleType(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_listStyleType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_listStyleType(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_listStylePosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_listStylePosition(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_listStylePosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_listStylePosition(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_listStyleImage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_listStyleImage(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_listStyleImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_listStyleImage(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_listStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_listStyle(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_listStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_listStyle(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_whiteSpace(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_whiteSpace(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_whiteSpace(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_whiteSpace(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_top(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_top(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_top(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_top(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_left(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_left(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_left(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_left(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_position(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_position(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_zIndex(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_zIndex(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_zIndex(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_zIndex(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_overflow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_overflow(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_overflow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_overflow(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_pageBreakBefore(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_pageBreakBefore(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_pageBreakBefore(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_pageBreakBefore(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_pageBreakAfter(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_pageBreakAfter(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_pageBreakAfter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_pageBreakAfter(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_cssText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_cssText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_cursor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_cursor(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_cursor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_cursor(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_clip(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_clip(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_clip(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_clip(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_put_filter(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).put_filter(@ptrCast(*const IHTMLRuleStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_get_filter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).get_filter(@ptrCast(*const IHTMLRuleStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_setAttribute(self: *const T, strAttributeName: BSTR, AttributeValue: VARIANT, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLRuleStyle, self), strAttributeName, AttributeValue, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_getAttribute(self: *const T, strAttributeName: BSTR, lFlags: i32, AttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLRuleStyle, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle_removeAttribute(self: *const T, strAttributeName: BSTR, lFlags: i32, pfSuccess: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLRuleStyle, self), strAttributeName, lFlags, pfSuccess);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle2_Value = @import("../zig.zig").Guid.initString("3050F4AC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRuleStyle2 = &IID_IHTMLRuleStyle2_Value;
pub const IHTMLRuleStyle2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_tableLayout: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tableLayout: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderCollapse: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderCollapse: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_direction: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_direction: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_behavior: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_behavior: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_position: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_position: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_unicodeBidi: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unicodeBidi: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bottom: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bottom: fn(
            self: *const IHTMLRuleStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_right: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_right: fn(
            self: *const IHTMLRuleStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelBottom: fn(
            self: *const IHTMLRuleStyle2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelBottom: fn(
            self: *const IHTMLRuleStyle2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelRight: fn(
            self: *const IHTMLRuleStyle2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelRight: fn(
            self: *const IHTMLRuleStyle2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_posBottom: fn(
            self: *const IHTMLRuleStyle2,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_posBottom: fn(
            self: *const IHTMLRuleStyle2,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_posRight: fn(
            self: *const IHTMLRuleStyle2,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_posRight: fn(
            self: *const IHTMLRuleStyle2,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_imeMode: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imeMode: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rubyAlign: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyAlign: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rubyPosition: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyPosition: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rubyOverhang: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyOverhang: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridChar: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridChar: fn(
            self: *const IHTMLRuleStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridLine: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridLine: fn(
            self: *const IHTMLRuleStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridMode: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridMode: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGridType: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridType: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_layoutGrid: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGrid: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAutospace: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAutospace: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wordBreak: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordBreak: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lineBreak: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineBreak: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textJustify: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textJustify: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textJustifyTrim: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textJustifyTrim: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textKashida: fn(
            self: *const IHTMLRuleStyle2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textKashida: fn(
            self: *const IHTMLRuleStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_overflowX: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflowX: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_overflowY: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflowY: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_accelerator: fn(
            self: *const IHTMLRuleStyle2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accelerator: fn(
            self: *const IHTMLRuleStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_tableLayout(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_tableLayout(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_tableLayout(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_tableLayout(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_borderCollapse(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_borderCollapse(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_borderCollapse(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_borderCollapse(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_direction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_direction(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_direction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_behavior(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_behavior(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_behavior(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_position(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_position(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_position(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_position(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_unicodeBidi(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_unicodeBidi(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_unicodeBidi(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_unicodeBidi(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_bottom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_bottom(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_bottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_right(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_right(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_right(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_right(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_pixelBottom(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_pixelBottom(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_pixelBottom(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_pixelBottom(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_pixelRight(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_pixelRight(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_pixelRight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_pixelRight(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_posBottom(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_posBottom(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_posBottom(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_posBottom(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_posRight(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_posRight(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_posRight(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_posRight(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_imeMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_imeMode(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_imeMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_imeMode(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_rubyAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_rubyAlign(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_rubyAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_rubyAlign(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_rubyPosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_rubyPosition(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_rubyPosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_rubyPosition(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_rubyOverhang(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_rubyOverhang(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_rubyOverhang(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_rubyOverhang(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGridChar(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGridChar(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGridChar(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGridChar(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGridLine(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGridLine(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGridLine(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGridLine(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGridMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGridMode(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGridMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGridMode(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGridType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGridType(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGridType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGridType(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_layoutGrid(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_layoutGrid(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_layoutGrid(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_layoutGrid(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_textAutospace(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_textAutospace(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_textAutospace(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_textAutospace(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_wordBreak(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_wordBreak(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_wordBreak(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_wordBreak(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_lineBreak(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_lineBreak(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_lineBreak(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_lineBreak(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_textJustify(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_textJustify(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_textJustify(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_textJustify(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_textJustifyTrim(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_textJustifyTrim(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_textJustifyTrim(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_textJustifyTrim(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_textKashida(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_textKashida(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_textKashida(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_textKashida(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_overflowX(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_overflowX(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_overflowX(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_overflowX(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_overflowY(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_overflowY(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_overflowY(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_overflowY(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_put_accelerator(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).put_accelerator(@ptrCast(*const IHTMLRuleStyle2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle2_get_accelerator(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle2.VTable, self.vtable).get_accelerator(@ptrCast(*const IHTMLRuleStyle2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle3_Value = @import("../zig.zig").Guid.initString("3050F657-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRuleStyle3 = &IID_IHTMLRuleStyle3_Value;
pub const IHTMLRuleStyle3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_layoutFlow: fn(
            self: *const IHTMLRuleStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutFlow: fn(
            self: *const IHTMLRuleStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_zoom: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_zoom: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wordWrap: fn(
            self: *const IHTMLRuleStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordWrap: fn(
            self: *const IHTMLRuleStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textUnderlinePosition: fn(
            self: *const IHTMLRuleStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textUnderlinePosition: fn(
            self: *const IHTMLRuleStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarBaseColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarBaseColor: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarFaceColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarFaceColor: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbar3dLightColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbar3dLightColor: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarShadowColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarShadowColor: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarHighlightColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarHighlightColor: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarDarkShadowColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarDarkShadowColor: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarArrowColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarArrowColor: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbarTrackColor: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarTrackColor: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_writingMode: fn(
            self: *const IHTMLRuleStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_writingMode: fn(
            self: *const IHTMLRuleStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAlignLast: fn(
            self: *const IHTMLRuleStyle3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAlignLast: fn(
            self: *const IHTMLRuleStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textKashidaSpace: fn(
            self: *const IHTMLRuleStyle3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textKashidaSpace: fn(
            self: *const IHTMLRuleStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_layoutFlow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_layoutFlow(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_layoutFlow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_layoutFlow(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_zoom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_zoom(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_zoom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_zoom(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_wordWrap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_wordWrap(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_wordWrap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_wordWrap(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_textUnderlinePosition(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_textUnderlinePosition(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_textUnderlinePosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_textUnderlinePosition(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarBaseColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarBaseColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarBaseColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarBaseColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarFaceColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarFaceColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarFaceColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarFaceColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbar3dLightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbar3dLightColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbar3dLightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbar3dLightColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarShadowColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarShadowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarShadowColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarHighlightColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarHighlightColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarHighlightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarHighlightColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarDarkShadowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarDarkShadowColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarDarkShadowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarDarkShadowColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarArrowColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarArrowColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarArrowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarArrowColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_scrollbarTrackColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_scrollbarTrackColor(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_scrollbarTrackColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_scrollbarTrackColor(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_writingMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_writingMode(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_writingMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_writingMode(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_textAlignLast(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_textAlignLast(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_textAlignLast(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_textAlignLast(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_put_textKashidaSpace(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).put_textKashidaSpace(@ptrCast(*const IHTMLRuleStyle3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle3_get_textKashidaSpace(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle3.VTable, self.vtable).get_textKashidaSpace(@ptrCast(*const IHTMLRuleStyle3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle4_Value = @import("../zig.zig").Guid.initString("3050F817-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRuleStyle4 = &IID_IHTMLRuleStyle4_Value;
pub const IHTMLRuleStyle4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_textOverflow: fn(
            self: *const IHTMLRuleStyle4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textOverflow: fn(
            self: *const IHTMLRuleStyle4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_minHeight: fn(
            self: *const IHTMLRuleStyle4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_minHeight: fn(
            self: *const IHTMLRuleStyle4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle4_put_textOverflow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle4.VTable, self.vtable).put_textOverflow(@ptrCast(*const IHTMLRuleStyle4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle4_get_textOverflow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle4.VTable, self.vtable).get_textOverflow(@ptrCast(*const IHTMLRuleStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle4_put_minHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle4.VTable, self.vtable).put_minHeight(@ptrCast(*const IHTMLRuleStyle4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle4_get_minHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle4.VTable, self.vtable).get_minHeight(@ptrCast(*const IHTMLRuleStyle4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle5_Value = @import("../zig.zig").Guid.initString("3050F335-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRuleStyle5 = &IID_IHTMLRuleStyle5_Value;
pub const IHTMLRuleStyle5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_msInterpolationMode: fn(
            self: *const IHTMLRuleStyle5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msInterpolationMode: fn(
            self: *const IHTMLRuleStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maxHeight: fn(
            self: *const IHTMLRuleStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxHeight: fn(
            self: *const IHTMLRuleStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_minWidth: fn(
            self: *const IHTMLRuleStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_minWidth: fn(
            self: *const IHTMLRuleStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maxWidth: fn(
            self: *const IHTMLRuleStyle5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxWidth: fn(
            self: *const IHTMLRuleStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_put_msInterpolationMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).put_msInterpolationMode(@ptrCast(*const IHTMLRuleStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_get_msInterpolationMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).get_msInterpolationMode(@ptrCast(*const IHTMLRuleStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_put_maxHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).put_maxHeight(@ptrCast(*const IHTMLRuleStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_get_maxHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).get_maxHeight(@ptrCast(*const IHTMLRuleStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_put_minWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).put_minWidth(@ptrCast(*const IHTMLRuleStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_get_minWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).get_minWidth(@ptrCast(*const IHTMLRuleStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_put_maxWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).put_maxWidth(@ptrCast(*const IHTMLRuleStyle5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle5_get_maxWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle5.VTable, self.vtable).get_maxWidth(@ptrCast(*const IHTMLRuleStyle5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRuleStyle6_Value = @import("../zig.zig").Guid.initString("30510471-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRuleStyle6 = &IID_IHTMLRuleStyle6_Value;
pub const IHTMLRuleStyle6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_content: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_content: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_captionSide: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_captionSide: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_counterIncrement: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_counterIncrement: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_counterReset: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_counterReset: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outline: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outline: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outlineWidth: fn(
            self: *const IHTMLRuleStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineWidth: fn(
            self: *const IHTMLRuleStyle6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outlineStyle: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineStyle: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outlineColor: fn(
            self: *const IHTMLRuleStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineColor: fn(
            self: *const IHTMLRuleStyle6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_boxSizing: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boxSizing: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderSpacing: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderSpacing: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_orphans: fn(
            self: *const IHTMLRuleStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_orphans: fn(
            self: *const IHTMLRuleStyle6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_widows: fn(
            self: *const IHTMLRuleStyle6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_widows: fn(
            self: *const IHTMLRuleStyle6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageBreakInside: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakInside: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_emptyCells: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_emptyCells: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msBlockProgression: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msBlockProgression: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_quotes: fn(
            self: *const IHTMLRuleStyle6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_quotes: fn(
            self: *const IHTMLRuleStyle6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_content(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_content(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_content(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_content(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_captionSide(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_captionSide(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_captionSide(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_captionSide(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_counterIncrement(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_counterIncrement(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_counterIncrement(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_counterIncrement(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_counterReset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_counterReset(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_counterReset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_counterReset(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_outline(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_outline(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_outline(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_outline(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_outlineWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_outlineWidth(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_outlineWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_outlineWidth(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_outlineStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_outlineStyle(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_outlineStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_outlineStyle(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_outlineColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_outlineColor(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_outlineColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_outlineColor(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_boxSizing(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_boxSizing(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_boxSizing(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_boxSizing(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_borderSpacing(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_borderSpacing(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_borderSpacing(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_borderSpacing(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_orphans(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_orphans(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_orphans(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_orphans(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_widows(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_widows(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_widows(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_widows(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_pageBreakInside(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_pageBreakInside(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_pageBreakInside(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_pageBreakInside(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_emptyCells(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_emptyCells(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_emptyCells(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_emptyCells(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_msBlockProgression(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_msBlockProgression(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_msBlockProgression(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_msBlockProgression(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_put_quotes(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).put_quotes(@ptrCast(*const IHTMLRuleStyle6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRuleStyle6_get_quotes(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRuleStyle6.VTable, self.vtable).get_quotes(@ptrCast(*const IHTMLRuleStyle6, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyle_Value = @import("../zig.zig").Guid.initString("3050F55A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyle = &IID_DispHTMLStyle_Value;
pub const DispHTMLStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLRuleStyle_Value = @import("../zig.zig").Guid.initString("3050F55C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLRuleStyle = &IID_DispHTMLRuleStyle_Value;
pub const DispHTMLRuleStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRulesCollection_Value = @import("../zig.zig").Guid.initString("3050F2E5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetRulesCollection = &IID_IHTMLStyleSheetRulesCollection_Value;
pub const IHTMLStyleSheetRulesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLStyleSheetRulesCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLStyleSheetRulesCollection,
            index: i32,
            ppHTMLStyleSheetRule: **IHTMLStyleSheetRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetRulesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesCollection_item(self: *const T, index: i32, ppHTMLStyleSheetRule: **IHTMLStyleSheetRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetRulesCollection, self), index, ppHTMLStyleSheetRule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheet_Value = @import("../zig.zig").Guid.initString("3050F2E3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheet = &IID_IHTMLStyleSheet_Value;
pub const IHTMLStyleSheet = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_title: fn(
            self: *const IHTMLStyleSheet,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_title: fn(
            self: *const IHTMLStyleSheet,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentStyleSheet: fn(
            self: *const IHTMLStyleSheet,
            p: **IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_owningElement: fn(
            self: *const IHTMLStyleSheet,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLStyleSheet,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLStyleSheet,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readOnly: fn(
            self: *const IHTMLStyleSheet,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imports: fn(
            self: *const IHTMLStyleSheet,
            p: **IHTMLStyleSheetsCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_href: fn(
            self: *const IHTMLStyleSheet,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLStyleSheet,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLStyleSheet,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_id: fn(
            self: *const IHTMLStyleSheet,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addImport: fn(
            self: *const IHTMLStyleSheet,
            bstrURL: BSTR,
            lIndex: i32,
            plIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addRule: fn(
            self: *const IHTMLStyleSheet,
            bstrSelector: BSTR,
            bstrStyle: BSTR,
            lIndex: i32,
            plNewIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeImport: fn(
            self: *const IHTMLStyleSheet,
            lIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeRule: fn(
            self: *const IHTMLStyleSheet,
            lIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_media: fn(
            self: *const IHTMLStyleSheet,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_media: fn(
            self: *const IHTMLStyleSheet,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cssText: fn(
            self: *const IHTMLStyleSheet,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cssText: fn(
            self: *const IHTMLStyleSheet,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rules: fn(
            self: *const IHTMLStyleSheet,
            p: **IHTMLStyleSheetRulesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_title(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_title(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_title(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_title(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_parentStyleSheet(self: *const T, p: **IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_parentStyleSheet(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_owningElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_owningElement(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_readOnly(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_imports(self: *const T, p: **IHTMLStyleSheetsCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_imports(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_href(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_href(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_type(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_id(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_id(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_addImport(self: *const T, bstrURL: BSTR, lIndex: i32, plIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).addImport(@ptrCast(*const IHTMLStyleSheet, self), bstrURL, lIndex, plIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_addRule(self: *const T, bstrSelector: BSTR, bstrStyle: BSTR, lIndex: i32, plNewIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).addRule(@ptrCast(*const IHTMLStyleSheet, self), bstrSelector, bstrStyle, lIndex, plNewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_removeImport(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).removeImport(@ptrCast(*const IHTMLStyleSheet, self), lIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_removeRule(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).removeRule(@ptrCast(*const IHTMLStyleSheet, self), lIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_media(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_media(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_media(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_media(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_put_cssText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLStyleSheet, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_cssText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet_get_rules(self: *const T, p: **IHTMLStyleSheetRulesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet.VTable, self.vtable).get_rules(@ptrCast(*const IHTMLStyleSheet, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSRule_Value = @import("../zig.zig").Guid.initString("305106E9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCSSRule = &IID_IHTMLCSSRule_Value;
pub const IHTMLCSSRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLCSSRule,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cssText: fn(
            self: *const IHTMLCSSRule,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cssText: fn(
            self: *const IHTMLCSSRule,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentRule: fn(
            self: *const IHTMLCSSRule,
            p: **IHTMLCSSRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentStyleSheet: fn(
            self: *const IHTMLCSSRule,
            p: **IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_get_type(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).get_type(@ptrCast(*const IHTMLCSSRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_put_cssText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).put_cssText(@ptrCast(*const IHTMLCSSRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_get_cssText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).get_cssText(@ptrCast(*const IHTMLCSSRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_get_parentRule(self: *const T, p: **IHTMLCSSRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).get_parentRule(@ptrCast(*const IHTMLCSSRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSRule_get_parentStyleSheet(self: *const T, p: **IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSRule.VTable, self.vtable).get_parentStyleSheet(@ptrCast(*const IHTMLCSSRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSImportRule_Value = @import("../zig.zig").Guid.initString("305106EA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCSSImportRule = &IID_IHTMLCSSImportRule_Value;
pub const IHTMLCSSImportRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_href: fn(
            self: *const IHTMLCSSImportRule,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_media: fn(
            self: *const IHTMLCSSImportRule,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_media: fn(
            self: *const IHTMLCSSImportRule,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_styleSheet: fn(
            self: *const IHTMLCSSImportRule,
            p: **IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSImportRule_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSImportRule.VTable, self.vtable).get_href(@ptrCast(*const IHTMLCSSImportRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSImportRule_put_media(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSImportRule.VTable, self.vtable).put_media(@ptrCast(*const IHTMLCSSImportRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSImportRule_get_media(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSImportRule.VTable, self.vtable).get_media(@ptrCast(*const IHTMLCSSImportRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSImportRule_get_styleSheet(self: *const T, p: **IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSImportRule.VTable, self.vtable).get_styleSheet(@ptrCast(*const IHTMLCSSImportRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSMediaRule_Value = @import("../zig.zig").Guid.initString("305106EB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCSSMediaRule = &IID_IHTMLCSSMediaRule_Value;
pub const IHTMLCSSMediaRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_media: fn(
            self: *const IHTMLCSSMediaRule,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_media: fn(
            self: *const IHTMLCSSMediaRule,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cssRules: fn(
            self: *const IHTMLCSSMediaRule,
            p: **IHTMLStyleSheetRulesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRule: fn(
            self: *const IHTMLCSSMediaRule,
            bstrRule: BSTR,
            lIndex: i32,
            plNewIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRule: fn(
            self: *const IHTMLCSSMediaRule,
            lIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_put_media(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).put_media(@ptrCast(*const IHTMLCSSMediaRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_get_media(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).get_media(@ptrCast(*const IHTMLCSSMediaRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_get_cssRules(self: *const T, p: **IHTMLStyleSheetRulesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).get_cssRules(@ptrCast(*const IHTMLCSSMediaRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_insertRule(self: *const T, bstrRule: BSTR, lIndex: i32, plNewIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).insertRule(@ptrCast(*const IHTMLCSSMediaRule, self), bstrRule, lIndex, plNewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaRule_deleteRule(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaRule.VTable, self.vtable).deleteRule(@ptrCast(*const IHTMLCSSMediaRule, self), lIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSMediaList_Value = @import("../zig.zig").Guid.initString("30510731-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCSSMediaList = &IID_IHTMLCSSMediaList_Value;
pub const IHTMLCSSMediaList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_mediaText: fn(
            self: *const IHTMLCSSMediaList,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_mediaText: fn(
            self: *const IHTMLCSSMediaList,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLCSSMediaList,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLCSSMediaList,
            index: i32,
            pbstrMedium: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendMedium: fn(
            self: *const IHTMLCSSMediaList,
            bstrMedium: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteMedium: fn(
            self: *const IHTMLCSSMediaList,
            bstrMedium: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_put_mediaText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).put_mediaText(@ptrCast(*const IHTMLCSSMediaList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_get_mediaText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).get_mediaText(@ptrCast(*const IHTMLCSSMediaList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).get_length(@ptrCast(*const IHTMLCSSMediaList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_item(self: *const T, index: i32, pbstrMedium: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).item(@ptrCast(*const IHTMLCSSMediaList, self), index, pbstrMedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_appendMedium(self: *const T, bstrMedium: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).appendMedium(@ptrCast(*const IHTMLCSSMediaList, self), bstrMedium);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSMediaList_deleteMedium(self: *const T, bstrMedium: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSMediaList.VTable, self.vtable).deleteMedium(@ptrCast(*const IHTMLCSSMediaList, self), bstrMedium);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCSSNamespaceRule_Value = @import("../zig.zig").Guid.initString("305106EE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCSSNamespaceRule = &IID_IHTMLCSSNamespaceRule_Value;
pub const IHTMLCSSNamespaceRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_namespaceURI: fn(
            self: *const IHTMLCSSNamespaceRule,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_prefix: fn(
            self: *const IHTMLCSSNamespaceRule,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSNamespaceRule_get_namespaceURI(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSNamespaceRule.VTable, self.vtable).get_namespaceURI(@ptrCast(*const IHTMLCSSNamespaceRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCSSNamespaceRule_get_prefix(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCSSNamespaceRule.VTable, self.vtable).get_prefix(@ptrCast(*const IHTMLCSSNamespaceRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMSCSSKeyframeRule_Value = @import("../zig.zig").Guid.initString("3051080C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMSCSSKeyframeRule = &IID_IHTMLMSCSSKeyframeRule_Value;
pub const IHTMLMSCSSKeyframeRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_keyText: fn(
            self: *const IHTMLMSCSSKeyframeRule,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_keyText: fn(
            self: *const IHTMLMSCSSKeyframeRule,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_style: fn(
            self: *const IHTMLMSCSSKeyframeRule,
            p: **IHTMLRuleStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframeRule_put_keyText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframeRule.VTable, self.vtable).put_keyText(@ptrCast(*const IHTMLMSCSSKeyframeRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframeRule_get_keyText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframeRule.VTable, self.vtable).get_keyText(@ptrCast(*const IHTMLMSCSSKeyframeRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframeRule_get_style(self: *const T, p: **IHTMLRuleStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframeRule.VTable, self.vtable).get_style(@ptrCast(*const IHTMLMSCSSKeyframeRule, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMSCSSKeyframesRule_Value = @import("../zig.zig").Guid.initString("3051080D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMSCSSKeyframesRule = &IID_IHTMLMSCSSKeyframesRule_Value;
pub const IHTMLMSCSSKeyframesRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_name: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cssRules: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            p: **IHTMLStyleSheetRulesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendRule: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            bstrRule: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRule: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            bstrKey: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        findRule: fn(
            self: *const IHTMLMSCSSKeyframesRule,
            bstrKey: BSTR,
            ppMSKeyframeRule: **IHTMLMSCSSKeyframeRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).put_name(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).get_name(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_get_cssRules(self: *const T, p: **IHTMLStyleSheetRulesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).get_cssRules(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_appendRule(self: *const T, bstrRule: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).appendRule(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), bstrRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_deleteRule(self: *const T, bstrKey: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).deleteRule(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), bstrKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSCSSKeyframesRule_findRule(self: *const T, bstrKey: BSTR, ppMSKeyframeRule: **IHTMLMSCSSKeyframeRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSCSSKeyframesRule.VTable, self.vtable).findRule(@ptrCast(*const IHTMLMSCSSKeyframesRule, self), bstrKey, ppMSKeyframeRule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSRule_Value = @import("../zig.zig").Guid.initString("3059007D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLCSSRule = &IID_DispHTMLCSSRule_Value;
pub const DispHTMLCSSRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSImportRule_Value = @import("../zig.zig").Guid.initString("3059007E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLCSSImportRule = &IID_DispHTMLCSSImportRule_Value;
pub const DispHTMLCSSImportRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSMediaRule_Value = @import("../zig.zig").Guid.initString("3059007F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLCSSMediaRule = &IID_DispHTMLCSSMediaRule_Value;
pub const DispHTMLCSSMediaRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSMediaList_Value = @import("../zig.zig").Guid.initString("30590097-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLCSSMediaList = &IID_DispHTMLCSSMediaList_Value;
pub const DispHTMLCSSMediaList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCSSNamespaceRule_Value = @import("../zig.zig").Guid.initString("30590080-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLCSSNamespaceRule = &IID_DispHTMLCSSNamespaceRule_Value;
pub const DispHTMLCSSNamespaceRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMSCSSKeyframeRule_Value = @import("../zig.zig").Guid.initString("305900DE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLMSCSSKeyframeRule = &IID_DispHTMLMSCSSKeyframeRule_Value;
pub const DispHTMLMSCSSKeyframeRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMSCSSKeyframesRule_Value = @import("../zig.zig").Guid.initString("305900DF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLMSCSSKeyframesRule = &IID_DispHTMLMSCSSKeyframesRule_Value;
pub const DispHTMLMSCSSKeyframesRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRenderStyle_Value = @import("../zig.zig").Guid.initString("3050F6AE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRenderStyle = &IID_IHTMLRenderStyle_Value;
pub const IHTMLRenderStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_textLineThroughStyle: fn(
            self: *const IHTMLRenderStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textLineThroughStyle: fn(
            self: *const IHTMLRenderStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textUnderlineStyle: fn(
            self: *const IHTMLRenderStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textUnderlineStyle: fn(
            self: *const IHTMLRenderStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textEffect: fn(
            self: *const IHTMLRenderStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textEffect: fn(
            self: *const IHTMLRenderStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textColor: fn(
            self: *const IHTMLRenderStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textColor: fn(
            self: *const IHTMLRenderStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textBackgroundColor: fn(
            self: *const IHTMLRenderStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textBackgroundColor: fn(
            self: *const IHTMLRenderStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecorationColor: fn(
            self: *const IHTMLRenderStyle,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecorationColor: fn(
            self: *const IHTMLRenderStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_renderingPriority: fn(
            self: *const IHTMLRenderStyle,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_renderingPriority: fn(
            self: *const IHTMLRenderStyle,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultTextSelection: fn(
            self: *const IHTMLRenderStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultTextSelection: fn(
            self: *const IHTMLRenderStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textDecoration: fn(
            self: *const IHTMLRenderStyle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecoration: fn(
            self: *const IHTMLRenderStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textLineThroughStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textLineThroughStyle(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textLineThroughStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textLineThroughStyle(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textUnderlineStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textUnderlineStyle(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textUnderlineStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textUnderlineStyle(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textEffect(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textEffect(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textEffect(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textEffect(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textColor(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textColor(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textBackgroundColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textBackgroundColor(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textBackgroundColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textBackgroundColor(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textDecorationColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textDecorationColor(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textDecorationColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textDecorationColor(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_renderingPriority(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_renderingPriority(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_renderingPriority(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_renderingPriority(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_defaultTextSelection(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_defaultTextSelection(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_defaultTextSelection(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_defaultTextSelection(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_put_textDecoration(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).put_textDecoration(@ptrCast(*const IHTMLRenderStyle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRenderStyle_get_textDecoration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRenderStyle.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLRenderStyle, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLRenderStyle_Value = @import("../zig.zig").Guid.initString("3050F58B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLRenderStyle = &IID_DispHTMLRenderStyle_Value;
pub const DispHTMLRenderStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle_Value = @import("../zig.zig").Guid.initString("3050F3DB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCurrentStyle = &IID_IHTMLCurrentStyle_Value;
pub const IHTMLCurrentStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_position: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_styleFloat: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_color: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundColor: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontFamily: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontVariant: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontWeight: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontSize: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundImage: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPositionX: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundPositionY: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundRepeat: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftColor: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopColor: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightColor: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomColor: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderTopWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderRightWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderBottomWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderLeftWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_left: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_top: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingLeft: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingTop: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingRight: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paddingBottom: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAlign: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDecoration: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_display: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_visibility: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_zIndex: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_letterSpacing: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineHeight: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textIndent: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_verticalAlign: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundAttachment: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginTop: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginRight: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginBottom: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginLeft: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clear: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyleType: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStylePosition: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_listStyleImage: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipTop: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipRight: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipBottom: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipLeft: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflow: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakBefore: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakAfter: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cursor: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tableLayout: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderCollapse: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_direction: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_behavior: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLCurrentStyle,
            strAttributeName: BSTR,
            lFlags: i32,
            AttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unicodeBidi: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_right: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bottom: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imeMode: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyAlign: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyPosition: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rubyOverhang: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAutospace: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineBreak: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordBreak: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textJustify: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textJustifyTrim: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textKashida: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_blockDirection: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridChar: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridLine: fn(
            self: *const IHTMLCurrentStyle,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridMode: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layoutGridType: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderStyle: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColor: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderWidth: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_padding: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_margin: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accelerator: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflowX: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overflowY: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textTransform: fn(
            self: *const IHTMLCurrentStyle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_position(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_position(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_styleFloat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_styleFloat(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_color(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_color(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontFamily(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontFamily(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontVariant(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontVariant(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontWeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_fontSize(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundImage(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundPositionX(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundPositionX(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundPositionY(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundPositionY(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundRepeat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundRepeat(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderLeftColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderLeftColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderTopColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderTopColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderRightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderRightColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderBottomColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderBottomColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderTopStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderTopStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderRightStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderRightStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderBottomStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderBottomStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderLeftStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderLeftStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderTopWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderTopWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderRightWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderRightWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderBottomWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderBottomWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderLeftWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderLeftWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_left(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_left(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_top(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_top(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_width(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_height(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_paddingLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_paddingLeft(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_paddingTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_paddingTop(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_paddingRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_paddingRight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_paddingBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_paddingBottom(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textAlign(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textDecoration(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textDecoration(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_display(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_display(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_visibility(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_visibility(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_zIndex(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_zIndex(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_letterSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_letterSpacing(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_lineHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_lineHeight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textIndent(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textIndent(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_verticalAlign(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_verticalAlign(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_backgroundAttachment(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_backgroundAttachment(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_marginTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_marginTop(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_marginRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_marginRight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_marginBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_marginBottom(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_marginLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_marginLeft(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clear(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_listStyleType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_listStyleType(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_listStylePosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_listStylePosition(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_listStyleImage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_listStyleImage(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clipTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clipTop(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clipRight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clipRight(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clipBottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clipBottom(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_clipLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_clipLeft(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_overflow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_overflow(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_pageBreakBefore(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_pageBreakBefore(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_pageBreakAfter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_pageBreakAfter(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_cursor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_cursor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_tableLayout(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_tableLayout(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderCollapse(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderCollapse(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_direction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_behavior(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_getAttribute(self: *const T, strAttributeName: BSTR, lFlags: i32, AttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLCurrentStyle, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_unicodeBidi(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_unicodeBidi(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_right(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_right(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_bottom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_imeMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_imeMode(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_rubyAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_rubyAlign(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_rubyPosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_rubyPosition(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_rubyOverhang(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_rubyOverhang(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textAutospace(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textAutospace(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_lineBreak(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_lineBreak(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_wordBreak(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_wordBreak(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textJustify(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textJustify(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textJustifyTrim(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textJustifyTrim(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textKashida(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textKashida(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_blockDirection(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_blockDirection(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_layoutGridChar(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_layoutGridChar(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_layoutGridLine(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_layoutGridLine(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_layoutGridMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_layoutGridMode(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_layoutGridType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_layoutGridType(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderColor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_borderWidth(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_borderWidth(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_padding(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_padding(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_margin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_margin(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_accelerator(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_accelerator(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_overflowX(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_overflowX(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_overflowY(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_overflowY(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle_get_textTransform(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle.VTable, self.vtable).get_textTransform(@ptrCast(*const IHTMLCurrentStyle, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle2_Value = @import("../zig.zig").Guid.initString("3050F658-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCurrentStyle2 = &IID_IHTMLCurrentStyle2_Value;
pub const IHTMLCurrentStyle2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_layoutFlow: fn(
            self: *const IHTMLCurrentStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordWrap: fn(
            self: *const IHTMLCurrentStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textUnderlinePosition: fn(
            self: *const IHTMLCurrentStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hasLayout: fn(
            self: *const IHTMLCurrentStyle2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarBaseColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarFaceColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbar3dLightColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarShadowColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarHighlightColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarDarkShadowColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarArrowColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbarTrackColor: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_writingMode: fn(
            self: *const IHTMLCurrentStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_zoom: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_filter: fn(
            self: *const IHTMLCurrentStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAlignLast: fn(
            self: *const IHTMLCurrentStyle2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textKashidaSpace: fn(
            self: *const IHTMLCurrentStyle2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isBlock: fn(
            self: *const IHTMLCurrentStyle2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_layoutFlow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_layoutFlow(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_wordWrap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_wordWrap(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_textUnderlinePosition(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_textUnderlinePosition(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_hasLayout(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_hasLayout(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarBaseColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarBaseColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarFaceColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarFaceColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbar3dLightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbar3dLightColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarShadowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarShadowColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarHighlightColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarHighlightColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarDarkShadowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarDarkShadowColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarArrowColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarArrowColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_scrollbarTrackColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_scrollbarTrackColor(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_writingMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_writingMode(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_zoom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_zoom(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_filter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_filter(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_textAlignLast(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_textAlignLast(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_textKashidaSpace(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_textKashidaSpace(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle2_get_isBlock(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle2.VTable, self.vtable).get_isBlock(@ptrCast(*const IHTMLCurrentStyle2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle3_Value = @import("../zig.zig").Guid.initString("3050F818-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCurrentStyle3 = &IID_IHTMLCurrentStyle3_Value;
pub const IHTMLCurrentStyle3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_textOverflow: fn(
            self: *const IHTMLCurrentStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_minHeight: fn(
            self: *const IHTMLCurrentStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wordSpacing: fn(
            self: *const IHTMLCurrentStyle3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_whiteSpace: fn(
            self: *const IHTMLCurrentStyle3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle3_get_textOverflow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle3.VTable, self.vtable).get_textOverflow(@ptrCast(*const IHTMLCurrentStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle3_get_minHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle3.VTable, self.vtable).get_minHeight(@ptrCast(*const IHTMLCurrentStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle3_get_wordSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle3.VTable, self.vtable).get_wordSpacing(@ptrCast(*const IHTMLCurrentStyle3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle3_get_whiteSpace(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle3.VTable, self.vtable).get_whiteSpace(@ptrCast(*const IHTMLCurrentStyle3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle4_Value = @import("../zig.zig").Guid.initString("3050F33B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCurrentStyle4 = &IID_IHTMLCurrentStyle4_Value;
pub const IHTMLCurrentStyle4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_msInterpolationMode: fn(
            self: *const IHTMLCurrentStyle4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxHeight: fn(
            self: *const IHTMLCurrentStyle4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_minWidth: fn(
            self: *const IHTMLCurrentStyle4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxWidth: fn(
            self: *const IHTMLCurrentStyle4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle4_get_msInterpolationMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle4.VTable, self.vtable).get_msInterpolationMode(@ptrCast(*const IHTMLCurrentStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle4_get_maxHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle4.VTable, self.vtable).get_maxHeight(@ptrCast(*const IHTMLCurrentStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle4_get_minWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle4.VTable, self.vtable).get_minWidth(@ptrCast(*const IHTMLCurrentStyle4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle4_get_maxWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle4.VTable, self.vtable).get_maxWidth(@ptrCast(*const IHTMLCurrentStyle4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCurrentStyle5_Value = @import("../zig.zig").Guid.initString("30510481-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCurrentStyle5 = &IID_IHTMLCurrentStyle5_Value;
pub const IHTMLCurrentStyle5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_captionSide: fn(
            self: *const IHTMLCurrentStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outline: fn(
            self: *const IHTMLCurrentStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineWidth: fn(
            self: *const IHTMLCurrentStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineStyle: fn(
            self: *const IHTMLCurrentStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outlineColor: fn(
            self: *const IHTMLCurrentStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boxSizing: fn(
            self: *const IHTMLCurrentStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderSpacing: fn(
            self: *const IHTMLCurrentStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_orphans: fn(
            self: *const IHTMLCurrentStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_widows: fn(
            self: *const IHTMLCurrentStyle5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageBreakInside: fn(
            self: *const IHTMLCurrentStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_emptyCells: fn(
            self: *const IHTMLCurrentStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msBlockProgression: fn(
            self: *const IHTMLCurrentStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_quotes: fn(
            self: *const IHTMLCurrentStyle5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_captionSide(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_captionSide(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_outline(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_outline(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_outlineWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_outlineWidth(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_outlineStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_outlineStyle(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_outlineColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_outlineColor(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_boxSizing(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_boxSizing(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_borderSpacing(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_borderSpacing(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_orphans(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_orphans(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_widows(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_widows(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_pageBreakInside(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_pageBreakInside(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_emptyCells(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_emptyCells(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_msBlockProgression(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_msBlockProgression(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCurrentStyle5_get_quotes(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCurrentStyle5.VTable, self.vtable).get_quotes(@ptrCast(*const IHTMLCurrentStyle5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCurrentStyle_Value = @import("../zig.zig").Guid.initString("3050F557-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLCurrentStyle = &IID_DispHTMLCurrentStyle_Value;
pub const DispHTMLCurrentStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement_Value = @import("../zig.zig").Guid.initString("3050F1FF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElement = &IID_IHTMLElement_Value;
pub const IHTMLElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        setAttribute: fn(
            self: *const IHTMLElement,
            strAttributeName: BSTR,
            AttributeValue: VARIANT,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLElement,
            strAttributeName: BSTR,
            lFlags: i32,
            AttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLElement,
            strAttributeName: BSTR,
            lFlags: i32,
            pfSuccess: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_className: fn(
            self: *const IHTMLElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_className: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_id: fn(
            self: *const IHTMLElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_id: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tagName: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentElement: fn(
            self: *const IHTMLElement,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_style: fn(
            self: *const IHTMLElement,
            p: **IHTMLStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onhelp: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onhelp: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onclick: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onclick: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondblclick: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondblclick: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onkeydown: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onkeydown: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onkeyup: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onkeyup: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onkeypress: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onkeypress: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseout: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseout: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseover: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseover: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmousemove: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmousemove: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmousedown: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmousedown: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseup: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseup: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_document: fn(
            self: *const IHTMLElement,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_title: fn(
            self: *const IHTMLElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_title: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_language: fn(
            self: *const IHTMLElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_language: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselectstart: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselectstart: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollIntoView: fn(
            self: *const IHTMLElement,
            varargStart: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        contains: fn(
            self: *const IHTMLElement,
            pChild: *IHTMLElement,
            pfResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_sourceIndex: fn(
            self: *const IHTMLElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_recordNumber: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lang: fn(
            self: *const IHTMLElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lang: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetLeft: fn(
            self: *const IHTMLElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetTop: fn(
            self: *const IHTMLElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetWidth: fn(
            self: *const IHTMLElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetHeight: fn(
            self: *const IHTMLElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetParent: fn(
            self: *const IHTMLElement,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_innerHTML: fn(
            self: *const IHTMLElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_innerHTML: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_innerText: fn(
            self: *const IHTMLElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_innerText: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outerHTML: fn(
            self: *const IHTMLElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outerHTML: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_outerText: fn(
            self: *const IHTMLElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outerText: fn(
            self: *const IHTMLElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertAdjacentHTML: fn(
            self: *const IHTMLElement,
            where: BSTR,
            html: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertAdjacentText: fn(
            self: *const IHTMLElement,
            where: BSTR,
            text: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentTextEdit: fn(
            self: *const IHTMLElement,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isTextEdit: fn(
            self: *const IHTMLElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        click: fn(
            self: *const IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_filters: fn(
            self: *const IHTMLElement,
            p: **IHTMLFiltersCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragstart: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragstart: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLElement,
            String: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeupdate: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeupdate: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onafterupdate: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onafterupdate: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerrorupdate: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerrorupdate: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onrowexit: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onrowexit: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onrowenter: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onrowenter: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondatasetchanged: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondatasetchanged: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondataavailable: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondataavailable: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondatasetcomplete: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondatasetcomplete: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfilterchange: fn(
            self: *const IHTMLElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfilterchange: fn(
            self: *const IHTMLElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_children: fn(
            self: *const IHTMLElement,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_all: fn(
            self: *const IHTMLElement,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_setAttribute(self: *const T, strAttributeName: BSTR, AttributeValue: VARIANT, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLElement, self), strAttributeName, AttributeValue, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_getAttribute(self: *const T, strAttributeName: BSTR, lFlags: i32, AttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLElement, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_removeAttribute(self: *const T, strAttributeName: BSTR, lFlags: i32, pfSuccess: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLElement, self), strAttributeName, lFlags, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_className(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_className(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_className(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_className(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_id(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_id(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_id(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_id(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_tagName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_tagName(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_parentElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_parentElement(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_style(self: *const T, p: **IHTMLStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_style(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onhelp(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onhelp(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onhelp(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onhelp(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onclick(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onclick(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onclick(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondblclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondblclick(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondblclick(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondblclick(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onkeydown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onkeydown(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onkeydown(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onkeydown(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onkeyup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onkeyup(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onkeyup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onkeyup(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onkeypress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onkeypress(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onkeypress(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onkeypress(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmouseout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmouseout(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmouseout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmouseout(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmouseover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmouseover(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmouseover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmouseover(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmousemove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmousemove(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmousemove(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmousemove(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmousedown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmousedown(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmousedown(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmousedown(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onmouseup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onmouseup(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onmouseup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onmouseup(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_document(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_document(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_title(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_title(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_title(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_title(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_language(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_language(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_language(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_language(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onselectstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onselectstart(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onselectstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onselectstart(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_scrollIntoView(self: *const T, varargStart: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).scrollIntoView(@ptrCast(*const IHTMLElement, self), varargStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_contains(self: *const T, pChild: *IHTMLElement, pfResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).contains(@ptrCast(*const IHTMLElement, self), pChild, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_sourceIndex(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_sourceIndex(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_recordNumber(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_recordNumber(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_lang(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_lang(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_lang(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_lang(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetLeft(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetTop(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetWidth(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetHeight(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_offsetParent(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_offsetParent(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_innerHTML(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_innerHTML(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_innerHTML(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_innerHTML(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_innerText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_innerText(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_innerText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_innerText(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_outerHTML(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_outerHTML(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_outerHTML(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_outerHTML(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_outerText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_outerText(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_outerText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_outerText(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_insertAdjacentHTML(self: *const T, where: BSTR, html: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).insertAdjacentHTML(@ptrCast(*const IHTMLElement, self), where, html);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_insertAdjacentText(self: *const T, where: BSTR, text: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).insertAdjacentText(@ptrCast(*const IHTMLElement, self), where, text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_parentTextEdit(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_parentTextEdit(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_isTextEdit(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_isTextEdit(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_click(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).click(@ptrCast(*const IHTMLElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_filters(self: *const T, p: **IHTMLFiltersCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_filters(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondragstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondragstart(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondragstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondragstart(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_toString(self: *const T, String: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).toString(@ptrCast(*const IHTMLElement, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onbeforeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onbeforeupdate(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onbeforeupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onbeforeupdate(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onafterupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onafterupdate(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onafterupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onafterupdate(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onerrorupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onerrorupdate(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onerrorupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onerrorupdate(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onrowexit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onrowexit(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onrowexit(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onrowexit(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onrowenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onrowenter(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onrowenter(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onrowenter(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondatasetchanged(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondatasetchanged(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondatasetchanged(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondatasetchanged(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondataavailable(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondataavailable(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondataavailable(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondataavailable(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_ondatasetcomplete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_ondatasetcomplete(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_ondatasetcomplete(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_ondatasetcomplete(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_put_onfilterchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).put_onfilterchange(@ptrCast(*const IHTMLElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_onfilterchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_onfilterchange(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_children(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_children(@ptrCast(*const IHTMLElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement_get_all(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement.VTable, self.vtable).get_all(@ptrCast(*const IHTMLElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRect_Value = @import("../zig.zig").Guid.initString("3050F4A3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRect = &IID_IHTMLRect_Value;
pub const IHTMLRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_left: fn(
            self: *const IHTMLRect,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_left: fn(
            self: *const IHTMLRect,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_top: fn(
            self: *const IHTMLRect,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_top: fn(
            self: *const IHTMLRect,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_right: fn(
            self: *const IHTMLRect,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_right: fn(
            self: *const IHTMLRect,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bottom: fn(
            self: *const IHTMLRect,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bottom: fn(
            self: *const IHTMLRect,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_put_left(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).put_left(@ptrCast(*const IHTMLRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_get_left(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).get_left(@ptrCast(*const IHTMLRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_put_top(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).put_top(@ptrCast(*const IHTMLRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_get_top(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).get_top(@ptrCast(*const IHTMLRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_put_right(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).put_right(@ptrCast(*const IHTMLRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_get_right(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).get_right(@ptrCast(*const IHTMLRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_put_bottom(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).put_bottom(@ptrCast(*const IHTMLRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect_get_bottom(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect.VTable, self.vtable).get_bottom(@ptrCast(*const IHTMLRect, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRect2_Value = @import("../zig.zig").Guid.initString("3051076C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRect2 = &IID_IHTMLRect2_Value;
pub const IHTMLRect2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_width: fn(
            self: *const IHTMLRect2,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLRect2,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect2_get_width(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect2.VTable, self.vtable).get_width(@ptrCast(*const IHTMLRect2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRect2_get_height(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRect2.VTable, self.vtable).get_height(@ptrCast(*const IHTMLRect2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLRectCollection_Value = @import("../zig.zig").Guid.initString("3050F4A4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLRectCollection = &IID_IHTMLRectCollection_Value;
pub const IHTMLRectCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLRectCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLRectCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLRectCollection,
            pvarIndex: *VARIANT,
            pvarResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRectCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRectCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLRectCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRectCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRectCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLRectCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLRectCollection_item(self: *const T, pvarIndex: *VARIANT, pvarResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLRectCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLRectCollection, self), pvarIndex, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementCollection_Value = @import("../zig.zig").Guid.initString("3050F21F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElementCollection = &IID_IHTMLElementCollection_Value;
pub const IHTMLElementCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        toString: fn(
            self: *const IHTMLElementCollection,
            String: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_length: fn(
            self: *const IHTMLElementCollection,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLElementCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLElementCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLElementCollection,
            name: VARIANT,
            index: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        tags: fn(
            self: *const IHTMLElementCollection,
            tagName: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_toString(self: *const T, String: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).toString(@ptrCast(*const IHTMLElementCollection, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).put_length(@ptrCast(*const IHTMLElementCollection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLElementCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLElementCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_item(self: *const T, name: VARIANT, index: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLElementCollection, self), name, index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection_tags(self: *const T, tagName: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection.VTable, self.vtable).tags(@ptrCast(*const IHTMLElementCollection, self), tagName, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement2_Value = @import("../zig.zig").Guid.initString("3050F434-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElement2 = &IID_IHTMLElement2_Value;
pub const IHTMLElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_scopeName: fn(
            self: *const IHTMLElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setCapture: fn(
            self: *const IHTMLElement2,
            containerCapture: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        releaseCapture: fn(
            self: *const IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onlosecapture: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onlosecapture: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        componentFromPoint: fn(
            self: *const IHTMLElement2,
            x: i32,
            y: i32,
            component: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doScroll: fn(
            self: *const IHTMLElement2,
            component: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onscroll: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onscroll: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondrag: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondrag: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragend: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragend: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragenter: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragenter: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragover: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragover: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragleave: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragleave: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondrop: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondrop: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforecut: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforecut: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncut: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncut: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforecopy: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforecopy: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncopy: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncopy: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforepaste: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforepaste: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onpaste: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onpaste: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentStyle: fn(
            self: *const IHTMLElement2,
            p: **IHTMLCurrentStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onpropertychange: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onpropertychange: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getClientRects: fn(
            self: *const IHTMLElement2,
            pRectCol: **IHTMLRectCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBoundingClientRect: fn(
            self: *const IHTMLElement2,
            pRect: **IHTMLRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setExpression: fn(
            self: *const IHTMLElement2,
            propname: BSTR,
            expression: BSTR,
            language: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getExpression: fn(
            self: *const IHTMLElement2,
            propname: BSTR,
            expression: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeExpression: fn(
            self: *const IHTMLElement2,
            propname: BSTR,
            pfSuccess: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_tabIndex: fn(
            self: *const IHTMLElement2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tabIndex: fn(
            self: *const IHTMLElement2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_accessKey: fn(
            self: *const IHTMLElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accessKey: fn(
            self: *const IHTMLElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onblur: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onblur: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocus: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocus: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onresize: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onresize: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addFilter: fn(
            self: *const IHTMLElement2,
            pUnk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeFilter: fn(
            self: *const IHTMLElement2,
            pUnk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientHeight: fn(
            self: *const IHTMLElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientWidth: fn(
            self: *const IHTMLElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientTop: fn(
            self: *const IHTMLElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientLeft: fn(
            self: *const IHTMLElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attachEvent: fn(
            self: *const IHTMLElement2,
            event: BSTR,
            pDisp: *IDispatch,
            pfResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTMLElement2,
            event: BSTR,
            pDisp: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onrowsdelete: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onrowsdelete: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onrowsinserted: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onrowsinserted: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncellchange: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncellchange: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dir: fn(
            self: *const IHTMLElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dir: fn(
            self: *const IHTMLElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createControlRange: fn(
            self: *const IHTMLElement2,
            range: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollHeight: fn(
            self: *const IHTMLElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollWidth: fn(
            self: *const IHTMLElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollTop: fn(
            self: *const IHTMLElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollTop: fn(
            self: *const IHTMLElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollLeft: fn(
            self: *const IHTMLElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollLeft: fn(
            self: *const IHTMLElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearAttributes: fn(
            self: *const IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        mergeAttributes: fn(
            self: *const IHTMLElement2,
            mergeThis: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncontextmenu: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncontextmenu: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertAdjacentElement: fn(
            self: *const IHTMLElement2,
            where: BSTR,
            insertedElement: *IHTMLElement,
            inserted: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        applyElement: fn(
            self: *const IHTMLElement2,
            apply: *IHTMLElement,
            where: BSTR,
            applied: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAdjacentText: fn(
            self: *const IHTMLElement2,
            where: BSTR,
            text: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceAdjacentText: fn(
            self: *const IHTMLElement2,
            where: BSTR,
            newText: BSTR,
            oldText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_canHaveChildren: fn(
            self: *const IHTMLElement2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addBehavior: fn(
            self: *const IHTMLElement2,
            bstrUrl: BSTR,
            pvarFactory: *VARIANT,
            pCookie: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeBehavior: fn(
            self: *const IHTMLElement2,
            cookie: i32,
            pfResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_runtimeStyle: fn(
            self: *const IHTMLElement2,
            p: **IHTMLStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_behaviorUrns: fn(
            self: *const IHTMLElement2,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_tagUrn: fn(
            self: *const IHTMLElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tagUrn: fn(
            self: *const IHTMLElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeeditfocus: fn(
            self: *const IHTMLElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeeditfocus: fn(
            self: *const IHTMLElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyStateValue: fn(
            self: *const IHTMLElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagName: fn(
            self: *const IHTMLElement2,
            v: BSTR,
            pelColl: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scopeName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scopeName(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_setCapture(self: *const T, containerCapture: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).setCapture(@ptrCast(*const IHTMLElement2, self), containerCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_releaseCapture(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).releaseCapture(@ptrCast(*const IHTMLElement2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onlosecapture(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onlosecapture(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onlosecapture(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onlosecapture(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_componentFromPoint(self: *const T, x: i32, y: i32, component: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).componentFromPoint(@ptrCast(*const IHTMLElement2, self), x, y, component);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_doScroll(self: *const T, component: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).doScroll(@ptrCast(*const IHTMLElement2, self), component);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onscroll(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onscroll(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onscroll(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onscroll(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondrag(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondrag(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondrag(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondrag(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondragend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondragend(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondragend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondragend(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondragenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondragenter(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondragenter(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondragenter(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondragover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondragover(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondragover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondragover(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondragleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondragleave(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondragleave(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondragleave(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_ondrop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_ondrop(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_ondrop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_ondrop(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onbeforecut(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onbeforecut(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onbeforecut(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onbeforecut(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_oncut(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_oncut(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_oncut(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_oncut(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onbeforecopy(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onbeforecopy(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onbeforecopy(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onbeforecopy(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_oncopy(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_oncopy(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_oncopy(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_oncopy(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onbeforepaste(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onbeforepaste(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onbeforepaste(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onbeforepaste(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onpaste(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onpaste(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onpaste(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onpaste(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_currentStyle(self: *const T, p: **IHTMLCurrentStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_currentStyle(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onpropertychange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onpropertychange(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onpropertychange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onpropertychange(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getClientRects(self: *const T, pRectCol: **IHTMLRectCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getClientRects(@ptrCast(*const IHTMLElement2, self), pRectCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getBoundingClientRect(self: *const T, pRect: **IHTMLRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getBoundingClientRect(@ptrCast(*const IHTMLElement2, self), pRect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_setExpression(self: *const T, propname: BSTR, expression: BSTR, language: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).setExpression(@ptrCast(*const IHTMLElement2, self), propname, expression, language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getExpression(self: *const T, propname: BSTR, expression: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getExpression(@ptrCast(*const IHTMLElement2, self), propname, expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_removeExpression(self: *const T, propname: BSTR, pfSuccess: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).removeExpression(@ptrCast(*const IHTMLElement2, self), propname, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_tabIndex(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_tabIndex(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_tabIndex(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_tabIndex(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).focus(@ptrCast(*const IHTMLElement2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_accessKey(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_accessKey(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_accessKey(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_accessKey(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onblur(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onfocus(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onresize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onresize(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onresize(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onresize(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).blur(@ptrCast(*const IHTMLElement2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_addFilter(self: *const T, pUnk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).addFilter(@ptrCast(*const IHTMLElement2, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_removeFilter(self: *const T, pUnk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).removeFilter(@ptrCast(*const IHTMLElement2, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_clientHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_clientHeight(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_clientWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_clientWidth(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_clientTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_clientTop(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_clientLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_clientLeft(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_attachEvent(self: *const T, event: BSTR, pDisp: *IDispatch, pfResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).attachEvent(@ptrCast(*const IHTMLElement2, self), event, pDisp, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_detachEvent(self: *const T, event: BSTR, pDisp: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).detachEvent(@ptrCast(*const IHTMLElement2, self), event, pDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_readyState(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onrowsdelete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onrowsdelete(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onrowsdelete(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onrowsdelete(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onrowsinserted(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onrowsinserted(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onrowsinserted(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onrowsinserted(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_oncellchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_oncellchange(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_oncellchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_oncellchange(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_dir(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_dir(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_dir(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_dir(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_createControlRange(self: *const T, range: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).createControlRange(@ptrCast(*const IHTMLElement2, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scrollHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scrollHeight(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scrollWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scrollWidth(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_scrollTop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_scrollTop(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scrollTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scrollTop(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_scrollLeft(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_scrollLeft(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_scrollLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_scrollLeft(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_clearAttributes(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).clearAttributes(@ptrCast(*const IHTMLElement2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_mergeAttributes(self: *const T, mergeThis: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).mergeAttributes(@ptrCast(*const IHTMLElement2, self), mergeThis);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_oncontextmenu(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_oncontextmenu(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_oncontextmenu(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_oncontextmenu(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_insertAdjacentElement(self: *const T, where: BSTR, insertedElement: *IHTMLElement, inserted: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).insertAdjacentElement(@ptrCast(*const IHTMLElement2, self), where, insertedElement, inserted);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_applyElement(self: *const T, apply: *IHTMLElement, where: BSTR, applied: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).applyElement(@ptrCast(*const IHTMLElement2, self), apply, where, applied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getAdjacentText(self: *const T, where: BSTR, text: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getAdjacentText(@ptrCast(*const IHTMLElement2, self), where, text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_replaceAdjacentText(self: *const T, where: BSTR, newText: BSTR, oldText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).replaceAdjacentText(@ptrCast(*const IHTMLElement2, self), where, newText, oldText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_canHaveChildren(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_canHaveChildren(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_addBehavior(self: *const T, bstrUrl: BSTR, pvarFactory: *VARIANT, pCookie: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).addBehavior(@ptrCast(*const IHTMLElement2, self), bstrUrl, pvarFactory, pCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_removeBehavior(self: *const T, cookie: i32, pfResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).removeBehavior(@ptrCast(*const IHTMLElement2, self), cookie, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_runtimeStyle(self: *const T, p: **IHTMLStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_runtimeStyle(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_behaviorUrns(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_behaviorUrns(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_tagUrn(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_tagUrn(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_tagUrn(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_tagUrn(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_put_onbeforeeditfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).put_onbeforeeditfocus(@ptrCast(*const IHTMLElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_onbeforeeditfocus(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_onbeforeeditfocus(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_get_readyStateValue(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).get_readyStateValue(@ptrCast(*const IHTMLElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement2_getElementsByTagName(self: *const T, v: BSTR, pelColl: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement2.VTable, self.vtable).getElementsByTagName(@ptrCast(*const IHTMLElement2, self), v, pelColl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAttributeCollection3_Value = @import("../zig.zig").Guid.initString("30510469-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAttributeCollection3 = &IID_IHTMLAttributeCollection3_Value;
pub const IHTMLAttributeCollection3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getNamedItem: fn(
            self: *const IHTMLAttributeCollection3,
            bstrName: BSTR,
            ppNodeOut: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItem: fn(
            self: *const IHTMLAttributeCollection3,
            pNodeIn: *IHTMLDOMAttribute,
            ppNodeOut: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItem: fn(
            self: *const IHTMLAttributeCollection3,
            bstrName: BSTR,
            ppNodeOut: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAttributeCollection3,
            index: i32,
            ppNodeOut: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLAttributeCollection3,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_getNamedItem(self: *const T, bstrName: BSTR, ppNodeOut: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).getNamedItem(@ptrCast(*const IHTMLAttributeCollection3, self), bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_setNamedItem(self: *const T, pNodeIn: *IHTMLDOMAttribute, ppNodeOut: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).setNamedItem(@ptrCast(*const IHTMLAttributeCollection3, self), pNodeIn, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_removeNamedItem(self: *const T, bstrName: BSTR, ppNodeOut: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).removeNamedItem(@ptrCast(*const IHTMLAttributeCollection3, self), bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_item(self: *const T, index: i32, ppNodeOut: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).item(@ptrCast(*const IHTMLAttributeCollection3, self), index, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection3_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection3.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAttributeCollection3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMDocumentType_Value = @import("../zig.zig").Guid.initString("30510738-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMDocumentType = &IID_IDOMDocumentType_Value;
pub const IDOMDocumentType = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_name: fn(
            self: *const IDOMDocumentType,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_entities: fn(
            self: *const IDOMDocumentType,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_notations: fn(
            self: *const IDOMDocumentType,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_publicId: fn(
            self: *const IDOMDocumentType,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_systemId: fn(
            self: *const IDOMDocumentType,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_internalSubset: fn(
            self: *const IDOMDocumentType,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_name(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_entities(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_entities(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_notations(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_notations(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_publicId(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_publicId(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_systemId(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_systemId(@ptrCast(*const IDOMDocumentType, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDocumentType_get_internalSubset(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDocumentType.VTable, self.vtable).get_internalSubset(@ptrCast(*const IDOMDocumentType, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument7_Value = @import("../zig.zig").Guid.initString("305104B8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDocument7 = &IID_IHTMLDocument7_Value;
pub const IHTMLDocument7 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_defaultView: fn(
            self: *const IHTMLDocument7,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createCDATASection: fn(
            self: *const IHTMLDocument7,
            text: BSTR,
            newCDATASectionNode: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getSelection: fn(
            self: *const IHTMLDocument7,
            ppIHTMLSelection: **IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagNameNS: fn(
            self: *const IHTMLDocument7,
            pvarNS: *VARIANT,
            bstrLocalName: BSTR,
            pelColl: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElementNS: fn(
            self: *const IHTMLDocument7,
            pvarNS: *VARIANT,
            bstrTag: BSTR,
            newElem: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createAttributeNS: fn(
            self: *const IHTMLDocument7,
            pvarNS: *VARIANT,
            bstrAttrName: BSTR,
            ppAttribute: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsthumbnailclick: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsthumbnailclick: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_characterSet: fn(
            self: *const IHTMLDocument7,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IHTMLDocument7,
            bstrTag: BSTR,
            newElem: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createAttribute: fn(
            self: *const IHTMLDocument7,
            bstrAttrName: BSTR,
            ppAttribute: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByClassName: fn(
            self: *const IHTMLDocument7,
            v: BSTR,
            pel: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createProcessingInstruction: fn(
            self: *const IHTMLDocument7,
            bstrTarget: BSTR,
            bstrData: BSTR,
            newProcessingInstruction: **IDOMProcessingInstruction,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        adoptNode: fn(
            self: *const IHTMLDocument7,
            pNodeSource: *IHTMLDOMNode,
            ppNodeDest: **IHTMLDOMNode3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmssitemodejumplistitemremoved: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmssitemodejumplistitemremoved: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_all: fn(
            self: *const IHTMLDocument7,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_inputEncoding: fn(
            self: *const IHTMLDocument7,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_xmlEncoding: fn(
            self: *const IHTMLDocument7,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_xmlStandalone: fn(
            self: *const IHTMLDocument7,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_xmlStandalone: fn(
            self: *const IHTMLDocument7,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_xmlVersion: fn(
            self: *const IHTMLDocument7,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_xmlVersion: fn(
            self: *const IHTMLDocument7,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLDocument7,
            pfHasAttributes: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onabort: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onabort: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onblur: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onblur: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncanplay: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncanplay: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncanplaythrough: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncanplaythrough: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchange: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchange: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondrag: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondrag: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragend: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragend: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragenter: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragenter: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragleave: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragleave: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragover: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragover: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondrop: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondrop: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondurationchange: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondurationchange: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onemptied: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onemptied: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onended: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onended: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocus: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocus: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oninput: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oninput: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onloadeddata: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onloadeddata: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onloadedmetadata: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onloadedmetadata: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onloadstart: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onloadstart: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onpause: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onpause: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onplay: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onplay: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onplaying: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onplaying: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onprogress: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onprogress: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onratechange: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onratechange: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreset: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreset: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onscroll: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onscroll: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onseeked: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onseeked: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onseeking: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onseeking: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselect: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselect: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstalled: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstalled: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onsubmit: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onsubmit: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onsuspend: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onsuspend: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ontimeupdate: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ontimeupdate: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onvolumechange: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onvolumechange: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onwaiting: fn(
            self: *const IHTMLDocument7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onwaiting: fn(
            self: *const IHTMLDocument7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IHTMLDocument7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        importNode: fn(
            self: *const IHTMLDocument7,
            pNodeSource: *IHTMLDOMNode,
            fDeep: i16,
            ppNodeDest: **IHTMLDOMNode3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentWindow: fn(
            self: *const IHTMLDocument7,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_body: fn(
            self: *const IHTMLDocument7,
            v: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_body: fn(
            self: *const IHTMLDocument7,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_head: fn(
            self: *const IHTMLDocument7,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_defaultView(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_defaultView(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createCDATASection(self: *const T, text: BSTR, newCDATASectionNode: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createCDATASection(@ptrCast(*const IHTMLDocument7, self), text, newCDATASectionNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_getSelection(self: *const T, ppIHTMLSelection: **IHTMLSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).getSelection(@ptrCast(*const IHTMLDocument7, self), ppIHTMLSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_getElementsByTagNameNS(self: *const T, pvarNS: *VARIANT, bstrLocalName: BSTR, pelColl: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).getElementsByTagNameNS(@ptrCast(*const IHTMLDocument7, self), pvarNS, bstrLocalName, pelColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createElementNS(self: *const T, pvarNS: *VARIANT, bstrTag: BSTR, newElem: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createElementNS(@ptrCast(*const IHTMLDocument7, self), pvarNS, bstrTag, newElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createAttributeNS(self: *const T, pvarNS: *VARIANT, bstrAttrName: BSTR, ppAttribute: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createAttributeNS(@ptrCast(*const IHTMLDocument7, self), pvarNS, bstrAttrName, ppAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onmsthumbnailclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onmsthumbnailclick(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onmsthumbnailclick(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onmsthumbnailclick(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_characterSet(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_characterSet(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createElement(self: *const T, bstrTag: BSTR, newElem: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createElement(@ptrCast(*const IHTMLDocument7, self), bstrTag, newElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createAttribute(self: *const T, bstrAttrName: BSTR, ppAttribute: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createAttribute(@ptrCast(*const IHTMLDocument7, self), bstrAttrName, ppAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_getElementsByClassName(self: *const T, v: BSTR, pel: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).getElementsByClassName(@ptrCast(*const IHTMLDocument7, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_createProcessingInstruction(self: *const T, bstrTarget: BSTR, bstrData: BSTR, newProcessingInstruction: **IDOMProcessingInstruction) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).createProcessingInstruction(@ptrCast(*const IHTMLDocument7, self), bstrTarget, bstrData, newProcessingInstruction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_adoptNode(self: *const T, pNodeSource: *IHTMLDOMNode, ppNodeDest: **IHTMLDOMNode3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).adoptNode(@ptrCast(*const IHTMLDocument7, self), pNodeSource, ppNodeDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onmssitemodejumplistitemremoved(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onmssitemodejumplistitemremoved(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onmssitemodejumplistitemremoved(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onmssitemodejumplistitemremoved(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_all(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_all(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_inputEncoding(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_inputEncoding(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_xmlEncoding(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_xmlEncoding(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_xmlStandalone(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_xmlStandalone(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_xmlStandalone(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_xmlStandalone(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_xmlVersion(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_xmlVersion(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_xmlVersion(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_xmlVersion(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_hasAttributes(self: *const T, pfHasAttributes: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLDocument7, self), pfHasAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onabort(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onblur(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_oncanplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_oncanplay(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_oncanplay(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_oncanplay(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_oncanplaythrough(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_oncanplaythrough(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_oncanplaythrough(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_oncanplaythrough(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondrag(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondrag(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondrag(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondrag(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondragend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondragend(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondragend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondragend(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondragenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondragenter(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondragenter(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondragenter(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondragleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondragleave(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondragleave(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondragleave(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondragover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondragover(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondragover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondragover(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondrop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondrop(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondrop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondrop(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ondurationchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ondurationchange(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ondurationchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ondurationchange(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onemptied(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onemptied(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onemptied(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onemptied(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onended(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onended(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onended(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onended(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onfocus(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_oninput(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_oninput(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_oninput(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_oninput(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onloadeddata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onloadeddata(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onloadeddata(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onloadeddata(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onloadedmetadata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onloadedmetadata(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onloadedmetadata(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onloadedmetadata(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onloadstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onloadstart(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onloadstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onloadstart(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onpause(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onpause(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onpause(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onpause(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onplay(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onplay(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onplay(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onplaying(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onplaying(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onplaying(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onplaying(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onprogress(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onratechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onratechange(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onratechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onratechange(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onreset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onreset(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onreset(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onreset(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onscroll(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onscroll(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onscroll(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onscroll(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onseeked(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onseeked(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onseeked(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onseeked(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onseeking(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onseeking(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onseeking(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onseeking(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onstalled(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onstalled(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onstalled(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onstalled(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onsubmit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onsubmit(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onsubmit(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onsubmit(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onsuspend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onsuspend(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onsuspend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onsuspend(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_ontimeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_ontimeupdate(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_ontimeupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_ontimeupdate(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onvolumechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onvolumechange(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onvolumechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onvolumechange(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_put_onwaiting(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).put_onwaiting(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_onwaiting(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_onwaiting(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).normalize(@ptrCast(*const IHTMLDocument7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_importNode(self: *const T, pNodeSource: *IHTMLDOMNode, fDeep: i16, ppNodeDest: **IHTMLDOMNode3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).importNode(@ptrCast(*const IHTMLDocument7, self), pNodeSource, fDeep, ppNodeDest);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_parentWindow(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_parentWindow(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_putref_body(self: *const T, v: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).putref_body(@ptrCast(*const IHTMLDocument7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_body(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_body(@ptrCast(*const IHTMLDocument7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument7_get_head(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument7.VTable, self.vtable).get_head(@ptrCast(*const IHTMLDocument7, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMNode_Value = @import("../zig.zig").Guid.initString("3050F5DA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMNode = &IID_IHTMLDOMNode_Value;
pub const IHTMLDOMNode = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_nodeType: fn(
            self: *const IHTMLDOMNode,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentNode: fn(
            self: *const IHTMLDOMNode,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasChildNodes: fn(
            self: *const IHTMLDOMNode,
            fChildren: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_childNodes: fn(
            self: *const IHTMLDOMNode,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_attributes: fn(
            self: *const IHTMLDOMNode,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertBefore: fn(
            self: *const IHTMLDOMNode,
            newChild: *IHTMLDOMNode,
            refChild: VARIANT,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IHTMLDOMNode,
            oldChild: *IHTMLDOMNode,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceChild: fn(
            self: *const IHTMLDOMNode,
            newChild: *IHTMLDOMNode,
            oldChild: *IHTMLDOMNode,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneNode: fn(
            self: *const IHTMLDOMNode,
            fDeep: i16,
            clonedNode: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNode: fn(
            self: *const IHTMLDOMNode,
            fDeep: i16,
            removed: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        swapNode: fn(
            self: *const IHTMLDOMNode,
            otherNode: *IHTMLDOMNode,
            swappedNode: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceNode: fn(
            self: *const IHTMLDOMNode,
            replacement: *IHTMLDOMNode,
            replaced: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendChild: fn(
            self: *const IHTMLDOMNode,
            newChild: *IHTMLDOMNode,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeName: fn(
            self: *const IHTMLDOMNode,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_nodeValue: fn(
            self: *const IHTMLDOMNode,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeValue: fn(
            self: *const IHTMLDOMNode,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_firstChild: fn(
            self: *const IHTMLDOMNode,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lastChild: fn(
            self: *const IHTMLDOMNode,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_previousSibling: fn(
            self: *const IHTMLDOMNode,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nextSibling: fn(
            self: *const IHTMLDOMNode,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_nodeType(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_nodeType(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_parentNode(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_parentNode(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_hasChildNodes(self: *const T, fChildren: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).hasChildNodes(@ptrCast(*const IHTMLDOMNode, self), fChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_childNodes(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_childNodes(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_attributes(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_attributes(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_insertBefore(self: *const T, newChild: *IHTMLDOMNode, refChild: VARIANT, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).insertBefore(@ptrCast(*const IHTMLDOMNode, self), newChild, refChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_removeChild(self: *const T, oldChild: *IHTMLDOMNode, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).removeChild(@ptrCast(*const IHTMLDOMNode, self), oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_replaceChild(self: *const T, newChild: *IHTMLDOMNode, oldChild: *IHTMLDOMNode, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).replaceChild(@ptrCast(*const IHTMLDOMNode, self), newChild, oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_cloneNode(self: *const T, fDeep: i16, clonedNode: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).cloneNode(@ptrCast(*const IHTMLDOMNode, self), fDeep, clonedNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_removeNode(self: *const T, fDeep: i16, removed: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).removeNode(@ptrCast(*const IHTMLDOMNode, self), fDeep, removed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_swapNode(self: *const T, otherNode: *IHTMLDOMNode, swappedNode: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).swapNode(@ptrCast(*const IHTMLDOMNode, self), otherNode, swappedNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_replaceNode(self: *const T, replacement: *IHTMLDOMNode, replaced: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).replaceNode(@ptrCast(*const IHTMLDOMNode, self), replacement, replaced);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_appendChild(self: *const T, newChild: *IHTMLDOMNode, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).appendChild(@ptrCast(*const IHTMLDOMNode, self), newChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_nodeName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_nodeName(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_put_nodeValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).put_nodeValue(@ptrCast(*const IHTMLDOMNode, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_nodeValue(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_nodeValue(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_firstChild(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_firstChild(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_lastChild(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_lastChild(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_previousSibling(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_previousSibling(@ptrCast(*const IHTMLDOMNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode_get_nextSibling(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode.VTable, self.vtable).get_nextSibling(@ptrCast(*const IHTMLDOMNode, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMNode2_Value = @import("../zig.zig").Guid.initString("3050F80B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMNode2 = &IID_IHTMLDOMNode2_Value;
pub const IHTMLDOMNode2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_ownerDocument: fn(
            self: *const IHTMLDOMNode2,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode2_get_ownerDocument(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode2.VTable, self.vtable).get_ownerDocument(@ptrCast(*const IHTMLDOMNode2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMNode3_Value = @import("../zig.zig").Guid.initString("305106E0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMNode3 = &IID_IHTMLDOMNode3_Value;
pub const IHTMLDOMNode3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_prefix: fn(
            self: *const IHTMLDOMNode3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_prefix: fn(
            self: *const IHTMLDOMNode3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_localName: fn(
            self: *const IHTMLDOMNode3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_namespaceURI: fn(
            self: *const IHTMLDOMNode3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textContent: fn(
            self: *const IHTMLDOMNode3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textContent: fn(
            self: *const IHTMLDOMNode3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isEqualNode: fn(
            self: *const IHTMLDOMNode3,
            otherNode: *IHTMLDOMNode3,
            isEqual: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lookupNamespaceURI: fn(
            self: *const IHTMLDOMNode3,
            pvarPrefix: *VARIANT,
            pvarNamespaceURI: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lookupPrefix: fn(
            self: *const IHTMLDOMNode3,
            pvarNamespaceURI: *VARIANT,
            pvarPrefix: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isDefaultNamespace: fn(
            self: *const IHTMLDOMNode3,
            pvarNamespace: *VARIANT,
            pfDefaultNamespace: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendChild: fn(
            self: *const IHTMLDOMNode3,
            newChild: *IHTMLDOMNode,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertBefore: fn(
            self: *const IHTMLDOMNode3,
            newChild: *IHTMLDOMNode,
            refChild: VARIANT,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IHTMLDOMNode3,
            oldChild: *IHTMLDOMNode,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceChild: fn(
            self: *const IHTMLDOMNode3,
            newChild: *IHTMLDOMNode,
            oldChild: *IHTMLDOMNode,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isSameNode: fn(
            self: *const IHTMLDOMNode3,
            otherNode: *IHTMLDOMNode3,
            isSame: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        compareDocumentPosition: fn(
            self: *const IHTMLDOMNode3,
            otherNode: *IHTMLDOMNode,
            flags: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isSupported: fn(
            self: *const IHTMLDOMNode3,
            feature: BSTR,
            version: VARIANT,
            pfisSupported: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_put_prefix(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).put_prefix(@ptrCast(*const IHTMLDOMNode3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_get_prefix(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).get_prefix(@ptrCast(*const IHTMLDOMNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_get_localName(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).get_localName(@ptrCast(*const IHTMLDOMNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_get_namespaceURI(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).get_namespaceURI(@ptrCast(*const IHTMLDOMNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_put_textContent(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).put_textContent(@ptrCast(*const IHTMLDOMNode3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_get_textContent(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).get_textContent(@ptrCast(*const IHTMLDOMNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_isEqualNode(self: *const T, otherNode: *IHTMLDOMNode3, isEqual: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).isEqualNode(@ptrCast(*const IHTMLDOMNode3, self), otherNode, isEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_lookupNamespaceURI(self: *const T, pvarPrefix: *VARIANT, pvarNamespaceURI: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).lookupNamespaceURI(@ptrCast(*const IHTMLDOMNode3, self), pvarPrefix, pvarNamespaceURI);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_lookupPrefix(self: *const T, pvarNamespaceURI: *VARIANT, pvarPrefix: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).lookupPrefix(@ptrCast(*const IHTMLDOMNode3, self), pvarNamespaceURI, pvarPrefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_isDefaultNamespace(self: *const T, pvarNamespace: *VARIANT, pfDefaultNamespace: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).isDefaultNamespace(@ptrCast(*const IHTMLDOMNode3, self), pvarNamespace, pfDefaultNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_appendChild(self: *const T, newChild: *IHTMLDOMNode, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).appendChild(@ptrCast(*const IHTMLDOMNode3, self), newChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_insertBefore(self: *const T, newChild: *IHTMLDOMNode, refChild: VARIANT, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).insertBefore(@ptrCast(*const IHTMLDOMNode3, self), newChild, refChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_removeChild(self: *const T, oldChild: *IHTMLDOMNode, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).removeChild(@ptrCast(*const IHTMLDOMNode3, self), oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_replaceChild(self: *const T, newChild: *IHTMLDOMNode, oldChild: *IHTMLDOMNode, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).replaceChild(@ptrCast(*const IHTMLDOMNode3, self), newChild, oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_isSameNode(self: *const T, otherNode: *IHTMLDOMNode3, isSame: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).isSameNode(@ptrCast(*const IHTMLDOMNode3, self), otherNode, isSame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_compareDocumentPosition(self: *const T, otherNode: *IHTMLDOMNode, flags: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).compareDocumentPosition(@ptrCast(*const IHTMLDOMNode3, self), otherNode, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMNode3_isSupported(self: *const T, feature: BSTR, version: VARIANT, pfisSupported: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMNode3.VTable, self.vtable).isSupported(@ptrCast(*const IHTMLDOMNode3, self), feature, version, pfisSupported);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMAttribute_Value = @import("../zig.zig").Guid.initString("3050F4B0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMAttribute = &IID_IHTMLDOMAttribute_Value;
pub const IHTMLDOMAttribute = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_nodeName: fn(
            self: *const IHTMLDOMAttribute,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_nodeValue: fn(
            self: *const IHTMLDOMAttribute,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeValue: fn(
            self: *const IHTMLDOMAttribute,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_specified: fn(
            self: *const IHTMLDOMAttribute,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute_get_nodeName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute.VTable, self.vtable).get_nodeName(@ptrCast(*const IHTMLDOMAttribute, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute_put_nodeValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute.VTable, self.vtable).put_nodeValue(@ptrCast(*const IHTMLDOMAttribute, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute_get_nodeValue(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute.VTable, self.vtable).get_nodeValue(@ptrCast(*const IHTMLDOMAttribute, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute_get_specified(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute.VTable, self.vtable).get_specified(@ptrCast(*const IHTMLDOMAttribute, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMAttribute2_Value = @import("../zig.zig").Guid.initString("3050F810-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMAttribute2 = &IID_IHTMLDOMAttribute2_Value;
pub const IHTMLDOMAttribute2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_name: fn(
            self: *const IHTMLDOMAttribute2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLDOMAttribute2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLDOMAttribute2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_expando: fn(
            self: *const IHTMLDOMAttribute2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeType: fn(
            self: *const IHTMLDOMAttribute2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentNode: fn(
            self: *const IHTMLDOMAttribute2,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_childNodes: fn(
            self: *const IHTMLDOMAttribute2,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_firstChild: fn(
            self: *const IHTMLDOMAttribute2,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lastChild: fn(
            self: *const IHTMLDOMAttribute2,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_previousSibling: fn(
            self: *const IHTMLDOMAttribute2,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nextSibling: fn(
            self: *const IHTMLDOMAttribute2,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_attributes: fn(
            self: *const IHTMLDOMAttribute2,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ownerDocument: fn(
            self: *const IHTMLDOMAttribute2,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertBefore: fn(
            self: *const IHTMLDOMAttribute2,
            newChild: *IHTMLDOMNode,
            refChild: VARIANT,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceChild: fn(
            self: *const IHTMLDOMAttribute2,
            newChild: *IHTMLDOMNode,
            oldChild: *IHTMLDOMNode,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeChild: fn(
            self: *const IHTMLDOMAttribute2,
            oldChild: *IHTMLDOMNode,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendChild: fn(
            self: *const IHTMLDOMAttribute2,
            newChild: *IHTMLDOMNode,
            node: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasChildNodes: fn(
            self: *const IHTMLDOMAttribute2,
            fChildren: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneNode: fn(
            self: *const IHTMLDOMAttribute2,
            fDeep: i16,
            clonedNode: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_name(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).put_value(@ptrCast(*const IHTMLDOMAttribute2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_value(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_expando(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_expando(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_nodeType(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_nodeType(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_parentNode(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_parentNode(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_childNodes(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_childNodes(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_firstChild(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_firstChild(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_lastChild(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_lastChild(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_previousSibling(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_previousSibling(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_nextSibling(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_nextSibling(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_attributes(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_attributes(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_get_ownerDocument(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).get_ownerDocument(@ptrCast(*const IHTMLDOMAttribute2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_insertBefore(self: *const T, newChild: *IHTMLDOMNode, refChild: VARIANT, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).insertBefore(@ptrCast(*const IHTMLDOMAttribute2, self), newChild, refChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_replaceChild(self: *const T, newChild: *IHTMLDOMNode, oldChild: *IHTMLDOMNode, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).replaceChild(@ptrCast(*const IHTMLDOMAttribute2, self), newChild, oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_removeChild(self: *const T, oldChild: *IHTMLDOMNode, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).removeChild(@ptrCast(*const IHTMLDOMAttribute2, self), oldChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_appendChild(self: *const T, newChild: *IHTMLDOMNode, node: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).appendChild(@ptrCast(*const IHTMLDOMAttribute2, self), newChild, node);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_hasChildNodes(self: *const T, fChildren: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).hasChildNodes(@ptrCast(*const IHTMLDOMAttribute2, self), fChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute2_cloneNode(self: *const T, fDeep: i16, clonedNode: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute2.VTable, self.vtable).cloneNode(@ptrCast(*const IHTMLDOMAttribute2, self), fDeep, clonedNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMAttribute3_Value = @import("../zig.zig").Guid.initString("30510468-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMAttribute3 = &IID_IHTMLDOMAttribute3_Value;
pub const IHTMLDOMAttribute3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_nodeValue: fn(
            self: *const IHTMLDOMAttribute3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeValue: fn(
            self: *const IHTMLDOMAttribute3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLDOMAttribute3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLDOMAttribute3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_specified: fn(
            self: *const IHTMLDOMAttribute3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ownerElement: fn(
            self: *const IHTMLDOMAttribute3,
            p: **IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_put_nodeValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).put_nodeValue(@ptrCast(*const IHTMLDOMAttribute3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_get_nodeValue(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).get_nodeValue(@ptrCast(*const IHTMLDOMAttribute3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).put_value(@ptrCast(*const IHTMLDOMAttribute3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).get_value(@ptrCast(*const IHTMLDOMAttribute3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_get_specified(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).get_specified(@ptrCast(*const IHTMLDOMAttribute3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute3_get_ownerElement(self: *const T, p: **IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute3.VTable, self.vtable).get_ownerElement(@ptrCast(*const IHTMLDOMAttribute3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMAttribute4_Value = @import("../zig.zig").Guid.initString("305106F9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMAttribute4 = &IID_IHTMLDOMAttribute4_Value;
pub const IHTMLDOMAttribute4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_nodeValue: fn(
            self: *const IHTMLDOMAttribute4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeValue: fn(
            self: *const IHTMLDOMAttribute4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeName: fn(
            self: *const IHTMLDOMAttribute4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLDOMAttribute4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLDOMAttribute4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLDOMAttribute4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_firstChild: fn(
            self: *const IHTMLDOMAttribute4,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lastChild: fn(
            self: *const IHTMLDOMAttribute4,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_childNodes: fn(
            self: *const IHTMLDOMAttribute4,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLDOMAttribute4,
            pfHasAttributes: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasChildNodes: fn(
            self: *const IHTMLDOMAttribute4,
            fChildren: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IHTMLDOMAttribute4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_specified: fn(
            self: *const IHTMLDOMAttribute4,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_put_nodeValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).put_nodeValue(@ptrCast(*const IHTMLDOMAttribute4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_nodeValue(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_nodeValue(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_nodeName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_nodeName(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_name(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).put_value(@ptrCast(*const IHTMLDOMAttribute4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_value(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_firstChild(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_firstChild(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_lastChild(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_lastChild(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_childNodes(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_childNodes(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_hasAttributes(self: *const T, pfHasAttributes: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLDOMAttribute4, self), pfHasAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_hasChildNodes(self: *const T, fChildren: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).hasChildNodes(@ptrCast(*const IHTMLDOMAttribute4, self), fChildren);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).normalize(@ptrCast(*const IHTMLDOMAttribute4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMAttribute4_get_specified(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMAttribute4.VTable, self.vtable).get_specified(@ptrCast(*const IHTMLDOMAttribute4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMTextNode_Value = @import("../zig.zig").Guid.initString("3050F4B1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMTextNode = &IID_IHTMLDOMTextNode_Value;
pub const IHTMLDOMTextNode = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_data: fn(
            self: *const IHTMLDOMTextNode,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_data: fn(
            self: *const IHTMLDOMTextNode,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLDOMTextNode,
            String: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLDOMTextNode,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        splitText: fn(
            self: *const IHTMLDOMTextNode,
            offset: i32,
            pRetNode: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_put_data(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).put_data(@ptrCast(*const IHTMLDOMTextNode, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).get_data(@ptrCast(*const IHTMLDOMTextNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_toString(self: *const T, String: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).toString(@ptrCast(*const IHTMLDOMTextNode, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).get_length(@ptrCast(*const IHTMLDOMTextNode, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode_splitText(self: *const T, offset: i32, pRetNode: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode.VTable, self.vtable).splitText(@ptrCast(*const IHTMLDOMTextNode, self), offset, pRetNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMTextNode2_Value = @import("../zig.zig").Guid.initString("3050F809-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMTextNode2 = &IID_IHTMLDOMTextNode2_Value;
pub const IHTMLDOMTextNode2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        substringData: fn(
            self: *const IHTMLDOMTextNode2,
            offset: i32,
            Count: i32,
            pbstrsubString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendData: fn(
            self: *const IHTMLDOMTextNode2,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IHTMLDOMTextNode2,
            offset: i32,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IHTMLDOMTextNode2,
            offset: i32,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IHTMLDOMTextNode2,
            offset: i32,
            Count: i32,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_substringData(self: *const T, offset: i32, Count: i32, pbstrsubString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).substringData(@ptrCast(*const IHTMLDOMTextNode2, self), offset, Count, pbstrsubString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_appendData(self: *const T, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).appendData(@ptrCast(*const IHTMLDOMTextNode2, self), bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_insertData(self: *const T, offset: i32, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).insertData(@ptrCast(*const IHTMLDOMTextNode2, self), offset, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_deleteData(self: *const T, offset: i32, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).deleteData(@ptrCast(*const IHTMLDOMTextNode2, self), offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode2_replaceData(self: *const T, offset: i32, Count: i32, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode2.VTable, self.vtable).replaceData(@ptrCast(*const IHTMLDOMTextNode2, self), offset, Count, bstrstring);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMTextNode3_Value = @import("../zig.zig").Guid.initString("3051073E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMTextNode3 = &IID_IHTMLDOMTextNode3_Value;
pub const IHTMLDOMTextNode3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        substringData: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            Count: i32,
            pbstrsubString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            Count: i32,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        splitText: fn(
            self: *const IHTMLDOMTextNode3,
            offset: i32,
            pRetNode: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wholeText: fn(
            self: *const IHTMLDOMTextNode3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceWholeText: fn(
            self: *const IHTMLDOMTextNode3,
            bstrText: BSTR,
            ppRetNode: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLDOMTextNode3,
            pfHasAttributes: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IHTMLDOMTextNode3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_substringData(self: *const T, offset: i32, Count: i32, pbstrsubString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).substringData(@ptrCast(*const IHTMLDOMTextNode3, self), offset, Count, pbstrsubString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_insertData(self: *const T, offset: i32, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).insertData(@ptrCast(*const IHTMLDOMTextNode3, self), offset, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_deleteData(self: *const T, offset: i32, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).deleteData(@ptrCast(*const IHTMLDOMTextNode3, self), offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_replaceData(self: *const T, offset: i32, Count: i32, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).replaceData(@ptrCast(*const IHTMLDOMTextNode3, self), offset, Count, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_splitText(self: *const T, offset: i32, pRetNode: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).splitText(@ptrCast(*const IHTMLDOMTextNode3, self), offset, pRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_get_wholeText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).get_wholeText(@ptrCast(*const IHTMLDOMTextNode3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_replaceWholeText(self: *const T, bstrText: BSTR, ppRetNode: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).replaceWholeText(@ptrCast(*const IHTMLDOMTextNode3, self), bstrText, ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_hasAttributes(self: *const T, pfHasAttributes: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLDOMTextNode3, self), pfHasAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMTextNode3_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMTextNode3.VTable, self.vtable).normalize(@ptrCast(*const IHTMLDOMTextNode3, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMImplementation_Value = @import("../zig.zig").Guid.initString("3050F80D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMImplementation = &IID_IHTMLDOMImplementation_Value;
pub const IHTMLDOMImplementation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        hasFeature: fn(
            self: *const IHTMLDOMImplementation,
            bstrfeature: BSTR,
            version: VARIANT,
            pfHasFeature: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation_hasFeature(self: *const T, bstrfeature: BSTR, version: VARIANT, pfHasFeature: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation.VTable, self.vtable).hasFeature(@ptrCast(*const IHTMLDOMImplementation, self), bstrfeature, version, pfHasFeature);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMImplementation2_Value = @import("../zig.zig").Guid.initString("3051073C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMImplementation2 = &IID_IHTMLDOMImplementation2_Value;
pub const IHTMLDOMImplementation2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createDocumentType: fn(
            self: *const IHTMLDOMImplementation2,
            bstrQualifiedName: BSTR,
            pvarPublicId: *VARIANT,
            pvarSystemId: *VARIANT,
            newDocumentType: **IDOMDocumentType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createDocument: fn(
            self: *const IHTMLDOMImplementation2,
            pvarNS: *VARIANT,
            pvarTagName: *VARIANT,
            pDocumentType: *IDOMDocumentType,
            ppnewDocument: **IHTMLDocument7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createHTMLDocument: fn(
            self: *const IHTMLDOMImplementation2,
            bstrTitle: BSTR,
            ppnewDocument: **IHTMLDocument7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasFeature: fn(
            self: *const IHTMLDOMImplementation2,
            bstrfeature: BSTR,
            version: VARIANT,
            pfHasFeature: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation2_createDocumentType(self: *const T, bstrQualifiedName: BSTR, pvarPublicId: *VARIANT, pvarSystemId: *VARIANT, newDocumentType: **IDOMDocumentType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation2.VTable, self.vtable).createDocumentType(@ptrCast(*const IHTMLDOMImplementation2, self), bstrQualifiedName, pvarPublicId, pvarSystemId, newDocumentType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation2_createDocument(self: *const T, pvarNS: *VARIANT, pvarTagName: *VARIANT, pDocumentType: *IDOMDocumentType, ppnewDocument: **IHTMLDocument7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation2.VTable, self.vtable).createDocument(@ptrCast(*const IHTMLDOMImplementation2, self), pvarNS, pvarTagName, pDocumentType, ppnewDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation2_createHTMLDocument(self: *const T, bstrTitle: BSTR, ppnewDocument: **IHTMLDocument7) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation2.VTable, self.vtable).createHTMLDocument(@ptrCast(*const IHTMLDOMImplementation2, self), bstrTitle, ppnewDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMImplementation2_hasFeature(self: *const T, bstrfeature: BSTR, version: VARIANT, pfHasFeature: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMImplementation2.VTable, self.vtable).hasFeature(@ptrCast(*const IHTMLDOMImplementation2, self), bstrfeature, version, pfHasFeature);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDOMAttribute_Value = @import("../zig.zig").Guid.initString("3050F564-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDOMAttribute = &IID_DispHTMLDOMAttribute_Value;
pub const DispHTMLDOMAttribute = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDOMTextNode_Value = @import("../zig.zig").Guid.initString("3050F565-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDOMTextNode = &IID_DispHTMLDOMTextNode_Value;
pub const DispHTMLDOMTextNode = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDOMImplementation_Value = @import("../zig.zig").Guid.initString("3050F58F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDOMImplementation = &IID_DispHTMLDOMImplementation_Value;
pub const DispHTMLDOMImplementation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAttributeCollection_Value = @import("../zig.zig").Guid.initString("3050F4C3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAttributeCollection = &IID_IHTMLAttributeCollection_Value;
pub const IHTMLAttributeCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLAttributeCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLAttributeCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAttributeCollection,
            name: *VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAttributeCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLAttributeCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection_item(self: *const T, name: *VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLAttributeCollection, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAttributeCollection2_Value = @import("../zig.zig").Guid.initString("3050F80A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAttributeCollection2 = &IID_IHTMLAttributeCollection2_Value;
pub const IHTMLAttributeCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getNamedItem: fn(
            self: *const IHTMLAttributeCollection2,
            bstrName: BSTR,
            newretNode: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItem: fn(
            self: *const IHTMLAttributeCollection2,
            ppNode: *IHTMLDOMAttribute,
            newretNode: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItem: fn(
            self: *const IHTMLAttributeCollection2,
            bstrName: BSTR,
            newretNode: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection2_getNamedItem(self: *const T, bstrName: BSTR, newretNode: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection2.VTable, self.vtable).getNamedItem(@ptrCast(*const IHTMLAttributeCollection2, self), bstrName, newretNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection2_setNamedItem(self: *const T, ppNode: *IHTMLDOMAttribute, newretNode: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection2.VTable, self.vtable).setNamedItem(@ptrCast(*const IHTMLAttributeCollection2, self), ppNode, newretNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection2_removeNamedItem(self: *const T, bstrName: BSTR, newretNode: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection2.VTable, self.vtable).removeNamedItem(@ptrCast(*const IHTMLAttributeCollection2, self), bstrName, newretNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAttributeCollection4_Value = @import("../zig.zig").Guid.initString("305106FA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAttributeCollection4 = &IID_IHTMLAttributeCollection4_Value;
pub const IHTMLAttributeCollection4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getNamedItemNS: fn(
            self: *const IHTMLAttributeCollection4,
            pvarNS: *VARIANT,
            bstrName: BSTR,
            ppNodeOut: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItemNS: fn(
            self: *const IHTMLAttributeCollection4,
            pNodeIn: *IHTMLDOMAttribute2,
            ppNodeOut: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItemNS: fn(
            self: *const IHTMLAttributeCollection4,
            pvarNS: *VARIANT,
            bstrName: BSTR,
            ppNodeOut: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getNamedItem: fn(
            self: *const IHTMLAttributeCollection4,
            bstrName: BSTR,
            ppNodeOut: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setNamedItem: fn(
            self: *const IHTMLAttributeCollection4,
            pNodeIn: *IHTMLDOMAttribute2,
            ppNodeOut: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeNamedItem: fn(
            self: *const IHTMLAttributeCollection4,
            bstrName: BSTR,
            ppNodeOut: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAttributeCollection4,
            index: i32,
            ppNodeOut: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLAttributeCollection4,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_getNamedItemNS(self: *const T, pvarNS: *VARIANT, bstrName: BSTR, ppNodeOut: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).getNamedItemNS(@ptrCast(*const IHTMLAttributeCollection4, self), pvarNS, bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_setNamedItemNS(self: *const T, pNodeIn: *IHTMLDOMAttribute2, ppNodeOut: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).setNamedItemNS(@ptrCast(*const IHTMLAttributeCollection4, self), pNodeIn, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_removeNamedItemNS(self: *const T, pvarNS: *VARIANT, bstrName: BSTR, ppNodeOut: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).removeNamedItemNS(@ptrCast(*const IHTMLAttributeCollection4, self), pvarNS, bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_getNamedItem(self: *const T, bstrName: BSTR, ppNodeOut: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).getNamedItem(@ptrCast(*const IHTMLAttributeCollection4, self), bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_setNamedItem(self: *const T, pNodeIn: *IHTMLDOMAttribute2, ppNodeOut: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).setNamedItem(@ptrCast(*const IHTMLAttributeCollection4, self), pNodeIn, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_removeNamedItem(self: *const T, bstrName: BSTR, ppNodeOut: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).removeNamedItem(@ptrCast(*const IHTMLAttributeCollection4, self), bstrName, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_item(self: *const T, index: i32, ppNodeOut: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).item(@ptrCast(*const IHTMLAttributeCollection4, self), index, ppNodeOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAttributeCollection4_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAttributeCollection4.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAttributeCollection4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMChildrenCollection_Value = @import("../zig.zig").Guid.initString("3050F5AB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMChildrenCollection = &IID_IHTMLDOMChildrenCollection_Value;
pub const IHTMLDOMChildrenCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLDOMChildrenCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLDOMChildrenCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLDOMChildrenCollection,
            index: i32,
            ppItem: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMChildrenCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMChildrenCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLDOMChildrenCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMChildrenCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMChildrenCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLDOMChildrenCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMChildrenCollection_item(self: *const T, index: i32, ppItem: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMChildrenCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLDOMChildrenCollection, self), index, ppItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMChildrenCollection2_Value = @import("../zig.zig").Guid.initString("30510791-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMChildrenCollection2 = &IID_IHTMLDOMChildrenCollection2_Value;
pub const IHTMLDOMChildrenCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IHTMLDOMChildrenCollection2,
            index: i32,
            ppItem: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMChildrenCollection2_item(self: *const T, index: i32, ppItem: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMChildrenCollection2.VTable, self.vtable).item(@ptrCast(*const IHTMLDOMChildrenCollection2, self), index, ppItem);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAttributeCollection_Value = @import("../zig.zig").Guid.initString("3050F56C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLAttributeCollection = &IID_DispHTMLAttributeCollection_Value;
pub const DispHTMLAttributeCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispStaticNodeList_Value = @import("../zig.zig").Guid.initString("3050F59B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispStaticNodeList = &IID_DispStaticNodeList_Value;
pub const DispStaticNodeList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMChildrenCollection_Value = @import("../zig.zig").Guid.initString("3050F577-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMChildrenCollection = &IID_DispDOMChildrenCollection_Value;
pub const DispDOMChildrenCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLElementEvents4_Value = @import("../zig.zig").Guid.initString("3051075E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLElementEvents4 = &IID_HTMLElementEvents4_Value;
pub const HTMLElementEvents4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLElementEvents3_Value = @import("../zig.zig").Guid.initString("3050F59F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLElementEvents3 = &IID_HTMLElementEvents3_Value;
pub const HTMLElementEvents3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F60F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLElementEvents2 = &IID_HTMLElementEvents2_Value;
pub const HTMLElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLElementEvents_Value = @import("../zig.zig").Guid.initString("3050F33C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLElementEvents = &IID_HTMLElementEvents_Value;
pub const HTMLElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("305104BE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IRulesAppliedCollection = &IID_IRulesAppliedCollection_Value;
pub const IRulesAppliedCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IRulesAppliedCollection,
            index: i32,
            ppRulesApplied: **IRulesApplied,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IRulesAppliedCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_element: fn(
            self: *const IRulesAppliedCollection,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyInheritedFrom: fn(
            self: *const IRulesAppliedCollection,
            name: BSTR,
            ppRulesApplied: **IRulesApplied,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_propertyCount: fn(
            self: *const IRulesAppliedCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        property: fn(
            self: *const IRulesAppliedCollection,
            index: i32,
            pbstrProperty: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyInheritedTrace: fn(
            self: *const IRulesAppliedCollection,
            name: BSTR,
            index: i32,
            ppRulesApplied: **IRulesApplied,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyInheritedTraceLength: fn(
            self: *const IRulesAppliedCollection,
            name: BSTR,
            pLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_item(self: *const T, index: i32, ppRulesApplied: **IRulesApplied) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).item(@ptrCast(*const IRulesAppliedCollection, self), index, ppRulesApplied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).get_length(@ptrCast(*const IRulesAppliedCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_get_element(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).get_element(@ptrCast(*const IRulesAppliedCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_propertyInheritedFrom(self: *const T, name: BSTR, ppRulesApplied: **IRulesApplied) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).propertyInheritedFrom(@ptrCast(*const IRulesAppliedCollection, self), name, ppRulesApplied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_get_propertyCount(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).get_propertyCount(@ptrCast(*const IRulesAppliedCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_property(self: *const T, index: i32, pbstrProperty: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).property(@ptrCast(*const IRulesAppliedCollection, self), index, pbstrProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_propertyInheritedTrace(self: *const T, name: BSTR, index: i32, ppRulesApplied: **IRulesApplied) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).propertyInheritedTrace(@ptrCast(*const IRulesAppliedCollection, self), name, index, ppRulesApplied);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesAppliedCollection_propertyInheritedTraceLength(self: *const T, name: BSTR, pLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesAppliedCollection.VTable, self.vtable).propertyInheritedTraceLength(@ptrCast(*const IRulesAppliedCollection, self), name, pLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement3_Value = @import("../zig.zig").Guid.initString("3050F673-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElement3 = &IID_IHTMLElement3_Value;
pub const IHTMLElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        mergeAttributes: fn(
            self: *const IHTMLElement3,
            mergeThis: *IHTMLElement,
            pvarFlags: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isMultiLine: fn(
            self: *const IHTMLElement3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_canHaveHTML: fn(
            self: *const IHTMLElement3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onlayoutcomplete: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onlayoutcomplete: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onpage: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onpage: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_inflateBlock: fn(
            self: *const IHTMLElement3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_inflateBlock: fn(
            self: *const IHTMLElement3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforedeactivate: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforedeactivate: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setActive: fn(
            self: *const IHTMLElement3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_contentEditable: fn(
            self: *const IHTMLElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_contentEditable: fn(
            self: *const IHTMLElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isContentEditable: fn(
            self: *const IHTMLElement3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hideFocus: fn(
            self: *const IHTMLElement3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hideFocus: fn(
            self: *const IHTMLElement3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLElement3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLElement3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isDisabled: fn(
            self: *const IHTMLElement3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmove: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmove: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncontrolselect: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncontrolselect: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fireEvent: fn(
            self: *const IHTMLElement3,
            bstrEventName: BSTR,
            pvarEventObject: *VARIANT,
            pfCancelled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onresizestart: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onresizestart: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onresizeend: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onresizeend: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmovestart: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmovestart: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmoveend: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmoveend: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseenter: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseenter: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseleave: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseleave: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onactivate: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onactivate: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondeactivate: fn(
            self: *const IHTMLElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondeactivate: fn(
            self: *const IHTMLElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        dragDrop: fn(
            self: *const IHTMLElement3,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_glyphMode: fn(
            self: *const IHTMLElement3,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_mergeAttributes(self: *const T, mergeThis: *IHTMLElement, pvarFlags: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).mergeAttributes(@ptrCast(*const IHTMLElement3, self), mergeThis, pvarFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_isMultiLine(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_isMultiLine(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_canHaveHTML(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_canHaveHTML(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onlayoutcomplete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onlayoutcomplete(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onlayoutcomplete(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onlayoutcomplete(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onpage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onpage(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onpage(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onpage(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_inflateBlock(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_inflateBlock(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_inflateBlock(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_inflateBlock(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onbeforedeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onbeforedeactivate(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onbeforedeactivate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onbeforedeactivate(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_setActive(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).setActive(@ptrCast(*const IHTMLElement3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_contentEditable(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_contentEditable(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_contentEditable(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_contentEditable(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_isContentEditable(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_isContentEditable(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_hideFocus(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_hideFocus(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_hideFocus(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_hideFocus(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_isDisabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_isDisabled(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmove(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmove(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmove(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_oncontrolselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_oncontrolselect(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_oncontrolselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_oncontrolselect(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_fireEvent(self: *const T, bstrEventName: BSTR, pvarEventObject: *VARIANT, pfCancelled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).fireEvent(@ptrCast(*const IHTMLElement3, self), bstrEventName, pvarEventObject, pfCancelled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onresizestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onresizestart(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onresizestart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onresizestart(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onresizeend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onresizeend(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onresizeend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onresizeend(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmovestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmovestart(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmovestart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmovestart(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmoveend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmoveend(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmoveend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmoveend(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmouseenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmouseenter(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmouseenter(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmouseenter(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onmouseleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onmouseleave(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onmouseleave(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onmouseleave(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_onactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_onactivate(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_onactivate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_onactivate(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_put_ondeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).put_ondeactivate(@ptrCast(*const IHTMLElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_ondeactivate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_ondeactivate(@ptrCast(*const IHTMLElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_dragDrop(self: *const T, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).dragDrop(@ptrCast(*const IHTMLElement3, self), pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement3_get_glyphMode(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement3.VTable, self.vtable).get_glyphMode(@ptrCast(*const IHTMLElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement4_Value = @import("../zig.zig").Guid.initString("3050F80F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElement4 = &IID_IHTMLElement4_Value;
pub const IHTMLElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onmousewheel: fn(
            self: *const IHTMLElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmousewheel: fn(
            self: *const IHTMLElement4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        normalize: fn(
            self: *const IHTMLElement4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttributeNode: fn(
            self: *const IHTMLElement4,
            bstrname: BSTR,
            ppAttribute: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNode: fn(
            self: *const IHTMLElement4,
            pattr: *IHTMLDOMAttribute,
            ppretAttribute: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNode: fn(
            self: *const IHTMLElement4,
            pattr: *IHTMLDOMAttribute,
            ppretAttribute: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeactivate: fn(
            self: *const IHTMLElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeactivate: fn(
            self: *const IHTMLElement4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocusin: fn(
            self: *const IHTMLElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocusin: fn(
            self: *const IHTMLElement4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocusout: fn(
            self: *const IHTMLElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocusout: fn(
            self: *const IHTMLElement4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_put_onmousewheel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).put_onmousewheel(@ptrCast(*const IHTMLElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_get_onmousewheel(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).get_onmousewheel(@ptrCast(*const IHTMLElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_normalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).normalize(@ptrCast(*const IHTMLElement4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_getAttributeNode(self: *const T, bstrname: BSTR, ppAttribute: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).getAttributeNode(@ptrCast(*const IHTMLElement4, self), bstrname, ppAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_setAttributeNode(self: *const T, pattr: *IHTMLDOMAttribute, ppretAttribute: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).setAttributeNode(@ptrCast(*const IHTMLElement4, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_removeAttributeNode(self: *const T, pattr: *IHTMLDOMAttribute, ppretAttribute: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).removeAttributeNode(@ptrCast(*const IHTMLElement4, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_put_onbeforeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).put_onbeforeactivate(@ptrCast(*const IHTMLElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_get_onbeforeactivate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).get_onbeforeactivate(@ptrCast(*const IHTMLElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_put_onfocusin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).put_onfocusin(@ptrCast(*const IHTMLElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_get_onfocusin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).get_onfocusin(@ptrCast(*const IHTMLElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_put_onfocusout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).put_onfocusout(@ptrCast(*const IHTMLElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement4_get_onfocusout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement4.VTable, self.vtable).get_onfocusout(@ptrCast(*const IHTMLElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementSelector_Value = @import("../zig.zig").Guid.initString("30510463-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementSelector = &IID_IElementSelector_Value;
pub const IElementSelector = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        querySelector: fn(
            self: *const IElementSelector,
            v: BSTR,
            pel: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        querySelectorAll: fn(
            self: *const IElementSelector,
            v: BSTR,
            pel: **IHTMLDOMChildrenCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSelector_querySelector(self: *const T, v: BSTR, pel: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSelector.VTable, self.vtable).querySelector(@ptrCast(*const IElementSelector, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSelector_querySelectorAll(self: *const T, v: BSTR, pel: **IHTMLDOMChildrenCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSelector.VTable, self.vtable).querySelectorAll(@ptrCast(*const IElementSelector, self), v, pel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementRender_Value = @import("../zig.zig").Guid.initString("3050F669-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElementRender = &IID_IHTMLElementRender_Value;
pub const IHTMLElementRender = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        DrawToDC: fn(
            self: *const IHTMLElementRender,
            hDC: HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentPrinter: fn(
            self: *const IHTMLElementRender,
            bstrPrinterName: BSTR,
            hDC: HDC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementRender_DrawToDC(self: *const T, hDC: HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementRender.VTable, self.vtable).DrawToDC(@ptrCast(*const IHTMLElementRender, self), hDC);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementRender_SetDocumentPrinter(self: *const T, bstrPrinterName: BSTR, hDC: HDC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementRender.VTable, self.vtable).SetDocumentPrinter(@ptrCast(*const IHTMLElementRender, self), bstrPrinterName, hDC);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLUniqueName_Value = @import("../zig.zig").Guid.initString("3050F4D0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLUniqueName = &IID_IHTMLUniqueName_Value;
pub const IHTMLUniqueName = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_uniqueNumber: fn(
            self: *const IHTMLUniqueName,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_uniqueID: fn(
            self: *const IHTMLUniqueName,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUniqueName_get_uniqueNumber(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUniqueName.VTable, self.vtable).get_uniqueNumber(@ptrCast(*const IHTMLUniqueName, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUniqueName_get_uniqueID(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUniqueName.VTable, self.vtable).get_uniqueID(@ptrCast(*const IHTMLUniqueName, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement5_Value = @import("../zig.zig").Guid.initString("3051045D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElement5 = &IID_IHTMLElement5_Value;
pub const IHTMLElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getAttributeNode: fn(
            self: *const IHTMLElement5,
            bstrname: BSTR,
            ppretAttribute: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNode: fn(
            self: *const IHTMLElement5,
            pattr: *IHTMLDOMAttribute2,
            ppretAttribute: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNode: fn(
            self: *const IHTMLElement5,
            pattr: *IHTMLDOMAttribute2,
            ppretAttribute: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttribute: fn(
            self: *const IHTMLElement5,
            name: BSTR,
            pfHasAttribute: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_role: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_role: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaBusy: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaBusy: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaChecked: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaChecked: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaDisabled: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaDisabled: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaExpanded: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaExpanded: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaHaspopup: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaHaspopup: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaHidden: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaHidden: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaInvalid: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaInvalid: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaMultiselectable: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaMultiselectable: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaPressed: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaPressed: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaReadonly: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaReadonly: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaRequired: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaRequired: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaSecret: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaSecret: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaSelected: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaSelected: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLElement5,
            strAttributeName: BSTR,
            AttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLElement5,
            strAttributeName: BSTR,
            AttributeValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLElement5,
            strAttributeName: BSTR,
            pfSuccess: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_attributes: fn(
            self: *const IHTMLElement5,
            p: **IHTMLAttributeCollection3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaValuenow: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaValuenow: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaPosinset: fn(
            self: *const IHTMLElement5,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaPosinset: fn(
            self: *const IHTMLElement5,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaSetsize: fn(
            self: *const IHTMLElement5,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaSetsize: fn(
            self: *const IHTMLElement5,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaLevel: fn(
            self: *const IHTMLElement5,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaLevel: fn(
            self: *const IHTMLElement5,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaValuemin: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaValuemin: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaValuemax: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaValuemax: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaControls: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaControls: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaDescribedby: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaDescribedby: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaFlowto: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaFlowto: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaLabelledby: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaLabelledby: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaActivedescendant: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaActivedescendant: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaOwns: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaOwns: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLElement5,
            pfHasAttributes: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaLive: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaLive: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ariaRelevant: fn(
            self: *const IHTMLElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ariaRelevant: fn(
            self: *const IHTMLElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_getAttributeNode(self: *const T, bstrname: BSTR, ppretAttribute: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).getAttributeNode(@ptrCast(*const IHTMLElement5, self), bstrname, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_setAttributeNode(self: *const T, pattr: *IHTMLDOMAttribute2, ppretAttribute: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).setAttributeNode(@ptrCast(*const IHTMLElement5, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_removeAttributeNode(self: *const T, pattr: *IHTMLDOMAttribute2, ppretAttribute: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).removeAttributeNode(@ptrCast(*const IHTMLElement5, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_hasAttribute(self: *const T, name: BSTR, pfHasAttribute: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).hasAttribute(@ptrCast(*const IHTMLElement5, self), name, pfHasAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_role(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_role(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_role(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_role(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaBusy(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaBusy(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaBusy(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaBusy(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaChecked(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaChecked(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaChecked(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaChecked(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaDisabled(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaDisabled(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaDisabled(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaDisabled(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaExpanded(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaExpanded(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaExpanded(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaExpanded(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaHaspopup(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaHaspopup(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaHaspopup(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaHaspopup(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaHidden(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaHidden(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaHidden(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaHidden(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaInvalid(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaInvalid(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaInvalid(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaInvalid(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaMultiselectable(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaMultiselectable(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaMultiselectable(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaMultiselectable(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaPressed(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaPressed(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaPressed(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaPressed(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaReadonly(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaReadonly(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaReadonly(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaReadonly(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaRequired(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaRequired(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaRequired(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaRequired(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaSecret(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaSecret(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaSecret(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaSecret(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaSelected(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaSelected(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaSelected(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaSelected(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_getAttribute(self: *const T, strAttributeName: BSTR, AttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLElement5, self), strAttributeName, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_setAttribute(self: *const T, strAttributeName: BSTR, AttributeValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLElement5, self), strAttributeName, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_removeAttribute(self: *const T, strAttributeName: BSTR, pfSuccess: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLElement5, self), strAttributeName, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_attributes(self: *const T, p: **IHTMLAttributeCollection3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_attributes(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaValuenow(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaValuenow(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaValuenow(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaValuenow(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaPosinset(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaPosinset(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaPosinset(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaPosinset(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaSetsize(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaSetsize(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaSetsize(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaSetsize(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaLevel(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaLevel(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaLevel(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaLevel(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaValuemin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaValuemin(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaValuemin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaValuemin(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaValuemax(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaValuemax(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaValuemax(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaValuemax(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaControls(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaControls(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaControls(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaControls(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaDescribedby(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaDescribedby(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaDescribedby(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaDescribedby(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaFlowto(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaFlowto(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaFlowto(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaFlowto(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaLabelledby(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaLabelledby(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaLabelledby(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaLabelledby(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaActivedescendant(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaActivedescendant(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaActivedescendant(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaActivedescendant(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaOwns(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaOwns(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaOwns(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaOwns(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_hasAttributes(self: *const T, pfHasAttributes: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLElement5, self), pfHasAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaLive(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaLive(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaLive(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaLive(@ptrCast(*const IHTMLElement5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_put_ariaRelevant(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).put_ariaRelevant(@ptrCast(*const IHTMLElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement5_get_ariaRelevant(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement5.VTable, self.vtable).get_ariaRelevant(@ptrCast(*const IHTMLElement5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement6_Value = @import("../zig.zig").Guid.initString("305106F8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElement6 = &IID_IHTMLElement6_Value;
pub const IHTMLElement6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getAttributeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: *VARIANT,
            strAttributeName: BSTR,
            AttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: *VARIANT,
            strAttributeName: BSTR,
            pvarAttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: *VARIANT,
            strAttributeName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttributeNodeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: *VARIANT,
            bstrname: BSTR,
            ppretAttribute: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNodeNS: fn(
            self: *const IHTMLElement6,
            pattr: *IHTMLDOMAttribute2,
            ppretAttribute: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributeNS: fn(
            self: *const IHTMLElement6,
            pvarNS: *VARIANT,
            name: BSTR,
            pfHasAttribute: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLElement6,
            strAttributeName: BSTR,
            AttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLElement6,
            strAttributeName: BSTR,
            pvarAttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLElement6,
            strAttributeName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttributeNode: fn(
            self: *const IHTMLElement6,
            strAttributeName: BSTR,
            ppretAttribute: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttributeNode: fn(
            self: *const IHTMLElement6,
            pattr: *IHTMLDOMAttribute2,
            ppretAttribute: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttributeNode: fn(
            self: *const IHTMLElement6,
            pattr: *IHTMLDOMAttribute2,
            ppretAttribute: **IHTMLDOMAttribute2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttribute: fn(
            self: *const IHTMLElement6,
            name: BSTR,
            pfHasAttribute: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagNameNS: fn(
            self: *const IHTMLElement6,
            varNS: *VARIANT,
            bstrLocalName: BSTR,
            pelColl: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tagName: fn(
            self: *const IHTMLElement6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nodeName: fn(
            self: *const IHTMLElement6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByClassName: fn(
            self: *const IHTMLElement6,
            v: BSTR,
            pel: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msMatchesSelector: fn(
            self: *const IHTMLElement6,
            v: BSTR,
            pfMatches: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onabort: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onabort: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncanplay: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncanplay: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncanplaythrough: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncanplaythrough: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchange: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchange: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondurationchange: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondurationchange: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onemptied: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onemptied: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onended: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onended: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oninput: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oninput: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onloadeddata: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onloadeddata: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onloadedmetadata: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onloadedmetadata: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onloadstart: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onloadstart: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onpause: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onpause: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onplay: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onplay: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onplaying: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onplaying: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onprogress: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onprogress: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onratechange: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onratechange: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreset: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreset: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onseeked: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onseeked: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onseeking: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onseeking: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselect: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselect: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstalled: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstalled: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onsubmit: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onsubmit: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onsuspend: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onsuspend: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ontimeupdate: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ontimeupdate: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onvolumechange: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onvolumechange: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onwaiting: fn(
            self: *const IHTMLElement6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onwaiting: fn(
            self: *const IHTMLElement6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasAttributes: fn(
            self: *const IHTMLElement6,
            pfHasAttributes: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getAttributeNS(self: *const T, pvarNS: *VARIANT, strAttributeName: BSTR, AttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getAttributeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, strAttributeName, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_setAttributeNS(self: *const T, pvarNS: *VARIANT, strAttributeName: BSTR, pvarAttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).setAttributeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, strAttributeName, pvarAttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_removeAttributeNS(self: *const T, pvarNS: *VARIANT, strAttributeName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).removeAttributeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, strAttributeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getAttributeNodeNS(self: *const T, pvarNS: *VARIANT, bstrname: BSTR, ppretAttribute: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getAttributeNodeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, bstrname, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_setAttributeNodeNS(self: *const T, pattr: *IHTMLDOMAttribute2, ppretAttribute: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).setAttributeNodeNS(@ptrCast(*const IHTMLElement6, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_hasAttributeNS(self: *const T, pvarNS: *VARIANT, name: BSTR, pfHasAttribute: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).hasAttributeNS(@ptrCast(*const IHTMLElement6, self), pvarNS, name, pfHasAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getAttribute(self: *const T, strAttributeName: BSTR, AttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLElement6, self), strAttributeName, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_setAttribute(self: *const T, strAttributeName: BSTR, pvarAttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLElement6, self), strAttributeName, pvarAttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_removeAttribute(self: *const T, strAttributeName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLElement6, self), strAttributeName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getAttributeNode(self: *const T, strAttributeName: BSTR, ppretAttribute: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getAttributeNode(@ptrCast(*const IHTMLElement6, self), strAttributeName, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_setAttributeNode(self: *const T, pattr: *IHTMLDOMAttribute2, ppretAttribute: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).setAttributeNode(@ptrCast(*const IHTMLElement6, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_removeAttributeNode(self: *const T, pattr: *IHTMLDOMAttribute2, ppretAttribute: **IHTMLDOMAttribute2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).removeAttributeNode(@ptrCast(*const IHTMLElement6, self), pattr, ppretAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_hasAttribute(self: *const T, name: BSTR, pfHasAttribute: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).hasAttribute(@ptrCast(*const IHTMLElement6, self), name, pfHasAttribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getElementsByTagNameNS(self: *const T, varNS: *VARIANT, bstrLocalName: BSTR, pelColl: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getElementsByTagNameNS(@ptrCast(*const IHTMLElement6, self), varNS, bstrLocalName, pelColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_tagName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_tagName(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_nodeName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_nodeName(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_getElementsByClassName(self: *const T, v: BSTR, pel: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).getElementsByClassName(@ptrCast(*const IHTMLElement6, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_msMatchesSelector(self: *const T, v: BSTR, pfMatches: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).msMatchesSelector(@ptrCast(*const IHTMLElement6, self), v, pfMatches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onabort(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_oncanplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_oncanplay(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_oncanplay(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_oncanplay(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_oncanplaythrough(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_oncanplaythrough(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_oncanplaythrough(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_oncanplaythrough(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_ondurationchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_ondurationchange(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_ondurationchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_ondurationchange(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onemptied(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onemptied(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onemptied(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onemptied(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onended(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onended(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onended(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onended(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_oninput(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_oninput(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_oninput(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_oninput(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onloadeddata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onloadeddata(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onloadeddata(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onloadeddata(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onloadedmetadata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onloadedmetadata(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onloadedmetadata(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onloadedmetadata(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onloadstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onloadstart(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onloadstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onloadstart(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onpause(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onpause(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onpause(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onpause(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onplay(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onplay(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onplay(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onplaying(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onplaying(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onplaying(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onplaying(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onprogress(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onratechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onratechange(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onratechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onratechange(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onreset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onreset(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onreset(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onreset(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onseeked(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onseeked(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onseeked(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onseeked(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onseeking(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onseeking(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onseeking(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onseeking(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onstalled(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onstalled(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onstalled(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onstalled(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onsubmit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onsubmit(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onsubmit(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onsubmit(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onsuspend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onsuspend(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onsuspend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onsuspend(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_ontimeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_ontimeupdate(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_ontimeupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_ontimeupdate(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onvolumechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onvolumechange(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onvolumechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onvolumechange(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_put_onwaiting(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).put_onwaiting(@ptrCast(*const IHTMLElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_get_onwaiting(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).get_onwaiting(@ptrCast(*const IHTMLElement6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement6_hasAttributes(self: *const T, pfHasAttributes: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement6.VTable, self.vtable).hasAttributes(@ptrCast(*const IHTMLElement6, self), pfHasAttributes);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElement7_Value = @import("../zig.zig").Guid.initString("305107AA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElement7 = &IID_IHTMLElement7_Value;
pub const IHTMLElement7 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onmspointerdown: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerdown: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointermove: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointermove: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerup: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerup: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerover: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerover: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerout: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerout: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointercancel: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointercancel: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerhover: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerhover: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmslostpointercapture: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmslostpointercapture: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgotpointercapture: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgotpointercapture: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturestart: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturestart: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturechange: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturechange: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgestureend: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgestureend: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturehold: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturehold: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturetap: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturetap: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturedoubletap: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturedoubletap: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsinertiastart: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsinertiastart: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msSetPointerCapture: fn(
            self: *const IHTMLElement7,
            pointerId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msReleasePointerCapture: fn(
            self: *const IHTMLElement7,
            pointerId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmstransitionstart: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmstransitionstart: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmstransitionend: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmstransitionend: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsanimationstart: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsanimationstart: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsanimationend: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsanimationend: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsanimationiteration: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsanimationiteration: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oninvalid: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oninvalid: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_xmsAcceleratorKey: fn(
            self: *const IHTMLElement7,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_xmsAcceleratorKey: fn(
            self: *const IHTMLElement7,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_spellcheck: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_spellcheck: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsmanipulationstatechanged: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsmanipulationstatechanged: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncuechange: fn(
            self: *const IHTMLElement7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncuechange: fn(
            self: *const IHTMLElement7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerdown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerdown(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerdown(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerdown(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointermove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointermove(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointermove(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointermove(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerup(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerup(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerover(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerover(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerout(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerout(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointercancel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointercancel(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointercancel(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointercancel(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmspointerhover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmspointerhover(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmspointerhover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmspointerhover(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmslostpointercapture(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmslostpointercapture(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmslostpointercapture(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmslostpointercapture(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgotpointercapture(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgotpointercapture(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgotpointercapture(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgotpointercapture(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturestart(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturestart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturestart(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturechange(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturechange(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgestureend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgestureend(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgestureend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgestureend(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturehold(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturehold(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturehold(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturehold(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturetap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturetap(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturetap(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturetap(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsgesturedoubletap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsgesturedoubletap(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsgesturedoubletap(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsgesturedoubletap(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsinertiastart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsinertiastart(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsinertiastart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsinertiastart(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_msSetPointerCapture(self: *const T, pointerId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).msSetPointerCapture(@ptrCast(*const IHTMLElement7, self), pointerId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_msReleasePointerCapture(self: *const T, pointerId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).msReleasePointerCapture(@ptrCast(*const IHTMLElement7, self), pointerId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmstransitionstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmstransitionstart(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmstransitionstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmstransitionstart(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmstransitionend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmstransitionend(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmstransitionend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmstransitionend(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsanimationstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsanimationstart(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsanimationstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsanimationstart(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsanimationend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsanimationend(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsanimationend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsanimationend(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsanimationiteration(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsanimationiteration(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsanimationiteration(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsanimationiteration(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_oninvalid(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_oninvalid(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_oninvalid(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_oninvalid(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_xmsAcceleratorKey(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_xmsAcceleratorKey(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_xmsAcceleratorKey(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_xmsAcceleratorKey(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_spellcheck(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_spellcheck(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_spellcheck(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_spellcheck(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_onmsmanipulationstatechanged(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_onmsmanipulationstatechanged(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_onmsmanipulationstatechanged(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_onmsmanipulationstatechanged(@ptrCast(*const IHTMLElement7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_put_oncuechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).put_oncuechange(@ptrCast(*const IHTMLElement7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElement7_get_oncuechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElement7.VTable, self.vtable).get_oncuechange(@ptrCast(*const IHTMLElement7, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementAppliedStyles_Value = @import("../zig.zig").Guid.initString("305104BD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElementAppliedStyles = &IID_IHTMLElementAppliedStyles_Value;
pub const IHTMLElementAppliedStyles = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        msGetRulesApplied: fn(
            self: *const IHTMLElementAppliedStyles,
            ppRulesAppliedCollection: **IRulesAppliedCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msGetRulesAppliedWithAncestor: fn(
            self: *const IHTMLElementAppliedStyles,
            varContext: VARIANT,
            ppRulesAppliedCollection: **IRulesAppliedCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementAppliedStyles_msGetRulesApplied(self: *const T, ppRulesAppliedCollection: **IRulesAppliedCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementAppliedStyles.VTable, self.vtable).msGetRulesApplied(@ptrCast(*const IHTMLElementAppliedStyles, self), ppRulesAppliedCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementAppliedStyles_msGetRulesAppliedWithAncestor(self: *const T, varContext: VARIANT, ppRulesAppliedCollection: **IRulesAppliedCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementAppliedStyles.VTable, self.vtable).msGetRulesAppliedWithAncestor(@ptrCast(*const IHTMLElementAppliedStyles, self), varContext, ppRulesAppliedCollection);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementTraversal_Value = @import("../zig.zig").Guid.initString("30510736-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementTraversal = &IID_IElementTraversal_Value;
pub const IElementTraversal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_firstElementChild: fn(
            self: *const IElementTraversal,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lastElementChild: fn(
            self: *const IElementTraversal,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_previousElementSibling: fn(
            self: *const IElementTraversal,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nextElementSibling: fn(
            self: *const IElementTraversal,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_childElementCount: fn(
            self: *const IElementTraversal,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_firstElementChild(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_firstElementChild(@ptrCast(*const IElementTraversal, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_lastElementChild(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_lastElementChild(@ptrCast(*const IElementTraversal, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_previousElementSibling(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_previousElementSibling(@ptrCast(*const IElementTraversal, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_nextElementSibling(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_nextElementSibling(@ptrCast(*const IElementTraversal, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementTraversal_get_childElementCount(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementTraversal.VTable, self.vtable).get_childElementCount(@ptrCast(*const IElementTraversal, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDatabinding_Value = @import("../zig.zig").Guid.initString("3050F3F2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDatabinding = &IID_IHTMLDatabinding_Value;
pub const IHTMLDatabinding = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_dataFld: fn(
            self: *const IHTMLDatabinding,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dataFld: fn(
            self: *const IHTMLDatabinding,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dataSrc: fn(
            self: *const IHTMLDatabinding,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dataSrc: fn(
            self: *const IHTMLDatabinding,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dataFormatAs: fn(
            self: *const IHTMLDatabinding,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dataFormatAs: fn(
            self: *const IHTMLDatabinding,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_put_dataFld(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).put_dataFld(@ptrCast(*const IHTMLDatabinding, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_get_dataFld(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).get_dataFld(@ptrCast(*const IHTMLDatabinding, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_put_dataSrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).put_dataSrc(@ptrCast(*const IHTMLDatabinding, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_get_dataSrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).get_dataSrc(@ptrCast(*const IHTMLDatabinding, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_put_dataFormatAs(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).put_dataFormatAs(@ptrCast(*const IHTMLDatabinding, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDatabinding_get_dataFormatAs(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDatabinding.VTable, self.vtable).get_dataFormatAs(@ptrCast(*const IHTMLDatabinding, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument_Value = @import("../zig.zig").Guid.initString("626FC520-A41E-11CF-A731-00A0C9082637");
pub const IID_IHTMLDocument = &IID_IHTMLDocument_Value;
pub const IHTMLDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_Script: fn(
            self: *const IHTMLDocument,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument_get_Script(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument.VTable, self.vtable).get_Script(@ptrCast(*const IHTMLDocument, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementDefaults_Value = @import("../zig.zig").Guid.initString("3050F6C9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElementDefaults = &IID_IHTMLElementDefaults_Value;
pub const IHTMLElementDefaults = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_style: fn(
            self: *const IHTMLElementDefaults,
            p: **IHTMLStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_tabStop: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tabStop: fn(
            self: *const IHTMLElementDefaults,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_viewInheritStyle: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_viewInheritStyle: fn(
            self: *const IHTMLElementDefaults,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_viewMasterTab: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_viewMasterTab: fn(
            self: *const IHTMLElementDefaults,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollSegmentX: fn(
            self: *const IHTMLElementDefaults,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollSegmentX: fn(
            self: *const IHTMLElementDefaults,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollSegmentY: fn(
            self: *const IHTMLElementDefaults,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollSegmentY: fn(
            self: *const IHTMLElementDefaults,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_isMultiLine: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isMultiLine: fn(
            self: *const IHTMLElementDefaults,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_contentEditable: fn(
            self: *const IHTMLElementDefaults,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_contentEditable: fn(
            self: *const IHTMLElementDefaults,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_canHaveHTML: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_canHaveHTML: fn(
            self: *const IHTMLElementDefaults,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_viewLink: fn(
            self: *const IHTMLElementDefaults,
            v: *IHTMLDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_viewLink: fn(
            self: *const IHTMLElementDefaults,
            p: **IHTMLDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frozen: fn(
            self: *const IHTMLElementDefaults,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frozen: fn(
            self: *const IHTMLElementDefaults,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_style(self: *const T, p: **IHTMLStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_style(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_tabStop(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_tabStop(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_tabStop(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_tabStop(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_viewInheritStyle(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_viewInheritStyle(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_viewInheritStyle(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_viewInheritStyle(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_viewMasterTab(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_viewMasterTab(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_viewMasterTab(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_viewMasterTab(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_scrollSegmentX(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_scrollSegmentX(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_scrollSegmentX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_scrollSegmentX(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_scrollSegmentY(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_scrollSegmentY(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_scrollSegmentY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_scrollSegmentY(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_isMultiLine(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_isMultiLine(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_isMultiLine(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_isMultiLine(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_contentEditable(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_contentEditable(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_contentEditable(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_contentEditable(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_canHaveHTML(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_canHaveHTML(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_canHaveHTML(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_canHaveHTML(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_putref_viewLink(self: *const T, v: *IHTMLDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).putref_viewLink(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_viewLink(self: *const T, p: **IHTMLDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_viewLink(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_put_frozen(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).put_frozen(@ptrCast(*const IHTMLElementDefaults, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementDefaults_get_frozen(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementDefaults.VTable, self.vtable).get_frozen(@ptrCast(*const IHTMLElementDefaults, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDefaults_Value = @import("../zig.zig").Guid.initString("3050F58C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDefaults = &IID_DispHTMLDefaults_Value;
pub const DispHTMLDefaults = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCDefaultDispatch_Value = @import("../zig.zig").Guid.initString("3050F4FD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTCDefaultDispatch = &IID_IHTCDefaultDispatch_Value;
pub const IHTCDefaultDispatch = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_element: fn(
            self: *const IHTCDefaultDispatch,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createEventObject: fn(
            self: *const IHTCDefaultDispatch,
            eventObj: **IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaults: fn(
            self: *const IHTCDefaultDispatch,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_document: fn(
            self: *const IHTCDefaultDispatch,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDefaultDispatch_get_element(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDefaultDispatch.VTable, self.vtable).get_element(@ptrCast(*const IHTCDefaultDispatch, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDefaultDispatch_createEventObject(self: *const T, eventObj: **IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDefaultDispatch.VTable, self.vtable).createEventObject(@ptrCast(*const IHTCDefaultDispatch, self), eventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDefaultDispatch_get_defaults(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDefaultDispatch.VTable, self.vtable).get_defaults(@ptrCast(*const IHTCDefaultDispatch, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDefaultDispatch_get_document(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDefaultDispatch.VTable, self.vtable).get_document(@ptrCast(*const IHTCDefaultDispatch, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCPropertyBehavior_Value = @import("../zig.zig").Guid.initString("3050F5DF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTCPropertyBehavior = &IID_IHTCPropertyBehavior_Value;
pub const IHTCPropertyBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        fireChange: fn(
            self: *const IHTCPropertyBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTCPropertyBehavior,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTCPropertyBehavior,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCPropertyBehavior_fireChange(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCPropertyBehavior.VTable, self.vtable).fireChange(@ptrCast(*const IHTCPropertyBehavior, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCPropertyBehavior_put_value(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCPropertyBehavior.VTable, self.vtable).put_value(@ptrCast(*const IHTCPropertyBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCPropertyBehavior_get_value(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCPropertyBehavior.VTable, self.vtable).get_value(@ptrCast(*const IHTCPropertyBehavior, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCMethodBehavior_Value = @import("../zig.zig").Guid.initString("3050F631-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTCMethodBehavior = &IID_IHTCMethodBehavior_Value;
pub const IHTCMethodBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCEventBehavior_Value = @import("../zig.zig").Guid.initString("3050F4FF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTCEventBehavior = &IID_IHTCEventBehavior_Value;
pub const IHTCEventBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        fire: fn(
            self: *const IHTCEventBehavior,
            pvar: *IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCEventBehavior_fire(self: *const T, pvar: *IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCEventBehavior.VTable, self.vtable).fire(@ptrCast(*const IHTCEventBehavior, self), pvar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCAttachBehavior_Value = @import("../zig.zig").Guid.initString("3050F5F4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTCAttachBehavior = &IID_IHTCAttachBehavior_Value;
pub const IHTCAttachBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        fireEvent: fn(
            self: *const IHTCAttachBehavior,
            evt: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTCAttachBehavior,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCAttachBehavior_fireEvent(self: *const T, evt: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCAttachBehavior.VTable, self.vtable).fireEvent(@ptrCast(*const IHTCAttachBehavior, self), evt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCAttachBehavior_detachEvent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCAttachBehavior.VTable, self.vtable).detachEvent(@ptrCast(*const IHTCAttachBehavior, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCAttachBehavior2_Value = @import("../zig.zig").Guid.initString("3050F7EB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTCAttachBehavior2 = &IID_IHTCAttachBehavior2_Value;
pub const IHTCAttachBehavior2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        fireEvent: fn(
            self: *const IHTCAttachBehavior2,
            evt: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCAttachBehavior2_fireEvent(self: *const T, evt: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCAttachBehavior2.VTable, self.vtable).fireEvent(@ptrCast(*const IHTCAttachBehavior2, self), evt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTCDescBehavior_Value = @import("../zig.zig").Guid.initString("3050F5DC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTCDescBehavior = &IID_IHTCDescBehavior_Value;
pub const IHTCDescBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_urn: fn(
            self: *const IHTCDescBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTCDescBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDescBehavior_get_urn(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDescBehavior.VTable, self.vtable).get_urn(@ptrCast(*const IHTCDescBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTCDescBehavior_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTCDescBehavior.VTable, self.vtable).get_name(@ptrCast(*const IHTCDescBehavior, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCDefaultDispatch_Value = @import("../zig.zig").Guid.initString("3050F573-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTCDefaultDispatch = &IID_DispHTCDefaultDispatch_Value;
pub const DispHTCDefaultDispatch = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCPropertyBehavior_Value = @import("../zig.zig").Guid.initString("3050F57F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTCPropertyBehavior = &IID_DispHTCPropertyBehavior_Value;
pub const DispHTCPropertyBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCMethodBehavior_Value = @import("../zig.zig").Guid.initString("3050F587-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTCMethodBehavior = &IID_DispHTCMethodBehavior_Value;
pub const DispHTCMethodBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCEventBehavior_Value = @import("../zig.zig").Guid.initString("3050F574-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTCEventBehavior = &IID_DispHTCEventBehavior_Value;
pub const DispHTCEventBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCAttachBehavior_Value = @import("../zig.zig").Guid.initString("3050F583-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTCAttachBehavior = &IID_DispHTCAttachBehavior_Value;
pub const DispHTCAttachBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTCDescBehavior_Value = @import("../zig.zig").Guid.initString("3050F57E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTCDescBehavior = &IID_DispHTCDescBehavior_Value;
pub const DispHTCDescBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLUrnCollection_Value = @import("../zig.zig").Guid.initString("3050F5E2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLUrnCollection = &IID_IHTMLUrnCollection_Value;
pub const IHTMLUrnCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLUrnCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLUrnCollection,
            index: i32,
            ppUrn: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUrnCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUrnCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLUrnCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUrnCollection_item(self: *const T, index: i32, ppUrn: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUrnCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLUrnCollection, self), index, ppUrn);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLUrnCollection_Value = @import("../zig.zig").Guid.initString("3050F551-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLUrnCollection = &IID_DispHTMLUrnCollection_Value;
pub const DispHTMLUrnCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLGenericElement_Value = @import("../zig.zig").Guid.initString("3050F4B7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLGenericElement = &IID_IHTMLGenericElement_Value;
pub const IHTMLGenericElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_recordset: fn(
            self: *const IHTMLGenericElement,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        namedRecordset: fn(
            self: *const IHTMLGenericElement,
            dataMember: BSTR,
            hierarchy: *VARIANT,
            ppRecordset: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLGenericElement_get_recordset(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLGenericElement.VTable, self.vtable).get_recordset(@ptrCast(*const IHTMLGenericElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLGenericElement_namedRecordset(self: *const T, dataMember: BSTR, hierarchy: *VARIANT, ppRecordset: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLGenericElement.VTable, self.vtable).namedRecordset(@ptrCast(*const IHTMLGenericElement, self), dataMember, hierarchy, ppRecordset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLGenericElement_Value = @import("../zig.zig").Guid.initString("3050F563-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLGenericElement = &IID_DispHTMLGenericElement_Value;
pub const DispHTMLGenericElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRuleApplied_Value = @import("../zig.zig").Guid.initString("305104C1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetRuleApplied = &IID_IHTMLStyleSheetRuleApplied_Value;
pub const IHTMLStyleSheetRuleApplied = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_msSpecificity: fn(
            self: *const IHTMLStyleSheetRuleApplied,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msGetSpecificity: fn(
            self: *const IHTMLStyleSheetRuleApplied,
            index: i32,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRuleApplied_get_msSpecificity(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRuleApplied.VTable, self.vtable).get_msSpecificity(@ptrCast(*const IHTMLStyleSheetRuleApplied, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRuleApplied_msGetSpecificity(self: *const T, index: i32, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRuleApplied.VTable, self.vtable).msGetSpecificity(@ptrCast(*const IHTMLStyleSheetRuleApplied, self), index, p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRule2_Value = @import("../zig.zig").Guid.initString("305106FD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetRule2 = &IID_IHTMLStyleSheetRule2_Value;
pub const IHTMLStyleSheetRule2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_selectorText: fn(
            self: *const IHTMLStyleSheetRule2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectorText: fn(
            self: *const IHTMLStyleSheetRule2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule2_put_selectorText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule2.VTable, self.vtable).put_selectorText(@ptrCast(*const IHTMLStyleSheetRule2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRule2_get_selectorText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRule2.VTable, self.vtable).get_selectorText(@ptrCast(*const IHTMLStyleSheetRule2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRulesCollection2_Value = @import("../zig.zig").Guid.initString("305106E8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetRulesCollection2 = &IID_IHTMLStyleSheetRulesCollection2_Value;
pub const IHTMLStyleSheetRulesCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLStyleSheetRulesCollection2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLStyleSheetRulesCollection2,
            index: i32,
            ppHTMLCSSRule: **IHTMLCSSRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesCollection2_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesCollection2.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetRulesCollection2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesCollection2_item(self: *const T, index: i32, ppHTMLCSSRule: **IHTMLCSSRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesCollection2.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetRulesCollection2, self), index, ppHTMLCSSRule);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetRule_Value = @import("../zig.zig").Guid.initString("3050F50E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleSheetRule = &IID_DispHTMLStyleSheetRule_Value;
pub const DispHTMLStyleSheetRule = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetRulesCollection_Value = @import("../zig.zig").Guid.initString("3050F52F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleSheetRulesCollection = &IID_DispHTMLStyleSheetRulesCollection_Value;
pub const DispHTMLStyleSheetRulesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetPage_Value = @import("../zig.zig").Guid.initString("3050F7EE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetPage = &IID_IHTMLStyleSheetPage_Value;
pub const IHTMLStyleSheetPage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_selector: fn(
            self: *const IHTMLStyleSheetPage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pseudoClass: fn(
            self: *const IHTMLStyleSheetPage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage_get_selector(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage.VTable, self.vtable).get_selector(@ptrCast(*const IHTMLStyleSheetPage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage_get_pseudoClass(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage.VTable, self.vtable).get_pseudoClass(@ptrCast(*const IHTMLStyleSheetPage, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetPage2_Value = @import("../zig.zig").Guid.initString("305106ED-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetPage2 = &IID_IHTMLStyleSheetPage2_Value;
pub const IHTMLStyleSheetPage2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_selectorText: fn(
            self: *const IHTMLStyleSheetPage2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectorText: fn(
            self: *const IHTMLStyleSheetPage2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_style: fn(
            self: *const IHTMLStyleSheetPage2,
            p: **IHTMLRuleStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage2_put_selectorText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage2.VTable, self.vtable).put_selectorText(@ptrCast(*const IHTMLStyleSheetPage2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage2_get_selectorText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage2.VTable, self.vtable).get_selectorText(@ptrCast(*const IHTMLStyleSheetPage2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPage2_get_style(self: *const T, p: **IHTMLRuleStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPage2.VTable, self.vtable).get_style(@ptrCast(*const IHTMLStyleSheetPage2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetPagesCollection_Value = @import("../zig.zig").Guid.initString("3050F7F0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetPagesCollection = &IID_IHTMLStyleSheetPagesCollection_Value;
pub const IHTMLStyleSheetPagesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLStyleSheetPagesCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLStyleSheetPagesCollection,
            index: i32,
            ppHTMLStyleSheetPage: **IHTMLStyleSheetPage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPagesCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPagesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetPagesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetPagesCollection_item(self: *const T, index: i32, ppHTMLStyleSheetPage: **IHTMLStyleSheetPage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetPagesCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetPagesCollection, self), index, ppHTMLStyleSheetPage);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetPage_Value = @import("../zig.zig").Guid.initString("3050F540-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleSheetPage = &IID_DispHTMLStyleSheetPage_Value;
pub const DispHTMLStyleSheetPage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetPagesCollection_Value = @import("../zig.zig").Guid.initString("3050F543-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleSheetPagesCollection = &IID_DispHTMLStyleSheetPagesCollection_Value;
pub const DispHTMLStyleSheetPagesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetsCollection_Value = @import("../zig.zig").Guid.initString("3050F37E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetsCollection = &IID_IHTMLStyleSheetsCollection_Value;
pub const IHTMLStyleSheetsCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLStyleSheetsCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLStyleSheetsCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLStyleSheetsCollection,
            pvarIndex: *VARIANT,
            pvarResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetsCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetsCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetsCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetsCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetsCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLStyleSheetsCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetsCollection_item(self: *const T, pvarIndex: *VARIANT, pvarResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetsCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetsCollection, self), pvarIndex, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheet2_Value = @import("../zig.zig").Guid.initString("3050F3D1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheet2 = &IID_IHTMLStyleSheet2_Value;
pub const IHTMLStyleSheet2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_pages: fn(
            self: *const IHTMLStyleSheet2,
            p: **IHTMLStyleSheetPagesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addPageRule: fn(
            self: *const IHTMLStyleSheet2,
            bstrSelector: BSTR,
            bstrStyle: BSTR,
            lIndex: i32,
            plNewIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet2_get_pages(self: *const T, p: **IHTMLStyleSheetPagesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet2.VTable, self.vtable).get_pages(@ptrCast(*const IHTMLStyleSheet2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet2_addPageRule(self: *const T, bstrSelector: BSTR, bstrStyle: BSTR, lIndex: i32, plNewIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet2.VTable, self.vtable).addPageRule(@ptrCast(*const IHTMLStyleSheet2, self), bstrSelector, bstrStyle, lIndex, plNewIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheet3_Value = @import("../zig.zig").Guid.initString("30510496-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheet3 = &IID_IHTMLStyleSheet3_Value;
pub const IHTMLStyleSheet3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_href: fn(
            self: *const IHTMLStyleSheet3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLStyleSheet3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isAlternate: fn(
            self: *const IHTMLStyleSheet3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isPrefAlternate: fn(
            self: *const IHTMLStyleSheet3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet3_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet3.VTable, self.vtable).put_href(@ptrCast(*const IHTMLStyleSheet3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet3_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet3.VTable, self.vtable).get_href(@ptrCast(*const IHTMLStyleSheet3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet3_get_isAlternate(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet3.VTable, self.vtable).get_isAlternate(@ptrCast(*const IHTMLStyleSheet3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet3_get_isPrefAlternate(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet3.VTable, self.vtable).get_isPrefAlternate(@ptrCast(*const IHTMLStyleSheet3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheet4_Value = @import("../zig.zig").Guid.initString("305106F4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheet4 = &IID_IHTMLStyleSheet4_Value;
pub const IHTMLStyleSheet4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLStyleSheet4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLStyleSheet4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_title: fn(
            self: *const IHTMLStyleSheet4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ownerNode: fn(
            self: *const IHTMLStyleSheet4,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ownerRule: fn(
            self: *const IHTMLStyleSheet4,
            p: **IHTMLCSSRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cssRules: fn(
            self: *const IHTMLStyleSheet4,
            p: **IHTMLStyleSheetRulesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_media: fn(
            self: *const IHTMLStyleSheet4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRule: fn(
            self: *const IHTMLStyleSheet4,
            bstrRule: BSTR,
            lIndex: i32,
            plNewIndex: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRule: fn(
            self: *const IHTMLStyleSheet4,
            lIndex: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_type(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_href(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_href(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_title(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_title(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_ownerNode(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_ownerNode(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_ownerRule(self: *const T, p: **IHTMLCSSRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_ownerRule(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_cssRules(self: *const T, p: **IHTMLStyleSheetRulesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_cssRules(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_get_media(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).get_media(@ptrCast(*const IHTMLStyleSheet4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_insertRule(self: *const T, bstrRule: BSTR, lIndex: i32, plNewIndex: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).insertRule(@ptrCast(*const IHTMLStyleSheet4, self), bstrRule, lIndex, plNewIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheet4_deleteRule(self: *const T, lIndex: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheet4.VTable, self.vtable).deleteRule(@ptrCast(*const IHTMLStyleSheet4, self), lIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheet_Value = @import("../zig.zig").Guid.initString("3050F58D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleSheet = &IID_DispHTMLStyleSheet_Value;
pub const DispHTMLStyleSheet = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetsCollection2_Value = @import("../zig.zig").Guid.initString("305106E7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetsCollection2 = &IID_IHTMLStyleSheetsCollection2_Value;
pub const IHTMLStyleSheetsCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IHTMLStyleSheetsCollection2,
            index: i32,
            pvarResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetsCollection2_item(self: *const T, index: i32, pvarResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetsCollection2.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetsCollection2, self), index, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetsCollection_Value = @import("../zig.zig").Guid.initString("3050F547-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleSheetsCollection = &IID_DispHTMLStyleSheetsCollection_Value;
pub const DispHTMLStyleSheetsCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLLinkElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F61D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLLinkElementEvents2 = &IID_HTMLLinkElementEvents2_Value;
pub const HTMLLinkElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLLinkElementEvents_Value = @import("../zig.zig").Guid.initString("3050F3CC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLLinkElementEvents = &IID_HTMLLinkElementEvents_Value;
pub const HTMLLinkElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement_Value = @import("../zig.zig").Guid.initString("3050F205-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLinkElement = &IID_IHTMLLinkElement_Value;
pub const IHTMLLinkElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_href: fn(
            self: *const IHTMLLinkElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLLinkElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rel: fn(
            self: *const IHTMLLinkElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rel: fn(
            self: *const IHTMLLinkElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rev: fn(
            self: *const IHTMLLinkElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rev: fn(
            self: *const IHTMLLinkElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLLinkElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLLinkElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLLinkElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLLinkElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLLinkElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLLinkElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLLinkElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLLinkElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLLinkElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_styleSheet: fn(
            self: *const IHTMLLinkElement,
            p: **IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLLinkElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLLinkElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_media: fn(
            self: *const IHTMLLinkElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_media: fn(
            self: *const IHTMLLinkElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_href(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_rel(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_rel(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_rel(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_rel(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_rev(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_rev(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_rev(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_rev(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_readyState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_styleSheet(self: *const T, p: **IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_styleSheet(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLLinkElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_put_media(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).put_media(@ptrCast(*const IHTMLLinkElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement_get_media(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement.VTable, self.vtable).get_media(@ptrCast(*const IHTMLLinkElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement2_Value = @import("../zig.zig").Guid.initString("3050F4E5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLinkElement2 = &IID_IHTMLLinkElement2_Value;
pub const IHTMLLinkElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_target: fn(
            self: *const IHTMLLinkElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_target: fn(
            self: *const IHTMLLinkElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement2_put_target(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement2.VTable, self.vtable).put_target(@ptrCast(*const IHTMLLinkElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement2_get_target(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement2.VTable, self.vtable).get_target(@ptrCast(*const IHTMLLinkElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement3_Value = @import("../zig.zig").Guid.initString("3050F81E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLinkElement3 = &IID_IHTMLLinkElement3_Value;
pub const IHTMLLinkElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_charset: fn(
            self: *const IHTMLLinkElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_charset: fn(
            self: *const IHTMLLinkElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hreflang: fn(
            self: *const IHTMLLinkElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hreflang: fn(
            self: *const IHTMLLinkElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement3_put_charset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement3.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLLinkElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement3_get_charset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement3.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLLinkElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement3_put_hreflang(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement3.VTable, self.vtable).put_hreflang(@ptrCast(*const IHTMLLinkElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement3_get_hreflang(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement3.VTable, self.vtable).get_hreflang(@ptrCast(*const IHTMLLinkElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement4_Value = @import("../zig.zig").Guid.initString("3051043A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLinkElement4 = &IID_IHTMLLinkElement4_Value;
pub const IHTMLLinkElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_href: fn(
            self: *const IHTMLLinkElement4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLLinkElement4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement4_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement4.VTable, self.vtable).put_href(@ptrCast(*const IHTMLLinkElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement4_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement4.VTable, self.vtable).get_href(@ptrCast(*const IHTMLLinkElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLinkElement5_Value = @import("../zig.zig").Guid.initString("30510726-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLinkElement5 = &IID_IHTMLLinkElement5_Value;
pub const IHTMLLinkElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_sheet: fn(
            self: *const IHTMLLinkElement5,
            p: **IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLinkElement5_get_sheet(self: *const T, p: **IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLinkElement5.VTable, self.vtable).get_sheet(@ptrCast(*const IHTMLLinkElement5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLinkElement_Value = @import("../zig.zig").Guid.initString("3050F524-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLLinkElement = &IID_DispHTMLLinkElement_Value;
pub const DispHTMLLinkElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTxtRange_Value = @import("../zig.zig").Guid.initString("3050F220-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTxtRange = &IID_IHTMLTxtRange_Value;
pub const IHTMLTxtRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_htmlText: fn(
            self: *const IHTMLTxtRange,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_text: fn(
            self: *const IHTMLTxtRange,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_text: fn(
            self: *const IHTMLTxtRange,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        parentElement: fn(
            self: *const IHTMLTxtRange,
            parent: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        duplicate: fn(
            self: *const IHTMLTxtRange,
            Duplicate: **IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        inRange: fn(
            self: *const IHTMLTxtRange,
            Range: *IHTMLTxtRange,
            InRange: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isEqual: fn(
            self: *const IHTMLTxtRange,
            Range: *IHTMLTxtRange,
            IsEqual: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollIntoView: fn(
            self: *const IHTMLTxtRange,
            fStart: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapse: fn(
            self: *const IHTMLTxtRange,
            Start: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        expand: fn(
            self: *const IHTMLTxtRange,
            Unit: BSTR,
            Success: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        move: fn(
            self: *const IHTMLTxtRange,
            Unit: BSTR,
            Count: i32,
            ActualCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveStart: fn(
            self: *const IHTMLTxtRange,
            Unit: BSTR,
            Count: i32,
            ActualCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveEnd: fn(
            self: *const IHTMLTxtRange,
            Unit: BSTR,
            Count: i32,
            ActualCount: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pasteHTML: fn(
            self: *const IHTMLTxtRange,
            html: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveToElementText: fn(
            self: *const IHTMLTxtRange,
            element: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setEndPoint: fn(
            self: *const IHTMLTxtRange,
            how: BSTR,
            SourceRange: *IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        compareEndPoints: fn(
            self: *const IHTMLTxtRange,
            how: BSTR,
            SourceRange: *IHTMLTxtRange,
            ret: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        findText: fn(
            self: *const IHTMLTxtRange,
            String: BSTR,
            count: i32,
            Flags: i32,
            Success: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveToPoint: fn(
            self: *const IHTMLTxtRange,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBookmark: fn(
            self: *const IHTMLTxtRange,
            Boolmark: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveToBookmark: fn(
            self: *const IHTMLTxtRange,
            Bookmark: BSTR,
            Success: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandSupported: fn(
            self: *const IHTMLTxtRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandEnabled: fn(
            self: *const IHTMLTxtRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandState: fn(
            self: *const IHTMLTxtRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandIndeterm: fn(
            self: *const IHTMLTxtRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandText: fn(
            self: *const IHTMLTxtRange,
            cmdID: BSTR,
            pcmdText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandValue: fn(
            self: *const IHTMLTxtRange,
            cmdID: BSTR,
            pcmdValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommand: fn(
            self: *const IHTMLTxtRange,
            cmdID: BSTR,
            showUI: i16,
            value: VARIANT,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommandShowHelp: fn(
            self: *const IHTMLTxtRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_get_htmlText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).get_htmlText(@ptrCast(*const IHTMLTxtRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_put_text(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).put_text(@ptrCast(*const IHTMLTxtRange, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_get_text(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).get_text(@ptrCast(*const IHTMLTxtRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_parentElement(self: *const T, parent: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).parentElement(@ptrCast(*const IHTMLTxtRange, self), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_duplicate(self: *const T, Duplicate: **IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).duplicate(@ptrCast(*const IHTMLTxtRange, self), Duplicate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_inRange(self: *const T, Range: *IHTMLTxtRange, InRange: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).inRange(@ptrCast(*const IHTMLTxtRange, self), Range, InRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_isEqual(self: *const T, Range: *IHTMLTxtRange, IsEqual: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).isEqual(@ptrCast(*const IHTMLTxtRange, self), Range, IsEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_scrollIntoView(self: *const T, fStart: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).scrollIntoView(@ptrCast(*const IHTMLTxtRange, self), fStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_collapse(self: *const T, Start: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).collapse(@ptrCast(*const IHTMLTxtRange, self), Start);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_expand(self: *const T, Unit: BSTR, Success: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).expand(@ptrCast(*const IHTMLTxtRange, self), Unit, Success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_move(self: *const T, Unit: BSTR, Count: i32, ActualCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).move(@ptrCast(*const IHTMLTxtRange, self), Unit, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveStart(self: *const T, Unit: BSTR, Count: i32, ActualCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveStart(@ptrCast(*const IHTMLTxtRange, self), Unit, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveEnd(self: *const T, Unit: BSTR, Count: i32, ActualCount: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveEnd(@ptrCast(*const IHTMLTxtRange, self), Unit, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).select(@ptrCast(*const IHTMLTxtRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_pasteHTML(self: *const T, html: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).pasteHTML(@ptrCast(*const IHTMLTxtRange, self), html);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveToElementText(self: *const T, element: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveToElementText(@ptrCast(*const IHTMLTxtRange, self), element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_setEndPoint(self: *const T, how: BSTR, SourceRange: *IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).setEndPoint(@ptrCast(*const IHTMLTxtRange, self), how, SourceRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_compareEndPoints(self: *const T, how: BSTR, SourceRange: *IHTMLTxtRange, ret: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).compareEndPoints(@ptrCast(*const IHTMLTxtRange, self), how, SourceRange, ret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_findText(self: *const T, String: BSTR, count: i32, Flags: i32, Success: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).findText(@ptrCast(*const IHTMLTxtRange, self), String, count, Flags, Success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveToPoint(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveToPoint(@ptrCast(*const IHTMLTxtRange, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_getBookmark(self: *const T, Boolmark: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).getBookmark(@ptrCast(*const IHTMLTxtRange, self), Boolmark);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_moveToBookmark(self: *const T, Bookmark: BSTR, Success: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).moveToBookmark(@ptrCast(*const IHTMLTxtRange, self), Bookmark, Success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandSupported(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandSupported(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandEnabled(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandEnabled(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandState(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandState(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandIndeterm(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandIndeterm(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandText(self: *const T, cmdID: BSTR, pcmdText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandText(@ptrCast(*const IHTMLTxtRange, self), cmdID, pcmdText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_queryCommandValue(self: *const T, cmdID: BSTR, pcmdValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).queryCommandValue(@ptrCast(*const IHTMLTxtRange, self), cmdID, pcmdValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_execCommand(self: *const T, cmdID: BSTR, showUI: i16, value: VARIANT, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).execCommand(@ptrCast(*const IHTMLTxtRange, self), cmdID, showUI, value, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRange_execCommandShowHelp(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRange.VTable, self.vtable).execCommandShowHelp(@ptrCast(*const IHTMLTxtRange, self), cmdID, pfRet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextRangeMetrics_Value = @import("../zig.zig").Guid.initString("3050F40B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTextRangeMetrics = &IID_IHTMLTextRangeMetrics_Value;
pub const IHTMLTextRangeMetrics = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_offsetTop: fn(
            self: *const IHTMLTextRangeMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetLeft: fn(
            self: *const IHTMLTextRangeMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boundingTop: fn(
            self: *const IHTMLTextRangeMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boundingLeft: fn(
            self: *const IHTMLTextRangeMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boundingWidth: fn(
            self: *const IHTMLTextRangeMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boundingHeight: fn(
            self: *const IHTMLTextRangeMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_offsetTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_offsetTop(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_offsetLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_offsetLeft(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_boundingTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_boundingTop(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_boundingLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_boundingLeft(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_boundingWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_boundingWidth(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics_get_boundingHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics.VTable, self.vtable).get_boundingHeight(@ptrCast(*const IHTMLTextRangeMetrics, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextRangeMetrics2_Value = @import("../zig.zig").Guid.initString("3050F4A6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTextRangeMetrics2 = &IID_IHTMLTextRangeMetrics2_Value;
pub const IHTMLTextRangeMetrics2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getClientRects: fn(
            self: *const IHTMLTextRangeMetrics2,
            pRectCol: **IHTMLRectCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBoundingClientRect: fn(
            self: *const IHTMLTextRangeMetrics2,
            pRect: **IHTMLRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics2_getClientRects(self: *const T, pRectCol: **IHTMLRectCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics2.VTable, self.vtable).getClientRects(@ptrCast(*const IHTMLTextRangeMetrics2, self), pRectCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextRangeMetrics2_getBoundingClientRect(self: *const T, pRect: **IHTMLRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextRangeMetrics2.VTable, self.vtable).getBoundingClientRect(@ptrCast(*const IHTMLTextRangeMetrics2, self), pRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTxtRangeCollection_Value = @import("../zig.zig").Guid.initString("3050F7ED-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTxtRangeCollection = &IID_IHTMLTxtRangeCollection_Value;
pub const IHTMLTxtRangeCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLTxtRangeCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLTxtRangeCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLTxtRangeCollection,
            pvarIndex: *VARIANT,
            pvarResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRangeCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRangeCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLTxtRangeCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRangeCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRangeCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLTxtRangeCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTxtRangeCollection_item(self: *const T, pvarIndex: *VARIANT, pvarResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTxtRangeCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLTxtRangeCollection, self), pvarIndex, pvarResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMRange_Value = @import("../zig.zig").Guid.initString("305104AE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMRange = &IID_IHTMLDOMRange_Value;
pub const IHTMLDOMRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_startContainer: fn(
            self: *const IHTMLDOMRange,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_startOffset: fn(
            self: *const IHTMLDOMRange,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_endContainer: fn(
            self: *const IHTMLDOMRange,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_endOffset: fn(
            self: *const IHTMLDOMRange,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_collapsed: fn(
            self: *const IHTMLDOMRange,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_commonAncestorContainer: fn(
            self: *const IHTMLDOMRange,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setStart: fn(
            self: *const IHTMLDOMRange,
            refNode: *IDispatch,
            offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setEnd: fn(
            self: *const IHTMLDOMRange,
            refNode: *IDispatch,
            offset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setStartBefore: fn(
            self: *const IHTMLDOMRange,
            refNode: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setStartAfter: fn(
            self: *const IHTMLDOMRange,
            refNode: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setEndBefore: fn(
            self: *const IHTMLDOMRange,
            refNode: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setEndAfter: fn(
            self: *const IHTMLDOMRange,
            refNode: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapse: fn(
            self: *const IHTMLDOMRange,
            toStart: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectNode: fn(
            self: *const IHTMLDOMRange,
            refNode: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectNodeContents: fn(
            self: *const IHTMLDOMRange,
            refNode: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        compareBoundaryPoints: fn(
            self: *const IHTMLDOMRange,
            how: i16,
            sourceRange: *IDispatch,
            compareResult: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteContents: fn(
            self: *const IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        extractContents: fn(
            self: *const IHTMLDOMRange,
            ppDocumentFragment: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneContents: fn(
            self: *const IHTMLDOMRange,
            ppDocumentFragment: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertNode: fn(
            self: *const IHTMLDOMRange,
            newNode: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        surroundContents: fn(
            self: *const IHTMLDOMRange,
            newParent: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        cloneRange: fn(
            self: *const IHTMLDOMRange,
            ppClonedRange: **IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLDOMRange,
            pRangeString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detach: fn(
            self: *const IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getClientRects: fn(
            self: *const IHTMLDOMRange,
            ppRectCol: **IHTMLRectCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBoundingClientRect: fn(
            self: *const IHTMLDOMRange,
            ppRect: **IHTMLRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_startContainer(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_startContainer(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_startOffset(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_startOffset(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_endContainer(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_endContainer(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_endOffset(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_endOffset(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_collapsed(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_collapsed(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_get_commonAncestorContainer(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).get_commonAncestorContainer(@ptrCast(*const IHTMLDOMRange, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setStart(self: *const T, refNode: *IDispatch, offset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setStart(@ptrCast(*const IHTMLDOMRange, self), refNode, offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setEnd(self: *const T, refNode: *IDispatch, offset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setEnd(@ptrCast(*const IHTMLDOMRange, self), refNode, offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setStartBefore(self: *const T, refNode: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setStartBefore(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setStartAfter(self: *const T, refNode: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setStartAfter(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setEndBefore(self: *const T, refNode: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setEndBefore(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_setEndAfter(self: *const T, refNode: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).setEndAfter(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_collapse(self: *const T, toStart: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).collapse(@ptrCast(*const IHTMLDOMRange, self), toStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_selectNode(self: *const T, refNode: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).selectNode(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_selectNodeContents(self: *const T, refNode: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).selectNodeContents(@ptrCast(*const IHTMLDOMRange, self), refNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_compareBoundaryPoints(self: *const T, how: i16, sourceRange: *IDispatch, compareResult: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).compareBoundaryPoints(@ptrCast(*const IHTMLDOMRange, self), how, sourceRange, compareResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_deleteContents(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).deleteContents(@ptrCast(*const IHTMLDOMRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_extractContents(self: *const T, ppDocumentFragment: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).extractContents(@ptrCast(*const IHTMLDOMRange, self), ppDocumentFragment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_cloneContents(self: *const T, ppDocumentFragment: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).cloneContents(@ptrCast(*const IHTMLDOMRange, self), ppDocumentFragment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_insertNode(self: *const T, newNode: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).insertNode(@ptrCast(*const IHTMLDOMRange, self), newNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_surroundContents(self: *const T, newParent: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).surroundContents(@ptrCast(*const IHTMLDOMRange, self), newParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_cloneRange(self: *const T, ppClonedRange: **IHTMLDOMRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).cloneRange(@ptrCast(*const IHTMLDOMRange, self), ppClonedRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_toString(self: *const T, pRangeString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).toString(@ptrCast(*const IHTMLDOMRange, self), pRangeString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).detach(@ptrCast(*const IHTMLDOMRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_getClientRects(self: *const T, ppRectCol: **IHTMLRectCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).getClientRects(@ptrCast(*const IHTMLDOMRange, self), ppRectCol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMRange_getBoundingClientRect(self: *const T, ppRect: **IHTMLRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMRange.VTable, self.vtable).getBoundingClientRect(@ptrCast(*const IHTMLDOMRange, self), ppRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDOMRange_Value = @import("../zig.zig").Guid.initString("3050F5A3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDOMRange = &IID_DispHTMLDOMRange_Value;
pub const DispHTMLDOMRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLFormElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F614-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLFormElementEvents2 = &IID_HTMLFormElementEvents2_Value;
pub const HTMLFormElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLFormElementEvents_Value = @import("../zig.zig").Guid.initString("3050F364-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLFormElementEvents = &IID_HTMLFormElementEvents_Value;
pub const HTMLFormElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFormElement_Value = @import("../zig.zig").Guid.initString("3050F1F7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFormElement = &IID_IHTMLFormElement_Value;
pub const IHTMLFormElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_action: fn(
            self: *const IHTMLFormElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_action: fn(
            self: *const IHTMLFormElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dir: fn(
            self: *const IHTMLFormElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dir: fn(
            self: *const IHTMLFormElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_encoding: fn(
            self: *const IHTMLFormElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_encoding: fn(
            self: *const IHTMLFormElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_method: fn(
            self: *const IHTMLFormElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_method: fn(
            self: *const IHTMLFormElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_elements: fn(
            self: *const IHTMLFormElement,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_target: fn(
            self: *const IHTMLFormElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_target: fn(
            self: *const IHTMLFormElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLFormElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLFormElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onsubmit: fn(
            self: *const IHTMLFormElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onsubmit: fn(
            self: *const IHTMLFormElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreset: fn(
            self: *const IHTMLFormElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreset: fn(
            self: *const IHTMLFormElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        submit: fn(
            self: *const IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reset: fn(
            self: *const IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_length: fn(
            self: *const IHTMLFormElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLFormElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLFormElement,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLFormElement,
            name: VARIANT,
            index: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        tags: fn(
            self: *const IHTMLFormElement,
            tagName: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_action(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_action(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_action(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_action(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_dir(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_dir(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_dir(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_dir(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_encoding(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_encoding(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_encoding(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_encoding(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_method(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_method(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_method(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_method(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_elements(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_elements(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_target(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_target(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_target(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_target(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_onsubmit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_onsubmit(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_onsubmit(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_onsubmit(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_onreset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_onreset(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_onreset(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_onreset(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_submit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).submit(@ptrCast(*const IHTMLFormElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).reset(@ptrCast(*const IHTMLFormElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).put_length(@ptrCast(*const IHTMLFormElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLFormElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_item(self: *const T, name: VARIANT, index: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).item(@ptrCast(*const IHTMLFormElement, self), name, index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement_tags(self: *const T, tagName: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement.VTable, self.vtable).tags(@ptrCast(*const IHTMLFormElement, self), tagName, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFormElement2_Value = @import("../zig.zig").Guid.initString("3050F4F6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFormElement2 = &IID_IHTMLFormElement2_Value;
pub const IHTMLFormElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_acceptCharset: fn(
            self: *const IHTMLFormElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_acceptCharset: fn(
            self: *const IHTMLFormElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        urns: fn(
            self: *const IHTMLFormElement2,
            urn: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement2_put_acceptCharset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement2.VTable, self.vtable).put_acceptCharset(@ptrCast(*const IHTMLFormElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement2_get_acceptCharset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement2.VTable, self.vtable).get_acceptCharset(@ptrCast(*const IHTMLFormElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement2_urns(self: *const T, urn: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement2.VTable, self.vtable).urns(@ptrCast(*const IHTMLFormElement2, self), urn, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFormElement3_Value = @import("../zig.zig").Guid.initString("3050F836-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFormElement3 = &IID_IHTMLFormElement3_Value;
pub const IHTMLFormElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedItem: fn(
            self: *const IHTMLFormElement3,
            name: BSTR,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement3_namedItem(self: *const T, name: BSTR, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement3.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLFormElement3, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSubmitData_Value = @import("../zig.zig").Guid.initString("3050F645-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSubmitData = &IID_IHTMLSubmitData_Value;
pub const IHTMLSubmitData = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        appendNameValuePair: fn(
            self: *const IHTMLSubmitData,
            name: BSTR,
            value: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendNameFilePair: fn(
            self: *const IHTMLSubmitData,
            name: BSTR,
            filename: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItemSeparator: fn(
            self: *const IHTMLSubmitData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSubmitData_appendNameValuePair(self: *const T, name: BSTR, value: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSubmitData.VTable, self.vtable).appendNameValuePair(@ptrCast(*const IHTMLSubmitData, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSubmitData_appendNameFilePair(self: *const T, name: BSTR, filename: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSubmitData.VTable, self.vtable).appendNameFilePair(@ptrCast(*const IHTMLSubmitData, self), name, filename);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSubmitData_appendItemSeparator(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSubmitData.VTable, self.vtable).appendItemSeparator(@ptrCast(*const IHTMLSubmitData, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFormElement4_Value = @import("../zig.zig").Guid.initString("3051042C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFormElement4 = &IID_IHTMLFormElement4_Value;
pub const IHTMLFormElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_action: fn(
            self: *const IHTMLFormElement4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_action: fn(
            self: *const IHTMLFormElement4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement4_put_action(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement4.VTable, self.vtable).put_action(@ptrCast(*const IHTMLFormElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFormElement4_get_action(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFormElement4.VTable, self.vtable).get_action(@ptrCast(*const IHTMLFormElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFormElement_Value = @import("../zig.zig").Guid.initString("3050F510-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLFormElement = &IID_DispHTMLFormElement_Value;
pub const DispHTMLFormElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLControlElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F612-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLControlElementEvents2 = &IID_HTMLControlElementEvents2_Value;
pub const HTMLControlElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLControlElementEvents_Value = @import("../zig.zig").Guid.initString("3050F4EA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLControlElementEvents = &IID_HTMLControlElementEvents_Value;
pub const HTMLControlElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLControlElement_Value = @import("../zig.zig").Guid.initString("3050F4E9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLControlElement = &IID_IHTMLControlElement_Value;
pub const IHTMLControlElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_tabIndex: fn(
            self: *const IHTMLControlElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tabIndex: fn(
            self: *const IHTMLControlElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLControlElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_accessKey: fn(
            self: *const IHTMLControlElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accessKey: fn(
            self: *const IHTMLControlElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onblur: fn(
            self: *const IHTMLControlElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onblur: fn(
            self: *const IHTMLControlElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocus: fn(
            self: *const IHTMLControlElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocus: fn(
            self: *const IHTMLControlElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onresize: fn(
            self: *const IHTMLControlElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onresize: fn(
            self: *const IHTMLControlElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLControlElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addFilter: fn(
            self: *const IHTMLControlElement,
            pUnk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeFilter: fn(
            self: *const IHTMLControlElement,
            pUnk: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientHeight: fn(
            self: *const IHTMLControlElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientWidth: fn(
            self: *const IHTMLControlElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientTop: fn(
            self: *const IHTMLControlElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientLeft: fn(
            self: *const IHTMLControlElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_tabIndex(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_tabIndex(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_tabIndex(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_tabIndex(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).focus(@ptrCast(*const IHTMLControlElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_accessKey(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_accessKey(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_accessKey(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_accessKey(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_onblur(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_onfocus(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_put_onresize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).put_onresize(@ptrCast(*const IHTMLControlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_onresize(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_onresize(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).blur(@ptrCast(*const IHTMLControlElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_addFilter(self: *const T, pUnk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).addFilter(@ptrCast(*const IHTMLControlElement, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_removeFilter(self: *const T, pUnk: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).removeFilter(@ptrCast(*const IHTMLControlElement, self), pUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_clientHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_clientHeight(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_clientWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_clientWidth(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_clientTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_clientTop(@ptrCast(*const IHTMLControlElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlElement_get_clientLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlElement.VTable, self.vtable).get_clientLeft(@ptrCast(*const IHTMLControlElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextElement_Value = @import("../zig.zig").Guid.initString("3050F218-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTextElement = &IID_IHTMLTextElement_Value;
pub const IHTMLTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTextElement_Value = @import("../zig.zig").Guid.initString("3050F537-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTextElement = &IID_DispHTMLTextElement_Value;
pub const DispHTMLTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLTextContainerEvents2_Value = @import("../zig.zig").Guid.initString("3050F624-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLTextContainerEvents2 = &IID_HTMLTextContainerEvents2_Value;
pub const HTMLTextContainerEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLTextContainerEvents_Value = @import("../zig.zig").Guid.initString("1FF6AA72-5842-11CF-A707-00AA00C0098D");
pub const IID_HTMLTextContainerEvents = &IID_HTMLTextContainerEvents_Value;
pub const HTMLTextContainerEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextContainer_Value = @import("../zig.zig").Guid.initString("3050F230-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTextContainer = &IID_IHTMLTextContainer_Value;
pub const IHTMLTextContainer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createControlRange: fn(
            self: *const IHTMLTextContainer,
            range: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollHeight: fn(
            self: *const IHTMLTextContainer,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollWidth: fn(
            self: *const IHTMLTextContainer,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollTop: fn(
            self: *const IHTMLTextContainer,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollTop: fn(
            self: *const IHTMLTextContainer,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollLeft: fn(
            self: *const IHTMLTextContainer,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollLeft: fn(
            self: *const IHTMLTextContainer,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onscroll: fn(
            self: *const IHTMLTextContainer,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onscroll: fn(
            self: *const IHTMLTextContainer,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_createControlRange(self: *const T, range: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).createControlRange(@ptrCast(*const IHTMLTextContainer, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_scrollHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_scrollHeight(@ptrCast(*const IHTMLTextContainer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_scrollWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_scrollWidth(@ptrCast(*const IHTMLTextContainer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_put_scrollTop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).put_scrollTop(@ptrCast(*const IHTMLTextContainer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_scrollTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_scrollTop(@ptrCast(*const IHTMLTextContainer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_put_scrollLeft(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).put_scrollLeft(@ptrCast(*const IHTMLTextContainer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_scrollLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_scrollLeft(@ptrCast(*const IHTMLTextContainer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_put_onscroll(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).put_onscroll(@ptrCast(*const IHTMLTextContainer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextContainer_get_onscroll(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextContainer.VTable, self.vtable).get_onscroll(@ptrCast(*const IHTMLTextContainer, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLControlRange_Value = @import("../zig.zig").Guid.initString("3050F29C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLControlRange = &IID_IHTMLControlRange_Value;
pub const IHTMLControlRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        select: fn(
            self: *const IHTMLControlRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        add: fn(
            self: *const IHTMLControlRange,
            item: *IHTMLControlElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        remove: fn(
            self: *const IHTMLControlRange,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLControlRange,
            index: i32,
            pdisp: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollIntoView: fn(
            self: *const IHTMLControlRange,
            varargStart: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandSupported: fn(
            self: *const IHTMLControlRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandEnabled: fn(
            self: *const IHTMLControlRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandState: fn(
            self: *const IHTMLControlRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandIndeterm: fn(
            self: *const IHTMLControlRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandText: fn(
            self: *const IHTMLControlRange,
            cmdID: BSTR,
            pcmdText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandValue: fn(
            self: *const IHTMLControlRange,
            cmdID: BSTR,
            pcmdValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommand: fn(
            self: *const IHTMLControlRange,
            cmdID: BSTR,
            showUI: i16,
            value: VARIANT,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommandShowHelp: fn(
            self: *const IHTMLControlRange,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        commonParentElement: fn(
            self: *const IHTMLControlRange,
            parent: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLControlRange,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).select(@ptrCast(*const IHTMLControlRange, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_add(self: *const T, item: *IHTMLControlElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).add(@ptrCast(*const IHTMLControlRange, self), item);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_remove(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).remove(@ptrCast(*const IHTMLControlRange, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_item(self: *const T, index: i32, pdisp: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).item(@ptrCast(*const IHTMLControlRange, self), index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_scrollIntoView(self: *const T, varargStart: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).scrollIntoView(@ptrCast(*const IHTMLControlRange, self), varargStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandSupported(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandSupported(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandEnabled(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandEnabled(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandState(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandState(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandIndeterm(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandIndeterm(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandText(self: *const T, cmdID: BSTR, pcmdText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandText(@ptrCast(*const IHTMLControlRange, self), cmdID, pcmdText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_queryCommandValue(self: *const T, cmdID: BSTR, pcmdValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).queryCommandValue(@ptrCast(*const IHTMLControlRange, self), cmdID, pcmdValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_execCommand(self: *const T, cmdID: BSTR, showUI: i16, value: VARIANT, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).execCommand(@ptrCast(*const IHTMLControlRange, self), cmdID, showUI, value, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_execCommandShowHelp(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).execCommandShowHelp(@ptrCast(*const IHTMLControlRange, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_commonParentElement(self: *const T, parent: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).commonParentElement(@ptrCast(*const IHTMLControlRange, self), parent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange.VTable, self.vtable).get_length(@ptrCast(*const IHTMLControlRange, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLControlRange2_Value = @import("../zig.zig").Guid.initString("3050F65E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLControlRange2 = &IID_IHTMLControlRange2_Value;
pub const IHTMLControlRange2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addElement: fn(
            self: *const IHTMLControlRange2,
            item: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLControlRange2_addElement(self: *const T, item: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLControlRange2.VTable, self.vtable).addElement(@ptrCast(*const IHTMLControlRange2, self), item);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLImgEvents2_Value = @import("../zig.zig").Guid.initString("3050F616-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLImgEvents2 = &IID_HTMLImgEvents2_Value;
pub const HTMLImgEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLImgEvents_Value = @import("../zig.zig").Guid.initString("3050F25B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLImgEvents = &IID_HTMLImgEvents_Value;
pub const HTMLImgEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImgElement_Value = @import("../zig.zig").Guid.initString("3050F240-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLImgElement = &IID_IHTMLImgElement_Value;
pub const IHTMLImgElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_isMap: fn(
            self: *const IHTMLImgElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isMap: fn(
            self: *const IHTMLImgElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_useMap: fn(
            self: *const IHTMLImgElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_useMap: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_mimeType: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileSize: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileCreatedDate: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileModifiedDate: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileUpdatedDate: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_protocol: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nameProp: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLImgElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vspace: fn(
            self: *const IHTMLImgElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vspace: fn(
            self: *const IHTMLImgElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hspace: fn(
            self: *const IHTMLImgElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hspace: fn(
            self: *const IHTMLImgElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alt: fn(
            self: *const IHTMLImgElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alt: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_src: fn(
            self: *const IHTMLImgElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lowsrc: fn(
            self: *const IHTMLImgElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lowsrc: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vrml: fn(
            self: *const IHTMLImgElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vrml: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dynsrc: fn(
            self: *const IHTMLImgElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dynsrc: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_complete: fn(
            self: *const IHTMLImgElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_loop: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_loop: fn(
            self: *const IHTMLImgElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_align: fn(
            self: *const IHTMLImgElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLImgElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLImgElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onabort: fn(
            self: *const IHTMLImgElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onabort: fn(
            self: *const IHTMLImgElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLImgElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLImgElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLImgElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLImgElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLImgElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_start: fn(
            self: *const IHTMLImgElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_start: fn(
            self: *const IHTMLImgElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_isMap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_isMap(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_isMap(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_isMap(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_useMap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_useMap(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_useMap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_useMap(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_mimeType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_mimeType(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_fileSize(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_fileSize(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_fileCreatedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_fileCreatedDate(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_fileModifiedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_fileModifiedDate(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_fileUpdatedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_fileUpdatedDate(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_protocol(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_nameProp(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_nameProp(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_border(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_border(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_border(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_vspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_hspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_alt(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_alt(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_lowsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_lowsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_vrml(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_vrml(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_dynsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_dynsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_readyState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_complete(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_complete(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_loop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_loop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_onabort(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_width(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_height(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_put_start(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).put_start(@ptrCast(*const IHTMLImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement_get_start(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement.VTable, self.vtable).get_start(@ptrCast(*const IHTMLImgElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImgElement2_Value = @import("../zig.zig").Guid.initString("3050F826-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLImgElement2 = &IID_IHTMLImgElement2_Value;
pub const IHTMLImgElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_longDesc: fn(
            self: *const IHTMLImgElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_longDesc: fn(
            self: *const IHTMLImgElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement2_put_longDesc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement2.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLImgElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement2_get_longDesc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement2.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLImgElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImgElement3_Value = @import("../zig.zig").Guid.initString("30510434-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLImgElement3 = &IID_IHTMLImgElement3_Value;
pub const IHTMLImgElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_longDesc: fn(
            self: *const IHTMLImgElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_longDesc: fn(
            self: *const IHTMLImgElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vrml: fn(
            self: *const IHTMLImgElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vrml: fn(
            self: *const IHTMLImgElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lowsrc: fn(
            self: *const IHTMLImgElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lowsrc: fn(
            self: *const IHTMLImgElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dynsrc: fn(
            self: *const IHTMLImgElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dynsrc: fn(
            self: *const IHTMLImgElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_put_longDesc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLImgElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_get_longDesc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLImgElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_put_vrml(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLImgElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_get_vrml(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLImgElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_put_lowsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLImgElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_get_lowsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLImgElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_put_dynsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLImgElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement3_get_dynsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement3.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLImgElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImgElement4_Value = @import("../zig.zig").Guid.initString("305107F6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLImgElement4 = &IID_IHTMLImgElement4_Value;
pub const IHTMLImgElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_naturalWidth: fn(
            self: *const IHTMLImgElement4,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_naturalHeight: fn(
            self: *const IHTMLImgElement4,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement4_get_naturalWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement4.VTable, self.vtable).get_naturalWidth(@ptrCast(*const IHTMLImgElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImgElement4_get_naturalHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImgElement4.VTable, self.vtable).get_naturalHeight(@ptrCast(*const IHTMLImgElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMSImgElement_Value = @import("../zig.zig").Guid.initString("30510793-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMSImgElement = &IID_IHTMLMSImgElement_Value;
pub const IHTMLMSImgElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_msPlayToDisabled: fn(
            self: *const IHTMLMSImgElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msPlayToDisabled: fn(
            self: *const IHTMLMSImgElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msPlayToPrimary: fn(
            self: *const IHTMLMSImgElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msPlayToPrimary: fn(
            self: *const IHTMLMSImgElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSImgElement_put_msPlayToDisabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSImgElement.VTable, self.vtable).put_msPlayToDisabled(@ptrCast(*const IHTMLMSImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSImgElement_get_msPlayToDisabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSImgElement.VTable, self.vtable).get_msPlayToDisabled(@ptrCast(*const IHTMLMSImgElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSImgElement_put_msPlayToPrimary(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSImgElement.VTable, self.vtable).put_msPlayToPrimary(@ptrCast(*const IHTMLMSImgElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSImgElement_get_msPlayToPrimary(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSImgElement.VTable, self.vtable).get_msPlayToPrimary(@ptrCast(*const IHTMLMSImgElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLImageElementFactory_Value = @import("../zig.zig").Guid.initString("3050F38E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLImageElementFactory = &IID_IHTMLImageElementFactory_Value;
pub const IHTMLImageElementFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLImageElementFactory,
            width: VARIANT,
            height: VARIANT,
            __MIDL__IHTMLImageElementFactory0000: **IHTMLImgElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLImageElementFactory_create(self: *const T, width: VARIANT, height: VARIANT, __MIDL__IHTMLImageElementFactory0000: **IHTMLImgElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLImageElementFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLImageElementFactory, self), width, height, __MIDL__IHTMLImageElementFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLImg_Value = @import("../zig.zig").Guid.initString("3050F51C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLImg = &IID_DispHTMLImg_Value;
pub const DispHTMLImg = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement_Value = @import("../zig.zig").Guid.initString("3050F1D8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBodyElement = &IID_IHTMLBodyElement_Value;
pub const IHTMLBodyElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_background: fn(
            self: *const IHTMLBodyElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_background: fn(
            self: *const IHTMLBodyElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bgProperties: fn(
            self: *const IHTMLBodyElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bgProperties: fn(
            self: *const IHTMLBodyElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_leftMargin: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_leftMargin: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_topMargin: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_topMargin: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rightMargin: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rightMargin: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bottomMargin: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bottomMargin: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_noWrap: fn(
            self: *const IHTMLBodyElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_noWrap: fn(
            self: *const IHTMLBodyElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bgColor: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bgColor: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_text: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_text: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_link: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_link: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vLink: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vLink: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_aLink: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_aLink: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onunload: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onunload: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scroll: fn(
            self: *const IHTMLBodyElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scroll: fn(
            self: *const IHTMLBodyElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselect: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselect: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeunload: fn(
            self: *const IHTMLBodyElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeunload: fn(
            self: *const IHTMLBodyElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLBodyElement,
            range: **IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_background(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_background(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_background(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_background(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_bgProperties(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_bgProperties(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_bgProperties(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_bgProperties(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_leftMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_leftMargin(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_leftMargin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_leftMargin(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_topMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_topMargin(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_topMargin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_topMargin(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_rightMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_rightMargin(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_rightMargin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_rightMargin(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_bottomMargin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_bottomMargin(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_bottomMargin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_bottomMargin(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_noWrap(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_bgColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_text(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_text(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_link(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_link(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_link(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_link(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_vLink(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_vLink(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_vLink(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_vLink(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_aLink(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_aLink(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_aLink(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_aLink(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_onunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_onunload(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_onunload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_onunload(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_scroll(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_scroll(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_scroll(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_scroll(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_onselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_put_onbeforeunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).put_onbeforeunload(@ptrCast(*const IHTMLBodyElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_get_onbeforeunload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).get_onbeforeunload(@ptrCast(*const IHTMLBodyElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement_createTextRange(self: *const T, range: **IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLBodyElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement2_Value = @import("../zig.zig").Guid.initString("3050F5C5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBodyElement2 = &IID_IHTMLBodyElement2_Value;
pub const IHTMLBodyElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onbeforeprint: fn(
            self: *const IHTMLBodyElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeprint: fn(
            self: *const IHTMLBodyElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onafterprint: fn(
            self: *const IHTMLBodyElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onafterprint: fn(
            self: *const IHTMLBodyElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement2_put_onbeforeprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement2.VTable, self.vtable).put_onbeforeprint(@ptrCast(*const IHTMLBodyElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement2_get_onbeforeprint(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement2.VTable, self.vtable).get_onbeforeprint(@ptrCast(*const IHTMLBodyElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement2_put_onafterprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement2.VTable, self.vtable).put_onafterprint(@ptrCast(*const IHTMLBodyElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement2_get_onafterprint(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement2.VTable, self.vtable).get_onafterprint(@ptrCast(*const IHTMLBodyElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement3_Value = @import("../zig.zig").Guid.initString("30510422-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBodyElement3 = &IID_IHTMLBodyElement3_Value;
pub const IHTMLBodyElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_background: fn(
            self: *const IHTMLBodyElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_background: fn(
            self: *const IHTMLBodyElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ononline: fn(
            self: *const IHTMLBodyElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ononline: fn(
            self: *const IHTMLBodyElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onoffline: fn(
            self: *const IHTMLBodyElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onoffline: fn(
            self: *const IHTMLBodyElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onhashchange: fn(
            self: *const IHTMLBodyElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onhashchange: fn(
            self: *const IHTMLBodyElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_put_background(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).put_background(@ptrCast(*const IHTMLBodyElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_get_background(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).get_background(@ptrCast(*const IHTMLBodyElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_put_ononline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).put_ononline(@ptrCast(*const IHTMLBodyElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_get_ononline(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).get_ononline(@ptrCast(*const IHTMLBodyElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_put_onoffline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).put_onoffline(@ptrCast(*const IHTMLBodyElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_get_onoffline(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).get_onoffline(@ptrCast(*const IHTMLBodyElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_put_onhashchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).put_onhashchange(@ptrCast(*const IHTMLBodyElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement3_get_onhashchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement3.VTable, self.vtable).get_onhashchange(@ptrCast(*const IHTMLBodyElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement4_Value = @import("../zig.zig").Guid.initString("30510795-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBodyElement4 = &IID_IHTMLBodyElement4_Value;
pub const IHTMLBodyElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onmessage: fn(
            self: *const IHTMLBodyElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmessage: fn(
            self: *const IHTMLBodyElement4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstorage: fn(
            self: *const IHTMLBodyElement4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstorage: fn(
            self: *const IHTMLBodyElement4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement4_put_onmessage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement4.VTable, self.vtable).put_onmessage(@ptrCast(*const IHTMLBodyElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement4_get_onmessage(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement4.VTable, self.vtable).get_onmessage(@ptrCast(*const IHTMLBodyElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement4_put_onstorage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement4.VTable, self.vtable).put_onstorage(@ptrCast(*const IHTMLBodyElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement4_get_onstorage(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement4.VTable, self.vtable).get_onstorage(@ptrCast(*const IHTMLBodyElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBodyElement5_Value = @import("../zig.zig").Guid.initString("30510822-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBodyElement5 = &IID_IHTMLBodyElement5_Value;
pub const IHTMLBodyElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onpopstate: fn(
            self: *const IHTMLBodyElement5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onpopstate: fn(
            self: *const IHTMLBodyElement5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement5_put_onpopstate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement5.VTable, self.vtable).put_onpopstate(@ptrCast(*const IHTMLBodyElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBodyElement5_get_onpopstate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBodyElement5.VTable, self.vtable).get_onpopstate(@ptrCast(*const IHTMLBodyElement5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBody_Value = @import("../zig.zig").Guid.initString("3050F507-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLBody = &IID_DispHTMLBody_Value;
pub const DispHTMLBody = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFontElement_Value = @import("../zig.zig").Guid.initString("3050F1D9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFontElement = &IID_IHTMLFontElement_Value;
pub const IHTMLFontElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_color: fn(
            self: *const IHTMLFontElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_color: fn(
            self: *const IHTMLFontElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_face: fn(
            self: *const IHTMLFontElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_face: fn(
            self: *const IHTMLFontElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_size: fn(
            self: *const IHTMLFontElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_size: fn(
            self: *const IHTMLFontElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).put_color(@ptrCast(*const IHTMLFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_get_color(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).get_color(@ptrCast(*const IHTMLFontElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_put_face(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).put_face(@ptrCast(*const IHTMLFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_get_face(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).get_face(@ptrCast(*const IHTMLFontElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_put_size(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontElement_get_size(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLFontElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFontElement_Value = @import("../zig.zig").Guid.initString("3050F512-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLFontElement = &IID_DispHTMLFontElement_Value;
pub const DispHTMLFontElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLAnchorEvents2_Value = @import("../zig.zig").Guid.initString("3050F610-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLAnchorEvents2 = &IID_HTMLAnchorEvents2_Value;
pub const HTMLAnchorEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLAnchorEvents_Value = @import("../zig.zig").Guid.initString("3050F29D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLAnchorEvents = &IID_HTMLAnchorEvents_Value;
pub const HTMLAnchorEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAnchorElement_Value = @import("../zig.zig").Guid.initString("3050F1DA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAnchorElement = &IID_IHTMLAnchorElement_Value;
pub const IHTMLAnchorElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_href: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_target: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_target: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rel: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rel: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rev: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rev: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_urn: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_urn: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Methods: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Methods: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_host: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_host: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hostname: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hostname: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pathname: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pathname: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_port: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_port: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_protocol: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_protocol: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_search: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_search: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hash: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hash: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onblur: fn(
            self: *const IHTMLAnchorElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onblur: fn(
            self: *const IHTMLAnchorElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocus: fn(
            self: *const IHTMLAnchorElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocus: fn(
            self: *const IHTMLAnchorElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_accessKey: fn(
            self: *const IHTMLAnchorElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accessKey: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_protocolLong: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_mimeType: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nameProp: fn(
            self: *const IHTMLAnchorElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_tabIndex: fn(
            self: *const IHTMLAnchorElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tabIndex: fn(
            self: *const IHTMLAnchorElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLAnchorElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLAnchorElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_href(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_target(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_target(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_target(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_target(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_rel(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_rel(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_rel(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_rel(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_rev(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_rev(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_rev(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_rev(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_urn(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_urn(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_urn(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_urn(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_Methods(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_Methods(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_Methods(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_Methods(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_host(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_host(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_host(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_host(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_hostname(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_hostname(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_hostname(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_hostname(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_pathname(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_pathname(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_pathname(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_pathname(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_port(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_port(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_port(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_port(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_protocol(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_protocol(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_protocol(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_search(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_search(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_search(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_search(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_hash(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_hash(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_hash(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_hash(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_onblur(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_onfocus(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_accessKey(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_accessKey(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_accessKey(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_accessKey(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_protocolLong(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_protocolLong(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_mimeType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_mimeType(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_nameProp(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_nameProp(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_put_tabIndex(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).put_tabIndex(@ptrCast(*const IHTMLAnchorElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_get_tabIndex(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).get_tabIndex(@ptrCast(*const IHTMLAnchorElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).focus(@ptrCast(*const IHTMLAnchorElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement.VTable, self.vtable).blur(@ptrCast(*const IHTMLAnchorElement, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAnchorElement2_Value = @import("../zig.zig").Guid.initString("3050F825-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAnchorElement2 = &IID_IHTMLAnchorElement2_Value;
pub const IHTMLAnchorElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_charset: fn(
            self: *const IHTMLAnchorElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_charset: fn(
            self: *const IHTMLAnchorElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_coords: fn(
            self: *const IHTMLAnchorElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_coords: fn(
            self: *const IHTMLAnchorElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hreflang: fn(
            self: *const IHTMLAnchorElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hreflang: fn(
            self: *const IHTMLAnchorElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_shape: fn(
            self: *const IHTMLAnchorElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shape: fn(
            self: *const IHTMLAnchorElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLAnchorElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLAnchorElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_charset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_charset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_coords(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_coords(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_coords(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_coords(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_hreflang(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_hreflang(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_hreflang(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_hreflang(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_shape(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_shape(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_shape(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_shape(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).put_type(@ptrCast(*const IHTMLAnchorElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement2_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement2.VTable, self.vtable).get_type(@ptrCast(*const IHTMLAnchorElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAnchorElement3_Value = @import("../zig.zig").Guid.initString("3051041D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAnchorElement3 = &IID_IHTMLAnchorElement3_Value;
pub const IHTMLAnchorElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_shape: fn(
            self: *const IHTMLAnchorElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shape: fn(
            self: *const IHTMLAnchorElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_coords: fn(
            self: *const IHTMLAnchorElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_coords: fn(
            self: *const IHTMLAnchorElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_href: fn(
            self: *const IHTMLAnchorElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLAnchorElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_put_shape(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).put_shape(@ptrCast(*const IHTMLAnchorElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_get_shape(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).get_shape(@ptrCast(*const IHTMLAnchorElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_put_coords(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).put_coords(@ptrCast(*const IHTMLAnchorElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_get_coords(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).get_coords(@ptrCast(*const IHTMLAnchorElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).put_href(@ptrCast(*const IHTMLAnchorElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAnchorElement3_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAnchorElement3.VTable, self.vtable).get_href(@ptrCast(*const IHTMLAnchorElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAnchorElement_Value = @import("../zig.zig").Guid.initString("3050F502-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLAnchorElement = &IID_DispHTMLAnchorElement_Value;
pub const DispHTMLAnchorElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLLabelEvents2_Value = @import("../zig.zig").Guid.initString("3050F61C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLLabelEvents2 = &IID_HTMLLabelEvents2_Value;
pub const HTMLLabelEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLLabelEvents_Value = @import("../zig.zig").Guid.initString("3050F329-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLLabelEvents = &IID_HTMLLabelEvents_Value;
pub const HTMLLabelEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLabelElement_Value = @import("../zig.zig").Guid.initString("3050F32A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLabelElement = &IID_IHTMLLabelElement_Value;
pub const IHTMLLabelElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_htmlFor: fn(
            self: *const IHTMLLabelElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_htmlFor: fn(
            self: *const IHTMLLabelElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_accessKey: fn(
            self: *const IHTMLLabelElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accessKey: fn(
            self: *const IHTMLLabelElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement_put_htmlFor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement.VTable, self.vtable).put_htmlFor(@ptrCast(*const IHTMLLabelElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement_get_htmlFor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement.VTable, self.vtable).get_htmlFor(@ptrCast(*const IHTMLLabelElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement_put_accessKey(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement.VTable, self.vtable).put_accessKey(@ptrCast(*const IHTMLLabelElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement_get_accessKey(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement.VTable, self.vtable).get_accessKey(@ptrCast(*const IHTMLLabelElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLabelElement2_Value = @import("../zig.zig").Guid.initString("3050F832-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLabelElement2 = &IID_IHTMLLabelElement2_Value;
pub const IHTMLLabelElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_form: fn(
            self: *const IHTMLLabelElement2,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLabelElement2_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLabelElement2.VTable, self.vtable).get_form(@ptrCast(*const IHTMLLabelElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLabelElement_Value = @import("../zig.zig").Guid.initString("3050F522-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLLabelElement = &IID_DispHTMLLabelElement_Value;
pub const DispHTMLLabelElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLListElement_Value = @import("../zig.zig").Guid.initString("3050F20E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLListElement = &IID_IHTMLListElement_Value;
pub const IHTMLListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLListElement2_Value = @import("../zig.zig").Guid.initString("3050F822-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLListElement2 = &IID_IHTMLListElement2_Value;
pub const IHTMLListElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_compact: fn(
            self: *const IHTMLListElement2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_compact: fn(
            self: *const IHTMLListElement2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLListElement2_put_compact(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLListElement2.VTable, self.vtable).put_compact(@ptrCast(*const IHTMLListElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLListElement2_get_compact(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLListElement2.VTable, self.vtable).get_compact(@ptrCast(*const IHTMLListElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLListElement_Value = @import("../zig.zig").Guid.initString("3050F525-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLListElement = &IID_DispHTMLListElement_Value;
pub const DispHTMLListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLUListElement_Value = @import("../zig.zig").Guid.initString("3050F1DD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLUListElement = &IID_IHTMLUListElement_Value;
pub const IHTMLUListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_compact: fn(
            self: *const IHTMLUListElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_compact: fn(
            self: *const IHTMLUListElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLUListElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLUListElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUListElement_put_compact(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUListElement.VTable, self.vtable).put_compact(@ptrCast(*const IHTMLUListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUListElement_get_compact(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUListElement.VTable, self.vtable).get_compact(@ptrCast(*const IHTMLUListElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUListElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUListElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLUListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLUListElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLUListElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLUListElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLUListElement_Value = @import("../zig.zig").Guid.initString("3050F538-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLUListElement = &IID_DispHTMLUListElement_Value;
pub const DispHTMLUListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOListElement_Value = @import("../zig.zig").Guid.initString("3050F1DE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLOListElement = &IID_IHTMLOListElement_Value;
pub const IHTMLOListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_compact: fn(
            self: *const IHTMLOListElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_compact: fn(
            self: *const IHTMLOListElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_start: fn(
            self: *const IHTMLOListElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_start: fn(
            self: *const IHTMLOListElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLOListElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLOListElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_put_compact(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).put_compact(@ptrCast(*const IHTMLOListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_get_compact(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).get_compact(@ptrCast(*const IHTMLOListElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_put_start(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).put_start(@ptrCast(*const IHTMLOListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_get_start(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).get_start(@ptrCast(*const IHTMLOListElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLOListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOListElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOListElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLOListElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLOListElement_Value = @import("../zig.zig").Guid.initString("3050F52A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLOListElement = &IID_DispHTMLOListElement_Value;
pub const DispHTMLOListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLIElement_Value = @import("../zig.zig").Guid.initString("3050F1E0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLIElement = &IID_IHTMLLIElement_Value;
pub const IHTMLLIElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_type: fn(
            self: *const IHTMLLIElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLLIElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLLIElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLLIElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLIElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLIElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLLIElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLIElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLIElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLLIElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLIElement_put_value(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLIElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLLIElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLIElement_get_value(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLIElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLLIElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLIElement_Value = @import("../zig.zig").Guid.initString("3050F523-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLLIElement = &IID_DispHTMLLIElement_Value;
pub const DispHTMLLIElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBlockElement_Value = @import("../zig.zig").Guid.initString("3050F208-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBlockElement = &IID_IHTMLBlockElement_Value;
pub const IHTMLBlockElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_clear: fn(
            self: *const IHTMLBlockElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clear: fn(
            self: *const IHTMLBlockElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement_put_clear(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLBlockElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement_get_clear(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLBlockElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBlockElement2_Value = @import("../zig.zig").Guid.initString("3050F823-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBlockElement2 = &IID_IHTMLBlockElement2_Value;
pub const IHTMLBlockElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_cite: fn(
            self: *const IHTMLBlockElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cite: fn(
            self: *const IHTMLBlockElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLBlockElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLBlockElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement2_put_cite(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement2.VTable, self.vtable).put_cite(@ptrCast(*const IHTMLBlockElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement2_get_cite(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement2.VTable, self.vtable).get_cite(@ptrCast(*const IHTMLBlockElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement2_put_width(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement2.VTable, self.vtable).put_width(@ptrCast(*const IHTMLBlockElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement2_get_width(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement2.VTable, self.vtable).get_width(@ptrCast(*const IHTMLBlockElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBlockElement3_Value = @import("../zig.zig").Guid.initString("30510494-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBlockElement3 = &IID_IHTMLBlockElement3_Value;
pub const IHTMLBlockElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_cite: fn(
            self: *const IHTMLBlockElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cite: fn(
            self: *const IHTMLBlockElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement3_put_cite(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement3.VTable, self.vtable).put_cite(@ptrCast(*const IHTMLBlockElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBlockElement3_get_cite(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBlockElement3.VTable, self.vtable).get_cite(@ptrCast(*const IHTMLBlockElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBlockElement_Value = @import("../zig.zig").Guid.initString("3050F506-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLBlockElement = &IID_DispHTMLBlockElement_Value;
pub const DispHTMLBlockElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDivElement_Value = @import("../zig.zig").Guid.initString("3050F200-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDivElement = &IID_IHTMLDivElement_Value;
pub const IHTMLDivElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLDivElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLDivElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_noWrap: fn(
            self: *const IHTMLDivElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_noWrap: fn(
            self: *const IHTMLDivElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLDivElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLDivElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivElement_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivElement.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLDivElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivElement_get_noWrap(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivElement.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLDivElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDivElement_Value = @import("../zig.zig").Guid.initString("3050F50C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDivElement = &IID_DispHTMLDivElement_Value;
pub const DispHTMLDivElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDDElement_Value = @import("../zig.zig").Guid.initString("3050F1F2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDDElement = &IID_IHTMLDDElement_Value;
pub const IHTMLDDElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_noWrap: fn(
            self: *const IHTMLDDElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_noWrap: fn(
            self: *const IHTMLDDElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDDElement_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDDElement.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLDDElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDDElement_get_noWrap(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDDElement.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLDDElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDDElement_Value = @import("../zig.zig").Guid.initString("3050F50B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDDElement = &IID_DispHTMLDDElement_Value;
pub const DispHTMLDDElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDTElement_Value = @import("../zig.zig").Guid.initString("3050F1F3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDTElement = &IID_IHTMLDTElement_Value;
pub const IHTMLDTElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_noWrap: fn(
            self: *const IHTMLDTElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_noWrap: fn(
            self: *const IHTMLDTElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDTElement_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDTElement.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLDTElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDTElement_get_noWrap(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDTElement.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLDTElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDTElement_Value = @import("../zig.zig").Guid.initString("3050F50D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDTElement = &IID_DispHTMLDTElement_Value;
pub const DispHTMLDTElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBRElement_Value = @import("../zig.zig").Guid.initString("3050F1F0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBRElement = &IID_IHTMLBRElement_Value;
pub const IHTMLBRElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_clear: fn(
            self: *const IHTMLBRElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clear: fn(
            self: *const IHTMLBRElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBRElement_put_clear(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBRElement.VTable, self.vtable).put_clear(@ptrCast(*const IHTMLBRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBRElement_get_clear(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBRElement.VTable, self.vtable).get_clear(@ptrCast(*const IHTMLBRElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBRElement_Value = @import("../zig.zig").Guid.initString("3050F53A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLBRElement = &IID_DispHTMLBRElement_Value;
pub const DispHTMLBRElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDListElement_Value = @import("../zig.zig").Guid.initString("3050F1F1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDListElement = &IID_IHTMLDListElement_Value;
pub const IHTMLDListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_compact: fn(
            self: *const IHTMLDListElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_compact: fn(
            self: *const IHTMLDListElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDListElement_put_compact(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDListElement.VTable, self.vtable).put_compact(@ptrCast(*const IHTMLDListElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDListElement_get_compact(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDListElement.VTable, self.vtable).get_compact(@ptrCast(*const IHTMLDListElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDListElement_Value = @import("../zig.zig").Guid.initString("3050F53B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDListElement = &IID_DispHTMLDListElement_Value;
pub const DispHTMLDListElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHRElement_Value = @import("../zig.zig").Guid.initString("3050F1F4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLHRElement = &IID_IHTMLHRElement_Value;
pub const IHTMLHRElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLHRElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLHRElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_color: fn(
            self: *const IHTMLHRElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_color: fn(
            self: *const IHTMLHRElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_noShade: fn(
            self: *const IHTMLHRElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_noShade: fn(
            self: *const IHTMLHRElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLHRElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLHRElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_size: fn(
            self: *const IHTMLHRElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_size: fn(
            self: *const IHTMLHRElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLHRElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_color(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_color(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_color(@ptrCast(*const IHTMLHRElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_noShade(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_noShade(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_noShade(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_noShade(@ptrCast(*const IHTMLHRElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLHRElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_put_size(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLHRElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHRElement_get_size(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHRElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLHRElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHRElement_Value = @import("../zig.zig").Guid.initString("3050F53D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLHRElement = &IID_DispHTMLHRElement_Value;
pub const DispHTMLHRElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLParaElement_Value = @import("../zig.zig").Guid.initString("3050F1F5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLParaElement = &IID_IHTMLParaElement_Value;
pub const IHTMLParaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLParaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLParaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParaElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParaElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLParaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParaElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParaElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLParaElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLParaElement_Value = @import("../zig.zig").Guid.initString("3050F52C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLParaElement = &IID_DispHTMLParaElement_Value;
pub const DispHTMLParaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementCollection2_Value = @import("../zig.zig").Guid.initString("3050F5EE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElementCollection2 = &IID_IHTMLElementCollection2_Value;
pub const IHTMLElementCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        urns: fn(
            self: *const IHTMLElementCollection2,
            urn: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection2_urns(self: *const T, urn: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection2.VTable, self.vtable).urns(@ptrCast(*const IHTMLElementCollection2, self), urn, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementCollection3_Value = @import("../zig.zig").Guid.initString("3050F835-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElementCollection3 = &IID_IHTMLElementCollection3_Value;
pub const IHTMLElementCollection3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedItem: fn(
            self: *const IHTMLElementCollection3,
            name: BSTR,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection3_namedItem(self: *const T, name: BSTR, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection3.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLElementCollection3, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLElementCollection4_Value = @import("../zig.zig").Guid.initString("30510425-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLElementCollection4 = &IID_IHTMLElementCollection4_Value;
pub const IHTMLElementCollection4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLElementCollection4,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLElementCollection4,
            index: i32,
            pNode: **IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        namedItem: fn(
            self: *const IHTMLElementCollection4,
            name: BSTR,
            pNode: **IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection4_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection4.VTable, self.vtable).get_length(@ptrCast(*const IHTMLElementCollection4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection4_item(self: *const T, index: i32, pNode: **IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection4.VTable, self.vtable).item(@ptrCast(*const IHTMLElementCollection4, self), index, pNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLElementCollection4_namedItem(self: *const T, name: BSTR, pNode: **IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLElementCollection4.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLElementCollection4, self), name, pNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLElementCollection_Value = @import("../zig.zig").Guid.initString("3050F56B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLElementCollection = &IID_DispHTMLElementCollection_Value;
pub const DispHTMLElementCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHeaderElement_Value = @import("../zig.zig").Guid.initString("3050F1F6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLHeaderElement = &IID_IHTMLHeaderElement_Value;
pub const IHTMLHeaderElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLHeaderElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLHeaderElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeaderElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeaderElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLHeaderElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeaderElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeaderElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLHeaderElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHeaderElement_Value = @import("../zig.zig").Guid.initString("3050F515-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLHeaderElement = &IID_DispHTMLHeaderElement_Value;
pub const DispHTMLHeaderElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLSelectElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F622-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLSelectElementEvents2 = &IID_HTMLSelectElementEvents2_Value;
pub const HTMLSelectElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLSelectElementEvents_Value = @import("../zig.zig").Guid.initString("3050F302-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLSelectElementEvents = &IID_HTMLSelectElementEvents_Value;
pub const HTMLSelectElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionElement_Value = @import("../zig.zig").Guid.initString("3050F211-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLOptionElement = &IID_IHTMLOptionElement_Value;
pub const IHTMLOptionElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_selected: fn(
            self: *const IHTMLOptionElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selected: fn(
            self: *const IHTMLOptionElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLOptionElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLOptionElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultSelected: fn(
            self: *const IHTMLOptionElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultSelected: fn(
            self: *const IHTMLOptionElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_index: fn(
            self: *const IHTMLOptionElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_index: fn(
            self: *const IHTMLOptionElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_text: fn(
            self: *const IHTMLOptionElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_text: fn(
            self: *const IHTMLOptionElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLOptionElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_selected(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_selected(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_selected(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_selected(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_defaultSelected(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_defaultSelected(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_defaultSelected(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_defaultSelected(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_index(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_index(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_index(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_index(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_put_text(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLOptionElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_text(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLOptionElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLOptionElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElementEx_Value = @import("../zig.zig").Guid.initString("3050F2D1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSelectElementEx = &IID_IHTMLSelectElementEx_Value;
pub const IHTMLSelectElementEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ShowDropdown: fn(
            self: *const IHTMLSelectElementEx,
            fShow: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSelectExFlags: fn(
            self: *const IHTMLSelectElementEx,
            lFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectExFlags: fn(
            self: *const IHTMLSelectElementEx,
            pFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDropdownOpen: fn(
            self: *const IHTMLSelectElementEx,
            pfOpen: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElementEx_ShowDropdown(self: *const T, fShow: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElementEx.VTable, self.vtable).ShowDropdown(@ptrCast(*const IHTMLSelectElementEx, self), fShow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElementEx_SetSelectExFlags(self: *const T, lFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElementEx.VTable, self.vtable).SetSelectExFlags(@ptrCast(*const IHTMLSelectElementEx, self), lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElementEx_GetSelectExFlags(self: *const T, pFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElementEx.VTable, self.vtable).GetSelectExFlags(@ptrCast(*const IHTMLSelectElementEx, self), pFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElementEx_GetDropdownOpen(self: *const T, pfOpen: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElementEx.VTable, self.vtable).GetDropdownOpen(@ptrCast(*const IHTMLSelectElementEx, self), pfOpen);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement_Value = @import("../zig.zig").Guid.initString("3050F244-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSelectElement = &IID_IHTMLSelectElement_Value;
pub const IHTMLSelectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_size: fn(
            self: *const IHTMLSelectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_size: fn(
            self: *const IHTMLSelectElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_multiple: fn(
            self: *const IHTMLSelectElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_multiple: fn(
            self: *const IHTMLSelectElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLSelectElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLSelectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_options: fn(
            self: *const IHTMLSelectElement,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchange: fn(
            self: *const IHTMLSelectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchange: fn(
            self: *const IHTMLSelectElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_selectedIndex: fn(
            self: *const IHTMLSelectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectedIndex: fn(
            self: *const IHTMLSelectElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLSelectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLSelectElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLSelectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLSelectElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLSelectElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLSelectElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        add: fn(
            self: *const IHTMLSelectElement,
            element: *IHTMLElement,
            before: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        remove: fn(
            self: *const IHTMLSelectElement,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_length: fn(
            self: *const IHTMLSelectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLSelectElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLSelectElement,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLSelectElement,
            name: VARIANT,
            index: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        tags: fn(
            self: *const IHTMLSelectElement,
            tagName: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_size(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_multiple(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_multiple(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_multiple(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_multiple(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_options(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_options(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_onchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_selectedIndex(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_selectedIndex(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_selectedIndex(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_selectedIndex(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_add(self: *const T, element: *IHTMLElement, before: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).add(@ptrCast(*const IHTMLSelectElement, self), element, before);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_remove(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).remove(@ptrCast(*const IHTMLSelectElement, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).put_length(@ptrCast(*const IHTMLSelectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get_length(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLSelectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_item(self: *const T, name: VARIANT, index: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).item(@ptrCast(*const IHTMLSelectElement, self), name, index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement_tags(self: *const T, tagName: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement.VTable, self.vtable).tags(@ptrCast(*const IHTMLSelectElement, self), tagName, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement2_Value = @import("../zig.zig").Guid.initString("3050F5ED-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSelectElement2 = &IID_IHTMLSelectElement2_Value;
pub const IHTMLSelectElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        urns: fn(
            self: *const IHTMLSelectElement2,
            urn: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement2_urns(self: *const T, urn: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement2.VTable, self.vtable).urns(@ptrCast(*const IHTMLSelectElement2, self), urn, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement4_Value = @import("../zig.zig").Guid.initString("3050F838-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSelectElement4 = &IID_IHTMLSelectElement4_Value;
pub const IHTMLSelectElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedItem: fn(
            self: *const IHTMLSelectElement4,
            name: BSTR,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement4_namedItem(self: *const T, name: BSTR, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement4.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLSelectElement4, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement5_Value = @import("../zig.zig").Guid.initString("3051049D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSelectElement5 = &IID_IHTMLSelectElement5_Value;
pub const IHTMLSelectElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        add: fn(
            self: *const IHTMLSelectElement5,
            pElem: *IHTMLOptionElement,
            pvarBefore: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement5_add(self: *const T, pElem: *IHTMLOptionElement, pvarBefore: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement5.VTable, self.vtable).add(@ptrCast(*const IHTMLSelectElement5, self), pElem, pvarBefore);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectElement6_Value = @import("../zig.zig").Guid.initString("30510760-98B6-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSelectElement6 = &IID_IHTMLSelectElement6_Value;
pub const IHTMLSelectElement6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        add: fn(
            self: *const IHTMLSelectElement6,
            pElem: *IHTMLOptionElement,
            pvarBefore: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLSelectElement6,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLSelectElement6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement6_add(self: *const T, pElem: *IHTMLOptionElement, pvarBefore: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement6.VTable, self.vtable).add(@ptrCast(*const IHTMLSelectElement6, self), pElem, pvarBefore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement6_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement6.VTable, self.vtable).put_value(@ptrCast(*const IHTMLSelectElement6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectElement6_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectElement6.VTable, self.vtable).get_value(@ptrCast(*const IHTMLSelectElement6, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSelectElement_Value = @import("../zig.zig").Guid.initString("3050F531-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLSelectElement = &IID_DispHTMLSelectElement_Value;
pub const DispHTMLSelectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLWndSelectElement_Value = @import("../zig.zig").Guid.initString("3050F597-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLWndSelectElement = &IID_DispHTMLWndSelectElement_Value;
pub const DispHTMLWndSelectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectionObject_Value = @import("../zig.zig").Guid.initString("3050F25A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSelectionObject = &IID_IHTMLSelectionObject_Value;
pub const IHTMLSelectionObject = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createRange: fn(
            self: *const IHTMLSelectionObject,
            range: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        empty: fn(
            self: *const IHTMLSelectionObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const IHTMLSelectionObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLSelectionObject,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject_createRange(self: *const T, range: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject.VTable, self.vtable).createRange(@ptrCast(*const IHTMLSelectionObject, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject_empty(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject.VTable, self.vtable).empty(@ptrCast(*const IHTMLSelectionObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject.VTable, self.vtable).clear(@ptrCast(*const IHTMLSelectionObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject.VTable, self.vtable).get_type(@ptrCast(*const IHTMLSelectionObject, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelectionObject2_Value = @import("../zig.zig").Guid.initString("3050F7EC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSelectionObject2 = &IID_IHTMLSelectionObject2_Value;
pub const IHTMLSelectionObject2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createRangeCollection: fn(
            self: *const IHTMLSelectionObject2,
            rangeCollection: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_typeDetail: fn(
            self: *const IHTMLSelectionObject2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject2_createRangeCollection(self: *const T, rangeCollection: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject2.VTable, self.vtable).createRangeCollection(@ptrCast(*const IHTMLSelectionObject2, self), rangeCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelectionObject2_get_typeDetail(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelectionObject2.VTable, self.vtable).get_typeDetail(@ptrCast(*const IHTMLSelectionObject2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSelection_Value = @import("../zig.zig").Guid.initString("305104B6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSelection = &IID_IHTMLSelection_Value;
pub const IHTMLSelection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_anchorNode: fn(
            self: *const IHTMLSelection,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_anchorOffset: fn(
            self: *const IHTMLSelection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_focusNode: fn(
            self: *const IHTMLSelection,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_focusOffset: fn(
            self: *const IHTMLSelection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isCollapsed: fn(
            self: *const IHTMLSelection,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapse: fn(
            self: *const IHTMLSelection,
            parentNode: *IDispatch,
            offfset: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapseToStart: fn(
            self: *const IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        collapseToEnd: fn(
            self: *const IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectAllChildren: fn(
            self: *const IHTMLSelection,
            parentNode: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteFromDocument: fn(
            self: *const IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rangeCount: fn(
            self: *const IHTMLSelection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRangeAt: fn(
            self: *const IHTMLSelection,
            index: i32,
            ppRange: **IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addRange: fn(
            self: *const IHTMLSelection,
            range: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeRange: fn(
            self: *const IHTMLSelection,
            range: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAllRanges: fn(
            self: *const IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLSelection,
            pSelectionString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_anchorNode(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_anchorNode(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_anchorOffset(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_anchorOffset(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_focusNode(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_focusNode(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_focusOffset(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_focusOffset(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_isCollapsed(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_isCollapsed(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_collapse(self: *const T, parentNode: *IDispatch, offfset: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).collapse(@ptrCast(*const IHTMLSelection, self), parentNode, offfset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_collapseToStart(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).collapseToStart(@ptrCast(*const IHTMLSelection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_collapseToEnd(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).collapseToEnd(@ptrCast(*const IHTMLSelection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_selectAllChildren(self: *const T, parentNode: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).selectAllChildren(@ptrCast(*const IHTMLSelection, self), parentNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_deleteFromDocument(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).deleteFromDocument(@ptrCast(*const IHTMLSelection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_get_rangeCount(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).get_rangeCount(@ptrCast(*const IHTMLSelection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_getRangeAt(self: *const T, index: i32, ppRange: **IHTMLDOMRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).getRangeAt(@ptrCast(*const IHTMLSelection, self), index, ppRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_addRange(self: *const T, range: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).addRange(@ptrCast(*const IHTMLSelection, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_removeRange(self: *const T, range: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).removeRange(@ptrCast(*const IHTMLSelection, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_removeAllRanges(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).removeAllRanges(@ptrCast(*const IHTMLSelection, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSelection_toString(self: *const T, pSelectionString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSelection.VTable, self.vtable).toString(@ptrCast(*const IHTMLSelection, self), pSelectionString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionElement3_Value = @import("../zig.zig").Guid.initString("3050F820-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLOptionElement3 = &IID_IHTMLOptionElement3_Value;
pub const IHTMLOptionElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_label: fn(
            self: *const IHTMLOptionElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_label: fn(
            self: *const IHTMLOptionElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement3_put_label(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement3.VTable, self.vtable).put_label(@ptrCast(*const IHTMLOptionElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement3_get_label(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement3.VTable, self.vtable).get_label(@ptrCast(*const IHTMLOptionElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionElement4_Value = @import("../zig.zig").Guid.initString("305107B4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLOptionElement4 = &IID_IHTMLOptionElement4_Value;
pub const IHTMLOptionElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_value: fn(
            self: *const IHTMLOptionElement4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLOptionElement4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement4_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement4.VTable, self.vtable).put_value(@ptrCast(*const IHTMLOptionElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElement4_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElement4.VTable, self.vtable).get_value(@ptrCast(*const IHTMLOptionElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionElementFactory_Value = @import("../zig.zig").Guid.initString("3050F38C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLOptionElementFactory = &IID_IHTMLOptionElementFactory_Value;
pub const IHTMLOptionElementFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLOptionElementFactory,
            text: VARIANT,
            value: VARIANT,
            defaultselected: VARIANT,
            selected: VARIANT,
            __MIDL__IHTMLOptionElementFactory0000: **IHTMLOptionElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionElementFactory_create(self: *const T, text: VARIANT, value: VARIANT, defaultselected: VARIANT, selected: VARIANT, __MIDL__IHTMLOptionElementFactory0000: **IHTMLOptionElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionElementFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLOptionElementFactory, self), text, value, defaultselected, selected, __MIDL__IHTMLOptionElementFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLOptionElement_Value = @import("../zig.zig").Guid.initString("3050F52B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLOptionElement = &IID_DispHTMLOptionElement_Value;
pub const DispHTMLOptionElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLWndOptionElement_Value = @import("../zig.zig").Guid.initString("3050F598-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLWndOptionElement = &IID_DispHTMLWndOptionElement_Value;
pub const DispHTMLWndOptionElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLButtonElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F617-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLButtonElementEvents2 = &IID_HTMLButtonElementEvents2_Value;
pub const HTMLButtonElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLButtonElementEvents_Value = @import("../zig.zig").Guid.initString("3050F2B3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLButtonElementEvents = &IID_HTMLButtonElementEvents_Value;
pub const HTMLButtonElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputTextElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F618-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLInputTextElementEvents2 = &IID_HTMLInputTextElementEvents2_Value;
pub const HTMLInputTextElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLOptionButtonElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F619-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLOptionButtonElementEvents2 = &IID_HTMLOptionButtonElementEvents2_Value;
pub const HTMLOptionButtonElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputFileElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F61A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLInputFileElementEvents2 = &IID_HTMLInputFileElementEvents2_Value;
pub const HTMLInputFileElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputImageEvents2_Value = @import("../zig.zig").Guid.initString("3050F61B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLInputImageEvents2 = &IID_HTMLInputImageEvents2_Value;
pub const HTMLInputImageEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputTextElementEvents_Value = @import("../zig.zig").Guid.initString("3050F2A7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLInputTextElementEvents = &IID_HTMLInputTextElementEvents_Value;
pub const HTMLInputTextElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLOptionButtonElementEvents_Value = @import("../zig.zig").Guid.initString("3050F2BD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLOptionButtonElementEvents = &IID_HTMLOptionButtonElementEvents_Value;
pub const HTMLOptionButtonElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputFileElementEvents_Value = @import("../zig.zig").Guid.initString("3050F2AF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLInputFileElementEvents = &IID_HTMLInputFileElementEvents_Value;
pub const HTMLInputFileElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLInputImageEvents_Value = @import("../zig.zig").Guid.initString("3050F2C3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLInputImageEvents = &IID_HTMLInputImageEvents_Value;
pub const HTMLInputImageEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputElement_Value = @import("../zig.zig").Guid.initString("3050F5D2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputElement = &IID_IHTMLInputElement_Value;
pub const IHTMLInputElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_type: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_status: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLInputElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLInputElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLInputElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_size: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_size: fn(
            self: *const IHTMLInputElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maxLength: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxLength: fn(
            self: *const IHTMLInputElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLInputElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchange: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchange: fn(
            self: *const IHTMLInputElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselect: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselect: fn(
            self: *const IHTMLInputElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultValue: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultValue: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_readOnly: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readOnly: fn(
            self: *const IHTMLInputElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLInputElement,
            range: **IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_indeterminate: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_indeterminate: fn(
            self: *const IHTMLInputElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultChecked: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultChecked: fn(
            self: *const IHTMLInputElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_checked: fn(
            self: *const IHTMLInputElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_checked: fn(
            self: *const IHTMLInputElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLInputElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vspace: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vspace: fn(
            self: *const IHTMLInputElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hspace: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hspace: fn(
            self: *const IHTMLInputElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alt: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alt: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_src: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lowsrc: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lowsrc: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vrml: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vrml: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dynsrc: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dynsrc: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_complete: fn(
            self: *const IHTMLInputElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_loop: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_loop: fn(
            self: *const IHTMLInputElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_align: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLInputElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLInputElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onabort: fn(
            self: *const IHTMLInputElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onabort: fn(
            self: *const IHTMLInputElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLInputElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLInputElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLInputElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_start: fn(
            self: *const IHTMLInputElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_start: fn(
            self: *const IHTMLInputElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_status(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_status(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_size(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_maxLength(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_maxLength(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_maxLength(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_maxLength(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).select(@ptrCast(*const IHTMLInputElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_defaultValue(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_defaultValue(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_defaultValue(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_defaultValue(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_readOnly(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_readOnly(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_readOnly(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_createTextRange(self: *const T, range: **IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLInputElement, self), range);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_indeterminate(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_indeterminate(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_indeterminate(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_indeterminate(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_defaultChecked(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_defaultChecked(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_defaultChecked(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_defaultChecked(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_checked(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_checked(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_checked(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_checked(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_border(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_border(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_border(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_vspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_hspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_alt(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_alt(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_lowsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_lowsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_vrml(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_vrml(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_dynsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_dynsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_readyState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_complete(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_complete(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_loop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_loop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_onabort(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_width(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_height(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLInputElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_put_start(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).put_start(@ptrCast(*const IHTMLInputElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement_get_start(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement.VTable, self.vtable).get_start(@ptrCast(*const IHTMLInputElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputElement2_Value = @import("../zig.zig").Guid.initString("3050F821-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputElement2 = &IID_IHTMLInputElement2_Value;
pub const IHTMLInputElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_accept: fn(
            self: *const IHTMLInputElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accept: fn(
            self: *const IHTMLInputElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_useMap: fn(
            self: *const IHTMLInputElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_useMap: fn(
            self: *const IHTMLInputElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement2_put_accept(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement2.VTable, self.vtable).put_accept(@ptrCast(*const IHTMLInputElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement2_get_accept(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement2.VTable, self.vtable).get_accept(@ptrCast(*const IHTMLInputElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement2_put_useMap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement2.VTable, self.vtable).put_useMap(@ptrCast(*const IHTMLInputElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement2_get_useMap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement2.VTable, self.vtable).get_useMap(@ptrCast(*const IHTMLInputElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputElement3_Value = @import("../zig.zig").Guid.initString("30510435-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputElement3 = &IID_IHTMLInputElement3_Value;
pub const IHTMLInputElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_src: fn(
            self: *const IHTMLInputElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLInputElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lowsrc: fn(
            self: *const IHTMLInputElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lowsrc: fn(
            self: *const IHTMLInputElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vrml: fn(
            self: *const IHTMLInputElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vrml: fn(
            self: *const IHTMLInputElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dynsrc: fn(
            self: *const IHTMLInputElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dynsrc: fn(
            self: *const IHTMLInputElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).put_src(@ptrCast(*const IHTMLInputElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).get_src(@ptrCast(*const IHTMLInputElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_put_lowsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLInputElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_get_lowsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLInputElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_put_vrml(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLInputElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_get_vrml(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLInputElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_put_dynsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLInputElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputElement3_get_dynsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputElement3.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLInputElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputButtonElement_Value = @import("../zig.zig").Guid.initString("3050F2B2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputButtonElement = &IID_IHTMLInputButtonElement_Value;
pub const IHTMLInputButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLInputButtonElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLInputButtonElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLInputButtonElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLInputButtonElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLInputButtonElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_status: fn(
            self: *const IHTMLInputButtonElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLInputButtonElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLInputButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLInputButtonElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLInputButtonElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLInputButtonElement,
            range: **IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_status(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputButtonElement_createTextRange(self: *const T, range: **IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputButtonElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLInputButtonElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputHiddenElement_Value = @import("../zig.zig").Guid.initString("3050F2A4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputHiddenElement = &IID_IHTMLInputHiddenElement_Value;
pub const IHTMLInputHiddenElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLInputHiddenElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLInputHiddenElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLInputHiddenElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLInputHiddenElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLInputHiddenElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_status: fn(
            self: *const IHTMLInputHiddenElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLInputHiddenElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLInputHiddenElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLInputHiddenElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLInputHiddenElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLInputHiddenElement,
            range: **IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputHiddenElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputHiddenElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputHiddenElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_status(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputHiddenElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputHiddenElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputHiddenElement_createTextRange(self: *const T, range: **IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputHiddenElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLInputHiddenElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputTextElement_Value = @import("../zig.zig").Guid.initString("3050F2A6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputTextElement = &IID_IHTMLInputTextElement_Value;
pub const IHTMLInputTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLInputTextElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLInputTextElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLInputTextElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLInputTextElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLInputTextElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_status: fn(
            self: *const IHTMLInputTextElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLInputTextElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLInputTextElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLInputTextElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLInputTextElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultValue: fn(
            self: *const IHTMLInputTextElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultValue: fn(
            self: *const IHTMLInputTextElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_size: fn(
            self: *const IHTMLInputTextElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_size: fn(
            self: *const IHTMLInputTextElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maxLength: fn(
            self: *const IHTMLInputTextElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxLength: fn(
            self: *const IHTMLInputTextElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLInputTextElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchange: fn(
            self: *const IHTMLInputTextElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchange: fn(
            self: *const IHTMLInputTextElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselect: fn(
            self: *const IHTMLInputTextElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselect: fn(
            self: *const IHTMLInputTextElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_readOnly: fn(
            self: *const IHTMLInputTextElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readOnly: fn(
            self: *const IHTMLInputTextElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLInputTextElement,
            range: **IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_status(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_defaultValue(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_defaultValue(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_defaultValue(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_defaultValue(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_size(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_maxLength(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_maxLength(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_maxLength(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_maxLength(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).select(@ptrCast(*const IHTMLInputTextElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_onchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_onselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_put_readOnly(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).put_readOnly(@ptrCast(*const IHTMLInputTextElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_get_readOnly(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLInputTextElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement_createTextRange(self: *const T, range: **IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLInputTextElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputTextElement2_Value = @import("../zig.zig").Guid.initString("3050F2D2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputTextElement2 = &IID_IHTMLInputTextElement2_Value;
pub const IHTMLInputTextElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_selectionStart: fn(
            self: *const IHTMLInputTextElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectionStart: fn(
            self: *const IHTMLInputTextElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_selectionEnd: fn(
            self: *const IHTMLInputTextElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectionEnd: fn(
            self: *const IHTMLInputTextElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setSelectionRange: fn(
            self: *const IHTMLInputTextElement2,
            start: i32,
            end: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_put_selectionStart(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).put_selectionStart(@ptrCast(*const IHTMLInputTextElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_get_selectionStart(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).get_selectionStart(@ptrCast(*const IHTMLInputTextElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_put_selectionEnd(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).put_selectionEnd(@ptrCast(*const IHTMLInputTextElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_get_selectionEnd(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).get_selectionEnd(@ptrCast(*const IHTMLInputTextElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputTextElement2_setSelectionRange(self: *const T, start: i32, end: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputTextElement2.VTable, self.vtable).setSelectionRange(@ptrCast(*const IHTMLInputTextElement2, self), start, end);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputFileElement_Value = @import("../zig.zig").Guid.initString("3050F2AD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputFileElement = &IID_IHTMLInputFileElement_Value;
pub const IHTMLInputFileElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLInputFileElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLInputFileElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLInputFileElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_status: fn(
            self: *const IHTMLInputFileElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLInputFileElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLInputFileElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLInputFileElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLInputFileElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_size: fn(
            self: *const IHTMLInputFileElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_size: fn(
            self: *const IHTMLInputFileElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maxLength: fn(
            self: *const IHTMLInputFileElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxLength: fn(
            self: *const IHTMLInputFileElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLInputFileElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchange: fn(
            self: *const IHTMLInputFileElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchange: fn(
            self: *const IHTMLInputFileElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselect: fn(
            self: *const IHTMLInputFileElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselect: fn(
            self: *const IHTMLInputFileElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLInputFileElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLInputFileElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_status(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_size(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_maxLength(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_maxLength(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_maxLength(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_maxLength(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).select(@ptrCast(*const IHTMLInputFileElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_onchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_onselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputFileElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputFileElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputFileElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputFileElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionButtonElement_Value = @import("../zig.zig").Guid.initString("3050F2BC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLOptionButtonElement = &IID_IHTMLOptionButtonElement_Value;
pub const IHTMLOptionButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_value: fn(
            self: *const IHTMLOptionButtonElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLOptionButtonElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLOptionButtonElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLOptionButtonElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLOptionButtonElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_checked: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_checked: fn(
            self: *const IHTMLOptionButtonElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultChecked: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultChecked: fn(
            self: *const IHTMLOptionButtonElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchange: fn(
            self: *const IHTMLOptionButtonElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchange: fn(
            self: *const IHTMLOptionButtonElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLOptionButtonElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_status: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLOptionButtonElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_indeterminate: fn(
            self: *const IHTMLOptionButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_indeterminate: fn(
            self: *const IHTMLOptionButtonElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLOptionButtonElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_checked(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_checked(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_checked(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_checked(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_defaultChecked(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_defaultChecked(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_defaultChecked(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_defaultChecked(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_onchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_status(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_status(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_put_indeterminate(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).put_indeterminate(@ptrCast(*const IHTMLOptionButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_indeterminate(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_indeterminate(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionButtonElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionButtonElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLOptionButtonElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputImage_Value = @import("../zig.zig").Guid.initString("3050F2C2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputImage = &IID_IHTMLInputImage_Value;
pub const IHTMLInputImage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLInputImage,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLInputImage,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLInputImage,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vspace: fn(
            self: *const IHTMLInputImage,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vspace: fn(
            self: *const IHTMLInputImage,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hspace: fn(
            self: *const IHTMLInputImage,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hspace: fn(
            self: *const IHTMLInputImage,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alt: fn(
            self: *const IHTMLInputImage,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alt: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_src: fn(
            self: *const IHTMLInputImage,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lowsrc: fn(
            self: *const IHTMLInputImage,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lowsrc: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vrml: fn(
            self: *const IHTMLInputImage,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vrml: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dynsrc: fn(
            self: *const IHTMLInputImage,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dynsrc: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_complete: fn(
            self: *const IHTMLInputImage,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_loop: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_loop: fn(
            self: *const IHTMLInputImage,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_align: fn(
            self: *const IHTMLInputImage,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLInputImage,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLInputImage,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onabort: fn(
            self: *const IHTMLInputImage,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onabort: fn(
            self: *const IHTMLInputImage,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLInputImage,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLInputImage,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLInputImage,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLInputImage,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLInputImage,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_start: fn(
            self: *const IHTMLInputImage,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_start: fn(
            self: *const IHTMLInputImage,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_border(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_border(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_border(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_vspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_hspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_alt(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_alt(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_src(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_src(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_lowsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_lowsrc(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_lowsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_lowsrc(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_vrml(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_vrml(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_vrml(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_vrml(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_dynsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_dynsrc(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_dynsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_dynsrc(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_readyState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_complete(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_complete(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_loop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_loop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_align(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_align(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_onabort(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_width(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_width(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_width(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_height(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_height(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_height(@ptrCast(*const IHTMLInputImage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_put_start(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).put_start(@ptrCast(*const IHTMLInputImage, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputImage_get_start(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputImage.VTable, self.vtable).get_start(@ptrCast(*const IHTMLInputImage, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLInputRangeElement_Value = @import("../zig.zig").Guid.initString("3050F2D4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLInputRangeElement = &IID_IHTMLInputRangeElement_Value;
pub const IHTMLInputRangeElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_disabled: fn(
            self: *const IHTMLInputRangeElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLInputRangeElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLInputRangeElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alt: fn(
            self: *const IHTMLInputRangeElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alt: fn(
            self: *const IHTMLInputRangeElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLInputRangeElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLInputRangeElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLInputRangeElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLInputRangeElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_min: fn(
            self: *const IHTMLInputRangeElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_min: fn(
            self: *const IHTMLInputRangeElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_max: fn(
            self: *const IHTMLInputRangeElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_max: fn(
            self: *const IHTMLInputRangeElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_step: fn(
            self: *const IHTMLInputRangeElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_step: fn(
            self: *const IHTMLInputRangeElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_valueAsNumber: fn(
            self: *const IHTMLInputRangeElement,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_valueAsNumber: fn(
            self: *const IHTMLInputRangeElement,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stepUp: fn(
            self: *const IHTMLInputRangeElement,
            n: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stepDown: fn(
            self: *const IHTMLInputRangeElement,
            n: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_alt(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_alt(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_min(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_min(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_min(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_min(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_max(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_max(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_max(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_max(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_step(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_step(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_step(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_step(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_put_valueAsNumber(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).put_valueAsNumber(@ptrCast(*const IHTMLInputRangeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_get_valueAsNumber(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).get_valueAsNumber(@ptrCast(*const IHTMLInputRangeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_stepUp(self: *const T, n: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).stepUp(@ptrCast(*const IHTMLInputRangeElement, self), n);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLInputRangeElement_stepDown(self: *const T, n: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLInputRangeElement.VTable, self.vtable).stepDown(@ptrCast(*const IHTMLInputRangeElement, self), n);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLInputElement_Value = @import("../zig.zig").Guid.initString("3050F57D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLInputElement = &IID_DispHTMLInputElement_Value;
pub const DispHTMLInputElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextAreaElement_Value = @import("../zig.zig").Guid.initString("3050F2AA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTextAreaElement = &IID_IHTMLTextAreaElement_Value;
pub const IHTMLTextAreaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLTextAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLTextAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLTextAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLTextAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLTextAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_status: fn(
            self: *const IHTMLTextAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLTextAreaElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLTextAreaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLTextAreaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLTextAreaElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultValue: fn(
            self: *const IHTMLTextAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultValue: fn(
            self: *const IHTMLTextAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        select: fn(
            self: *const IHTMLTextAreaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchange: fn(
            self: *const IHTMLTextAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchange: fn(
            self: *const IHTMLTextAreaElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselect: fn(
            self: *const IHTMLTextAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselect: fn(
            self: *const IHTMLTextAreaElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_readOnly: fn(
            self: *const IHTMLTextAreaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readOnly: fn(
            self: *const IHTMLTextAreaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rows: fn(
            self: *const IHTMLTextAreaElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rows: fn(
            self: *const IHTMLTextAreaElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cols: fn(
            self: *const IHTMLTextAreaElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cols: fn(
            self: *const IHTMLTextAreaElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_wrap: fn(
            self: *const IHTMLTextAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_wrap: fn(
            self: *const IHTMLTextAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLTextAreaElement,
            range: **IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_status(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_defaultValue(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_defaultValue(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_defaultValue(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_defaultValue(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_select(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).select(@ptrCast(*const IHTMLTextAreaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_onchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_onselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_readOnly(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_readOnly(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_readOnly(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_readOnly(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_rows(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_rows(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_rows(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_rows(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_cols(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_cols(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_cols(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_cols(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_put_wrap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).put_wrap(@ptrCast(*const IHTMLTextAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_get_wrap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).get_wrap(@ptrCast(*const IHTMLTextAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement_createTextRange(self: *const T, range: **IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLTextAreaElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTextAreaElement2_Value = @import("../zig.zig").Guid.initString("3050F2D3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTextAreaElement2 = &IID_IHTMLTextAreaElement2_Value;
pub const IHTMLTextAreaElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_selectionStart: fn(
            self: *const IHTMLTextAreaElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectionStart: fn(
            self: *const IHTMLTextAreaElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_selectionEnd: fn(
            self: *const IHTMLTextAreaElement2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectionEnd: fn(
            self: *const IHTMLTextAreaElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setSelectionRange: fn(
            self: *const IHTMLTextAreaElement2,
            start: i32,
            end: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_put_selectionStart(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).put_selectionStart(@ptrCast(*const IHTMLTextAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_get_selectionStart(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).get_selectionStart(@ptrCast(*const IHTMLTextAreaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_put_selectionEnd(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).put_selectionEnd(@ptrCast(*const IHTMLTextAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_get_selectionEnd(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).get_selectionEnd(@ptrCast(*const IHTMLTextAreaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTextAreaElement2_setSelectionRange(self: *const T, start: i32, end: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTextAreaElement2.VTable, self.vtable).setSelectionRange(@ptrCast(*const IHTMLTextAreaElement2, self), start, end);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTextAreaElement_Value = @import("../zig.zig").Guid.initString("3050F521-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTextAreaElement = &IID_DispHTMLTextAreaElement_Value;
pub const DispHTMLTextAreaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLRichtextElement_Value = @import("../zig.zig").Guid.initString("3050F54D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLRichtextElement = &IID_DispHTMLRichtextElement_Value;
pub const DispHTMLRichtextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLButtonElement_Value = @import("../zig.zig").Guid.initString("3050F2BB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLButtonElement = &IID_IHTMLButtonElement_Value;
pub const IHTMLButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLButtonElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLButtonElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLButtonElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLButtonElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLButtonElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_status: fn(
            self: *const IHTMLButtonElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLButtonElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLButtonElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLButtonElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLButtonElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextRange: fn(
            self: *const IHTMLButtonElement,
            range: **IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_put_status(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).put_status(@ptrCast(*const IHTMLButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_status(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_status(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLButtonElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLButtonElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement_createTextRange(self: *const T, range: **IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement.VTable, self.vtable).createTextRange(@ptrCast(*const IHTMLButtonElement, self), range);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLButtonElement2_Value = @import("../zig.zig").Guid.initString("305106F3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLButtonElement2 = &IID_IHTMLButtonElement2_Value;
pub const IHTMLButtonElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_type: fn(
            self: *const IHTMLButtonElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLButtonElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement2_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement2.VTable, self.vtable).put_type(@ptrCast(*const IHTMLButtonElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLButtonElement2_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLButtonElement2.VTable, self.vtable).get_type(@ptrCast(*const IHTMLButtonElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLButtonElement_Value = @import("../zig.zig").Guid.initString("3050F51F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLButtonElement = &IID_DispHTMLButtonElement_Value;
pub const DispHTMLButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLMarqueeElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F61F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLMarqueeElementEvents2 = &IID_HTMLMarqueeElementEvents2_Value;
pub const HTMLMarqueeElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLMarqueeElementEvents_Value = @import("../zig.zig").Guid.initString("3050F2B8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLMarqueeElementEvents = &IID_HTMLMarqueeElementEvents_Value;
pub const HTMLMarqueeElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMarqueeElement_Value = @import("../zig.zig").Guid.initString("3050F2B5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMarqueeElement = &IID_IHTMLMarqueeElement_Value;
pub const IHTMLMarqueeElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_bgColor: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bgColor: fn(
            self: *const IHTMLMarqueeElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollDelay: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollDelay: fn(
            self: *const IHTMLMarqueeElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_direction: fn(
            self: *const IHTMLMarqueeElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_direction: fn(
            self: *const IHTMLMarqueeElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_behavior: fn(
            self: *const IHTMLMarqueeElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_behavior: fn(
            self: *const IHTMLMarqueeElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollAmount: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollAmount: fn(
            self: *const IHTMLMarqueeElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_loop: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_loop: fn(
            self: *const IHTMLMarqueeElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vspace: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vspace: fn(
            self: *const IHTMLMarqueeElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hspace: fn(
            self: *const IHTMLMarqueeElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hspace: fn(
            self: *const IHTMLMarqueeElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfinish: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfinish: fn(
            self: *const IHTMLMarqueeElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstart: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstart: fn(
            self: *const IHTMLMarqueeElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbounce: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbounce: fn(
            self: *const IHTMLMarqueeElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLMarqueeElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLMarqueeElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLMarqueeElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_trueSpeed: fn(
            self: *const IHTMLMarqueeElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_trueSpeed: fn(
            self: *const IHTMLMarqueeElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        start: fn(
            self: *const IHTMLMarqueeElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stop: fn(
            self: *const IHTMLMarqueeElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_bgColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_scrollDelay(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_scrollDelay(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_scrollDelay(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_scrollDelay(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_direction(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_direction(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_direction(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_behavior(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_behavior(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_behavior(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_behavior(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_scrollAmount(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_scrollAmount(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_scrollAmount(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_scrollAmount(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_loop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_loop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_vspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_hspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_onfinish(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_onfinish(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_onfinish(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_onfinish(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_onstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_onstart(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_onstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_onstart(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_onbounce(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_onbounce(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_onbounce(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_onbounce(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_put_trueSpeed(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).put_trueSpeed(@ptrCast(*const IHTMLMarqueeElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_get_trueSpeed(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).get_trueSpeed(@ptrCast(*const IHTMLMarqueeElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_start(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).start(@ptrCast(*const IHTMLMarqueeElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMarqueeElement_stop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMarqueeElement.VTable, self.vtable).stop(@ptrCast(*const IHTMLMarqueeElement, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMarqueeElement_Value = @import("../zig.zig").Guid.initString("3050F527-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLMarqueeElement = &IID_DispHTMLMarqueeElement_Value;
pub const DispHTMLMarqueeElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHtmlElement_Value = @import("../zig.zig").Guid.initString("3050F81C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLHtmlElement = &IID_IHTMLHtmlElement_Value;
pub const IHTMLHtmlElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_version: fn(
            self: *const IHTMLHtmlElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_version: fn(
            self: *const IHTMLHtmlElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHtmlElement_put_version(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHtmlElement.VTable, self.vtable).put_version(@ptrCast(*const IHTMLHtmlElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHtmlElement_get_version(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHtmlElement.VTable, self.vtable).get_version(@ptrCast(*const IHTMLHtmlElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHeadElement_Value = @import("../zig.zig").Guid.initString("3050F81D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLHeadElement = &IID_IHTMLHeadElement_Value;
pub const IHTMLHeadElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_profile: fn(
            self: *const IHTMLHeadElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_profile: fn(
            self: *const IHTMLHeadElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeadElement_put_profile(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeadElement.VTable, self.vtable).put_profile(@ptrCast(*const IHTMLHeadElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeadElement_get_profile(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeadElement.VTable, self.vtable).get_profile(@ptrCast(*const IHTMLHeadElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLHeadElement2_Value = @import("../zig.zig").Guid.initString("3051042F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLHeadElement2 = &IID_IHTMLHeadElement2_Value;
pub const IHTMLHeadElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_profile: fn(
            self: *const IHTMLHeadElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_profile: fn(
            self: *const IHTMLHeadElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeadElement2_put_profile(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeadElement2.VTable, self.vtable).put_profile(@ptrCast(*const IHTMLHeadElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLHeadElement2_get_profile(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLHeadElement2.VTable, self.vtable).get_profile(@ptrCast(*const IHTMLHeadElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTitleElement_Value = @import("../zig.zig").Guid.initString("3050F322-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTitleElement = &IID_IHTMLTitleElement_Value;
pub const IHTMLTitleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_text: fn(
            self: *const IHTMLTitleElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_text: fn(
            self: *const IHTMLTitleElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTitleElement_put_text(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTitleElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLTitleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTitleElement_get_text(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTitleElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLTitleElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMetaElement_Value = @import("../zig.zig").Guid.initString("3050F203-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMetaElement = &IID_IHTMLMetaElement_Value;
pub const IHTMLMetaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_httpEquiv: fn(
            self: *const IHTMLMetaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_httpEquiv: fn(
            self: *const IHTMLMetaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_content: fn(
            self: *const IHTMLMetaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_content: fn(
            self: *const IHTMLMetaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLMetaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLMetaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_url: fn(
            self: *const IHTMLMetaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_url: fn(
            self: *const IHTMLMetaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_charset: fn(
            self: *const IHTMLMetaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_charset: fn(
            self: *const IHTMLMetaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_httpEquiv(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_httpEquiv(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_httpEquiv(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_httpEquiv(@ptrCast(*const IHTMLMetaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_content(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_content(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_content(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_content(@ptrCast(*const IHTMLMetaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLMetaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_url(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_url(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_url(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_url(@ptrCast(*const IHTMLMetaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_put_charset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLMetaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement_get_charset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLMetaElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMetaElement2_Value = @import("../zig.zig").Guid.initString("3050F81F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMetaElement2 = &IID_IHTMLMetaElement2_Value;
pub const IHTMLMetaElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_scheme: fn(
            self: *const IHTMLMetaElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scheme: fn(
            self: *const IHTMLMetaElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement2_put_scheme(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement2.VTable, self.vtable).put_scheme(@ptrCast(*const IHTMLMetaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement2_get_scheme(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement2.VTable, self.vtable).get_scheme(@ptrCast(*const IHTMLMetaElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMetaElement3_Value = @import("../zig.zig").Guid.initString("30510495-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMetaElement3 = &IID_IHTMLMetaElement3_Value;
pub const IHTMLMetaElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_url: fn(
            self: *const IHTMLMetaElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_url: fn(
            self: *const IHTMLMetaElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement3_put_url(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement3.VTable, self.vtable).put_url(@ptrCast(*const IHTMLMetaElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMetaElement3_get_url(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMetaElement3.VTable, self.vtable).get_url(@ptrCast(*const IHTMLMetaElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBaseElement_Value = @import("../zig.zig").Guid.initString("3050F204-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBaseElement = &IID_IHTMLBaseElement_Value;
pub const IHTMLBaseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_href: fn(
            self: *const IHTMLBaseElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLBaseElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_target: fn(
            self: *const IHTMLBaseElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_target: fn(
            self: *const IHTMLBaseElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement.VTable, self.vtable).put_href(@ptrCast(*const IHTMLBaseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLBaseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement_put_target(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement.VTable, self.vtable).put_target(@ptrCast(*const IHTMLBaseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement_get_target(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement.VTable, self.vtable).get_target(@ptrCast(*const IHTMLBaseElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBaseElement2_Value = @import("../zig.zig").Guid.initString("30510420-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBaseElement2 = &IID_IHTMLBaseElement2_Value;
pub const IHTMLBaseElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_href: fn(
            self: *const IHTMLBaseElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLBaseElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement2_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement2.VTable, self.vtable).put_href(@ptrCast(*const IHTMLBaseElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseElement2_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseElement2.VTable, self.vtable).get_href(@ptrCast(*const IHTMLBaseElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHtmlElement_Value = @import("../zig.zig").Guid.initString("3050F560-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLHtmlElement = &IID_DispHTMLHtmlElement_Value;
pub const DispHTMLHtmlElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHeadElement_Value = @import("../zig.zig").Guid.initString("3050F561-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLHeadElement = &IID_DispHTMLHeadElement_Value;
pub const DispHTMLHeadElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTitleElement_Value = @import("../zig.zig").Guid.initString("3050F516-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTitleElement = &IID_DispHTMLTitleElement_Value;
pub const DispHTMLTitleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMetaElement_Value = @import("../zig.zig").Guid.initString("3050F517-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLMetaElement = &IID_DispHTMLMetaElement_Value;
pub const DispHTMLMetaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBaseElement_Value = @import("../zig.zig").Guid.initString("3050F518-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLBaseElement = &IID_DispHTMLBaseElement_Value;
pub const DispHTMLBaseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIsIndexElement_Value = @import("../zig.zig").Guid.initString("3050F206-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLIsIndexElement = &IID_IHTMLIsIndexElement_Value;
pub const IHTMLIsIndexElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_prompt: fn(
            self: *const IHTMLIsIndexElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_prompt: fn(
            self: *const IHTMLIsIndexElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_action: fn(
            self: *const IHTMLIsIndexElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_action: fn(
            self: *const IHTMLIsIndexElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement_put_prompt(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement.VTable, self.vtable).put_prompt(@ptrCast(*const IHTMLIsIndexElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement_get_prompt(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement.VTable, self.vtable).get_prompt(@ptrCast(*const IHTMLIsIndexElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement_put_action(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement.VTable, self.vtable).put_action(@ptrCast(*const IHTMLIsIndexElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement_get_action(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement.VTable, self.vtable).get_action(@ptrCast(*const IHTMLIsIndexElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIsIndexElement2_Value = @import("../zig.zig").Guid.initString("3050F82F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLIsIndexElement2 = &IID_IHTMLIsIndexElement2_Value;
pub const IHTMLIsIndexElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_form: fn(
            self: *const IHTMLIsIndexElement2,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIsIndexElement2_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIsIndexElement2.VTable, self.vtable).get_form(@ptrCast(*const IHTMLIsIndexElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLNextIdElement_Value = @import("../zig.zig").Guid.initString("3050F207-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLNextIdElement = &IID_IHTMLNextIdElement_Value;
pub const IHTMLNextIdElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_n: fn(
            self: *const IHTMLNextIdElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_n: fn(
            self: *const IHTMLNextIdElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNextIdElement_put_n(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNextIdElement.VTable, self.vtable).put_n(@ptrCast(*const IHTMLNextIdElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNextIdElement_get_n(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNextIdElement.VTable, self.vtable).get_n(@ptrCast(*const IHTMLNextIdElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLIsIndexElement_Value = @import("../zig.zig").Guid.initString("3050F519-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLIsIndexElement = &IID_DispHTMLIsIndexElement_Value;
pub const DispHTMLIsIndexElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNextIdElement_Value = @import("../zig.zig").Guid.initString("3050F51A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLNextIdElement = &IID_DispHTMLNextIdElement_Value;
pub const DispHTMLNextIdElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBaseFontElement_Value = @import("../zig.zig").Guid.initString("3050F202-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBaseFontElement = &IID_IHTMLBaseFontElement_Value;
pub const IHTMLBaseFontElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_color: fn(
            self: *const IHTMLBaseFontElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_color: fn(
            self: *const IHTMLBaseFontElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_face: fn(
            self: *const IHTMLBaseFontElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_face: fn(
            self: *const IHTMLBaseFontElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_size: fn(
            self: *const IHTMLBaseFontElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_size: fn(
            self: *const IHTMLBaseFontElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_put_color(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).put_color(@ptrCast(*const IHTMLBaseFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_get_color(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).get_color(@ptrCast(*const IHTMLBaseFontElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_put_face(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).put_face(@ptrCast(*const IHTMLBaseFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_get_face(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).get_face(@ptrCast(*const IHTMLBaseFontElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_put_size(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).put_size(@ptrCast(*const IHTMLBaseFontElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBaseFontElement_get_size(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBaseFontElement.VTable, self.vtable).get_size(@ptrCast(*const IHTMLBaseFontElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBaseFontElement_Value = @import("../zig.zig").Guid.initString("3050F504-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLBaseFontElement = &IID_DispHTMLBaseFontElement_Value;
pub const DispHTMLBaseFontElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLUnknownElement_Value = @import("../zig.zig").Guid.initString("3050F209-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLUnknownElement = &IID_IHTMLUnknownElement_Value;
pub const IHTMLUnknownElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLUnknownElement_Value = @import("../zig.zig").Guid.initString("3050F539-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLUnknownElement = &IID_DispHTMLUnknownElement_Value;
pub const DispHTMLUnknownElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebGeolocation_Value = @import("../zig.zig").Guid.initString("305107C5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IWebGeolocation = &IID_IWebGeolocation_Value;
pub const IWebGeolocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getCurrentPosition: fn(
            self: *const IWebGeolocation,
            successCallback: *IDispatch,
            errorCallback: *IDispatch,
            options: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        watchPosition: fn(
            self: *const IWebGeolocation,
            successCallback: *IDispatch,
            errorCallback: *IDispatch,
            options: *IDispatch,
            watchId: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearWatch: fn(
            self: *const IWebGeolocation,
            watchId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeolocation_getCurrentPosition(self: *const T, successCallback: *IDispatch, errorCallback: *IDispatch, options: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeolocation.VTable, self.vtable).getCurrentPosition(@ptrCast(*const IWebGeolocation, self), successCallback, errorCallback, options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeolocation_watchPosition(self: *const T, successCallback: *IDispatch, errorCallback: *IDispatch, options: *IDispatch, watchId: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeolocation.VTable, self.vtable).watchPosition(@ptrCast(*const IWebGeolocation, self), successCallback, errorCallback, options, watchId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeolocation_clearWatch(self: *const T, watchId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeolocation.VTable, self.vtable).clearWatch(@ptrCast(*const IWebGeolocation, self), watchId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMimeTypesCollection_Value = @import("../zig.zig").Guid.initString("3050F3FC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMimeTypesCollection = &IID_IHTMLMimeTypesCollection_Value;
pub const IHTMLMimeTypesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLMimeTypesCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMimeTypesCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMimeTypesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLMimeTypesCollection, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPluginsCollection_Value = @import("../zig.zig").Guid.initString("3050F3FD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPluginsCollection = &IID_IHTMLPluginsCollection_Value;
pub const IHTMLPluginsCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLPluginsCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        refresh: fn(
            self: *const IHTMLPluginsCollection,
            reload: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPluginsCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPluginsCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLPluginsCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPluginsCollection_refresh(self: *const T, reload: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPluginsCollection.VTable, self.vtable).refresh(@ptrCast(*const IHTMLPluginsCollection, self), reload);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOmHistory_Value = @import("../zig.zig").Guid.initString("FECEAAA2-8405-11CF-8BA1-00AA00476DA6");
pub const IID_IOmHistory = &IID_IOmHistory_Value;
pub const IOmHistory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IOmHistory,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        back: fn(
            self: *const IOmHistory,
            pvargdistance: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        forward: fn(
            self: *const IOmHistory,
            pvargdistance: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        go: fn(
            self: *const IOmHistory,
            pvargdistance: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmHistory_get_length(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmHistory.VTable, self.vtable).get_length(@ptrCast(*const IOmHistory, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmHistory_back(self: *const T, pvargdistance: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmHistory.VTable, self.vtable).back(@ptrCast(*const IOmHistory, self), pvargdistance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmHistory_forward(self: *const T, pvargdistance: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmHistory.VTable, self.vtable).forward(@ptrCast(*const IOmHistory, self), pvargdistance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmHistory_go(self: *const T, pvargdistance: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmHistory.VTable, self.vtable).go(@ptrCast(*const IOmHistory, self), pvargdistance);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOpsProfile_Value = @import("../zig.zig").Guid.initString("3050F401-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLOpsProfile = &IID_IHTMLOpsProfile_Value;
pub const IHTMLOpsProfile = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addRequest: fn(
            self: *const IHTMLOpsProfile,
            name: BSTR,
            reserved: VARIANT,
            success: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearRequest: fn(
            self: *const IHTMLOpsProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doRequest: fn(
            self: *const IHTMLOpsProfile,
            usage: VARIANT,
            fname: VARIANT,
            domain: VARIANT,
            path: VARIANT,
            expire: VARIANT,
            reserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLOpsProfile,
            name: BSTR,
            value: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setAttribute: fn(
            self: *const IHTMLOpsProfile,
            name: BSTR,
            value: BSTR,
            prefs: VARIANT,
            success: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        commitChanges: fn(
            self: *const IHTMLOpsProfile,
            success: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addReadRequest: fn(
            self: *const IHTMLOpsProfile,
            name: BSTR,
            reserved: VARIANT,
            success: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doReadRequest: fn(
            self: *const IHTMLOpsProfile,
            usage: VARIANT,
            fname: VARIANT,
            domain: VARIANT,
            path: VARIANT,
            expire: VARIANT,
            reserved: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doWriteRequest: fn(
            self: *const IHTMLOpsProfile,
            success: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_addRequest(self: *const T, name: BSTR, reserved: VARIANT, success: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).addRequest(@ptrCast(*const IHTMLOpsProfile, self), name, reserved, success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_clearRequest(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).clearRequest(@ptrCast(*const IHTMLOpsProfile, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_doRequest(self: *const T, usage: VARIANT, fname: VARIANT, domain: VARIANT, path: VARIANT, expire: VARIANT, reserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).doRequest(@ptrCast(*const IHTMLOpsProfile, self), usage, fname, domain, path, expire, reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_getAttribute(self: *const T, name: BSTR, value: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLOpsProfile, self), name, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_setAttribute(self: *const T, name: BSTR, value: BSTR, prefs: VARIANT, success: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLOpsProfile, self), name, value, prefs, success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_commitChanges(self: *const T, success: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).commitChanges(@ptrCast(*const IHTMLOpsProfile, self), success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_addReadRequest(self: *const T, name: BSTR, reserved: VARIANT, success: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).addReadRequest(@ptrCast(*const IHTMLOpsProfile, self), name, reserved, success);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_doReadRequest(self: *const T, usage: VARIANT, fname: VARIANT, domain: VARIANT, path: VARIANT, expire: VARIANT, reserved: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).doReadRequest(@ptrCast(*const IHTMLOpsProfile, self), usage, fname, domain, path, expire, reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOpsProfile_doWriteRequest(self: *const T, success: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOpsProfile.VTable, self.vtable).doWriteRequest(@ptrCast(*const IHTMLOpsProfile, self), success);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IOmNavigator_Value = @import("../zig.zig").Guid.initString("FECEAAA5-8405-11CF-8BA1-00AA00476DA6");
pub const IID_IOmNavigator = &IID_IOmNavigator_Value;
pub const IOmNavigator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_appCodeName: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_appName: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_appVersion: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_userAgent: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        javaEnabled: fn(
            self: *const IOmNavigator,
            enabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        taintEnabled: fn(
            self: *const IOmNavigator,
            enabled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_mimeTypes: fn(
            self: *const IOmNavigator,
            p: **IHTMLMimeTypesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_plugins: fn(
            self: *const IOmNavigator,
            p: **IHTMLPluginsCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cookieEnabled: fn(
            self: *const IOmNavigator,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_opsProfile: fn(
            self: *const IOmNavigator,
            p: **IHTMLOpsProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IOmNavigator,
            string: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cpuClass: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_systemLanguage: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_browserLanguage: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_userLanguage: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_platform: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_appMinorVersion: fn(
            self: *const IOmNavigator,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_connectionSpeed: fn(
            self: *const IOmNavigator,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onLine: fn(
            self: *const IOmNavigator,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_userProfile: fn(
            self: *const IOmNavigator,
            p: **IHTMLOpsProfile,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_appCodeName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_appCodeName(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_appName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_appName(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_appVersion(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_appVersion(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_userAgent(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_userAgent(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_javaEnabled(self: *const T, enabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).javaEnabled(@ptrCast(*const IOmNavigator, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_taintEnabled(self: *const T, enabled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).taintEnabled(@ptrCast(*const IOmNavigator, self), enabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_mimeTypes(self: *const T, p: **IHTMLMimeTypesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_mimeTypes(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_plugins(self: *const T, p: **IHTMLPluginsCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_plugins(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_cookieEnabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_cookieEnabled(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_opsProfile(self: *const T, p: **IHTMLOpsProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_opsProfile(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_toString(self: *const T, string: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).toString(@ptrCast(*const IOmNavigator, self), string);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_cpuClass(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_cpuClass(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_systemLanguage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_systemLanguage(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_browserLanguage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_browserLanguage(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_userLanguage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_userLanguage(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_platform(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_platform(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_appMinorVersion(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_appMinorVersion(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_connectionSpeed(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_connectionSpeed(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_onLine(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_onLine(@ptrCast(*const IOmNavigator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IOmNavigator_get_userProfile(self: *const T, p: **IHTMLOpsProfile) callconv(.Inline) HRESULT {
            return @ptrCast(*const IOmNavigator.VTable, self.vtable).get_userProfile(@ptrCast(*const IOmNavigator, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_INavigatorGeolocation_Value = @import("../zig.zig").Guid.initString("305107CF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_INavigatorGeolocation = &IID_INavigatorGeolocation_Value;
pub const INavigatorGeolocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_geolocation: fn(
            self: *const INavigatorGeolocation,
            p: **IWebGeolocation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INavigatorGeolocation_get_geolocation(self: *const T, p: **IWebGeolocation) callconv(.Inline) HRESULT {
            return @ptrCast(*const INavigatorGeolocation.VTable, self.vtable).get_geolocation(@ptrCast(*const INavigatorGeolocation, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_INavigatorDoNotTrack_Value = @import("../zig.zig").Guid.initString("30510804-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_INavigatorDoNotTrack = &IID_INavigatorDoNotTrack_Value;
pub const INavigatorDoNotTrack = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_msDoNotTrack: fn(
            self: *const INavigatorDoNotTrack,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn INavigatorDoNotTrack_get_msDoNotTrack(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const INavigatorDoNotTrack.VTable, self.vtable).get_msDoNotTrack(@ptrCast(*const INavigatorDoNotTrack, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLocation_Value = @import("../zig.zig").Guid.initString("163BB1E0-6E00-11CF-837A-48DC04C10000");
pub const IID_IHTMLLocation = &IID_IHTMLLocation_Value;
pub const IHTMLLocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_href: fn(
            self: *const IHTMLLocation,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLLocation,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_protocol: fn(
            self: *const IHTMLLocation,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_protocol: fn(
            self: *const IHTMLLocation,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_host: fn(
            self: *const IHTMLLocation,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_host: fn(
            self: *const IHTMLLocation,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hostname: fn(
            self: *const IHTMLLocation,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hostname: fn(
            self: *const IHTMLLocation,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_port: fn(
            self: *const IHTMLLocation,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_port: fn(
            self: *const IHTMLLocation,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pathname: fn(
            self: *const IHTMLLocation,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pathname: fn(
            self: *const IHTMLLocation,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_search: fn(
            self: *const IHTMLLocation,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_search: fn(
            self: *const IHTMLLocation,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hash: fn(
            self: *const IHTMLLocation,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hash: fn(
            self: *const IHTMLLocation,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        reload: fn(
            self: *const IHTMLLocation,
            flag: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replace: fn(
            self: *const IHTMLLocation,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        assign: fn(
            self: *const IHTMLLocation,
            bstr: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLLocation,
            string: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_href(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_href(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_protocol(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_protocol(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_protocol(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_host(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_host(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_host(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_host(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_hostname(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_hostname(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_hostname(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_hostname(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_port(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_port(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_port(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_port(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_pathname(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_pathname(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_pathname(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_pathname(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_search(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_search(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_search(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_search(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_put_hash(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).put_hash(@ptrCast(*const IHTMLLocation, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_get_hash(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).get_hash(@ptrCast(*const IHTMLLocation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_reload(self: *const T, flag: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).reload(@ptrCast(*const IHTMLLocation, self), flag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_replace(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).replace(@ptrCast(*const IHTMLLocation, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_assign(self: *const T, bstr: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).assign(@ptrCast(*const IHTMLLocation, self), bstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLocation_toString(self: *const T, string: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLocation.VTable, self.vtable).toString(@ptrCast(*const IHTMLLocation, self), string);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLHistory_Value = @import("../zig.zig").Guid.initString("3050F549-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLHistory = &IID_DispHTMLHistory_Value;
pub const DispHTMLHistory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNavigator_Value = @import("../zig.zig").Guid.initString("3050F54C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLNavigator = &IID_DispHTMLNavigator_Value;
pub const DispHTMLNavigator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLocation_Value = @import("../zig.zig").Guid.initString("3050F54E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLLocation = &IID_DispHTMLLocation_Value;
pub const DispHTMLLocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCPlugins_Value = @import("../zig.zig").Guid.initString("3050F54A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispCPlugins = &IID_DispCPlugins_Value;
pub const DispCPlugins = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBookmarkCollection_Value = @import("../zig.zig").Guid.initString("3050F4CE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBookmarkCollection = &IID_IHTMLBookmarkCollection_Value;
pub const IHTMLBookmarkCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLBookmarkCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLBookmarkCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLBookmarkCollection,
            index: i32,
            pVarBookmark: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBookmarkCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBookmarkCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLBookmarkCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBookmarkCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBookmarkCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLBookmarkCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBookmarkCollection_item(self: *const T, index: i32, pVarBookmark: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBookmarkCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLBookmarkCollection, self), index, pVarBookmark);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDataTransfer_Value = @import("../zig.zig").Guid.initString("3050F4B3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDataTransfer = &IID_IHTMLDataTransfer_Value;
pub const IHTMLDataTransfer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        setData: fn(
            self: *const IHTMLDataTransfer,
            format: BSTR,
            data: *VARIANT,
            pret: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getData: fn(
            self: *const IHTMLDataTransfer,
            format: BSTR,
            pvarRet: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearData: fn(
            self: *const IHTMLDataTransfer,
            format: BSTR,
            pret: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dropEffect: fn(
            self: *const IHTMLDataTransfer,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dropEffect: fn(
            self: *const IHTMLDataTransfer,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_effectAllowed: fn(
            self: *const IHTMLDataTransfer,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_effectAllowed: fn(
            self: *const IHTMLDataTransfer,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_setData(self: *const T, format: BSTR, data: *VARIANT, pret: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).setData(@ptrCast(*const IHTMLDataTransfer, self), format, data, pret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_getData(self: *const T, format: BSTR, pvarRet: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).getData(@ptrCast(*const IHTMLDataTransfer, self), format, pvarRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_clearData(self: *const T, format: BSTR, pret: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).clearData(@ptrCast(*const IHTMLDataTransfer, self), format, pret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_put_dropEffect(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).put_dropEffect(@ptrCast(*const IHTMLDataTransfer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_get_dropEffect(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).get_dropEffect(@ptrCast(*const IHTMLDataTransfer, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_put_effectAllowed(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).put_effectAllowed(@ptrCast(*const IHTMLDataTransfer, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDataTransfer_get_effectAllowed(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDataTransfer.VTable, self.vtable).get_effectAllowed(@ptrCast(*const IHTMLDataTransfer, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj2_Value = @import("../zig.zig").Guid.initString("3050F48B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEventObj2 = &IID_IHTMLEventObj2_Value;
pub const IHTMLEventObj2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        setAttribute: fn(
            self: *const IHTMLEventObj2,
            strAttributeName: BSTR,
            AttributeValue: VARIANT,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAttribute: fn(
            self: *const IHTMLEventObj2,
            strAttributeName: BSTR,
            lFlags: i32,
            AttributeValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeAttribute: fn(
            self: *const IHTMLEventObj2,
            strAttributeName: BSTR,
            lFlags: i32,
            pfSuccess: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_propertyName: fn(
            self: *const IHTMLEventObj2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_propertyName: fn(
            self: *const IHTMLEventObj2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_bookmarks: fn(
            self: *const IHTMLEventObj2,
            v: *IHTMLBookmarkCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bookmarks: fn(
            self: *const IHTMLEventObj2,
            p: **IHTMLBookmarkCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_recordset: fn(
            self: *const IHTMLEventObj2,
            v: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_recordset: fn(
            self: *const IHTMLEventObj2,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dataFld: fn(
            self: *const IHTMLEventObj2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dataFld: fn(
            self: *const IHTMLEventObj2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_boundElements: fn(
            self: *const IHTMLEventObj2,
            v: *IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_boundElements: fn(
            self: *const IHTMLEventObj2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_repeat: fn(
            self: *const IHTMLEventObj2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_repeat: fn(
            self: *const IHTMLEventObj2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_srcUrn: fn(
            self: *const IHTMLEventObj2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_srcUrn: fn(
            self: *const IHTMLEventObj2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_srcElement: fn(
            self: *const IHTMLEventObj2,
            v: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_srcElement: fn(
            self: *const IHTMLEventObj2,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_altKey: fn(
            self: *const IHTMLEventObj2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_altKey: fn(
            self: *const IHTMLEventObj2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ctrlKey: fn(
            self: *const IHTMLEventObj2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ctrlKey: fn(
            self: *const IHTMLEventObj2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_shiftKey: fn(
            self: *const IHTMLEventObj2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shiftKey: fn(
            self: *const IHTMLEventObj2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_fromElement: fn(
            self: *const IHTMLEventObj2,
            v: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fromElement: fn(
            self: *const IHTMLEventObj2,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_toElement: fn(
            self: *const IHTMLEventObj2,
            v: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_toElement: fn(
            self: *const IHTMLEventObj2,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_button: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_button: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLEventObj2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLEventObj2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_qualifier: fn(
            self: *const IHTMLEventObj2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_qualifier: fn(
            self: *const IHTMLEventObj2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_reason: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_reason: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_x: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clientX: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientX: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_clientY: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientY: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_offsetX: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetX: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_offsetY: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetY: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_screenX: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenX: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_screenY: fn(
            self: *const IHTMLEventObj2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenY: fn(
            self: *const IHTMLEventObj2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_srcFilter: fn(
            self: *const IHTMLEventObj2,
            v: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_srcFilter: fn(
            self: *const IHTMLEventObj2,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dataTransfer: fn(
            self: *const IHTMLEventObj2,
            p: **IHTMLDataTransfer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_setAttribute(self: *const T, strAttributeName: BSTR, AttributeValue: VARIANT, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).setAttribute(@ptrCast(*const IHTMLEventObj2, self), strAttributeName, AttributeValue, lFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_getAttribute(self: *const T, strAttributeName: BSTR, lFlags: i32, AttributeValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).getAttribute(@ptrCast(*const IHTMLEventObj2, self), strAttributeName, lFlags, AttributeValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_removeAttribute(self: *const T, strAttributeName: BSTR, lFlags: i32, pfSuccess: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).removeAttribute(@ptrCast(*const IHTMLEventObj2, self), strAttributeName, lFlags, pfSuccess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_propertyName(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_propertyName(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_propertyName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_propertyName(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_bookmarks(self: *const T, v: *IHTMLBookmarkCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_bookmarks(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_bookmarks(self: *const T, p: **IHTMLBookmarkCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_bookmarks(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_recordset(self: *const T, v: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_recordset(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_recordset(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_recordset(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_dataFld(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_dataFld(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_dataFld(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_dataFld(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_boundElements(self: *const T, v: *IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_boundElements(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_boundElements(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_boundElements(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_repeat(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_repeat(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_repeat(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_repeat(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_srcUrn(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_srcUrn(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_srcUrn(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_srcUrn(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_srcElement(self: *const T, v: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_srcElement(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_srcElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_srcElement(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_altKey(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_altKey(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_altKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_altKey(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_ctrlKey(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_ctrlKey(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_ctrlKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_ctrlKey(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_shiftKey(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_shiftKey(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_shiftKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_shiftKey(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_fromElement(self: *const T, v: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_fromElement(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_fromElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_fromElement(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_toElement(self: *const T, v: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_toElement(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_toElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_toElement(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_button(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_button(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_button(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_button(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_type(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_type(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_qualifier(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_qualifier(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_qualifier(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_qualifier(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_reason(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_reason(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_reason(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_reason(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_x(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_x(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_x(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_x(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_y(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_y(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_y(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_y(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_clientX(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_clientX(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_clientX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_clientX(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_clientY(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_clientY(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_clientY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_clientY(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_offsetX(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_offsetX(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_offsetX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_offsetX(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_offsetY(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_offsetY(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_offsetY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_offsetY(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_screenX(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_screenX(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_screenX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_screenX(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_put_screenY(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).put_screenY(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_screenY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_screenY(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_putref_srcFilter(self: *const T, v: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).putref_srcFilter(@ptrCast(*const IHTMLEventObj2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_srcFilter(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_srcFilter(@ptrCast(*const IHTMLEventObj2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj2_get_dataTransfer(self: *const T, p: **IHTMLDataTransfer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj2.VTable, self.vtable).get_dataTransfer(@ptrCast(*const IHTMLEventObj2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj3_Value = @import("../zig.zig").Guid.initString("3050F680-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEventObj3 = &IID_IHTMLEventObj3_Value;
pub const IHTMLEventObj3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_contentOverflow: fn(
            self: *const IHTMLEventObj3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_shiftLeft: fn(
            self: *const IHTMLEventObj3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shiftLeft: fn(
            self: *const IHTMLEventObj3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_altLeft: fn(
            self: *const IHTMLEventObj3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_altLeft: fn(
            self: *const IHTMLEventObj3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ctrlLeft: fn(
            self: *const IHTMLEventObj3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ctrlLeft: fn(
            self: *const IHTMLEventObj3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imeCompositionChange: fn(
            self: *const IHTMLEventObj3,
            p: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imeNotifyCommand: fn(
            self: *const IHTMLEventObj3,
            p: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imeNotifyData: fn(
            self: *const IHTMLEventObj3,
            p: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imeRequest: fn(
            self: *const IHTMLEventObj3,
            p: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_imeRequestData: fn(
            self: *const IHTMLEventObj3,
            p: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_keyboardLayout: fn(
            self: *const IHTMLEventObj3,
            p: *?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_behaviorCookie: fn(
            self: *const IHTMLEventObj3,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_behaviorPart: fn(
            self: *const IHTMLEventObj3,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nextPage: fn(
            self: *const IHTMLEventObj3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_contentOverflow(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_contentOverflow(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_put_shiftLeft(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).put_shiftLeft(@ptrCast(*const IHTMLEventObj3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_shiftLeft(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_shiftLeft(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_put_altLeft(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).put_altLeft(@ptrCast(*const IHTMLEventObj3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_altLeft(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_altLeft(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_put_ctrlLeft(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).put_ctrlLeft(@ptrCast(*const IHTMLEventObj3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_ctrlLeft(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_ctrlLeft(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeCompositionChange(self: *const T, p: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeCompositionChange(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeNotifyCommand(self: *const T, p: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeNotifyCommand(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeNotifyData(self: *const T, p: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeNotifyData(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeRequest(self: *const T, p: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeRequest(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_imeRequestData(self: *const T, p: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_imeRequestData(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_keyboardLayout(self: *const T, p: *?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_keyboardLayout(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_behaviorCookie(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_behaviorCookie(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_behaviorPart(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_behaviorPart(@ptrCast(*const IHTMLEventObj3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj3_get_nextPage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj3.VTable, self.vtable).get_nextPage(@ptrCast(*const IHTMLEventObj3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj4_Value = @import("../zig.zig").Guid.initString("3050F814-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEventObj4 = &IID_IHTMLEventObj4_Value;
pub const IHTMLEventObj4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_wheelDelta: fn(
            self: *const IHTMLEventObj4,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj4_get_wheelDelta(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj4.VTable, self.vtable).get_wheelDelta(@ptrCast(*const IHTMLEventObj4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj5_Value = @import("../zig.zig").Guid.initString("30510478-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEventObj5 = &IID_IHTMLEventObj5_Value;
pub const IHTMLEventObj5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_url: fn(
            self: *const IHTMLEventObj5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_url: fn(
            self: *const IHTMLEventObj5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_data: fn(
            self: *const IHTMLEventObj5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_data: fn(
            self: *const IHTMLEventObj5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_source: fn(
            self: *const IHTMLEventObj5,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_origin: fn(
            self: *const IHTMLEventObj5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_origin: fn(
            self: *const IHTMLEventObj5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_issession: fn(
            self: *const IHTMLEventObj5,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_issession: fn(
            self: *const IHTMLEventObj5,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_put_url(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).put_url(@ptrCast(*const IHTMLEventObj5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_url(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_url(@ptrCast(*const IHTMLEventObj5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_put_data(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).put_data(@ptrCast(*const IHTMLEventObj5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_data(@ptrCast(*const IHTMLEventObj5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_source(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_source(@ptrCast(*const IHTMLEventObj5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_put_origin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).put_origin(@ptrCast(*const IHTMLEventObj5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_origin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_origin(@ptrCast(*const IHTMLEventObj5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_put_issession(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).put_issession(@ptrCast(*const IHTMLEventObj5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj5_get_issession(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj5.VTable, self.vtable).get_issession(@ptrCast(*const IHTMLEventObj5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEventObj6_Value = @import("../zig.zig").Guid.initString("30510734-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEventObj6 = &IID_IHTMLEventObj6_Value;
pub const IHTMLEventObj6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_actionURL: fn(
            self: *const IHTMLEventObj6,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_buttonID: fn(
            self: *const IHTMLEventObj6,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj6_get_actionURL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj6.VTable, self.vtable).get_actionURL(@ptrCast(*const IHTMLEventObj6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEventObj6_get_buttonID(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEventObj6.VTable, self.vtable).get_buttonID(@ptrCast(*const IHTMLEventObj6, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCEventObj_Value = @import("../zig.zig").Guid.initString("3050F558-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispCEventObj = &IID_DispCEventObj_Value;
pub const DispCEventObj = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleMedia_Value = @import("../zig.zig").Guid.initString("3051074B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleMedia = &IID_IHTMLStyleMedia_Value;
pub const IHTMLStyleMedia = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLStyleMedia,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        matchMedium: fn(
            self: *const IHTMLStyleMedia,
            mediaQuery: BSTR,
            matches: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleMedia_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleMedia.VTable, self.vtable).get_type(@ptrCast(*const IHTMLStyleMedia, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleMedia_matchMedium(self: *const T, mediaQuery: BSTR, matches: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleMedia.VTable, self.vtable).matchMedium(@ptrCast(*const IHTMLStyleMedia, self), mediaQuery, matches);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleMedia_Value = @import("../zig.zig").Guid.initString("3059009E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleMedia = &IID_DispHTMLStyleMedia_Value;
pub const DispHTMLStyleMedia = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFramesCollection2_Value = @import("../zig.zig").Guid.initString("332C4426-26CB-11D0-B483-00C04FD90119");
pub const IID_IHTMLFramesCollection2 = &IID_IHTMLFramesCollection2_Value;
pub const IHTMLFramesCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IHTMLFramesCollection2,
            pvarIndex: *VARIANT,
            pvarResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLFramesCollection2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFramesCollection2_item(self: *const T, pvarIndex: *VARIANT, pvarResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFramesCollection2.VTable, self.vtable).item(@ptrCast(*const IHTMLFramesCollection2, self), pvarIndex, pvarResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFramesCollection2_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFramesCollection2.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFramesCollection2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLWindowEvents3_Value = @import("../zig.zig").Guid.initString("3050F5A1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLWindowEvents3 = &IID_HTMLWindowEvents3_Value;
pub const HTMLWindowEvents3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLWindowEvents2_Value = @import("../zig.zig").Guid.initString("3050F625-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLWindowEvents2 = &IID_HTMLWindowEvents2_Value;
pub const HTMLWindowEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLWindowEvents_Value = @import("../zig.zig").Guid.initString("96A0A4E0-D062-11CF-94B6-00AA0060275C");
pub const IID_HTMLWindowEvents = &IID_HTMLWindowEvents_Value;
pub const HTMLWindowEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument2_Value = @import("../zig.zig").Guid.initString("332C4425-26CB-11D0-B483-00C04FD90119");
pub const IID_IHTMLDocument2 = &IID_IHTMLDocument2_Value;
pub const IHTMLDocument2 = extern struct {
    pub const VTable = extern struct {
        base: IHTMLDocument.VTable,
        get_all: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_body: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_activeElement: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_images: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_applets: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_links: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_forms: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_anchors: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_title: fn(
            self: *const IHTMLDocument2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_title: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scripts: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_designMode: fn(
            self: *const IHTMLDocument2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_designMode: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selection: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLSelectionObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frames: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLFramesCollection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_embeds: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_plugins: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alinkColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alinkColor: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bgColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bgColor: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fgColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fgColor: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_linkColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_linkColor: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vlinkColor: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vlinkColor: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_referrer: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_location: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLLocation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lastModified: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_URL: fn(
            self: *const IHTMLDocument2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_URL: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_domain: fn(
            self: *const IHTMLDocument2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_domain: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cookie: fn(
            self: *const IHTMLDocument2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cookie: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_expando: fn(
            self: *const IHTMLDocument2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_expando: fn(
            self: *const IHTMLDocument2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_charset: fn(
            self: *const IHTMLDocument2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_charset: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultCharset: fn(
            self: *const IHTMLDocument2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultCharset: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_mimeType: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileSize: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileCreatedDate: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileModifiedDate: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fileUpdatedDate: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_security: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_protocol: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nameProp: fn(
            self: *const IHTMLDocument2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        write: fn(
            self: *const IHTMLDocument2,
            psarray: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        writeln: fn(
            self: *const IHTMLDocument2,
            psarray: *SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        open: fn(
            self: *const IHTMLDocument2,
            url: BSTR,
            name: VARIANT,
            features: VARIANT,
            replace: VARIANT,
            pomWindowResult: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        close: fn(
            self: *const IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandSupported: fn(
            self: *const IHTMLDocument2,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandEnabled: fn(
            self: *const IHTMLDocument2,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandState: fn(
            self: *const IHTMLDocument2,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandIndeterm: fn(
            self: *const IHTMLDocument2,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandText: fn(
            self: *const IHTMLDocument2,
            cmdID: BSTR,
            pcmdText: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        queryCommandValue: fn(
            self: *const IHTMLDocument2,
            cmdID: BSTR,
            pcmdValue: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommand: fn(
            self: *const IHTMLDocument2,
            cmdID: BSTR,
            showUI: i16,
            value: VARIANT,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execCommandShowHelp: fn(
            self: *const IHTMLDocument2,
            cmdID: BSTR,
            pfRet: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createElement: fn(
            self: *const IHTMLDocument2,
            eTag: BSTR,
            newElem: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onhelp: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onhelp: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onclick: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onclick: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondblclick: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondblclick: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onkeyup: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onkeyup: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onkeydown: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onkeydown: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onkeypress: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onkeypress: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseup: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseup: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmousedown: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmousedown: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmousemove: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmousemove: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseout: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseout: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseover: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseover: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onafterupdate: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onafterupdate: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onrowexit: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onrowexit: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onrowenter: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onrowenter: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragstart: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragstart: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselectstart: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselectstart: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        elementFromPoint: fn(
            self: *const IHTMLDocument2,
            x: i32,
            y: i32,
            elementHit: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentWindow: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_styleSheets: fn(
            self: *const IHTMLDocument2,
            p: **IHTMLStyleSheetsCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeupdate: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeupdate: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerrorupdate: fn(
            self: *const IHTMLDocument2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerrorupdate: fn(
            self: *const IHTMLDocument2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLDocument2,
            String: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createStyleSheet: fn(
            self: *const IHTMLDocument2,
            bstrHref: BSTR,
            lIndex: i32,
            ppnewStyleSheet: **IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHTMLDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_all(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_all(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_body(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_body(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_activeElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_activeElement(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_images(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_images(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_applets(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_applets(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_links(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_links(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_forms(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_forms(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_anchors(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_anchors(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_title(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_title(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_title(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_title(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_scripts(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_scripts(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_designMode(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_designMode(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_designMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_designMode(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_selection(self: *const T, p: **IHTMLSelectionObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_selection(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_readyState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_frames(self: *const T, p: **IHTMLFramesCollection2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_frames(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_embeds(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_embeds(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_plugins(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_plugins(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_alinkColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_alinkColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_alinkColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_alinkColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_bgColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_fgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_fgColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fgColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fgColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_linkColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_linkColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_linkColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_linkColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_vlinkColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_vlinkColor(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_vlinkColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_vlinkColor(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_referrer(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_referrer(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_location(self: *const T, p: **IHTMLLocation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_location(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_lastModified(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_lastModified(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_URL(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_URL(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_URL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_URL(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_domain(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_domain(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_domain(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_domain(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_cookie(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_cookie(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_cookie(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_cookie(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_expando(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_expando(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_expando(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_expando(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_charset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_charset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_defaultCharset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_defaultCharset(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_defaultCharset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_defaultCharset(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_mimeType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_mimeType(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fileSize(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fileSize(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fileCreatedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fileCreatedDate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fileModifiedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fileModifiedDate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_fileUpdatedDate(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_fileUpdatedDate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_security(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_security(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_protocol(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_nameProp(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_nameProp(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_write(self: *const T, psarray: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).write(@ptrCast(*const IHTMLDocument2, self), psarray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_writeln(self: *const T, psarray: *SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).writeln(@ptrCast(*const IHTMLDocument2, self), psarray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_open(self: *const T, url: BSTR, name: VARIANT, features: VARIANT, replace: VARIANT, pomWindowResult: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).open(@ptrCast(*const IHTMLDocument2, self), url, name, features, replace, pomWindowResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).close(@ptrCast(*const IHTMLDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).clear(@ptrCast(*const IHTMLDocument2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandSupported(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandSupported(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandEnabled(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandEnabled(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandState(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandState(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandIndeterm(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandIndeterm(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandText(self: *const T, cmdID: BSTR, pcmdText: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandText(@ptrCast(*const IHTMLDocument2, self), cmdID, pcmdText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_queryCommandValue(self: *const T, cmdID: BSTR, pcmdValue: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).queryCommandValue(@ptrCast(*const IHTMLDocument2, self), cmdID, pcmdValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_execCommand(self: *const T, cmdID: BSTR, showUI: i16, value: VARIANT, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).execCommand(@ptrCast(*const IHTMLDocument2, self), cmdID, showUI, value, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_execCommandShowHelp(self: *const T, cmdID: BSTR, pfRet: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).execCommandShowHelp(@ptrCast(*const IHTMLDocument2, self), cmdID, pfRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_createElement(self: *const T, eTag: BSTR, newElem: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).createElement(@ptrCast(*const IHTMLDocument2, self), eTag, newElem);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onhelp(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onhelp(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onhelp(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onhelp(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onclick(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onclick(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onclick(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_ondblclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_ondblclick(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_ondblclick(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_ondblclick(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onkeyup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onkeyup(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onkeyup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onkeyup(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onkeydown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onkeydown(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onkeydown(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onkeydown(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onkeypress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onkeypress(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onkeypress(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onkeypress(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmouseup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmouseup(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmouseup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmouseup(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmousedown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmousedown(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmousedown(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmousedown(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmousemove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmousemove(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmousemove(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmousemove(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmouseout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmouseout(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmouseout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmouseout(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onmouseover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onmouseover(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onmouseover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onmouseover(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onafterupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onafterupdate(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onafterupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onafterupdate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onrowexit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onrowexit(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onrowexit(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onrowexit(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onrowenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onrowenter(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onrowenter(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onrowenter(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_ondragstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_ondragstart(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_ondragstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_ondragstart(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onselectstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onselectstart(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onselectstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onselectstart(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_elementFromPoint(self: *const T, x: i32, y: i32, elementHit: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).elementFromPoint(@ptrCast(*const IHTMLDocument2, self), x, y, elementHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_parentWindow(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_parentWindow(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_styleSheets(self: *const T, p: **IHTMLStyleSheetsCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_styleSheets(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onbeforeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onbeforeupdate(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onbeforeupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onbeforeupdate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_put_onerrorupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).put_onerrorupdate(@ptrCast(*const IHTMLDocument2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_get_onerrorupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).get_onerrorupdate(@ptrCast(*const IHTMLDocument2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_toString(self: *const T, String: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).toString(@ptrCast(*const IHTMLDocument2, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument2_createStyleSheet(self: *const T, bstrHref: BSTR, lIndex: i32, ppnewStyleSheet: **IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument2.VTable, self.vtable).createStyleSheet(@ptrCast(*const IHTMLDocument2, self), bstrHref, lIndex, ppnewStyleSheet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow2_Value = @import("../zig.zig").Guid.initString("332C4427-26CB-11D0-B483-00C04FD90119");
pub const IID_IHTMLWindow2 = &IID_IHTMLWindow2_Value;
pub const IHTMLWindow2 = extern struct {
    pub const VTable = extern struct {
        base: IHTMLFramesCollection2.VTable,
        get_frames: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLFramesCollection2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultStatus: fn(
            self: *const IHTMLWindow2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultStatus: fn(
            self: *const IHTMLWindow2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_status: fn(
            self: *const IHTMLWindow2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLWindow2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setTimeout: fn(
            self: *const IHTMLWindow2,
            expression: BSTR,
            msec: i32,
            language: *VARIANT,
            timerID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearTimeout: fn(
            self: *const IHTMLWindow2,
            timerID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        alert: fn(
            self: *const IHTMLWindow2,
            message: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        confirm: fn(
            self: *const IHTMLWindow2,
            message: BSTR,
            confirmed: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        prompt: fn(
            self: *const IHTMLWindow2,
            message: BSTR,
            defstr: BSTR,
            textdata: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Image: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLImageElementFactory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_location: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLLocation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_history: fn(
            self: *const IHTMLWindow2,
            p: **IOmHistory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        close: fn(
            self: *const IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_opener: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_opener: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_navigator: fn(
            self: *const IHTMLWindow2,
            p: **IOmNavigator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLWindow2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLWindow2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parent: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        open: fn(
            self: *const IHTMLWindow2,
            url: BSTR,
            name: BSTR,
            features: BSTR,
            replace: i16,
            pomWindowResult: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_self: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_top: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_window: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        navigate: fn(
            self: *const IHTMLWindow2,
            url: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocus: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocus: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onblur: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onblur: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeunload: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeunload: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onunload: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onunload: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onhelp: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onhelp: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onresize: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onresize: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onscroll: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onscroll: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_document: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_event: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLWindow2,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showModalDialog: fn(
            self: *const IHTMLWindow2,
            dialog: BSTR,
            varArgIn: *VARIANT,
            varOptions: *VARIANT,
            varArgOut: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showHelp: fn(
            self: *const IHTMLWindow2,
            helpURL: BSTR,
            helpArg: VARIANT,
            features: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screen: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLScreen,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Option: fn(
            self: *const IHTMLWindow2,
            p: **IHTMLOptionElementFactory,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_closed: fn(
            self: *const IHTMLWindow2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scroll: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientInformation: fn(
            self: *const IHTMLWindow2,
            p: **IOmNavigator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setInterval: fn(
            self: *const IHTMLWindow2,
            expression: BSTR,
            msec: i32,
            language: *VARIANT,
            timerID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearInterval: fn(
            self: *const IHTMLWindow2,
            timerID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_offscreenBuffering: fn(
            self: *const IHTMLWindow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offscreenBuffering: fn(
            self: *const IHTMLWindow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        execScript: fn(
            self: *const IHTMLWindow2,
            code: BSTR,
            language: BSTR,
            pvarRet: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLWindow2,
            String: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollBy: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scrollTo: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveTo: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveBy: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        resizeTo: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        resizeBy: fn(
            self: *const IHTMLWindow2,
            x: i32,
            y: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_external: fn(
            self: *const IHTMLWindow2,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHTMLFramesCollection2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_frames(self: *const T, p: **IHTMLFramesCollection2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_frames(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_defaultStatus(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_defaultStatus(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_defaultStatus(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_defaultStatus(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_status(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_status(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_status(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_status(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_setTimeout(self: *const T, expression: BSTR, msec: i32, language: *VARIANT, timerID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).setTimeout(@ptrCast(*const IHTMLWindow2, self), expression, msec, language, timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_clearTimeout(self: *const T, timerID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).clearTimeout(@ptrCast(*const IHTMLWindow2, self), timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_alert(self: *const T, message: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).alert(@ptrCast(*const IHTMLWindow2, self), message);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_confirm(self: *const T, message: BSTR, confirmed: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).confirm(@ptrCast(*const IHTMLWindow2, self), message, confirmed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_prompt(self: *const T, message: BSTR, defstr: BSTR, textdata: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).prompt(@ptrCast(*const IHTMLWindow2, self), message, defstr, textdata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_Image(self: *const T, p: **IHTMLImageElementFactory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_Image(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_location(self: *const T, p: **IHTMLLocation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_location(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_history(self: *const T, p: **IOmHistory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_history(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).close(@ptrCast(*const IHTMLWindow2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_opener(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_opener(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_opener(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_opener(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_navigator(self: *const T, p: **IOmNavigator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_navigator(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_name(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_name(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_parent(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_parent(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_open(self: *const T, url: BSTR, name: BSTR, features: BSTR, replace: i16, pomWindowResult: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).open(@ptrCast(*const IHTMLWindow2, self), url, name, features, replace, pomWindowResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_self(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_self(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_top(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_top(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_window(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_window(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_navigate(self: *const T, url: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).navigate(@ptrCast(*const IHTMLWindow2, self), url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onfocus(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onblur(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onbeforeunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onbeforeunload(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onbeforeunload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onbeforeunload(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onunload(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onunload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onunload(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onhelp(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onhelp(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onhelp(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onhelp(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onresize(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onresize(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onresize(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onresize(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_onscroll(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_onscroll(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_onscroll(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_onscroll(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_document(self: *const T, p: **IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_document(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_event(self: *const T, p: **IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_event(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_showModalDialog(self: *const T, dialog: BSTR, varArgIn: *VARIANT, varOptions: *VARIANT, varArgOut: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).showModalDialog(@ptrCast(*const IHTMLWindow2, self), dialog, varArgIn, varOptions, varArgOut);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_showHelp(self: *const T, helpURL: BSTR, helpArg: VARIANT, features: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).showHelp(@ptrCast(*const IHTMLWindow2, self), helpURL, helpArg, features);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_screen(self: *const T, p: **IHTMLScreen) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_screen(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_Option(self: *const T, p: **IHTMLOptionElementFactory) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_Option(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).focus(@ptrCast(*const IHTMLWindow2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_closed(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_closed(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).blur(@ptrCast(*const IHTMLWindow2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_scroll(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).scroll(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_clientInformation(self: *const T, p: **IOmNavigator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_clientInformation(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_setInterval(self: *const T, expression: BSTR, msec: i32, language: *VARIANT, timerID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).setInterval(@ptrCast(*const IHTMLWindow2, self), expression, msec, language, timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_clearInterval(self: *const T, timerID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).clearInterval(@ptrCast(*const IHTMLWindow2, self), timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_put_offscreenBuffering(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).put_offscreenBuffering(@ptrCast(*const IHTMLWindow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_offscreenBuffering(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_offscreenBuffering(@ptrCast(*const IHTMLWindow2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_execScript(self: *const T, code: BSTR, language: BSTR, pvarRet: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).execScript(@ptrCast(*const IHTMLWindow2, self), code, language, pvarRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_toString(self: *const T, String: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).toString(@ptrCast(*const IHTMLWindow2, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_scrollBy(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).scrollBy(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_scrollTo(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).scrollTo(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_moveTo(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).moveTo(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_moveBy(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).moveBy(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_resizeTo(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).resizeTo(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_resizeBy(self: *const T, x: i32, y: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).resizeBy(@ptrCast(*const IHTMLWindow2, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow2_get_external(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow2.VTable, self.vtable).get_external(@ptrCast(*const IHTMLWindow2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow3_Value = @import("../zig.zig").Guid.initString("3050F4AE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLWindow3 = &IID_IHTMLWindow3_Value;
pub const IHTMLWindow3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_screenLeft: fn(
            self: *const IHTMLWindow3,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenTop: fn(
            self: *const IHTMLWindow3,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attachEvent: fn(
            self: *const IHTMLWindow3,
            event: BSTR,
            pDisp: *IDispatch,
            pfResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTMLWindow3,
            event: BSTR,
            pDisp: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setTimeout: fn(
            self: *const IHTMLWindow3,
            expression: *VARIANT,
            msec: i32,
            language: *VARIANT,
            timerID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setInterval: fn(
            self: *const IHTMLWindow3,
            expression: *VARIANT,
            msec: i32,
            language: *VARIANT,
            timerID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        print: fn(
            self: *const IHTMLWindow3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeprint: fn(
            self: *const IHTMLWindow3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeprint: fn(
            self: *const IHTMLWindow3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onafterprint: fn(
            self: *const IHTMLWindow3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onafterprint: fn(
            self: *const IHTMLWindow3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipboardData: fn(
            self: *const IHTMLWindow3,
            p: **IHTMLDataTransfer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showModelessDialog: fn(
            self: *const IHTMLWindow3,
            url: BSTR,
            varArgIn: *VARIANT,
            options: *VARIANT,
            pDialog: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_screenLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_screenLeft(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_screenTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_screenTop(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_attachEvent(self: *const T, event: BSTR, pDisp: *IDispatch, pfResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).attachEvent(@ptrCast(*const IHTMLWindow3, self), event, pDisp, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_detachEvent(self: *const T, event: BSTR, pDisp: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).detachEvent(@ptrCast(*const IHTMLWindow3, self), event, pDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_setTimeout(self: *const T, expression: *VARIANT, msec: i32, language: *VARIANT, timerID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).setTimeout(@ptrCast(*const IHTMLWindow3, self), expression, msec, language, timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_setInterval(self: *const T, expression: *VARIANT, msec: i32, language: *VARIANT, timerID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).setInterval(@ptrCast(*const IHTMLWindow3, self), expression, msec, language, timerID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_print(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).print(@ptrCast(*const IHTMLWindow3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_put_onbeforeprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).put_onbeforeprint(@ptrCast(*const IHTMLWindow3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_onbeforeprint(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_onbeforeprint(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_put_onafterprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).put_onafterprint(@ptrCast(*const IHTMLWindow3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_onafterprint(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_onafterprint(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_get_clipboardData(self: *const T, p: **IHTMLDataTransfer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).get_clipboardData(@ptrCast(*const IHTMLWindow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow3_showModelessDialog(self: *const T, url: BSTR, varArgIn: *VARIANT, options: *VARIANT, pDialog: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow3.VTable, self.vtable).showModelessDialog(@ptrCast(*const IHTMLWindow3, self), url, varArgIn, options, pDialog);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameBase_Value = @import("../zig.zig").Guid.initString("3050F311-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFrameBase = &IID_IHTMLFrameBase_Value;
pub const IHTMLFrameBase = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_src: fn(
            self: *const IHTMLFrameBase,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLFrameBase,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLFrameBase,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLFrameBase,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLFrameBase,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLFrameBase,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frameBorder: fn(
            self: *const IHTMLFrameBase,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameBorder: fn(
            self: *const IHTMLFrameBase,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frameSpacing: fn(
            self: *const IHTMLFrameBase,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameSpacing: fn(
            self: *const IHTMLFrameBase,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginWidth: fn(
            self: *const IHTMLFrameBase,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginWidth: fn(
            self: *const IHTMLFrameBase,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginHeight: fn(
            self: *const IHTMLFrameBase,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginHeight: fn(
            self: *const IHTMLFrameBase,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_noResize: fn(
            self: *const IHTMLFrameBase,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_noResize: fn(
            self: *const IHTMLFrameBase,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrolling: fn(
            self: *const IHTMLFrameBase,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrolling: fn(
            self: *const IHTMLFrameBase,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_src(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_src(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_name(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_name(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_border(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_border(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_border(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_frameBorder(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_frameBorder(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_frameBorder(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_frameBorder(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_frameSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_frameSpacing(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_frameSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_frameSpacing(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_marginWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_marginWidth(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_marginWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_marginWidth(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_marginHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_marginHeight(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_marginHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_marginHeight(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_noResize(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_noResize(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_noResize(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_noResize(@ptrCast(*const IHTMLFrameBase, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_put_scrolling(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).put_scrolling(@ptrCast(*const IHTMLFrameBase, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase_get_scrolling(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase.VTable, self.vtable).get_scrolling(@ptrCast(*const IHTMLFrameBase, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStorage_Value = @import("../zig.zig").Guid.initString("30510474-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStorage = &IID_IHTMLStorage_Value;
pub const IHTMLStorage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLStorage,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_remainingSpace: fn(
            self: *const IHTMLStorage,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        key: fn(
            self: *const IHTMLStorage,
            lIndex: i32,
            __MIDL__IHTMLStorage0000: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const IHTMLStorage,
            bstrKey: BSTR,
            __MIDL__IHTMLStorage0001: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setItem: fn(
            self: *const IHTMLStorage,
            bstrKey: BSTR,
            bstrValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const IHTMLStorage,
            bstrKey: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStorage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_get_remainingSpace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).get_remainingSpace(@ptrCast(*const IHTMLStorage, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_key(self: *const T, lIndex: i32, __MIDL__IHTMLStorage0000: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).key(@ptrCast(*const IHTMLStorage, self), lIndex, __MIDL__IHTMLStorage0000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_getItem(self: *const T, bstrKey: BSTR, __MIDL__IHTMLStorage0001: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).getItem(@ptrCast(*const IHTMLStorage, self), bstrKey, __MIDL__IHTMLStorage0001);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_setItem(self: *const T, bstrKey: BSTR, bstrValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).setItem(@ptrCast(*const IHTMLStorage, self), bstrKey, bstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_removeItem(self: *const T, bstrKey: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).removeItem(@ptrCast(*const IHTMLStorage, self), bstrKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage.VTable, self.vtable).clear(@ptrCast(*const IHTMLStorage, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPerformance_Value = @import("../zig.zig").Guid.initString("3051074E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPerformance = &IID_IHTMLPerformance_Value;
pub const IHTMLPerformance = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_navigation: fn(
            self: *const IHTMLPerformance,
            p: **IHTMLPerformanceNavigation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_timing: fn(
            self: *const IHTMLPerformance,
            p: **IHTMLPerformanceTiming,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLPerformance,
            string: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toJSON: fn(
            self: *const IHTMLPerformance,
            pVar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformance_get_navigation(self: *const T, p: **IHTMLPerformanceNavigation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformance.VTable, self.vtable).get_navigation(@ptrCast(*const IHTMLPerformance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformance_get_timing(self: *const T, p: **IHTMLPerformanceTiming) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformance.VTable, self.vtable).get_timing(@ptrCast(*const IHTMLPerformance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformance_toString(self: *const T, string: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformance.VTable, self.vtable).toString(@ptrCast(*const IHTMLPerformance, self), string);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformance_toJSON(self: *const T, pVar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformance.VTable, self.vtable).toJSON(@ptrCast(*const IHTMLPerformance, self), pVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLApplicationCache_Value = @import("../zig.zig").Guid.initString("30510828-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLApplicationCache = &IID_IHTMLApplicationCache_Value;
pub const IHTMLApplicationCache = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_status: fn(
            self: *const IHTMLApplicationCache,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchecking: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchecking: fn(
            self: *const IHTMLApplicationCache,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLApplicationCache,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onnoupdate: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onnoupdate: fn(
            self: *const IHTMLApplicationCache,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondownloading: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondownloading: fn(
            self: *const IHTMLApplicationCache,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onprogress: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onprogress: fn(
            self: *const IHTMLApplicationCache,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onupdateready: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onupdateready: fn(
            self: *const IHTMLApplicationCache,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncached: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncached: fn(
            self: *const IHTMLApplicationCache,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onobsolete: fn(
            self: *const IHTMLApplicationCache,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onobsolete: fn(
            self: *const IHTMLApplicationCache,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        update: fn(
            self: *const IHTMLApplicationCache,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        swapCache: fn(
            self: *const IHTMLApplicationCache,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IHTMLApplicationCache,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_status(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_status(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onchecking(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onchecking(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onchecking(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onchecking(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onnoupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onnoupdate(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onnoupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onnoupdate(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_ondownloading(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_ondownloading(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_ondownloading(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_ondownloading(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onprogress(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onupdateready(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onupdateready(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onupdateready(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onupdateready(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_oncached(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_oncached(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_oncached(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_oncached(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_put_onobsolete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).put_onobsolete(@ptrCast(*const IHTMLApplicationCache, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_get_onobsolete(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).get_onobsolete(@ptrCast(*const IHTMLApplicationCache, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_update(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).update(@ptrCast(*const IHTMLApplicationCache, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_swapCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).swapCache(@ptrCast(*const IHTMLApplicationCache, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLApplicationCache_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLApplicationCache.VTable, self.vtable).abort(@ptrCast(*const IHTMLApplicationCache, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScreen_Value = @import("../zig.zig").Guid.initString("3050F35C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLScreen = &IID_IHTMLScreen_Value;
pub const IHTMLScreen = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_colorDepth: fn(
            self: *const IHTMLScreen,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bufferDepth: fn(
            self: *const IHTMLScreen,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bufferDepth: fn(
            self: *const IHTMLScreen,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLScreen,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLScreen,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_updateInterval: fn(
            self: *const IHTMLScreen,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_updateInterval: fn(
            self: *const IHTMLScreen,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_availHeight: fn(
            self: *const IHTMLScreen,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_availWidth: fn(
            self: *const IHTMLScreen,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontSmoothingEnabled: fn(
            self: *const IHTMLScreen,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_colorDepth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_colorDepth(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_put_bufferDepth(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).put_bufferDepth(@ptrCast(*const IHTMLScreen, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_bufferDepth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_bufferDepth(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_width(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_width(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_height(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_height(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_put_updateInterval(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).put_updateInterval(@ptrCast(*const IHTMLScreen, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_updateInterval(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_updateInterval(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_availHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_availHeight(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_availWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_availWidth(@ptrCast(*const IHTMLScreen, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen_get_fontSmoothingEnabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen.VTable, self.vtable).get_fontSmoothingEnabled(@ptrCast(*const IHTMLScreen, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScreen2_Value = @import("../zig.zig").Guid.initString("3050F84A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLScreen2 = &IID_IHTMLScreen2_Value;
pub const IHTMLScreen2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_logicalXDPI: fn(
            self: *const IHTMLScreen2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_logicalYDPI: fn(
            self: *const IHTMLScreen2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_deviceXDPI: fn(
            self: *const IHTMLScreen2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_deviceYDPI: fn(
            self: *const IHTMLScreen2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen2_get_logicalXDPI(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen2.VTable, self.vtable).get_logicalXDPI(@ptrCast(*const IHTMLScreen2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen2_get_logicalYDPI(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen2.VTable, self.vtable).get_logicalYDPI(@ptrCast(*const IHTMLScreen2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen2_get_deviceXDPI(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen2.VTable, self.vtable).get_deviceXDPI(@ptrCast(*const IHTMLScreen2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen2_get_deviceYDPI(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen2.VTable, self.vtable).get_deviceYDPI(@ptrCast(*const IHTMLScreen2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScreen3_Value = @import("../zig.zig").Guid.initString("305104A1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLScreen3 = &IID_IHTMLScreen3_Value;
pub const IHTMLScreen3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_systemXDPI: fn(
            self: *const IHTMLScreen3,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_systemYDPI: fn(
            self: *const IHTMLScreen3,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen3_get_systemXDPI(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen3.VTable, self.vtable).get_systemXDPI(@ptrCast(*const IHTMLScreen3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen3_get_systemYDPI(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen3.VTable, self.vtable).get_systemYDPI(@ptrCast(*const IHTMLScreen3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScreen4_Value = @import("../zig.zig").Guid.initString("3051076B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLScreen4 = &IID_IHTMLScreen4_Value;
pub const IHTMLScreen4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_pixelDepth: fn(
            self: *const IHTMLScreen4,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScreen4_get_pixelDepth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScreen4.VTable, self.vtable).get_pixelDepth(@ptrCast(*const IHTMLScreen4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow4_Value = @import("../zig.zig").Guid.initString("3050F6CF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLWindow4 = &IID_IHTMLWindow4_Value;
pub const IHTMLWindow4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createPopup: fn(
            self: *const IHTMLWindow4,
            varArgIn: *VARIANT,
            ppPopup: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameElement: fn(
            self: *const IHTMLWindow4,
            p: **IHTMLFrameBase,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow4_createPopup(self: *const T, varArgIn: *VARIANT, ppPopup: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow4.VTable, self.vtable).createPopup(@ptrCast(*const IHTMLWindow4, self), varArgIn, ppPopup);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow4_get_frameElement(self: *const T, p: **IHTMLFrameBase) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow4.VTable, self.vtable).get_frameElement(@ptrCast(*const IHTMLWindow4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow5_Value = @import("../zig.zig").Guid.initString("3051040E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLWindow5 = &IID_IHTMLWindow5_Value;
pub const IHTMLWindow5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_XMLHttpRequest: fn(
            self: *const IHTMLWindow5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_XMLHttpRequest: fn(
            self: *const IHTMLWindow5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow5_put_XMLHttpRequest(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow5.VTable, self.vtable).put_XMLHttpRequest(@ptrCast(*const IHTMLWindow5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow5_get_XMLHttpRequest(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow5.VTable, self.vtable).get_XMLHttpRequest(@ptrCast(*const IHTMLWindow5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow6_Value = @import("../zig.zig").Guid.initString("30510453-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLWindow6 = &IID_IHTMLWindow6_Value;
pub const IHTMLWindow6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_XDomainRequest: fn(
            self: *const IHTMLWindow6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_XDomainRequest: fn(
            self: *const IHTMLWindow6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_sessionStorage: fn(
            self: *const IHTMLWindow6,
            p: **IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_localStorage: fn(
            self: *const IHTMLWindow6,
            p: **IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onhashchange: fn(
            self: *const IHTMLWindow6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onhashchange: fn(
            self: *const IHTMLWindow6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maxConnectionsPerServer: fn(
            self: *const IHTMLWindow6,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        postMessage: fn(
            self: *const IHTMLWindow6,
            msg: BSTR,
            targetOrigin: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toStaticHTML: fn(
            self: *const IHTMLWindow6,
            bstrHTML: BSTR,
            pbstrStaticHTML: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmessage: fn(
            self: *const IHTMLWindow6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmessage: fn(
            self: *const IHTMLWindow6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        msWriteProfilerMark: fn(
            self: *const IHTMLWindow6,
            bstrProfilerMarkName: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_put_XDomainRequest(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).put_XDomainRequest(@ptrCast(*const IHTMLWindow6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_XDomainRequest(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_XDomainRequest(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_sessionStorage(self: *const T, p: **IHTMLStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_sessionStorage(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_localStorage(self: *const T, p: **IHTMLStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_localStorage(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_put_onhashchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).put_onhashchange(@ptrCast(*const IHTMLWindow6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_onhashchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_onhashchange(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_maxConnectionsPerServer(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_maxConnectionsPerServer(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_postMessage(self: *const T, msg: BSTR, targetOrigin: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).postMessage(@ptrCast(*const IHTMLWindow6, self), msg, targetOrigin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_toStaticHTML(self: *const T, bstrHTML: BSTR, pbstrStaticHTML: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).toStaticHTML(@ptrCast(*const IHTMLWindow6, self), bstrHTML, pbstrStaticHTML);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_put_onmessage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).put_onmessage(@ptrCast(*const IHTMLWindow6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_get_onmessage(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).get_onmessage(@ptrCast(*const IHTMLWindow6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow6_msWriteProfilerMark(self: *const T, bstrProfilerMarkName: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow6.VTable, self.vtable).msWriteProfilerMark(@ptrCast(*const IHTMLWindow6, self), bstrProfilerMarkName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow7_Value = @import("../zig.zig").Guid.initString("305104B7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLWindow7 = &IID_IHTMLWindow7_Value;
pub const IHTMLWindow7 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getSelection: fn(
            self: *const IHTMLWindow7,
            ppIHTMLSelection: **IHTMLSelection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getComputedStyle: fn(
            self: *const IHTMLWindow7,
            varArgIn: *IHTMLDOMNode,
            bstrPseudoElt: BSTR,
            ppComputedStyle: **IHTMLCSSStyleDeclaration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_styleMedia: fn(
            self: *const IHTMLWindow7,
            p: **IHTMLStyleMedia,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_performance: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_performance: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_innerWidth: fn(
            self: *const IHTMLWindow7,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_innerHeight: fn(
            self: *const IHTMLWindow7,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageXOffset: fn(
            self: *const IHTMLWindow7,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageYOffset: fn(
            self: *const IHTMLWindow7,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenX: fn(
            self: *const IHTMLWindow7,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenY: fn(
            self: *const IHTMLWindow7,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outerWidth: fn(
            self: *const IHTMLWindow7,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_outerHeight: fn(
            self: *const IHTMLWindow7,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onabort: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onabort: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncanplay: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncanplay: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncanplaythrough: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncanplaythrough: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onchange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onchange: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onclick: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onclick: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncontextmenu: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncontextmenu: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondblclick: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondblclick: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondrag: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondrag: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragend: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragend: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragenter: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragenter: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragleave: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragleave: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragover: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragover: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondragstart: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondragstart: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondrop: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondrop: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondurationchange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondurationchange: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocusin: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocusin: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocusout: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocusout: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oninput: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oninput: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onemptied: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onemptied: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onended: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onended: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onkeydown: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onkeydown: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onkeypress: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onkeypress: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onkeyup: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onkeyup: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onloadeddata: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onloadeddata: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onloadedmetadata: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onloadedmetadata: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onloadstart: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onloadstart: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmousedown: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmousedown: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseenter: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseenter: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseleave: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseleave: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmousemove: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmousemove: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseout: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseout: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseover: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseover: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmouseup: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmouseup: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmousewheel: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmousewheel: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onoffline: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onoffline: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ononline: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ononline: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onprogress: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onprogress: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onratechange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onratechange: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreset: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreset: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onseeked: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onseeked: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onseeking: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onseeking: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselect: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselect: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstalled: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstalled: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstorage: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstorage: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onsubmit: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onsubmit: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onsuspend: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onsuspend: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ontimeupdate: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ontimeupdate: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onpause: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onpause: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onplay: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onplay: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onplaying: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onplaying: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onvolumechange: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onvolumechange: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onwaiting: fn(
            self: *const IHTMLWindow7,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onwaiting: fn(
            self: *const IHTMLWindow7,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_getSelection(self: *const T, ppIHTMLSelection: **IHTMLSelection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).getSelection(@ptrCast(*const IHTMLWindow7, self), ppIHTMLSelection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_getComputedStyle(self: *const T, varArgIn: *IHTMLDOMNode, bstrPseudoElt: BSTR, ppComputedStyle: **IHTMLCSSStyleDeclaration) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).getComputedStyle(@ptrCast(*const IHTMLWindow7, self), varArgIn, bstrPseudoElt, ppComputedStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_styleMedia(self: *const T, p: **IHTMLStyleMedia) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_styleMedia(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_performance(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_performance(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_performance(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_performance(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_innerWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_innerWidth(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_innerHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_innerHeight(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_pageXOffset(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_pageXOffset(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_pageYOffset(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_pageYOffset(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_screenX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_screenX(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_screenY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_screenY(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_outerWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_outerWidth(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_outerHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_outerHeight(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onabort(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onabort(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onabort(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onabort(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_oncanplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_oncanplay(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_oncanplay(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_oncanplay(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_oncanplaythrough(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_oncanplaythrough(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_oncanplaythrough(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_oncanplaythrough(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onchange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onchange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onclick(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onclick(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onclick(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_oncontextmenu(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_oncontextmenu(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_oncontextmenu(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_oncontextmenu(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondblclick(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondblclick(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondblclick(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondblclick(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondrag(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondrag(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondrag(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondrag(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragend(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragend(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragenter(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragenter(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragenter(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragleave(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragleave(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragleave(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragover(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragover(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondragstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondragstart(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondragstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondragstart(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondrop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondrop(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondrop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondrop(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ondurationchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ondurationchange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ondurationchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ondurationchange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onfocusin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onfocusin(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onfocusin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onfocusin(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onfocusout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onfocusout(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onfocusout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onfocusout(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_oninput(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_oninput(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_oninput(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_oninput(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onemptied(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onemptied(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onemptied(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onemptied(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onended(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onended(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onended(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onended(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onkeydown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onkeydown(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onkeydown(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onkeydown(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onkeypress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onkeypress(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onkeypress(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onkeypress(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onkeyup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onkeyup(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onkeyup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onkeyup(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onloadeddata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onloadeddata(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onloadeddata(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onloadeddata(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onloadedmetadata(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onloadedmetadata(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onloadedmetadata(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onloadedmetadata(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onloadstart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onloadstart(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onloadstart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onloadstart(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmousedown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmousedown(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmousedown(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmousedown(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseenter(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseenter(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseenter(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseenter(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseleave(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseleave(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseleave(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseleave(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmousemove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmousemove(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmousemove(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmousemove(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseout(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseout(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseover(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseover(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmouseup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmouseup(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmouseup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmouseup(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onmousewheel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onmousewheel(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onmousewheel(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onmousewheel(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onoffline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onoffline(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onoffline(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onoffline(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ononline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ononline(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ononline(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ononline(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onprogress(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onratechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onratechange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onratechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onratechange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onreset(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onreset(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onreset(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onreset(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onseeked(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onseeked(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onseeked(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onseeked(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onseeking(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onseeking(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onseeking(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onseeking(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onselect(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onselect(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onstalled(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onstalled(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onstalled(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onstalled(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onstorage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onstorage(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onstorage(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onstorage(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onsubmit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onsubmit(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onsubmit(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onsubmit(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onsuspend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onsuspend(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onsuspend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onsuspend(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_ontimeupdate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_ontimeupdate(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_ontimeupdate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_ontimeupdate(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onpause(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onpause(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onpause(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onpause(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onplay(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onplay(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onplay(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onplay(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onplaying(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onplaying(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onplaying(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onplaying(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onvolumechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onvolumechange(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onvolumechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onvolumechange(@ptrCast(*const IHTMLWindow7, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_put_onwaiting(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).put_onwaiting(@ptrCast(*const IHTMLWindow7, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow7_get_onwaiting(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow7.VTable, self.vtable).get_onwaiting(@ptrCast(*const IHTMLWindow7, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLWindow8_Value = @import("../zig.zig").Guid.initString("305107AB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLWindow8 = &IID_IHTMLWindow8_Value;
pub const IHTMLWindow8 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onmspointerdown: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerdown: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointermove: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointermove: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerup: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerup: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerover: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerover: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerout: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerout: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointercancel: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointercancel: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerhover: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerhover: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturestart: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturestart: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturechange: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturechange: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgestureend: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgestureend: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturehold: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturehold: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturetap: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturetap: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturedoubletap: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturedoubletap: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsinertiastart: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsinertiastart: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_applicationCache: fn(
            self: *const IHTMLWindow8,
            p: **IHTMLApplicationCache,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onpopstate: fn(
            self: *const IHTMLWindow8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onpopstate: fn(
            self: *const IHTMLWindow8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerdown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerdown(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerdown(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerdown(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointermove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointermove(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointermove(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointermove(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerup(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerup(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerover(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerover(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerout(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerout(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointercancel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointercancel(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointercancel(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointercancel(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmspointerhover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmspointerhover(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmspointerhover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmspointerhover(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturestart(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturestart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturestart(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturechange(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturechange(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgestureend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgestureend(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgestureend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgestureend(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturehold(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturehold(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturehold(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturehold(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturetap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturetap(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturetap(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturetap(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsgesturedoubletap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsgesturedoubletap(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsgesturedoubletap(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsgesturedoubletap(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onmsinertiastart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onmsinertiastart(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onmsinertiastart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onmsinertiastart(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_applicationCache(self: *const T, p: **IHTMLApplicationCache) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_applicationCache(@ptrCast(*const IHTMLWindow8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_put_onpopstate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).put_onpopstate(@ptrCast(*const IHTMLWindow8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLWindow8_get_onpopstate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLWindow8.VTable, self.vtable).get_onpopstate(@ptrCast(*const IHTMLWindow8, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLScreen_Value = @import("../zig.zig").Guid.initString("3050F591-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLScreen = &IID_DispHTMLScreen_Value;
pub const DispHTMLScreen = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLWindow2_Value = @import("../zig.zig").Guid.initString("3050F55D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLWindow2 = &IID_DispHTMLWindow2_Value;
pub const DispHTMLWindow2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLWindowProxy_Value = @import("../zig.zig").Guid.initString("3050F55E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLWindowProxy = &IID_DispHTMLWindowProxy_Value;
pub const DispHTMLWindowProxy = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocumentCompatibleInfo_Value = @import("../zig.zig").Guid.initString("3051041A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDocumentCompatibleInfo = &IID_IHTMLDocumentCompatibleInfo_Value;
pub const IHTMLDocumentCompatibleInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_userAgent: fn(
            self: *const IHTMLDocumentCompatibleInfo,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_version: fn(
            self: *const IHTMLDocumentCompatibleInfo,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocumentCompatibleInfo_get_userAgent(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocumentCompatibleInfo.VTable, self.vtable).get_userAgent(@ptrCast(*const IHTMLDocumentCompatibleInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocumentCompatibleInfo_get_version(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocumentCompatibleInfo.VTable, self.vtable).get_version(@ptrCast(*const IHTMLDocumentCompatibleInfo, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocumentCompatibleInfoCollection_Value = @import("../zig.zig").Guid.initString("30510418-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDocumentCompatibleInfoCollection = &IID_IHTMLDocumentCompatibleInfoCollection_Value;
pub const IHTMLDocumentCompatibleInfoCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLDocumentCompatibleInfoCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLDocumentCompatibleInfoCollection,
            index: i32,
            compatibleInfo: **IHTMLDocumentCompatibleInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocumentCompatibleInfoCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocumentCompatibleInfoCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLDocumentCompatibleInfoCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocumentCompatibleInfoCollection_item(self: *const T, index: i32, compatibleInfo: **IHTMLDocumentCompatibleInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocumentCompatibleInfoCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLDocumentCompatibleInfoCollection, self), index, compatibleInfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDocumentCompatibleInfo_Value = @import("../zig.zig").Guid.initString("3050F53E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDocumentCompatibleInfo = &IID_DispHTMLDocumentCompatibleInfo_Value;
pub const DispHTMLDocumentCompatibleInfo = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDocumentCompatibleInfoCollection_Value = @import("../zig.zig").Guid.initString("3050F53F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDocumentCompatibleInfoCollection = &IID_DispHTMLDocumentCompatibleInfoCollection_Value;
pub const DispHTMLDocumentCompatibleInfoCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLDocumentEvents4_Value = @import("../zig.zig").Guid.initString("30510737-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLDocumentEvents4 = &IID_HTMLDocumentEvents4_Value;
pub const HTMLDocumentEvents4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLDocumentEvents3_Value = @import("../zig.zig").Guid.initString("3050F5A0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLDocumentEvents3 = &IID_HTMLDocumentEvents3_Value;
pub const HTMLDocumentEvents3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLDocumentEvents2_Value = @import("../zig.zig").Guid.initString("3050F613-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLDocumentEvents2 = &IID_HTMLDocumentEvents2_Value;
pub const HTMLDocumentEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLDocumentEvents_Value = @import("../zig.zig").Guid.initString("3050F260-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLDocumentEvents = &IID_HTMLDocumentEvents_Value;
pub const HTMLDocumentEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGSVGElement_Value = @import("../zig.zig").Guid.initString("305104E7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGSVGElement = &IID_ISVGSVGElement_Value;
pub const ISVGSVGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGSVGElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGSVGElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGSVGElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGSVGElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGSVGElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const ISVGSVGElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGSVGElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const ISVGSVGElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_contentScriptType: fn(
            self: *const ISVGSVGElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_contentScriptType: fn(
            self: *const ISVGSVGElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_contentStyleType: fn(
            self: *const ISVGSVGElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_contentStyleType: fn(
            self: *const ISVGSVGElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_viewport: fn(
            self: *const ISVGSVGElement,
            v: *ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_viewport: fn(
            self: *const ISVGSVGElement,
            p: **ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelUnitToMillimeterX: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelUnitToMillimeterX: fn(
            self: *const ISVGSVGElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pixelUnitToMillimeterY: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pixelUnitToMillimeterY: fn(
            self: *const ISVGSVGElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_screenPixelToMillimeterX: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenPixelToMillimeterX: fn(
            self: *const ISVGSVGElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_screenPixelToMillimeterY: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenPixelToMillimeterY: fn(
            self: *const ISVGSVGElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_useCurrentView: fn(
            self: *const ISVGSVGElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_useCurrentView: fn(
            self: *const ISVGSVGElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_currentView: fn(
            self: *const ISVGSVGElement,
            v: *ISVGViewSpec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentView: fn(
            self: *const ISVGSVGElement,
            p: **ISVGViewSpec,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_currentScale: fn(
            self: *const ISVGSVGElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentScale: fn(
            self: *const ISVGSVGElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_currentTranslate: fn(
            self: *const ISVGSVGElement,
            v: *ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentTranslate: fn(
            self: *const ISVGSVGElement,
            p: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        suspendRedraw: fn(
            self: *const ISVGSVGElement,
            maxWaitMilliseconds: u32,
            pResult: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        unsuspendRedraw: fn(
            self: *const ISVGSVGElement,
            suspendHandeID: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        unsuspendRedrawAll: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        forceRedraw: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pauseAnimations: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        unpauseAnimations: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        animationsPaused: fn(
            self: *const ISVGSVGElement,
            pResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCurrentTime: fn(
            self: *const ISVGSVGElement,
            pResult: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setCurrentTime: fn(
            self: *const ISVGSVGElement,
            seconds: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getIntersectionList: fn(
            self: *const ISVGSVGElement,
            rect: *ISVGRect,
            referenceElement: *ISVGElement,
            pResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getEnclosureList: fn(
            self: *const ISVGSVGElement,
            rect: *ISVGRect,
            referenceElement: *ISVGElement,
            pResult: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        checkIntersection: fn(
            self: *const ISVGSVGElement,
            element: *ISVGElement,
            rect: *ISVGRect,
            pResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        checkEnclosure: fn(
            self: *const ISVGSVGElement,
            element: *ISVGElement,
            rect: *ISVGRect,
            pResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deselectAll: fn(
            self: *const ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGNumber: fn(
            self: *const ISVGSVGElement,
            pResult: **ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGLength: fn(
            self: *const ISVGSVGElement,
            pResult: **ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGAngle: fn(
            self: *const ISVGSVGElement,
            pResult: **ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPoint: fn(
            self: *const ISVGSVGElement,
            pResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGMatrix: fn(
            self: *const ISVGSVGElement,
            pResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGRect: fn(
            self: *const ISVGSVGElement,
            pResult: **ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGTransform: fn(
            self: *const ISVGSVGElement,
            pResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGTransformFromMatrix: fn(
            self: *const ISVGSVGElement,
            matrix: *ISVGMatrix,
            pResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementById: fn(
            self: *const ISVGSVGElement,
            elementId: BSTR,
            pResult: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_x(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_x(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_y(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_y(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_width(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_width(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_height(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_height(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_contentScriptType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_contentScriptType(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_contentScriptType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_contentScriptType(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_contentStyleType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_contentStyleType(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_contentStyleType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_contentStyleType(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_viewport(self: *const T, v: *ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_viewport(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_viewport(self: *const T, p: **ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_viewport(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_pixelUnitToMillimeterX(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_pixelUnitToMillimeterX(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_pixelUnitToMillimeterX(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_pixelUnitToMillimeterX(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_pixelUnitToMillimeterY(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_pixelUnitToMillimeterY(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_pixelUnitToMillimeterY(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_pixelUnitToMillimeterY(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_screenPixelToMillimeterX(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_screenPixelToMillimeterX(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_screenPixelToMillimeterX(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_screenPixelToMillimeterX(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_screenPixelToMillimeterY(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_screenPixelToMillimeterY(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_screenPixelToMillimeterY(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_screenPixelToMillimeterY(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_useCurrentView(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_useCurrentView(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_useCurrentView(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_useCurrentView(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_currentView(self: *const T, v: *ISVGViewSpec) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_currentView(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_currentView(self: *const T, p: **ISVGViewSpec) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_currentView(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_put_currentScale(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).put_currentScale(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_currentScale(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_currentScale(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_putref_currentTranslate(self: *const T, v: *ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).putref_currentTranslate(@ptrCast(*const ISVGSVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_get_currentTranslate(self: *const T, p: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).get_currentTranslate(@ptrCast(*const ISVGSVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_suspendRedraw(self: *const T, maxWaitMilliseconds: u32, pResult: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).suspendRedraw(@ptrCast(*const ISVGSVGElement, self), maxWaitMilliseconds, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_unsuspendRedraw(self: *const T, suspendHandeID: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).unsuspendRedraw(@ptrCast(*const ISVGSVGElement, self), suspendHandeID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_unsuspendRedrawAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).unsuspendRedrawAll(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_forceRedraw(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).forceRedraw(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_pauseAnimations(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).pauseAnimations(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_unpauseAnimations(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).unpauseAnimations(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_animationsPaused(self: *const T, pResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).animationsPaused(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_getCurrentTime(self: *const T, pResult: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).getCurrentTime(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_setCurrentTime(self: *const T, seconds: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).setCurrentTime(@ptrCast(*const ISVGSVGElement, self), seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_getIntersectionList(self: *const T, rect: *ISVGRect, referenceElement: *ISVGElement, pResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).getIntersectionList(@ptrCast(*const ISVGSVGElement, self), rect, referenceElement, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_getEnclosureList(self: *const T, rect: *ISVGRect, referenceElement: *ISVGElement, pResult: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).getEnclosureList(@ptrCast(*const ISVGSVGElement, self), rect, referenceElement, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_checkIntersection(self: *const T, element: *ISVGElement, rect: *ISVGRect, pResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).checkIntersection(@ptrCast(*const ISVGSVGElement, self), element, rect, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_checkEnclosure(self: *const T, element: *ISVGElement, rect: *ISVGRect, pResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).checkEnclosure(@ptrCast(*const ISVGSVGElement, self), element, rect, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_deselectAll(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).deselectAll(@ptrCast(*const ISVGSVGElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGNumber(self: *const T, pResult: **ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGNumber(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGLength(self: *const T, pResult: **ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGLength(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGAngle(self: *const T, pResult: **ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGAngle(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGPoint(self: *const T, pResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGPoint(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGMatrix(self: *const T, pResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGMatrix(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGRect(self: *const T, pResult: **ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGRect(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGTransform(self: *const T, pResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGTransform(@ptrCast(*const ISVGSVGElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_createSVGTransformFromMatrix(self: *const T, matrix: *ISVGMatrix, pResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).createSVGTransformFromMatrix(@ptrCast(*const ISVGSVGElement, self), matrix, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGSVGElement_getElementById(self: *const T, elementId: BSTR, pResult: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGSVGElement.VTable, self.vtable).getElementById(@ptrCast(*const ISVGSVGElement, self), elementId, pResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMNodeIterator_Value = @import("../zig.zig").Guid.initString("30510746-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMNodeIterator = &IID_IDOMNodeIterator_Value;
pub const IDOMNodeIterator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_root: fn(
            self: *const IDOMNodeIterator,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_whatToShow: fn(
            self: *const IDOMNodeIterator,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_filter: fn(
            self: *const IDOMNodeIterator,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_expandEntityReferences: fn(
            self: *const IDOMNodeIterator,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextNode: fn(
            self: *const IDOMNodeIterator,
            ppRetNode: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        previousNode: fn(
            self: *const IDOMNodeIterator,
            ppRetNode: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detach: fn(
            self: *const IDOMNodeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_get_root(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).get_root(@ptrCast(*const IDOMNodeIterator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_get_whatToShow(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).get_whatToShow(@ptrCast(*const IDOMNodeIterator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_get_filter(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).get_filter(@ptrCast(*const IDOMNodeIterator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_get_expandEntityReferences(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).get_expandEntityReferences(@ptrCast(*const IDOMNodeIterator, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_nextNode(self: *const T, ppRetNode: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).nextNode(@ptrCast(*const IDOMNodeIterator, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_previousNode(self: *const T, ppRetNode: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).previousNode(@ptrCast(*const IDOMNodeIterator, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMNodeIterator_detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMNodeIterator.VTable, self.vtable).detach(@ptrCast(*const IDOMNodeIterator, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMTreeWalker_Value = @import("../zig.zig").Guid.initString("30510748-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMTreeWalker = &IID_IDOMTreeWalker_Value;
pub const IDOMTreeWalker = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_root: fn(
            self: *const IDOMTreeWalker,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_whatToShow: fn(
            self: *const IDOMTreeWalker,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_filter: fn(
            self: *const IDOMTreeWalker,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_expandEntityReferences: fn(
            self: *const IDOMTreeWalker,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_currentNode: fn(
            self: *const IDOMTreeWalker,
            v: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentNode: fn(
            self: *const IDOMTreeWalker,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        parentNode: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        firstChild: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lastChild: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        previousSibling: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextSibling: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        previousNode: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextNode: fn(
            self: *const IDOMTreeWalker,
            ppRetNode: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_root(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_root(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_whatToShow(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_whatToShow(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_filter(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_filter(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_expandEntityReferences(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_expandEntityReferences(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_putref_currentNode(self: *const T, v: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).putref_currentNode(@ptrCast(*const IDOMTreeWalker, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_get_currentNode(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).get_currentNode(@ptrCast(*const IDOMTreeWalker, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_parentNode(self: *const T, ppRetNode: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).parentNode(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_firstChild(self: *const T, ppRetNode: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).firstChild(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_lastChild(self: *const T, ppRetNode: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).lastChild(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_previousSibling(self: *const T, ppRetNode: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).previousSibling(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_nextSibling(self: *const T, ppRetNode: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).nextSibling(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_previousNode(self: *const T, ppRetNode: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).previousNode(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTreeWalker_nextNode(self: *const T, ppRetNode: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTreeWalker.VTable, self.vtable).nextNode(@ptrCast(*const IDOMTreeWalker, self), ppRetNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMProcessingInstruction_Value = @import("../zig.zig").Guid.initString("30510742-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMProcessingInstruction = &IID_IDOMProcessingInstruction_Value;
pub const IDOMProcessingInstruction = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_target: fn(
            self: *const IDOMProcessingInstruction,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_data: fn(
            self: *const IDOMProcessingInstruction,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_data: fn(
            self: *const IDOMProcessingInstruction,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProcessingInstruction_get_target(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProcessingInstruction.VTable, self.vtable).get_target(@ptrCast(*const IDOMProcessingInstruction, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProcessingInstruction_put_data(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProcessingInstruction.VTable, self.vtable).put_data(@ptrCast(*const IDOMProcessingInstruction, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProcessingInstruction_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProcessingInstruction.VTable, self.vtable).get_data(@ptrCast(*const IDOMProcessingInstruction, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument3_Value = @import("../zig.zig").Guid.initString("3050F485-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDocument3 = &IID_IHTMLDocument3_Value;
pub const IHTMLDocument3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        releaseCapture: fn(
            self: *const IHTMLDocument3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        recalc: fn(
            self: *const IHTMLDocument3,
            fForce: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTextNode: fn(
            self: *const IHTMLDocument3,
            text: BSTR,
            newTextNode: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_documentElement: fn(
            self: *const IHTMLDocument3,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_uniqueID: fn(
            self: *const IHTMLDocument3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attachEvent: fn(
            self: *const IHTMLDocument3,
            event: BSTR,
            pDisp: *IDispatch,
            pfResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTMLDocument3,
            event: BSTR,
            pDisp: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onrowsdelete: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onrowsdelete: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onrowsinserted: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onrowsinserted: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncellchange: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncellchange: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondatasetchanged: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondatasetchanged: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondataavailable: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondataavailable: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondatasetcomplete: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondatasetcomplete: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onpropertychange: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onpropertychange: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dir: fn(
            self: *const IHTMLDocument3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dir: fn(
            self: *const IHTMLDocument3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncontextmenu: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncontextmenu: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstop: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstop: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createDocumentFragment: fn(
            self: *const IHTMLDocument3,
            pNewDoc: **IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentDocument: fn(
            self: *const IHTMLDocument3,
            p: **IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_enableDownload: fn(
            self: *const IHTMLDocument3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_enableDownload: fn(
            self: *const IHTMLDocument3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_baseUrl: fn(
            self: *const IHTMLDocument3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseUrl: fn(
            self: *const IHTMLDocument3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_childNodes: fn(
            self: *const IHTMLDocument3,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_inheritStyleSheets: fn(
            self: *const IHTMLDocument3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_inheritStyleSheets: fn(
            self: *const IHTMLDocument3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeeditfocus: fn(
            self: *const IHTMLDocument3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeeditfocus: fn(
            self: *const IHTMLDocument3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByName: fn(
            self: *const IHTMLDocument3,
            v: BSTR,
            pelColl: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementById: fn(
            self: *const IHTMLDocument3,
            v: BSTR,
            pel: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementsByTagName: fn(
            self: *const IHTMLDocument3,
            v: BSTR,
            pelColl: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_releaseCapture(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).releaseCapture(@ptrCast(*const IHTMLDocument3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_recalc(self: *const T, fForce: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).recalc(@ptrCast(*const IHTMLDocument3, self), fForce);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_createTextNode(self: *const T, text: BSTR, newTextNode: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).createTextNode(@ptrCast(*const IHTMLDocument3, self), text, newTextNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_documentElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_documentElement(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_uniqueID(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_uniqueID(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_attachEvent(self: *const T, event: BSTR, pDisp: *IDispatch, pfResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).attachEvent(@ptrCast(*const IHTMLDocument3, self), event, pDisp, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_detachEvent(self: *const T, event: BSTR, pDisp: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).detachEvent(@ptrCast(*const IHTMLDocument3, self), event, pDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onrowsdelete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onrowsdelete(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onrowsdelete(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onrowsdelete(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onrowsinserted(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onrowsinserted(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onrowsinserted(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onrowsinserted(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_oncellchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_oncellchange(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_oncellchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_oncellchange(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_ondatasetchanged(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_ondatasetchanged(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_ondatasetchanged(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_ondatasetchanged(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_ondataavailable(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_ondataavailable(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_ondataavailable(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_ondataavailable(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_ondatasetcomplete(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_ondatasetcomplete(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_ondatasetcomplete(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_ondatasetcomplete(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onpropertychange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onpropertychange(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onpropertychange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onpropertychange(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_dir(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_dir(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_dir(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_dir(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_oncontextmenu(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_oncontextmenu(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_oncontextmenu(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_oncontextmenu(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onstop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onstop(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onstop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onstop(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_createDocumentFragment(self: *const T, pNewDoc: **IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).createDocumentFragment(@ptrCast(*const IHTMLDocument3, self), pNewDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_parentDocument(self: *const T, p: **IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_parentDocument(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_enableDownload(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_enableDownload(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_enableDownload(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_enableDownload(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_baseUrl(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_baseUrl(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_baseUrl(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_baseUrl(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_childNodes(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_childNodes(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_inheritStyleSheets(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_inheritStyleSheets(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_inheritStyleSheets(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_inheritStyleSheets(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_put_onbeforeeditfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).put_onbeforeeditfocus(@ptrCast(*const IHTMLDocument3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_get_onbeforeeditfocus(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).get_onbeforeeditfocus(@ptrCast(*const IHTMLDocument3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_getElementsByName(self: *const T, v: BSTR, pelColl: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).getElementsByName(@ptrCast(*const IHTMLDocument3, self), v, pelColl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_getElementById(self: *const T, v: BSTR, pel: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).getElementById(@ptrCast(*const IHTMLDocument3, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument3_getElementsByTagName(self: *const T, v: BSTR, pelColl: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument3.VTable, self.vtable).getElementsByTagName(@ptrCast(*const IHTMLDocument3, self), v, pelColl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument4_Value = @import("../zig.zig").Guid.initString("3050F69A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDocument4 = &IID_IHTMLDocument4_Value;
pub const IHTMLDocument4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        focus: fn(
            self: *const IHTMLDocument4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasFocus: fn(
            self: *const IHTMLDocument4,
            pfFocus: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onselectionchange: fn(
            self: *const IHTMLDocument4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onselectionchange: fn(
            self: *const IHTMLDocument4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_namespaces: fn(
            self: *const IHTMLDocument4,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createDocumentFromUrl: fn(
            self: *const IHTMLDocument4,
            bstrUrl: BSTR,
            bstrOptions: BSTR,
            newDoc: **IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_media: fn(
            self: *const IHTMLDocument4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_media: fn(
            self: *const IHTMLDocument4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createEventObject: fn(
            self: *const IHTMLDocument4,
            pvarEventObject: *VARIANT,
            ppEventObj: **IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fireEvent: fn(
            self: *const IHTMLDocument4,
            bstrEventName: BSTR,
            pvarEventObject: *VARIANT,
            pfCancelled: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createRenderStyle: fn(
            self: *const IHTMLDocument4,
            v: BSTR,
            ppIHTMLRenderStyle: **IHTMLRenderStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_oncontrolselect: fn(
            self: *const IHTMLDocument4,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oncontrolselect: fn(
            self: *const IHTMLDocument4,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_URLUnencoded: fn(
            self: *const IHTMLDocument4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).focus(@ptrCast(*const IHTMLDocument4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_hasFocus(self: *const T, pfFocus: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).hasFocus(@ptrCast(*const IHTMLDocument4, self), pfFocus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_put_onselectionchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).put_onselectionchange(@ptrCast(*const IHTMLDocument4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_onselectionchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_onselectionchange(@ptrCast(*const IHTMLDocument4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_namespaces(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_namespaces(@ptrCast(*const IHTMLDocument4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_createDocumentFromUrl(self: *const T, bstrUrl: BSTR, bstrOptions: BSTR, newDoc: **IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).createDocumentFromUrl(@ptrCast(*const IHTMLDocument4, self), bstrUrl, bstrOptions, newDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_put_media(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).put_media(@ptrCast(*const IHTMLDocument4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_media(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_media(@ptrCast(*const IHTMLDocument4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_createEventObject(self: *const T, pvarEventObject: *VARIANT, ppEventObj: **IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).createEventObject(@ptrCast(*const IHTMLDocument4, self), pvarEventObject, ppEventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_fireEvent(self: *const T, bstrEventName: BSTR, pvarEventObject: *VARIANT, pfCancelled: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).fireEvent(@ptrCast(*const IHTMLDocument4, self), bstrEventName, pvarEventObject, pfCancelled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_createRenderStyle(self: *const T, v: BSTR, ppIHTMLRenderStyle: **IHTMLRenderStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).createRenderStyle(@ptrCast(*const IHTMLDocument4, self), v, ppIHTMLRenderStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_put_oncontrolselect(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).put_oncontrolselect(@ptrCast(*const IHTMLDocument4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_oncontrolselect(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_oncontrolselect(@ptrCast(*const IHTMLDocument4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument4_get_URLUnencoded(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument4.VTable, self.vtable).get_URLUnencoded(@ptrCast(*const IHTMLDocument4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument5_Value = @import("../zig.zig").Guid.initString("3050F80C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDocument5 = &IID_IHTMLDocument5_Value;
pub const IHTMLDocument5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onmousewheel: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmousewheel: fn(
            self: *const IHTMLDocument5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_doctype: fn(
            self: *const IHTMLDocument5,
            p: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_implementation: fn(
            self: *const IHTMLDocument5,
            p: **IHTMLDOMImplementation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createAttribute: fn(
            self: *const IHTMLDocument5,
            bstrattrName: BSTR,
            ppattribute: **IHTMLDOMAttribute,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createComment: fn(
            self: *const IHTMLDocument5,
            bstrdata: BSTR,
            ppRetNode: **IHTMLDOMNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocusin: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocusin: fn(
            self: *const IHTMLDocument5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocusout: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocusout: fn(
            self: *const IHTMLDocument5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onactivate: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onactivate: fn(
            self: *const IHTMLDocument5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ondeactivate: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ondeactivate: fn(
            self: *const IHTMLDocument5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeactivate: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeactivate: fn(
            self: *const IHTMLDocument5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforedeactivate: fn(
            self: *const IHTMLDocument5,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforedeactivate: fn(
            self: *const IHTMLDocument5,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_compatMode: fn(
            self: *const IHTMLDocument5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onmousewheel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onmousewheel(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onmousewheel(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onmousewheel(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_doctype(self: *const T, p: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_doctype(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_implementation(self: *const T, p: **IHTMLDOMImplementation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_implementation(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_createAttribute(self: *const T, bstrattrName: BSTR, ppattribute: **IHTMLDOMAttribute) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).createAttribute(@ptrCast(*const IHTMLDocument5, self), bstrattrName, ppattribute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_createComment(self: *const T, bstrdata: BSTR, ppRetNode: **IHTMLDOMNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).createComment(@ptrCast(*const IHTMLDocument5, self), bstrdata, ppRetNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onfocusin(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onfocusin(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onfocusin(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onfocusin(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onfocusout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onfocusout(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onfocusout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onfocusout(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onactivate(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onactivate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onactivate(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_ondeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_ondeactivate(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_ondeactivate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_ondeactivate(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onbeforeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onbeforeactivate(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onbeforeactivate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onbeforeactivate(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_put_onbeforedeactivate(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).put_onbeforedeactivate(@ptrCast(*const IHTMLDocument5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_onbeforedeactivate(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_onbeforedeactivate(@ptrCast(*const IHTMLDocument5, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument5_get_compatMode(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument5.VTable, self.vtable).get_compatMode(@ptrCast(*const IHTMLDocument5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument6_Value = @import("../zig.zig").Guid.initString("30510417-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDocument6 = &IID_IHTMLDocument6_Value;
pub const IHTMLDocument6 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_compatible: fn(
            self: *const IHTMLDocument6,
            p: **IHTMLDocumentCompatibleInfoCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_documentMode: fn(
            self: *const IHTMLDocument6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstorage: fn(
            self: *const IHTMLDocument6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstorage: fn(
            self: *const IHTMLDocument6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstoragecommit: fn(
            self: *const IHTMLDocument6,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstoragecommit: fn(
            self: *const IHTMLDocument6,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getElementById: fn(
            self: *const IHTMLDocument6,
            bstrId: BSTR,
            ppRetElement: **IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        updateSettings: fn(
            self: *const IHTMLDocument6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_get_compatible(self: *const T, p: **IHTMLDocumentCompatibleInfoCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).get_compatible(@ptrCast(*const IHTMLDocument6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_get_documentMode(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).get_documentMode(@ptrCast(*const IHTMLDocument6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_put_onstorage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).put_onstorage(@ptrCast(*const IHTMLDocument6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_get_onstorage(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).get_onstorage(@ptrCast(*const IHTMLDocument6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_put_onstoragecommit(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).put_onstoragecommit(@ptrCast(*const IHTMLDocument6, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_get_onstoragecommit(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).get_onstoragecommit(@ptrCast(*const IHTMLDocument6, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_getElementById(self: *const T, bstrId: BSTR, ppRetElement: **IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).getElementById(@ptrCast(*const IHTMLDocument6, self), bstrId, ppRetElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument6_updateSettings(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument6.VTable, self.vtable).updateSettings(@ptrCast(*const IHTMLDocument6, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDocument8_Value = @import("../zig.zig").Guid.initString("305107D0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDocument8 = &IID_IHTMLDocument8_Value;
pub const IHTMLDocument8 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onmscontentzoom: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmscontentzoom: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerdown: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerdown: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointermove: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointermove: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerup: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerup: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerover: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerover: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerout: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerout: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointercancel: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointercancel: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmspointerhover: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmspointerhover: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturestart: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturestart: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturechange: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturechange: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgestureend: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgestureend: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturehold: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturehold: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturetap: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturetap: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsgesturedoubletap: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsgesturedoubletap: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsinertiastart: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsinertiastart: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        elementsFromPoint: fn(
            self: *const IHTMLDocument8,
            x: f32,
            y: f32,
            elementsHit: **IHTMLDOMChildrenCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        elementsFromRect: fn(
            self: *const IHTMLDocument8,
            left: f32,
            top: f32,
            width: f32,
            height: f32,
            elementsHit: **IHTMLDOMChildrenCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmsmanipulationstatechanged: fn(
            self: *const IHTMLDocument8,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmsmanipulationstatechanged: fn(
            self: *const IHTMLDocument8,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msCapsLockWarningOff: fn(
            self: *const IHTMLDocument8,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msCapsLockWarningOff: fn(
            self: *const IHTMLDocument8,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmscontentzoom(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmscontentzoom(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmscontentzoom(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmscontentzoom(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerdown(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerdown(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerdown(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerdown(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointermove(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointermove(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointermove(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointermove(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerup(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerup(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerup(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerup(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerover(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerover(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerout(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerout(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointercancel(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointercancel(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointercancel(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointercancel(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmspointerhover(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmspointerhover(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmspointerhover(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmspointerhover(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturestart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturestart(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturestart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturestart(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturechange(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturechange(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgestureend(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgestureend(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgestureend(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgestureend(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturehold(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturehold(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturehold(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturehold(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturetap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturetap(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturetap(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturetap(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsgesturedoubletap(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsgesturedoubletap(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsgesturedoubletap(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsgesturedoubletap(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsinertiastart(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsinertiastart(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsinertiastart(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsinertiastart(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_elementsFromPoint(self: *const T, x: f32, y: f32, elementsHit: **IHTMLDOMChildrenCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).elementsFromPoint(@ptrCast(*const IHTMLDocument8, self), x, y, elementsHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_elementsFromRect(self: *const T, left: f32, top: f32, width: f32, height: f32, elementsHit: **IHTMLDOMChildrenCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).elementsFromRect(@ptrCast(*const IHTMLDocument8, self), left, top, width, height, elementsHit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_onmsmanipulationstatechanged(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_onmsmanipulationstatechanged(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_onmsmanipulationstatechanged(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_onmsmanipulationstatechanged(@ptrCast(*const IHTMLDocument8, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_put_msCapsLockWarningOff(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).put_msCapsLockWarningOff(@ptrCast(*const IHTMLDocument8, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDocument8_get_msCapsLockWarningOff(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDocument8.VTable, self.vtable).get_msCapsLockWarningOff(@ptrCast(*const IHTMLDocument8, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocumentEvent_Value = @import("../zig.zig").Guid.initString("305104BC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDocumentEvent = &IID_IDocumentEvent_Value;
pub const IDocumentEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createEvent: fn(
            self: *const IDocumentEvent,
            eventType: BSTR,
            ppEvent: **IDOMEvent,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentEvent_createEvent(self: *const T, eventType: BSTR, ppEvent: **IDOMEvent) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentEvent.VTable, self.vtable).createEvent(@ptrCast(*const IDocumentEvent, self), eventType, ppEvent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocumentRange_Value = @import("../zig.zig").Guid.initString("305104AF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDocumentRange = &IID_IDocumentRange_Value;
pub const IDocumentRange = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createRange: fn(
            self: *const IDocumentRange,
            ppIHTMLDOMRange: **IHTMLDOMRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentRange_createRange(self: *const T, ppIHTMLDOMRange: **IHTMLDOMRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentRange.VTable, self.vtable).createRange(@ptrCast(*const IDocumentRange, self), ppIHTMLDOMRange);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocumentSelector_Value = @import("../zig.zig").Guid.initString("30510462-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDocumentSelector = &IID_IDocumentSelector_Value;
pub const IDocumentSelector = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        querySelector: fn(
            self: *const IDocumentSelector,
            v: BSTR,
            pel: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        querySelectorAll: fn(
            self: *const IDocumentSelector,
            v: BSTR,
            pel: **IHTMLDOMChildrenCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentSelector_querySelector(self: *const T, v: BSTR, pel: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentSelector.VTable, self.vtable).querySelector(@ptrCast(*const IDocumentSelector, self), v, pel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentSelector_querySelectorAll(self: *const T, v: BSTR, pel: **IHTMLDOMChildrenCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentSelector.VTable, self.vtable).querySelectorAll(@ptrCast(*const IDocumentSelector, self), v, pel);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDocumentTraversal_Value = @import("../zig.zig").Guid.initString("30510744-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDocumentTraversal = &IID_IDocumentTraversal_Value;
pub const IDocumentTraversal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        createNodeIterator: fn(
            self: *const IDocumentTraversal,
            pRootNode: *IDispatch,
            ulWhatToShow: i32,
            pFilter: *VARIANT,
            fEntityReferenceExpansion: i16,
            ppNodeIterator: **IDOMNodeIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTreeWalker: fn(
            self: *const IDocumentTraversal,
            pRootNode: *IDispatch,
            ulWhatToShow: i32,
            pFilter: *VARIANT,
            fEntityReferenceExpansion: i16,
            ppTreeWalker: **IDOMTreeWalker,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentTraversal_createNodeIterator(self: *const T, pRootNode: *IDispatch, ulWhatToShow: i32, pFilter: *VARIANT, fEntityReferenceExpansion: i16, ppNodeIterator: **IDOMNodeIterator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentTraversal.VTable, self.vtable).createNodeIterator(@ptrCast(*const IDocumentTraversal, self), pRootNode, ulWhatToShow, pFilter, fEntityReferenceExpansion, ppNodeIterator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDocumentTraversal_createTreeWalker(self: *const T, pRootNode: *IDispatch, ulWhatToShow: i32, pFilter: *VARIANT, fEntityReferenceExpansion: i16, ppTreeWalker: **IDOMTreeWalker) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDocumentTraversal.VTable, self.vtable).createTreeWalker(@ptrCast(*const IDocumentTraversal, self), pRootNode, ulWhatToShow, pFilter, fEntityReferenceExpansion, ppTreeWalker);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDocument_Value = @import("../zig.zig").Guid.initString("3050F55F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDocument = &IID_DispHTMLDocument_Value;
pub const DispHTMLDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DWebBridgeEvents_Value = @import("../zig.zig").Guid.initString("A6D897FF-0A95-11D1-B0BA-006008166E11");
pub const IID_DWebBridgeEvents = &IID_DWebBridgeEvents_Value;
pub const DWebBridgeEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebBridge_Value = @import("../zig.zig").Guid.initString("AE24FDAD-03C6-11D1-8B76-0080C744F389");
pub const IID_IWebBridge = &IID_IWebBridge_Value;
pub const IWebBridge = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_URL: fn(
            self: *const IWebBridge,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_URL: fn(
            self: *const IWebBridge,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Scrollbar: fn(
            self: *const IWebBridge,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Scrollbar: fn(
            self: *const IWebBridge,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_embed: fn(
            self: *const IWebBridge,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_embed: fn(
            self: *const IWebBridge,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_event: fn(
            self: *const IWebBridge,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IWebBridge,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AboutBox: fn(
            self: *const IWebBridge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_put_URL(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).put_URL(@ptrCast(*const IWebBridge, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_URL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_URL(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_put_Scrollbar(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).put_Scrollbar(@ptrCast(*const IWebBridge, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_Scrollbar(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_Scrollbar(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_put_embed(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).put_embed(@ptrCast(*const IWebBridge, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_embed(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_embed(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_event(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_event(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_get_readyState(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).get_readyState(@ptrCast(*const IWebBridge, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebBridge_AboutBox(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebBridge.VTable, self.vtable).AboutBox(@ptrCast(*const IWebBridge, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWBScriptControl_Value = @import("../zig.zig").Guid.initString("A5170870-0CF8-11D1-8B91-0080C744F389");
pub const IID_IWBScriptControl = &IID_IWBScriptControl_Value;
pub const IWBScriptControl = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        raiseEvent: fn(
            self: *const IWBScriptControl,
            name: BSTR,
            eventData: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        bubbleEvent: fn(
            self: *const IWBScriptControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setContextMenu: fn(
            self: *const IWBScriptControl,
            menuItemPairs: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_selectableContent: fn(
            self: *const IWBScriptControl,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectableContent: fn(
            self: *const IWBScriptControl,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frozen: fn(
            self: *const IWBScriptControl,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollbar: fn(
            self: *const IWBScriptControl,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollbar: fn(
            self: *const IWBScriptControl,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_version: fn(
            self: *const IWBScriptControl,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_visibility: fn(
            self: *const IWBScriptControl,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onvisibilitychange: fn(
            self: *const IWBScriptControl,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onvisibilitychange: fn(
            self: *const IWBScriptControl,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_raiseEvent(self: *const T, name: BSTR, eventData: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).raiseEvent(@ptrCast(*const IWBScriptControl, self), name, eventData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_bubbleEvent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).bubbleEvent(@ptrCast(*const IWBScriptControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_setContextMenu(self: *const T, menuItemPairs: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).setContextMenu(@ptrCast(*const IWBScriptControl, self), menuItemPairs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_put_selectableContent(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).put_selectableContent(@ptrCast(*const IWBScriptControl, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_selectableContent(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_selectableContent(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_frozen(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_frozen(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_put_scrollbar(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).put_scrollbar(@ptrCast(*const IWBScriptControl, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_scrollbar(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_scrollbar(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_version(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_version(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_visibility(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_visibility(@ptrCast(*const IWBScriptControl, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_put_onvisibilitychange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).put_onvisibilitychange(@ptrCast(*const IWBScriptControl, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWBScriptControl_get_onvisibilitychange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWBScriptControl.VTable, self.vtable).get_onvisibilitychange(@ptrCast(*const IWBScriptControl, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEmbedElement_Value = @import("../zig.zig").Guid.initString("3050F25F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEmbedElement = &IID_IHTMLEmbedElement_Value;
pub const IHTMLEmbedElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_hidden: fn(
            self: *const IHTMLEmbedElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hidden: fn(
            self: *const IHTMLEmbedElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_palette: fn(
            self: *const IHTMLEmbedElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pluginspage: fn(
            self: *const IHTMLEmbedElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_src: fn(
            self: *const IHTMLEmbedElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLEmbedElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_units: fn(
            self: *const IHTMLEmbedElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_units: fn(
            self: *const IHTMLEmbedElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLEmbedElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLEmbedElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLEmbedElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLEmbedElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLEmbedElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLEmbedElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_hidden(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_hidden(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_hidden(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_hidden(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_palette(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_palette(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_pluginspage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_pluginspage(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_units(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_units(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_units(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_units(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLEmbedElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLEmbedElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEmbedElement2_Value = @import("../zig.zig").Guid.initString("30510493-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEmbedElement2 = &IID_IHTMLEmbedElement2_Value;
pub const IHTMLEmbedElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_src: fn(
            self: *const IHTMLEmbedElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLEmbedElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pluginspage: fn(
            self: *const IHTMLEmbedElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement2_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement2.VTable, self.vtable).put_src(@ptrCast(*const IHTMLEmbedElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement2_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement2.VTable, self.vtable).get_src(@ptrCast(*const IHTMLEmbedElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEmbedElement2_get_pluginspage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEmbedElement2.VTable, self.vtable).get_pluginspage(@ptrCast(*const IHTMLEmbedElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLEmbed_Value = @import("../zig.zig").Guid.initString("3050F52E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLEmbed = &IID_DispHTMLEmbed_Value;
pub const DispHTMLEmbed = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLMapEvents2_Value = @import("../zig.zig").Guid.initString("3050F61E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLMapEvents2 = &IID_HTMLMapEvents2_Value;
pub const HTMLMapEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLMapEvents_Value = @import("../zig.zig").Guid.initString("3050F3BA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLMapEvents = &IID_HTMLMapEvents_Value;
pub const HTMLMapEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreasCollection_Value = @import("../zig.zig").Guid.initString("3050F383-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAreasCollection = &IID_IHTMLAreasCollection_Value;
pub const IHTMLAreasCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_length: fn(
            self: *const IHTMLAreasCollection,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLAreasCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLAreasCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAreasCollection,
            name: VARIANT,
            index: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        tags: fn(
            self: *const IHTMLAreasCollection,
            tagName: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        add: fn(
            self: *const IHTMLAreasCollection,
            element: *IHTMLElement,
            before: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        remove: fn(
            self: *const IHTMLAreasCollection,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_put_length(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).put_length(@ptrCast(*const IHTMLAreasCollection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAreasCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLAreasCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_item(self: *const T, name: VARIANT, index: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLAreasCollection, self), name, index, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_tags(self: *const T, tagName: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).tags(@ptrCast(*const IHTMLAreasCollection, self), tagName, pdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_add(self: *const T, element: *IHTMLElement, before: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).add(@ptrCast(*const IHTMLAreasCollection, self), element, before);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection_remove(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection.VTable, self.vtable).remove(@ptrCast(*const IHTMLAreasCollection, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreasCollection2_Value = @import("../zig.zig").Guid.initString("3050F5EC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAreasCollection2 = &IID_IHTMLAreasCollection2_Value;
pub const IHTMLAreasCollection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        urns: fn(
            self: *const IHTMLAreasCollection2,
            urn: VARIANT,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection2_urns(self: *const T, urn: VARIANT, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection2.VTable, self.vtable).urns(@ptrCast(*const IHTMLAreasCollection2, self), urn, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreasCollection3_Value = @import("../zig.zig").Guid.initString("3050F837-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAreasCollection3 = &IID_IHTMLAreasCollection3_Value;
pub const IHTMLAreasCollection3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedItem: fn(
            self: *const IHTMLAreasCollection3,
            name: BSTR,
            pdisp: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection3_namedItem(self: *const T, name: BSTR, pdisp: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection3.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLAreasCollection3, self), name, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreasCollection4_Value = @import("../zig.zig").Guid.initString("30510492-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAreasCollection4 = &IID_IHTMLAreasCollection4_Value;
pub const IHTMLAreasCollection4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLAreasCollection4,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLAreasCollection4,
            index: i32,
            pNode: **IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        namedItem: fn(
            self: *const IHTMLAreasCollection4,
            name: BSTR,
            pNode: **IHTMLElement2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection4_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection4.VTable, self.vtable).get_length(@ptrCast(*const IHTMLAreasCollection4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection4_item(self: *const T, index: i32, pNode: **IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection4.VTable, self.vtable).item(@ptrCast(*const IHTMLAreasCollection4, self), index, pNode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreasCollection4_namedItem(self: *const T, name: BSTR, pNode: **IHTMLElement2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreasCollection4.VTable, self.vtable).namedItem(@ptrCast(*const IHTMLAreasCollection4, self), name, pNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMapElement_Value = @import("../zig.zig").Guid.initString("3050F266-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMapElement = &IID_IHTMLMapElement_Value;
pub const IHTMLMapElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_areas: fn(
            self: *const IHTMLMapElement,
            p: **IHTMLAreasCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLMapElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLMapElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMapElement_get_areas(self: *const T, p: **IHTMLAreasCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMapElement.VTable, self.vtable).get_areas(@ptrCast(*const IHTMLMapElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMapElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMapElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLMapElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMapElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMapElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLMapElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAreasCollection_Value = @import("../zig.zig").Guid.initString("3050F56A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLAreasCollection = &IID_DispHTMLAreasCollection_Value;
pub const DispHTMLAreasCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMapElement_Value = @import("../zig.zig").Guid.initString("3050F526-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLMapElement = &IID_DispHTMLMapElement_Value;
pub const DispHTMLMapElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLAreaEvents2_Value = @import("../zig.zig").Guid.initString("3050F611-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLAreaEvents2 = &IID_HTMLAreaEvents2_Value;
pub const HTMLAreaEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLAreaEvents_Value = @import("../zig.zig").Guid.initString("3050F366-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLAreaEvents = &IID_HTMLAreaEvents_Value;
pub const HTMLAreaEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreaElement_Value = @import("../zig.zig").Guid.initString("3050F265-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAreaElement = &IID_IHTMLAreaElement_Value;
pub const IHTMLAreaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_shape: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shape: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_coords: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_coords: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_href: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_target: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_target: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alt: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alt: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_noHref: fn(
            self: *const IHTMLAreaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_noHref: fn(
            self: *const IHTMLAreaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_host: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_host: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hostname: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hostname: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pathname: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pathname: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_port: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_port: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_protocol: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_protocol: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_search: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_search: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hash: fn(
            self: *const IHTMLAreaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hash: fn(
            self: *const IHTMLAreaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onblur: fn(
            self: *const IHTMLAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onblur: fn(
            self: *const IHTMLAreaElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onfocus: fn(
            self: *const IHTMLAreaElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onfocus: fn(
            self: *const IHTMLAreaElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_tabIndex: fn(
            self: *const IHTMLAreaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tabIndex: fn(
            self: *const IHTMLAreaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        focus: fn(
            self: *const IHTMLAreaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        blur: fn(
            self: *const IHTMLAreaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_shape(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_shape(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_shape(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_shape(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_coords(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_coords(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_coords(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_coords(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_href(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_href(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_target(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_target(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_target(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_target(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_alt(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_alt(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_noHref(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_noHref(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_noHref(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_noHref(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_host(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_host(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_host(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_host(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_hostname(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_hostname(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_hostname(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_hostname(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_pathname(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_pathname(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_pathname(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_pathname(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_port(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_port(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_port(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_port(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_protocol(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_protocol(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_protocol(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_protocol(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_search(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_search(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_search(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_search(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_hash(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_hash(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_hash(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_hash(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_onblur(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_onblur(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_onblur(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_onblur(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_onfocus(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_onfocus(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_onfocus(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_onfocus(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_put_tabIndex(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).put_tabIndex(@ptrCast(*const IHTMLAreaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_get_tabIndex(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).get_tabIndex(@ptrCast(*const IHTMLAreaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_focus(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).focus(@ptrCast(*const IHTMLAreaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement_blur(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement.VTable, self.vtable).blur(@ptrCast(*const IHTMLAreaElement, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAreaElement2_Value = @import("../zig.zig").Guid.initString("3051041F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAreaElement2 = &IID_IHTMLAreaElement2_Value;
pub const IHTMLAreaElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_shape: fn(
            self: *const IHTMLAreaElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shape: fn(
            self: *const IHTMLAreaElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_coords: fn(
            self: *const IHTMLAreaElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_coords: fn(
            self: *const IHTMLAreaElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_href: fn(
            self: *const IHTMLAreaElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_href: fn(
            self: *const IHTMLAreaElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_put_shape(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).put_shape(@ptrCast(*const IHTMLAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_get_shape(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).get_shape(@ptrCast(*const IHTMLAreaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_put_coords(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).put_coords(@ptrCast(*const IHTMLAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_get_coords(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).get_coords(@ptrCast(*const IHTMLAreaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_put_href(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).put_href(@ptrCast(*const IHTMLAreaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAreaElement2_get_href(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAreaElement2.VTable, self.vtable).get_href(@ptrCast(*const IHTMLAreaElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAreaElement_Value = @import("../zig.zig").Guid.initString("3050F503-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLAreaElement = &IID_DispHTMLAreaElement_Value;
pub const DispHTMLAreaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCaption_Value = @import("../zig.zig").Guid.initString("3050F2EB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableCaption = &IID_IHTMLTableCaption_Value;
pub const IHTMLTableCaption = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLTableCaption,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLTableCaption,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vAlign: fn(
            self: *const IHTMLTableCaption,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vAlign: fn(
            self: *const IHTMLTableCaption,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCaption_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCaption.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableCaption, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCaption_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCaption.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableCaption, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCaption_put_vAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCaption.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableCaption, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCaption_get_vAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCaption.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableCaption, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableCaption_Value = @import("../zig.zig").Guid.initString("3050F508-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTableCaption = &IID_DispHTMLTableCaption_Value;
pub const DispHTMLTableCaption = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCommentElement_Value = @import("../zig.zig").Guid.initString("3050F20C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCommentElement = &IID_IHTMLCommentElement_Value;
pub const IHTMLCommentElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_text: fn(
            self: *const IHTMLCommentElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_text: fn(
            self: *const IHTMLCommentElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_atomic: fn(
            self: *const IHTMLCommentElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_atomic: fn(
            self: *const IHTMLCommentElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement_put_text(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLCommentElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement_get_text(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLCommentElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement_put_atomic(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement.VTable, self.vtable).put_atomic(@ptrCast(*const IHTMLCommentElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement_get_atomic(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement.VTable, self.vtable).get_atomic(@ptrCast(*const IHTMLCommentElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCommentElement2_Value = @import("../zig.zig").Guid.initString("3050F813-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCommentElement2 = &IID_IHTMLCommentElement2_Value;
pub const IHTMLCommentElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_data: fn(
            self: *const IHTMLCommentElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_data: fn(
            self: *const IHTMLCommentElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLCommentElement2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        substringData: fn(
            self: *const IHTMLCommentElement2,
            offset: i32,
            Count: i32,
            pbstrsubString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendData: fn(
            self: *const IHTMLCommentElement2,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IHTMLCommentElement2,
            offset: i32,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IHTMLCommentElement2,
            offset: i32,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IHTMLCommentElement2,
            offset: i32,
            Count: i32,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_put_data(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).put_data(@ptrCast(*const IHTMLCommentElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).get_data(@ptrCast(*const IHTMLCommentElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).get_length(@ptrCast(*const IHTMLCommentElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_substringData(self: *const T, offset: i32, Count: i32, pbstrsubString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).substringData(@ptrCast(*const IHTMLCommentElement2, self), offset, Count, pbstrsubString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_appendData(self: *const T, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).appendData(@ptrCast(*const IHTMLCommentElement2, self), bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_insertData(self: *const T, offset: i32, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).insertData(@ptrCast(*const IHTMLCommentElement2, self), offset, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_deleteData(self: *const T, offset: i32, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).deleteData(@ptrCast(*const IHTMLCommentElement2, self), offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement2_replaceData(self: *const T, offset: i32, Count: i32, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement2.VTable, self.vtable).replaceData(@ptrCast(*const IHTMLCommentElement2, self), offset, Count, bstrstring);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCommentElement3_Value = @import("../zig.zig").Guid.initString("3051073F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCommentElement3 = &IID_IHTMLCommentElement3_Value;
pub const IHTMLCommentElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        substringData: fn(
            self: *const IHTMLCommentElement3,
            offset: i32,
            Count: i32,
            pbstrsubString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertData: fn(
            self: *const IHTMLCommentElement3,
            offset: i32,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteData: fn(
            self: *const IHTMLCommentElement3,
            offset: i32,
            Count: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceData: fn(
            self: *const IHTMLCommentElement3,
            offset: i32,
            Count: i32,
            bstrstring: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement3_substringData(self: *const T, offset: i32, Count: i32, pbstrsubString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement3.VTable, self.vtable).substringData(@ptrCast(*const IHTMLCommentElement3, self), offset, Count, pbstrsubString);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement3_insertData(self: *const T, offset: i32, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement3.VTable, self.vtable).insertData(@ptrCast(*const IHTMLCommentElement3, self), offset, bstrstring);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement3_deleteData(self: *const T, offset: i32, Count: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement3.VTable, self.vtable).deleteData(@ptrCast(*const IHTMLCommentElement3, self), offset, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCommentElement3_replaceData(self: *const T, offset: i32, Count: i32, bstrstring: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCommentElement3.VTable, self.vtable).replaceData(@ptrCast(*const IHTMLCommentElement3, self), offset, Count, bstrstring);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCommentElement_Value = @import("../zig.zig").Guid.initString("3050F50A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLCommentElement = &IID_DispHTMLCommentElement_Value;
pub const DispHTMLCommentElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPhraseElement_Value = @import("../zig.zig").Guid.initString("3050F20A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPhraseElement = &IID_IHTMLPhraseElement_Value;
pub const IHTMLPhraseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPhraseElement2_Value = @import("../zig.zig").Guid.initString("3050F824-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPhraseElement2 = &IID_IHTMLPhraseElement2_Value;
pub const IHTMLPhraseElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_cite: fn(
            self: *const IHTMLPhraseElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cite: fn(
            self: *const IHTMLPhraseElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dateTime: fn(
            self: *const IHTMLPhraseElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dateTime: fn(
            self: *const IHTMLPhraseElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement2_put_cite(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement2.VTable, self.vtable).put_cite(@ptrCast(*const IHTMLPhraseElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement2_get_cite(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement2.VTable, self.vtable).get_cite(@ptrCast(*const IHTMLPhraseElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement2_put_dateTime(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement2.VTable, self.vtable).put_dateTime(@ptrCast(*const IHTMLPhraseElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement2_get_dateTime(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement2.VTable, self.vtable).get_dateTime(@ptrCast(*const IHTMLPhraseElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPhraseElement3_Value = @import("../zig.zig").Guid.initString("3051043D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPhraseElement3 = &IID_IHTMLPhraseElement3_Value;
pub const IHTMLPhraseElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_cite: fn(
            self: *const IHTMLPhraseElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cite: fn(
            self: *const IHTMLPhraseElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement3_put_cite(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement3.VTable, self.vtable).put_cite(@ptrCast(*const IHTMLPhraseElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPhraseElement3_get_cite(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPhraseElement3.VTable, self.vtable).get_cite(@ptrCast(*const IHTMLPhraseElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSpanElement_Value = @import("../zig.zig").Guid.initString("3050F3F3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSpanElement = &IID_IHTMLSpanElement_Value;
pub const IHTMLSpanElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPhraseElement_Value = @import("../zig.zig").Guid.initString("3050F52D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLPhraseElement = &IID_DispHTMLPhraseElement_Value;
pub const DispHTMLPhraseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSpanElement_Value = @import("../zig.zig").Guid.initString("3050F548-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLSpanElement = &IID_DispHTMLSpanElement_Value;
pub const DispHTMLSpanElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLTableEvents2_Value = @import("../zig.zig").Guid.initString("3050F623-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLTableEvents2 = &IID_HTMLTableEvents2_Value;
pub const HTMLTableEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLTableEvents_Value = @import("../zig.zig").Guid.initString("3050F407-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLTableEvents = &IID_HTMLTableEvents_Value;
pub const HTMLTableEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableSection_Value = @import("../zig.zig").Guid.initString("3050F23B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableSection = &IID_IHTMLTableSection_Value;
pub const IHTMLTableSection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLTableSection,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLTableSection,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vAlign: fn(
            self: *const IHTMLTableSection,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vAlign: fn(
            self: *const IHTMLTableSection,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bgColor: fn(
            self: *const IHTMLTableSection,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bgColor: fn(
            self: *const IHTMLTableSection,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rows: fn(
            self: *const IHTMLTableSection,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRow: fn(
            self: *const IHTMLTableSection,
            index: i32,
            row: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRow: fn(
            self: *const IHTMLTableSection,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableSection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableSection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_put_vAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableSection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_get_vAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableSection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLTableSection, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_get_bgColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLTableSection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_get_rows(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).get_rows(@ptrCast(*const IHTMLTableSection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_insertRow(self: *const T, index: i32, row: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).insertRow(@ptrCast(*const IHTMLTableSection, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection_deleteRow(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection.VTable, self.vtable).deleteRow(@ptrCast(*const IHTMLTableSection, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTable_Value = @import("../zig.zig").Guid.initString("3050F21E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTable = &IID_IHTMLTable_Value;
pub const IHTMLTable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_cols: fn(
            self: *const IHTMLTable,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cols: fn(
            self: *const IHTMLTable,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frame: fn(
            self: *const IHTMLTable,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frame: fn(
            self: *const IHTMLTable,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_rules: fn(
            self: *const IHTMLTable,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rules: fn(
            self: *const IHTMLTable,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cellSpacing: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cellSpacing: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cellPadding: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cellPadding: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_background: fn(
            self: *const IHTMLTable,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_background: fn(
            self: *const IHTMLTable,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bgColor: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bgColor: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColor: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColor: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColorLight: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColorLight: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColorDark: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColorDark: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_align: fn(
            self: *const IHTMLTable,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLTable,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        refresh: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rows: fn(
            self: *const IHTMLTable,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dataPageSize: fn(
            self: *const IHTMLTable,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dataPageSize: fn(
            self: *const IHTMLTable,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        nextPage: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        previousPage: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tHead: fn(
            self: *const IHTMLTable,
            p: **IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tFoot: fn(
            self: *const IHTMLTable,
            p: **IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tBodies: fn(
            self: *const IHTMLTable,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_caption: fn(
            self: *const IHTMLTable,
            p: **IHTMLTableCaption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTHead: fn(
            self: *const IHTMLTable,
            head: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteTHead: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTFoot: fn(
            self: *const IHTMLTable,
            foot: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteTFoot: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createCaption: fn(
            self: *const IHTMLTable,
            caption: **IHTMLTableCaption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteCaption: fn(
            self: *const IHTMLTable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRow: fn(
            self: *const IHTMLTable,
            index: i32,
            row: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRow: fn(
            self: *const IHTMLTable,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLTable,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLTable,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLTable,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_cols(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_cols(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_cols(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_cols(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_border(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_border(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_border(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_frame(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_frame(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_frame(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_frame(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_rules(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_rules(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_rules(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_rules(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_cellSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_cellSpacing(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_cellSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_cellSpacing(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_cellPadding(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_cellPadding(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_cellPadding(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_cellPadding(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_background(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_background(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_background(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_background(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_bgColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_borderColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_borderColorLight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_borderColorLight(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_borderColorLight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_borderColorLight(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_borderColorDark(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_borderColorDark(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_borderColorDark(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_borderColorDark(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).refresh(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_rows(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_rows(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_width(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_width(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_height(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_height(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_dataPageSize(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_dataPageSize(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_dataPageSize(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_dataPageSize(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_nextPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).nextPage(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_previousPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).previousPage(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_tHead(self: *const T, p: **IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_tHead(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_tFoot(self: *const T, p: **IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_tFoot(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_tBodies(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_tBodies(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_caption(self: *const T, p: **IHTMLTableCaption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_caption(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_createTHead(self: *const T, head: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).createTHead(@ptrCast(*const IHTMLTable, self), head);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_deleteTHead(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).deleteTHead(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_createTFoot(self: *const T, foot: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).createTFoot(@ptrCast(*const IHTMLTable, self), foot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_deleteTFoot(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).deleteTFoot(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_createCaption(self: *const T, caption: **IHTMLTableCaption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).createCaption(@ptrCast(*const IHTMLTable, self), caption);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_deleteCaption(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).deleteCaption(@ptrCast(*const IHTMLTable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_insertRow(self: *const T, index: i32, row: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).insertRow(@ptrCast(*const IHTMLTable, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_deleteRow(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).deleteRow(@ptrCast(*const IHTMLTable, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_readyState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLTable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLTable, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLTable, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTable2_Value = @import("../zig.zig").Guid.initString("3050F4AD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTable2 = &IID_IHTMLTable2_Value;
pub const IHTMLTable2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        firstPage: fn(
            self: *const IHTMLTable2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lastPage: fn(
            self: *const IHTMLTable2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cells: fn(
            self: *const IHTMLTable2,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveRow: fn(
            self: *const IHTMLTable2,
            indexFrom: i32,
            indexTo: i32,
            row: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable2_firstPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable2.VTable, self.vtable).firstPage(@ptrCast(*const IHTMLTable2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable2_lastPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable2.VTable, self.vtable).lastPage(@ptrCast(*const IHTMLTable2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable2_get_cells(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable2.VTable, self.vtable).get_cells(@ptrCast(*const IHTMLTable2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable2_moveRow(self: *const T, indexFrom: i32, indexTo: i32, row: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable2.VTable, self.vtable).moveRow(@ptrCast(*const IHTMLTable2, self), indexFrom, indexTo, row);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTable3_Value = @import("../zig.zig").Guid.initString("3050F829-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTable3 = &IID_IHTMLTable3_Value;
pub const IHTMLTable3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_summary: fn(
            self: *const IHTMLTable3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_summary: fn(
            self: *const IHTMLTable3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable3_put_summary(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable3.VTable, self.vtable).put_summary(@ptrCast(*const IHTMLTable3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable3_get_summary(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable3.VTable, self.vtable).get_summary(@ptrCast(*const IHTMLTable3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTable4_Value = @import("../zig.zig").Guid.initString("305106C2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTable4 = &IID_IHTMLTable4_Value;
pub const IHTMLTable4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_tHead: fn(
            self: *const IHTMLTable4,
            v: *IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tHead: fn(
            self: *const IHTMLTable4,
            p: **IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_tFoot: fn(
            self: *const IHTMLTable4,
            v: *IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tFoot: fn(
            self: *const IHTMLTable4,
            p: **IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_caption: fn(
            self: *const IHTMLTable4,
            v: *IHTMLTableCaption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_caption: fn(
            self: *const IHTMLTable4,
            p: **IHTMLTableCaption,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRow: fn(
            self: *const IHTMLTable4,
            index: i32,
            row: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRow: fn(
            self: *const IHTMLTable4,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createTBody: fn(
            self: *const IHTMLTable4,
            tbody: **IHTMLTableSection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_putref_tHead(self: *const T, v: *IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).putref_tHead(@ptrCast(*const IHTMLTable4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_get_tHead(self: *const T, p: **IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).get_tHead(@ptrCast(*const IHTMLTable4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_putref_tFoot(self: *const T, v: *IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).putref_tFoot(@ptrCast(*const IHTMLTable4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_get_tFoot(self: *const T, p: **IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).get_tFoot(@ptrCast(*const IHTMLTable4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_putref_caption(self: *const T, v: *IHTMLTableCaption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).putref_caption(@ptrCast(*const IHTMLTable4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_get_caption(self: *const T, p: **IHTMLTableCaption) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).get_caption(@ptrCast(*const IHTMLTable4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_insertRow(self: *const T, index: i32, row: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).insertRow(@ptrCast(*const IHTMLTable4, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_deleteRow(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).deleteRow(@ptrCast(*const IHTMLTable4, self), index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTable4_createTBody(self: *const T, tbody: **IHTMLTableSection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTable4.VTable, self.vtable).createTBody(@ptrCast(*const IHTMLTable4, self), tbody);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCol_Value = @import("../zig.zig").Guid.initString("3050F23A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableCol = &IID_IHTMLTableCol_Value;
pub const IHTMLTableCol = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_span: fn(
            self: *const IHTMLTableCol,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_span: fn(
            self: *const IHTMLTableCol,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLTableCol,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLTableCol,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_align: fn(
            self: *const IHTMLTableCol,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLTableCol,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vAlign: fn(
            self: *const IHTMLTableCol,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vAlign: fn(
            self: *const IHTMLTableCol,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_put_span(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).put_span(@ptrCast(*const IHTMLTableCol, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_get_span(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).get_span(@ptrCast(*const IHTMLTableCol, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).put_width(@ptrCast(*const IHTMLTableCol, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).get_width(@ptrCast(*const IHTMLTableCol, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableCol, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableCol, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_put_vAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableCol, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol_get_vAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableCol, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCol2_Value = @import("../zig.zig").Guid.initString("3050F82A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableCol2 = &IID_IHTMLTableCol2_Value;
pub const IHTMLTableCol2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_ch: fn(
            self: *const IHTMLTableCol2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ch: fn(
            self: *const IHTMLTableCol2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_chOff: fn(
            self: *const IHTMLTableCol2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_chOff: fn(
            self: *const IHTMLTableCol2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol2_put_ch(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol2.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableCol2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol2_get_ch(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol2.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableCol2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol2_put_chOff(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol2.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableCol2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol2_get_chOff(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol2.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableCol2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCol3_Value = @import("../zig.zig").Guid.initString("305106C4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableCol3 = &IID_IHTMLTableCol3_Value;
pub const IHTMLTableCol3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_ch: fn(
            self: *const IHTMLTableCol3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ch: fn(
            self: *const IHTMLTableCol3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_chOff: fn(
            self: *const IHTMLTableCol3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_chOff: fn(
            self: *const IHTMLTableCol3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol3_put_ch(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol3.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableCol3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol3_get_ch(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol3.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableCol3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol3_put_chOff(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol3.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableCol3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCol3_get_chOff(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCol3.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableCol3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableSection2_Value = @import("../zig.zig").Guid.initString("3050F5C7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableSection2 = &IID_IHTMLTableSection2_Value;
pub const IHTMLTableSection2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        moveRow: fn(
            self: *const IHTMLTableSection2,
            indexFrom: i32,
            indexTo: i32,
            row: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection2_moveRow(self: *const T, indexFrom: i32, indexTo: i32, row: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection2.VTable, self.vtable).moveRow(@ptrCast(*const IHTMLTableSection2, self), indexFrom, indexTo, row);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableSection3_Value = @import("../zig.zig").Guid.initString("3050F82B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableSection3 = &IID_IHTMLTableSection3_Value;
pub const IHTMLTableSection3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_ch: fn(
            self: *const IHTMLTableSection3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ch: fn(
            self: *const IHTMLTableSection3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_chOff: fn(
            self: *const IHTMLTableSection3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_chOff: fn(
            self: *const IHTMLTableSection3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection3_put_ch(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection3.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableSection3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection3_get_ch(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection3.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableSection3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection3_put_chOff(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection3.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableSection3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection3_get_chOff(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection3.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableSection3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableSection4_Value = @import("../zig.zig").Guid.initString("305106C5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableSection4 = &IID_IHTMLTableSection4_Value;
pub const IHTMLTableSection4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_ch: fn(
            self: *const IHTMLTableSection4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ch: fn(
            self: *const IHTMLTableSection4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_chOff: fn(
            self: *const IHTMLTableSection4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_chOff: fn(
            self: *const IHTMLTableSection4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertRow: fn(
            self: *const IHTMLTableSection4,
            index: i32,
            row: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteRow: fn(
            self: *const IHTMLTableSection4,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_put_ch(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableSection4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_get_ch(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableSection4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_put_chOff(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableSection4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_get_chOff(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableSection4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_insertRow(self: *const T, index: i32, row: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).insertRow(@ptrCast(*const IHTMLTableSection4, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableSection4_deleteRow(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableSection4.VTable, self.vtable).deleteRow(@ptrCast(*const IHTMLTableSection4, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRow_Value = @import("../zig.zig").Guid.initString("3050F23C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableRow = &IID_IHTMLTableRow_Value;
pub const IHTMLTableRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLTableRow,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLTableRow,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vAlign: fn(
            self: *const IHTMLTableRow,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vAlign: fn(
            self: *const IHTMLTableRow,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bgColor: fn(
            self: *const IHTMLTableRow,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bgColor: fn(
            self: *const IHTMLTableRow,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColor: fn(
            self: *const IHTMLTableRow,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColor: fn(
            self: *const IHTMLTableRow,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColorLight: fn(
            self: *const IHTMLTableRow,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColorLight: fn(
            self: *const IHTMLTableRow,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColorDark: fn(
            self: *const IHTMLTableRow,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColorDark: fn(
            self: *const IHTMLTableRow,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rowIndex: fn(
            self: *const IHTMLTableRow,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_sectionRowIndex: fn(
            self: *const IHTMLTableRow,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cells: fn(
            self: *const IHTMLTableRow,
            p: **IHTMLElementCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertCell: fn(
            self: *const IHTMLTableRow,
            index: i32,
            row: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteCell: fn(
            self: *const IHTMLTableRow,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_vAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_vAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_bgColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_borderColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_borderColorLight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_borderColorLight(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_borderColorLight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_borderColorLight(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_put_borderColorDark(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).put_borderColorDark(@ptrCast(*const IHTMLTableRow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_borderColorDark(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_borderColorDark(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_rowIndex(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_rowIndex(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_sectionRowIndex(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_sectionRowIndex(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_get_cells(self: *const T, p: **IHTMLElementCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).get_cells(@ptrCast(*const IHTMLTableRow, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_insertCell(self: *const T, index: i32, row: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).insertCell(@ptrCast(*const IHTMLTableRow, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow_deleteCell(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow.VTable, self.vtable).deleteCell(@ptrCast(*const IHTMLTableRow, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRow2_Value = @import("../zig.zig").Guid.initString("3050F4A1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableRow2 = &IID_IHTMLTableRow2_Value;
pub const IHTMLTableRow2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_height: fn(
            self: *const IHTMLTableRow2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLTableRow2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow2_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow2.VTable, self.vtable).put_height(@ptrCast(*const IHTMLTableRow2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow2_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow2.VTable, self.vtable).get_height(@ptrCast(*const IHTMLTableRow2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRow3_Value = @import("../zig.zig").Guid.initString("3050F82C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableRow3 = &IID_IHTMLTableRow3_Value;
pub const IHTMLTableRow3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_ch: fn(
            self: *const IHTMLTableRow3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ch: fn(
            self: *const IHTMLTableRow3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_chOff: fn(
            self: *const IHTMLTableRow3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_chOff: fn(
            self: *const IHTMLTableRow3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow3_put_ch(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow3.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableRow3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow3_get_ch(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow3.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableRow3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow3_put_chOff(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow3.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableRow3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow3_get_chOff(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow3.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableRow3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRow4_Value = @import("../zig.zig").Guid.initString("305106C6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableRow4 = &IID_IHTMLTableRow4_Value;
pub const IHTMLTableRow4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_ch: fn(
            self: *const IHTMLTableRow4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ch: fn(
            self: *const IHTMLTableRow4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_chOff: fn(
            self: *const IHTMLTableRow4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_chOff: fn(
            self: *const IHTMLTableRow4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertCell: fn(
            self: *const IHTMLTableRow4,
            index: i32,
            row: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deleteCell: fn(
            self: *const IHTMLTableRow4,
            index: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_put_ch(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableRow4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_get_ch(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableRow4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_put_chOff(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableRow4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_get_chOff(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableRow4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_insertCell(self: *const T, index: i32, row: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).insertCell(@ptrCast(*const IHTMLTableRow4, self), index, row);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRow4_deleteCell(self: *const T, index: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRow4.VTable, self.vtable).deleteCell(@ptrCast(*const IHTMLTableRow4, self), index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableRowMetrics_Value = @import("../zig.zig").Guid.initString("3050F413-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableRowMetrics = &IID_IHTMLTableRowMetrics_Value;
pub const IHTMLTableRowMetrics = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_clientHeight: fn(
            self: *const IHTMLTableRowMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientWidth: fn(
            self: *const IHTMLTableRowMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientTop: fn(
            self: *const IHTMLTableRowMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientLeft: fn(
            self: *const IHTMLTableRowMetrics,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRowMetrics_get_clientHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRowMetrics.VTable, self.vtable).get_clientHeight(@ptrCast(*const IHTMLTableRowMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRowMetrics_get_clientWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRowMetrics.VTable, self.vtable).get_clientWidth(@ptrCast(*const IHTMLTableRowMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRowMetrics_get_clientTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRowMetrics.VTable, self.vtable).get_clientTop(@ptrCast(*const IHTMLTableRowMetrics, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableRowMetrics_get_clientLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableRowMetrics.VTable, self.vtable).get_clientLeft(@ptrCast(*const IHTMLTableRowMetrics, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCell_Value = @import("../zig.zig").Guid.initString("3050F23D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableCell = &IID_IHTMLTableCell_Value;
pub const IHTMLTableCell = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_rowSpan: fn(
            self: *const IHTMLTableCell,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rowSpan: fn(
            self: *const IHTMLTableCell,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_colSpan: fn(
            self: *const IHTMLTableCell,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_colSpan: fn(
            self: *const IHTMLTableCell,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_align: fn(
            self: *const IHTMLTableCell,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLTableCell,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vAlign: fn(
            self: *const IHTMLTableCell,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vAlign: fn(
            self: *const IHTMLTableCell,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_bgColor: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bgColor: fn(
            self: *const IHTMLTableCell,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_noWrap: fn(
            self: *const IHTMLTableCell,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_noWrap: fn(
            self: *const IHTMLTableCell,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_background: fn(
            self: *const IHTMLTableCell,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_background: fn(
            self: *const IHTMLTableCell,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColor: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColor: fn(
            self: *const IHTMLTableCell,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColorLight: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColorLight: fn(
            self: *const IHTMLTableCell,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColorDark: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColorDark: fn(
            self: *const IHTMLTableCell,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLTableCell,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLTableCell,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLTableCell,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cellIndex: fn(
            self: *const IHTMLTableCell,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_rowSpan(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_rowSpan(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_rowSpan(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_rowSpan(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_colSpan(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_colSpan(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_colSpan(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_colSpan(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_align(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_align(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_vAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_vAlign(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_vAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_vAlign(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_bgColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_bgColor(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_bgColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_bgColor(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_noWrap(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_noWrap(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_noWrap(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_noWrap(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_background(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_background(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_background(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_background(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_borderColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_borderColorLight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_borderColorLight(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_borderColorLight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_borderColorLight(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_borderColorDark(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_borderColorDark(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_borderColorDark(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_borderColorDark(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_width(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_width(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).put_height(@ptrCast(*const IHTMLTableCell, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_height(@ptrCast(*const IHTMLTableCell, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell_get_cellIndex(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell.VTable, self.vtable).get_cellIndex(@ptrCast(*const IHTMLTableCell, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCell2_Value = @import("../zig.zig").Guid.initString("3050F82D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableCell2 = &IID_IHTMLTableCell2_Value;
pub const IHTMLTableCell2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_abbr: fn(
            self: *const IHTMLTableCell2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_abbr: fn(
            self: *const IHTMLTableCell2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_axis: fn(
            self: *const IHTMLTableCell2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_axis: fn(
            self: *const IHTMLTableCell2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ch: fn(
            self: *const IHTMLTableCell2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ch: fn(
            self: *const IHTMLTableCell2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_chOff: fn(
            self: *const IHTMLTableCell2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_chOff: fn(
            self: *const IHTMLTableCell2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_headers: fn(
            self: *const IHTMLTableCell2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_headers: fn(
            self: *const IHTMLTableCell2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scope: fn(
            self: *const IHTMLTableCell2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scope: fn(
            self: *const IHTMLTableCell2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_abbr(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_abbr(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_abbr(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_abbr(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_axis(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_axis(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_axis(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_axis(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_ch(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_ch(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_chOff(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_chOff(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_headers(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_headers(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_headers(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_headers(@ptrCast(*const IHTMLTableCell2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_put_scope(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).put_scope(@ptrCast(*const IHTMLTableCell2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell2_get_scope(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell2.VTable, self.vtable).get_scope(@ptrCast(*const IHTMLTableCell2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTableCell3_Value = @import("../zig.zig").Guid.initString("305106C7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTableCell3 = &IID_IHTMLTableCell3_Value;
pub const IHTMLTableCell3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_ch: fn(
            self: *const IHTMLTableCell3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ch: fn(
            self: *const IHTMLTableCell3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_chOff: fn(
            self: *const IHTMLTableCell3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_chOff: fn(
            self: *const IHTMLTableCell3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell3_put_ch(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell3.VTable, self.vtable).put_ch(@ptrCast(*const IHTMLTableCell3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell3_get_ch(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell3.VTable, self.vtable).get_ch(@ptrCast(*const IHTMLTableCell3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell3_put_chOff(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell3.VTable, self.vtable).put_chOff(@ptrCast(*const IHTMLTableCell3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTableCell3_get_chOff(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTableCell3.VTable, self.vtable).get_chOff(@ptrCast(*const IHTMLTableCell3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTable_Value = @import("../zig.zig").Guid.initString("3050F532-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTable = &IID_DispHTMLTable_Value;
pub const DispHTMLTable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableCol_Value = @import("../zig.zig").Guid.initString("3050F533-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTableCol = &IID_DispHTMLTableCol_Value;
pub const DispHTMLTableCol = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableSection_Value = @import("../zig.zig").Guid.initString("3050F534-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTableSection = &IID_DispHTMLTableSection_Value;
pub const DispHTMLTableSection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableRow_Value = @import("../zig.zig").Guid.initString("3050F535-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTableRow = &IID_DispHTMLTableRow_Value;
pub const DispHTMLTableRow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTableCell_Value = @import("../zig.zig").Guid.initString("3050F536-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTableCell = &IID_DispHTMLTableCell_Value;
pub const DispHTMLTableCell = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLScriptEvents2_Value = @import("../zig.zig").Guid.initString("3050F621-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLScriptEvents2 = &IID_HTMLScriptEvents2_Value;
pub const HTMLScriptEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLScriptEvents_Value = @import("../zig.zig").Guid.initString("3050F3E2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLScriptEvents = &IID_HTMLScriptEvents_Value;
pub const HTMLScriptEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScriptElement_Value = @import("../zig.zig").Guid.initString("3050F28B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLScriptElement = &IID_IHTMLScriptElement_Value;
pub const IHTMLScriptElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_src: fn(
            self: *const IHTMLScriptElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLScriptElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_htmlFor: fn(
            self: *const IHTMLScriptElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_htmlFor: fn(
            self: *const IHTMLScriptElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_event: fn(
            self: *const IHTMLScriptElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_event: fn(
            self: *const IHTMLScriptElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_text: fn(
            self: *const IHTMLScriptElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_text: fn(
            self: *const IHTMLScriptElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defer: fn(
            self: *const IHTMLScriptElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defer: fn(
            self: *const IHTMLScriptElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLScriptElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLScriptElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLScriptElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLScriptElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLScriptElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_htmlFor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_htmlFor(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_htmlFor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_htmlFor(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_event(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_event(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_event(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_event(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_text(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_text(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_text(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_text(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_defer(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_defer(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_defer(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_defer(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_readyState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLScriptElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLScriptElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScriptElement2_Value = @import("../zig.zig").Guid.initString("3050F828-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLScriptElement2 = &IID_IHTMLScriptElement2_Value;
pub const IHTMLScriptElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_charset: fn(
            self: *const IHTMLScriptElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_charset: fn(
            self: *const IHTMLScriptElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement2_put_charset(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement2.VTable, self.vtable).put_charset(@ptrCast(*const IHTMLScriptElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement2_get_charset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement2.VTable, self.vtable).get_charset(@ptrCast(*const IHTMLScriptElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScriptElement3_Value = @import("../zig.zig").Guid.initString("30510447-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLScriptElement3 = &IID_IHTMLScriptElement3_Value;
pub const IHTMLScriptElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_src: fn(
            self: *const IHTMLScriptElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLScriptElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement3_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement3.VTable, self.vtable).put_src(@ptrCast(*const IHTMLScriptElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement3_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement3.VTable, self.vtable).get_src(@ptrCast(*const IHTMLScriptElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLScriptElement4_Value = @import("../zig.zig").Guid.initString("30510801-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLScriptElement4 = &IID_IHTMLScriptElement4_Value;
pub const IHTMLScriptElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_usedCharset: fn(
            self: *const IHTMLScriptElement4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLScriptElement4_get_usedCharset(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLScriptElement4.VTable, self.vtable).get_usedCharset(@ptrCast(*const IHTMLScriptElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLScriptElement_Value = @import("../zig.zig").Guid.initString("3050F530-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLScriptElement = &IID_DispHTMLScriptElement_Value;
pub const DispHTMLScriptElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLNoShowElement_Value = @import("../zig.zig").Guid.initString("3050F38A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLNoShowElement = &IID_IHTMLNoShowElement_Value;
pub const IHTMLNoShowElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNoShowElement_Value = @import("../zig.zig").Guid.initString("3050F528-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLNoShowElement = &IID_DispHTMLNoShowElement_Value;
pub const DispHTMLNoShowElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLObjectElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F620-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLObjectElementEvents2 = &IID_HTMLObjectElementEvents2_Value;
pub const HTMLObjectElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLObjectElementEvents_Value = @import("../zig.zig").Guid.initString("3050F3C4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLObjectElementEvents = &IID_HTMLObjectElementEvents_Value;
pub const HTMLObjectElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement_Value = @import("../zig.zig").Guid.initString("3050F24F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLObjectElement = &IID_IHTMLObjectElement_Value;
pub const IHTMLObjectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_object: fn(
            self: *const IHTMLObjectElement,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_classid: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_data: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_recordset: fn(
            self: *const IHTMLObjectElement,
            v: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_recordset: fn(
            self: *const IHTMLObjectElement,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_align: fn(
            self: *const IHTMLObjectElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLObjectElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_codeBase: fn(
            self: *const IHTMLObjectElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_codeBase: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_codeType: fn(
            self: *const IHTMLObjectElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_codeType: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_code: fn(
            self: *const IHTMLObjectElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_code: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BaseHref: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLObjectElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLObjectElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLObjectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLObjectElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLObjectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLObjectElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLObjectElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLObjectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLObjectElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLObjectElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLObjectElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_altHtml: fn(
            self: *const IHTMLObjectElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_altHtml: fn(
            self: *const IHTMLObjectElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_vspace: fn(
            self: *const IHTMLObjectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vspace: fn(
            self: *const IHTMLObjectElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hspace: fn(
            self: *const IHTMLObjectElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hspace: fn(
            self: *const IHTMLObjectElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_object(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_object(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_classid(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_classid(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_data(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_putref_recordset(self: *const T, v: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).putref_recordset(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_recordset(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_recordset(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_codeBase(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_codeBase(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_codeBase(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_codeBase(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_codeType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_codeType(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_codeType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_codeType(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_code(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_code(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_code(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_code(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_BaseHref(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_BaseHref(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_readyState(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_altHtml(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_altHtml(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_altHtml(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_altHtml(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_vspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLObjectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLObjectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement_get_hspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLObjectElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement2_Value = @import("../zig.zig").Guid.initString("3050F4CD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLObjectElement2 = &IID_IHTMLObjectElement2_Value;
pub const IHTMLObjectElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        namedRecordset: fn(
            self: *const IHTMLObjectElement2,
            dataMember: BSTR,
            hierarchy: *VARIANT,
            ppRecordset: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_classid: fn(
            self: *const IHTMLObjectElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_classid: fn(
            self: *const IHTMLObjectElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_data: fn(
            self: *const IHTMLObjectElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_data: fn(
            self: *const IHTMLObjectElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_namedRecordset(self: *const T, dataMember: BSTR, hierarchy: *VARIANT, ppRecordset: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).namedRecordset(@ptrCast(*const IHTMLObjectElement2, self), dataMember, hierarchy, ppRecordset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_put_classid(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).put_classid(@ptrCast(*const IHTMLObjectElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_get_classid(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).get_classid(@ptrCast(*const IHTMLObjectElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_put_data(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).put_data(@ptrCast(*const IHTMLObjectElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement2_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement2.VTable, self.vtable).get_data(@ptrCast(*const IHTMLObjectElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement3_Value = @import("../zig.zig").Guid.initString("3050F827-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLObjectElement3 = &IID_IHTMLObjectElement3_Value;
pub const IHTMLObjectElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_archive: fn(
            self: *const IHTMLObjectElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_archive: fn(
            self: *const IHTMLObjectElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_alt: fn(
            self: *const IHTMLObjectElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_alt: fn(
            self: *const IHTMLObjectElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_declare: fn(
            self: *const IHTMLObjectElement3,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_declare: fn(
            self: *const IHTMLObjectElement3,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_standby: fn(
            self: *const IHTMLObjectElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_standby: fn(
            self: *const IHTMLObjectElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLObjectElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLObjectElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_useMap: fn(
            self: *const IHTMLObjectElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_useMap: fn(
            self: *const IHTMLObjectElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_archive(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_archive(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_archive(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_archive(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_alt(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_alt(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_alt(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_alt(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_declare(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_declare(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_declare(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_declare(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_standby(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_standby(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_standby(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_standby(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_border(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_border(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_border(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_put_useMap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).put_useMap(@ptrCast(*const IHTMLObjectElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement3_get_useMap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement3.VTable, self.vtable).get_useMap(@ptrCast(*const IHTMLObjectElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement4_Value = @import("../zig.zig").Guid.initString("3051043E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLObjectElement4 = &IID_IHTMLObjectElement4_Value;
pub const IHTMLObjectElement4 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_contentDocument: fn(
            self: *const IHTMLObjectElement4,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_codeBase: fn(
            self: *const IHTMLObjectElement4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_codeBase: fn(
            self: *const IHTMLObjectElement4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_data: fn(
            self: *const IHTMLObjectElement4,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_data: fn(
            self: *const IHTMLObjectElement4,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_get_contentDocument(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).get_contentDocument(@ptrCast(*const IHTMLObjectElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_put_codeBase(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).put_codeBase(@ptrCast(*const IHTMLObjectElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_get_codeBase(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).get_codeBase(@ptrCast(*const IHTMLObjectElement4, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_put_data(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).put_data(@ptrCast(*const IHTMLObjectElement4, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement4_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement4.VTable, self.vtable).get_data(@ptrCast(*const IHTMLObjectElement4, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLObjectElement5_Value = @import("../zig.zig").Guid.initString("305104B5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLObjectElement5 = &IID_IHTMLObjectElement5_Value;
pub const IHTMLObjectElement5 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_object: fn(
            self: *const IHTMLObjectElement5,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_object: fn(
            self: *const IHTMLObjectElement5,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement5_put_object(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement5.VTable, self.vtable).put_object(@ptrCast(*const IHTMLObjectElement5, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLObjectElement5_get_object(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLObjectElement5.VTable, self.vtable).get_object(@ptrCast(*const IHTMLObjectElement5, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLParamElement_Value = @import("../zig.zig").Guid.initString("3050F83D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLParamElement = &IID_IHTMLParamElement_Value;
pub const IHTMLParamElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_name: fn(
            self: *const IHTMLParamElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLParamElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLParamElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLParamElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLParamElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLParamElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_valueType: fn(
            self: *const IHTMLParamElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_valueType: fn(
            self: *const IHTMLParamElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLParamElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLParamElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLParamElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLParamElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLParamElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLParamElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_put_valueType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).put_valueType(@ptrCast(*const IHTMLParamElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement_get_valueType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement.VTable, self.vtable).get_valueType(@ptrCast(*const IHTMLParamElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLParamElement2_Value = @import("../zig.zig").Guid.initString("30510444-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLParamElement2 = &IID_IHTMLParamElement2_Value;
pub const IHTMLParamElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_name: fn(
            self: *const IHTMLParamElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLParamElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLParamElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLParamElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const IHTMLParamElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLParamElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_valueType: fn(
            self: *const IHTMLParamElement2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_valueType: fn(
            self: *const IHTMLParamElement2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).put_name(@ptrCast(*const IHTMLParamElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).get_name(@ptrCast(*const IHTMLParamElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).put_type(@ptrCast(*const IHTMLParamElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).get_type(@ptrCast(*const IHTMLParamElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_put_value(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).put_value(@ptrCast(*const IHTMLParamElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_get_value(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).get_value(@ptrCast(*const IHTMLParamElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_put_valueType(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).put_valueType(@ptrCast(*const IHTMLParamElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLParamElement2_get_valueType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLParamElement2.VTable, self.vtable).get_valueType(@ptrCast(*const IHTMLParamElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLObjectElement_Value = @import("../zig.zig").Guid.initString("3050F529-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLObjectElement = &IID_DispHTMLObjectElement_Value;
pub const DispHTMLObjectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLParamElement_Value = @import("../zig.zig").Guid.initString("3050F590-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLParamElement = &IID_DispHTMLParamElement_Value;
pub const DispHTMLParamElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLFrameSiteEvents2_Value = @import("../zig.zig").Guid.initString("3050F7FF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLFrameSiteEvents2 = &IID_HTMLFrameSiteEvents2_Value;
pub const HTMLFrameSiteEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLFrameSiteEvents_Value = @import("../zig.zig").Guid.initString("3050F800-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLFrameSiteEvents = &IID_HTMLFrameSiteEvents_Value;
pub const HTMLFrameSiteEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameBase2_Value = @import("../zig.zig").Guid.initString("3050F6DB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFrameBase2 = &IID_IHTMLFrameBase2_Value;
pub const IHTMLFrameBase2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_contentWindow: fn(
            self: *const IHTMLFrameBase2,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLFrameBase2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLFrameBase2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLFrameBase2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLFrameBase2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLFrameBase2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_allowTransparency: fn(
            self: *const IHTMLFrameBase2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_allowTransparency: fn(
            self: *const IHTMLFrameBase2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_contentWindow(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_contentWindow(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLFrameBase2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLFrameBase2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_readyState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_put_allowTransparency(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).put_allowTransparency(@ptrCast(*const IHTMLFrameBase2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase2_get_allowTransparency(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase2.VTable, self.vtable).get_allowTransparency(@ptrCast(*const IHTMLFrameBase2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameBase3_Value = @import("../zig.zig").Guid.initString("3050F82E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFrameBase3 = &IID_IHTMLFrameBase3_Value;
pub const IHTMLFrameBase3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_longDesc: fn(
            self: *const IHTMLFrameBase3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_longDesc: fn(
            self: *const IHTMLFrameBase3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase3_put_longDesc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase3.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLFrameBase3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameBase3_get_longDesc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameBase3.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLFrameBase3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFrameBase_Value = @import("../zig.zig").Guid.initString("3050F541-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLFrameBase = &IID_DispHTMLFrameBase_Value;
pub const DispHTMLFrameBase = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameElement_Value = @import("../zig.zig").Guid.initString("3050F313-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFrameElement = &IID_IHTMLFrameElement_Value;
pub const IHTMLFrameElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_borderColor: fn(
            self: *const IHTMLFrameElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColor: fn(
            self: *const IHTMLFrameElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLFrameElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement_get_borderColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLFrameElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameElement2_Value = @import("../zig.zig").Guid.initString("3050F7F5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFrameElement2 = &IID_IHTMLFrameElement2_Value;
pub const IHTMLFrameElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_height: fn(
            self: *const IHTMLFrameElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLFrameElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLFrameElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLFrameElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement2_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement2.VTable, self.vtable).put_height(@ptrCast(*const IHTMLFrameElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement2_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement2.VTable, self.vtable).get_height(@ptrCast(*const IHTMLFrameElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement2_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement2.VTable, self.vtable).put_width(@ptrCast(*const IHTMLFrameElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement2_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement2.VTable, self.vtable).get_width(@ptrCast(*const IHTMLFrameElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameElement3_Value = @import("../zig.zig").Guid.initString("3051042D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFrameElement3 = &IID_IHTMLFrameElement3_Value;
pub const IHTMLFrameElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_contentDocument: fn(
            self: *const IHTMLFrameElement3,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_src: fn(
            self: *const IHTMLFrameElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLFrameElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_longDesc: fn(
            self: *const IHTMLFrameElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_longDesc: fn(
            self: *const IHTMLFrameElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frameBorder: fn(
            self: *const IHTMLFrameElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameBorder: fn(
            self: *const IHTMLFrameElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_get_contentDocument(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).get_contentDocument(@ptrCast(*const IHTMLFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).put_src(@ptrCast(*const IHTMLFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).get_src(@ptrCast(*const IHTMLFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_put_longDesc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_get_longDesc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_put_frameBorder(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).put_frameBorder(@ptrCast(*const IHTMLFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameElement3_get_frameBorder(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameElement3.VTable, self.vtable).get_frameBorder(@ptrCast(*const IHTMLFrameElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFrameElement_Value = @import("../zig.zig").Guid.initString("3050F513-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLFrameElement = &IID_DispHTMLFrameElement_Value;
pub const DispHTMLFrameElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIFrameElement_Value = @import("../zig.zig").Guid.initString("3050F315-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLIFrameElement = &IID_IHTMLIFrameElement_Value;
pub const IHTMLIFrameElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_vspace: fn(
            self: *const IHTMLIFrameElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_vspace: fn(
            self: *const IHTMLIFrameElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_hspace: fn(
            self: *const IHTMLIFrameElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hspace: fn(
            self: *const IHTMLIFrameElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_align: fn(
            self: *const IHTMLIFrameElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLIFrameElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_put_vspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).put_vspace(@ptrCast(*const IHTMLIFrameElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_get_vspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).get_vspace(@ptrCast(*const IHTMLIFrameElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_put_hspace(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).put_hspace(@ptrCast(*const IHTMLIFrameElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_get_hspace(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).get_hspace(@ptrCast(*const IHTMLIFrameElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLIFrameElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLIFrameElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIFrameElement2_Value = @import("../zig.zig").Guid.initString("3050F4E6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLIFrameElement2 = &IID_IHTMLIFrameElement2_Value;
pub const IHTMLIFrameElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_height: fn(
            self: *const IHTMLIFrameElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLIFrameElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const IHTMLIFrameElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLIFrameElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement2_put_height(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement2.VTable, self.vtable).put_height(@ptrCast(*const IHTMLIFrameElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement2_get_height(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement2.VTable, self.vtable).get_height(@ptrCast(*const IHTMLIFrameElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement2_put_width(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement2.VTable, self.vtable).put_width(@ptrCast(*const IHTMLIFrameElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement2_get_width(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement2.VTable, self.vtable).get_width(@ptrCast(*const IHTMLIFrameElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIFrameElement3_Value = @import("../zig.zig").Guid.initString("30510433-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLIFrameElement3 = &IID_IHTMLIFrameElement3_Value;
pub const IHTMLIFrameElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_contentDocument: fn(
            self: *const IHTMLIFrameElement3,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_src: fn(
            self: *const IHTMLIFrameElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLIFrameElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_longDesc: fn(
            self: *const IHTMLIFrameElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_longDesc: fn(
            self: *const IHTMLIFrameElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frameBorder: fn(
            self: *const IHTMLIFrameElement3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameBorder: fn(
            self: *const IHTMLIFrameElement3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_get_contentDocument(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).get_contentDocument(@ptrCast(*const IHTMLIFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).put_src(@ptrCast(*const IHTMLIFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).get_src(@ptrCast(*const IHTMLIFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_put_longDesc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).put_longDesc(@ptrCast(*const IHTMLIFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_get_longDesc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).get_longDesc(@ptrCast(*const IHTMLIFrameElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_put_frameBorder(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).put_frameBorder(@ptrCast(*const IHTMLIFrameElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIFrameElement3_get_frameBorder(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIFrameElement3.VTable, self.vtable).get_frameBorder(@ptrCast(*const IHTMLIFrameElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLIFrame_Value = @import("../zig.zig").Guid.initString("3050F51B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLIFrame = &IID_DispHTMLIFrame_Value;
pub const DispHTMLIFrame = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDivPosition_Value = @import("../zig.zig").Guid.initString("3050F212-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDivPosition = &IID_IHTMLDivPosition_Value;
pub const IHTMLDivPosition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLDivPosition,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLDivPosition,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivPosition_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivPosition.VTable, self.vtable).put_align(@ptrCast(*const IHTMLDivPosition, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDivPosition_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDivPosition.VTable, self.vtable).get_align(@ptrCast(*const IHTMLDivPosition, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFieldSetElement_Value = @import("../zig.zig").Guid.initString("3050F3E7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFieldSetElement = &IID_IHTMLFieldSetElement_Value;
pub const IHTMLFieldSetElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLFieldSetElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLFieldSetElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFieldSetElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFieldSetElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLFieldSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFieldSetElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFieldSetElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLFieldSetElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFieldSetElement2_Value = @import("../zig.zig").Guid.initString("3050F833-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFieldSetElement2 = &IID_IHTMLFieldSetElement2_Value;
pub const IHTMLFieldSetElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_form: fn(
            self: *const IHTMLFieldSetElement2,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFieldSetElement2_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFieldSetElement2.VTable, self.vtable).get_form(@ptrCast(*const IHTMLFieldSetElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLegendElement_Value = @import("../zig.zig").Guid.initString("3050F3EA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLegendElement = &IID_IHTMLLegendElement_Value;
pub const IHTMLLegendElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLLegendElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLLegendElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLegendElement_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLegendElement.VTable, self.vtable).put_align(@ptrCast(*const IHTMLLegendElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLegendElement_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLegendElement.VTable, self.vtable).get_align(@ptrCast(*const IHTMLLegendElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLLegendElement2_Value = @import("../zig.zig").Guid.initString("3050F834-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLLegendElement2 = &IID_IHTMLLegendElement2_Value;
pub const IHTMLLegendElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_form: fn(
            self: *const IHTMLLegendElement2,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLLegendElement2_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLLegendElement2.VTable, self.vtable).get_form(@ptrCast(*const IHTMLLegendElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLDivPosition_Value = @import("../zig.zig").Guid.initString("3050F50F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLDivPosition = &IID_DispHTMLDivPosition_Value;
pub const DispHTMLDivPosition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFieldSetElement_Value = @import("../zig.zig").Guid.initString("3050F545-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLFieldSetElement = &IID_DispHTMLFieldSetElement_Value;
pub const DispHTMLFieldSetElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLLegendElement_Value = @import("../zig.zig").Guid.initString("3050F546-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLLegendElement = &IID_DispHTMLLegendElement_Value;
pub const DispHTMLLegendElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSpanFlow_Value = @import("../zig.zig").Guid.initString("3050F3E5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSpanFlow = &IID_IHTMLSpanFlow_Value;
pub const IHTMLSpanFlow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const IHTMLSpanFlow,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const IHTMLSpanFlow,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSpanFlow_put_align(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSpanFlow.VTable, self.vtable).put_align(@ptrCast(*const IHTMLSpanFlow, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSpanFlow_get_align(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSpanFlow.VTable, self.vtable).get_align(@ptrCast(*const IHTMLSpanFlow, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSpanFlow_Value = @import("../zig.zig").Guid.initString("3050F544-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLSpanFlow = &IID_DispHTMLSpanFlow_Value;
pub const DispHTMLSpanFlow = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameSetElement_Value = @import("../zig.zig").Guid.initString("3050F319-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFrameSetElement = &IID_IHTMLFrameSetElement_Value;
pub const IHTMLFrameSetElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_rows: fn(
            self: *const IHTMLFrameSetElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rows: fn(
            self: *const IHTMLFrameSetElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_cols: fn(
            self: *const IHTMLFrameSetElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cols: fn(
            self: *const IHTMLFrameSetElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLFrameSetElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderColor: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderColor: fn(
            self: *const IHTMLFrameSetElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frameBorder: fn(
            self: *const IHTMLFrameSetElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameBorder: fn(
            self: *const IHTMLFrameSetElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frameSpacing: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameSpacing: fn(
            self: *const IHTMLFrameSetElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_name: fn(
            self: *const IHTMLFrameSetElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_name: fn(
            self: *const IHTMLFrameSetElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLFrameSetElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onunload: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onunload: fn(
            self: *const IHTMLFrameSetElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onbeforeunload: fn(
            self: *const IHTMLFrameSetElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeunload: fn(
            self: *const IHTMLFrameSetElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_rows(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_rows(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_rows(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_rows(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_cols(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_cols(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_cols(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_cols(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_border(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_border(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_border(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_border(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_borderColor(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_borderColor(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_borderColor(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_borderColor(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_frameBorder(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_frameBorder(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_frameBorder(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_frameBorder(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_frameSpacing(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_frameSpacing(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_frameSpacing(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_frameSpacing(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_name(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_name(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_name(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_onunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_onunload(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_onunload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_onunload(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_put_onbeforeunload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).put_onbeforeunload(@ptrCast(*const IHTMLFrameSetElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement_get_onbeforeunload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement.VTable, self.vtable).get_onbeforeunload(@ptrCast(*const IHTMLFrameSetElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameSetElement2_Value = @import("../zig.zig").Guid.initString("3050F5C6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFrameSetElement2 = &IID_IHTMLFrameSetElement2_Value;
pub const IHTMLFrameSetElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onbeforeprint: fn(
            self: *const IHTMLFrameSetElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onbeforeprint: fn(
            self: *const IHTMLFrameSetElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onafterprint: fn(
            self: *const IHTMLFrameSetElement2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onafterprint: fn(
            self: *const IHTMLFrameSetElement2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement2_put_onbeforeprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement2.VTable, self.vtable).put_onbeforeprint(@ptrCast(*const IHTMLFrameSetElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement2_get_onbeforeprint(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement2.VTable, self.vtable).get_onbeforeprint(@ptrCast(*const IHTMLFrameSetElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement2_put_onafterprint(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement2.VTable, self.vtable).put_onafterprint(@ptrCast(*const IHTMLFrameSetElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement2_get_onafterprint(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement2.VTable, self.vtable).get_onafterprint(@ptrCast(*const IHTMLFrameSetElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFrameSetElement3_Value = @import("../zig.zig").Guid.initString("30510796-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFrameSetElement3 = &IID_IHTMLFrameSetElement3_Value;
pub const IHTMLFrameSetElement3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_onhashchange: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onhashchange: fn(
            self: *const IHTMLFrameSetElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onmessage: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onmessage: fn(
            self: *const IHTMLFrameSetElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onoffline: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onoffline: fn(
            self: *const IHTMLFrameSetElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ononline: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ononline: fn(
            self: *const IHTMLFrameSetElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onstorage: fn(
            self: *const IHTMLFrameSetElement3,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onstorage: fn(
            self: *const IHTMLFrameSetElement3,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_onhashchange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_onhashchange(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_onhashchange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_onhashchange(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_onmessage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_onmessage(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_onmessage(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_onmessage(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_onoffline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_onoffline(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_onoffline(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_onoffline(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_ononline(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_ononline(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_ononline(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_ononline(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_put_onstorage(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).put_onstorage(@ptrCast(*const IHTMLFrameSetElement3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFrameSetElement3_get_onstorage(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFrameSetElement3.VTable, self.vtable).get_onstorage(@ptrCast(*const IHTMLFrameSetElement3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLFrameSetSite_Value = @import("../zig.zig").Guid.initString("3050F514-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLFrameSetSite = &IID_DispHTMLFrameSetSite_Value;
pub const DispHTMLFrameSetSite = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLBGsound_Value = @import("../zig.zig").Guid.initString("3050F369-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLBGsound = &IID_IHTMLBGsound_Value;
pub const IHTMLBGsound = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_src: fn(
            self: *const IHTMLBGsound,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLBGsound,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_loop: fn(
            self: *const IHTMLBGsound,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_loop: fn(
            self: *const IHTMLBGsound,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_volume: fn(
            self: *const IHTMLBGsound,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_volume: fn(
            self: *const IHTMLBGsound,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_balance: fn(
            self: *const IHTMLBGsound,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_balance: fn(
            self: *const IHTMLBGsound,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).put_src(@ptrCast(*const IHTMLBGsound, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).get_src(@ptrCast(*const IHTMLBGsound, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_put_loop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLBGsound, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_get_loop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLBGsound, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_put_volume(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).put_volume(@ptrCast(*const IHTMLBGsound, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_get_volume(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).get_volume(@ptrCast(*const IHTMLBGsound, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_put_balance(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).put_balance(@ptrCast(*const IHTMLBGsound, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLBGsound_get_balance(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLBGsound.VTable, self.vtable).get_balance(@ptrCast(*const IHTMLBGsound, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLBGsound_Value = @import("../zig.zig").Guid.initString("3050F53C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLBGsound = &IID_DispHTMLBGsound_Value;
pub const DispHTMLBGsound = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFontNamesCollection_Value = @import("../zig.zig").Guid.initString("3050F376-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFontNamesCollection = &IID_IHTMLFontNamesCollection_Value;
pub const IHTMLFontNamesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLFontNamesCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLFontNamesCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLFontNamesCollection,
            index: i32,
            pBstr: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontNamesCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontNamesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFontNamesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontNamesCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontNamesCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLFontNamesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontNamesCollection_item(self: *const T, index: i32, pBstr: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontNamesCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLFontNamesCollection, self), index, pBstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLFontSizesCollection_Value = @import("../zig.zig").Guid.initString("3050F377-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLFontSizesCollection = &IID_IHTMLFontSizesCollection_Value;
pub const IHTMLFontSizesCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLFontSizesCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLFontSizesCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_forFont: fn(
            self: *const IHTMLFontSizesCollection,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLFontSizesCollection,
            index: i32,
            plSize: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontSizesCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontSizesCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLFontSizesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontSizesCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontSizesCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLFontSizesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontSizesCollection_get_forFont(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontSizesCollection.VTable, self.vtable).get_forFont(@ptrCast(*const IHTMLFontSizesCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLFontSizesCollection_item(self: *const T, index: i32, plSize: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLFontSizesCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLFontSizesCollection, self), index, plSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLOptionsHolder_Value = @import("../zig.zig").Guid.initString("3050F378-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLOptionsHolder = &IID_IHTMLOptionsHolder_Value;
pub const IHTMLOptionsHolder = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_document: fn(
            self: *const IHTMLOptionsHolder,
            p: **IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fonts: fn(
            self: *const IHTMLOptionsHolder,
            p: **IHTMLFontNamesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_execArg: fn(
            self: *const IHTMLOptionsHolder,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_execArg: fn(
            self: *const IHTMLOptionsHolder,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_errorLine: fn(
            self: *const IHTMLOptionsHolder,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_errorLine: fn(
            self: *const IHTMLOptionsHolder,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_errorCharacter: fn(
            self: *const IHTMLOptionsHolder,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_errorCharacter: fn(
            self: *const IHTMLOptionsHolder,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_errorCode: fn(
            self: *const IHTMLOptionsHolder,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_errorCode: fn(
            self: *const IHTMLOptionsHolder,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_errorMessage: fn(
            self: *const IHTMLOptionsHolder,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_errorMessage: fn(
            self: *const IHTMLOptionsHolder,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_errorDebug: fn(
            self: *const IHTMLOptionsHolder,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_errorDebug: fn(
            self: *const IHTMLOptionsHolder,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unsecuredWindowOfDocument: fn(
            self: *const IHTMLOptionsHolder,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_findText: fn(
            self: *const IHTMLOptionsHolder,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_findText: fn(
            self: *const IHTMLOptionsHolder,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_anythingAfterFrameset: fn(
            self: *const IHTMLOptionsHolder,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_anythingAfterFrameset: fn(
            self: *const IHTMLOptionsHolder,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        sizes: fn(
            self: *const IHTMLOptionsHolder,
            fontName: BSTR,
            pSizesCollection: **IHTMLFontSizesCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        openfiledlg: fn(
            self: *const IHTMLOptionsHolder,
            initFile: VARIANT,
            initDir: VARIANT,
            filter: VARIANT,
            title: VARIANT,
            pathName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        savefiledlg: fn(
            self: *const IHTMLOptionsHolder,
            initFile: VARIANT,
            initDir: VARIANT,
            filter: VARIANT,
            title: VARIANT,
            pathName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        choosecolordlg: fn(
            self: *const IHTMLOptionsHolder,
            initColor: VARIANT,
            rgbColor: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showSecurityInfo: fn(
            self: *const IHTMLOptionsHolder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isApartmentModel: fn(
            self: *const IHTMLOptionsHolder,
            object: *IHTMLObjectElement,
            fApartment: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCharset: fn(
            self: *const IHTMLOptionsHolder,
            fontName: BSTR,
            charset: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_secureConnectionInfo: fn(
            self: *const IHTMLOptionsHolder,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_document(self: *const T, p: **IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_document(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_fonts(self: *const T, p: **IHTMLFontNamesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_fonts(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_execArg(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_execArg(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_execArg(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_execArg(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorLine(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorLine(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorLine(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorLine(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorCharacter(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorCharacter(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorCharacter(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorCharacter(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorCode(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorCode(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorCode(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorCode(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorMessage(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorMessage(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorMessage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorMessage(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_errorDebug(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_errorDebug(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_errorDebug(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_errorDebug(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_unsecuredWindowOfDocument(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_unsecuredWindowOfDocument(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_findText(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_findText(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_findText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_findText(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_put_anythingAfterFrameset(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).put_anythingAfterFrameset(@ptrCast(*const IHTMLOptionsHolder, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_anythingAfterFrameset(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_anythingAfterFrameset(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_sizes(self: *const T, fontName: BSTR, pSizesCollection: **IHTMLFontSizesCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).sizes(@ptrCast(*const IHTMLOptionsHolder, self), fontName, pSizesCollection);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_openfiledlg(self: *const T, initFile: VARIANT, initDir: VARIANT, filter: VARIANT, title: VARIANT, pathName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).openfiledlg(@ptrCast(*const IHTMLOptionsHolder, self), initFile, initDir, filter, title, pathName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_savefiledlg(self: *const T, initFile: VARIANT, initDir: VARIANT, filter: VARIANT, title: VARIANT, pathName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).savefiledlg(@ptrCast(*const IHTMLOptionsHolder, self), initFile, initDir, filter, title, pathName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_choosecolordlg(self: *const T, initColor: VARIANT, rgbColor: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).choosecolordlg(@ptrCast(*const IHTMLOptionsHolder, self), initColor, rgbColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_showSecurityInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).showSecurityInfo(@ptrCast(*const IHTMLOptionsHolder, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_isApartmentModel(self: *const T, object: *IHTMLObjectElement, fApartment: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).isApartmentModel(@ptrCast(*const IHTMLOptionsHolder, self), object, fApartment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_getCharset(self: *const T, fontName: BSTR, charset: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).getCharset(@ptrCast(*const IHTMLOptionsHolder, self), fontName, charset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLOptionsHolder_get_secureConnectionInfo(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLOptionsHolder.VTable, self.vtable).get_secureConnectionInfo(@ptrCast(*const IHTMLOptionsHolder, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLStyleElementEvents2_Value = @import("../zig.zig").Guid.initString("3050F615-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLStyleElementEvents2 = &IID_HTMLStyleElementEvents2_Value;
pub const HTMLStyleElementEvents2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLStyleElementEvents_Value = @import("../zig.zig").Guid.initString("3050F3CB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLStyleElementEvents = &IID_HTMLStyleElementEvents_Value;
pub const HTMLStyleElementEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleElement_Value = @import("../zig.zig").Guid.initString("3050F375-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleElement = &IID_IHTMLStyleElement_Value;
pub const IHTMLStyleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_type: fn(
            self: *const IHTMLStyleElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLStyleElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLStyleElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLStyleElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLStyleElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLStyleElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLStyleElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLStyleElement,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLStyleElement,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_styleSheet: fn(
            self: *const IHTMLStyleElement,
            p: **IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_disabled: fn(
            self: *const IHTMLStyleElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_disabled: fn(
            self: *const IHTMLStyleElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_media: fn(
            self: *const IHTMLStyleElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_media: fn(
            self: *const IHTMLStyleElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_readyState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_styleSheet(self: *const T, p: **IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_styleSheet(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_disabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_disabled(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_disabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_disabled(@ptrCast(*const IHTMLStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_put_media(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).put_media(@ptrCast(*const IHTMLStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement_get_media(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement.VTable, self.vtable).get_media(@ptrCast(*const IHTMLStyleElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleElement2_Value = @import("../zig.zig").Guid.initString("3051072A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleElement2 = &IID_IHTMLStyleElement2_Value;
pub const IHTMLStyleElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_sheet: fn(
            self: *const IHTMLStyleElement2,
            p: **IHTMLStyleSheet,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleElement2_get_sheet(self: *const T, p: **IHTMLStyleSheet) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleElement2.VTable, self.vtable).get_sheet(@ptrCast(*const IHTMLStyleElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleElement_Value = @import("../zig.zig").Guid.initString("3050F511-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleElement = &IID_DispHTMLStyleElement_Value;
pub const DispHTMLStyleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleFontFace_Value = @import("../zig.zig").Guid.initString("3050F3D5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleFontFace = &IID_IHTMLStyleFontFace_Value;
pub const IHTMLStyleFontFace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_fontsrc: fn(
            self: *const IHTMLStyleFontFace,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontsrc: fn(
            self: *const IHTMLStyleFontFace,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleFontFace_put_fontsrc(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleFontFace.VTable, self.vtable).put_fontsrc(@ptrCast(*const IHTMLStyleFontFace, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleFontFace_get_fontsrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleFontFace.VTable, self.vtable).get_fontsrc(@ptrCast(*const IHTMLStyleFontFace, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleFontFace2_Value = @import("../zig.zig").Guid.initString("305106EC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleFontFace2 = &IID_IHTMLStyleFontFace2_Value;
pub const IHTMLStyleFontFace2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_style: fn(
            self: *const IHTMLStyleFontFace2,
            p: **IHTMLRuleStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleFontFace2_get_style(self: *const T, p: **IHTMLRuleStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleFontFace2.VTable, self.vtable).get_style(@ptrCast(*const IHTMLStyleFontFace2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleFontFace_Value = @import("../zig.zig").Guid.initString("30590081-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleFontFace = &IID_DispHTMLStyleFontFace_Value;
pub const DispHTMLStyleFontFace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXDomainRequest_Value = @import("../zig.zig").Guid.initString("30510454-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLXDomainRequest = &IID_IHTMLXDomainRequest_Value;
pub const IHTMLXDomainRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_responseText: fn(
            self: *const IHTMLXDomainRequest,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_timeout: fn(
            self: *const IHTMLXDomainRequest,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_timeout: fn(
            self: *const IHTMLXDomainRequest,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_contentType: fn(
            self: *const IHTMLXDomainRequest,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onprogress: fn(
            self: *const IHTMLXDomainRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onprogress: fn(
            self: *const IHTMLXDomainRequest,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onerror: fn(
            self: *const IHTMLXDomainRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onerror: fn(
            self: *const IHTMLXDomainRequest,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ontimeout: fn(
            self: *const IHTMLXDomainRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ontimeout: fn(
            self: *const IHTMLXDomainRequest,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onload: fn(
            self: *const IHTMLXDomainRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onload: fn(
            self: *const IHTMLXDomainRequest,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IHTMLXDomainRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        open: fn(
            self: *const IHTMLXDomainRequest,
            bstrMethod: BSTR,
            bstrUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        send: fn(
            self: *const IHTMLXDomainRequest,
            varBody: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_responseText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_responseText(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_timeout(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_timeout(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_timeout(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_timeout(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_contentType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_contentType(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_onprogress(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_onprogress(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_onprogress(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_onprogress(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_onerror(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_onerror(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_onerror(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_onerror(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_ontimeout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_ontimeout(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_ontimeout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_ontimeout(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_put_onload(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).put_onload(@ptrCast(*const IHTMLXDomainRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_get_onload(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).get_onload(@ptrCast(*const IHTMLXDomainRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).abort(@ptrCast(*const IHTMLXDomainRequest, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_open(self: *const T, bstrMethod: BSTR, bstrUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).open(@ptrCast(*const IHTMLXDomainRequest, self), bstrMethod, bstrUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequest_send(self: *const T, varBody: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequest.VTable, self.vtable).send(@ptrCast(*const IHTMLXDomainRequest, self), varBody);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXDomainRequestFactory_Value = @import("../zig.zig").Guid.initString("30510456-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLXDomainRequestFactory = &IID_IHTMLXDomainRequestFactory_Value;
pub const IHTMLXDomainRequestFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLXDomainRequestFactory,
            __MIDL__IHTMLXDomainRequestFactory0000: **IHTMLXDomainRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXDomainRequestFactory_create(self: *const T, __MIDL__IHTMLXDomainRequestFactory0000: **IHTMLXDomainRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXDomainRequestFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLXDomainRequestFactory, self), __MIDL__IHTMLXDomainRequestFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispXDomainRequest_Value = @import("../zig.zig").Guid.initString("3050F599-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispXDomainRequest = &IID_DispXDomainRequest_Value;
pub const DispXDomainRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStorage2_Value = @import("../zig.zig").Guid.initString("30510799-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStorage2 = &IID_IHTMLStorage2_Value;
pub const IHTMLStorage2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        setItem: fn(
            self: *const IHTMLStorage2,
            bstrKey: BSTR,
            bstrValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStorage2_setItem(self: *const T, bstrKey: BSTR, bstrValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStorage2.VTable, self.vtable).setItem(@ptrCast(*const IHTMLStorage2, self), bstrKey, bstrValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStorage_Value = @import("../zig.zig").Guid.initString("3050F59D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStorage = &IID_DispHTMLStorage_Value;
pub const DispHTMLStorage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEventTarget_Value = @import("../zig.zig").Guid.initString("305104B9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IEventTarget = &IID_IEventTarget_Value;
pub const IEventTarget = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addEventListener: fn(
            self: *const IEventTarget,
            type: BSTR,
            listener: *IDispatch,
            useCapture: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeEventListener: fn(
            self: *const IEventTarget,
            type: BSTR,
            listener: *IDispatch,
            useCapture: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        dispatchEvent: fn(
            self: *const IEventTarget,
            evt: *IDOMEvent,
            pfResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget_addEventListener(self: *const T, type: BSTR, listener: *IDispatch, useCapture: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget.VTable, self.vtable).addEventListener(@ptrCast(*const IEventTarget, self), type, listener, useCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget_removeEventListener(self: *const T, type: BSTR, listener: *IDispatch, useCapture: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget.VTable, self.vtable).removeEventListener(@ptrCast(*const IEventTarget, self), type, listener, useCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget_dispatchEvent(self: *const T, evt: *IDOMEvent, pfResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget.VTable, self.vtable).dispatchEvent(@ptrCast(*const IEventTarget, self), evt, pfResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMEvent_Value = @import("../zig.zig").Guid.initString("3050F5A2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMEvent = &IID_DispDOMEvent_Value;
pub const DispDOMEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMUIEvent_Value = @import("../zig.zig").Guid.initString("305106CA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMUIEvent = &IID_IDOMUIEvent_Value;
pub const IDOMUIEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_view: fn(
            self: *const IDOMUIEvent,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_detail: fn(
            self: *const IDOMUIEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initUIEvent: fn(
            self: *const IDOMUIEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            view: *IHTMLWindow2,
            detail: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMUIEvent_get_view(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMUIEvent.VTable, self.vtable).get_view(@ptrCast(*const IDOMUIEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMUIEvent_get_detail(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMUIEvent.VTable, self.vtable).get_detail(@ptrCast(*const IDOMUIEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMUIEvent_initUIEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, view: *IHTMLWindow2, detail: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMUIEvent.VTable, self.vtable).initUIEvent(@ptrCast(*const IDOMUIEvent, self), eventType, canBubble, cancelable, view, detail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMUIEvent_Value = @import("../zig.zig").Guid.initString("30590072-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMUIEvent = &IID_DispDOMUIEvent_Value;
pub const DispDOMUIEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMouseEvent_Value = @import("../zig.zig").Guid.initString("305106CE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMMouseEvent = &IID_IDOMMouseEvent_Value;
pub const IDOMMouseEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_screenX: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_screenY: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientX: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clientY: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ctrlKey: fn(
            self: *const IDOMMouseEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shiftKey: fn(
            self: *const IDOMMouseEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_altKey: fn(
            self: *const IDOMMouseEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_metaKey: fn(
            self: *const IDOMMouseEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_button: fn(
            self: *const IDOMMouseEvent,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_relatedTarget: fn(
            self: *const IDOMMouseEvent,
            p: **IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMouseEvent: fn(
            self: *const IDOMMouseEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: *IHTMLWindow2,
            detailArg: i32,
            screenXArg: i32,
            screenYArg: i32,
            clientXArg: i32,
            clientYArg: i32,
            ctrlKeyArg: i16,
            altKeyArg: i16,
            shiftKeyArg: i16,
            metaKeyArg: i16,
            buttonArg: u16,
            relatedTargetArg: *IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getModifierState: fn(
            self: *const IDOMMouseEvent,
            keyArg: BSTR,
            activated: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_buttons: fn(
            self: *const IDOMMouseEvent,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fromElement: fn(
            self: *const IDOMMouseEvent,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_toElement: fn(
            self: *const IDOMMouseEvent,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetX: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offsetY: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageX: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageY: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layerX: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_layerY: fn(
            self: *const IDOMMouseEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_which: fn(
            self: *const IDOMMouseEvent,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_screenX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_screenX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_screenY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_screenY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_clientX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_clientX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_clientY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_clientY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_ctrlKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_ctrlKey(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_shiftKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_shiftKey(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_altKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_altKey(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_metaKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_metaKey(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_button(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_button(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_relatedTarget(self: *const T, p: **IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_relatedTarget(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_initMouseEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, viewArg: *IHTMLWindow2, detailArg: i32, screenXArg: i32, screenYArg: i32, clientXArg: i32, clientYArg: i32, ctrlKeyArg: i16, altKeyArg: i16, shiftKeyArg: i16, metaKeyArg: i16, buttonArg: u16, relatedTargetArg: *IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).initMouseEvent(@ptrCast(*const IDOMMouseEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, buttonArg, relatedTargetArg);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_getModifierState(self: *const T, keyArg: BSTR, activated: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).getModifierState(@ptrCast(*const IDOMMouseEvent, self), keyArg, activated);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_buttons(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_buttons(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_fromElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_fromElement(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_toElement(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_toElement(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_x(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_x(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_y(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_y(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_offsetX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_offsetX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_offsetY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_offsetY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_pageX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_pageX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_pageY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_pageY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_layerX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_layerX(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_layerY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_layerY(@ptrCast(*const IDOMMouseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseEvent_get_which(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseEvent.VTable, self.vtable).get_which(@ptrCast(*const IDOMMouseEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMouseEvent_Value = @import("../zig.zig").Guid.initString("30590073-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMMouseEvent = &IID_DispDOMMouseEvent_Value;
pub const DispDOMMouseEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMDragEvent_Value = @import("../zig.zig").Guid.initString("30510761-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMDragEvent = &IID_IDOMDragEvent_Value;
pub const IDOMDragEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_dataTransfer: fn(
            self: *const IDOMDragEvent,
            p: **IHTMLDataTransfer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initDragEvent: fn(
            self: *const IDOMDragEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: *IHTMLWindow2,
            detailArg: i32,
            screenXArg: i32,
            screenYArg: i32,
            clientXArg: i32,
            clientYArg: i32,
            ctrlKeyArg: i16,
            altKeyArg: i16,
            shiftKeyArg: i16,
            metaKeyArg: i16,
            buttonArg: u16,
            relatedTargetArg: *IEventTarget,
            dataTransferArg: *IHTMLDataTransfer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDragEvent_get_dataTransfer(self: *const T, p: **IHTMLDataTransfer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDragEvent.VTable, self.vtable).get_dataTransfer(@ptrCast(*const IDOMDragEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMDragEvent_initDragEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, viewArg: *IHTMLWindow2, detailArg: i32, screenXArg: i32, screenYArg: i32, clientXArg: i32, clientYArg: i32, ctrlKeyArg: i16, altKeyArg: i16, shiftKeyArg: i16, metaKeyArg: i16, buttonArg: u16, relatedTargetArg: *IEventTarget, dataTransferArg: *IHTMLDataTransfer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMDragEvent.VTable, self.vtable).initDragEvent(@ptrCast(*const IDOMDragEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, ctrlKeyArg, altKeyArg, shiftKeyArg, metaKeyArg, buttonArg, relatedTargetArg, dataTransferArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMDragEvent_Value = @import("../zig.zig").Guid.initString("305900A7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMDragEvent = &IID_DispDOMDragEvent_Value;
pub const DispDOMDragEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMouseWheelEvent_Value = @import("../zig.zig").Guid.initString("305106D0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMMouseWheelEvent = &IID_IDOMMouseWheelEvent_Value;
pub const IDOMMouseWheelEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_wheelDelta: fn(
            self: *const IDOMMouseWheelEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMouseWheelEvent: fn(
            self: *const IDOMMouseWheelEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: *IHTMLWindow2,
            detailArg: i32,
            screenXArg: i32,
            screenYArg: i32,
            clientXArg: i32,
            clientYArg: i32,
            buttonArg: u16,
            relatedTargetArg: *IEventTarget,
            modifiersListArg: BSTR,
            wheelDeltaArg: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseWheelEvent_get_wheelDelta(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseWheelEvent.VTable, self.vtable).get_wheelDelta(@ptrCast(*const IDOMMouseWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMouseWheelEvent_initMouseWheelEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, viewArg: *IHTMLWindow2, detailArg: i32, screenXArg: i32, screenYArg: i32, clientXArg: i32, clientYArg: i32, buttonArg: u16, relatedTargetArg: *IEventTarget, modifiersListArg: BSTR, wheelDeltaArg: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMouseWheelEvent.VTable, self.vtable).initMouseWheelEvent(@ptrCast(*const IDOMMouseWheelEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, buttonArg, relatedTargetArg, modifiersListArg, wheelDeltaArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMouseWheelEvent_Value = @import("../zig.zig").Guid.initString("30590074-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMMouseWheelEvent = &IID_DispDOMMouseWheelEvent_Value;
pub const DispDOMMouseWheelEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMWheelEvent_Value = @import("../zig.zig").Guid.initString("305106D2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMWheelEvent = &IID_IDOMWheelEvent_Value;
pub const IDOMWheelEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_deltaX: fn(
            self: *const IDOMWheelEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_deltaY: fn(
            self: *const IDOMWheelEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_deltaZ: fn(
            self: *const IDOMWheelEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_deltaMode: fn(
            self: *const IDOMWheelEvent,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initWheelEvent: fn(
            self: *const IDOMWheelEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: *IHTMLWindow2,
            detailArg: i32,
            screenXArg: i32,
            screenYArg: i32,
            clientXArg: i32,
            clientYArg: i32,
            buttonArg: u16,
            relatedTargetArg: *IEventTarget,
            modifiersListArg: BSTR,
            deltaX: i32,
            deltaY: i32,
            deltaZ: i32,
            deltaMode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_get_deltaX(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).get_deltaX(@ptrCast(*const IDOMWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_get_deltaY(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).get_deltaY(@ptrCast(*const IDOMWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_get_deltaZ(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).get_deltaZ(@ptrCast(*const IDOMWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_get_deltaMode(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).get_deltaMode(@ptrCast(*const IDOMWheelEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMWheelEvent_initWheelEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, viewArg: *IHTMLWindow2, detailArg: i32, screenXArg: i32, screenYArg: i32, clientXArg: i32, clientYArg: i32, buttonArg: u16, relatedTargetArg: *IEventTarget, modifiersListArg: BSTR, deltaX: i32, deltaY: i32, deltaZ: i32, deltaMode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMWheelEvent.VTable, self.vtable).initWheelEvent(@ptrCast(*const IDOMWheelEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, screenXArg, screenYArg, clientXArg, clientYArg, buttonArg, relatedTargetArg, modifiersListArg, deltaX, deltaY, deltaZ, deltaMode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMWheelEvent_Value = @import("../zig.zig").Guid.initString("30590075-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMWheelEvent = &IID_DispDOMWheelEvent_Value;
pub const DispDOMWheelEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMTextEvent_Value = @import("../zig.zig").Guid.initString("305106D4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMTextEvent = &IID_IDOMTextEvent_Value;
pub const IDOMTextEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_data: fn(
            self: *const IDOMTextEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_inputMethod: fn(
            self: *const IDOMTextEvent,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initTextEvent: fn(
            self: *const IDOMTextEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: *IHTMLWindow2,
            dataArg: BSTR,
            inputMethod: u32,
            locale: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_locale: fn(
            self: *const IDOMTextEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTextEvent_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTextEvent.VTable, self.vtable).get_data(@ptrCast(*const IDOMTextEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTextEvent_get_inputMethod(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTextEvent.VTable, self.vtable).get_inputMethod(@ptrCast(*const IDOMTextEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTextEvent_initTextEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, viewArg: *IHTMLWindow2, dataArg: BSTR, inputMethod: u32, locale: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTextEvent.VTable, self.vtable).initTextEvent(@ptrCast(*const IDOMTextEvent, self), eventType, canBubble, cancelable, viewArg, dataArg, inputMethod, locale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMTextEvent_get_locale(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMTextEvent.VTable, self.vtable).get_locale(@ptrCast(*const IDOMTextEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMTextEvent_Value = @import("../zig.zig").Guid.initString("30590076-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMTextEvent = &IID_DispDOMTextEvent_Value;
pub const DispDOMTextEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMKeyboardEvent_Value = @import("../zig.zig").Guid.initString("305106D6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMKeyboardEvent = &IID_IDOMKeyboardEvent_Value;
pub const IDOMKeyboardEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_key: fn(
            self: *const IDOMKeyboardEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_location: fn(
            self: *const IDOMKeyboardEvent,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ctrlKey: fn(
            self: *const IDOMKeyboardEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shiftKey: fn(
            self: *const IDOMKeyboardEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_altKey: fn(
            self: *const IDOMKeyboardEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_metaKey: fn(
            self: *const IDOMKeyboardEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_repeat: fn(
            self: *const IDOMKeyboardEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getModifierState: fn(
            self: *const IDOMKeyboardEvent,
            keyArg: BSTR,
            state: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initKeyboardEvent: fn(
            self: *const IDOMKeyboardEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: *IHTMLWindow2,
            keyArg: BSTR,
            locationArg: u32,
            modifiersListArg: BSTR,
            repeat: i16,
            locale: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_keyCode: fn(
            self: *const IDOMKeyboardEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_charCode: fn(
            self: *const IDOMKeyboardEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_which: fn(
            self: *const IDOMKeyboardEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ie9_char: fn(
            self: *const IDOMKeyboardEvent,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_locale: fn(
            self: *const IDOMKeyboardEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_key(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_key(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_location(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_location(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_ctrlKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_ctrlKey(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_shiftKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_shiftKey(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_altKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_altKey(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_metaKey(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_metaKey(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_repeat(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_repeat(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_getModifierState(self: *const T, keyArg: BSTR, state: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).getModifierState(@ptrCast(*const IDOMKeyboardEvent, self), keyArg, state);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_initKeyboardEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, viewArg: *IHTMLWindow2, keyArg: BSTR, locationArg: u32, modifiersListArg: BSTR, repeat: i16, locale: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).initKeyboardEvent(@ptrCast(*const IDOMKeyboardEvent, self), eventType, canBubble, cancelable, viewArg, keyArg, locationArg, modifiersListArg, repeat, locale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_keyCode(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_keyCode(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_charCode(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_charCode(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_which(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_which(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_ie9_char(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_ie9_char(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMKeyboardEvent_get_locale(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMKeyboardEvent.VTable, self.vtable).get_locale(@ptrCast(*const IDOMKeyboardEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMKeyboardEvent_Value = @import("../zig.zig").Guid.initString("30590077-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMKeyboardEvent = &IID_DispDOMKeyboardEvent_Value;
pub const DispDOMKeyboardEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMCompositionEvent_Value = @import("../zig.zig").Guid.initString("305106D8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMCompositionEvent = &IID_IDOMCompositionEvent_Value;
pub const IDOMCompositionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_data: fn(
            self: *const IDOMCompositionEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initCompositionEvent: fn(
            self: *const IDOMCompositionEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: *IHTMLWindow2,
            data: BSTR,
            locale: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_locale: fn(
            self: *const IDOMCompositionEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCompositionEvent_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCompositionEvent.VTable, self.vtable).get_data(@ptrCast(*const IDOMCompositionEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCompositionEvent_initCompositionEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, viewArg: *IHTMLWindow2, data: BSTR, locale: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCompositionEvent.VTable, self.vtable).initCompositionEvent(@ptrCast(*const IDOMCompositionEvent, self), eventType, canBubble, cancelable, viewArg, data, locale);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCompositionEvent_get_locale(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCompositionEvent.VTable, self.vtable).get_locale(@ptrCast(*const IDOMCompositionEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMCompositionEvent_Value = @import("../zig.zig").Guid.initString("30590078-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMCompositionEvent = &IID_DispDOMCompositionEvent_Value;
pub const DispDOMCompositionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMutationEvent_Value = @import("../zig.zig").Guid.initString("305106DA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMMutationEvent = &IID_IDOMMutationEvent_Value;
pub const IDOMMutationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_relatedNode: fn(
            self: *const IDOMMutationEvent,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_prevValue: fn(
            self: *const IDOMMutationEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_newValue: fn(
            self: *const IDOMMutationEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_attrName: fn(
            self: *const IDOMMutationEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_attrChange: fn(
            self: *const IDOMMutationEvent,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMutationEvent: fn(
            self: *const IDOMMutationEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            relatedNodeArg: *IDispatch,
            prevValueArg: BSTR,
            newValueArg: BSTR,
            attrNameArg: BSTR,
            attrChangeArg: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_relatedNode(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_relatedNode(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_prevValue(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_prevValue(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_newValue(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_newValue(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_attrName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_attrName(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_get_attrChange(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).get_attrChange(@ptrCast(*const IDOMMutationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMutationEvent_initMutationEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, relatedNodeArg: *IDispatch, prevValueArg: BSTR, newValueArg: BSTR, attrNameArg: BSTR, attrChangeArg: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMutationEvent.VTable, self.vtable).initMutationEvent(@ptrCast(*const IDOMMutationEvent, self), eventType, canBubble, cancelable, relatedNodeArg, prevValueArg, newValueArg, attrNameArg, attrChangeArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMutationEvent_Value = @import("../zig.zig").Guid.initString("30590079-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMMutationEvent = &IID_DispDOMMutationEvent_Value;
pub const DispDOMMutationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMBeforeUnloadEvent_Value = @import("../zig.zig").Guid.initString("30510763-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMBeforeUnloadEvent = &IID_IDOMBeforeUnloadEvent_Value;
pub const IDOMBeforeUnloadEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_returnValue: fn(
            self: *const IDOMBeforeUnloadEvent,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_returnValue: fn(
            self: *const IDOMBeforeUnloadEvent,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMBeforeUnloadEvent_put_returnValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMBeforeUnloadEvent.VTable, self.vtable).put_returnValue(@ptrCast(*const IDOMBeforeUnloadEvent, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMBeforeUnloadEvent_get_returnValue(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMBeforeUnloadEvent.VTable, self.vtable).get_returnValue(@ptrCast(*const IDOMBeforeUnloadEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMBeforeUnloadEvent_Value = @import("../zig.zig").Guid.initString("305900A8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMBeforeUnloadEvent = &IID_DispDOMBeforeUnloadEvent_Value;
pub const DispDOMBeforeUnloadEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMFocusEvent_Value = @import("../zig.zig").Guid.initString("305106CC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMFocusEvent = &IID_IDOMFocusEvent_Value;
pub const IDOMFocusEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_relatedTarget: fn(
            self: *const IDOMFocusEvent,
            p: **IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initFocusEvent: fn(
            self: *const IDOMFocusEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            view: *IHTMLWindow2,
            detail: i32,
            relatedTargetArg: *IEventTarget,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMFocusEvent_get_relatedTarget(self: *const T, p: **IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMFocusEvent.VTable, self.vtable).get_relatedTarget(@ptrCast(*const IDOMFocusEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMFocusEvent_initFocusEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, view: *IHTMLWindow2, detail: i32, relatedTargetArg: *IEventTarget) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMFocusEvent.VTable, self.vtable).initFocusEvent(@ptrCast(*const IDOMFocusEvent, self), eventType, canBubble, cancelable, view, detail, relatedTargetArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMFocusEvent_Value = @import("../zig.zig").Guid.initString("30590071-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMFocusEvent = &IID_DispDOMFocusEvent_Value;
pub const DispDOMFocusEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMCustomEvent_Value = @import("../zig.zig").Guid.initString("305106DE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMCustomEvent = &IID_IDOMCustomEvent_Value;
pub const IDOMCustomEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_detail: fn(
            self: *const IDOMCustomEvent,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initCustomEvent: fn(
            self: *const IDOMCustomEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            detail: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCustomEvent_get_detail(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCustomEvent.VTable, self.vtable).get_detail(@ptrCast(*const IDOMCustomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCustomEvent_initCustomEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, detail: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCustomEvent.VTable, self.vtable).initCustomEvent(@ptrCast(*const IDOMCustomEvent, self), eventType, canBubble, cancelable, detail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMCustomEvent_Value = @import("../zig.zig").Guid.initString("3059007C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMCustomEvent = &IID_DispDOMCustomEvent_Value;
pub const DispDOMCustomEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasGradient_Value = @import("../zig.zig").Guid.initString("30510714-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ICanvasGradient = &IID_ICanvasGradient_Value;
pub const ICanvasGradient = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        addColorStop: fn(
            self: *const ICanvasGradient,
            offset: f32,
            color: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasGradient_addColorStop(self: *const T, offset: f32, color: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasGradient.VTable, self.vtable).addColorStop(@ptrCast(*const ICanvasGradient, self), offset, color);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasPattern_Value = @import("../zig.zig").Guid.initString("30510716-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ICanvasPattern = &IID_ICanvasPattern_Value;
pub const ICanvasPattern = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasTextMetrics_Value = @import("../zig.zig").Guid.initString("30510718-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ICanvasTextMetrics = &IID_ICanvasTextMetrics_Value;
pub const ICanvasTextMetrics = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_width: fn(
            self: *const ICanvasTextMetrics,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasTextMetrics_get_width(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasTextMetrics.VTable, self.vtable).get_width(@ptrCast(*const ICanvasTextMetrics, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasImageData_Value = @import("../zig.zig").Guid.initString("3051071A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ICanvasImageData = &IID_ICanvasImageData_Value;
pub const ICanvasImageData = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_width: fn(
            self: *const ICanvasImageData,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const ICanvasImageData,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_data: fn(
            self: *const ICanvasImageData,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasImageData_get_width(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasImageData.VTable, self.vtable).get_width(@ptrCast(*const ICanvasImageData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasImageData_get_height(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasImageData.VTable, self.vtable).get_height(@ptrCast(*const ICanvasImageData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasImageData_get_data(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasImageData.VTable, self.vtable).get_data(@ptrCast(*const ICanvasImageData, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasPixelArray_Value = @import("../zig.zig").Guid.initString("3051071C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ICanvasPixelArray = &IID_ICanvasPixelArray_Value;
pub const ICanvasPixelArray = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const ICanvasPixelArray,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasPixelArray_get_length(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasPixelArray.VTable, self.vtable).get_length(@ptrCast(*const ICanvasPixelArray, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCanvasElement_Value = @import("../zig.zig").Guid.initString("305106E4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCanvasElement = &IID_IHTMLCanvasElement_Value;
pub const IHTMLCanvasElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_width: fn(
            self: *const IHTMLCanvasElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLCanvasElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLCanvasElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLCanvasElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getContext: fn(
            self: *const IHTMLCanvasElement,
            contextId: BSTR,
            ppContext: **ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toDataURL: fn(
            self: *const IHTMLCanvasElement,
            type: BSTR,
            jpegquality: VARIANT,
            pUrl: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLCanvasElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_get_width(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLCanvasElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLCanvasElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_get_height(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLCanvasElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_getContext(self: *const T, contextId: BSTR, ppContext: **ICanvasRenderingContext2D) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).getContext(@ptrCast(*const IHTMLCanvasElement, self), contextId, ppContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCanvasElement_toDataURL(self: *const T, type: BSTR, jpegquality: VARIANT, pUrl: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCanvasElement.VTable, self.vtable).toDataURL(@ptrCast(*const IHTMLCanvasElement, self), type, jpegquality, pUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasRenderingContext2D_Value = @import("../zig.zig").Guid.initString("305106FF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ICanvasRenderingContext2D = &IID_ICanvasRenderingContext2D_Value;
pub const ICanvasRenderingContext2D = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_canvas: fn(
            self: *const ICanvasRenderingContext2D,
            p: **IHTMLCanvasElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        restore: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        save: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rotate: fn(
            self: *const ICanvasRenderingContext2D,
            angle: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scale: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setTransform: fn(
            self: *const ICanvasRenderingContext2D,
            m11: f32,
            m12: f32,
            m21: f32,
            m22: f32,
            dx: f32,
            dy: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        transform: fn(
            self: *const ICanvasRenderingContext2D,
            m11: f32,
            m12: f32,
            m21: f32,
            m22: f32,
            dx: f32,
            dy: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        translate: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_globalAlpha: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_globalAlpha: fn(
            self: *const ICanvasRenderingContext2D,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_globalCompositeOperation: fn(
            self: *const ICanvasRenderingContext2D,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_globalCompositeOperation: fn(
            self: *const ICanvasRenderingContext2D,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_fillStyle: fn(
            self: *const ICanvasRenderingContext2D,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fillStyle: fn(
            self: *const ICanvasRenderingContext2D,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_strokeStyle: fn(
            self: *const ICanvasRenderingContext2D,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_strokeStyle: fn(
            self: *const ICanvasRenderingContext2D,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createLinearGradient: fn(
            self: *const ICanvasRenderingContext2D,
            x0: f32,
            y0: f32,
            x1: f32,
            y1: f32,
            ppCanvasGradient: **ICanvasGradient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createRadialGradient: fn(
            self: *const ICanvasRenderingContext2D,
            x0: f32,
            y0: f32,
            r0: f32,
            x1: f32,
            y1: f32,
            r1: f32,
            ppCanvasGradient: **ICanvasGradient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createPattern: fn(
            self: *const ICanvasRenderingContext2D,
            image: *IDispatch,
            repetition: VARIANT,
            ppCanvasPattern: **ICanvasPattern,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lineCap: fn(
            self: *const ICanvasRenderingContext2D,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineCap: fn(
            self: *const ICanvasRenderingContext2D,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lineJoin: fn(
            self: *const ICanvasRenderingContext2D,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineJoin: fn(
            self: *const ICanvasRenderingContext2D,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_lineWidth: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineWidth: fn(
            self: *const ICanvasRenderingContext2D,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_miterLimit: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_miterLimit: fn(
            self: *const ICanvasRenderingContext2D,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_shadowBlur: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shadowBlur: fn(
            self: *const ICanvasRenderingContext2D,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_shadowColor: fn(
            self: *const ICanvasRenderingContext2D,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shadowColor: fn(
            self: *const ICanvasRenderingContext2D,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_shadowOffsetX: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shadowOffsetX: fn(
            self: *const ICanvasRenderingContext2D,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_shadowOffsetY: fn(
            self: *const ICanvasRenderingContext2D,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shadowOffsetY: fn(
            self: *const ICanvasRenderingContext2D,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearRect: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            w: f32,
            h: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fillRect: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            w: f32,
            h: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        strokeRect: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            w: f32,
            h: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        arc: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            radius: f32,
            startAngle: f32,
            endAngle: f32,
            anticlockwise: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        arcTo: fn(
            self: *const ICanvasRenderingContext2D,
            x1: f32,
            y1: f32,
            x2: f32,
            y2: f32,
            radius: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        beginPath: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        bezierCurveTo: fn(
            self: *const ICanvasRenderingContext2D,
            cp1x: f32,
            cp1y: f32,
            cp2x: f32,
            cp2y: f32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clip: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        closePath: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fill: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        lineTo: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        moveTo: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        quadraticCurveTo: fn(
            self: *const ICanvasRenderingContext2D,
            cpx: f32,
            cpy: f32,
            x: f32,
            y: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rect: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            w: f32,
            h: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stroke: fn(
            self: *const ICanvasRenderingContext2D,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isPointInPath: fn(
            self: *const ICanvasRenderingContext2D,
            x: f32,
            y: f32,
            pResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_font: fn(
            self: *const ICanvasRenderingContext2D,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_font: fn(
            self: *const ICanvasRenderingContext2D,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textAlign: fn(
            self: *const ICanvasRenderingContext2D,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textAlign: fn(
            self: *const ICanvasRenderingContext2D,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_textBaseline: fn(
            self: *const ICanvasRenderingContext2D,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textBaseline: fn(
            self: *const ICanvasRenderingContext2D,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        fillText: fn(
            self: *const ICanvasRenderingContext2D,
            text: BSTR,
            x: f32,
            y: f32,
            maxWidth: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        measureText: fn(
            self: *const ICanvasRenderingContext2D,
            text: BSTR,
            ppCanvasTextMetrics: **ICanvasTextMetrics,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        strokeText: fn(
            self: *const ICanvasRenderingContext2D,
            text: BSTR,
            x: f32,
            y: f32,
            maxWidth: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        drawImage: fn(
            self: *const ICanvasRenderingContext2D,
            pSrc: *IDispatch,
            a1: VARIANT,
            a2: VARIANT,
            a3: VARIANT,
            a4: VARIANT,
            a5: VARIANT,
            a6: VARIANT,
            a7: VARIANT,
            a8: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createImageData: fn(
            self: *const ICanvasRenderingContext2D,
            a1: VARIANT,
            a2: VARIANT,
            ppCanvasImageData: **ICanvasImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getImageData: fn(
            self: *const ICanvasRenderingContext2D,
            sx: f32,
            sy: f32,
            sw: f32,
            sh: f32,
            ppCanvasImageData: **ICanvasImageData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putImageData: fn(
            self: *const ICanvasRenderingContext2D,
            imagedata: *ICanvasImageData,
            dx: f32,
            dy: f32,
            dirtyX: VARIANT,
            dirtyY: VARIANT,
            dirtyWidth: VARIANT,
            dirtyHeight: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_canvas(self: *const T, p: **IHTMLCanvasElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_canvas(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_restore(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).restore(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_save(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).save(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_rotate(self: *const T, angle: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).rotate(@ptrCast(*const ICanvasRenderingContext2D, self), angle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_scale(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).scale(@ptrCast(*const ICanvasRenderingContext2D, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_setTransform(self: *const T, m11: f32, m12: f32, m21: f32, m22: f32, dx: f32, dy: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).setTransform(@ptrCast(*const ICanvasRenderingContext2D, self), m11, m12, m21, m22, dx, dy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_transform(self: *const T, m11: f32, m12: f32, m21: f32, m22: f32, dx: f32, dy: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).transform(@ptrCast(*const ICanvasRenderingContext2D, self), m11, m12, m21, m22, dx, dy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_translate(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).translate(@ptrCast(*const ICanvasRenderingContext2D, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_globalAlpha(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_globalAlpha(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_globalAlpha(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_globalAlpha(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_globalCompositeOperation(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_globalCompositeOperation(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_globalCompositeOperation(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_globalCompositeOperation(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_fillStyle(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_fillStyle(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_fillStyle(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_fillStyle(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_strokeStyle(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_strokeStyle(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_strokeStyle(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_strokeStyle(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_createLinearGradient(self: *const T, x0: f32, y0: f32, x1: f32, y1: f32, ppCanvasGradient: **ICanvasGradient) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).createLinearGradient(@ptrCast(*const ICanvasRenderingContext2D, self), x0, y0, x1, y1, ppCanvasGradient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_createRadialGradient(self: *const T, x0: f32, y0: f32, r0: f32, x1: f32, y1: f32, r1: f32, ppCanvasGradient: **ICanvasGradient) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).createRadialGradient(@ptrCast(*const ICanvasRenderingContext2D, self), x0, y0, r0, x1, y1, r1, ppCanvasGradient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_createPattern(self: *const T, image: *IDispatch, repetition: VARIANT, ppCanvasPattern: **ICanvasPattern) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).createPattern(@ptrCast(*const ICanvasRenderingContext2D, self), image, repetition, ppCanvasPattern);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_lineCap(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_lineCap(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_lineCap(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_lineCap(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_lineJoin(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_lineJoin(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_lineJoin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_lineJoin(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_lineWidth(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_lineWidth(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_lineWidth(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_lineWidth(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_miterLimit(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_miterLimit(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_miterLimit(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_miterLimit(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_shadowBlur(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_shadowBlur(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_shadowBlur(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_shadowBlur(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_shadowColor(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_shadowColor(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_shadowColor(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_shadowColor(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_shadowOffsetX(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_shadowOffsetX(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_shadowOffsetX(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_shadowOffsetX(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_shadowOffsetY(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_shadowOffsetY(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_shadowOffsetY(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_shadowOffsetY(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_clearRect(self: *const T, x: f32, y: f32, w: f32, h: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).clearRect(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, w, h);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_fillRect(self: *const T, x: f32, y: f32, w: f32, h: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).fillRect(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, w, h);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_strokeRect(self: *const T, x: f32, y: f32, w: f32, h: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).strokeRect(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, w, h);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_arc(self: *const T, x: f32, y: f32, radius: f32, startAngle: f32, endAngle: f32, anticlockwise: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).arc(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, radius, startAngle, endAngle, anticlockwise);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_arcTo(self: *const T, x1: f32, y1: f32, x2: f32, y2: f32, radius: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).arcTo(@ptrCast(*const ICanvasRenderingContext2D, self), x1, y1, x2, y2, radius);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_beginPath(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).beginPath(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_bezierCurveTo(self: *const T, cp1x: f32, cp1y: f32, cp2x: f32, cp2y: f32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).bezierCurveTo(@ptrCast(*const ICanvasRenderingContext2D, self), cp1x, cp1y, cp2x, cp2y, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_clip(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).clip(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_closePath(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).closePath(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_fill(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).fill(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_lineTo(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).lineTo(@ptrCast(*const ICanvasRenderingContext2D, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_moveTo(self: *const T, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).moveTo(@ptrCast(*const ICanvasRenderingContext2D, self), x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_quadraticCurveTo(self: *const T, cpx: f32, cpy: f32, x: f32, y: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).quadraticCurveTo(@ptrCast(*const ICanvasRenderingContext2D, self), cpx, cpy, x, y);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_rect(self: *const T, x: f32, y: f32, w: f32, h: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).rect(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, w, h);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_stroke(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).stroke(@ptrCast(*const ICanvasRenderingContext2D, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_isPointInPath(self: *const T, x: f32, y: f32, pResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).isPointInPath(@ptrCast(*const ICanvasRenderingContext2D, self), x, y, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_font(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_font(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_font(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_font(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_textAlign(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_textAlign(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_textAlign(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_textAlign(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_put_textBaseline(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).put_textBaseline(@ptrCast(*const ICanvasRenderingContext2D, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_get_textBaseline(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).get_textBaseline(@ptrCast(*const ICanvasRenderingContext2D, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_fillText(self: *const T, text: BSTR, x: f32, y: f32, maxWidth: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).fillText(@ptrCast(*const ICanvasRenderingContext2D, self), text, x, y, maxWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_measureText(self: *const T, text: BSTR, ppCanvasTextMetrics: **ICanvasTextMetrics) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).measureText(@ptrCast(*const ICanvasRenderingContext2D, self), text, ppCanvasTextMetrics);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_strokeText(self: *const T, text: BSTR, x: f32, y: f32, maxWidth: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).strokeText(@ptrCast(*const ICanvasRenderingContext2D, self), text, x, y, maxWidth);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_drawImage(self: *const T, pSrc: *IDispatch, a1: VARIANT, a2: VARIANT, a3: VARIANT, a4: VARIANT, a5: VARIANT, a6: VARIANT, a7: VARIANT, a8: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).drawImage(@ptrCast(*const ICanvasRenderingContext2D, self), pSrc, a1, a2, a3, a4, a5, a6, a7, a8);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_createImageData(self: *const T, a1: VARIANT, a2: VARIANT, ppCanvasImageData: **ICanvasImageData) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).createImageData(@ptrCast(*const ICanvasRenderingContext2D, self), a1, a2, ppCanvasImageData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_getImageData(self: *const T, sx: f32, sy: f32, sw: f32, sh: f32, ppCanvasImageData: **ICanvasImageData) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).getImageData(@ptrCast(*const ICanvasRenderingContext2D, self), sx, sy, sw, sh, ppCanvasImageData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasRenderingContext2D_putImageData(self: *const T, imagedata: *ICanvasImageData, dx: f32, dy: f32, dirtyX: VARIANT, dirtyY: VARIANT, dirtyWidth: VARIANT, dirtyHeight: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasRenderingContext2D.VTable, self.vtable).putImageData(@ptrCast(*const ICanvasRenderingContext2D, self), imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasGradient_Value = @import("../zig.zig").Guid.initString("3059008C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispCanvasGradient = &IID_DispCanvasGradient_Value;
pub const DispCanvasGradient = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasPattern_Value = @import("../zig.zig").Guid.initString("3059008D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispCanvasPattern = &IID_DispCanvasPattern_Value;
pub const DispCanvasPattern = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasTextMetrics_Value = @import("../zig.zig").Guid.initString("3059008E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispCanvasTextMetrics = &IID_DispCanvasTextMetrics_Value;
pub const DispCanvasTextMetrics = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasImageData_Value = @import("../zig.zig").Guid.initString("3059008F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispCanvasImageData = &IID_DispCanvasImageData_Value;
pub const DispCanvasImageData = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCanvasRenderingContext2D_Value = @import("../zig.zig").Guid.initString("30590082-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispCanvasRenderingContext2D = &IID_DispCanvasRenderingContext2D_Value;
pub const DispCanvasRenderingContext2D = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLCanvasElement_Value = @import("../zig.zig").Guid.initString("3059007B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLCanvasElement = &IID_DispHTMLCanvasElement_Value;
pub const DispHTMLCanvasElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMProgressEvent_Value = @import("../zig.zig").Guid.initString("3051071E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMProgressEvent = &IID_IDOMProgressEvent_Value;
pub const IDOMProgressEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_lengthComputable: fn(
            self: *const IDOMProgressEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_loaded: fn(
            self: *const IDOMProgressEvent,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_total: fn(
            self: *const IDOMProgressEvent,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initProgressEvent: fn(
            self: *const IDOMProgressEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            lengthComputableArg: i16,
            loadedArg: u64,
            totalArg: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProgressEvent_get_lengthComputable(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProgressEvent.VTable, self.vtable).get_lengthComputable(@ptrCast(*const IDOMProgressEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProgressEvent_get_loaded(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProgressEvent.VTable, self.vtable).get_loaded(@ptrCast(*const IDOMProgressEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProgressEvent_get_total(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProgressEvent.VTable, self.vtable).get_total(@ptrCast(*const IDOMProgressEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMProgressEvent_initProgressEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, lengthComputableArg: i16, loadedArg: u64, totalArg: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMProgressEvent.VTable, self.vtable).initProgressEvent(@ptrCast(*const IDOMProgressEvent, self), eventType, canBubble, cancelable, lengthComputableArg, loadedArg, totalArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMProgressEvent_Value = @import("../zig.zig").Guid.initString("30590091-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMProgressEvent = &IID_DispDOMProgressEvent_Value;
pub const DispDOMProgressEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMessageEvent_Value = @import("../zig.zig").Guid.initString("30510720-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMMessageEvent = &IID_IDOMMessageEvent_Value;
pub const IDOMMessageEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_data: fn(
            self: *const IDOMMessageEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_origin: fn(
            self: *const IDOMMessageEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_source: fn(
            self: *const IDOMMessageEvent,
            p: **IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMessageEvent: fn(
            self: *const IDOMMessageEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            data: BSTR,
            origin: BSTR,
            lastEventId: BSTR,
            source: *IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMessageEvent_get_data(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMessageEvent.VTable, self.vtable).get_data(@ptrCast(*const IDOMMessageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMessageEvent_get_origin(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMessageEvent.VTable, self.vtable).get_origin(@ptrCast(*const IDOMMessageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMessageEvent_get_source(self: *const T, p: **IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMessageEvent.VTable, self.vtable).get_source(@ptrCast(*const IDOMMessageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMessageEvent_initMessageEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, data: BSTR, origin: BSTR, lastEventId: BSTR, source: *IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMessageEvent.VTable, self.vtable).initMessageEvent(@ptrCast(*const IDOMMessageEvent, self), eventType, canBubble, cancelable, data, origin, lastEventId, source);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMessageEvent_Value = @import("../zig.zig").Guid.initString("30590092-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMMessageEvent = &IID_DispDOMMessageEvent_Value;
pub const DispDOMMessageEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMSiteModeEvent_Value = @import("../zig.zig").Guid.initString("30510765-98B6-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMSiteModeEvent = &IID_IDOMSiteModeEvent_Value;
pub const IDOMSiteModeEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_buttonID: fn(
            self: *const IDOMSiteModeEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_actionURL: fn(
            self: *const IDOMSiteModeEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMSiteModeEvent_get_buttonID(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMSiteModeEvent.VTable, self.vtable).get_buttonID(@ptrCast(*const IDOMSiteModeEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMSiteModeEvent_get_actionURL(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMSiteModeEvent.VTable, self.vtable).get_actionURL(@ptrCast(*const IDOMSiteModeEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMSiteModeEvent_Value = @import("../zig.zig").Guid.initString("305900A9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMSiteModeEvent = &IID_DispDOMSiteModeEvent_Value;
pub const DispDOMSiteModeEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMStorageEvent_Value = @import("../zig.zig").Guid.initString("30510722-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMStorageEvent = &IID_IDOMStorageEvent_Value;
pub const IDOMStorageEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_key: fn(
            self: *const IDOMStorageEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_oldValue: fn(
            self: *const IDOMStorageEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_newValue: fn(
            self: *const IDOMStorageEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_url: fn(
            self: *const IDOMStorageEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_storageArea: fn(
            self: *const IDOMStorageEvent,
            p: **IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initStorageEvent: fn(
            self: *const IDOMStorageEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            keyArg: BSTR,
            oldValueArg: BSTR,
            newValueArg: BSTR,
            urlArg: BSTR,
            storageAreaArg: *IHTMLStorage,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_key(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_key(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_oldValue(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_oldValue(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_newValue(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_newValue(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_url(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_url(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_get_storageArea(self: *const T, p: **IHTMLStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).get_storageArea(@ptrCast(*const IDOMStorageEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMStorageEvent_initStorageEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, keyArg: BSTR, oldValueArg: BSTR, newValueArg: BSTR, urlArg: BSTR, storageAreaArg: *IHTMLStorage) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMStorageEvent.VTable, self.vtable).initStorageEvent(@ptrCast(*const IDOMStorageEvent, self), eventType, canBubble, cancelable, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMStorageEvent_Value = @import("../zig.zig").Guid.initString("30590093-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMStorageEvent = &IID_DispDOMStorageEvent_Value;
pub const DispDOMStorageEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLHttpRequestEventTarget_Value = @import("../zig.zig").Guid.initString("30510830-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IXMLHttpRequestEventTarget = &IID_IXMLHttpRequestEventTarget_Value;
pub const IXMLHttpRequestEventTarget = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispXMLHttpRequestEventTarget_Value = @import("../zig.zig").Guid.initString("305900E7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispXMLHttpRequestEventTarget = &IID_DispXMLHttpRequestEventTarget_Value;
pub const DispXMLHttpRequestEventTarget = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLXMLHttpRequestEvents_Value = @import("../zig.zig").Guid.initString("30510498-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLXMLHttpRequestEvents = &IID_HTMLXMLHttpRequestEvents_Value;
pub const HTMLXMLHttpRequestEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXMLHttpRequest_Value = @import("../zig.zig").Guid.initString("3051040A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLXMLHttpRequest = &IID_IHTMLXMLHttpRequest_Value;
pub const IHTMLXMLHttpRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_readyState: fn(
            self: *const IHTMLXMLHttpRequest,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_responseBody: fn(
            self: *const IHTMLXMLHttpRequest,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_responseText: fn(
            self: *const IHTMLXMLHttpRequest,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_responseXML: fn(
            self: *const IHTMLXMLHttpRequest,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLXMLHttpRequest,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_statusText: fn(
            self: *const IHTMLXMLHttpRequest,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLXMLHttpRequest,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLXMLHttpRequest,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        abort: fn(
            self: *const IHTMLXMLHttpRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        open: fn(
            self: *const IHTMLXMLHttpRequest,
            bstrMethod: BSTR,
            bstrUrl: BSTR,
            varAsync: VARIANT,
            varUser: VARIANT,
            varPassword: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        send: fn(
            self: *const IHTMLXMLHttpRequest,
            varBody: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getAllResponseHeaders: fn(
            self: *const IHTMLXMLHttpRequest,
            __MIDL__IHTMLXMLHttpRequest0000: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getResponseHeader: fn(
            self: *const IHTMLXMLHttpRequest,
            bstrHeader: BSTR,
            __MIDL__IHTMLXMLHttpRequest0001: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setRequestHeader: fn(
            self: *const IHTMLXMLHttpRequest,
            bstrHeader: BSTR,
            bstrValue: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_readyState(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_responseBody(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_responseBody(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_responseText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_responseText(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_responseXML(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_responseXML(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_status(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_status(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_statusText(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_statusText(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLXMLHttpRequest, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLXMLHttpRequest, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).abort(@ptrCast(*const IHTMLXMLHttpRequest, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_open(self: *const T, bstrMethod: BSTR, bstrUrl: BSTR, varAsync: VARIANT, varUser: VARIANT, varPassword: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).open(@ptrCast(*const IHTMLXMLHttpRequest, self), bstrMethod, bstrUrl, varAsync, varUser, varPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_send(self: *const T, varBody: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).send(@ptrCast(*const IHTMLXMLHttpRequest, self), varBody);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_getAllResponseHeaders(self: *const T, __MIDL__IHTMLXMLHttpRequest0000: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).getAllResponseHeaders(@ptrCast(*const IHTMLXMLHttpRequest, self), __MIDL__IHTMLXMLHttpRequest0000);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_getResponseHeader(self: *const T, bstrHeader: BSTR, __MIDL__IHTMLXMLHttpRequest0001: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).getResponseHeader(@ptrCast(*const IHTMLXMLHttpRequest, self), bstrHeader, __MIDL__IHTMLXMLHttpRequest0001);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest_setRequestHeader(self: *const T, bstrHeader: BSTR, bstrValue: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest.VTable, self.vtable).setRequestHeader(@ptrCast(*const IHTMLXMLHttpRequest, self), bstrHeader, bstrValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXMLHttpRequest2_Value = @import("../zig.zig").Guid.initString("30510482-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLXMLHttpRequest2 = &IID_IHTMLXMLHttpRequest2_Value;
pub const IHTMLXMLHttpRequest2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_timeout: fn(
            self: *const IHTMLXMLHttpRequest2,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_timeout: fn(
            self: *const IHTMLXMLHttpRequest2,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_ontimeout: fn(
            self: *const IHTMLXMLHttpRequest2,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ontimeout: fn(
            self: *const IHTMLXMLHttpRequest2,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest2_put_timeout(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest2.VTable, self.vtable).put_timeout(@ptrCast(*const IHTMLXMLHttpRequest2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest2_get_timeout(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest2.VTable, self.vtable).get_timeout(@ptrCast(*const IHTMLXMLHttpRequest2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest2_put_ontimeout(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest2.VTable, self.vtable).put_ontimeout(@ptrCast(*const IHTMLXMLHttpRequest2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequest2_get_ontimeout(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequest2.VTable, self.vtable).get_ontimeout(@ptrCast(*const IHTMLXMLHttpRequest2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLXMLHttpRequestFactory_Value = @import("../zig.zig").Guid.initString("3051040C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLXMLHttpRequestFactory = &IID_IHTMLXMLHttpRequestFactory_Value;
pub const IHTMLXMLHttpRequestFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLXMLHttpRequestFactory,
            __MIDL__IHTMLXMLHttpRequestFactory0000: **IHTMLXMLHttpRequest,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLXMLHttpRequestFactory_create(self: *const T, __MIDL__IHTMLXMLHttpRequestFactory0000: **IHTMLXMLHttpRequest) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLXMLHttpRequestFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLXMLHttpRequestFactory, self), __MIDL__IHTMLXMLHttpRequestFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLXMLHttpRequest_Value = @import("../zig.zig").Guid.initString("3050F596-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLXMLHttpRequest = &IID_DispHTMLXMLHttpRequest_Value;
pub const DispHTMLXMLHttpRequest = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAngle_Value = @import("../zig.zig").Guid.initString("305104D3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAngle = &IID_ISVGAngle_Value;
pub const ISVGAngle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_unitType: fn(
            self: *const ISVGAngle,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unitType: fn(
            self: *const ISVGAngle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const ISVGAngle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const ISVGAngle,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_valueInSpecifiedUnits: fn(
            self: *const ISVGAngle,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_valueInSpecifiedUnits: fn(
            self: *const ISVGAngle,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_valueAsString: fn(
            self: *const ISVGAngle,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_valueAsString: fn(
            self: *const ISVGAngle,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        newValueSpecifiedUnits: fn(
            self: *const ISVGAngle,
            unitType: i16,
            valueInSpecifiedUnits: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        convertToSpecifiedUnits: fn(
            self: *const ISVGAngle,
            unitType: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_put_unitType(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).put_unitType(@ptrCast(*const ISVGAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_get_unitType(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).get_unitType(@ptrCast(*const ISVGAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_put_value(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).put_value(@ptrCast(*const ISVGAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_get_value(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).get_value(@ptrCast(*const ISVGAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_put_valueInSpecifiedUnits(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).put_valueInSpecifiedUnits(@ptrCast(*const ISVGAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_get_valueInSpecifiedUnits(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).get_valueInSpecifiedUnits(@ptrCast(*const ISVGAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_put_valueAsString(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).put_valueAsString(@ptrCast(*const ISVGAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_get_valueAsString(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).get_valueAsString(@ptrCast(*const ISVGAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_newValueSpecifiedUnits(self: *const T, unitType: i16, valueInSpecifiedUnits: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).newValueSpecifiedUnits(@ptrCast(*const ISVGAngle, self), unitType, valueInSpecifiedUnits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAngle_convertToSpecifiedUnits(self: *const T, unitType: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAngle.VTable, self.vtable).convertToSpecifiedUnits(@ptrCast(*const ISVGAngle, self), unitType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGElement_Value = @import("../zig.zig").Guid.initString("305104C5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGElement = &IID_ISVGElement_Value;
pub const ISVGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_xmlbase: fn(
            self: *const ISVGElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_xmlbase: fn(
            self: *const ISVGElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_ownerSVGElement: fn(
            self: *const ISVGElement,
            v: *ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ownerSVGElement: fn(
            self: *const ISVGElement,
            p: **ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_viewportElement: fn(
            self: *const ISVGElement,
            v: *ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_viewportElement: fn(
            self: *const ISVGElement,
            p: **ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_focusable: fn(
            self: *const ISVGElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_focusable: fn(
            self: *const ISVGElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_put_xmlbase(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).put_xmlbase(@ptrCast(*const ISVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_get_xmlbase(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).get_xmlbase(@ptrCast(*const ISVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_putref_ownerSVGElement(self: *const T, v: *ISVGSVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).putref_ownerSVGElement(@ptrCast(*const ISVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_get_ownerSVGElement(self: *const T, p: **ISVGSVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).get_ownerSVGElement(@ptrCast(*const ISVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_putref_viewportElement(self: *const T, v: *ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).putref_viewportElement(@ptrCast(*const ISVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_get_viewportElement(self: *const T, p: **ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).get_viewportElement(@ptrCast(*const ISVGElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_putref_focusable(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).putref_focusable(@ptrCast(*const ISVGElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElement_get_focusable(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElement.VTable, self.vtable).get_focusable(@ptrCast(*const ISVGElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGRect_Value = @import("../zig.zig").Guid.initString("305104D7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGRect = &IID_ISVGRect_Value;
pub const ISVGRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGRect,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGRect,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGRect,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGRect,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_width: fn(
            self: *const ISVGRect,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const ISVGRect,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const ISVGRect,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const ISVGRect,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).put_x(@ptrCast(*const ISVGRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).get_x(@ptrCast(*const ISVGRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).put_y(@ptrCast(*const ISVGRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).get_y(@ptrCast(*const ISVGRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_put_width(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).put_width(@ptrCast(*const ISVGRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_get_width(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).get_width(@ptrCast(*const ISVGRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_put_height(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).put_height(@ptrCast(*const ISVGRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRect_get_height(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRect.VTable, self.vtable).get_height(@ptrCast(*const ISVGRect, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGMatrix_Value = @import("../zig.zig").Guid.initString("305104F6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGMatrix = &IID_ISVGMatrix_Value;
pub const ISVGMatrix = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_a: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_a: fn(
            self: *const ISVGMatrix,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_b: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_b: fn(
            self: *const ISVGMatrix,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_c: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_c: fn(
            self: *const ISVGMatrix,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_d: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_d: fn(
            self: *const ISVGMatrix,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_e: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_e: fn(
            self: *const ISVGMatrix,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_f: fn(
            self: *const ISVGMatrix,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_f: fn(
            self: *const ISVGMatrix,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        multiply: fn(
            self: *const ISVGMatrix,
            secondMatrix: *ISVGMatrix,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        inverse: fn(
            self: *const ISVGMatrix,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        translate: fn(
            self: *const ISVGMatrix,
            x: f32,
            y: f32,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scale: fn(
            self: *const ISVGMatrix,
            scaleFactor: f32,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        scaleNonUniform: fn(
            self: *const ISVGMatrix,
            scaleFactorX: f32,
            scaleFactorY: f32,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rotate: fn(
            self: *const ISVGMatrix,
            angle: f32,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        rotateFromVector: fn(
            self: *const ISVGMatrix,
            x: f32,
            y: f32,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        flipX: fn(
            self: *const ISVGMatrix,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        flipY: fn(
            self: *const ISVGMatrix,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        skewX: fn(
            self: *const ISVGMatrix,
            angle: f32,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        skewY: fn(
            self: *const ISVGMatrix,
            angle: f32,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_a(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_a(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_a(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_a(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_b(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_b(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_b(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_b(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_c(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_c(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_c(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_c(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_d(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_d(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_d(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_d(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_e(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_e(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_e(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_e(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_put_f(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).put_f(@ptrCast(*const ISVGMatrix, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_get_f(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).get_f(@ptrCast(*const ISVGMatrix, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_multiply(self: *const T, secondMatrix: *ISVGMatrix, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).multiply(@ptrCast(*const ISVGMatrix, self), secondMatrix, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_inverse(self: *const T, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).inverse(@ptrCast(*const ISVGMatrix, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_translate(self: *const T, x: f32, y: f32, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).translate(@ptrCast(*const ISVGMatrix, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_scale(self: *const T, scaleFactor: f32, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).scale(@ptrCast(*const ISVGMatrix, self), scaleFactor, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_scaleNonUniform(self: *const T, scaleFactorX: f32, scaleFactorY: f32, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).scaleNonUniform(@ptrCast(*const ISVGMatrix, self), scaleFactorX, scaleFactorY, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_rotate(self: *const T, angle: f32, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).rotate(@ptrCast(*const ISVGMatrix, self), angle, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_rotateFromVector(self: *const T, x: f32, y: f32, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).rotateFromVector(@ptrCast(*const ISVGMatrix, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_flipX(self: *const T, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).flipX(@ptrCast(*const ISVGMatrix, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_flipY(self: *const T, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).flipY(@ptrCast(*const ISVGMatrix, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_skewX(self: *const T, angle: f32, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).skewX(@ptrCast(*const ISVGMatrix, self), angle, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMatrix_skewY(self: *const T, angle: f32, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMatrix.VTable, self.vtable).skewY(@ptrCast(*const ISVGMatrix, self), angle, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGStringList_Value = @import("../zig.zig").Guid.initString("305104C8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGStringList = &IID_ISVGStringList_Value;
pub const ISVGStringList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_numberOfItems: fn(
            self: *const ISVGStringList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_numberOfItems: fn(
            self: *const ISVGStringList,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGStringList,
            newItem: BSTR,
            ppResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGStringList,
            index: i32,
            ppResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGStringList,
            newItem: BSTR,
            index: i32,
            ppResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGStringList,
            newItem: BSTR,
            index: i32,
            ppResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGStringList,
            index: i32,
            ppResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGStringList,
            newItem: BSTR,
            ppResult: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGStringList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_get_numberOfItems(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGStringList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).clear(@ptrCast(*const ISVGStringList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_initialize(self: *const T, newItem: BSTR, ppResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).initialize(@ptrCast(*const ISVGStringList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_getItem(self: *const T, index: i32, ppResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).getItem(@ptrCast(*const ISVGStringList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_insertItemBefore(self: *const T, newItem: BSTR, index: i32, ppResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGStringList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_replaceItem(self: *const T, newItem: BSTR, index: i32, ppResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGStringList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_removeItem(self: *const T, index: i32, ppResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGStringList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStringList_appendItem(self: *const T, newItem: BSTR, ppResult: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStringList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGStringList, self), newItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedRect_Value = @import("../zig.zig").Guid.initString("305104D8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedRect = &IID_ISVGAnimatedRect_Value;
pub const ISVGAnimatedRect = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedRect,
            v: *ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedRect,
            p: **ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedRect,
            v: *ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedRect,
            p: **ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedRect_putref_baseVal(self: *const T, v: *ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedRect.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedRect_get_baseVal(self: *const T, p: **ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedRect.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedRect, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedRect_putref_animVal(self: *const T, v: *ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedRect.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedRect, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedRect_get_animVal(self: *const T, p: **ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedRect.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedRect, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedString_Value = @import("../zig.zig").Guid.initString("305104C7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedString = &IID_ISVGAnimatedString_Value;
pub const ISVGAnimatedString = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_baseVal: fn(
            self: *const ISVGAnimatedString,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedString,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedString,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedString_put_baseVal(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedString.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedString, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedString_get_baseVal(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedString.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedString, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedString_get_animVal(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedString.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedString, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedBoolean_Value = @import("../zig.zig").Guid.initString("305104C6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedBoolean = &IID_ISVGAnimatedBoolean_Value;
pub const ISVGAnimatedBoolean = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_baseVal: fn(
            self: *const ISVGAnimatedBoolean,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedBoolean,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animVal: fn(
            self: *const ISVGAnimatedBoolean,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedBoolean,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedBoolean_put_baseVal(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedBoolean.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedBoolean, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedBoolean_get_baseVal(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedBoolean.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedBoolean, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedBoolean_put_animVal(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedBoolean.VTable, self.vtable).put_animVal(@ptrCast(*const ISVGAnimatedBoolean, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedBoolean_get_animVal(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedBoolean.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedBoolean, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedTransformList_Value = @import("../zig.zig").Guid.initString("305104F9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedTransformList = &IID_ISVGAnimatedTransformList_Value;
pub const ISVGAnimatedTransformList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedTransformList,
            v: *ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedTransformList,
            p: **ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedTransformList,
            v: *ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedTransformList,
            p: **ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedTransformList_putref_baseVal(self: *const T, v: *ISVGTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedTransformList.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedTransformList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedTransformList_get_baseVal(self: *const T, p: **ISVGTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedTransformList.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedTransformList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedTransformList_putref_animVal(self: *const T, v: *ISVGTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedTransformList.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedTransformList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedTransformList_get_animVal(self: *const T, p: **ISVGTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedTransformList.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedTransformList, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedPreserveAspectRatio_Value = @import("../zig.zig").Guid.initString("305104FB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedPreserveAspectRatio = &IID_ISVGAnimatedPreserveAspectRatio_Value;
pub const ISVGAnimatedPreserveAspectRatio = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedPreserveAspectRatio,
            v: *ISVGPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedPreserveAspectRatio,
            p: **ISVGPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedPreserveAspectRatio,
            v: *ISVGPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedPreserveAspectRatio,
            p: **ISVGPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPreserveAspectRatio_putref_baseVal(self: *const T, v: *ISVGPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPreserveAspectRatio.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedPreserveAspectRatio, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPreserveAspectRatio_get_baseVal(self: *const T, p: **ISVGPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPreserveAspectRatio.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedPreserveAspectRatio, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPreserveAspectRatio_putref_animVal(self: *const T, v: *ISVGPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPreserveAspectRatio.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedPreserveAspectRatio, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPreserveAspectRatio_get_animVal(self: *const T, p: **ISVGPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPreserveAspectRatio.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedPreserveAspectRatio, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGStylable_Value = @import("../zig.zig").Guid.initString("305104DA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGStylable = &IID_ISVGStylable_Value;
pub const ISVGStylable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_className: fn(
            self: *const ISVGStylable,
            p: **ISVGAnimatedString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStylable_get_className(self: *const T, p: **ISVGAnimatedString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStylable.VTable, self.vtable).get_className(@ptrCast(*const ISVGStylable, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLocatable_Value = @import("../zig.zig").Guid.initString("305104DB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGLocatable = &IID_ISVGLocatable_Value;
pub const ISVGLocatable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_nearestViewportElement: fn(
            self: *const ISVGLocatable,
            p: **ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_farthestViewportElement: fn(
            self: *const ISVGLocatable,
            p: **ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getBBox: fn(
            self: *const ISVGLocatable,
            ppResult: **ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCTM: fn(
            self: *const ISVGLocatable,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getScreenCTM: fn(
            self: *const ISVGLocatable,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getTransformToElement: fn(
            self: *const ISVGLocatable,
            pElement: *ISVGElement,
            ppResult: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_get_nearestViewportElement(self: *const T, p: **ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).get_nearestViewportElement(@ptrCast(*const ISVGLocatable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_get_farthestViewportElement(self: *const T, p: **ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).get_farthestViewportElement(@ptrCast(*const ISVGLocatable, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_getBBox(self: *const T, ppResult: **ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).getBBox(@ptrCast(*const ISVGLocatable, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_getCTM(self: *const T, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).getCTM(@ptrCast(*const ISVGLocatable, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_getScreenCTM(self: *const T, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).getScreenCTM(@ptrCast(*const ISVGLocatable, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLocatable_getTransformToElement(self: *const T, pElement: *ISVGElement, ppResult: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLocatable.VTable, self.vtable).getTransformToElement(@ptrCast(*const ISVGLocatable, self), pElement, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTransformable_Value = @import("../zig.zig").Guid.initString("305104DC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTransformable = &IID_ISVGTransformable_Value;
pub const ISVGTransformable = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_transform: fn(
            self: *const ISVGTransformable,
            p: **ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformable_get_transform(self: *const T, p: **ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformable.VTable, self.vtable).get_transform(@ptrCast(*const ISVGTransformable, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTests_Value = @import("../zig.zig").Guid.initString("305104DD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTests = &IID_ISVGTests_Value;
pub const ISVGTests = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_requiredFeatures: fn(
            self: *const ISVGTests,
            p: **ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_requiredExtensions: fn(
            self: *const ISVGTests,
            p: **ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_systemLanguage: fn(
            self: *const ISVGTests,
            p: **ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasExtension: fn(
            self: *const ISVGTests,
            extension: BSTR,
            pResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTests_get_requiredFeatures(self: *const T, p: **ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTests.VTable, self.vtable).get_requiredFeatures(@ptrCast(*const ISVGTests, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTests_get_requiredExtensions(self: *const T, p: **ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTests.VTable, self.vtable).get_requiredExtensions(@ptrCast(*const ISVGTests, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTests_get_systemLanguage(self: *const T, p: **ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTests.VTable, self.vtable).get_systemLanguage(@ptrCast(*const ISVGTests, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTests_hasExtension(self: *const T, extension: BSTR, pResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTests.VTable, self.vtable).hasExtension(@ptrCast(*const ISVGTests, self), extension, pResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLangSpace_Value = @import("../zig.zig").Guid.initString("305104DE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGLangSpace = &IID_ISVGLangSpace_Value;
pub const ISVGLangSpace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_xmllang: fn(
            self: *const ISVGLangSpace,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_xmllang: fn(
            self: *const ISVGLangSpace,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_xmlspace: fn(
            self: *const ISVGLangSpace,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_xmlspace: fn(
            self: *const ISVGLangSpace,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLangSpace_put_xmllang(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLangSpace.VTable, self.vtable).put_xmllang(@ptrCast(*const ISVGLangSpace, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLangSpace_get_xmllang(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLangSpace.VTable, self.vtable).get_xmllang(@ptrCast(*const ISVGLangSpace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLangSpace_put_xmlspace(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLangSpace.VTable, self.vtable).put_xmlspace(@ptrCast(*const ISVGLangSpace, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLangSpace_get_xmlspace(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLangSpace.VTable, self.vtable).get_xmlspace(@ptrCast(*const ISVGLangSpace, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGExternalResourcesRequired_Value = @import("../zig.zig").Guid.initString("305104DF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGExternalResourcesRequired = &IID_ISVGExternalResourcesRequired_Value;
pub const ISVGExternalResourcesRequired = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_externalResourcesRequired: fn(
            self: *const ISVGExternalResourcesRequired,
            p: **ISVGAnimatedBoolean,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGExternalResourcesRequired_get_externalResourcesRequired(self: *const T, p: **ISVGAnimatedBoolean) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGExternalResourcesRequired.VTable, self.vtable).get_externalResourcesRequired(@ptrCast(*const ISVGExternalResourcesRequired, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGFitToViewBox_Value = @import("../zig.zig").Guid.initString("305104E0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGFitToViewBox = &IID_ISVGFitToViewBox_Value;
pub const ISVGFitToViewBox = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_viewBox: fn(
            self: *const ISVGFitToViewBox,
            p: **ISVGAnimatedRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_preserveAspectRatio: fn(
            self: *const ISVGFitToViewBox,
            v: *ISVGAnimatedPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_preserveAspectRatio: fn(
            self: *const ISVGFitToViewBox,
            p: **ISVGAnimatedPreserveAspectRatio,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGFitToViewBox_get_viewBox(self: *const T, p: **ISVGAnimatedRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGFitToViewBox.VTable, self.vtable).get_viewBox(@ptrCast(*const ISVGFitToViewBox, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGFitToViewBox_putref_preserveAspectRatio(self: *const T, v: *ISVGAnimatedPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGFitToViewBox.VTable, self.vtable).putref_preserveAspectRatio(@ptrCast(*const ISVGFitToViewBox, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGFitToViewBox_get_preserveAspectRatio(self: *const T, p: **ISVGAnimatedPreserveAspectRatio) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGFitToViewBox.VTable, self.vtable).get_preserveAspectRatio(@ptrCast(*const ISVGFitToViewBox, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGZoomAndPan_Value = @import("../zig.zig").Guid.initString("305104E1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGZoomAndPan = &IID_ISVGZoomAndPan_Value;
pub const ISVGZoomAndPan = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_zoomAndPan: fn(
            self: *const ISVGZoomAndPan,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomAndPan_get_zoomAndPan(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomAndPan.VTable, self.vtable).get_zoomAndPan(@ptrCast(*const ISVGZoomAndPan, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGURIReference_Value = @import("../zig.zig").Guid.initString("305104E3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGURIReference = &IID_ISVGURIReference_Value;
pub const ISVGURIReference = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_href: fn(
            self: *const ISVGURIReference,
            p: **ISVGAnimatedString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGURIReference_get_href(self: *const T, p: **ISVGAnimatedString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGURIReference.VTable, self.vtable).get_href(@ptrCast(*const ISVGURIReference, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedAngle_Value = @import("../zig.zig").Guid.initString("305104D4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedAngle = &IID_ISVGAnimatedAngle_Value;
pub const ISVGAnimatedAngle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedAngle,
            v: *ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedAngle,
            p: **ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedAngle,
            v: *ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedAngle,
            p: **ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedAngle_putref_baseVal(self: *const T, v: *ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedAngle.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedAngle_get_baseVal(self: *const T, p: **ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedAngle.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedAngle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedAngle_putref_animVal(self: *const T, v: *ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedAngle.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedAngle, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedAngle_get_animVal(self: *const T, p: **ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedAngle.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedAngle, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTransformList_Value = @import("../zig.zig").Guid.initString("305104F8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTransformList = &IID_ISVGTransformList_Value;
pub const ISVGTransformList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_numberOfItems: fn(
            self: *const ISVGTransformList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_numberOfItems: fn(
            self: *const ISVGTransformList,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGTransformList,
            newItem: *ISVGTransform,
            ppResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGTransformList,
            index: i32,
            ppResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGTransformList,
            newItem: *ISVGTransform,
            index: i32,
            ppResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGTransformList,
            newItem: *ISVGTransform,
            index: i32,
            ppResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGTransformList,
            index: i32,
            ppResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGTransformList,
            newItem: *ISVGTransform,
            ppResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGTransformFromMatrix: fn(
            self: *const ISVGTransformList,
            newItem: *ISVGMatrix,
            ppResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        consolidate: fn(
            self: *const ISVGTransformList,
            ppResult: **ISVGTransform,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGTransformList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_get_numberOfItems(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGTransformList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).clear(@ptrCast(*const ISVGTransformList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_initialize(self: *const T, newItem: *ISVGTransform, ppResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).initialize(@ptrCast(*const ISVGTransformList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_getItem(self: *const T, index: i32, ppResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).getItem(@ptrCast(*const ISVGTransformList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_insertItemBefore(self: *const T, newItem: *ISVGTransform, index: i32, ppResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGTransformList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_replaceItem(self: *const T, newItem: *ISVGTransform, index: i32, ppResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGTransformList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_removeItem(self: *const T, index: i32, ppResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGTransformList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_appendItem(self: *const T, newItem: *ISVGTransform, ppResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGTransformList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_createSVGTransformFromMatrix(self: *const T, newItem: *ISVGMatrix, ppResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).createSVGTransformFromMatrix(@ptrCast(*const ISVGTransformList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransformList_consolidate(self: *const T, ppResult: **ISVGTransform) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransformList.VTable, self.vtable).consolidate(@ptrCast(*const ISVGTransformList, self), ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedEnumeration_Value = @import("../zig.zig").Guid.initString("305104C9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedEnumeration = &IID_ISVGAnimatedEnumeration_Value;
pub const ISVGAnimatedEnumeration = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_baseVal: fn(
            self: *const ISVGAnimatedEnumeration,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedEnumeration,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animVal: fn(
            self: *const ISVGAnimatedEnumeration,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedEnumeration,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedEnumeration_put_baseVal(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedEnumeration.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedEnumeration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedEnumeration_get_baseVal(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedEnumeration.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedEnumeration, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedEnumeration_put_animVal(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedEnumeration.VTable, self.vtable).put_animVal(@ptrCast(*const ISVGAnimatedEnumeration, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedEnumeration_get_animVal(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedEnumeration.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedEnumeration, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedInteger_Value = @import("../zig.zig").Guid.initString("305104CA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedInteger = &IID_ISVGAnimatedInteger_Value;
pub const ISVGAnimatedInteger = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_baseVal: fn(
            self: *const ISVGAnimatedInteger,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedInteger,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animVal: fn(
            self: *const ISVGAnimatedInteger,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedInteger,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedInteger_put_baseVal(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedInteger.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedInteger, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedInteger_get_baseVal(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedInteger.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedInteger, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedInteger_put_animVal(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedInteger.VTable, self.vtable).put_animVal(@ptrCast(*const ISVGAnimatedInteger, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedInteger_get_animVal(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedInteger.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedInteger, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLength_Value = @import("../zig.zig").Guid.initString("305104CF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGLength = &IID_ISVGLength_Value;
pub const ISVGLength = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_unitType: fn(
            self: *const ISVGLength,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unitType: fn(
            self: *const ISVGLength,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_value: fn(
            self: *const ISVGLength,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const ISVGLength,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_valueInSpecifiedUnits: fn(
            self: *const ISVGLength,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_valueInSpecifiedUnits: fn(
            self: *const ISVGLength,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_valueAsString: fn(
            self: *const ISVGLength,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_valueAsString: fn(
            self: *const ISVGLength,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        newValueSpecifiedUnits: fn(
            self: *const ISVGLength,
            unitType: i16,
            valueInSpecifiedUnits: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        convertToSpecifiedUnits: fn(
            self: *const ISVGLength,
            unitType: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_put_unitType(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).put_unitType(@ptrCast(*const ISVGLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_get_unitType(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).get_unitType(@ptrCast(*const ISVGLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_put_value(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).put_value(@ptrCast(*const ISVGLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_get_value(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).get_value(@ptrCast(*const ISVGLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_put_valueInSpecifiedUnits(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).put_valueInSpecifiedUnits(@ptrCast(*const ISVGLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_get_valueInSpecifiedUnits(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).get_valueInSpecifiedUnits(@ptrCast(*const ISVGLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_put_valueAsString(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).put_valueAsString(@ptrCast(*const ISVGLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_get_valueAsString(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).get_valueAsString(@ptrCast(*const ISVGLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_newValueSpecifiedUnits(self: *const T, unitType: i16, valueInSpecifiedUnits: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).newValueSpecifiedUnits(@ptrCast(*const ISVGLength, self), unitType, valueInSpecifiedUnits);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLength_convertToSpecifiedUnits(self: *const T, unitType: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLength.VTable, self.vtable).convertToSpecifiedUnits(@ptrCast(*const ISVGLength, self), unitType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedLength_Value = @import("../zig.zig").Guid.initString("305104D0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedLength = &IID_ISVGAnimatedLength_Value;
pub const ISVGAnimatedLength = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedLength,
            v: *ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedLength,
            p: **ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedLength,
            v: *ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedLength,
            p: **ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLength_putref_baseVal(self: *const T, v: *ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLength.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLength_get_baseVal(self: *const T, p: **ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLength.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedLength, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLength_putref_animVal(self: *const T, v: *ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLength.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedLength, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLength_get_animVal(self: *const T, p: **ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLength.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedLength, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLengthList_Value = @import("../zig.zig").Guid.initString("305104D1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGLengthList = &IID_ISVGLengthList_Value;
pub const ISVGLengthList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_numberOfItems: fn(
            self: *const ISVGLengthList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_numberOfItems: fn(
            self: *const ISVGLengthList,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGLengthList,
            newItem: *ISVGLength,
            ppResult: **ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGLengthList,
            index: i32,
            ppResult: **ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGLengthList,
            newItem: *ISVGLength,
            index: i32,
            ppResult: **ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGLengthList,
            newItem: *ISVGLength,
            index: i32,
            ppResult: **ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGLengthList,
            index: i32,
            ppResult: **ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGLengthList,
            newItem: *ISVGLength,
            ppResult: **ISVGLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGLengthList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_get_numberOfItems(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGLengthList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).clear(@ptrCast(*const ISVGLengthList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_initialize(self: *const T, newItem: *ISVGLength, ppResult: **ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).initialize(@ptrCast(*const ISVGLengthList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_getItem(self: *const T, index: i32, ppResult: **ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).getItem(@ptrCast(*const ISVGLengthList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_insertItemBefore(self: *const T, newItem: *ISVGLength, index: i32, ppResult: **ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGLengthList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_replaceItem(self: *const T, newItem: *ISVGLength, index: i32, ppResult: **ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGLengthList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_removeItem(self: *const T, index: i32, ppResult: **ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGLengthList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLengthList_appendItem(self: *const T, newItem: *ISVGLength, ppResult: **ISVGLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLengthList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGLengthList, self), newItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedLengthList_Value = @import("../zig.zig").Guid.initString("305104D2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedLengthList = &IID_ISVGAnimatedLengthList_Value;
pub const ISVGAnimatedLengthList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedLengthList,
            v: *ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedLengthList,
            p: **ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedLengthList,
            v: *ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedLengthList,
            p: **ISVGLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLengthList_putref_baseVal(self: *const T, v: *ISVGLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLengthList.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedLengthList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLengthList_get_baseVal(self: *const T, p: **ISVGLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLengthList.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedLengthList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLengthList_putref_animVal(self: *const T, v: *ISVGLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLengthList.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedLengthList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedLengthList_get_animVal(self: *const T, p: **ISVGLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedLengthList.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedLengthList, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGNumber_Value = @import("../zig.zig").Guid.initString("305104CB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGNumber = &IID_ISVGNumber_Value;
pub const ISVGNumber = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_value: fn(
            self: *const ISVGNumber,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const ISVGNumber,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumber_put_value(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumber.VTable, self.vtable).put_value(@ptrCast(*const ISVGNumber, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumber_get_value(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumber.VTable, self.vtable).get_value(@ptrCast(*const ISVGNumber, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedNumber_Value = @import("../zig.zig").Guid.initString("305104CC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedNumber = &IID_ISVGAnimatedNumber_Value;
pub const ISVGAnimatedNumber = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_baseVal: fn(
            self: *const ISVGAnimatedNumber,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedNumber,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_animVal: fn(
            self: *const ISVGAnimatedNumber,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedNumber,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumber_put_baseVal(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumber.VTable, self.vtable).put_baseVal(@ptrCast(*const ISVGAnimatedNumber, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumber_get_baseVal(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumber.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedNumber, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumber_put_animVal(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumber.VTable, self.vtable).put_animVal(@ptrCast(*const ISVGAnimatedNumber, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumber_get_animVal(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumber.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedNumber, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGNumberList_Value = @import("../zig.zig").Guid.initString("305104CD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGNumberList = &IID_ISVGNumberList_Value;
pub const ISVGNumberList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_numberOfItems: fn(
            self: *const ISVGNumberList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_numberOfItems: fn(
            self: *const ISVGNumberList,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGNumberList,
            newItem: *ISVGNumber,
            ppResult: **ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGNumberList,
            index: i32,
            ppResult: **ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGNumberList,
            newItem: *ISVGNumber,
            index: i32,
            ppResult: **ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGNumberList,
            newItem: *ISVGNumber,
            index: i32,
            ppResult: **ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGNumberList,
            index: i32,
            ppResult: **ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGNumberList,
            newItem: *ISVGNumber,
            ppResult: **ISVGNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGNumberList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_get_numberOfItems(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGNumberList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).clear(@ptrCast(*const ISVGNumberList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_initialize(self: *const T, newItem: *ISVGNumber, ppResult: **ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).initialize(@ptrCast(*const ISVGNumberList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_getItem(self: *const T, index: i32, ppResult: **ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).getItem(@ptrCast(*const ISVGNumberList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_insertItemBefore(self: *const T, newItem: *ISVGNumber, index: i32, ppResult: **ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGNumberList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_replaceItem(self: *const T, newItem: *ISVGNumber, index: i32, ppResult: **ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGNumberList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_removeItem(self: *const T, index: i32, ppResult: **ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGNumberList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGNumberList_appendItem(self: *const T, newItem: *ISVGNumber, ppResult: **ISVGNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGNumberList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGNumberList, self), newItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedNumberList_Value = @import("../zig.zig").Guid.initString("305104CE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedNumberList = &IID_ISVGAnimatedNumberList_Value;
pub const ISVGAnimatedNumberList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_baseVal: fn(
            self: *const ISVGAnimatedNumberList,
            v: *ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseVal: fn(
            self: *const ISVGAnimatedNumberList,
            p: **ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animVal: fn(
            self: *const ISVGAnimatedNumberList,
            v: *ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animVal: fn(
            self: *const ISVGAnimatedNumberList,
            p: **ISVGNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumberList_putref_baseVal(self: *const T, v: *ISVGNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumberList.VTable, self.vtable).putref_baseVal(@ptrCast(*const ISVGAnimatedNumberList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumberList_get_baseVal(self: *const T, p: **ISVGNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumberList.VTable, self.vtable).get_baseVal(@ptrCast(*const ISVGAnimatedNumberList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumberList_putref_animVal(self: *const T, v: *ISVGNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumberList.VTable, self.vtable).putref_animVal(@ptrCast(*const ISVGAnimatedNumberList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedNumberList_get_animVal(self: *const T, p: **ISVGNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedNumberList.VTable, self.vtable).get_animVal(@ptrCast(*const ISVGAnimatedNumberList, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGClipPathElement_Value = @import("../zig.zig").Guid.initString("3051052D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGClipPathElement = &IID_ISVGClipPathElement_Value;
pub const ISVGClipPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_clipPathUnits: fn(
            self: *const ISVGClipPathElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_clipPathUnits: fn(
            self: *const ISVGClipPathElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGClipPathElement_putref_clipPathUnits(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGClipPathElement.VTable, self.vtable).putref_clipPathUnits(@ptrCast(*const ISVGClipPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGClipPathElement_get_clipPathUnits(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGClipPathElement.VTable, self.vtable).get_clipPathUnits(@ptrCast(*const ISVGClipPathElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGClipPathElement_Value = @import("../zig.zig").Guid.initString("3059003B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGClipPathElement = &IID_DispSVGClipPathElement_Value;
pub const DispSVGClipPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGDocument_Value = @import("../zig.zig").Guid.initString("305104E6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGDocument = &IID_ISVGDocument_Value;
pub const ISVGDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_rootElement: fn(
            self: *const ISVGDocument,
            p: **ISVGSVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGDocument_get_rootElement(self: *const T, p: **ISVGSVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGDocument.VTable, self.vtable).get_rootElement(@ptrCast(*const ISVGDocument, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IGetSVGDocument_Value = @import("../zig.zig").Guid.initString("305105AB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IGetSVGDocument = &IID_IGetSVGDocument_Value;
pub const IGetSVGDocument = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        getSVGDocument: fn(
            self: *const IGetSVGDocument,
            ppSVGDocument: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IGetSVGDocument_getSVGDocument(self: *const T, ppSVGDocument: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IGetSVGDocument.VTable, self.vtable).getSVGDocument(@ptrCast(*const IGetSVGDocument, self), ppSVGDocument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGElement_Value = @import("../zig.zig").Guid.initString("30590000-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGElement = &IID_DispSVGElement_Value;
pub const DispSVGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IICCSVGColor_Value = @import("../zig.zig").Guid.initString("305104D6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IICCSVGColor = &IID_IICCSVGColor_Value;
pub const IICCSVGColor = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPaint_Value = @import("../zig.zig").Guid.initString("30510524-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPaint = &IID_ISVGPaint_Value;
pub const ISVGPaint = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPatternElement_Value = @import("../zig.zig").Guid.initString("3051052C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPatternElement = &IID_ISVGPatternElement_Value;
pub const ISVGPatternElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_patternUnits: fn(
            self: *const ISVGPatternElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_patternUnits: fn(
            self: *const ISVGPatternElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_patternContentUnits: fn(
            self: *const ISVGPatternElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_patternContentUnits: fn(
            self: *const ISVGPatternElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_patternTransform: fn(
            self: *const ISVGPatternElement,
            v: *ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_patternTransform: fn(
            self: *const ISVGPatternElement,
            p: **ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_x: fn(
            self: *const ISVGPatternElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPatternElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGPatternElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPatternElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGPatternElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const ISVGPatternElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGPatternElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const ISVGPatternElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_patternUnits(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_patternUnits(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_patternUnits(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_patternUnits(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_patternContentUnits(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_patternContentUnits(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_patternContentUnits(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_patternContentUnits(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_patternTransform(self: *const T, v: *ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_patternTransform(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_patternTransform(self: *const T, p: **ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_patternTransform(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_x(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_x(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_y(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_y(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_width(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_width(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGPatternElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_putref_height(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGPatternElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPatternElement_get_height(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPatternElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGPatternElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPatternElement_Value = @import("../zig.zig").Guid.initString("3059002C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPatternElement = &IID_DispSVGPatternElement_Value;
pub const DispSVGPatternElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSeg_Value = @import("../zig.zig").Guid.initString("305104FC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSeg = &IID_ISVGPathSeg_Value;
pub const ISVGPathSeg = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_pathSegType: fn(
            self: *const ISVGPathSeg,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pathSegType: fn(
            self: *const ISVGPathSeg,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pathSegTypeAsLetter: fn(
            self: *const ISVGPathSeg,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSeg_put_pathSegType(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSeg.VTable, self.vtable).put_pathSegType(@ptrCast(*const ISVGPathSeg, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSeg_get_pathSegType(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSeg.VTable, self.vtable).get_pathSegType(@ptrCast(*const ISVGPathSeg, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSeg_get_pathSegTypeAsLetter(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSeg.VTable, self.vtable).get_pathSegTypeAsLetter(@ptrCast(*const ISVGPathSeg, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegArcAbs_Value = @import("../zig.zig").Guid.initString("30510506-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegArcAbs = &IID_ISVGPathSegArcAbs_Value;
pub const ISVGPathSegArcAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegArcAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegArcAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_r1: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_r1: fn(
            self: *const ISVGPathSegArcAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_r2: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_r2: fn(
            self: *const ISVGPathSegArcAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_angle: fn(
            self: *const ISVGPathSegArcAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_angle: fn(
            self: *const ISVGPathSegArcAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_largeArcFlag: fn(
            self: *const ISVGPathSegArcAbs,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_largeArcFlag: fn(
            self: *const ISVGPathSegArcAbs,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_sweepFlag: fn(
            self: *const ISVGPathSegArcAbs,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_sweepFlag: fn(
            self: *const ISVGPathSegArcAbs,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_r1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_r1(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_r1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_r1(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_r2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_r2(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_r2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_r2(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_angle(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_angle(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_angle(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_angle(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_largeArcFlag(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_largeArcFlag(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_largeArcFlag(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_largeArcFlag(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_put_sweepFlag(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).put_sweepFlag(@ptrCast(*const ISVGPathSegArcAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcAbs_get_sweepFlag(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcAbs.VTable, self.vtable).get_sweepFlag(@ptrCast(*const ISVGPathSegArcAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegArcRel_Value = @import("../zig.zig").Guid.initString("30510507-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegArcRel = &IID_ISVGPathSegArcRel_Value;
pub const ISVGPathSegArcRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegArcRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegArcRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_r1: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_r1: fn(
            self: *const ISVGPathSegArcRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_r2: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_r2: fn(
            self: *const ISVGPathSegArcRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_angle: fn(
            self: *const ISVGPathSegArcRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_angle: fn(
            self: *const ISVGPathSegArcRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_largeArcFlag: fn(
            self: *const ISVGPathSegArcRel,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_largeArcFlag: fn(
            self: *const ISVGPathSegArcRel,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_sweepFlag: fn(
            self: *const ISVGPathSegArcRel,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_sweepFlag: fn(
            self: *const ISVGPathSegArcRel,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_r1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_r1(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_r1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_r1(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_r2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_r2(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_r2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_r2(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_angle(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_angle(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_angle(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_angle(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_largeArcFlag(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_largeArcFlag(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_largeArcFlag(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_largeArcFlag(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_put_sweepFlag(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).put_sweepFlag(@ptrCast(*const ISVGPathSegArcRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegArcRel_get_sweepFlag(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegArcRel.VTable, self.vtable).get_sweepFlag(@ptrCast(*const ISVGPathSegArcRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegClosePath_Value = @import("../zig.zig").Guid.initString("305104FD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegClosePath = &IID_ISVGPathSegClosePath_Value;
pub const ISVGPathSegClosePath = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegMovetoAbs_Value = @import("../zig.zig").Guid.initString("305104FE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegMovetoAbs = &IID_ISVGPathSegMovetoAbs_Value;
pub const ISVGPathSegMovetoAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegMovetoAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegMovetoAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegMovetoAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegMovetoAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegMovetoAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoAbs_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegMovetoAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegMovetoAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoAbs_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegMovetoAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegMovetoRel_Value = @import("../zig.zig").Guid.initString("305104FF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegMovetoRel = &IID_ISVGPathSegMovetoRel_Value;
pub const ISVGPathSegMovetoRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegMovetoRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegMovetoRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegMovetoRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegMovetoRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegMovetoRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoRel_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegMovetoRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegMovetoRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegMovetoRel_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegMovetoRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegMovetoRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoAbs_Value = @import("../zig.zig").Guid.initString("30510500-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegLinetoAbs = &IID_ISVGPathSegLinetoAbs_Value;
pub const ISVGPathSegLinetoAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegLinetoAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegLinetoAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegLinetoAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegLinetoAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegLinetoAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoAbs_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegLinetoAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegLinetoAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoAbs_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegLinetoAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoRel_Value = @import("../zig.zig").Guid.initString("30510501-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegLinetoRel = &IID_ISVGPathSegLinetoRel_Value;
pub const ISVGPathSegLinetoRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegLinetoRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegLinetoRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegLinetoRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegLinetoRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegLinetoRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoRel_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegLinetoRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegLinetoRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoRel_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegLinetoRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoCubicAbs_Value = @import("../zig.zig").Guid.initString("30510502-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegCurvetoCubicAbs = &IID_ISVGPathSegCurvetoCubicAbs_Value;
pub const ISVGPathSegCurvetoCubicAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_x1: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x1: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y1: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y1: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_x2: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x2: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y2: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y2: fn(
            self: *const ISVGPathSegCurvetoCubicAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_x1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_x1(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_x1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_x1(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_y1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_y1(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_y1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_y1(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_x2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_x2(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_x2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_x2(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_put_y2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).put_y2(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicAbs_get_y2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicAbs.VTable, self.vtable).get_y2(@ptrCast(*const ISVGPathSegCurvetoCubicAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoCubicRel_Value = @import("../zig.zig").Guid.initString("30510503-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegCurvetoCubicRel = &IID_ISVGPathSegCurvetoCubicRel_Value;
pub const ISVGPathSegCurvetoCubicRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_x1: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x1: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y1: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y1: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_x2: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x2: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y2: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y2: fn(
            self: *const ISVGPathSegCurvetoCubicRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_x1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_x1(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_x1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_x1(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_y1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_y1(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_y1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_y1(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_x2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_x2(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_x2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_x2(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_put_y2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).put_y2(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicRel_get_y2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicRel.VTable, self.vtable).get_y2(@ptrCast(*const ISVGPathSegCurvetoCubicRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoCubicSmoothAbs_Value = @import("../zig.zig").Guid.initString("3051050C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegCurvetoCubicSmoothAbs = &IID_ISVGPathSegCurvetoCubicSmoothAbs_Value;
pub const ISVGPathSegCurvetoCubicSmoothAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_x2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_put_x2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).put_x2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_get_x2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).get_x2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_put_y2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).put_y2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothAbs_get_y2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs.VTable, self.vtable).get_y2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoCubicSmoothRel_Value = @import("../zig.zig").Guid.initString("3051050D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegCurvetoCubicSmoothRel = &IID_ISVGPathSegCurvetoCubicSmoothRel_Value;
pub const ISVGPathSegCurvetoCubicSmoothRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_x2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y2: fn(
            self: *const ISVGPathSegCurvetoCubicSmoothRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_put_x2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).put_x2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_get_x2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).get_x2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_put_y2(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).put_y2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoCubicSmoothRel_get_y2(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel.VTable, self.vtable).get_y2(@ptrCast(*const ISVGPathSegCurvetoCubicSmoothRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoQuadraticAbs_Value = @import("../zig.zig").Guid.initString("30510504-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegCurvetoQuadraticAbs = &IID_ISVGPathSegCurvetoQuadraticAbs_Value;
pub const ISVGPathSegCurvetoQuadraticAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_x1: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x1: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y1: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y1: fn(
            self: *const ISVGPathSegCurvetoQuadraticAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_put_x1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).put_x1(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_get_x1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).get_x1(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_put_y1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).put_y1(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticAbs_get_y1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticAbs.VTable, self.vtable).get_y1(@ptrCast(*const ISVGPathSegCurvetoQuadraticAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoQuadraticRel_Value = @import("../zig.zig").Guid.initString("30510505-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegCurvetoQuadraticRel = &IID_ISVGPathSegCurvetoQuadraticRel_Value;
pub const ISVGPathSegCurvetoQuadraticRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_x1: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x1: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y1: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y1: fn(
            self: *const ISVGPathSegCurvetoQuadraticRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_put_x1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).put_x1(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_get_x1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).get_x1(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_put_y1(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).put_y1(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticRel_get_y1(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticRel.VTable, self.vtable).get_y1(@ptrCast(*const ISVGPathSegCurvetoQuadraticRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoQuadraticSmoothAbs_Value = @import("../zig.zig").Guid.initString("3051050E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegCurvetoQuadraticSmoothAbs = &IID_ISVGPathSegCurvetoQuadraticSmoothAbs_Value;
pub const ISVGPathSegCurvetoQuadraticSmoothAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothAbs_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothAbs_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegCurvetoQuadraticSmoothRel_Value = @import("../zig.zig").Guid.initString("3051050F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegCurvetoQuadraticSmoothRel = &IID_ISVGPathSegCurvetoQuadraticSmoothRel_Value;
pub const ISVGPathSegCurvetoQuadraticSmoothRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegCurvetoQuadraticSmoothRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothRel_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegCurvetoQuadraticSmoothRel_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegCurvetoQuadraticSmoothRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoHorizontalAbs_Value = @import("../zig.zig").Guid.initString("30510508-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegLinetoHorizontalAbs = &IID_ISVGPathSegLinetoHorizontalAbs_Value;
pub const ISVGPathSegLinetoHorizontalAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegLinetoHorizontalAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegLinetoHorizontalAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoHorizontalAbs_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoHorizontalAbs.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegLinetoHorizontalAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoHorizontalAbs_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoHorizontalAbs.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegLinetoHorizontalAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoHorizontalRel_Value = @import("../zig.zig").Guid.initString("30510509-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegLinetoHorizontalRel = &IID_ISVGPathSegLinetoHorizontalRel_Value;
pub const ISVGPathSegLinetoHorizontalRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPathSegLinetoHorizontalRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPathSegLinetoHorizontalRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoHorizontalRel_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoHorizontalRel.VTable, self.vtable).put_x(@ptrCast(*const ISVGPathSegLinetoHorizontalRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoHorizontalRel_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoHorizontalRel.VTable, self.vtable).get_x(@ptrCast(*const ISVGPathSegLinetoHorizontalRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoVerticalAbs_Value = @import("../zig.zig").Guid.initString("3051050A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegLinetoVerticalAbs = &IID_ISVGPathSegLinetoVerticalAbs_Value;
pub const ISVGPathSegLinetoVerticalAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_y: fn(
            self: *const ISVGPathSegLinetoVerticalAbs,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegLinetoVerticalAbs,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoVerticalAbs_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoVerticalAbs.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegLinetoVerticalAbs, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoVerticalAbs_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoVerticalAbs.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegLinetoVerticalAbs, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegLinetoVerticalRel_Value = @import("../zig.zig").Guid.initString("3051050B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegLinetoVerticalRel = &IID_ISVGPathSegLinetoVerticalRel_Value;
pub const ISVGPathSegLinetoVerticalRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_y: fn(
            self: *const ISVGPathSegLinetoVerticalRel,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPathSegLinetoVerticalRel,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoVerticalRel_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoVerticalRel.VTable, self.vtable).put_y(@ptrCast(*const ISVGPathSegLinetoVerticalRel, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegLinetoVerticalRel_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegLinetoVerticalRel.VTable, self.vtable).get_y(@ptrCast(*const ISVGPathSegLinetoVerticalRel, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegArcAbs_Value = @import("../zig.zig").Guid.initString("30590013-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegArcAbs = &IID_DispSVGPathSegArcAbs_Value;
pub const DispSVGPathSegArcAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegArcRel_Value = @import("../zig.zig").Guid.initString("30590014-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegArcRel = &IID_DispSVGPathSegArcRel_Value;
pub const DispSVGPathSegArcRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegClosePath_Value = @import("../zig.zig").Guid.initString("30590015-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegClosePath = &IID_DispSVGPathSegClosePath_Value;
pub const DispSVGPathSegClosePath = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegMovetoAbs_Value = @import("../zig.zig").Guid.initString("30590024-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegMovetoAbs = &IID_DispSVGPathSegMovetoAbs_Value;
pub const DispSVGPathSegMovetoAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegMovetoRel_Value = @import("../zig.zig").Guid.initString("30590025-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegMovetoRel = &IID_DispSVGPathSegMovetoRel_Value;
pub const DispSVGPathSegMovetoRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoAbs_Value = @import("../zig.zig").Guid.initString("3059001E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegLinetoAbs = &IID_DispSVGPathSegLinetoAbs_Value;
pub const DispSVGPathSegLinetoAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoRel_Value = @import("../zig.zig").Guid.initString("30590021-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegLinetoRel = &IID_DispSVGPathSegLinetoRel_Value;
pub const DispSVGPathSegLinetoRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoCubicAbs_Value = @import("../zig.zig").Guid.initString("30590016-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegCurvetoCubicAbs = &IID_DispSVGPathSegCurvetoCubicAbs_Value;
pub const DispSVGPathSegCurvetoCubicAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoCubicRel_Value = @import("../zig.zig").Guid.initString("30590017-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegCurvetoCubicRel = &IID_DispSVGPathSegCurvetoCubicRel_Value;
pub const DispSVGPathSegCurvetoCubicRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoCubicSmoothAbs_Value = @import("../zig.zig").Guid.initString("30590018-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegCurvetoCubicSmoothAbs = &IID_DispSVGPathSegCurvetoCubicSmoothAbs_Value;
pub const DispSVGPathSegCurvetoCubicSmoothAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoCubicSmoothRel_Value = @import("../zig.zig").Guid.initString("30590019-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegCurvetoCubicSmoothRel = &IID_DispSVGPathSegCurvetoCubicSmoothRel_Value;
pub const DispSVGPathSegCurvetoCubicSmoothRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoQuadraticAbs_Value = @import("../zig.zig").Guid.initString("3059001A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegCurvetoQuadraticAbs = &IID_DispSVGPathSegCurvetoQuadraticAbs_Value;
pub const DispSVGPathSegCurvetoQuadraticAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoQuadraticRel_Value = @import("../zig.zig").Guid.initString("3059001B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegCurvetoQuadraticRel = &IID_DispSVGPathSegCurvetoQuadraticRel_Value;
pub const DispSVGPathSegCurvetoQuadraticRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoQuadraticSmoothAbs_Value = @import("../zig.zig").Guid.initString("3059001C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegCurvetoQuadraticSmoothAbs = &IID_DispSVGPathSegCurvetoQuadraticSmoothAbs_Value;
pub const DispSVGPathSegCurvetoQuadraticSmoothAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegCurvetoQuadraticSmoothRel_Value = @import("../zig.zig").Guid.initString("3059001D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegCurvetoQuadraticSmoothRel = &IID_DispSVGPathSegCurvetoQuadraticSmoothRel_Value;
pub const DispSVGPathSegCurvetoQuadraticSmoothRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoHorizontalAbs_Value = @import("../zig.zig").Guid.initString("3059001F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegLinetoHorizontalAbs = &IID_DispSVGPathSegLinetoHorizontalAbs_Value;
pub const DispSVGPathSegLinetoHorizontalAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoHorizontalRel_Value = @import("../zig.zig").Guid.initString("30590020-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegLinetoHorizontalRel = &IID_DispSVGPathSegLinetoHorizontalRel_Value;
pub const DispSVGPathSegLinetoHorizontalRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoVerticalAbs_Value = @import("../zig.zig").Guid.initString("30590022-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegLinetoVerticalAbs = &IID_DispSVGPathSegLinetoVerticalAbs_Value;
pub const DispSVGPathSegLinetoVerticalAbs = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathSegLinetoVerticalRel_Value = @import("../zig.zig").Guid.initString("30590023-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathSegLinetoVerticalRel = &IID_DispSVGPathSegLinetoVerticalRel_Value;
pub const DispSVGPathSegLinetoVerticalRel = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathSegList_Value = @import("../zig.zig").Guid.initString("30510510-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathSegList = &IID_ISVGPathSegList_Value;
pub const ISVGPathSegList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_numberOfItems: fn(
            self: *const ISVGPathSegList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_numberOfItems: fn(
            self: *const ISVGPathSegList,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGPathSegList,
            newItem: *ISVGPathSeg,
            ppResult: **ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGPathSegList,
            index: i32,
            ppResult: **ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGPathSegList,
            newItem: *ISVGPathSeg,
            index: i32,
            ppResult: **ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGPathSegList,
            newItem: *ISVGPathSeg,
            index: i32,
            ppResult: **ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGPathSegList,
            index: i32,
            ppResult: **ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGPathSegList,
            newItem: *ISVGPathSeg,
            ppResult: **ISVGPathSeg,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGPathSegList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_get_numberOfItems(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGPathSegList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).clear(@ptrCast(*const ISVGPathSegList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_initialize(self: *const T, newItem: *ISVGPathSeg, ppResult: **ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).initialize(@ptrCast(*const ISVGPathSegList, self), newItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_getItem(self: *const T, index: i32, ppResult: **ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).getItem(@ptrCast(*const ISVGPathSegList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_insertItemBefore(self: *const T, newItem: *ISVGPathSeg, index: i32, ppResult: **ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGPathSegList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_replaceItem(self: *const T, newItem: *ISVGPathSeg, index: i32, ppResult: **ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGPathSegList, self), newItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_removeItem(self: *const T, index: i32, ppResult: **ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGPathSegList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathSegList_appendItem(self: *const T, newItem: *ISVGPathSeg, ppResult: **ISVGPathSeg) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathSegList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGPathSegList, self), newItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPoint_Value = @import("../zig.zig").Guid.initString("305104F4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPoint = &IID_ISVGPoint_Value;
pub const ISVGPoint = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_x: fn(
            self: *const ISVGPoint,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGPoint,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_y: fn(
            self: *const ISVGPoint,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGPoint,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        matrixTransform: fn(
            self: *const ISVGPoint,
            pMatrix: *ISVGMatrix,
            ppResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_put_x(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).put_x(@ptrCast(*const ISVGPoint, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_get_x(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).get_x(@ptrCast(*const ISVGPoint, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_put_y(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).put_y(@ptrCast(*const ISVGPoint, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_get_y(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).get_y(@ptrCast(*const ISVGPoint, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPoint_matrixTransform(self: *const T, pMatrix: *ISVGMatrix, ppResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPoint.VTable, self.vtable).matrixTransform(@ptrCast(*const ISVGPoint, self), pMatrix, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPointList_Value = @import("../zig.zig").Guid.initString("305104F5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPointList = &IID_ISVGPointList_Value;
pub const ISVGPointList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_numberOfItems: fn(
            self: *const ISVGPointList,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_numberOfItems: fn(
            self: *const ISVGPointList,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clear: fn(
            self: *const ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initialize: fn(
            self: *const ISVGPointList,
            pNewItem: *ISVGPoint,
            ppResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getItem: fn(
            self: *const ISVGPointList,
            index: i32,
            ppResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        insertItemBefore: fn(
            self: *const ISVGPointList,
            pNewItem: *ISVGPoint,
            index: i32,
            ppResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        replaceItem: fn(
            self: *const ISVGPointList,
            pNewItem: *ISVGPoint,
            index: i32,
            ppResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        removeItem: fn(
            self: *const ISVGPointList,
            index: i32,
            ppResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        appendItem: fn(
            self: *const ISVGPointList,
            pNewItem: *ISVGPoint,
            ppResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_put_numberOfItems(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).put_numberOfItems(@ptrCast(*const ISVGPointList, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_get_numberOfItems(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).get_numberOfItems(@ptrCast(*const ISVGPointList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_clear(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).clear(@ptrCast(*const ISVGPointList, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_initialize(self: *const T, pNewItem: *ISVGPoint, ppResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).initialize(@ptrCast(*const ISVGPointList, self), pNewItem, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_getItem(self: *const T, index: i32, ppResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).getItem(@ptrCast(*const ISVGPointList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_insertItemBefore(self: *const T, pNewItem: *ISVGPoint, index: i32, ppResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).insertItemBefore(@ptrCast(*const ISVGPointList, self), pNewItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_replaceItem(self: *const T, pNewItem: *ISVGPoint, index: i32, ppResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).replaceItem(@ptrCast(*const ISVGPointList, self), pNewItem, index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_removeItem(self: *const T, index: i32, ppResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).removeItem(@ptrCast(*const ISVGPointList, self), index, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPointList_appendItem(self: *const T, pNewItem: *ISVGPoint, ppResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPointList.VTable, self.vtable).appendItem(@ptrCast(*const ISVGPointList, self), pNewItem, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGViewSpec_Value = @import("../zig.zig").Guid.initString("305104E2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGViewSpec = &IID_ISVGViewSpec_Value;
pub const ISVGViewSpec = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTransform_Value = @import("../zig.zig").Guid.initString("305104F7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTransform = &IID_ISVGTransform_Value;
pub const ISVGTransform = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_type: fn(
            self: *const ISVGTransform,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const ISVGTransform,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_matrix: fn(
            self: *const ISVGTransform,
            v: *ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_matrix: fn(
            self: *const ISVGTransform,
            p: **ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_angle: fn(
            self: *const ISVGTransform,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_angle: fn(
            self: *const ISVGTransform,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setMatrix: fn(
            self: *const ISVGTransform,
            matrix: *ISVGMatrix,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setTranslate: fn(
            self: *const ISVGTransform,
            tx: f32,
            ty: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setScale: fn(
            self: *const ISVGTransform,
            sx: f32,
            sy: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setRotate: fn(
            self: *const ISVGTransform,
            angle: f32,
            cx: f32,
            cy: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setSkewX: fn(
            self: *const ISVGTransform,
            angle: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setSkewY: fn(
            self: *const ISVGTransform,
            angle: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_put_type(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).put_type(@ptrCast(*const ISVGTransform, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_get_type(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).get_type(@ptrCast(*const ISVGTransform, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_putref_matrix(self: *const T, v: *ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).putref_matrix(@ptrCast(*const ISVGTransform, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_get_matrix(self: *const T, p: **ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).get_matrix(@ptrCast(*const ISVGTransform, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_put_angle(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).put_angle(@ptrCast(*const ISVGTransform, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_get_angle(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).get_angle(@ptrCast(*const ISVGTransform, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setMatrix(self: *const T, matrix: *ISVGMatrix) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setMatrix(@ptrCast(*const ISVGTransform, self), matrix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setTranslate(self: *const T, tx: f32, ty: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setTranslate(@ptrCast(*const ISVGTransform, self), tx, ty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setScale(self: *const T, sx: f32, sy: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setScale(@ptrCast(*const ISVGTransform, self), sx, sy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setRotate(self: *const T, angle: f32, cx: f32, cy: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setRotate(@ptrCast(*const ISVGTransform, self), angle, cx, cy);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setSkewX(self: *const T, angle: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setSkewX(@ptrCast(*const ISVGTransform, self), angle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTransform_setSkewY(self: *const T, angle: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTransform.VTable, self.vtable).setSkewY(@ptrCast(*const ISVGTransform, self), angle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGSVGElement_Value = @import("../zig.zig").Guid.initString("30590001-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGSVGElement = &IID_DispSVGSVGElement_Value;
pub const DispSVGSVGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGElementInstance_Value = @import("../zig.zig").Guid.initString("305104EE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGElementInstance = &IID_ISVGElementInstance_Value;
pub const ISVGElementInstance = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_correspondingElement: fn(
            self: *const ISVGElementInstance,
            p: **ISVGElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_correspondingUseElement: fn(
            self: *const ISVGElementInstance,
            p: **ISVGUseElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_parentNode: fn(
            self: *const ISVGElementInstance,
            p: **ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_childNodes: fn(
            self: *const ISVGElementInstance,
            p: **ISVGElementInstanceList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_firstChild: fn(
            self: *const ISVGElementInstance,
            p: **ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lastChild: fn(
            self: *const ISVGElementInstance,
            p: **ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_previousSibling: fn(
            self: *const ISVGElementInstance,
            p: **ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_nextSibling: fn(
            self: *const ISVGElementInstance,
            p: **ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_correspondingElement(self: *const T, p: **ISVGElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_correspondingElement(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_correspondingUseElement(self: *const T, p: **ISVGUseElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_correspondingUseElement(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_parentNode(self: *const T, p: **ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_parentNode(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_childNodes(self: *const T, p: **ISVGElementInstanceList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_childNodes(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_firstChild(self: *const T, p: **ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_firstChild(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_lastChild(self: *const T, p: **ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_lastChild(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_previousSibling(self: *const T, p: **ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_previousSibling(@ptrCast(*const ISVGElementInstance, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstance_get_nextSibling(self: *const T, p: **ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstance.VTable, self.vtable).get_nextSibling(@ptrCast(*const ISVGElementInstance, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGUseElement_Value = @import("../zig.zig").Guid.initString("305104ED-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGUseElement = &IID_ISVGUseElement_Value;
pub const ISVGUseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGUseElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGUseElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGUseElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGUseElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGUseElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const ISVGUseElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGUseElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const ISVGUseElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_instanceRoot: fn(
            self: *const ISVGUseElement,
            v: *ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_instanceRoot: fn(
            self: *const ISVGUseElement,
            p: **ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animatedInstanceRoot: fn(
            self: *const ISVGUseElement,
            v: *ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animatedInstanceRoot: fn(
            self: *const ISVGUseElement,
            p: **ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_x(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_x(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_y(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_y(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_width(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_width(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_height(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_height(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_instanceRoot(self: *const T, v: *ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_instanceRoot(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_instanceRoot(self: *const T, p: **ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_instanceRoot(@ptrCast(*const ISVGUseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_putref_animatedInstanceRoot(self: *const T, v: *ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).putref_animatedInstanceRoot(@ptrCast(*const ISVGUseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGUseElement_get_animatedInstanceRoot(self: *const T, p: **ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGUseElement.VTable, self.vtable).get_animatedInstanceRoot(@ptrCast(*const ISVGUseElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGUseElement_Value = @import("../zig.zig").Guid.initString("30590010-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGUseElement = &IID_DispSVGUseElement_Value;
pub const DispSVGUseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLStyleSheetRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("305104C0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLStyleSheetRulesAppliedCollection = &IID_IHTMLStyleSheetRulesAppliedCollection_Value;
pub const IHTMLStyleSheetRulesAppliedCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        item: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            index: i32,
            ppHTMLStyleSheetRule: **IHTMLStyleSheetRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_length: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyAppliedBy: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            name: BSTR,
            ppRule: **IHTMLStyleSheetRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyAppliedTrace: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            name: BSTR,
            index: i32,
            ppRule: **IHTMLStyleSheetRule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyAppliedTraceLength: fn(
            self: *const IHTMLStyleSheetRulesAppliedCollection,
            name: BSTR,
            pLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_item(self: *const T, index: i32, ppHTMLStyleSheetRule: **IHTMLStyleSheetRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), index, ppHTMLStyleSheetRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_propertyAppliedBy(self: *const T, name: BSTR, ppRule: **IHTMLStyleSheetRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).propertyAppliedBy(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), name, ppRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_propertyAppliedTrace(self: *const T, name: BSTR, index: i32, ppRule: **IHTMLStyleSheetRule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).propertyAppliedTrace(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), name, index, ppRule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLStyleSheetRulesAppliedCollection_propertyAppliedTraceLength(self: *const T, name: BSTR, pLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLStyleSheetRulesAppliedCollection.VTable, self.vtable).propertyAppliedTraceLength(@ptrCast(*const IHTMLStyleSheetRulesAppliedCollection, self), name, pLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRulesApplied_Value = @import("../zig.zig").Guid.initString("305104BF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IRulesApplied = &IID_IRulesApplied_Value;
pub const IRulesApplied = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_element: fn(
            self: *const IRulesApplied,
            p: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_inlineStyles: fn(
            self: *const IRulesApplied,
            p: **IHTMLStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_appliedRules: fn(
            self: *const IRulesApplied,
            p: **IHTMLStyleSheetRulesAppliedCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyIsInline: fn(
            self: *const IRulesApplied,
            name: BSTR,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        propertyIsInheritable: fn(
            self: *const IRulesApplied,
            name: BSTR,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hasInheritableProperty: fn(
            self: *const IRulesApplied,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_get_element(self: *const T, p: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).get_element(@ptrCast(*const IRulesApplied, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_get_inlineStyles(self: *const T, p: **IHTMLStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).get_inlineStyles(@ptrCast(*const IRulesApplied, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_get_appliedRules(self: *const T, p: **IHTMLStyleSheetRulesAppliedCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).get_appliedRules(@ptrCast(*const IRulesApplied, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_propertyIsInline(self: *const T, name: BSTR, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).propertyIsInline(@ptrCast(*const IRulesApplied, self), name, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_propertyIsInheritable(self: *const T, name: BSTR, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).propertyIsInheritable(@ptrCast(*const IRulesApplied, self), name, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRulesApplied_hasInheritableProperty(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRulesApplied.VTable, self.vtable).hasInheritableProperty(@ptrCast(*const IRulesApplied, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLStyleSheetRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("3050F5A6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLStyleSheetRulesAppliedCollection = &IID_DispHTMLStyleSheetRulesAppliedCollection_Value;
pub const DispHTMLStyleSheetRulesAppliedCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispRulesApplied_Value = @import("../zig.zig").Guid.initString("3050F5A5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispRulesApplied = &IID_DispRulesApplied_Value;
pub const DispRulesApplied = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispRulesAppliedCollection_Value = @import("../zig.zig").Guid.initString("3050F5A4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispRulesAppliedCollection = &IID_DispRulesAppliedCollection_Value;
pub const DispRulesAppliedCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLW3CComputedStyle_Value = @import("../zig.zig").Guid.initString("30590070-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLW3CComputedStyle = &IID_DispHTMLW3CComputedStyle_Value;
pub const DispHTMLW3CComputedStyle = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedPoints_Value = @import("../zig.zig").Guid.initString("30510517-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedPoints = &IID_ISVGAnimatedPoints_Value;
pub const ISVGAnimatedPoints = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_points: fn(
            self: *const ISVGAnimatedPoints,
            v: *ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_points: fn(
            self: *const ISVGAnimatedPoints,
            p: **ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animatedPoints: fn(
            self: *const ISVGAnimatedPoints,
            v: *ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animatedPoints: fn(
            self: *const ISVGAnimatedPoints,
            p: **ISVGPointList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPoints_putref_points(self: *const T, v: *ISVGPointList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPoints.VTable, self.vtable).putref_points(@ptrCast(*const ISVGAnimatedPoints, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPoints_get_points(self: *const T, p: **ISVGPointList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPoints.VTable, self.vtable).get_points(@ptrCast(*const ISVGAnimatedPoints, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPoints_putref_animatedPoints(self: *const T, v: *ISVGPointList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPoints.VTable, self.vtable).putref_animatedPoints(@ptrCast(*const ISVGAnimatedPoints, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPoints_get_animatedPoints(self: *const T, p: **ISVGPointList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPoints.VTable, self.vtable).get_animatedPoints(@ptrCast(*const ISVGAnimatedPoints, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGCircleElement_Value = @import("../zig.zig").Guid.initString("30510514-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGCircleElement = &IID_ISVGCircleElement_Value;
pub const ISVGCircleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_cx: fn(
            self: *const ISVGCircleElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cx: fn(
            self: *const ISVGCircleElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_cy: fn(
            self: *const ISVGCircleElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cy: fn(
            self: *const ISVGCircleElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_r: fn(
            self: *const ISVGCircleElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_r: fn(
            self: *const ISVGCircleElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_putref_cx(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).putref_cx(@ptrCast(*const ISVGCircleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_get_cx(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).get_cx(@ptrCast(*const ISVGCircleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_putref_cy(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).putref_cy(@ptrCast(*const ISVGCircleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_get_cy(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).get_cy(@ptrCast(*const ISVGCircleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_putref_r(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).putref_r(@ptrCast(*const ISVGCircleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGCircleElement_get_r(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGCircleElement.VTable, self.vtable).get_r(@ptrCast(*const ISVGCircleElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGEllipseElement_Value = @import("../zig.zig").Guid.initString("30510515-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGEllipseElement = &IID_ISVGEllipseElement_Value;
pub const ISVGEllipseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_cx: fn(
            self: *const ISVGEllipseElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cx: fn(
            self: *const ISVGEllipseElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_cy: fn(
            self: *const ISVGEllipseElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cy: fn(
            self: *const ISVGEllipseElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_rx: fn(
            self: *const ISVGEllipseElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rx: fn(
            self: *const ISVGEllipseElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_ry: fn(
            self: *const ISVGEllipseElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ry: fn(
            self: *const ISVGEllipseElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_putref_cx(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).putref_cx(@ptrCast(*const ISVGEllipseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_get_cx(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).get_cx(@ptrCast(*const ISVGEllipseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_putref_cy(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).putref_cy(@ptrCast(*const ISVGEllipseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_get_cy(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).get_cy(@ptrCast(*const ISVGEllipseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_putref_rx(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).putref_rx(@ptrCast(*const ISVGEllipseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_get_rx(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).get_rx(@ptrCast(*const ISVGEllipseElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_putref_ry(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).putref_ry(@ptrCast(*const ISVGEllipseElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGEllipseElement_get_ry(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGEllipseElement.VTable, self.vtable).get_ry(@ptrCast(*const ISVGEllipseElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLineElement_Value = @import("../zig.zig").Guid.initString("30510516-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGLineElement = &IID_ISVGLineElement_Value;
pub const ISVGLineElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x1: fn(
            self: *const ISVGLineElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x1: fn(
            self: *const ISVGLineElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y1: fn(
            self: *const ISVGLineElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y1: fn(
            self: *const ISVGLineElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_x2: fn(
            self: *const ISVGLineElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x2: fn(
            self: *const ISVGLineElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y2: fn(
            self: *const ISVGLineElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y2: fn(
            self: *const ISVGLineElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_putref_x1(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).putref_x1(@ptrCast(*const ISVGLineElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_get_x1(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).get_x1(@ptrCast(*const ISVGLineElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_putref_y1(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).putref_y1(@ptrCast(*const ISVGLineElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_get_y1(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).get_y1(@ptrCast(*const ISVGLineElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_putref_x2(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).putref_x2(@ptrCast(*const ISVGLineElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_get_x2(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).get_x2(@ptrCast(*const ISVGLineElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_putref_y2(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).putref_y2(@ptrCast(*const ISVGLineElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLineElement_get_y2(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLineElement.VTable, self.vtable).get_y2(@ptrCast(*const ISVGLineElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGRectElement_Value = @import("../zig.zig").Guid.initString("30510513-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGRectElement = &IID_ISVGRectElement_Value;
pub const ISVGRectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGRectElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGRectElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGRectElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGRectElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGRectElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const ISVGRectElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGRectElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const ISVGRectElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_rx: fn(
            self: *const ISVGRectElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rx: fn(
            self: *const ISVGRectElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_ry: fn(
            self: *const ISVGRectElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ry: fn(
            self: *const ISVGRectElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_x(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_x(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_y(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_y(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_width(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_width(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_height(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_height(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_rx(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_rx(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_rx(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_rx(@ptrCast(*const ISVGRectElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_putref_ry(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).putref_ry(@ptrCast(*const ISVGRectElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRectElement_get_ry(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRectElement.VTable, self.vtable).get_ry(@ptrCast(*const ISVGRectElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPolygonElement_Value = @import("../zig.zig").Guid.initString("30510519-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPolygonElement = &IID_ISVGPolygonElement_Value;
pub const ISVGPolygonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPolylineElement_Value = @import("../zig.zig").Guid.initString("30510518-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPolylineElement = &IID_ISVGPolylineElement_Value;
pub const ISVGPolylineElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGCircleElement_Value = @import("../zig.zig").Guid.initString("3059000A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGCircleElement = &IID_DispSVGCircleElement_Value;
pub const DispSVGCircleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGEllipseElement_Value = @import("../zig.zig").Guid.initString("3059000B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGEllipseElement = &IID_DispSVGEllipseElement_Value;
pub const DispSVGEllipseElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGLineElement_Value = @import("../zig.zig").Guid.initString("3059000C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGLineElement = &IID_DispSVGLineElement_Value;
pub const DispSVGLineElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGRectElement_Value = @import("../zig.zig").Guid.initString("30590009-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGRectElement = &IID_DispSVGRectElement_Value;
pub const DispSVGRectElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPolygonElement_Value = @import("../zig.zig").Guid.initString("3059000D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPolygonElement = &IID_DispSVGPolygonElement_Value;
pub const DispSVGPolygonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPolylineElement_Value = @import("../zig.zig").Guid.initString("3059000E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPolylineElement = &IID_DispSVGPolylineElement_Value;
pub const DispSVGPolylineElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGGElement_Value = @import("../zig.zig").Guid.initString("305104E8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGGElement = &IID_ISVGGElement_Value;
pub const ISVGGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGGElement_Value = @import("../zig.zig").Guid.initString("30590002-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGGElement = &IID_DispSVGGElement_Value;
pub const DispSVGGElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGSymbolElement_Value = @import("../zig.zig").Guid.initString("305104EC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGSymbolElement = &IID_ISVGSymbolElement_Value;
pub const ISVGSymbolElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGSymbolElement_Value = @import("../zig.zig").Guid.initString("30590004-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGSymbolElement = &IID_DispSVGSymbolElement_Value;
pub const DispSVGSymbolElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGDefsElement_Value = @import("../zig.zig").Guid.initString("305104E9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGDefsElement = &IID_ISVGDefsElement_Value;
pub const ISVGDefsElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGDefsElement_Value = @import("../zig.zig").Guid.initString("30590003-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGDefsElement = &IID_DispSVGDefsElement_Value;
pub const DispSVGDefsElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAnimatedPathData_Value = @import("../zig.zig").Guid.initString("30510511-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAnimatedPathData = &IID_ISVGAnimatedPathData_Value;
pub const ISVGAnimatedPathData = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_pathSegList: fn(
            self: *const ISVGAnimatedPathData,
            v: *ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pathSegList: fn(
            self: *const ISVGAnimatedPathData,
            p: **ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_normalizedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            v: *ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_normalizedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            p: **ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animatedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            v: *ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animatedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            p: **ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_animatedNormalizedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            v: *ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_animatedNormalizedPathSegList: fn(
            self: *const ISVGAnimatedPathData,
            p: **ISVGPathSegList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_putref_pathSegList(self: *const T, v: *ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).putref_pathSegList(@ptrCast(*const ISVGAnimatedPathData, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_get_pathSegList(self: *const T, p: **ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).get_pathSegList(@ptrCast(*const ISVGAnimatedPathData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_putref_normalizedPathSegList(self: *const T, v: *ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).putref_normalizedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_get_normalizedPathSegList(self: *const T, p: **ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).get_normalizedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_putref_animatedPathSegList(self: *const T, v: *ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).putref_animatedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_get_animatedPathSegList(self: *const T, p: **ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).get_animatedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_putref_animatedNormalizedPathSegList(self: *const T, v: *ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).putref_animatedNormalizedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAnimatedPathData_get_animatedNormalizedPathSegList(self: *const T, p: **ISVGPathSegList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAnimatedPathData.VTable, self.vtable).get_animatedNormalizedPathSegList(@ptrCast(*const ISVGAnimatedPathData, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPathElement_Value = @import("../zig.zig").Guid.initString("30510512-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPathElement = &IID_ISVGPathElement_Value;
pub const ISVGPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_pathLength: fn(
            self: *const ISVGPathElement,
            v: *ISVGAnimatedNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pathLength: fn(
            self: *const ISVGPathElement,
            p: **ISVGAnimatedNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getTotalLength: fn(
            self: *const ISVGPathElement,
            pfltResult: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPointAtLength: fn(
            self: *const ISVGPathElement,
            fltdistance: f32,
            ppPointResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPathSegAtLength: fn(
            self: *const ISVGPathElement,
            fltdistance: f32,
            plResult: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegClosePath: fn(
            self: *const ISVGPathElement,
            ppResult: **ISVGPathSegClosePath,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegMovetoAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: **ISVGPathSegMovetoAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegMovetoRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: **ISVGPathSegMovetoRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: **ISVGPathSegLinetoAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: **ISVGPathSegLinetoRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoCubicAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x1: f32,
            y1: f32,
            x2: f32,
            y2: f32,
            ppResult: **ISVGPathSegCurvetoCubicAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoCubicRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x1: f32,
            y1: f32,
            x2: f32,
            y2: f32,
            ppResult: **ISVGPathSegCurvetoCubicRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoQuadraticAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x1: f32,
            y1: f32,
            ppResult: **ISVGPathSegCurvetoQuadraticAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoQuadraticRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x1: f32,
            y1: f32,
            ppResult: **ISVGPathSegCurvetoQuadraticRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegArcAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            r1: f32,
            r2: f32,
            angle: f32,
            largeArcFlag: i16,
            sweepFlag: i16,
            ppResult: **ISVGPathSegArcAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegArcRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            r1: f32,
            r2: f32,
            angle: f32,
            largeArcFlag: i16,
            sweepFlag: i16,
            ppResult: **ISVGPathSegArcRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoHorizontalAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            ppResult: **ISVGPathSegLinetoHorizontalAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoHorizontalRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            ppResult: **ISVGPathSegLinetoHorizontalRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoVerticalAbs: fn(
            self: *const ISVGPathElement,
            y: f32,
            ppResult: **ISVGPathSegLinetoVerticalAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegLinetoVerticalRel: fn(
            self: *const ISVGPathElement,
            y: f32,
            ppResult: **ISVGPathSegLinetoVerticalRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoCubicSmoothAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x2: f32,
            y2: f32,
            ppResult: **ISVGPathSegCurvetoCubicSmoothAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoCubicSmoothRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            x2: f32,
            y2: f32,
            ppResult: **ISVGPathSegCurvetoCubicSmoothRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoQuadraticSmoothAbs: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: **ISVGPathSegCurvetoQuadraticSmoothAbs,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        createSVGPathSegCurvetoQuadraticSmoothRel: fn(
            self: *const ISVGPathElement,
            x: f32,
            y: f32,
            ppResult: **ISVGPathSegCurvetoQuadraticSmoothRel,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_putref_pathLength(self: *const T, v: *ISVGAnimatedNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).putref_pathLength(@ptrCast(*const ISVGPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_get_pathLength(self: *const T, p: **ISVGAnimatedNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).get_pathLength(@ptrCast(*const ISVGPathElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_getTotalLength(self: *const T, pfltResult: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).getTotalLength(@ptrCast(*const ISVGPathElement, self), pfltResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_getPointAtLength(self: *const T, fltdistance: f32, ppPointResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).getPointAtLength(@ptrCast(*const ISVGPathElement, self), fltdistance, ppPointResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_getPathSegAtLength(self: *const T, fltdistance: f32, plResult: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).getPathSegAtLength(@ptrCast(*const ISVGPathElement, self), fltdistance, plResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegClosePath(self: *const T, ppResult: **ISVGPathSegClosePath) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegClosePath(@ptrCast(*const ISVGPathElement, self), ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegMovetoAbs(self: *const T, x: f32, y: f32, ppResult: **ISVGPathSegMovetoAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegMovetoAbs(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegMovetoRel(self: *const T, x: f32, y: f32, ppResult: **ISVGPathSegMovetoRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegMovetoRel(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoAbs(self: *const T, x: f32, y: f32, ppResult: **ISVGPathSegLinetoAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoAbs(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoRel(self: *const T, x: f32, y: f32, ppResult: **ISVGPathSegLinetoRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoRel(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoCubicAbs(self: *const T, x: f32, y: f32, x1: f32, y1: f32, x2: f32, y2: f32, ppResult: **ISVGPathSegCurvetoCubicAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoCubicAbs(@ptrCast(*const ISVGPathElement, self), x, y, x1, y1, x2, y2, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoCubicRel(self: *const T, x: f32, y: f32, x1: f32, y1: f32, x2: f32, y2: f32, ppResult: **ISVGPathSegCurvetoCubicRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoCubicRel(@ptrCast(*const ISVGPathElement, self), x, y, x1, y1, x2, y2, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoQuadraticAbs(self: *const T, x: f32, y: f32, x1: f32, y1: f32, ppResult: **ISVGPathSegCurvetoQuadraticAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoQuadraticAbs(@ptrCast(*const ISVGPathElement, self), x, y, x1, y1, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoQuadraticRel(self: *const T, x: f32, y: f32, x1: f32, y1: f32, ppResult: **ISVGPathSegCurvetoQuadraticRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoQuadraticRel(@ptrCast(*const ISVGPathElement, self), x, y, x1, y1, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegArcAbs(self: *const T, x: f32, y: f32, r1: f32, r2: f32, angle: f32, largeArcFlag: i16, sweepFlag: i16, ppResult: **ISVGPathSegArcAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegArcAbs(@ptrCast(*const ISVGPathElement, self), x, y, r1, r2, angle, largeArcFlag, sweepFlag, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegArcRel(self: *const T, x: f32, y: f32, r1: f32, r2: f32, angle: f32, largeArcFlag: i16, sweepFlag: i16, ppResult: **ISVGPathSegArcRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegArcRel(@ptrCast(*const ISVGPathElement, self), x, y, r1, r2, angle, largeArcFlag, sweepFlag, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoHorizontalAbs(self: *const T, x: f32, ppResult: **ISVGPathSegLinetoHorizontalAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoHorizontalAbs(@ptrCast(*const ISVGPathElement, self), x, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoHorizontalRel(self: *const T, x: f32, ppResult: **ISVGPathSegLinetoHorizontalRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoHorizontalRel(@ptrCast(*const ISVGPathElement, self), x, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoVerticalAbs(self: *const T, y: f32, ppResult: **ISVGPathSegLinetoVerticalAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoVerticalAbs(@ptrCast(*const ISVGPathElement, self), y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegLinetoVerticalRel(self: *const T, y: f32, ppResult: **ISVGPathSegLinetoVerticalRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegLinetoVerticalRel(@ptrCast(*const ISVGPathElement, self), y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoCubicSmoothAbs(self: *const T, x: f32, y: f32, x2: f32, y2: f32, ppResult: **ISVGPathSegCurvetoCubicSmoothAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoCubicSmoothAbs(@ptrCast(*const ISVGPathElement, self), x, y, x2, y2, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoCubicSmoothRel(self: *const T, x: f32, y: f32, x2: f32, y2: f32, ppResult: **ISVGPathSegCurvetoCubicSmoothRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoCubicSmoothRel(@ptrCast(*const ISVGPathElement, self), x, y, x2, y2, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoQuadraticSmoothAbs(self: *const T, x: f32, y: f32, ppResult: **ISVGPathSegCurvetoQuadraticSmoothAbs) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoQuadraticSmoothAbs(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPathElement_createSVGPathSegCurvetoQuadraticSmoothRel(self: *const T, x: f32, y: f32, ppResult: **ISVGPathSegCurvetoQuadraticSmoothRel) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPathElement.VTable, self.vtable).createSVGPathSegCurvetoQuadraticSmoothRel(@ptrCast(*const ISVGPathElement, self), x, y, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGPathElement_Value = @import("../zig.zig").Guid.initString("30590011-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGPathElement = &IID_DispSVGPathElement_Value;
pub const DispSVGPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGPreserveAspectRatio_Value = @import("../zig.zig").Guid.initString("305104FA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGPreserveAspectRatio = &IID_ISVGPreserveAspectRatio_Value;
pub const ISVGPreserveAspectRatio = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_align: fn(
            self: *const ISVGPreserveAspectRatio,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_align: fn(
            self: *const ISVGPreserveAspectRatio,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_meetOrSlice: fn(
            self: *const ISVGPreserveAspectRatio,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_meetOrSlice: fn(
            self: *const ISVGPreserveAspectRatio,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPreserveAspectRatio_put_align(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPreserveAspectRatio.VTable, self.vtable).put_align(@ptrCast(*const ISVGPreserveAspectRatio, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPreserveAspectRatio_get_align(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPreserveAspectRatio.VTable, self.vtable).get_align(@ptrCast(*const ISVGPreserveAspectRatio, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPreserveAspectRatio_put_meetOrSlice(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPreserveAspectRatio.VTable, self.vtable).put_meetOrSlice(@ptrCast(*const ISVGPreserveAspectRatio, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGPreserveAspectRatio_get_meetOrSlice(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGPreserveAspectRatio.VTable, self.vtable).get_meetOrSlice(@ptrCast(*const ISVGPreserveAspectRatio, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTextElement_Value = @import("../zig.zig").Guid.initString("3051051C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTextElement = &IID_ISVGTextElement_Value;
pub const ISVGTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTextElement_Value = @import("../zig.zig").Guid.initString("30590037-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGTextElement = &IID_DispSVGTextElement_Value;
pub const DispSVGTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGImageElement_Value = @import("../zig.zig").Guid.initString("305104F0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGImageElement = &IID_ISVGImageElement_Value;
pub const ISVGImageElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGImageElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGImageElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGImageElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGImageElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGImageElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const ISVGImageElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGImageElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const ISVGImageElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_putref_x(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGImageElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_get_x(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGImageElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_putref_y(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGImageElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_get_y(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGImageElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_putref_width(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGImageElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_get_width(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGImageElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_putref_height(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGImageElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGImageElement_get_height(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGImageElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGImageElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGImageElement_Value = @import("../zig.zig").Guid.initString("30590027-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGImageElement = &IID_DispSVGImageElement_Value;
pub const DispSVGImageElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGStopElement_Value = @import("../zig.zig").Guid.initString("3051052B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGStopElement = &IID_ISVGStopElement_Value;
pub const ISVGStopElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_offset: fn(
            self: *const ISVGStopElement,
            v: *ISVGAnimatedNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_offset: fn(
            self: *const ISVGStopElement,
            p: **ISVGAnimatedNumber,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStopElement_putref_offset(self: *const T, v: *ISVGAnimatedNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStopElement.VTable, self.vtable).putref_offset(@ptrCast(*const ISVGStopElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStopElement_get_offset(self: *const T, p: **ISVGAnimatedNumber) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStopElement.VTable, self.vtable).get_offset(@ptrCast(*const ISVGStopElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGStopElement_Value = @import("../zig.zig").Guid.initString("3059002D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGStopElement = &IID_DispSVGStopElement_Value;
pub const DispSVGStopElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGGradientElement_Value = @import("../zig.zig").Guid.initString("30510528-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGGradientElement = &IID_ISVGGradientElement_Value;
pub const ISVGGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_gradientUnits: fn(
            self: *const ISVGGradientElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_gradientUnits: fn(
            self: *const ISVGGradientElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_gradientTransform: fn(
            self: *const ISVGGradientElement,
            v: *ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_gradientTransform: fn(
            self: *const ISVGGradientElement,
            p: **ISVGAnimatedTransformList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_spreadMethod: fn(
            self: *const ISVGGradientElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_spreadMethod: fn(
            self: *const ISVGGradientElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_putref_gradientUnits(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).putref_gradientUnits(@ptrCast(*const ISVGGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_get_gradientUnits(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).get_gradientUnits(@ptrCast(*const ISVGGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_putref_gradientTransform(self: *const T, v: *ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).putref_gradientTransform(@ptrCast(*const ISVGGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_get_gradientTransform(self: *const T, p: **ISVGAnimatedTransformList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).get_gradientTransform(@ptrCast(*const ISVGGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_putref_spreadMethod(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).putref_spreadMethod(@ptrCast(*const ISVGGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGGradientElement_get_spreadMethod(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGGradientElement.VTable, self.vtable).get_spreadMethod(@ptrCast(*const ISVGGradientElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGGradientElement_Value = @import("../zig.zig").Guid.initString("3059002E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGGradientElement = &IID_DispSVGGradientElement_Value;
pub const DispSVGGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGLinearGradientElement_Value = @import("../zig.zig").Guid.initString("30510529-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGLinearGradientElement = &IID_ISVGLinearGradientElement_Value;
pub const ISVGLinearGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x1: fn(
            self: *const ISVGLinearGradientElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x1: fn(
            self: *const ISVGLinearGradientElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y1: fn(
            self: *const ISVGLinearGradientElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y1: fn(
            self: *const ISVGLinearGradientElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_x2: fn(
            self: *const ISVGLinearGradientElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x2: fn(
            self: *const ISVGLinearGradientElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y2: fn(
            self: *const ISVGLinearGradientElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y2: fn(
            self: *const ISVGLinearGradientElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_putref_x1(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).putref_x1(@ptrCast(*const ISVGLinearGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_get_x1(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).get_x1(@ptrCast(*const ISVGLinearGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_putref_y1(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).putref_y1(@ptrCast(*const ISVGLinearGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_get_y1(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).get_y1(@ptrCast(*const ISVGLinearGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_putref_x2(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).putref_x2(@ptrCast(*const ISVGLinearGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_get_x2(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).get_x2(@ptrCast(*const ISVGLinearGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_putref_y2(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).putref_y2(@ptrCast(*const ISVGLinearGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGLinearGradientElement_get_y2(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGLinearGradientElement.VTable, self.vtable).get_y2(@ptrCast(*const ISVGLinearGradientElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGLinearGradientElement_Value = @import("../zig.zig").Guid.initString("3059002A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGLinearGradientElement = &IID_DispSVGLinearGradientElement_Value;
pub const DispSVGLinearGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGRadialGradientElement_Value = @import("../zig.zig").Guid.initString("3051052A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGRadialGradientElement = &IID_ISVGRadialGradientElement_Value;
pub const ISVGRadialGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_cx: fn(
            self: *const ISVGRadialGradientElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cx: fn(
            self: *const ISVGRadialGradientElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_cy: fn(
            self: *const ISVGRadialGradientElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cy: fn(
            self: *const ISVGRadialGradientElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_r: fn(
            self: *const ISVGRadialGradientElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_r: fn(
            self: *const ISVGRadialGradientElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_fx: fn(
            self: *const ISVGRadialGradientElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fx: fn(
            self: *const ISVGRadialGradientElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_fy: fn(
            self: *const ISVGRadialGradientElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fy: fn(
            self: *const ISVGRadialGradientElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_cx(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_cx(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_cx(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_cx(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_cy(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_cy(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_cy(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_cy(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_r(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_r(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_r(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_r(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_fx(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_fx(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_fx(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_fx(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_putref_fy(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).putref_fy(@ptrCast(*const ISVGRadialGradientElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGRadialGradientElement_get_fy(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGRadialGradientElement.VTable, self.vtable).get_fy(@ptrCast(*const ISVGRadialGradientElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGRadialGradientElement_Value = @import("../zig.zig").Guid.initString("3059002B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGRadialGradientElement = &IID_DispSVGRadialGradientElement_Value;
pub const DispSVGRadialGradientElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGMaskElement_Value = @import("../zig.zig").Guid.initString("3051052E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGMaskElement = &IID_ISVGMaskElement_Value;
pub const ISVGMaskElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_maskUnits: fn(
            self: *const ISVGMaskElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maskUnits: fn(
            self: *const ISVGMaskElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_maskContentUnits: fn(
            self: *const ISVGMaskElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maskContentUnits: fn(
            self: *const ISVGMaskElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_x: fn(
            self: *const ISVGMaskElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGMaskElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGMaskElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGMaskElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_width: fn(
            self: *const ISVGMaskElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const ISVGMaskElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_height: fn(
            self: *const ISVGMaskElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const ISVGMaskElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_maskUnits(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_maskUnits(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_maskUnits(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_maskUnits(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_maskContentUnits(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_maskContentUnits(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_maskContentUnits(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_maskContentUnits(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_x(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_x(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_y(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_y(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_width(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_width(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_width(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_width(@ptrCast(*const ISVGMaskElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_putref_height(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).putref_height(@ptrCast(*const ISVGMaskElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMaskElement_get_height(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMaskElement.VTable, self.vtable).get_height(@ptrCast(*const ISVGMaskElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGMaskElement_Value = @import("../zig.zig").Guid.initString("3059003C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGMaskElement = &IID_DispSVGMaskElement_Value;
pub const DispSVGMaskElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGMarkerElement_Value = @import("../zig.zig").Guid.initString("30510525-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGMarkerElement = &IID_ISVGMarkerElement_Value;
pub const ISVGMarkerElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_refX: fn(
            self: *const ISVGMarkerElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_refX: fn(
            self: *const ISVGMarkerElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_refY: fn(
            self: *const ISVGMarkerElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_refY: fn(
            self: *const ISVGMarkerElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_markerUnits: fn(
            self: *const ISVGMarkerElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_markerUnits: fn(
            self: *const ISVGMarkerElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_markerWidth: fn(
            self: *const ISVGMarkerElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_markerWidth: fn(
            self: *const ISVGMarkerElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_markerHeight: fn(
            self: *const ISVGMarkerElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_markerHeight: fn(
            self: *const ISVGMarkerElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_orientType: fn(
            self: *const ISVGMarkerElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_orientType: fn(
            self: *const ISVGMarkerElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_orientAngle: fn(
            self: *const ISVGMarkerElement,
            v: *ISVGAnimatedAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_orientAngle: fn(
            self: *const ISVGMarkerElement,
            p: **ISVGAnimatedAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setOrientToAuto: fn(
            self: *const ISVGMarkerElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setOrientToAngle: fn(
            self: *const ISVGMarkerElement,
            pSVGAngle: *ISVGAngle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_refX(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_refX(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_refX(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_refX(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_refY(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_refY(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_refY(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_refY(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_markerUnits(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_markerUnits(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_markerUnits(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_markerUnits(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_markerWidth(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_markerWidth(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_markerWidth(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_markerWidth(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_markerHeight(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_markerHeight(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_markerHeight(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_markerHeight(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_orientType(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_orientType(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_orientType(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_orientType(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_putref_orientAngle(self: *const T, v: *ISVGAnimatedAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).putref_orientAngle(@ptrCast(*const ISVGMarkerElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_get_orientAngle(self: *const T, p: **ISVGAnimatedAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).get_orientAngle(@ptrCast(*const ISVGMarkerElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_setOrientToAuto(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).setOrientToAuto(@ptrCast(*const ISVGMarkerElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGMarkerElement_setOrientToAngle(self: *const T, pSVGAngle: *ISVGAngle) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGMarkerElement.VTable, self.vtable).setOrientToAngle(@ptrCast(*const ISVGMarkerElement, self), pSVGAngle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGMarkerElement_Value = @import("../zig.zig").Guid.initString("30590036-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGMarkerElement = &IID_DispSVGMarkerElement_Value;
pub const DispSVGMarkerElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGZoomEvent_Value = @import("../zig.zig").Guid.initString("3051054E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGZoomEvent = &IID_ISVGZoomEvent_Value;
pub const ISVGZoomEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_zoomRectScreen: fn(
            self: *const ISVGZoomEvent,
            p: **ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_previousScale: fn(
            self: *const ISVGZoomEvent,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_previousTranslate: fn(
            self: *const ISVGZoomEvent,
            p: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_newScale: fn(
            self: *const ISVGZoomEvent,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_newTranslate: fn(
            self: *const ISVGZoomEvent,
            p: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_zoomRectScreen(self: *const T, p: **ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_zoomRectScreen(@ptrCast(*const ISVGZoomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_previousScale(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_previousScale(@ptrCast(*const ISVGZoomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_previousTranslate(self: *const T, p: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_previousTranslate(@ptrCast(*const ISVGZoomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_newScale(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_newScale(@ptrCast(*const ISVGZoomEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGZoomEvent_get_newTranslate(self: *const T, p: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGZoomEvent.VTable, self.vtable).get_newTranslate(@ptrCast(*const ISVGZoomEvent, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGZoomEvent_Value = @import("../zig.zig").Guid.initString("30590031-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGZoomEvent = &IID_DispSVGZoomEvent_Value;
pub const DispSVGZoomEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGAElement_Value = @import("../zig.zig").Guid.initString("3051054B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGAElement = &IID_ISVGAElement_Value;
pub const ISVGAElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_target: fn(
            self: *const ISVGAElement,
            v: *ISVGAnimatedString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_target: fn(
            self: *const ISVGAElement,
            p: **ISVGAnimatedString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAElement_putref_target(self: *const T, v: *ISVGAnimatedString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAElement.VTable, self.vtable).putref_target(@ptrCast(*const ISVGAElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGAElement_get_target(self: *const T, p: **ISVGAnimatedString) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGAElement.VTable, self.vtable).get_target(@ptrCast(*const ISVGAElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGAElement_Value = @import("../zig.zig").Guid.initString("30590033-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGAElement = &IID_DispSVGAElement_Value;
pub const DispSVGAElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGViewElement_Value = @import("../zig.zig").Guid.initString("3051054C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGViewElement = &IID_ISVGViewElement_Value;
pub const ISVGViewElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_viewTarget: fn(
            self: *const ISVGViewElement,
            v: *ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_viewTarget: fn(
            self: *const ISVGViewElement,
            p: **ISVGStringList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGViewElement_putref_viewTarget(self: *const T, v: *ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGViewElement.VTable, self.vtable).putref_viewTarget(@ptrCast(*const ISVGViewElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGViewElement_get_viewTarget(self: *const T, p: **ISVGStringList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGViewElement.VTable, self.vtable).get_viewTarget(@ptrCast(*const ISVGViewElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGViewElement_Value = @import("../zig.zig").Guid.initString("30590034-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGViewElement = &IID_DispSVGViewElement_Value;
pub const DispSVGViewElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMediaError_Value = @import("../zig.zig").Guid.initString("30510704-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMediaError = &IID_IHTMLMediaError_Value;
pub const IHTMLMediaError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_code: fn(
            self: *const IHTMLMediaError,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaError_get_code(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaError.VTable, self.vtable).get_code(@ptrCast(*const IHTMLMediaError, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTimeRanges_Value = @import("../zig.zig").Guid.initString("30510705-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTimeRanges = &IID_IHTMLTimeRanges_Value;
pub const IHTMLTimeRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLTimeRanges,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        start: fn(
            self: *const IHTMLTimeRanges,
            index: i32,
            startTime: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        end: fn(
            self: *const IHTMLTimeRanges,
            index: i32,
            endTime: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges.VTable, self.vtable).get_length(@ptrCast(*const IHTMLTimeRanges, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges_start(self: *const T, index: i32, startTime: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges.VTable, self.vtable).start(@ptrCast(*const IHTMLTimeRanges, self), index, startTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges_end(self: *const T, index: i32, endTime: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges.VTable, self.vtable).end(@ptrCast(*const IHTMLTimeRanges, self), index, endTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLTimeRanges2_Value = @import("../zig.zig").Guid.initString("3051080B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLTimeRanges2 = &IID_IHTMLTimeRanges2_Value;
pub const IHTMLTimeRanges2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        startDouble: fn(
            self: *const IHTMLTimeRanges2,
            index: i32,
            startTime: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endDouble: fn(
            self: *const IHTMLTimeRanges2,
            index: i32,
            endTime: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges2_startDouble(self: *const T, index: i32, startTime: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges2.VTable, self.vtable).startDouble(@ptrCast(*const IHTMLTimeRanges2, self), index, startTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLTimeRanges2_endDouble(self: *const T, index: i32, endTime: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLTimeRanges2.VTable, self.vtable).endDouble(@ptrCast(*const IHTMLTimeRanges2, self), index, endTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMediaElement_Value = @import("../zig.zig").Guid.initString("30510706-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMediaElement = &IID_IHTMLMediaElement_Value;
pub const IHTMLMediaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_error: fn(
            self: *const IHTMLMediaElement,
            p: **IHTMLMediaError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_src: fn(
            self: *const IHTMLMediaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLMediaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentSrc: fn(
            self: *const IHTMLMediaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_networkState: fn(
            self: *const IHTMLMediaElement,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_preload: fn(
            self: *const IHTMLMediaElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_preload: fn(
            self: *const IHTMLMediaElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_buffered: fn(
            self: *const IHTMLMediaElement,
            p: **IHTMLTimeRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        load: fn(
            self: *const IHTMLMediaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        canPlayType: fn(
            self: *const IHTMLMediaElement,
            type: BSTR,
            canPlay: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_seeking: fn(
            self: *const IHTMLMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_currentTime: fn(
            self: *const IHTMLMediaElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentTime: fn(
            self: *const IHTMLMediaElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_initialTime: fn(
            self: *const IHTMLMediaElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_duration: fn(
            self: *const IHTMLMediaElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_paused: fn(
            self: *const IHTMLMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultPlaybackRate: fn(
            self: *const IHTMLMediaElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultPlaybackRate: fn(
            self: *const IHTMLMediaElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_playbackRate: fn(
            self: *const IHTMLMediaElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_playbackRate: fn(
            self: *const IHTMLMediaElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_played: fn(
            self: *const IHTMLMediaElement,
            p: **IHTMLTimeRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_seekable: fn(
            self: *const IHTMLMediaElement,
            p: **IHTMLTimeRanges,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ended: fn(
            self: *const IHTMLMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_autoplay: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_autoplay: fn(
            self: *const IHTMLMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_loop: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_loop: fn(
            self: *const IHTMLMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        play: fn(
            self: *const IHTMLMediaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        pause: fn(
            self: *const IHTMLMediaElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_controls: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_controls: fn(
            self: *const IHTMLMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_volume: fn(
            self: *const IHTMLMediaElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_volume: fn(
            self: *const IHTMLMediaElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_muted: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_muted: fn(
            self: *const IHTMLMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_autobuffer: fn(
            self: *const IHTMLMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_autobuffer: fn(
            self: *const IHTMLMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_error(self: *const T, p: **IHTMLMediaError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_error(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_currentSrc(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_currentSrc(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_networkState(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_networkState(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_preload(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_preload(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_preload(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_preload(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_buffered(self: *const T, p: **IHTMLTimeRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_buffered(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_load(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).load(@ptrCast(*const IHTMLMediaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_canPlayType(self: *const T, type: BSTR, canPlay: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).canPlayType(@ptrCast(*const IHTMLMediaElement, self), type, canPlay);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_seeking(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_seeking(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_currentTime(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_currentTime(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_currentTime(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_currentTime(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_initialTime(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_initialTime(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_duration(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_duration(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_paused(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_paused(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_defaultPlaybackRate(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_defaultPlaybackRate(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_defaultPlaybackRate(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_defaultPlaybackRate(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_playbackRate(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_playbackRate(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_playbackRate(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_playbackRate(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_played(self: *const T, p: **IHTMLTimeRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_played(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_seekable(self: *const T, p: **IHTMLTimeRanges) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_seekable(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_ended(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_ended(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_autoplay(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_autoplay(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_autoplay(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_autoplay(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_loop(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_loop(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_loop(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_loop(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_play(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).play(@ptrCast(*const IHTMLMediaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_pause(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).pause(@ptrCast(*const IHTMLMediaElement, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_controls(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_controls(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_controls(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_controls(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_volume(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_volume(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_volume(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_volume(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_muted(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_muted(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_muted(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_muted(@ptrCast(*const IHTMLMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_put_autobuffer(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).put_autobuffer(@ptrCast(*const IHTMLMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement_get_autobuffer(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement.VTable, self.vtable).get_autobuffer(@ptrCast(*const IHTMLMediaElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMediaElement2_Value = @import("../zig.zig").Guid.initString("30510809-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMediaElement2 = &IID_IHTMLMediaElement2_Value;
pub const IHTMLMediaElement2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_currentTimeDouble: fn(
            self: *const IHTMLMediaElement2,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentTimeDouble: fn(
            self: *const IHTMLMediaElement2,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_initialTimeDouble: fn(
            self: *const IHTMLMediaElement2,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_durationDouble: fn(
            self: *const IHTMLMediaElement2,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_defaultPlaybackRateDouble: fn(
            self: *const IHTMLMediaElement2,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_defaultPlaybackRateDouble: fn(
            self: *const IHTMLMediaElement2,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_playbackRateDouble: fn(
            self: *const IHTMLMediaElement2,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_playbackRateDouble: fn(
            self: *const IHTMLMediaElement2,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_volumeDouble: fn(
            self: *const IHTMLMediaElement2,
            v: f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_volumeDouble: fn(
            self: *const IHTMLMediaElement2,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_put_currentTimeDouble(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).put_currentTimeDouble(@ptrCast(*const IHTMLMediaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_currentTimeDouble(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_currentTimeDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_initialTimeDouble(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_initialTimeDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_durationDouble(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_durationDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_put_defaultPlaybackRateDouble(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).put_defaultPlaybackRateDouble(@ptrCast(*const IHTMLMediaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_defaultPlaybackRateDouble(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_defaultPlaybackRateDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_put_playbackRateDouble(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).put_playbackRateDouble(@ptrCast(*const IHTMLMediaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_playbackRateDouble(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_playbackRateDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_put_volumeDouble(self: *const T, v: f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).put_volumeDouble(@ptrCast(*const IHTMLMediaElement2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMediaElement2_get_volumeDouble(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMediaElement2.VTable, self.vtable).get_volumeDouble(@ptrCast(*const IHTMLMediaElement2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLMSMediaElement_Value = @import("../zig.zig").Guid.initString("30510792-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLMSMediaElement = &IID_IHTMLMSMediaElement_Value;
pub const IHTMLMSMediaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_msPlayToDisabled: fn(
            self: *const IHTMLMSMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msPlayToDisabled: fn(
            self: *const IHTMLMSMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_msPlayToPrimary: fn(
            self: *const IHTMLMSMediaElement,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msPlayToPrimary: fn(
            self: *const IHTMLMSMediaElement,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSMediaElement_put_msPlayToDisabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSMediaElement.VTable, self.vtable).put_msPlayToDisabled(@ptrCast(*const IHTMLMSMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSMediaElement_get_msPlayToDisabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSMediaElement.VTable, self.vtable).get_msPlayToDisabled(@ptrCast(*const IHTMLMSMediaElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSMediaElement_put_msPlayToPrimary(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSMediaElement.VTable, self.vtable).put_msPlayToPrimary(@ptrCast(*const IHTMLMSMediaElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLMSMediaElement_get_msPlayToPrimary(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLMSMediaElement.VTable, self.vtable).get_msPlayToPrimary(@ptrCast(*const IHTMLMSMediaElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLSourceElement_Value = @import("../zig.zig").Guid.initString("30510707-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLSourceElement = &IID_IHTMLSourceElement_Value;
pub const IHTMLSourceElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_src: fn(
            self: *const IHTMLSourceElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_src: fn(
            self: *const IHTMLSourceElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_type: fn(
            self: *const IHTMLSourceElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const IHTMLSourceElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_media: fn(
            self: *const IHTMLSourceElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_media: fn(
            self: *const IHTMLSourceElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_put_src(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).put_src(@ptrCast(*const IHTMLSourceElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_get_src(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).get_src(@ptrCast(*const IHTMLSourceElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).put_type(@ptrCast(*const IHTMLSourceElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).get_type(@ptrCast(*const IHTMLSourceElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_put_media(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).put_media(@ptrCast(*const IHTMLSourceElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLSourceElement_get_media(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLSourceElement.VTable, self.vtable).get_media(@ptrCast(*const IHTMLSourceElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAudioElement_Value = @import("../zig.zig").Guid.initString("30510708-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAudioElement = &IID_IHTMLAudioElement_Value;
pub const IHTMLAudioElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLVideoElement_Value = @import("../zig.zig").Guid.initString("30510709-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLVideoElement = &IID_IHTMLVideoElement_Value;
pub const IHTMLVideoElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_width: fn(
            self: *const IHTMLVideoElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IHTMLVideoElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_height: fn(
            self: *const IHTMLVideoElement,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IHTMLVideoElement,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_videoWidth: fn(
            self: *const IHTMLVideoElement,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_videoHeight: fn(
            self: *const IHTMLVideoElement,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_poster: fn(
            self: *const IHTMLVideoElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_poster: fn(
            self: *const IHTMLVideoElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_put_width(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).put_width(@ptrCast(*const IHTMLVideoElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_width(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_width(@ptrCast(*const IHTMLVideoElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_put_height(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).put_height(@ptrCast(*const IHTMLVideoElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_height(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_height(@ptrCast(*const IHTMLVideoElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_videoWidth(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_videoWidth(@ptrCast(*const IHTMLVideoElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_videoHeight(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_videoHeight(@ptrCast(*const IHTMLVideoElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_put_poster(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).put_poster(@ptrCast(*const IHTMLVideoElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLVideoElement_get_poster(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLVideoElement.VTable, self.vtable).get_poster(@ptrCast(*const IHTMLVideoElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAudioElementFactory_Value = @import("../zig.zig").Guid.initString("305107EB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAudioElementFactory = &IID_IHTMLAudioElementFactory_Value;
pub const IHTMLAudioElementFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IHTMLAudioElementFactory,
            src: VARIANT,
            __MIDL__IHTMLAudioElementFactory0000: **IHTMLAudioElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAudioElementFactory_create(self: *const T, src: VARIANT, __MIDL__IHTMLAudioElementFactory0000: **IHTMLAudioElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAudioElementFactory.VTable, self.vtable).create(@ptrCast(*const IHTMLAudioElementFactory, self), src, __MIDL__IHTMLAudioElementFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMediaError_Value = @import("../zig.zig").Guid.initString("30590086-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLMediaError = &IID_DispHTMLMediaError_Value;
pub const DispHTMLMediaError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLTimeRanges_Value = @import("../zig.zig").Guid.initString("30590087-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLTimeRanges = &IID_DispHTMLTimeRanges_Value;
pub const DispHTMLTimeRanges = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLMediaElement_Value = @import("../zig.zig").Guid.initString("30590088-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLMediaElement = &IID_DispHTMLMediaElement_Value;
pub const DispHTMLMediaElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSourceElement_Value = @import("../zig.zig").Guid.initString("30590089-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLSourceElement = &IID_DispHTMLSourceElement_Value;
pub const DispHTMLSourceElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAudioElement_Value = @import("../zig.zig").Guid.initString("3059008A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLAudioElement = &IID_DispHTMLAudioElement_Value;
pub const DispHTMLAudioElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLVideoElement_Value = @import("../zig.zig").Guid.initString("3059008B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLVideoElement = &IID_DispHTMLVideoElement_Value;
pub const DispHTMLVideoElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGSwitchElement_Value = @import("../zig.zig").Guid.initString("305104F1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGSwitchElement = &IID_ISVGSwitchElement_Value;
pub const ISVGSwitchElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGSwitchElement_Value = @import("../zig.zig").Guid.initString("30590030-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGSwitchElement = &IID_DispSVGSwitchElement_Value;
pub const DispSVGSwitchElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGDescElement_Value = @import("../zig.zig").Guid.initString("305104EA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGDescElement = &IID_ISVGDescElement_Value;
pub const ISVGDescElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGDescElement_Value = @import("../zig.zig").Guid.initString("30590005-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGDescElement = &IID_DispSVGDescElement_Value;
pub const DispSVGDescElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTitleElement_Value = @import("../zig.zig").Guid.initString("305104EB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTitleElement = &IID_ISVGTitleElement_Value;
pub const ISVGTitleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTitleElement_Value = @import("../zig.zig").Guid.initString("30590006-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGTitleElement = &IID_DispSVGTitleElement_Value;
pub const DispSVGTitleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGMetadataElement_Value = @import("../zig.zig").Guid.initString("30510560-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGMetadataElement = &IID_ISVGMetadataElement_Value;
pub const ISVGMetadataElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGMetadataElement_Value = @import("../zig.zig").Guid.initString("3059002F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGMetadataElement = &IID_DispSVGMetadataElement_Value;
pub const DispSVGMetadataElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGElementInstanceList_Value = @import("../zig.zig").Guid.initString("305104EF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGElementInstanceList = &IID_ISVGElementInstanceList_Value;
pub const ISVGElementInstanceList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const ISVGElementInstanceList,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const ISVGElementInstanceList,
            index: i32,
            ppResult: **ISVGElementInstance,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstanceList_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstanceList.VTable, self.vtable).get_length(@ptrCast(*const ISVGElementInstanceList, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGElementInstanceList_item(self: *const T, index: i32, ppResult: **ISVGElementInstance) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGElementInstanceList.VTable, self.vtable).item(@ptrCast(*const ISVGElementInstanceList, self), index, ppResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGElementInstance_Value = @import("../zig.zig").Guid.initString("30590007-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGElementInstance = &IID_DispSVGElementInstance_Value;
pub const DispSVGElementInstance = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGElementInstanceList_Value = @import("../zig.zig").Guid.initString("30590008-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGElementInstanceList = &IID_DispSVGElementInstanceList_Value;
pub const DispSVGElementInstanceList = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMException_Value = @import("../zig.zig").Guid.initString("3051072B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMException = &IID_IDOMException_Value;
pub const IDOMException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_code: fn(
            self: *const IDOMException,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_code: fn(
            self: *const IDOMException,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_message: fn(
            self: *const IDOMException,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMException_put_code(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMException.VTable, self.vtable).put_code(@ptrCast(*const IDOMException, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMException_get_code(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMException.VTable, self.vtable).get_code(@ptrCast(*const IDOMException, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMException_get_message(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMException.VTable, self.vtable).get_message(@ptrCast(*const IDOMException, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMException_Value = @import("../zig.zig").Guid.initString("30590094-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMException = &IID_DispDOMException_Value;
pub const DispDOMException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRangeException_Value = @import("../zig.zig").Guid.initString("3051072D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IRangeException = &IID_IRangeException_Value;
pub const IRangeException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_code: fn(
            self: *const IRangeException,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_code: fn(
            self: *const IRangeException,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_message: fn(
            self: *const IRangeException,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeException_put_code(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeException.VTable, self.vtable).put_code(@ptrCast(*const IRangeException, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeException_get_code(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeException.VTable, self.vtable).get_code(@ptrCast(*const IRangeException, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRangeException_get_message(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRangeException.VTable, self.vtable).get_message(@ptrCast(*const IRangeException, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispRangeException_Value = @import("../zig.zig").Guid.initString("30590095-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispRangeException = &IID_DispRangeException_Value;
pub const DispRangeException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGException_Value = @import("../zig.zig").Guid.initString("3051072F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGException = &IID_ISVGException_Value;
pub const ISVGException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_code: fn(
            self: *const ISVGException,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_code: fn(
            self: *const ISVGException,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_message: fn(
            self: *const ISVGException,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGException_put_code(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGException.VTable, self.vtable).put_code(@ptrCast(*const ISVGException, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGException_get_code(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGException.VTable, self.vtable).get_code(@ptrCast(*const ISVGException, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGException_get_message(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGException.VTable, self.vtable).get_message(@ptrCast(*const ISVGException, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGException_Value = @import("../zig.zig").Guid.initString("30590096-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGException = &IID_DispSVGException_Value;
pub const DispSVGException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEventException_Value = @import("../zig.zig").Guid.initString("3051073A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IEventException = &IID_IEventException_Value;
pub const IEventException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_code: fn(
            self: *const IEventException,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_code: fn(
            self: *const IEventException,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_message: fn(
            self: *const IEventException,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventException_put_code(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventException.VTable, self.vtable).put_code(@ptrCast(*const IEventException, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventException_get_code(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventException.VTable, self.vtable).get_code(@ptrCast(*const IEventException, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventException_get_message(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventException.VTable, self.vtable).get_message(@ptrCast(*const IEventException, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispEventException_Value = @import("../zig.zig").Guid.initString("30590099-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispEventException = &IID_DispEventException_Value;
pub const DispEventException = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGScriptElement_Value = @import("../zig.zig").Guid.initString("3051054D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGScriptElement = &IID_ISVGScriptElement_Value;
pub const ISVGScriptElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_type: fn(
            self: *const ISVGScriptElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const ISVGScriptElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGScriptElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGScriptElement.VTable, self.vtable).put_type(@ptrCast(*const ISVGScriptElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGScriptElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGScriptElement.VTable, self.vtable).get_type(@ptrCast(*const ISVGScriptElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGScriptElement_Value = @import("../zig.zig").Guid.initString("30590039-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGScriptElement = &IID_DispSVGScriptElement_Value;
pub const DispSVGScriptElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGStyleElement_Value = @import("../zig.zig").Guid.initString("305104F3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGStyleElement = &IID_ISVGStyleElement_Value;
pub const ISVGStyleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_type: fn(
            self: *const ISVGStyleElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_type: fn(
            self: *const ISVGStyleElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_media: fn(
            self: *const ISVGStyleElement,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_media: fn(
            self: *const ISVGStyleElement,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStyleElement_put_type(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStyleElement.VTable, self.vtable).put_type(@ptrCast(*const ISVGStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStyleElement_get_type(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStyleElement.VTable, self.vtable).get_type(@ptrCast(*const ISVGStyleElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStyleElement_put_media(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStyleElement.VTable, self.vtable).put_media(@ptrCast(*const ISVGStyleElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGStyleElement_get_media(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGStyleElement.VTable, self.vtable).get_media(@ptrCast(*const ISVGStyleElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGStyleElement_Value = @import("../zig.zig").Guid.initString("30590029-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGStyleElement = &IID_DispSVGStyleElement_Value;
pub const DispSVGStyleElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTextContentElement_Value = @import("../zig.zig").Guid.initString("3051051A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTextContentElement = &IID_ISVGTextContentElement_Value;
pub const ISVGTextContentElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_textLength: fn(
            self: *const ISVGTextContentElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textLength: fn(
            self: *const ISVGTextContentElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_lengthAdjust: fn(
            self: *const ISVGTextContentElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lengthAdjust: fn(
            self: *const ISVGTextContentElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getNumberOfChars: fn(
            self: *const ISVGTextContentElement,
            pResult: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getComputedTextLength: fn(
            self: *const ISVGTextContentElement,
            pResult: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getSubStringLength: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            nchars: i32,
            pResult: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getStartPositionOfChar: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            ppResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getEndPositionOfChar: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            ppResult: **ISVGPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getExtentOfChar: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            ppResult: **ISVGRect,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getRotationOfChar: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            pResult: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCharNumAtPosition: fn(
            self: *const ISVGTextContentElement,
            point: *ISVGPoint,
            pResult: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        selectSubString: fn(
            self: *const ISVGTextContentElement,
            charnum: i32,
            nchars: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_putref_textLength(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).putref_textLength(@ptrCast(*const ISVGTextContentElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_get_textLength(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).get_textLength(@ptrCast(*const ISVGTextContentElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_putref_lengthAdjust(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).putref_lengthAdjust(@ptrCast(*const ISVGTextContentElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_get_lengthAdjust(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).get_lengthAdjust(@ptrCast(*const ISVGTextContentElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getNumberOfChars(self: *const T, pResult: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getNumberOfChars(@ptrCast(*const ISVGTextContentElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getComputedTextLength(self: *const T, pResult: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getComputedTextLength(@ptrCast(*const ISVGTextContentElement, self), pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getSubStringLength(self: *const T, charnum: i32, nchars: i32, pResult: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getSubStringLength(@ptrCast(*const ISVGTextContentElement, self), charnum, nchars, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getStartPositionOfChar(self: *const T, charnum: i32, ppResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getStartPositionOfChar(@ptrCast(*const ISVGTextContentElement, self), charnum, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getEndPositionOfChar(self: *const T, charnum: i32, ppResult: **ISVGPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getEndPositionOfChar(@ptrCast(*const ISVGTextContentElement, self), charnum, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getExtentOfChar(self: *const T, charnum: i32, ppResult: **ISVGRect) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getExtentOfChar(@ptrCast(*const ISVGTextContentElement, self), charnum, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getRotationOfChar(self: *const T, charnum: i32, pResult: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getRotationOfChar(@ptrCast(*const ISVGTextContentElement, self), charnum, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_getCharNumAtPosition(self: *const T, point: *ISVGPoint, pResult: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).getCharNumAtPosition(@ptrCast(*const ISVGTextContentElement, self), point, pResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextContentElement_selectSubString(self: *const T, charnum: i32, nchars: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextContentElement.VTable, self.vtable).selectSubString(@ptrCast(*const ISVGTextContentElement, self), charnum, nchars);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTextContentElement_Value = @import("../zig.zig").Guid.initString("30590035-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGTextContentElement = &IID_DispSVGTextContentElement_Value;
pub const DispSVGTextContentElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTextPositioningElement_Value = @import("../zig.zig").Guid.initString("3051051B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTextPositioningElement = &IID_ISVGTextPositioningElement_Value;
pub const ISVGTextPositioningElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_x: fn(
            self: *const ISVGTextPositioningElement,
            v: *ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_x: fn(
            self: *const ISVGTextPositioningElement,
            p: **ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_y: fn(
            self: *const ISVGTextPositioningElement,
            v: *ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_y: fn(
            self: *const ISVGTextPositioningElement,
            p: **ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_dx: fn(
            self: *const ISVGTextPositioningElement,
            v: *ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dx: fn(
            self: *const ISVGTextPositioningElement,
            p: **ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_dy: fn(
            self: *const ISVGTextPositioningElement,
            v: *ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dy: fn(
            self: *const ISVGTextPositioningElement,
            p: **ISVGAnimatedLengthList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_rotate: fn(
            self: *const ISVGTextPositioningElement,
            v: *ISVGAnimatedNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_rotate: fn(
            self: *const ISVGTextPositioningElement,
            p: **ISVGAnimatedNumberList,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_x(self: *const T, v: *ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_x(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_x(self: *const T, p: **ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_x(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_y(self: *const T, v: *ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_y(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_y(self: *const T, p: **ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_y(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_dx(self: *const T, v: *ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_dx(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_dx(self: *const T, p: **ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_dx(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_dy(self: *const T, v: *ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_dy(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_dy(self: *const T, p: **ISVGAnimatedLengthList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_dy(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_putref_rotate(self: *const T, v: *ISVGAnimatedNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).putref_rotate(@ptrCast(*const ISVGTextPositioningElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPositioningElement_get_rotate(self: *const T, p: **ISVGAnimatedNumberList) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPositioningElement.VTable, self.vtable).get_rotate(@ptrCast(*const ISVGTextPositioningElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTextPositioningElement_Value = @import("../zig.zig").Guid.initString("30590038-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGTextPositioningElement = &IID_DispSVGTextPositioningElement_Value;
pub const DispSVGTextPositioningElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMDocumentType_Value = @import("../zig.zig").Guid.initString("30590098-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMDocumentType = &IID_DispDOMDocumentType_Value;
pub const DispDOMDocumentType = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispNodeIterator_Value = @import("../zig.zig").Guid.initString("3059009C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispNodeIterator = &IID_DispNodeIterator_Value;
pub const DispNodeIterator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispTreeWalker_Value = @import("../zig.zig").Guid.initString("3059009D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispTreeWalker = &IID_DispTreeWalker_Value;
pub const DispTreeWalker = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMProcessingInstruction_Value = @import("../zig.zig").Guid.initString("3059009B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMProcessingInstruction = &IID_DispDOMProcessingInstruction_Value;
pub const DispDOMProcessingInstruction = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPerformanceNavigation_Value = @import("../zig.zig").Guid.initString("30510750-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPerformanceNavigation = &IID_IHTMLPerformanceNavigation_Value;
pub const IHTMLPerformanceNavigation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_type: fn(
            self: *const IHTMLPerformanceNavigation,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_redirectCount: fn(
            self: *const IHTMLPerformanceNavigation,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLPerformanceNavigation,
            string: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toJSON: fn(
            self: *const IHTMLPerformanceNavigation,
            pVar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceNavigation_get_type(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceNavigation.VTable, self.vtable).get_type(@ptrCast(*const IHTMLPerformanceNavigation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceNavigation_get_redirectCount(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceNavigation.VTable, self.vtable).get_redirectCount(@ptrCast(*const IHTMLPerformanceNavigation, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceNavigation_toString(self: *const T, string: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceNavigation.VTable, self.vtable).toString(@ptrCast(*const IHTMLPerformanceNavigation, self), string);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceNavigation_toJSON(self: *const T, pVar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceNavigation.VTable, self.vtable).toJSON(@ptrCast(*const IHTMLPerformanceNavigation, self), pVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPerformanceTiming_Value = @import("../zig.zig").Guid.initString("30510752-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPerformanceTiming = &IID_IHTMLPerformanceTiming_Value;
pub const IHTMLPerformanceTiming = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_navigationStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unloadEventStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unloadEventEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_redirectStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_redirectEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fetchStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_domainLookupStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_domainLookupEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_connectStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_connectEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_requestStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_responseStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_responseEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_domLoading: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_domInteractive: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_domContentLoadedEventStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_domContentLoadedEventEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_domComplete: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_loadEventStart: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_loadEventEnd: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_msFirstPaint: fn(
            self: *const IHTMLPerformanceTiming,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLPerformanceTiming,
            string: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toJSON: fn(
            self: *const IHTMLPerformanceTiming,
            pVar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_navigationStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_navigationStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_unloadEventStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_unloadEventStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_unloadEventEnd(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_unloadEventEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_redirectStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_redirectStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_redirectEnd(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_redirectEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_fetchStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_fetchStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domainLookupStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domainLookupStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domainLookupEnd(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domainLookupEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_connectStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_connectStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_connectEnd(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_connectEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_requestStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_requestStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_responseStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_responseStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_responseEnd(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_responseEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domLoading(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domLoading(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domInteractive(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domInteractive(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domContentLoadedEventStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domContentLoadedEventStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domContentLoadedEventEnd(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domContentLoadedEventEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_domComplete(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_domComplete(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_loadEventStart(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_loadEventStart(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_loadEventEnd(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_loadEventEnd(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_get_msFirstPaint(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).get_msFirstPaint(@ptrCast(*const IHTMLPerformanceTiming, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_toString(self: *const T, string: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).toString(@ptrCast(*const IHTMLPerformanceTiming, self), string);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPerformanceTiming_toJSON(self: *const T, pVar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPerformanceTiming.VTable, self.vtable).toJSON(@ptrCast(*const IHTMLPerformanceTiming, self), pVar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPerformance_Value = @import("../zig.zig").Guid.initString("3059009F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLPerformance = &IID_DispHTMLPerformance_Value;
pub const DispHTMLPerformance = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPerformanceNavigation_Value = @import("../zig.zig").Guid.initString("305900A0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLPerformanceNavigation = &IID_DispHTMLPerformanceNavigation_Value;
pub const DispHTMLPerformanceNavigation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPerformanceTiming_Value = @import("../zig.zig").Guid.initString("305900A1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLPerformanceTiming = &IID_DispHTMLPerformanceTiming_Value;
pub const DispHTMLPerformanceTiming = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTSpanElement_Value = @import("../zig.zig").Guid.initString("3051051D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTSpanElement = &IID_ISVGTSpanElement_Value;
pub const ISVGTSpanElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTSpanElement_Value = @import("../zig.zig").Guid.initString("3059003A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGTSpanElement = &IID_DispSVGTSpanElement_Value;
pub const DispSVGTSpanElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITemplatePrinter_Value = @import("../zig.zig").Guid.initString("3050F6B4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ITemplatePrinter = &IID_ITemplatePrinter_Value;
pub const ITemplatePrinter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        startDoc: fn(
            self: *const ITemplatePrinter,
            bstrTitle: BSTR,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        stopDoc: fn(
            self: *const ITemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        printBlankPage: fn(
            self: *const ITemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        printPage: fn(
            self: *const ITemplatePrinter,
            pElemDisp: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ensurePrintDialogDefaults: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showPrintDialog: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        showPageSetupDialog: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        printNonNative: fn(
            self: *const ITemplatePrinter,
            pMarkup: *IUnknown,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        printNonNativeFrames: fn(
            self: *const ITemplatePrinter,
            pMarkup: *IUnknown,
            fActiveFrame: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_framesetDocument: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_framesetDocument: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frameActive: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameActive: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frameAsShown: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameAsShown: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_selection: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selection: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_selectedPages: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectedPages: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_currentPage: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentPage: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_currentPageAvail: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentPageAvail: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_collate: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_collate: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_duplex: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_copies: fn(
            self: *const ITemplatePrinter,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_copies: fn(
            self: *const ITemplatePrinter,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageFrom: fn(
            self: *const ITemplatePrinter,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageFrom: fn(
            self: *const ITemplatePrinter,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_pageTo: fn(
            self: *const ITemplatePrinter,
            v: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageTo: fn(
            self: *const ITemplatePrinter,
            p: *u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_tableOfLinks: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tableOfLinks: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_allLinkedDocuments: fn(
            self: *const ITemplatePrinter,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_allLinkedDocuments: fn(
            self: *const ITemplatePrinter,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_header: fn(
            self: *const ITemplatePrinter,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_header: fn(
            self: *const ITemplatePrinter,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_footer: fn(
            self: *const ITemplatePrinter,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_footer: fn(
            self: *const ITemplatePrinter,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginLeft: fn(
            self: *const ITemplatePrinter,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginLeft: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginRight: fn(
            self: *const ITemplatePrinter,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginRight: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginTop: fn(
            self: *const ITemplatePrinter,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginTop: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_marginBottom: fn(
            self: *const ITemplatePrinter,
            v: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_marginBottom: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageWidth: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_pageHeight: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unprintableLeft: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unprintableTop: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unprintableRight: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unprintableBottom: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        updatePageStatus: fn(
            self: *const ITemplatePrinter,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_startDoc(self: *const T, bstrTitle: BSTR, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).startDoc(@ptrCast(*const ITemplatePrinter, self), bstrTitle, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_stopDoc(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).stopDoc(@ptrCast(*const ITemplatePrinter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_printBlankPage(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).printBlankPage(@ptrCast(*const ITemplatePrinter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_printPage(self: *const T, pElemDisp: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).printPage(@ptrCast(*const ITemplatePrinter, self), pElemDisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_ensurePrintDialogDefaults(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).ensurePrintDialogDefaults(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_showPrintDialog(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).showPrintDialog(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_showPageSetupDialog(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).showPageSetupDialog(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_printNonNative(self: *const T, pMarkup: *IUnknown, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).printNonNative(@ptrCast(*const ITemplatePrinter, self), pMarkup, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_printNonNativeFrames(self: *const T, pMarkup: *IUnknown, fActiveFrame: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).printNonNativeFrames(@ptrCast(*const ITemplatePrinter, self), pMarkup, fActiveFrame);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_framesetDocument(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_framesetDocument(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_framesetDocument(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_framesetDocument(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_frameActive(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_frameActive(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_frameActive(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_frameActive(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_frameAsShown(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_frameAsShown(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_frameAsShown(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_frameAsShown(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_selection(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_selection(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_selection(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_selection(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_selectedPages(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_selectedPages(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_selectedPages(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_selectedPages(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_currentPage(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_currentPage(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_currentPage(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_currentPage(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_currentPageAvail(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_currentPageAvail(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_currentPageAvail(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_currentPageAvail(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_collate(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_collate(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_collate(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_collate(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_duplex(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_duplex(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_copies(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_copies(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_copies(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_copies(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_pageFrom(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_pageFrom(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_pageFrom(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_pageFrom(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_pageTo(self: *const T, v: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_pageTo(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_pageTo(self: *const T, p: *u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_pageTo(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_tableOfLinks(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_tableOfLinks(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_tableOfLinks(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_tableOfLinks(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_allLinkedDocuments(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_allLinkedDocuments(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_allLinkedDocuments(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_allLinkedDocuments(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_header(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_header(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_header(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_header(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_footer(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_footer(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_footer(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_footer(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_marginLeft(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_marginLeft(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_marginLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_marginLeft(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_marginRight(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_marginRight(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_marginRight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_marginRight(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_marginTop(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_marginTop(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_marginTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_marginTop(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_put_marginBottom(self: *const T, v: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).put_marginBottom(@ptrCast(*const ITemplatePrinter, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_marginBottom(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_marginBottom(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_pageWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_pageWidth(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_pageHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_pageHeight(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_unprintableLeft(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_unprintableLeft(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_unprintableTop(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_unprintableTop(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_unprintableRight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_unprintableRight(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_get_unprintableBottom(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).get_unprintableBottom(@ptrCast(*const ITemplatePrinter, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter_updatePageStatus(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter.VTable, self.vtable).updatePageStatus(@ptrCast(*const ITemplatePrinter, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITemplatePrinter2_Value = @import("../zig.zig").Guid.initString("3050F83F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ITemplatePrinter2 = &IID_ITemplatePrinter2_Value;
pub const ITemplatePrinter2 = extern struct {
    pub const VTable = extern struct {
        base: ITemplatePrinter.VTable,
        put_selectionEnabled: fn(
            self: *const ITemplatePrinter2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selectionEnabled: fn(
            self: *const ITemplatePrinter2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_frameActiveEnabled: fn(
            self: *const ITemplatePrinter2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_frameActiveEnabled: fn(
            self: *const ITemplatePrinter2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_orientation: fn(
            self: *const ITemplatePrinter2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_orientation: fn(
            self: *const ITemplatePrinter2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_usePrinterCopyCollate: fn(
            self: *const ITemplatePrinter2,
            v: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_usePrinterCopyCollate: fn(
            self: *const ITemplatePrinter2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        deviceSupports: fn(
            self: *const ITemplatePrinter2,
            bstrProperty: BSTR,
            pvar: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITemplatePrinter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_put_selectionEnabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).put_selectionEnabled(@ptrCast(*const ITemplatePrinter2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_get_selectionEnabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).get_selectionEnabled(@ptrCast(*const ITemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_put_frameActiveEnabled(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).put_frameActiveEnabled(@ptrCast(*const ITemplatePrinter2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_get_frameActiveEnabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).get_frameActiveEnabled(@ptrCast(*const ITemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_put_orientation(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).put_orientation(@ptrCast(*const ITemplatePrinter2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_get_orientation(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).get_orientation(@ptrCast(*const ITemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_put_usePrinterCopyCollate(self: *const T, v: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).put_usePrinterCopyCollate(@ptrCast(*const ITemplatePrinter2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_get_usePrinterCopyCollate(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).get_usePrinterCopyCollate(@ptrCast(*const ITemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter2_deviceSupports(self: *const T, bstrProperty: BSTR, pvar: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter2.VTable, self.vtable).deviceSupports(@ptrCast(*const ITemplatePrinter2, self), bstrProperty, pvar);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITemplatePrinter3_Value = @import("../zig.zig").Guid.initString("305104A3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ITemplatePrinter3 = &IID_ITemplatePrinter3_Value;
pub const ITemplatePrinter3 = extern struct {
    pub const VTable = extern struct {
        base: ITemplatePrinter2.VTable,
        put_headerFooterFont: fn(
            self: *const ITemplatePrinter3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_headerFooterFont: fn(
            self: *const ITemplatePrinter3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginTop: fn(
            self: *const ITemplatePrinter3,
            pageRule: *IDispatch,
            pageWidth: i32,
            pageHeight: i32,
            pMargin: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginRight: fn(
            self: *const ITemplatePrinter3,
            pageRule: *IDispatch,
            pageWidth: i32,
            pageHeight: i32,
            pMargin: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginBottom: fn(
            self: *const ITemplatePrinter3,
            pageRule: *IDispatch,
            pageWidth: i32,
            pageHeight: i32,
            pMargin: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginLeft: fn(
            self: *const ITemplatePrinter3,
            pageRule: *IDispatch,
            pageWidth: i32,
            pageHeight: i32,
            pMargin: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginTopImportant: fn(
            self: *const ITemplatePrinter3,
            pageRule: *IDispatch,
            pbImportant: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginRightImportant: fn(
            self: *const ITemplatePrinter3,
            pageRule: *IDispatch,
            pbImportant: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginBottomImportant: fn(
            self: *const ITemplatePrinter3,
            pageRule: *IDispatch,
            pbImportant: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPageMarginLeftImportant: fn(
            self: *const ITemplatePrinter3,
            pageRule: *IDispatch,
            pbImportant: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITemplatePrinter2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_put_headerFooterFont(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).put_headerFooterFont(@ptrCast(*const ITemplatePrinter3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_get_headerFooterFont(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).get_headerFooterFont(@ptrCast(*const ITemplatePrinter3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginTop(self: *const T, pageRule: *IDispatch, pageWidth: i32, pageHeight: i32, pMargin: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginTop(@ptrCast(*const ITemplatePrinter3, self), pageRule, pageWidth, pageHeight, pMargin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginRight(self: *const T, pageRule: *IDispatch, pageWidth: i32, pageHeight: i32, pMargin: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginRight(@ptrCast(*const ITemplatePrinter3, self), pageRule, pageWidth, pageHeight, pMargin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginBottom(self: *const T, pageRule: *IDispatch, pageWidth: i32, pageHeight: i32, pMargin: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginBottom(@ptrCast(*const ITemplatePrinter3, self), pageRule, pageWidth, pageHeight, pMargin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginLeft(self: *const T, pageRule: *IDispatch, pageWidth: i32, pageHeight: i32, pMargin: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginLeft(@ptrCast(*const ITemplatePrinter3, self), pageRule, pageWidth, pageHeight, pMargin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginTopImportant(self: *const T, pageRule: *IDispatch, pbImportant: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginTopImportant(@ptrCast(*const ITemplatePrinter3, self), pageRule, pbImportant);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginRightImportant(self: *const T, pageRule: *IDispatch, pbImportant: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginRightImportant(@ptrCast(*const ITemplatePrinter3, self), pageRule, pbImportant);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginBottomImportant(self: *const T, pageRule: *IDispatch, pbImportant: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginBottomImportant(@ptrCast(*const ITemplatePrinter3, self), pageRule, pbImportant);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITemplatePrinter3_getPageMarginLeftImportant(self: *const T, pageRule: *IDispatch, pbImportant: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITemplatePrinter3.VTable, self.vtable).getPageMarginLeftImportant(@ptrCast(*const ITemplatePrinter3, self), pageRule, pbImportant);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPrintManagerTemplatePrinter_Value = @import("../zig.zig").Guid.initString("F633BE14-9EFF-4C4D-929E-05717B21B3E6");
pub const IID_IPrintManagerTemplatePrinter = &IID_IPrintManagerTemplatePrinter_Value;
pub const IPrintManagerTemplatePrinter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        startPrint: fn(
            self: *const IPrintManagerTemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        drawPreviewPage: fn(
            self: *const IPrintManagerTemplatePrinter,
            pElemDisp: *IDispatch,
            nPage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        setPageCount: fn(
            self: *const IPrintManagerTemplatePrinter,
            nPage: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        invalidatePreview: fn(
            self: *const IPrintManagerTemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getPrintTaskOptionValue: fn(
            self: *const IPrintManagerTemplatePrinter,
            bstrKey: BSTR,
            pvarin: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        endPrint: fn(
            self: *const IPrintManagerTemplatePrinter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_startPrint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).startPrint(@ptrCast(*const IPrintManagerTemplatePrinter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_drawPreviewPage(self: *const T, pElemDisp: *IDispatch, nPage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).drawPreviewPage(@ptrCast(*const IPrintManagerTemplatePrinter, self), pElemDisp, nPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_setPageCount(self: *const T, nPage: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).setPageCount(@ptrCast(*const IPrintManagerTemplatePrinter, self), nPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_invalidatePreview(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).invalidatePreview(@ptrCast(*const IPrintManagerTemplatePrinter, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_getPrintTaskOptionValue(self: *const T, bstrKey: BSTR, pvarin: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).getPrintTaskOptionValue(@ptrCast(*const IPrintManagerTemplatePrinter, self), bstrKey, pvarin);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter_endPrint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter.VTable, self.vtable).endPrint(@ptrCast(*const IPrintManagerTemplatePrinter, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPrintManagerTemplatePrinter2_Value = @import("../zig.zig").Guid.initString("C6403497-7493-4F09-8016-54B03E9BDA69");
pub const IID_IPrintManagerTemplatePrinter2 = &IID_IPrintManagerTemplatePrinter2_Value;
pub const IPrintManagerTemplatePrinter2 = extern struct {
    pub const VTable = extern struct {
        base: IPrintManagerTemplatePrinter.VTable,
        get_showHeaderFooter: fn(
            self: *const IPrintManagerTemplatePrinter2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_shrinkToFit: fn(
            self: *const IPrintManagerTemplatePrinter2,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_percentScale: fn(
            self: *const IPrintManagerTemplatePrinter2,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IPrintManagerTemplatePrinter.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter2_get_showHeaderFooter(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter2.VTable, self.vtable).get_showHeaderFooter(@ptrCast(*const IPrintManagerTemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter2_get_shrinkToFit(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter2.VTable, self.vtable).get_shrinkToFit(@ptrCast(*const IPrintManagerTemplatePrinter2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPrintManagerTemplatePrinter2_get_percentScale(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPrintManagerTemplatePrinter2.VTable, self.vtable).get_percentScale(@ptrCast(*const IPrintManagerTemplatePrinter2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispCPrintManagerTemplatePrinter_Value = @import("../zig.zig").Guid.initString("305900E9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispCPrintManagerTemplatePrinter = &IID_DispCPrintManagerTemplatePrinter_Value;
pub const DispCPrintManagerTemplatePrinter = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISVGTextPathElement_Value = @import("../zig.zig").Guid.initString("3051051F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISVGTextPathElement = &IID_ISVGTextPathElement_Value;
pub const ISVGTextPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        putref_startOffset: fn(
            self: *const ISVGTextPathElement,
            v: *ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_startOffset: fn(
            self: *const ISVGTextPathElement,
            p: **ISVGAnimatedLength,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_method: fn(
            self: *const ISVGTextPathElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_method: fn(
            self: *const ISVGTextPathElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        putref_spacing: fn(
            self: *const ISVGTextPathElement,
            v: *ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_spacing: fn(
            self: *const ISVGTextPathElement,
            p: **ISVGAnimatedEnumeration,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_putref_startOffset(self: *const T, v: *ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).putref_startOffset(@ptrCast(*const ISVGTextPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_get_startOffset(self: *const T, p: **ISVGAnimatedLength) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).get_startOffset(@ptrCast(*const ISVGTextPathElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_putref_method(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).putref_method(@ptrCast(*const ISVGTextPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_get_method(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).get_method(@ptrCast(*const ISVGTextPathElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_putref_spacing(self: *const T, v: *ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).putref_spacing(@ptrCast(*const ISVGTextPathElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISVGTextPathElement_get_spacing(self: *const T, p: **ISVGAnimatedEnumeration) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISVGTextPathElement.VTable, self.vtable).get_spacing(@ptrCast(*const ISVGTextPathElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispSVGTextPathElement_Value = @import("../zig.zig").Guid.initString("3059003D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispSVGTextPathElement = &IID_DispSVGTextPathElement_Value;
pub const DispSVGTextPathElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMXmlSerializer_Value = @import("../zig.zig").Guid.initString("3051077D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMXmlSerializer = &IID_IDOMXmlSerializer_Value;
pub const IDOMXmlSerializer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        serializeToString: fn(
            self: *const IDOMXmlSerializer,
            pNode: *IHTMLDOMNode,
            pString: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMXmlSerializer_serializeToString(self: *const T, pNode: *IHTMLDOMNode, pString: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMXmlSerializer.VTable, self.vtable).serializeToString(@ptrCast(*const IDOMXmlSerializer, self), pNode, pString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMParser_Value = @import("../zig.zig").Guid.initString("30510781-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMParser = &IID_IDOMParser_Value;
pub const IDOMParser = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        parseFromString: fn(
            self: *const IDOMParser,
            xmlSource: BSTR,
            mimeType: BSTR,
            ppNode: **IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMParser_parseFromString(self: *const T, xmlSource: BSTR, mimeType: BSTR, ppNode: **IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMParser.VTable, self.vtable).parseFromString(@ptrCast(*const IDOMParser, self), xmlSource, mimeType, ppNode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispXMLSerializer_Value = @import("../zig.zig").Guid.initString("305900AD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispXMLSerializer = &IID_DispXMLSerializer_Value;
pub const DispXMLSerializer = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMParser_Value = @import("../zig.zig").Guid.initString("305900AE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMParser = &IID_DispDOMParser_Value;
pub const DispDOMParser = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMXmlSerializerFactory_Value = @import("../zig.zig").Guid.initString("3051077F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMXmlSerializerFactory = &IID_IDOMXmlSerializerFactory_Value;
pub const IDOMXmlSerializerFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IDOMXmlSerializerFactory,
            __MIDL__IDOMXmlSerializerFactory0000: **IDOMXmlSerializer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMXmlSerializerFactory_create(self: *const T, __MIDL__IDOMXmlSerializerFactory0000: **IDOMXmlSerializer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMXmlSerializerFactory.VTable, self.vtable).create(@ptrCast(*const IDOMXmlSerializerFactory, self), __MIDL__IDOMXmlSerializerFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMParserFactory_Value = @import("../zig.zig").Guid.initString("30510783-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMParserFactory = &IID_IDOMParserFactory_Value;
pub const IDOMParserFactory = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        create: fn(
            self: *const IDOMParserFactory,
            __MIDL__IDOMParserFactory0000: **IDOMParser,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMParserFactory_create(self: *const T, __MIDL__IDOMParserFactory0000: **IDOMParser) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMParserFactory.VTable, self.vtable).create(@ptrCast(*const IDOMParserFactory, self), __MIDL__IDOMParserFactory0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLSemanticElement_Value = @import("../zig.zig").Guid.initString("305900BA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLSemanticElement = &IID_DispHTMLSemanticElement_Value;
pub const DispHTMLSemanticElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLProgressElement_Value = @import("../zig.zig").Guid.initString("3050F2D6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLProgressElement = &IID_IHTMLProgressElement_Value;
pub const IHTMLProgressElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_value: fn(
            self: *const IHTMLProgressElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_value: fn(
            self: *const IHTMLProgressElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_max: fn(
            self: *const IHTMLProgressElement,
            v: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_max: fn(
            self: *const IHTMLProgressElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_position: fn(
            self: *const IHTMLProgressElement,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_form: fn(
            self: *const IHTMLProgressElement,
            p: **IHTMLFormElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_put_value(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).put_value(@ptrCast(*const IHTMLProgressElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_get_value(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).get_value(@ptrCast(*const IHTMLProgressElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_put_max(self: *const T, v: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).put_max(@ptrCast(*const IHTMLProgressElement, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_get_max(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).get_max(@ptrCast(*const IHTMLProgressElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_get_position(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).get_position(@ptrCast(*const IHTMLProgressElement, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLProgressElement_get_form(self: *const T, p: **IHTMLFormElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLProgressElement.VTable, self.vtable).get_form(@ptrCast(*const IHTMLProgressElement, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLProgressElement_Value = @import("../zig.zig").Guid.initString("305900AF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLProgressElement = &IID_DispHTMLProgressElement_Value;
pub const DispHTMLProgressElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMSTransitionEvent_Value = @import("../zig.zig").Guid.initString("305107B5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMMSTransitionEvent = &IID_IDOMMSTransitionEvent_Value;
pub const IDOMMSTransitionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_propertyName: fn(
            self: *const IDOMMSTransitionEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_elapsedTime: fn(
            self: *const IDOMMSTransitionEvent,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMSTransitionEvent: fn(
            self: *const IDOMMSTransitionEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            propertyName: BSTR,
            elapsedTime: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSTransitionEvent_get_propertyName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSTransitionEvent.VTable, self.vtable).get_propertyName(@ptrCast(*const IDOMMSTransitionEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSTransitionEvent_get_elapsedTime(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSTransitionEvent.VTable, self.vtable).get_elapsedTime(@ptrCast(*const IDOMMSTransitionEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSTransitionEvent_initMSTransitionEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, propertyName: BSTR, elapsedTime: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSTransitionEvent.VTable, self.vtable).initMSTransitionEvent(@ptrCast(*const IDOMMSTransitionEvent, self), eventType, canBubble, cancelable, propertyName, elapsedTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMSTransitionEvent_Value = @import("../zig.zig").Guid.initString("305900BB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMMSTransitionEvent = &IID_DispDOMMSTransitionEvent_Value;
pub const DispDOMMSTransitionEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMSAnimationEvent_Value = @import("../zig.zig").Guid.initString("305107B7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMMSAnimationEvent = &IID_IDOMMSAnimationEvent_Value;
pub const IDOMMSAnimationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_animationName: fn(
            self: *const IDOMMSAnimationEvent,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_elapsedTime: fn(
            self: *const IDOMMSAnimationEvent,
            p: *f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMSAnimationEvent: fn(
            self: *const IDOMMSAnimationEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            animationName: BSTR,
            elapsedTime: f32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSAnimationEvent_get_animationName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSAnimationEvent.VTable, self.vtable).get_animationName(@ptrCast(*const IDOMMSAnimationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSAnimationEvent_get_elapsedTime(self: *const T, p: *f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSAnimationEvent.VTable, self.vtable).get_elapsedTime(@ptrCast(*const IDOMMSAnimationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSAnimationEvent_initMSAnimationEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, animationName: BSTR, elapsedTime: f32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSAnimationEvent.VTable, self.vtable).initMSAnimationEvent(@ptrCast(*const IDOMMSAnimationEvent, self), eventType, canBubble, cancelable, animationName, elapsedTime);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMSAnimationEvent_Value = @import("../zig.zig").Guid.initString("305900BC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMMSAnimationEvent = &IID_DispDOMMSAnimationEvent_Value;
pub const DispDOMMSAnimationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebGeocoordinates_Value = @import("../zig.zig").Guid.initString("305107C7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IWebGeocoordinates = &IID_IWebGeocoordinates_Value;
pub const IWebGeocoordinates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_latitude: fn(
            self: *const IWebGeocoordinates,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_longitude: fn(
            self: *const IWebGeocoordinates,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_altitude: fn(
            self: *const IWebGeocoordinates,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_accuracy: fn(
            self: *const IWebGeocoordinates,
            p: *f64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_altitudeAccuracy: fn(
            self: *const IWebGeocoordinates,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_heading: fn(
            self: *const IWebGeocoordinates,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_speed: fn(
            self: *const IWebGeocoordinates,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_latitude(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_latitude(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_longitude(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_longitude(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_altitude(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_altitude(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_accuracy(self: *const T, p: *f64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_accuracy(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_altitudeAccuracy(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_altitudeAccuracy(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_heading(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_heading(@ptrCast(*const IWebGeocoordinates, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeocoordinates_get_speed(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeocoordinates.VTable, self.vtable).get_speed(@ptrCast(*const IWebGeocoordinates, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebGeopositionError_Value = @import("../zig.zig").Guid.initString("305107C9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IWebGeopositionError = &IID_IWebGeopositionError_Value;
pub const IWebGeopositionError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_code: fn(
            self: *const IWebGeopositionError,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_message: fn(
            self: *const IWebGeopositionError,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeopositionError_get_code(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeopositionError.VTable, self.vtable).get_code(@ptrCast(*const IWebGeopositionError, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeopositionError_get_message(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeopositionError.VTable, self.vtable).get_message(@ptrCast(*const IWebGeopositionError, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebGeoposition_Value = @import("../zig.zig").Guid.initString("305107CD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IWebGeoposition = &IID_IWebGeoposition_Value;
pub const IWebGeoposition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_coords: fn(
            self: *const IWebGeoposition,
            p: **IWebGeocoordinates,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_timestamp: fn(
            self: *const IWebGeoposition,
            p: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeoposition_get_coords(self: *const T, p: **IWebGeocoordinates) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeoposition.VTable, self.vtable).get_coords(@ptrCast(*const IWebGeoposition, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebGeoposition_get_timestamp(self: *const T, p: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebGeoposition.VTable, self.vtable).get_timestamp(@ptrCast(*const IWebGeoposition, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispWebGeolocation_Value = @import("../zig.zig").Guid.initString("305900BD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispWebGeolocation = &IID_DispWebGeolocation_Value;
pub const DispWebGeolocation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispWebGeocoordinates_Value = @import("../zig.zig").Guid.initString("305900BE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispWebGeocoordinates = &IID_DispWebGeocoordinates_Value;
pub const DispWebGeocoordinates = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispWebGeopositionError_Value = @import("../zig.zig").Guid.initString("305900BF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispWebGeopositionError = &IID_DispWebGeopositionError_Value;
pub const DispWebGeopositionError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispWebGeoposition_Value = @import("../zig.zig").Guid.initString("305900C1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispWebGeoposition = &IID_DispWebGeoposition_Value;
pub const DispWebGeoposition = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IClientCaps_Value = @import("../zig.zig").Guid.initString("7E8BC44D-AEFF-11D1-89C2-00C04FB6BFC4");
pub const IID_IClientCaps = &IID_IClientCaps_Value;
pub const IClientCaps = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_javaEnabled: fn(
            self: *const IClientCaps,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cookieEnabled: fn(
            self: *const IClientCaps,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_cpuClass: fn(
            self: *const IClientCaps,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_systemLanguage: fn(
            self: *const IClientCaps,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_userLanguage: fn(
            self: *const IClientCaps,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_platform: fn(
            self: *const IClientCaps,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_connectionSpeed: fn(
            self: *const IClientCaps,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onLine: fn(
            self: *const IClientCaps,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_colorDepth: fn(
            self: *const IClientCaps,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_bufferDepth: fn(
            self: *const IClientCaps,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_width: fn(
            self: *const IClientCaps,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_height: fn(
            self: *const IClientCaps,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_availHeight: fn(
            self: *const IClientCaps,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_availWidth: fn(
            self: *const IClientCaps,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_connectionType: fn(
            self: *const IClientCaps,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        isComponentInstalled: fn(
            self: *const IClientCaps,
            bstrName: BSTR,
            bstrUrl: BSTR,
            bStrVer: BSTR,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getComponentVersion: fn(
            self: *const IClientCaps,
            bstrName: BSTR,
            bstrUrl: BSTR,
            pbstrVer: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        compareVersions: fn(
            self: *const IClientCaps,
            bstrVer1: BSTR,
            bstrVer2: BSTR,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        addComponentRequest: fn(
            self: *const IClientCaps,
            bstrName: BSTR,
            bstrUrl: BSTR,
            bStrVer: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doComponentRequest: fn(
            self: *const IClientCaps,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        clearComponentRequest: fn(
            self: *const IClientCaps,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_javaEnabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_javaEnabled(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_cookieEnabled(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_cookieEnabled(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_cpuClass(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_cpuClass(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_systemLanguage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_systemLanguage(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_userLanguage(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_userLanguage(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_platform(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_platform(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_connectionSpeed(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_connectionSpeed(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_onLine(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_onLine(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_colorDepth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_colorDepth(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_bufferDepth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_bufferDepth(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_width(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_width(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_height(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_height(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_availHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_availHeight(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_availWidth(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_availWidth(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_get_connectionType(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).get_connectionType(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_isComponentInstalled(self: *const T, bstrName: BSTR, bstrUrl: BSTR, bStrVer: BSTR, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).isComponentInstalled(@ptrCast(*const IClientCaps, self), bstrName, bstrUrl, bStrVer, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_getComponentVersion(self: *const T, bstrName: BSTR, bstrUrl: BSTR, pbstrVer: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).getComponentVersion(@ptrCast(*const IClientCaps, self), bstrName, bstrUrl, pbstrVer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_compareVersions(self: *const T, bstrVer1: BSTR, bstrVer2: BSTR, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).compareVersions(@ptrCast(*const IClientCaps, self), bstrVer1, bstrVer2, p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_addComponentRequest(self: *const T, bstrName: BSTR, bstrUrl: BSTR, bStrVer: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).addComponentRequest(@ptrCast(*const IClientCaps, self), bstrName, bstrUrl, bStrVer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_doComponentRequest(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).doComponentRequest(@ptrCast(*const IClientCaps, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IClientCaps_clearComponentRequest(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IClientCaps.VTable, self.vtable).clearComponentRequest(@ptrCast(*const IClientCaps, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMMSManipulationEvent_Value = @import("../zig.zig").Guid.initString("30510816-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMMSManipulationEvent = &IID_IDOMMSManipulationEvent_Value;
pub const IDOMMSManipulationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_lastState: fn(
            self: *const IDOMMSManipulationEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_currentState: fn(
            self: *const IDOMMSManipulationEvent,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initMSManipulationEvent: fn(
            self: *const IDOMMSManipulationEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            viewArg: *IHTMLWindow2,
            detailArg: i32,
            lastState: i32,
            currentState: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSManipulationEvent_get_lastState(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSManipulationEvent.VTable, self.vtable).get_lastState(@ptrCast(*const IDOMMSManipulationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSManipulationEvent_get_currentState(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSManipulationEvent.VTable, self.vtable).get_currentState(@ptrCast(*const IDOMMSManipulationEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMMSManipulationEvent_initMSManipulationEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, viewArg: *IHTMLWindow2, detailArg: i32, lastState: i32, currentState: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMMSManipulationEvent.VTable, self.vtable).initMSManipulationEvent(@ptrCast(*const IDOMMSManipulationEvent, self), eventType, canBubble, cancelable, viewArg, detailArg, lastState, currentState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMMSManipulationEvent_Value = @import("../zig.zig").Guid.initString("305900E1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMMSManipulationEvent = &IID_DispDOMMSManipulationEvent_Value;
pub const DispDOMMSManipulationEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMCloseEvent_Value = @import("../zig.zig").Guid.initString("305107FF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMCloseEvent = &IID_IDOMCloseEvent_Value;
pub const IDOMCloseEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_wasClean: fn(
            self: *const IDOMCloseEvent,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        initCloseEvent: fn(
            self: *const IDOMCloseEvent,
            eventType: BSTR,
            canBubble: i16,
            cancelable: i16,
            wasClean: i16,
            code: i32,
            reason: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCloseEvent_get_wasClean(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCloseEvent.VTable, self.vtable).get_wasClean(@ptrCast(*const IDOMCloseEvent, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMCloseEvent_initCloseEvent(self: *const T, eventType: BSTR, canBubble: i16, cancelable: i16, wasClean: i16, code: i32, reason: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMCloseEvent.VTable, self.vtable).initCloseEvent(@ptrCast(*const IDOMCloseEvent, self), eventType, canBubble, cancelable, wasClean, code, reason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispDOMCloseEvent_Value = @import("../zig.zig").Guid.initString("305900DC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispDOMCloseEvent = &IID_DispDOMCloseEvent_Value;
pub const DispDOMCloseEvent = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispApplicationCache_Value = @import("../zig.zig").Guid.initString("305900E4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispApplicationCache = &IID_DispApplicationCache_Value;
pub const DispApplicationCache = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICSSFilterSite_Value = @import("../zig.zig").Guid.initString("3050F3ED-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ICSSFilterSite = &IID_ICSSFilterSite_Value;
pub const ICSSFilterSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetElement: fn(
            self: *const ICSSFilterSite,
            Element: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FireOnFilterChangeEvent: fn(
            self: *const ICSSFilterSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICSSFilterSite_GetElement(self: *const T, Element: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICSSFilterSite.VTable, self.vtable).GetElement(@ptrCast(*const ICSSFilterSite, self), Element);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICSSFilterSite_FireOnFilterChangeEvent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICSSFilterSite.VTable, self.vtable).FireOnFilterChangeEvent(@ptrCast(*const ICSSFilterSite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupPointer_Value = @import("../zig.zig").Guid.initString("3050F49F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IMarkupPointer = &IID_IMarkupPointer_Value;
pub const IMarkupPointer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OwningDoc: fn(
            self: *const IMarkupPointer,
            ppDoc: **IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Gravity: fn(
            self: *const IMarkupPointer,
            pGravity: *POINTER_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetGravity: fn(
            self: *const IMarkupPointer,
            Gravity: POINTER_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cling: fn(
            self: *const IMarkupPointer,
            pfCling: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCling: fn(
            self: *const IMarkupPointer,
            fCLing: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unposition: fn(
            self: *const IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPositioned: fn(
            self: *const IMarkupPointer,
            pfPositioned: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainer: fn(
            self: *const IMarkupPointer,
            ppContainer: **IMarkupContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveAdjacentToElement: fn(
            self: *const IMarkupPointer,
            pElement: *IHTMLElement,
            eAdj: ELEMENT_ADJACENCY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToPointer: fn(
            self: *const IMarkupPointer,
            pPointer: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToContainer: fn(
            self: *const IMarkupPointer,
            pContainer: *IMarkupContainer,
            fAtStart: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Left: fn(
            self: *const IMarkupPointer,
            fMove: BOOL,
            pContext: *MARKUP_CONTEXT_TYPE,
            ppElement: **IHTMLElement,
            pcch: *i32,
            pchText: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Right: fn(
            self: *const IMarkupPointer,
            fMove: BOOL,
            pContext: *MARKUP_CONTEXT_TYPE,
            ppElement: **IHTMLElement,
            pcch: *i32,
            pchText: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CurrentScope: fn(
            self: *const IMarkupPointer,
            ppElemCurrent: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsLeftOf: fn(
            self: *const IMarkupPointer,
            pPointerThat: *IMarkupPointer,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsLeftOfOrEqualTo: fn(
            self: *const IMarkupPointer,
            pPointerThat: *IMarkupPointer,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRightOf: fn(
            self: *const IMarkupPointer,
            pPointerThat: *IMarkupPointer,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRightOfOrEqualTo: fn(
            self: *const IMarkupPointer,
            pPointerThat: *IMarkupPointer,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualTo: fn(
            self: *const IMarkupPointer,
            pPointerThat: *IMarkupPointer,
            pfAreEqual: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUnit: fn(
            self: *const IMarkupPointer,
            muAction: MOVEUNIT_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextA: fn(
            self: *const IMarkupPointer,
            pchFindText: PWSTR,
            dwFlags: u32,
            pIEndMatch: *IMarkupPointer,
            pIEndSearch: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_OwningDoc(self: *const T, ppDoc: **IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).OwningDoc(@ptrCast(*const IMarkupPointer, self), ppDoc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Gravity(self: *const T, pGravity: *POINTER_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Gravity(@ptrCast(*const IMarkupPointer, self), pGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_SetGravity(self: *const T, Gravity: POINTER_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).SetGravity(@ptrCast(*const IMarkupPointer, self), Gravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Cling(self: *const T, pfCling: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Cling(@ptrCast(*const IMarkupPointer, self), pfCling);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_SetCling(self: *const T, fCLing: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).SetCling(@ptrCast(*const IMarkupPointer, self), fCLing);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Unposition(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Unposition(@ptrCast(*const IMarkupPointer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsPositioned(self: *const T, pfPositioned: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsPositioned(@ptrCast(*const IMarkupPointer, self), pfPositioned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_GetContainer(self: *const T, ppContainer: **IMarkupContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).GetContainer(@ptrCast(*const IMarkupPointer, self), ppContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_MoveAdjacentToElement(self: *const T, pElement: *IHTMLElement, eAdj: ELEMENT_ADJACENCY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).MoveAdjacentToElement(@ptrCast(*const IMarkupPointer, self), pElement, eAdj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_MoveToPointer(self: *const T, pPointer: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).MoveToPointer(@ptrCast(*const IMarkupPointer, self), pPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_MoveToContainer(self: *const T, pContainer: *IMarkupContainer, fAtStart: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).MoveToContainer(@ptrCast(*const IMarkupPointer, self), pContainer, fAtStart);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Left(self: *const T, fMove: BOOL, pContext: *MARKUP_CONTEXT_TYPE, ppElement: **IHTMLElement, pcch: *i32, pchText: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Left(@ptrCast(*const IMarkupPointer, self), fMove, pContext, ppElement, pcch, pchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_Right(self: *const T, fMove: BOOL, pContext: *MARKUP_CONTEXT_TYPE, ppElement: **IHTMLElement, pcch: *i32, pchText: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).Right(@ptrCast(*const IMarkupPointer, self), fMove, pContext, ppElement, pcch, pchText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_CurrentScope(self: *const T, ppElemCurrent: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).CurrentScope(@ptrCast(*const IMarkupPointer, self), ppElemCurrent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsLeftOf(self: *const T, pPointerThat: *IMarkupPointer, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsLeftOf(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsLeftOfOrEqualTo(self: *const T, pPointerThat: *IMarkupPointer, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsLeftOfOrEqualTo(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsRightOf(self: *const T, pPointerThat: *IMarkupPointer, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsRightOf(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsRightOfOrEqualTo(self: *const T, pPointerThat: *IMarkupPointer, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsRightOfOrEqualTo(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_IsEqualTo(self: *const T, pPointerThat: *IMarkupPointer, pfAreEqual: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).IsEqualTo(@ptrCast(*const IMarkupPointer, self), pPointerThat, pfAreEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_MoveUnit(self: *const T, muAction: MOVEUNIT_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).MoveUnit(@ptrCast(*const IMarkupPointer, self), muAction);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer_FindTextA(self: *const T, pchFindText: PWSTR, dwFlags: u32, pIEndMatch: *IMarkupPointer, pIEndSearch: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer.VTable, self.vtable).FindTextA(@ptrCast(*const IMarkupPointer, self), pchFindText, dwFlags, pIEndMatch, pIEndSearch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupContainer_Value = @import("../zig.zig").Guid.initString("3050F5F9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IMarkupContainer = &IID_IMarkupContainer_Value;
pub const IMarkupContainer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OwningDoc: fn(
            self: *const IMarkupContainer,
            ppDoc: **IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer_OwningDoc(self: *const T, ppDoc: **IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer.VTable, self.vtable).OwningDoc(@ptrCast(*const IMarkupContainer, self), ppDoc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupContainer2_Value = @import("../zig.zig").Guid.initString("3050F648-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IMarkupContainer2 = &IID_IMarkupContainer2_Value;
pub const IMarkupContainer2 = extern struct {
    pub const VTable = extern struct {
        base: IMarkupContainer.VTable,
        CreateChangeLog: fn(
            self: *const IMarkupContainer2,
            pChangeSink: *IHTMLChangeSink,
            ppChangeLog: **IHTMLChangeLog,
            fForward: BOOL,
            fBackward: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForDirtyRange: fn(
            self: *const IMarkupContainer2,
            pChangeSink: *IHTMLChangeSink,
            pdwCookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnRegisterForDirtyRange: fn(
            self: *const IMarkupContainer2,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAndClearDirtyRange: fn(
            self: *const IMarkupContainer2,
            dwCookie: u32,
            pIPointerBegin: *IMarkupPointer,
            pIPointerEnd: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersionNumber: fn(
            self: *const IMarkupContainer2,
        ) callconv(@import("std").os.windows.WINAPI) i32,
        GetMasterElement: fn(
            self: *const IMarkupContainer2,
            ppElementMaster: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMarkupContainer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_CreateChangeLog(self: *const T, pChangeSink: *IHTMLChangeSink, ppChangeLog: **IHTMLChangeLog, fForward: BOOL, fBackward: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).CreateChangeLog(@ptrCast(*const IMarkupContainer2, self), pChangeSink, ppChangeLog, fForward, fBackward);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_RegisterForDirtyRange(self: *const T, pChangeSink: *IHTMLChangeSink, pdwCookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).RegisterForDirtyRange(@ptrCast(*const IMarkupContainer2, self), pChangeSink, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_UnRegisterForDirtyRange(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).UnRegisterForDirtyRange(@ptrCast(*const IMarkupContainer2, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_GetAndClearDirtyRange(self: *const T, dwCookie: u32, pIPointerBegin: *IMarkupPointer, pIPointerEnd: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).GetAndClearDirtyRange(@ptrCast(*const IMarkupContainer2, self), dwCookie, pIPointerBegin, pIPointerEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_GetVersionNumber(self: *const T) callconv(.Inline) i32 {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).GetVersionNumber(@ptrCast(*const IMarkupContainer2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupContainer2_GetMasterElement(self: *const T, ppElementMaster: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupContainer2.VTable, self.vtable).GetMasterElement(@ptrCast(*const IMarkupContainer2, self), ppElementMaster);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLChangeLog_Value = @import("../zig.zig").Guid.initString("3050F649-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLChangeLog = &IID_IHTMLChangeLog_Value;
pub const IHTMLChangeLog = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNextChange: fn(
            self: *const IHTMLChangeLog,
            pbBuffer: *u8,
            nBufferSize: i32,
            pnRecordLength: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLChangeLog_GetNextChange(self: *const T, pbBuffer: *u8, nBufferSize: i32, pnRecordLength: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLChangeLog.VTable, self.vtable).GetNextChange(@ptrCast(*const IHTMLChangeLog, self), pbBuffer, nBufferSize, pnRecordLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLChangeSink_Value = @import("../zig.zig").Guid.initString("3050F64A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLChangeSink = &IID_IHTMLChangeSink_Value;
pub const IHTMLChangeSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Notify: fn(
            self: *const IHTMLChangeSink,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLChangeSink_Notify(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLChangeSink.VTable, self.vtable).Notify(@ptrCast(*const IHTMLChangeSink, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISegmentList_Value = @import("../zig.zig").Guid.initString("3050F605-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISegmentList = &IID_ISegmentList_Value;
pub const ISegmentList = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateIterator: fn(
            self: *const ISegmentList,
            ppIIter: **ISegmentListIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const ISegmentList,
            peType: *SELECTION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEmpty: fn(
            self: *const ISegmentList,
            pfEmpty: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentList_CreateIterator(self: *const T, ppIIter: **ISegmentListIterator) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentList.VTable, self.vtable).CreateIterator(@ptrCast(*const ISegmentList, self), ppIIter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentList_GetType(self: *const T, peType: *SELECTION_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentList.VTable, self.vtable).GetType(@ptrCast(*const ISegmentList, self), peType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentList_IsEmpty(self: *const T, pfEmpty: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentList.VTable, self.vtable).IsEmpty(@ptrCast(*const ISegmentList, self), pfEmpty);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISegmentListIterator_Value = @import("../zig.zig").Guid.initString("3050F692-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISegmentListIterator = &IID_ISegmentListIterator_Value;
pub const ISegmentListIterator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Current: fn(
            self: *const ISegmentListIterator,
            ppISegment: **ISegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        First: fn(
            self: *const ISegmentListIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDone: fn(
            self: *const ISegmentListIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advance: fn(
            self: *const ISegmentListIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentListIterator_Current(self: *const T, ppISegment: **ISegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentListIterator.VTable, self.vtable).Current(@ptrCast(*const ISegmentListIterator, self), ppISegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentListIterator_First(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentListIterator.VTable, self.vtable).First(@ptrCast(*const ISegmentListIterator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentListIterator_IsDone(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentListIterator.VTable, self.vtable).IsDone(@ptrCast(*const ISegmentListIterator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegmentListIterator_Advance(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegmentListIterator.VTable, self.vtable).Advance(@ptrCast(*const ISegmentListIterator, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLCaret_Value = @import("../zig.zig").Guid.initString("3050F604-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLCaret = &IID_IHTMLCaret_Value;
pub const IHTMLCaret = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveCaretToPointer: fn(
            self: *const IHTMLCaret,
            pDispPointer: *IDisplayPointer,
            fScrollIntoView: BOOL,
            eDir: CARET_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveCaretToPointerEx: fn(
            self: *const IHTMLCaret,
            pDispPointer: *IDisplayPointer,
            fVisible: BOOL,
            fScrollIntoView: BOOL,
            eDir: CARET_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveMarkupPointerToCaret: fn(
            self: *const IHTMLCaret,
            pIMarkupPointer: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveDisplayPointerToCaret: fn(
            self: *const IHTMLCaret,
            pDispPointer: *IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsVisible: fn(
            self: *const IHTMLCaret,
            pIsVisible: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Show: fn(
            self: *const IHTMLCaret,
            fScrollIntoView: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Hide: fn(
            self: *const IHTMLCaret,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertText: fn(
            self: *const IHTMLCaret,
            pText: PWSTR,
            lLen: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const IHTMLCaret,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocation: fn(
            self: *const IHTMLCaret,
            pPoint: *POINT,
            fTranslate: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaretDirection: fn(
            self: *const IHTMLCaret,
            peDir: *CARET_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCaretDirection: fn(
            self: *const IHTMLCaret,
            eDir: CARET_DIRECTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_MoveCaretToPointer(self: *const T, pDispPointer: *IDisplayPointer, fScrollIntoView: BOOL, eDir: CARET_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).MoveCaretToPointer(@ptrCast(*const IHTMLCaret, self), pDispPointer, fScrollIntoView, eDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_MoveCaretToPointerEx(self: *const T, pDispPointer: *IDisplayPointer, fVisible: BOOL, fScrollIntoView: BOOL, eDir: CARET_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).MoveCaretToPointerEx(@ptrCast(*const IHTMLCaret, self), pDispPointer, fVisible, fScrollIntoView, eDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_MoveMarkupPointerToCaret(self: *const T, pIMarkupPointer: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).MoveMarkupPointerToCaret(@ptrCast(*const IHTMLCaret, self), pIMarkupPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_MoveDisplayPointerToCaret(self: *const T, pDispPointer: *IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).MoveDisplayPointerToCaret(@ptrCast(*const IHTMLCaret, self), pDispPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_IsVisible(self: *const T, pIsVisible: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).IsVisible(@ptrCast(*const IHTMLCaret, self), pIsVisible);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_Show(self: *const T, fScrollIntoView: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).Show(@ptrCast(*const IHTMLCaret, self), fScrollIntoView);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_Hide(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).Hide(@ptrCast(*const IHTMLCaret, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_InsertText(self: *const T, pText: PWSTR, lLen: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).InsertText(@ptrCast(*const IHTMLCaret, self), pText, lLen);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_ScrollIntoView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IHTMLCaret, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_GetLocation(self: *const T, pPoint: *POINT, fTranslate: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).GetLocation(@ptrCast(*const IHTMLCaret, self), pPoint, fTranslate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_GetCaretDirection(self: *const T, peDir: *CARET_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).GetCaretDirection(@ptrCast(*const IHTMLCaret, self), peDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLCaret_SetCaretDirection(self: *const T, eDir: CARET_DIRECTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLCaret.VTable, self.vtable).SetCaretDirection(@ptrCast(*const IHTMLCaret, self), eDir);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISegment_Value = @import("../zig.zig").Guid.initString("3050F683-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISegment = &IID_ISegment_Value;
pub const ISegment = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPointers: fn(
            self: *const ISegment,
            pIStart: *IMarkupPointer,
            pIEnd: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISegment_GetPointers(self: *const T, pIStart: *IMarkupPointer, pIEnd: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISegment.VTable, self.vtable).GetPointers(@ptrCast(*const ISegment, self), pIStart, pIEnd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementSegment_Value = @import("../zig.zig").Guid.initString("3050F68F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementSegment = &IID_IElementSegment_Value;
pub const IElementSegment = extern struct {
    pub const VTable = extern struct {
        base: ISegment.VTable,
        GetElement: fn(
            self: *const IElementSegment,
            ppIElement: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPrimary: fn(
            self: *const IElementSegment,
            fPrimary: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPrimary: fn(
            self: *const IElementSegment,
            pfPrimary: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISegment.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSegment_GetElement(self: *const T, ppIElement: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSegment.VTable, self.vtable).GetElement(@ptrCast(*const IElementSegment, self), ppIElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSegment_SetPrimary(self: *const T, fPrimary: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSegment.VTable, self.vtable).SetPrimary(@ptrCast(*const IElementSegment, self), fPrimary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementSegment_IsPrimary(self: *const T, pfPrimary: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementSegment.VTable, self.vtable).IsPrimary(@ptrCast(*const IElementSegment, self), pfPrimary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHighlightSegment_Value = @import("../zig.zig").Guid.initString("3050F690-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHighlightSegment = &IID_IHighlightSegment_Value;
pub const IHighlightSegment = extern struct {
    pub const VTable = extern struct {
        base: ISegment.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ISegment.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHighlightRenderingServices_Value = @import("../zig.zig").Guid.initString("3050F606-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHighlightRenderingServices = &IID_IHighlightRenderingServices_Value;
pub const IHighlightRenderingServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddSegment: fn(
            self: *const IHighlightRenderingServices,
            pDispPointerStart: *IDisplayPointer,
            pDispPointerEnd: *IDisplayPointer,
            pIRenderStyle: *IHTMLRenderStyle,
            ppISegment: **IHighlightSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveSegmentToPointers: fn(
            self: *const IHighlightRenderingServices,
            pISegment: *IHighlightSegment,
            pDispPointerStart: *IDisplayPointer,
            pDispPointerEnd: *IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSegment: fn(
            self: *const IHighlightRenderingServices,
            pISegment: *IHighlightSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHighlightRenderingServices_AddSegment(self: *const T, pDispPointerStart: *IDisplayPointer, pDispPointerEnd: *IDisplayPointer, pIRenderStyle: *IHTMLRenderStyle, ppISegment: **IHighlightSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHighlightRenderingServices.VTable, self.vtable).AddSegment(@ptrCast(*const IHighlightRenderingServices, self), pDispPointerStart, pDispPointerEnd, pIRenderStyle, ppISegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHighlightRenderingServices_MoveSegmentToPointers(self: *const T, pISegment: *IHighlightSegment, pDispPointerStart: *IDisplayPointer, pDispPointerEnd: *IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHighlightRenderingServices.VTable, self.vtable).MoveSegmentToPointers(@ptrCast(*const IHighlightRenderingServices, self), pISegment, pDispPointerStart, pDispPointerEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHighlightRenderingServices_RemoveSegment(self: *const T, pISegment: *IHighlightSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHighlightRenderingServices.VTable, self.vtable).RemoveSegment(@ptrCast(*const IHighlightRenderingServices, self), pISegment);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ILineInfo_Value = @import("../zig.zig").Guid.initString("3050F7E2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ILineInfo = &IID_ILineInfo_Value;
pub const ILineInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_x: fn(
            self: *const ILineInfo,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_baseLine: fn(
            self: *const ILineInfo,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textDescent: fn(
            self: *const ILineInfo,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textHeight: fn(
            self: *const ILineInfo,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_lineDirection: fn(
            self: *const ILineInfo,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_x(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_x(@ptrCast(*const ILineInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_baseLine(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_baseLine(@ptrCast(*const ILineInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_textDescent(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_textDescent(@ptrCast(*const ILineInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_textHeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_textHeight(@ptrCast(*const ILineInfo, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ILineInfo_get_lineDirection(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ILineInfo.VTable, self.vtable).get_lineDirection(@ptrCast(*const ILineInfo, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDisplayPointer_Value = @import("../zig.zig").Guid.initString("3050F69E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDisplayPointer = &IID_IDisplayPointer_Value;
pub const IDisplayPointer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        MoveToPoint: fn(
            self: *const IDisplayPointer,
            ptPoint: POINT,
            eCoordSystem: COORD_SYSTEM,
            pElementContext: *IHTMLElement,
            dwHitTestOptions: u32,
            pdwHitTestResults: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUnit: fn(
            self: *const IDisplayPointer,
            eMoveUnit: DISPLAY_MOVEUNIT,
            lXPos: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PositionMarkupPointer: fn(
            self: *const IDisplayPointer,
            pMarkupPointer: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToPointer: fn(
            self: *const IDisplayPointer,
            pDispPointer: *IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPointerGravity: fn(
            self: *const IDisplayPointer,
            eGravity: POINTER_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPointerGravity: fn(
            self: *const IDisplayPointer,
            peGravity: *POINTER_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplayGravity: fn(
            self: *const IDisplayPointer,
            eGravity: DISPLAY_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayGravity: fn(
            self: *const IDisplayPointer,
            peGravity: *DISPLAY_GRAVITY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPositioned: fn(
            self: *const IDisplayPointer,
            pfPositioned: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unposition: fn(
            self: *const IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualTo: fn(
            self: *const IDisplayPointer,
            pDispPointer: *IDisplayPointer,
            pfIsEqual: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsLeftOf: fn(
            self: *const IDisplayPointer,
            pDispPointer: *IDisplayPointer,
            pfIsLeftOf: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsRightOf: fn(
            self: *const IDisplayPointer,
            pDispPointer: *IDisplayPointer,
            pfIsRightOf: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsAtBOL: fn(
            self: *const IDisplayPointer,
            pfBOL: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToMarkupPointer: fn(
            self: *const IDisplayPointer,
            pPointer: *IMarkupPointer,
            pDispLineContext: *IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollIntoView: fn(
            self: *const IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineInfo: fn(
            self: *const IDisplayPointer,
            ppLineInfo: **ILineInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlowElement: fn(
            self: *const IDisplayPointer,
            ppLayoutElement: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryBreaks: fn(
            self: *const IDisplayPointer,
            pdwBreaks: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_MoveToPoint(self: *const T, ptPoint: POINT, eCoordSystem: COORD_SYSTEM, pElementContext: *IHTMLElement, dwHitTestOptions: u32, pdwHitTestResults: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).MoveToPoint(@ptrCast(*const IDisplayPointer, self), ptPoint, eCoordSystem, pElementContext, dwHitTestOptions, pdwHitTestResults);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_MoveUnit(self: *const T, eMoveUnit: DISPLAY_MOVEUNIT, lXPos: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).MoveUnit(@ptrCast(*const IDisplayPointer, self), eMoveUnit, lXPos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_PositionMarkupPointer(self: *const T, pMarkupPointer: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).PositionMarkupPointer(@ptrCast(*const IDisplayPointer, self), pMarkupPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_MoveToPointer(self: *const T, pDispPointer: *IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).MoveToPointer(@ptrCast(*const IDisplayPointer, self), pDispPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_SetPointerGravity(self: *const T, eGravity: POINTER_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).SetPointerGravity(@ptrCast(*const IDisplayPointer, self), eGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_GetPointerGravity(self: *const T, peGravity: *POINTER_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).GetPointerGravity(@ptrCast(*const IDisplayPointer, self), peGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_SetDisplayGravity(self: *const T, eGravity: DISPLAY_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).SetDisplayGravity(@ptrCast(*const IDisplayPointer, self), eGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_GetDisplayGravity(self: *const T, peGravity: *DISPLAY_GRAVITY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).GetDisplayGravity(@ptrCast(*const IDisplayPointer, self), peGravity);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsPositioned(self: *const T, pfPositioned: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsPositioned(@ptrCast(*const IDisplayPointer, self), pfPositioned);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_Unposition(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).Unposition(@ptrCast(*const IDisplayPointer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsEqualTo(self: *const T, pDispPointer: *IDisplayPointer, pfIsEqual: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsEqualTo(@ptrCast(*const IDisplayPointer, self), pDispPointer, pfIsEqual);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsLeftOf(self: *const T, pDispPointer: *IDisplayPointer, pfIsLeftOf: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsLeftOf(@ptrCast(*const IDisplayPointer, self), pDispPointer, pfIsLeftOf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsRightOf(self: *const T, pDispPointer: *IDisplayPointer, pfIsRightOf: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsRightOf(@ptrCast(*const IDisplayPointer, self), pDispPointer, pfIsRightOf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_IsAtBOL(self: *const T, pfBOL: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).IsAtBOL(@ptrCast(*const IDisplayPointer, self), pfBOL);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_MoveToMarkupPointer(self: *const T, pPointer: *IMarkupPointer, pDispLineContext: *IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).MoveToMarkupPointer(@ptrCast(*const IDisplayPointer, self), pPointer, pDispLineContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_ScrollIntoView(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).ScrollIntoView(@ptrCast(*const IDisplayPointer, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_GetLineInfo(self: *const T, ppLineInfo: **ILineInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).GetLineInfo(@ptrCast(*const IDisplayPointer, self), ppLineInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_GetFlowElement(self: *const T, ppLayoutElement: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).GetFlowElement(@ptrCast(*const IDisplayPointer, self), ppLayoutElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayPointer_QueryBreaks(self: *const T, pdwBreaks: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayPointer.VTable, self.vtable).QueryBreaks(@ptrCast(*const IDisplayPointer, self), pdwBreaks);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDisplayServices_Value = @import("../zig.zig").Guid.initString("3050F69D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDisplayServices = &IID_IDisplayServices_Value;
pub const IDisplayServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateDisplayPointer: fn(
            self: *const IDisplayServices,
            ppDispPointer: **IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransformRect: fn(
            self: *const IDisplayServices,
            pRect: *RECT,
            eSource: COORD_SYSTEM,
            eDestination: COORD_SYSTEM,
            pIElement: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransformPoint: fn(
            self: *const IDisplayServices,
            pPoint: *POINT,
            eSource: COORD_SYSTEM,
            eDestination: COORD_SYSTEM,
            pIElement: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCaret: fn(
            self: *const IDisplayServices,
            ppCaret: **IHTMLCaret,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetComputedStyle: fn(
            self: *const IDisplayServices,
            pPointer: *IMarkupPointer,
            ppComputedStyle: **IHTMLComputedStyle,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScrollRectIntoView: fn(
            self: *const IDisplayServices,
            pIElement: *IHTMLElement,
            rect: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HasFlowLayout: fn(
            self: *const IDisplayServices,
            pIElement: *IHTMLElement,
            pfHasFlowLayout: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_CreateDisplayPointer(self: *const T, ppDispPointer: **IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).CreateDisplayPointer(@ptrCast(*const IDisplayServices, self), ppDispPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_TransformRect(self: *const T, pRect: *RECT, eSource: COORD_SYSTEM, eDestination: COORD_SYSTEM, pIElement: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).TransformRect(@ptrCast(*const IDisplayServices, self), pRect, eSource, eDestination, pIElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_TransformPoint(self: *const T, pPoint: *POINT, eSource: COORD_SYSTEM, eDestination: COORD_SYSTEM, pIElement: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).TransformPoint(@ptrCast(*const IDisplayServices, self), pPoint, eSource, eDestination, pIElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_GetCaret(self: *const T, ppCaret: **IHTMLCaret) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).GetCaret(@ptrCast(*const IDisplayServices, self), ppCaret);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_GetComputedStyle(self: *const T, pPointer: *IMarkupPointer, ppComputedStyle: **IHTMLComputedStyle) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).GetComputedStyle(@ptrCast(*const IDisplayServices, self), pPointer, ppComputedStyle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_ScrollRectIntoView(self: *const T, pIElement: *IHTMLElement, rect: RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).ScrollRectIntoView(@ptrCast(*const IDisplayServices, self), pIElement, rect);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDisplayServices_HasFlowLayout(self: *const T, pIElement: *IHTMLElement, pfHasFlowLayout: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDisplayServices.VTable, self.vtable).HasFlowLayout(@ptrCast(*const IDisplayServices, self), pIElement, pfHasFlowLayout);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHtmlDlgSafeHelper_Value = @import("../zig.zig").Guid.initString("3050F81A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHtmlDlgSafeHelper = &IID_IHtmlDlgSafeHelper_Value;
pub const IHtmlDlgSafeHelper = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        choosecolordlg: fn(
            self: *const IHtmlDlgSafeHelper,
            initColor: VARIANT,
            rgbColor: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        getCharset: fn(
            self: *const IHtmlDlgSafeHelper,
            fontName: BSTR,
            charset: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Fonts: fn(
            self: *const IHtmlDlgSafeHelper,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BlockFormats: fn(
            self: *const IHtmlDlgSafeHelper,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHtmlDlgSafeHelper_choosecolordlg(self: *const T, initColor: VARIANT, rgbColor: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHtmlDlgSafeHelper.VTable, self.vtable).choosecolordlg(@ptrCast(*const IHtmlDlgSafeHelper, self), initColor, rgbColor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHtmlDlgSafeHelper_getCharset(self: *const T, fontName: BSTR, charset: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHtmlDlgSafeHelper.VTable, self.vtable).getCharset(@ptrCast(*const IHtmlDlgSafeHelper, self), fontName, charset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHtmlDlgSafeHelper_get_Fonts(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHtmlDlgSafeHelper.VTable, self.vtable).get_Fonts(@ptrCast(*const IHtmlDlgSafeHelper, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHtmlDlgSafeHelper_get_BlockFormats(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHtmlDlgSafeHelper.VTable, self.vtable).get_BlockFormats(@ptrCast(*const IHtmlDlgSafeHelper, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBlockFormats_Value = @import("../zig.zig").Guid.initString("3050F830-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IBlockFormats = &IID_IBlockFormats_Value;
pub const IBlockFormats = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get__NewEnum: fn(
            self: *const IBlockFormats,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Count: fn(
            self: *const IBlockFormats,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IBlockFormats,
            pvarIndex: *VARIANT,
            pbstrBlockFormat: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockFormats_get__NewEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockFormats.VTable, self.vtable).get__NewEnum(@ptrCast(*const IBlockFormats, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockFormats_get_Count(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockFormats.VTable, self.vtable).get_Count(@ptrCast(*const IBlockFormats, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBlockFormats_Item(self: *const T, pvarIndex: *VARIANT, pbstrBlockFormat: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBlockFormats.VTable, self.vtable).Item(@ptrCast(*const IBlockFormats, self), pvarIndex, pbstrBlockFormat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IFontNames_Value = @import("../zig.zig").Guid.initString("3050F839-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IFontNames = &IID_IFontNames_Value;
pub const IFontNames = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get__NewEnum: fn(
            self: *const IFontNames,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Count: fn(
            self: *const IFontNames,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Item: fn(
            self: *const IFontNames,
            pvarIndex: *VARIANT,
            pbstrFontName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFontNames_get__NewEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFontNames.VTable, self.vtable).get__NewEnum(@ptrCast(*const IFontNames, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFontNames_get_Count(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFontNames.VTable, self.vtable).get_Count(@ptrCast(*const IFontNames, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IFontNames_Item(self: *const T, pvarIndex: *VARIANT, pbstrFontName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IFontNames.VTable, self.vtable).Item(@ptrCast(*const IFontNames, self), pvarIndex, pbstrFontName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICSSFilter_Value = @import("../zig.zig").Guid.initString("3050F3EC-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ICSSFilter = &IID_ICSSFilter_Value;
pub const ICSSFilter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSite: fn(
            self: *const ICSSFilter,
            pSink: *ICSSFilterSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnAmbientPropertyChange: fn(
            self: *const ICSSFilter,
            dispid: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICSSFilter_SetSite(self: *const T, pSink: *ICSSFilterSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICSSFilter.VTable, self.vtable).SetSite(@ptrCast(*const ICSSFilter, self), pSink);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICSSFilter_OnAmbientPropertyChange(self: *const T, dispid: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICSSFilter.VTable, self.vtable).OnAmbientPropertyChange(@ptrCast(*const ICSSFilter, self), dispid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISecureUrlHost_Value = @import("../zig.zig").Guid.initString("C81984C4-74C8-11D2-BAA9-00C04FC2040E");
pub const IID_ISecureUrlHost = &IID_ISecureUrlHost_Value;
pub const ISecureUrlHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ValidateSecureUrl: fn(
            self: *const ISecureUrlHost,
            pfAllow: *BOOL,
            pchUrlInQuestion: PWSTR,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISecureUrlHost_ValidateSecureUrl(self: *const T, pfAllow: *BOOL, pchUrlInQuestion: PWSTR, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISecureUrlHost.VTable, self.vtable).ValidateSecureUrl(@ptrCast(*const ISecureUrlHost, self), pfAllow, pchUrlInQuestion, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupServices_Value = @import("../zig.zig").Guid.initString("3050F4A0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IMarkupServices = &IID_IMarkupServices_Value;
pub const IMarkupServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateMarkupPointer: fn(
            self: *const IMarkupServices,
            ppPointer: **IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMarkupContainer: fn(
            self: *const IMarkupServices,
            ppMarkupContainer: **IMarkupContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateElement: fn(
            self: *const IMarkupServices,
            tagID: ELEMENT_TAG_ID,
            pchAttributes: PWSTR,
            ppElement: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloneElement: fn(
            self: *const IMarkupServices,
            pElemCloneThis: *IHTMLElement,
            ppElementTheClone: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertElement: fn(
            self: *const IMarkupServices,
            pElementInsert: *IHTMLElement,
            pPointerStart: *IMarkupPointer,
            pPointerFinish: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveElement: fn(
            self: *const IMarkupServices,
            pElementRemove: *IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Remove: fn(
            self: *const IMarkupServices,
            pPointerStart: *IMarkupPointer,
            pPointerFinish: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Copy: fn(
            self: *const IMarkupServices,
            pPointerSourceStart: *IMarkupPointer,
            pPointerSourceFinish: *IMarkupPointer,
            pPointerTarget: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Move: fn(
            self: *const IMarkupServices,
            pPointerSourceStart: *IMarkupPointer,
            pPointerSourceFinish: *IMarkupPointer,
            pPointerTarget: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertText: fn(
            self: *const IMarkupServices,
            pchText: PWSTR,
            cch: i32,
            pPointerTarget: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseString: fn(
            self: *const IMarkupServices,
            pchHTML: PWSTR,
            dwFlags: u32,
            ppContainerResult: **IMarkupContainer,
            ppPointerStart: *IMarkupPointer,
            ppPointerFinish: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseGlobal: fn(
            self: *const IMarkupServices,
            hglobalHTML: ?*c_void,
            dwFlags: u32,
            ppContainerResult: **IMarkupContainer,
            pPointerStart: *IMarkupPointer,
            pPointerFinish: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsScopedElement: fn(
            self: *const IMarkupServices,
            pElement: *IHTMLElement,
            pfScoped: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetElementTagId: fn(
            self: *const IMarkupServices,
            pElement: *IHTMLElement,
            ptagId: *ELEMENT_TAG_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTagIDForName: fn(
            self: *const IMarkupServices,
            bstrName: BSTR,
            ptagId: *ELEMENT_TAG_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameForTagID: fn(
            self: *const IMarkupServices,
            tagId: ELEMENT_TAG_ID,
            pbstrName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MovePointersToRange: fn(
            self: *const IMarkupServices,
            pIRange: *IHTMLTxtRange,
            pPointerStart: *IMarkupPointer,
            pPointerFinish: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveRangeToPointers: fn(
            self: *const IMarkupServices,
            pPointerStart: *IMarkupPointer,
            pPointerFinish: *IMarkupPointer,
            pIRange: *IHTMLTxtRange,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeginUndoUnit: fn(
            self: *const IMarkupServices,
            pchTitle: PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndUndoUnit: fn(
            self: *const IMarkupServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_CreateMarkupPointer(self: *const T, ppPointer: **IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).CreateMarkupPointer(@ptrCast(*const IMarkupServices, self), ppPointer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_CreateMarkupContainer(self: *const T, ppMarkupContainer: **IMarkupContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).CreateMarkupContainer(@ptrCast(*const IMarkupServices, self), ppMarkupContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_CreateElement(self: *const T, tagID: ELEMENT_TAG_ID, pchAttributes: PWSTR, ppElement: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).CreateElement(@ptrCast(*const IMarkupServices, self), tagID, pchAttributes, ppElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_CloneElement(self: *const T, pElemCloneThis: *IHTMLElement, ppElementTheClone: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).CloneElement(@ptrCast(*const IMarkupServices, self), pElemCloneThis, ppElementTheClone);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_InsertElement(self: *const T, pElementInsert: *IHTMLElement, pPointerStart: *IMarkupPointer, pPointerFinish: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).InsertElement(@ptrCast(*const IMarkupServices, self), pElementInsert, pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_RemoveElement(self: *const T, pElementRemove: *IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).RemoveElement(@ptrCast(*const IMarkupServices, self), pElementRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_Remove(self: *const T, pPointerStart: *IMarkupPointer, pPointerFinish: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).Remove(@ptrCast(*const IMarkupServices, self), pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_Copy(self: *const T, pPointerSourceStart: *IMarkupPointer, pPointerSourceFinish: *IMarkupPointer, pPointerTarget: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).Copy(@ptrCast(*const IMarkupServices, self), pPointerSourceStart, pPointerSourceFinish, pPointerTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_Move(self: *const T, pPointerSourceStart: *IMarkupPointer, pPointerSourceFinish: *IMarkupPointer, pPointerTarget: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).Move(@ptrCast(*const IMarkupServices, self), pPointerSourceStart, pPointerSourceFinish, pPointerTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_InsertText(self: *const T, pchText: PWSTR, cch: i32, pPointerTarget: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).InsertText(@ptrCast(*const IMarkupServices, self), pchText, cch, pPointerTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_ParseString(self: *const T, pchHTML: PWSTR, dwFlags: u32, ppContainerResult: **IMarkupContainer, ppPointerStart: *IMarkupPointer, ppPointerFinish: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).ParseString(@ptrCast(*const IMarkupServices, self), pchHTML, dwFlags, ppContainerResult, ppPointerStart, ppPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_ParseGlobal(self: *const T, hglobalHTML: ?*c_void, dwFlags: u32, ppContainerResult: **IMarkupContainer, pPointerStart: *IMarkupPointer, pPointerFinish: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).ParseGlobal(@ptrCast(*const IMarkupServices, self), hglobalHTML, dwFlags, ppContainerResult, pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_IsScopedElement(self: *const T, pElement: *IHTMLElement, pfScoped: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).IsScopedElement(@ptrCast(*const IMarkupServices, self), pElement, pfScoped);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_GetElementTagId(self: *const T, pElement: *IHTMLElement, ptagId: *ELEMENT_TAG_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).GetElementTagId(@ptrCast(*const IMarkupServices, self), pElement, ptagId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_GetTagIDForName(self: *const T, bstrName: BSTR, ptagId: *ELEMENT_TAG_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).GetTagIDForName(@ptrCast(*const IMarkupServices, self), bstrName, ptagId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_GetNameForTagID(self: *const T, tagId: ELEMENT_TAG_ID, pbstrName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).GetNameForTagID(@ptrCast(*const IMarkupServices, self), tagId, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_MovePointersToRange(self: *const T, pIRange: *IHTMLTxtRange, pPointerStart: *IMarkupPointer, pPointerFinish: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).MovePointersToRange(@ptrCast(*const IMarkupServices, self), pIRange, pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_MoveRangeToPointers(self: *const T, pPointerStart: *IMarkupPointer, pPointerFinish: *IMarkupPointer, pIRange: *IHTMLTxtRange) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).MoveRangeToPointers(@ptrCast(*const IMarkupServices, self), pPointerStart, pPointerFinish, pIRange);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_BeginUndoUnit(self: *const T, pchTitle: PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).BeginUndoUnit(@ptrCast(*const IMarkupServices, self), pchTitle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices_EndUndoUnit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices.VTable, self.vtable).EndUndoUnit(@ptrCast(*const IMarkupServices, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupServices2_Value = @import("../zig.zig").Guid.initString("3050F682-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IMarkupServices2 = &IID_IMarkupServices2_Value;
pub const IMarkupServices2 = extern struct {
    pub const VTable = extern struct {
        base: IMarkupServices.VTable,
        ParseGlobalEx: fn(
            self: *const IMarkupServices2,
            hglobalHTML: ?*c_void,
            dwFlags: u32,
            pContext: *IMarkupContainer,
            ppContainerResult: **IMarkupContainer,
            pPointerStart: *IMarkupPointer,
            pPointerFinish: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ValidateElements: fn(
            self: *const IMarkupServices2,
            pPointerStart: *IMarkupPointer,
            pPointerFinish: *IMarkupPointer,
            pPointerTarget: *IMarkupPointer,
            pPointerStatus: *IMarkupPointer,
            ppElemFailBottom: **IHTMLElement,
            ppElemFailTop: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SaveSegmentsToClipboard: fn(
            self: *const IMarkupServices2,
            pSegmentList: *ISegmentList,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMarkupServices.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices2_ParseGlobalEx(self: *const T, hglobalHTML: ?*c_void, dwFlags: u32, pContext: *IMarkupContainer, ppContainerResult: **IMarkupContainer, pPointerStart: *IMarkupPointer, pPointerFinish: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices2.VTable, self.vtable).ParseGlobalEx(@ptrCast(*const IMarkupServices2, self), hglobalHTML, dwFlags, pContext, ppContainerResult, pPointerStart, pPointerFinish);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices2_ValidateElements(self: *const T, pPointerStart: *IMarkupPointer, pPointerFinish: *IMarkupPointer, pPointerTarget: *IMarkupPointer, pPointerStatus: *IMarkupPointer, ppElemFailBottom: **IHTMLElement, ppElemFailTop: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices2.VTable, self.vtable).ValidateElements(@ptrCast(*const IMarkupServices2, self), pPointerStart, pPointerFinish, pPointerTarget, pPointerStatus, ppElemFailBottom, ppElemFailTop);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupServices2_SaveSegmentsToClipboard(self: *const T, pSegmentList: *ISegmentList, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupServices2.VTable, self.vtable).SaveSegmentsToClipboard(@ptrCast(*const IMarkupServices2, self), pSegmentList, dwFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLChangePlayback_Value = @import("../zig.zig").Guid.initString("3050F6E0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLChangePlayback = &IID_IHTMLChangePlayback_Value;
pub const IHTMLChangePlayback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ExecChange: fn(
            self: *const IHTMLChangePlayback,
            pbRecord: *u8,
            fForward: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLChangePlayback_ExecChange(self: *const T, pbRecord: *u8, fForward: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLChangePlayback.VTable, self.vtable).ExecChange(@ptrCast(*const IHTMLChangePlayback, self), pbRecord, fForward);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupPointer2_Value = @import("../zig.zig").Guid.initString("3050F675-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IMarkupPointer2 = &IID_IMarkupPointer2_Value;
pub const IMarkupPointer2 = extern struct {
    pub const VTable = extern struct {
        base: IMarkupPointer.VTable,
        IsAtWordBreak: fn(
            self: *const IMarkupPointer2,
            pfAtBreak: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarkupPosition: fn(
            self: *const IMarkupPointer2,
            plMP: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToMarkupPosition: fn(
            self: *const IMarkupPointer2,
            pContainer: *IMarkupContainer,
            lMP: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveUnitBounded: fn(
            self: *const IMarkupPointer2,
            muAction: MOVEUNIT_ACTION,
            pIBoundary: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInsideURL: fn(
            self: *const IMarkupPointer2,
            pRight: *IMarkupPointer,
            pfResult: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToContent: fn(
            self: *const IMarkupPointer2,
            pIElement: *IHTMLElement,
            fAtStart: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IMarkupPointer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_IsAtWordBreak(self: *const T, pfAtBreak: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).IsAtWordBreak(@ptrCast(*const IMarkupPointer2, self), pfAtBreak);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_GetMarkupPosition(self: *const T, plMP: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).GetMarkupPosition(@ptrCast(*const IMarkupPointer2, self), plMP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_MoveToMarkupPosition(self: *const T, pContainer: *IMarkupContainer, lMP: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).MoveToMarkupPosition(@ptrCast(*const IMarkupPointer2, self), pContainer, lMP);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_MoveUnitBounded(self: *const T, muAction: MOVEUNIT_ACTION, pIBoundary: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).MoveUnitBounded(@ptrCast(*const IMarkupPointer2, self), muAction, pIBoundary);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_IsInsideURL(self: *const T, pRight: *IMarkupPointer, pfResult: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).IsInsideURL(@ptrCast(*const IMarkupPointer2, self), pRight, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupPointer2_MoveToContent(self: *const T, pIElement: *IHTMLElement, fAtStart: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupPointer2.VTable, self.vtable).MoveToContent(@ptrCast(*const IMarkupPointer2, self), pIElement, fAtStart);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMarkupTextFrags_Value = @import("../zig.zig").Guid.initString("3050F5FA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IMarkupTextFrags = &IID_IMarkupTextFrags_Value;
pub const IMarkupTextFrags = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTextFragCount: fn(
            self: *const IMarkupTextFrags,
            pcFrags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextFrag: fn(
            self: *const IMarkupTextFrags,
            iFrag: i32,
            pbstrFrag: *BSTR,
            pPointerFrag: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTextFrag: fn(
            self: *const IMarkupTextFrags,
            iFrag: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InsertTextFrag: fn(
            self: *const IMarkupTextFrags,
            iFrag: i32,
            bstrInsert: BSTR,
            pPointerInsert: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTextFragFromMarkupPointer: fn(
            self: *const IMarkupTextFrags,
            pPointerFind: *IMarkupPointer,
            piFrag: *i32,
            pfFragFound: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_GetTextFragCount(self: *const T, pcFrags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).GetTextFragCount(@ptrCast(*const IMarkupTextFrags, self), pcFrags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_GetTextFrag(self: *const T, iFrag: i32, pbstrFrag: *BSTR, pPointerFrag: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).GetTextFrag(@ptrCast(*const IMarkupTextFrags, self), iFrag, pbstrFrag, pPointerFrag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_RemoveTextFrag(self: *const T, iFrag: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).RemoveTextFrag(@ptrCast(*const IMarkupTextFrags, self), iFrag);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_InsertTextFrag(self: *const T, iFrag: i32, bstrInsert: BSTR, pPointerInsert: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).InsertTextFrag(@ptrCast(*const IMarkupTextFrags, self), iFrag, bstrInsert, pPointerInsert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMarkupTextFrags_FindTextFragFromMarkupPointer(self: *const T, pPointerFind: *IMarkupPointer, piFrag: *i32, pfFragFound: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMarkupTextFrags.VTable, self.vtable).FindTextFragFromMarkupPointer(@ptrCast(*const IMarkupTextFrags, self), pPointerFind, piFrag, pfFragFound);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IXMLGenericParse_Value = @import("../zig.zig").Guid.initString("E4E23071-4D07-11D2-AE76-0080C73BC199");
pub const IID_IXMLGenericParse = &IID_IXMLGenericParse_Value;
pub const IXMLGenericParse = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetGenericParse: fn(
            self: *const IXMLGenericParse,
            fDoGeneric: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IXMLGenericParse_SetGenericParse(self: *const T, fDoGeneric: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IXMLGenericParse.VTable, self.vtable).SetGenericParse(@ptrCast(*const IXMLGenericParse, self), fDoGeneric);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditHost_Value = @import("../zig.zig").Guid.initString("3050F6A0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEditHost = &IID_IHTMLEditHost_Value;
pub const IHTMLEditHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SnapRect: fn(
            self: *const IHTMLEditHost,
            pIElement: *IHTMLElement,
            prcNew: *RECT,
            eHandle: ELEMENT_CORNER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditHost_SnapRect(self: *const T, pIElement: *IHTMLElement, prcNew: *RECT, eHandle: ELEMENT_CORNER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditHost.VTable, self.vtable).SnapRect(@ptrCast(*const IHTMLEditHost, self), pIElement, prcNew, eHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditHost2_Value = @import("../zig.zig").Guid.initString("3050F848-98B5-11CF-BB82-00AA00BDCE0D");
pub const IID_IHTMLEditHost2 = &IID_IHTMLEditHost2_Value;
pub const IHTMLEditHost2 = extern struct {
    pub const VTable = extern struct {
        base: IHTMLEditHost.VTable,
        PreDrag: fn(
            self: *const IHTMLEditHost2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHTMLEditHost.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditHost2_PreDrag(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditHost2.VTable, self.vtable).PreDrag(@ptrCast(*const IHTMLEditHost2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISequenceNumber_Value = @import("../zig.zig").Guid.initString("3050F6C1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISequenceNumber = &IID_ISequenceNumber_Value;
pub const ISequenceNumber = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSequenceNumber: fn(
            self: *const ISequenceNumber,
            nCurrent: i32,
            pnNew: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISequenceNumber_GetSequenceNumber(self: *const T, nCurrent: i32, pnNew: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISequenceNumber.VTable, self.vtable).GetSequenceNumber(@ptrCast(*const ISequenceNumber, self), nCurrent, pnNew);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIMEServices_Value = @import("../zig.zig").Guid.initString("3050F6CA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IIMEServices = &IID_IIMEServices_Value;
pub const IIMEServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetActiveIMM: fn(
            self: *const IIMEServices,
            ppActiveIMM: **IActiveIMMApp,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIMEServices_GetActiveIMM(self: *const T, ppActiveIMM: **IActiveIMMApp) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIMEServices.VTable, self.vtable).GetActiveIMM(@ptrCast(*const IIMEServices, self), ppActiveIMM);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISelectionServicesListener_Value = @import("../zig.zig").Guid.initString("3050F699-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISelectionServicesListener = &IID_ISelectionServicesListener_Value;
pub const ISelectionServicesListener = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeginSelectionUndo: fn(
            self: *const ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSelectionUndo: fn(
            self: *const ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSelectedElementExit: fn(
            self: *const ISelectionServicesListener,
            pIElementStart: *IMarkupPointer,
            pIElementEnd: *IMarkupPointer,
            pIElementContentStart: *IMarkupPointer,
            pIElementContentEnd: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnChangeType: fn(
            self: *const ISelectionServicesListener,
            eType: SELECTION_TYPE,
            pIListener: *ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeDetail: fn(
            self: *const ISelectionServicesListener,
            pTypeDetail: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_BeginSelectionUndo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).BeginSelectionUndo(@ptrCast(*const ISelectionServicesListener, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_EndSelectionUndo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).EndSelectionUndo(@ptrCast(*const ISelectionServicesListener, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_OnSelectedElementExit(self: *const T, pIElementStart: *IMarkupPointer, pIElementEnd: *IMarkupPointer, pIElementContentStart: *IMarkupPointer, pIElementContentEnd: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).OnSelectedElementExit(@ptrCast(*const ISelectionServicesListener, self), pIElementStart, pIElementEnd, pIElementContentStart, pIElementContentEnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_OnChangeType(self: *const T, eType: SELECTION_TYPE, pIListener: *ISelectionServicesListener) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).OnChangeType(@ptrCast(*const ISelectionServicesListener, self), eType, pIListener);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServicesListener_GetTypeDetail(self: *const T, pTypeDetail: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServicesListener.VTable, self.vtable).GetTypeDetail(@ptrCast(*const ISelectionServicesListener, self), pTypeDetail);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISelectionServices_Value = @import("../zig.zig").Guid.initString("3050F684-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISelectionServices = &IID_ISelectionServices_Value;
pub const ISelectionServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetSelectionType: fn(
            self: *const ISelectionServices,
            eType: SELECTION_TYPE,
            pIListener: *ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMarkupContainer: fn(
            self: *const ISelectionServices,
            ppIContainer: **IMarkupContainer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSegment: fn(
            self: *const ISelectionServices,
            pIStart: *IMarkupPointer,
            pIEnd: *IMarkupPointer,
            ppISegmentAdded: **ISegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddElementSegment: fn(
            self: *const ISelectionServices,
            pIElement: *IHTMLElement,
            ppISegmentAdded: **IElementSegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSegment: fn(
            self: *const ISelectionServices,
            pISegment: *ISegment,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectionServicesListener: fn(
            self: *const ISelectionServices,
            ppISelectionServicesListener: **ISelectionServicesListener,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_SetSelectionType(self: *const T, eType: SELECTION_TYPE, pIListener: *ISelectionServicesListener) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).SetSelectionType(@ptrCast(*const ISelectionServices, self), eType, pIListener);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_GetMarkupContainer(self: *const T, ppIContainer: **IMarkupContainer) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).GetMarkupContainer(@ptrCast(*const ISelectionServices, self), ppIContainer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_AddSegment(self: *const T, pIStart: *IMarkupPointer, pIEnd: *IMarkupPointer, ppISegmentAdded: **ISegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).AddSegment(@ptrCast(*const ISelectionServices, self), pIStart, pIEnd, ppISegmentAdded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_AddElementSegment(self: *const T, pIElement: *IHTMLElement, ppISegmentAdded: **IElementSegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).AddElementSegment(@ptrCast(*const ISelectionServices, self), pIElement, ppISegmentAdded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_RemoveSegment(self: *const T, pISegment: *ISegment) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).RemoveSegment(@ptrCast(*const ISelectionServices, self), pISegment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISelectionServices_GetSelectionServicesListener(self: *const T, ppISelectionServicesListener: **ISelectionServicesListener) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISelectionServices.VTable, self.vtable).GetSelectionServicesListener(@ptrCast(*const ISelectionServices, self), ppISelectionServicesListener);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditDesigner_Value = @import("../zig.zig").Guid.initString("3050F662-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEditDesigner = &IID_IHTMLEditDesigner_Value;
pub const IHTMLEditDesigner = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PreHandleEvent: fn(
            self: *const IHTMLEditDesigner,
            inEvtDispId: i32,
            pIEventObj: *IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostHandleEvent: fn(
            self: *const IHTMLEditDesigner,
            inEvtDispId: i32,
            pIEventObj: *IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TranslateAcceleratorA: fn(
            self: *const IHTMLEditDesigner,
            inEvtDispId: i32,
            pIEventObj: *IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostEditorEventNotify: fn(
            self: *const IHTMLEditDesigner,
            inEvtDispId: i32,
            pIEventObj: *IHTMLEventObj,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditDesigner_PreHandleEvent(self: *const T, inEvtDispId: i32, pIEventObj: *IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditDesigner.VTable, self.vtable).PreHandleEvent(@ptrCast(*const IHTMLEditDesigner, self), inEvtDispId, pIEventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditDesigner_PostHandleEvent(self: *const T, inEvtDispId: i32, pIEventObj: *IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditDesigner.VTable, self.vtable).PostHandleEvent(@ptrCast(*const IHTMLEditDesigner, self), inEvtDispId, pIEventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditDesigner_TranslateAcceleratorA(self: *const T, inEvtDispId: i32, pIEventObj: *IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditDesigner.VTable, self.vtable).TranslateAcceleratorA(@ptrCast(*const IHTMLEditDesigner, self), inEvtDispId, pIEventObj);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditDesigner_PostEditorEventNotify(self: *const T, inEvtDispId: i32, pIEventObj: *IHTMLEventObj) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditDesigner.VTable, self.vtable).PostEditorEventNotify(@ptrCast(*const IHTMLEditDesigner, self), inEvtDispId, pIEventObj);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditServices_Value = @import("../zig.zig").Guid.initString("3050F663-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEditServices = &IID_IHTMLEditServices_Value;
pub const IHTMLEditServices = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddDesigner: fn(
            self: *const IHTMLEditServices,
            pIDesigner: *IHTMLEditDesigner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveDesigner: fn(
            self: *const IHTMLEditServices,
            pIDesigner: *IHTMLEditDesigner,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSelectionServices: fn(
            self: *const IHTMLEditServices,
            pIContainer: *IMarkupContainer,
            ppSelSvc: **ISelectionServices,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToSelectionAnchor: fn(
            self: *const IHTMLEditServices,
            pIStartAnchor: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToSelectionEnd: fn(
            self: *const IHTMLEditServices,
            pIEndAnchor: *IMarkupPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SelectRange: fn(
            self: *const IHTMLEditServices,
            pStart: *IMarkupPointer,
            pEnd: *IMarkupPointer,
            eType: SELECTION_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_AddDesigner(self: *const T, pIDesigner: *IHTMLEditDesigner) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).AddDesigner(@ptrCast(*const IHTMLEditServices, self), pIDesigner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_RemoveDesigner(self: *const T, pIDesigner: *IHTMLEditDesigner) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).RemoveDesigner(@ptrCast(*const IHTMLEditServices, self), pIDesigner);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_GetSelectionServices(self: *const T, pIContainer: *IMarkupContainer, ppSelSvc: **ISelectionServices) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).GetSelectionServices(@ptrCast(*const IHTMLEditServices, self), pIContainer, ppSelSvc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_MoveToSelectionAnchor(self: *const T, pIStartAnchor: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).MoveToSelectionAnchor(@ptrCast(*const IHTMLEditServices, self), pIStartAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_MoveToSelectionEnd(self: *const T, pIEndAnchor: *IMarkupPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).MoveToSelectionEnd(@ptrCast(*const IHTMLEditServices, self), pIEndAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices_SelectRange(self: *const T, pStart: *IMarkupPointer, pEnd: *IMarkupPointer, eType: SELECTION_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices.VTable, self.vtable).SelectRange(@ptrCast(*const IHTMLEditServices, self), pStart, pEnd, eType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLEditServices2_Value = @import("../zig.zig").Guid.initString("3050F812-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLEditServices2 = &IID_IHTMLEditServices2_Value;
pub const IHTMLEditServices2 = extern struct {
    pub const VTable = extern struct {
        base: IHTMLEditServices.VTable,
        MoveToSelectionAnchorEx: fn(
            self: *const IHTMLEditServices2,
            pIStartAnchor: *IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MoveToSelectionEndEx: fn(
            self: *const IHTMLEditServices2,
            pIEndAnchor: *IDisplayPointer,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreezeVirtualCaretPos: fn(
            self: *const IHTMLEditServices2,
            fReCompute: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnFreezeVirtualCaretPos: fn(
            self: *const IHTMLEditServices2,
            fReset: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IHTMLEditServices.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices2_MoveToSelectionAnchorEx(self: *const T, pIStartAnchor: *IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices2.VTable, self.vtable).MoveToSelectionAnchorEx(@ptrCast(*const IHTMLEditServices2, self), pIStartAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices2_MoveToSelectionEndEx(self: *const T, pIEndAnchor: *IDisplayPointer) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices2.VTable, self.vtable).MoveToSelectionEndEx(@ptrCast(*const IHTMLEditServices2, self), pIEndAnchor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices2_FreezeVirtualCaretPos(self: *const T, fReCompute: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices2.VTable, self.vtable).FreezeVirtualCaretPos(@ptrCast(*const IHTMLEditServices2, self), fReCompute);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLEditServices2_UnFreezeVirtualCaretPos(self: *const T, fReset: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLEditServices2.VTable, self.vtable).UnFreezeVirtualCaretPos(@ptrCast(*const IHTMLEditServices2, self), fReset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLComputedStyle_Value = @import("../zig.zig").Guid.initString("3050F6C3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLComputedStyle = &IID_IHTMLComputedStyle_Value;
pub const IHTMLComputedStyle = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_bold: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_italic: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_underline: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_overline: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_strikeOut: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_subScript: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_superScript: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_explicitFace: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontWeight: fn(
            self: *const IHTMLComputedStyle,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontSize: fn(
            self: *const IHTMLComputedStyle,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_fontName: fn(
            self: *const IHTMLComputedStyle,
            p: *i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_hasBgColor: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_textColor: fn(
            self: *const IHTMLComputedStyle,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_backgroundColor: fn(
            self: *const IHTMLComputedStyle,
            p: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_preFormatted: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_direction: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_blockDirection: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_OL: fn(
            self: *const IHTMLComputedStyle,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IHTMLComputedStyle,
            pComputedStyle: *IHTMLComputedStyle,
            pfEqual: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_bold(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_bold(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_italic(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_italic(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_underline(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_underline(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_overline(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_overline(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_strikeOut(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_strikeOut(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_subScript(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_subScript(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_superScript(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_superScript(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_explicitFace(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_explicitFace(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_fontWeight(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_fontWeight(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_fontSize(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_fontSize(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_fontName(self: *const T, p: *i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_fontName(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_hasBgColor(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_hasBgColor(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_textColor(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_textColor(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_backgroundColor(self: *const T, p: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_backgroundColor(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_preFormatted(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_preFormatted(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_direction(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_direction(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_blockDirection(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_blockDirection(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_get_OL(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).get_OL(@ptrCast(*const IHTMLComputedStyle, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLComputedStyle_IsEqual(self: *const T, pComputedStyle: *IHTMLComputedStyle, pfEqual: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLComputedStyle.VTable, self.vtable).IsEqual(@ptrCast(*const IHTMLComputedStyle, self), pComputedStyle, pfEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDeveloperConsoleMessageReceiver_Value = @import("../zig.zig").Guid.initString("30510808-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDeveloperConsoleMessageReceiver = &IID_IDeveloperConsoleMessageReceiver_Value;
pub const IDeveloperConsoleMessageReceiver = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Write: fn(
            self: *const IDeveloperConsoleMessageReceiver,
            source: [*:0]const u16,
            level: DEV_CONSOLE_MESSAGE_LEVEL,
            messageId: i32,
            messageText: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWithUrl: fn(
            self: *const IDeveloperConsoleMessageReceiver,
            source: [*:0]const u16,
            level: DEV_CONSOLE_MESSAGE_LEVEL,
            messageId: i32,
            messageText: [*:0]const u16,
            fileUrl: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWithUrlAndLine: fn(
            self: *const IDeveloperConsoleMessageReceiver,
            source: [*:0]const u16,
            level: DEV_CONSOLE_MESSAGE_LEVEL,
            messageId: i32,
            messageText: [*:0]const u16,
            fileUrl: [*:0]const u16,
            line: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteWithUrlLineAndColumn: fn(
            self: *const IDeveloperConsoleMessageReceiver,
            source: [*:0]const u16,
            level: DEV_CONSOLE_MESSAGE_LEVEL,
            messageId: i32,
            messageText: [*:0]const u16,
            fileUrl: [*:0]const u16,
            line: u32,
            column: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeveloperConsoleMessageReceiver_Write(self: *const T, source: [*:0]const u16, level: DEV_CONSOLE_MESSAGE_LEVEL, messageId: i32, messageText: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeveloperConsoleMessageReceiver.VTable, self.vtable).Write(@ptrCast(*const IDeveloperConsoleMessageReceiver, self), source, level, messageId, messageText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeveloperConsoleMessageReceiver_WriteWithUrl(self: *const T, source: [*:0]const u16, level: DEV_CONSOLE_MESSAGE_LEVEL, messageId: i32, messageText: [*:0]const u16, fileUrl: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeveloperConsoleMessageReceiver.VTable, self.vtable).WriteWithUrl(@ptrCast(*const IDeveloperConsoleMessageReceiver, self), source, level, messageId, messageText, fileUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeveloperConsoleMessageReceiver_WriteWithUrlAndLine(self: *const T, source: [*:0]const u16, level: DEV_CONSOLE_MESSAGE_LEVEL, messageId: i32, messageText: [*:0]const u16, fileUrl: [*:0]const u16, line: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeveloperConsoleMessageReceiver.VTable, self.vtable).WriteWithUrlAndLine(@ptrCast(*const IDeveloperConsoleMessageReceiver, self), source, level, messageId, messageText, fileUrl, line);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDeveloperConsoleMessageReceiver_WriteWithUrlLineAndColumn(self: *const T, source: [*:0]const u16, level: DEV_CONSOLE_MESSAGE_LEVEL, messageId: i32, messageText: [*:0]const u16, fileUrl: [*:0]const u16, line: u32, column: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDeveloperConsoleMessageReceiver.VTable, self.vtable).WriteWithUrlLineAndColumn(@ptrCast(*const IDeveloperConsoleMessageReceiver, self), source, level, messageId, messageText, fileUrl, line, column);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptEventHandler_Value = @import("../zig.zig").Guid.initString("3051083A-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IScriptEventHandler = &IID_IScriptEventHandler_Value;
pub const IScriptEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FunctionName: fn(
            self: *const IScriptEventHandler,
            pbstrFunctionName: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DebugDocumentContext: fn(
            self: *const IScriptEventHandler,
            ppDebugDocumentContext: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EventHandlerDispatch: fn(
            self: *const IScriptEventHandler,
            ppDispHandler: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UsesCapture: fn(
            self: *const IScriptEventHandler,
            pfUsesCapture: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Cookie: fn(
            self: *const IScriptEventHandler,
            pullCookie: *u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_FunctionName(self: *const T, pbstrFunctionName: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).FunctionName(@ptrCast(*const IScriptEventHandler, self), pbstrFunctionName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_DebugDocumentContext(self: *const T, ppDebugDocumentContext: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).DebugDocumentContext(@ptrCast(*const IScriptEventHandler, self), ppDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_EventHandlerDispatch(self: *const T, ppDispHandler: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).EventHandlerDispatch(@ptrCast(*const IScriptEventHandler, self), ppDispHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_UsesCapture(self: *const T, pfUsesCapture: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).UsesCapture(@ptrCast(*const IScriptEventHandler, self), pfUsesCapture);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandler_Cookie(self: *const T, pullCookie: *u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandler.VTable, self.vtable).Cookie(@ptrCast(*const IScriptEventHandler, self), pullCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCallbackNotificationHandler_Value = @import("../zig.zig").Guid.initString("30510842-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDebugCallbackNotificationHandler = &IID_IDebugCallbackNotificationHandler_Value;
pub const IDebugCallbackNotificationHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        RequestedCallbackTypes: fn(
            self: *const IDebugCallbackNotificationHandler,
            pCallbackMask: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeforeDispatchEvent: fn(
            self: *const IDebugCallbackNotificationHandler,
            pEvent: *IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DispatchEventComplete: fn(
            self: *const IDebugCallbackNotificationHandler,
            pEvent: *IUnknown,
            propagationStatus: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeforeInvokeDomCallback: fn(
            self: *const IDebugCallbackNotificationHandler,
            pEvent: *IUnknown,
            pCallback: *IScriptEventHandler,
            eStage: DOM_EVENT_PHASE,
            propagationStatus: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeDomCallbackComplete: fn(
            self: *const IDebugCallbackNotificationHandler,
            pEvent: *IUnknown,
            pCallback: *IScriptEventHandler,
            eStage: DOM_EVENT_PHASE,
            propagationStatus: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BeforeInvokeCallback: fn(
            self: *const IDebugCallbackNotificationHandler,
            eCallbackType: SCRIPT_TIMER_TYPE,
            callbackCookie: u32,
            pDispHandler: *IDispatch,
            ullHandlerCookie: u64,
            functionName: BSTR,
            line: u32,
            column: u32,
            cchLength: u32,
            pDebugDocumentContext: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeCallbackComplete: fn(
            self: *const IDebugCallbackNotificationHandler,
            eCallbackType: SCRIPT_TIMER_TYPE,
            callbackCookie: u32,
            pDispHandler: *IDispatch,
            ullHandlerCookie: u64,
            functionName: BSTR,
            line: u32,
            column: u32,
            cchLength: u32,
            pDebugDocumentContext: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_RequestedCallbackTypes(self: *const T, pCallbackMask: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).RequestedCallbackTypes(@ptrCast(*const IDebugCallbackNotificationHandler, self), pCallbackMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_BeforeDispatchEvent(self: *const T, pEvent: *IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).BeforeDispatchEvent(@ptrCast(*const IDebugCallbackNotificationHandler, self), pEvent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_DispatchEventComplete(self: *const T, pEvent: *IUnknown, propagationStatus: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).DispatchEventComplete(@ptrCast(*const IDebugCallbackNotificationHandler, self), pEvent, propagationStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_BeforeInvokeDomCallback(self: *const T, pEvent: *IUnknown, pCallback: *IScriptEventHandler, eStage: DOM_EVENT_PHASE, propagationStatus: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).BeforeInvokeDomCallback(@ptrCast(*const IDebugCallbackNotificationHandler, self), pEvent, pCallback, eStage, propagationStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_InvokeDomCallbackComplete(self: *const T, pEvent: *IUnknown, pCallback: *IScriptEventHandler, eStage: DOM_EVENT_PHASE, propagationStatus: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).InvokeDomCallbackComplete(@ptrCast(*const IDebugCallbackNotificationHandler, self), pEvent, pCallback, eStage, propagationStatus);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_BeforeInvokeCallback(self: *const T, eCallbackType: SCRIPT_TIMER_TYPE, callbackCookie: u32, pDispHandler: *IDispatch, ullHandlerCookie: u64, functionName: BSTR, line: u32, column: u32, cchLength: u32, pDebugDocumentContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).BeforeInvokeCallback(@ptrCast(*const IDebugCallbackNotificationHandler, self), eCallbackType, callbackCookie, pDispHandler, ullHandlerCookie, functionName, line, column, cchLength, pDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCallbackNotificationHandler_InvokeCallbackComplete(self: *const T, eCallbackType: SCRIPT_TIMER_TYPE, callbackCookie: u32, pDispHandler: *IDispatch, ullHandlerCookie: u64, functionName: BSTR, line: u32, column: u32, cchLength: u32, pDebugDocumentContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCallbackNotificationHandler.VTable, self.vtable).InvokeCallbackComplete(@ptrCast(*const IDebugCallbackNotificationHandler, self), eCallbackType, callbackCookie, pDispHandler, ullHandlerCookie, functionName, line, column, cchLength, pDebugDocumentContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IScriptEventHandlerSourceInfo_Value = @import("../zig.zig").Guid.initString("30510841-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IScriptEventHandlerSourceInfo = &IID_IScriptEventHandlerSourceInfo_Value;
pub const IScriptEventHandlerSourceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSourceInfo: fn(
            self: *const IScriptEventHandlerSourceInfo,
            pbstrFunctionName: *BSTR,
            line: *u32,
            column: *u32,
            cchLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IScriptEventHandlerSourceInfo_GetSourceInfo(self: *const T, pbstrFunctionName: *BSTR, line: *u32, column: *u32, cchLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IScriptEventHandlerSourceInfo.VTable, self.vtable).GetSourceInfo(@ptrCast(*const IScriptEventHandlerSourceInfo, self), pbstrFunctionName, line, column, cchLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDOMEventRegistrationCallback_Value = @import("../zig.zig").Guid.initString("3051083B-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IDOMEventRegistrationCallback = &IID_IDOMEventRegistrationCallback_Value;
pub const IDOMEventRegistrationCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnDOMEventListenerAdded: fn(
            self: *const IDOMEventRegistrationCallback,
            pszEventType: [*:0]const u16,
            pHandler: *IScriptEventHandler,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDOMEventListenerRemoved: fn(
            self: *const IDOMEventRegistrationCallback,
            ullCookie: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEventRegistrationCallback_OnDOMEventListenerAdded(self: *const T, pszEventType: [*:0]const u16, pHandler: *IScriptEventHandler) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEventRegistrationCallback.VTable, self.vtable).OnDOMEventListenerAdded(@ptrCast(*const IDOMEventRegistrationCallback, self), pszEventType, pHandler);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDOMEventRegistrationCallback_OnDOMEventListenerRemoved(self: *const T, ullCookie: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDOMEventRegistrationCallback.VTable, self.vtable).OnDOMEventListenerRemoved(@ptrCast(*const IDOMEventRegistrationCallback, self), ullCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEventTarget2_Value = @import("../zig.zig").Guid.initString("30510839-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IEventTarget2 = &IID_IEventTarget2_Value;
pub const IEventTarget2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRegisteredEventTypes: fn(
            self: *const IEventTarget2,
            ppEventTypeArray: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetListenersForType: fn(
            self: *const IEventTarget2,
            pszEventType: [*:0]const u16,
            ppEventHandlerArray: **SAFEARRAY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterForDOMEventListeners: fn(
            self: *const IEventTarget2,
            pCallback: *IDOMEventRegistrationCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterForDOMEventListeners: fn(
            self: *const IEventTarget2,
            pCallback: *IDOMEventRegistrationCallback,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget2_GetRegisteredEventTypes(self: *const T, ppEventTypeArray: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget2.VTable, self.vtable).GetRegisteredEventTypes(@ptrCast(*const IEventTarget2, self), ppEventTypeArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget2_GetListenersForType(self: *const T, pszEventType: [*:0]const u16, ppEventHandlerArray: **SAFEARRAY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget2.VTable, self.vtable).GetListenersForType(@ptrCast(*const IEventTarget2, self), pszEventType, ppEventHandlerArray);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget2_RegisterForDOMEventListeners(self: *const T, pCallback: *IDOMEventRegistrationCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget2.VTable, self.vtable).RegisterForDOMEventListeners(@ptrCast(*const IEventTarget2, self), pCallback);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEventTarget2_UnregisterForDOMEventListeners(self: *const T, pCallback: *IDOMEventRegistrationCallback) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEventTarget2.VTable, self.vtable).UnregisterForDOMEventListeners(@ptrCast(*const IEventTarget2, self), pCallback);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_HTMLNamespaceEvents_Value = @import("../zig.zig").Guid.initString("3050F6BD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_HTMLNamespaceEvents = &IID_HTMLNamespaceEvents_Value;
pub const HTMLNamespaceEvents = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLNamespace_Value = @import("../zig.zig").Guid.initString("3050F6BB-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLNamespace = &IID_IHTMLNamespace_Value;
pub const IHTMLNamespace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_name: fn(
            self: *const IHTMLNamespace,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_urn: fn(
            self: *const IHTMLNamespace,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_tagNames: fn(
            self: *const IHTMLNamespace,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_readyState: fn(
            self: *const IHTMLNamespace,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_onreadystatechange: fn(
            self: *const IHTMLNamespace,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_onreadystatechange: fn(
            self: *const IHTMLNamespace,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        doImport: fn(
            self: *const IHTMLNamespace,
            bstrImplementationUrl: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        attachEvent: fn(
            self: *const IHTMLNamespace,
            event: BSTR,
            pDisp: *IDispatch,
            pfResult: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        detachEvent: fn(
            self: *const IHTMLNamespace,
            event: BSTR,
            pDisp: *IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_name(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_name(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_urn(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_urn(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_tagNames(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_tagNames(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_readyState(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_readyState(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_put_onreadystatechange(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).put_onreadystatechange(@ptrCast(*const IHTMLNamespace, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_get_onreadystatechange(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).get_onreadystatechange(@ptrCast(*const IHTMLNamespace, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_doImport(self: *const T, bstrImplementationUrl: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).doImport(@ptrCast(*const IHTMLNamespace, self), bstrImplementationUrl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_attachEvent(self: *const T, event: BSTR, pDisp: *IDispatch, pfResult: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).attachEvent(@ptrCast(*const IHTMLNamespace, self), event, pDisp, pfResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespace_detachEvent(self: *const T, event: BSTR, pDisp: *IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespace.VTable, self.vtable).detachEvent(@ptrCast(*const IHTMLNamespace, self), event, pDisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLNamespaceCollection_Value = @import("../zig.zig").Guid.initString("3050F6B8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLNamespaceCollection = &IID_IHTMLNamespaceCollection_Value;
pub const IHTMLNamespaceCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLNamespaceCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLNamespaceCollection,
            index: VARIANT,
            ppNamespace: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        add: fn(
            self: *const IHTMLNamespaceCollection,
            bstrNamespace: BSTR,
            bstrUrn: BSTR,
            implementationUrl: VARIANT,
            ppNamespace: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespaceCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespaceCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLNamespaceCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespaceCollection_item(self: *const T, index: VARIANT, ppNamespace: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespaceCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLNamespaceCollection, self), index, ppNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLNamespaceCollection_add(self: *const T, bstrNamespace: BSTR, bstrUrn: BSTR, implementationUrl: VARIANT, ppNamespace: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLNamespaceCollection.VTable, self.vtable).add(@ptrCast(*const IHTMLNamespaceCollection, self), bstrNamespace, bstrUrn, implementationUrl, ppNamespace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNamespace_Value = @import("../zig.zig").Guid.initString("3050F54F-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLNamespace = &IID_DispHTMLNamespace_Value;
pub const DispHTMLNamespace = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLNamespaceCollection_Value = @import("../zig.zig").Guid.initString("3050F550-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLNamespaceCollection = &IID_DispHTMLNamespaceCollection_Value;
pub const DispHTMLNamespaceCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPainter_Value = @import("../zig.zig").Guid.initString("3050F6A6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPainter = &IID_IHTMLPainter_Value;
pub const IHTMLPainter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Draw: fn(
            self: *const IHTMLPainter,
            rcBounds: RECT,
            rcUpdate: RECT,
            lDrawFlags: i32,
            hdc: HDC,
            pvDrawObject: *c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnResize: fn(
            self: *const IHTMLPainter,
            size: SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPainterInfo: fn(
            self: *const IHTMLPainter,
            pInfo: *HTML_PAINTER_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HitTestPoint: fn(
            self: *const IHTMLPainter,
            pt: POINT,
            pbHit: *BOOL,
            plPartID: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainter_Draw(self: *const T, rcBounds: RECT, rcUpdate: RECT, lDrawFlags: i32, hdc: HDC, pvDrawObject: *c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainter.VTable, self.vtable).Draw(@ptrCast(*const IHTMLPainter, self), rcBounds, rcUpdate, lDrawFlags, hdc, pvDrawObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainter_OnResize(self: *const T, size: SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainter.VTable, self.vtable).OnResize(@ptrCast(*const IHTMLPainter, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainter_GetPainterInfo(self: *const T, pInfo: *HTML_PAINTER_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainter.VTable, self.vtable).GetPainterInfo(@ptrCast(*const IHTMLPainter, self), pInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainter_HitTestPoint(self: *const T, pt: POINT, pbHit: *BOOL, plPartID: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainter.VTable, self.vtable).HitTestPoint(@ptrCast(*const IHTMLPainter, self), pt, pbHit, plPartID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPaintSite_Value = @import("../zig.zig").Guid.initString("3050F6A7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPaintSite = &IID_IHTMLPaintSite_Value;
pub const IHTMLPaintSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvalidatePainterInfo: fn(
            self: *const IHTMLPaintSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateRect: fn(
            self: *const IHTMLPaintSite,
            prcInvalid: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateRegion: fn(
            self: *const IHTMLPaintSite,
            rgnInvalid: HRGN,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDrawInfo: fn(
            self: *const IHTMLPaintSite,
            lFlags: i32,
            pDrawInfo: *HTML_PAINT_DRAW_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransformGlobalToLocal: fn(
            self: *const IHTMLPaintSite,
            ptGlobal: POINT,
            pptLocal: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TransformLocalToGlobal: fn(
            self: *const IHTMLPaintSite,
            ptLocal: POINT,
            pptGlobal: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHitTestCookie: fn(
            self: *const IHTMLPaintSite,
            plCookie: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_InvalidatePainterInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).InvalidatePainterInfo(@ptrCast(*const IHTMLPaintSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_InvalidateRect(self: *const T, prcInvalid: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).InvalidateRect(@ptrCast(*const IHTMLPaintSite, self), prcInvalid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_InvalidateRegion(self: *const T, rgnInvalid: HRGN) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).InvalidateRegion(@ptrCast(*const IHTMLPaintSite, self), rgnInvalid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_GetDrawInfo(self: *const T, lFlags: i32, pDrawInfo: *HTML_PAINT_DRAW_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).GetDrawInfo(@ptrCast(*const IHTMLPaintSite, self), lFlags, pDrawInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_TransformGlobalToLocal(self: *const T, ptGlobal: POINT, pptLocal: *POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).TransformGlobalToLocal(@ptrCast(*const IHTMLPaintSite, self), ptGlobal, pptLocal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_TransformLocalToGlobal(self: *const T, ptLocal: POINT, pptGlobal: *POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).TransformLocalToGlobal(@ptrCast(*const IHTMLPaintSite, self), ptLocal, pptGlobal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPaintSite_GetHitTestCookie(self: *const T, plCookie: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPaintSite.VTable, self.vtable).GetHitTestCookie(@ptrCast(*const IHTMLPaintSite, self), plCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPainterEventInfo_Value = @import("../zig.zig").Guid.initString("3050F6DF-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPainterEventInfo = &IID_IHTMLPainterEventInfo_Value;
pub const IHTMLPainterEventInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventInfoFlags: fn(
            self: *const IHTMLPainterEventInfo,
            plEventInfoFlags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventTarget: fn(
            self: *const IHTMLPainterEventInfo,
            ppElement: **IHTMLElement,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCursor: fn(
            self: *const IHTMLPainterEventInfo,
            lPartID: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StringFromPartID: fn(
            self: *const IHTMLPainterEventInfo,
            lPartID: i32,
            pbstrPart: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterEventInfo_GetEventInfoFlags(self: *const T, plEventInfoFlags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterEventInfo.VTable, self.vtable).GetEventInfoFlags(@ptrCast(*const IHTMLPainterEventInfo, self), plEventInfoFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterEventInfo_GetEventTarget(self: *const T, ppElement: **IHTMLElement) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterEventInfo.VTable, self.vtable).GetEventTarget(@ptrCast(*const IHTMLPainterEventInfo, self), ppElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterEventInfo_SetCursor(self: *const T, lPartID: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterEventInfo.VTable, self.vtable).SetCursor(@ptrCast(*const IHTMLPainterEventInfo, self), lPartID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterEventInfo_StringFromPartID(self: *const T, lPartID: i32, pbstrPart: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterEventInfo.VTable, self.vtable).StringFromPartID(@ptrCast(*const IHTMLPainterEventInfo, self), lPartID, pbstrPart);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPainterOverlay_Value = @import("../zig.zig").Guid.initString("3050F7E3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPainterOverlay = &IID_IHTMLPainterOverlay_Value;
pub const IHTMLPainterOverlay = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnMove: fn(
            self: *const IHTMLPainterOverlay,
            rcDevice: RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPainterOverlay_OnMove(self: *const T, rcDevice: RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPainterOverlay.VTable, self.vtable).OnMove(@ptrCast(*const IHTMLPainterOverlay, self), rcDevice);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLIPrintCollection_Value = @import("../zig.zig").Guid.initString("3050F6B5-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLIPrintCollection = &IID_IHTMLIPrintCollection_Value;
pub const IHTMLIPrintCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_length: fn(
            self: *const IHTMLIPrintCollection,
            p: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get__newEnum: fn(
            self: *const IHTMLIPrintCollection,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        item: fn(
            self: *const IHTMLIPrintCollection,
            index: i32,
            ppIPrint: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIPrintCollection_get_length(self: *const T, p: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIPrintCollection.VTable, self.vtable).get_length(@ptrCast(*const IHTMLIPrintCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIPrintCollection_get__newEnum(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIPrintCollection.VTable, self.vtable).get__newEnum(@ptrCast(*const IHTMLIPrintCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLIPrintCollection_item(self: *const T, index: i32, ppIPrint: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLIPrintCollection.VTable, self.vtable).item(@ptrCast(*const IHTMLIPrintCollection, self), index, ppIPrint);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumPrivacyRecords_Value = @import("../zig.zig").Guid.initString("3050F844-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IEnumPrivacyRecords = &IID_IEnumPrivacyRecords_Value;
pub const IEnumPrivacyRecords = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IEnumPrivacyRecords,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IEnumPrivacyRecords,
            pSize: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivacyImpacted: fn(
            self: *const IEnumPrivacyRecords,
            pState: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Next: fn(
            self: *const IEnumPrivacyRecords,
            pbstrUrl: *BSTR,
            pbstrPolicyRef: *BSTR,
            pdwReserved: *i32,
            pdwPrivacyFlags: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPrivacyRecords_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPrivacyRecords.VTable, self.vtable).Reset(@ptrCast(*const IEnumPrivacyRecords, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPrivacyRecords_GetSize(self: *const T, pSize: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPrivacyRecords.VTable, self.vtable).GetSize(@ptrCast(*const IEnumPrivacyRecords, self), pSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPrivacyRecords_GetPrivacyImpacted(self: *const T, pState: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPrivacyRecords.VTable, self.vtable).GetPrivacyImpacted(@ptrCast(*const IEnumPrivacyRecords, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumPrivacyRecords_Next(self: *const T, pbstrUrl: *BSTR, pbstrPolicyRef: *BSTR, pdwReserved: *i32, pdwPrivacyFlags: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumPrivacyRecords.VTable, self.vtable).Next(@ptrCast(*const IEnumPrivacyRecords, self), pbstrUrl, pbstrPolicyRef, pdwReserved, pdwPrivacyFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWPCBlockedUrls_Value = @import("../zig.zig").Guid.initString("30510413-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IWPCBlockedUrls = &IID_IWPCBlockedUrls_Value;
pub const IWPCBlockedUrls = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCount: fn(
            self: *const IWPCBlockedUrls,
            pdwCount: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetUrl: fn(
            self: *const IWPCBlockedUrls,
            dwIdx: u32,
            pbstrUrl: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWPCBlockedUrls_GetCount(self: *const T, pdwCount: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWPCBlockedUrls.VTable, self.vtable).GetCount(@ptrCast(*const IWPCBlockedUrls, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWPCBlockedUrls_GetUrl(self: *const T, dwIdx: u32, pbstrUrl: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWPCBlockedUrls.VTable, self.vtable).GetUrl(@ptrCast(*const IWPCBlockedUrls, self), dwIdx, pbstrUrl);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDOMConstructorCollection_Value = @import("../zig.zig").Guid.initString("3051049C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDOMConstructorCollection = &IID_IHTMLDOMConstructorCollection_Value;
pub const IHTMLDOMConstructorCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_Attr: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BehaviorUrnsCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BookmarkCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CompatibleInfo: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CompatibleInfoCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ControlRangeCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CSSCurrentStyleDeclaration: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CSSRuleList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CSSRuleStyleDeclaration: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CSSStyleDeclaration: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CSSStyleRule: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CSSStyleSheet: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DataTransfer: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_DOMImplementation: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Element: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Event: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_History: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTCElementBehaviorDefaults: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLAnchorElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLAreaElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLAreasCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLBaseElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLBaseFontElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLBGSoundElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLBlockElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLBodyElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLBRElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLButtonElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLCommentElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLDDElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLDivElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLDocument: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLDListElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLDTElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLEmbedElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLFieldSetElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLFontElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLFormElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLFrameElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLFrameSetElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLGenericElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLHeadElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLHeadingElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLHRElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLHtmlElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLIFrameElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLImageElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLInputElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLIsIndexElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLLabelElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLLegendElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLLIElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLLinkElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLMapElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLMarqueeElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLMetaElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLModelessDialog: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLNamespaceInfo: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLNamespaceInfoCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLNextIdElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLNoShowElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLObjectElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLOListElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLOptionElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLParagraphElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLParamElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLPhraseElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLPluginsCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLPopup: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLScriptElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLSelectElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLSpanElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLStyleElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLTableCaptionElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLTableCellElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLTableColElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLTableElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLTableRowElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLTableSectionElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLTextAreaElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLTextElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLTitleElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLUListElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_HTMLUnknownElement: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Image: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Location: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_NamedNodeMap: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Navigator: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_NodeList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Option: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Screen: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Selection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_StaticNodeList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Storage: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_StyleSheetList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_StyleSheetPage: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_StyleSheetPageList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Text: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TextRange: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TextRangeCollection: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TextRectangle: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_TextRectangleList: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Window: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_XDomainRequest: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_XMLHttpRequest: fn(
            self: *const IHTMLDOMConstructorCollection,
            p: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Attr(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Attr(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_BehaviorUrnsCollection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_BehaviorUrnsCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_BookmarkCollection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_BookmarkCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CompatibleInfo(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CompatibleInfo(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CompatibleInfoCollection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CompatibleInfoCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_ControlRangeCollection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_ControlRangeCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSCurrentStyleDeclaration(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSCurrentStyleDeclaration(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSRuleList(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSRuleList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSRuleStyleDeclaration(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSRuleStyleDeclaration(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSStyleDeclaration(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSStyleDeclaration(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSStyleRule(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSStyleRule(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_CSSStyleSheet(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_CSSStyleSheet(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_DataTransfer(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_DataTransfer(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_DOMImplementation(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_DOMImplementation(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Element(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Element(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Event(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Event(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_History(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_History(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTCElementBehaviorDefaults(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTCElementBehaviorDefaults(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLAnchorElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLAnchorElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLAreaElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLAreaElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLAreasCollection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLAreasCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBaseElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBaseElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBaseFontElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBaseFontElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBGSoundElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBGSoundElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBlockElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBlockElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBodyElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBodyElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLBRElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLBRElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLButtonElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLButtonElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLCollection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLCommentElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLCommentElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDDElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDDElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDivElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDivElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDocument(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDocument(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDListElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDListElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLDTElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLDTElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLEmbedElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLEmbedElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFieldSetElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFieldSetElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFontElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFontElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFormElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFormElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFrameElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFrameElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLFrameSetElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLFrameSetElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLGenericElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLGenericElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLHeadElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLHeadElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLHeadingElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLHeadingElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLHRElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLHRElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLHtmlElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLHtmlElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLIFrameElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLIFrameElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLImageElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLImageElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLInputElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLInputElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLIsIndexElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLIsIndexElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLLabelElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLLabelElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLLegendElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLLegendElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLLIElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLLIElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLLinkElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLLinkElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLMapElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLMapElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLMarqueeElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLMarqueeElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLMetaElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLMetaElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLModelessDialog(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLModelessDialog(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLNamespaceInfo(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLNamespaceInfo(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLNamespaceInfoCollection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLNamespaceInfoCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLNextIdElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLNextIdElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLNoShowElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLNoShowElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLObjectElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLObjectElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLOListElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLOListElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLOptionElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLOptionElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLParagraphElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLParagraphElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLParamElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLParamElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLPhraseElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLPhraseElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLPluginsCollection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLPluginsCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLPopup(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLPopup(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLScriptElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLScriptElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLSelectElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLSelectElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLSpanElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLSpanElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLStyleElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLStyleElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableCaptionElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableCaptionElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableCellElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableCellElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableColElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableColElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableRowElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableRowElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTableSectionElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTableSectionElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTextAreaElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTextAreaElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTextElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTextElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLTitleElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLTitleElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLUListElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLUListElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_HTMLUnknownElement(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_HTMLUnknownElement(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Image(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Image(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Location(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Location(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_NamedNodeMap(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_NamedNodeMap(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Navigator(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Navigator(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_NodeList(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_NodeList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Option(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Option(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Screen(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Screen(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Selection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Selection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_StaticNodeList(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_StaticNodeList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Storage(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Storage(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_StyleSheetList(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_StyleSheetList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_StyleSheetPage(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_StyleSheetPage(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_StyleSheetPageList(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_StyleSheetPageList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Text(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Text(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_TextRange(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_TextRange(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_TextRangeCollection(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_TextRangeCollection(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_TextRectangle(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_TextRectangle(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_TextRectangleList(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_TextRectangleList(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_Window(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_Window(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_XDomainRequest(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_XDomainRequest(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDOMConstructorCollection_get_XMLHttpRequest(self: *const T, p: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDOMConstructorCollection.VTable, self.vtable).get_XMLHttpRequest(@ptrCast(*const IHTMLDOMConstructorCollection, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDialog_Value = @import("../zig.zig").Guid.initString("3050F216-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDialog = &IID_IHTMLDialog_Value;
pub const IHTMLDialog = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_dialogTop: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dialogTop: fn(
            self: *const IHTMLDialog,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dialogLeft: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dialogLeft: fn(
            self: *const IHTMLDialog,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dialogWidth: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dialogWidth: fn(
            self: *const IHTMLDialog,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dialogHeight: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dialogHeight: fn(
            self: *const IHTMLDialog,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dialogArguments: fn(
            self: *const IHTMLDialog,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_menuArguments: fn(
            self: *const IHTMLDialog,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_returnValue: fn(
            self: *const IHTMLDialog,
            v: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_returnValue: fn(
            self: *const IHTMLDialog,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        close: fn(
            self: *const IHTMLDialog,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        toString: fn(
            self: *const IHTMLDialog,
            String: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_dialogTop(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_dialogTop(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogTop(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogTop(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_dialogLeft(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_dialogLeft(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogLeft(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogLeft(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_dialogWidth(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_dialogWidth(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogWidth(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogWidth(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_dialogHeight(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_dialogHeight(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogHeight(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogHeight(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_dialogArguments(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_dialogArguments(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_menuArguments(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_menuArguments(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_put_returnValue(self: *const T, v: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).put_returnValue(@ptrCast(*const IHTMLDialog, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_get_returnValue(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).get_returnValue(@ptrCast(*const IHTMLDialog, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).close(@ptrCast(*const IHTMLDialog, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog_toString(self: *const T, String: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog.VTable, self.vtable).toString(@ptrCast(*const IHTMLDialog, self), String);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDialog2_Value = @import("../zig.zig").Guid.initString("3050F5E0-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDialog2 = &IID_IHTMLDialog2_Value;
pub const IHTMLDialog2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_status: fn(
            self: *const IHTMLDialog2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_status: fn(
            self: *const IHTMLDialog2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_resizable: fn(
            self: *const IHTMLDialog2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_resizable: fn(
            self: *const IHTMLDialog2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog2_put_status(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog2.VTable, self.vtable).put_status(@ptrCast(*const IHTMLDialog2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog2_get_status(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog2.VTable, self.vtable).get_status(@ptrCast(*const IHTMLDialog2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog2_put_resizable(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog2.VTable, self.vtable).put_resizable(@ptrCast(*const IHTMLDialog2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog2_get_resizable(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog2.VTable, self.vtable).get_resizable(@ptrCast(*const IHTMLDialog2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLDialog3_Value = @import("../zig.zig").Guid.initString("3050F388-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLDialog3 = &IID_IHTMLDialog3_Value;
pub const IHTMLDialog3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_unadorned: fn(
            self: *const IHTMLDialog3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_unadorned: fn(
            self: *const IHTMLDialog3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_dialogHide: fn(
            self: *const IHTMLDialog3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_dialogHide: fn(
            self: *const IHTMLDialog3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog3_put_unadorned(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog3.VTable, self.vtable).put_unadorned(@ptrCast(*const IHTMLDialog3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog3_get_unadorned(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog3.VTable, self.vtable).get_unadorned(@ptrCast(*const IHTMLDialog3, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog3_put_dialogHide(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog3.VTable, self.vtable).put_dialogHide(@ptrCast(*const IHTMLDialog3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLDialog3_get_dialogHide(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLDialog3.VTable, self.vtable).get_dialogHide(@ptrCast(*const IHTMLDialog3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLModelessInit_Value = @import("../zig.zig").Guid.initString("3050F5E4-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLModelessInit = &IID_IHTMLModelessInit_Value;
pub const IHTMLModelessInit = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_parameters: fn(
            self: *const IHTMLModelessInit,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_optionString: fn(
            self: *const IHTMLModelessInit,
            p: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_moniker: fn(
            self: *const IHTMLModelessInit,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_document: fn(
            self: *const IHTMLModelessInit,
            p: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLModelessInit_get_parameters(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLModelessInit.VTable, self.vtable).get_parameters(@ptrCast(*const IHTMLModelessInit, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLModelessInit_get_optionString(self: *const T, p: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLModelessInit.VTable, self.vtable).get_optionString(@ptrCast(*const IHTMLModelessInit, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLModelessInit_get_moniker(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLModelessInit.VTable, self.vtable).get_moniker(@ptrCast(*const IHTMLModelessInit, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLModelessInit_get_document(self: *const T, p: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLModelessInit.VTable, self.vtable).get_document(@ptrCast(*const IHTMLModelessInit, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLPopup_Value = @import("../zig.zig").Guid.initString("3050F666-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLPopup = &IID_IHTMLPopup_Value;
pub const IHTMLPopup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        show: fn(
            self: *const IHTMLPopup,
            x: i32,
            y: i32,
            w: i32,
            h: i32,
            pElement: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        hide: fn(
            self: *const IHTMLPopup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_document: fn(
            self: *const IHTMLPopup,
            p: **IHTMLDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_isOpen: fn(
            self: *const IHTMLPopup,
            p: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPopup_show(self: *const T, x: i32, y: i32, w: i32, h: i32, pElement: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPopup.VTable, self.vtable).show(@ptrCast(*const IHTMLPopup, self), x, y, w, h, pElement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPopup_hide(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPopup.VTable, self.vtable).hide(@ptrCast(*const IHTMLPopup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPopup_get_document(self: *const T, p: **IHTMLDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPopup.VTable, self.vtable).get_document(@ptrCast(*const IHTMLPopup, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLPopup_get_isOpen(self: *const T, p: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLPopup.VTable, self.vtable).get_isOpen(@ptrCast(*const IHTMLPopup, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLPopup_Value = @import("../zig.zig").Guid.initString("3050F589-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLPopup = &IID_DispHTMLPopup_Value;
pub const DispHTMLPopup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAppBehavior_Value = @import("../zig.zig").Guid.initString("3050F5CA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAppBehavior = &IID_IHTMLAppBehavior_Value;
pub const IHTMLAppBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_applicationName: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_applicationName: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_version: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_version: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_icon: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_icon: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_singleInstance: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_singleInstance: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_minimizeButton: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_minimizeButton: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_maximizeButton: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_maximizeButton: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_border: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_border: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_borderStyle: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_borderStyle: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_sysMenu: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_sysMenu: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_caption: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_caption: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_windowState: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_windowState: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_showInTaskBar: fn(
            self: *const IHTMLAppBehavior,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_showInTaskBar: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_commandLine: fn(
            self: *const IHTMLAppBehavior,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_applicationName(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_applicationName(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_applicationName(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_applicationName(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_version(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_version(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_version(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_version(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_icon(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_icon(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_icon(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_icon(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_singleInstance(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_singleInstance(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_singleInstance(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_singleInstance(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_minimizeButton(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_minimizeButton(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_minimizeButton(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_minimizeButton(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_maximizeButton(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_maximizeButton(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_maximizeButton(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_maximizeButton(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_border(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_border(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_border(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_border(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_borderStyle(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_borderStyle(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_borderStyle(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_borderStyle(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_sysMenu(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_sysMenu(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_sysMenu(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_sysMenu(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_caption(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_caption(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_caption(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_caption(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_windowState(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_windowState(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_windowState(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_windowState(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_put_showInTaskBar(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).put_showInTaskBar(@ptrCast(*const IHTMLAppBehavior, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_showInTaskBar(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_showInTaskBar(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior_get_commandLine(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior.VTable, self.vtable).get_commandLine(@ptrCast(*const IHTMLAppBehavior, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAppBehavior2_Value = @import("../zig.zig").Guid.initString("3050F5C9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAppBehavior2 = &IID_IHTMLAppBehavior2_Value;
pub const IHTMLAppBehavior2 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_contextMenu: fn(
            self: *const IHTMLAppBehavior2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_contextMenu: fn(
            self: *const IHTMLAppBehavior2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_innerBorder: fn(
            self: *const IHTMLAppBehavior2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_innerBorder: fn(
            self: *const IHTMLAppBehavior2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scroll: fn(
            self: *const IHTMLAppBehavior2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scroll: fn(
            self: *const IHTMLAppBehavior2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_scrollFlat: fn(
            self: *const IHTMLAppBehavior2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_scrollFlat: fn(
            self: *const IHTMLAppBehavior2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_selection: fn(
            self: *const IHTMLAppBehavior2,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_selection: fn(
            self: *const IHTMLAppBehavior2,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_contextMenu(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_contextMenu(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_contextMenu(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_contextMenu(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_innerBorder(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_innerBorder(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_innerBorder(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_innerBorder(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_scroll(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_scroll(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_scroll(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_scroll(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_scrollFlat(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_scrollFlat(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_scrollFlat(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_scrollFlat(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_put_selection(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).put_selection(@ptrCast(*const IHTMLAppBehavior2, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior2_get_selection(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior2.VTable, self.vtable).get_selection(@ptrCast(*const IHTMLAppBehavior2, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHTMLAppBehavior3_Value = @import("../zig.zig").Guid.initString("3050F5CD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHTMLAppBehavior3 = &IID_IHTMLAppBehavior3_Value;
pub const IHTMLAppBehavior3 = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_navigable: fn(
            self: *const IHTMLAppBehavior3,
            v: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_navigable: fn(
            self: *const IHTMLAppBehavior3,
            p: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior3_put_navigable(self: *const T, v: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior3.VTable, self.vtable).put_navigable(@ptrCast(*const IHTMLAppBehavior3, self), v);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHTMLAppBehavior3_get_navigable(self: *const T, p: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHTMLAppBehavior3.VTable, self.vtable).get_navigable(@ptrCast(*const IHTMLAppBehavior3, self), p);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispHTMLAppBehavior_Value = @import("../zig.zig").Guid.initString("3050F57C-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispHTMLAppBehavior = &IID_DispHTMLAppBehavior_Value;
pub const DispHTMLAppBehavior = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLInputButtonElement_Value = @import("../zig.zig").Guid.initString("3050F51E-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispIHTMLInputButtonElement = &IID_DispIHTMLInputButtonElement_Value;
pub const DispIHTMLInputButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLInputTextElement_Value = @import("../zig.zig").Guid.initString("3050F520-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispIHTMLInputTextElement = &IID_DispIHTMLInputTextElement_Value;
pub const DispIHTMLInputTextElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLInputFileElement_Value = @import("../zig.zig").Guid.initString("3050F542-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispIHTMLInputFileElement = &IID_DispIHTMLInputFileElement_Value;
pub const DispIHTMLInputFileElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLOptionButtonElement_Value = @import("../zig.zig").Guid.initString("3050F509-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispIHTMLOptionButtonElement = &IID_DispIHTMLOptionButtonElement_Value;
pub const DispIHTMLOptionButtonElement = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_DispIHTMLInputImage_Value = @import("../zig.zig").Guid.initString("3050F51D-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_DispIHTMLInputImage = &IID_DispIHTMLInputImage_Value;
pub const DispIHTMLInputImage = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespace_Value = @import("../zig.zig").Guid.initString("3050F671-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementNamespace = &IID_IElementNamespace_Value;
pub const IElementNamespace = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddTag: fn(
            self: *const IElementNamespace,
            bstrTagName: BSTR,
            lFlags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespace_AddTag(self: *const T, bstrTagName: BSTR, lFlags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespace.VTable, self.vtable).AddTag(@ptrCast(*const IElementNamespace, self), bstrTagName, lFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespaceTable_Value = @import("../zig.zig").Guid.initString("3050F670-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementNamespaceTable = &IID_IElementNamespaceTable_Value;
pub const IElementNamespaceTable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddNamespace: fn(
            self: *const IElementNamespaceTable,
            bstrNamespace: BSTR,
            bstrUrn: BSTR,
            lFlags: i32,
            pvarFactory: *VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespaceTable_AddNamespace(self: *const T, bstrNamespace: BSTR, bstrUrn: BSTR, lFlags: i32, pvarFactory: *VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespaceTable.VTable, self.vtable).AddNamespace(@ptrCast(*const IElementNamespaceTable, self), bstrNamespace, bstrUrn, lFlags, pvarFactory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespaceFactory_Value = @import("../zig.zig").Guid.initString("3050F672-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementNamespaceFactory = &IID_IElementNamespaceFactory_Value;
pub const IElementNamespaceFactory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Create: fn(
            self: *const IElementNamespaceFactory,
            pNamespace: *IElementNamespace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespaceFactory_Create(self: *const T, pNamespace: *IElementNamespace) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespaceFactory.VTable, self.vtable).Create(@ptrCast(*const IElementNamespaceFactory, self), pNamespace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespaceFactory2_Value = @import("../zig.zig").Guid.initString("3050F805-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementNamespaceFactory2 = &IID_IElementNamespaceFactory2_Value;
pub const IElementNamespaceFactory2 = extern struct {
    pub const VTable = extern struct {
        base: IElementNamespaceFactory.VTable,
        CreateWithImplementation: fn(
            self: *const IElementNamespaceFactory2,
            pNamespace: *IElementNamespace,
            bstrImplementation: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IElementNamespaceFactory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespaceFactory2_CreateWithImplementation(self: *const T, pNamespace: *IElementNamespace, bstrImplementation: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespaceFactory2.VTable, self.vtable).CreateWithImplementation(@ptrCast(*const IElementNamespaceFactory2, self), pNamespace, bstrImplementation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementNamespaceFactoryCallback_Value = @import("../zig.zig").Guid.initString("3050F7FD-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementNamespaceFactoryCallback = &IID_IElementNamespaceFactoryCallback_Value;
pub const IElementNamespaceFactoryCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Resolve: fn(
            self: *const IElementNamespaceFactoryCallback,
            bstrNamespace: BSTR,
            bstrTagName: BSTR,
            bstrAttrs: BSTR,
            pNamespace: *IElementNamespace,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementNamespaceFactoryCallback_Resolve(self: *const T, bstrNamespace: BSTR, bstrTagName: BSTR, bstrAttrs: BSTR, pNamespace: *IElementNamespace) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementNamespaceFactoryCallback.VTable, self.vtable).Resolve(@ptrCast(*const IElementNamespaceFactoryCallback, self), bstrNamespace, bstrTagName, bstrAttrs, pNamespace);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteOM2_Value = @import("../zig.zig").Guid.initString("3050F659-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorSiteOM2 = &IID_IElementBehaviorSiteOM2_Value;
pub const IElementBehaviorSiteOM2 = extern struct {
    pub const VTable = extern struct {
        base: IElementBehaviorSiteOM.VTable,
        GetDefaults: fn(
            self: *const IElementBehaviorSiteOM2,
            ppDefaults: **IHTMLElementDefaults,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IElementBehaviorSiteOM.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteOM2_GetDefaults(self: *const T, ppDefaults: **IHTMLElementDefaults) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteOM2.VTable, self.vtable).GetDefaults(@ptrCast(*const IElementBehaviorSiteOM2, self), ppDefaults);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorCategory_Value = @import("../zig.zig").Guid.initString("3050F4ED-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorCategory = &IID_IElementBehaviorCategory_Value;
pub const IElementBehaviorCategory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCategory: fn(
            self: *const IElementBehaviorCategory,
            ppchCategory: *PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorCategory_GetCategory(self: *const T, ppchCategory: *PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorCategory.VTable, self.vtable).GetCategory(@ptrCast(*const IElementBehaviorCategory, self), ppchCategory);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteCategory_Value = @import("../zig.zig").Guid.initString("3050F4EE-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorSiteCategory = &IID_IElementBehaviorSiteCategory_Value;
pub const IElementBehaviorSiteCategory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetRelatedBehaviors: fn(
            self: *const IElementBehaviorSiteCategory,
            lDirection: i32,
            pchCategory: PWSTR,
            ppEnumerator: **IEnumUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteCategory_GetRelatedBehaviors(self: *const T, lDirection: i32, pchCategory: PWSTR, ppEnumerator: **IEnumUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteCategory.VTable, self.vtable).GetRelatedBehaviors(@ptrCast(*const IElementBehaviorSiteCategory, self), lDirection, pchCategory, ppEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSubmit_Value = @import("../zig.zig").Guid.initString("3050F646-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorSubmit = &IID_IElementBehaviorSubmit_Value;
pub const IElementBehaviorSubmit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSubmitInfo: fn(
            self: *const IElementBehaviorSubmit,
            pSubmitData: *IHTMLSubmitData,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IElementBehaviorSubmit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSubmit_GetSubmitInfo(self: *const T, pSubmitData: *IHTMLSubmitData) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSubmit.VTable, self.vtable).GetSubmitInfo(@ptrCast(*const IElementBehaviorSubmit, self), pSubmitData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSubmit_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSubmit.VTable, self.vtable).Reset(@ptrCast(*const IElementBehaviorSubmit, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorFocus_Value = @import("../zig.zig").Guid.initString("3050F6B6-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorFocus = &IID_IElementBehaviorFocus_Value;
pub const IElementBehaviorFocus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFocusRect: fn(
            self: *const IElementBehaviorFocus,
            pRect: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorFocus_GetFocusRect(self: *const T, pRect: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorFocus.VTable, self.vtable).GetFocusRect(@ptrCast(*const IElementBehaviorFocus, self), pRect);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorLayout_Value = @import("../zig.zig").Guid.initString("3050F6BA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorLayout = &IID_IElementBehaviorLayout_Value;
pub const IElementBehaviorLayout = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSize: fn(
            self: *const IElementBehaviorLayout,
            dwFlags: i32,
            sizeContent: SIZE,
            pptTranslateBy: *POINT,
            pptTopLeft: *POINT,
            psizeProposed: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLayoutInfo: fn(
            self: *const IElementBehaviorLayout,
            plLayoutInfo: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const IElementBehaviorLayout,
            lFlags: i32,
            pptTopLeft: *POINT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapSize: fn(
            self: *const IElementBehaviorLayout,
            psizeIn: *SIZE,
            prcOut: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout_GetSize(self: *const T, dwFlags: i32, sizeContent: SIZE, pptTranslateBy: *POINT, pptTopLeft: *POINT, psizeProposed: *SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout.VTable, self.vtable).GetSize(@ptrCast(*const IElementBehaviorLayout, self), dwFlags, sizeContent, pptTranslateBy, pptTopLeft, psizeProposed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout_GetLayoutInfo(self: *const T, plLayoutInfo: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout.VTable, self.vtable).GetLayoutInfo(@ptrCast(*const IElementBehaviorLayout, self), plLayoutInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout_GetPosition(self: *const T, lFlags: i32, pptTopLeft: *POINT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout.VTable, self.vtable).GetPosition(@ptrCast(*const IElementBehaviorLayout, self), lFlags, pptTopLeft);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout_MapSize(self: *const T, psizeIn: *SIZE, prcOut: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout.VTable, self.vtable).MapSize(@ptrCast(*const IElementBehaviorLayout, self), psizeIn, prcOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorLayout2_Value = @import("../zig.zig").Guid.initString("3050F846-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorLayout2 = &IID_IElementBehaviorLayout2_Value;
pub const IElementBehaviorLayout2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTextDescent: fn(
            self: *const IElementBehaviorLayout2,
            plDescent: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorLayout2_GetTextDescent(self: *const T, plDescent: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorLayout2.VTable, self.vtable).GetTextDescent(@ptrCast(*const IElementBehaviorLayout2, self), plDescent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteLayout_Value = @import("../zig.zig").Guid.initString("3050F6B7-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorSiteLayout = &IID_IElementBehaviorSiteLayout_Value;
pub const IElementBehaviorSiteLayout = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InvalidateLayoutInfo: fn(
            self: *const IElementBehaviorSiteLayout,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvalidateSize: fn(
            self: *const IElementBehaviorSiteLayout,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMediaResolution: fn(
            self: *const IElementBehaviorSiteLayout,
            psizeResolution: *SIZE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteLayout_InvalidateLayoutInfo(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteLayout.VTable, self.vtable).InvalidateLayoutInfo(@ptrCast(*const IElementBehaviorSiteLayout, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteLayout_InvalidateSize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteLayout.VTable, self.vtable).InvalidateSize(@ptrCast(*const IElementBehaviorSiteLayout, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteLayout_GetMediaResolution(self: *const T, psizeResolution: *SIZE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteLayout.VTable, self.vtable).GetMediaResolution(@ptrCast(*const IElementBehaviorSiteLayout, self), psizeResolution);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IElementBehaviorSiteLayout2_Value = @import("../zig.zig").Guid.initString("3050F847-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IElementBehaviorSiteLayout2 = &IID_IElementBehaviorSiteLayout2_Value;
pub const IElementBehaviorSiteLayout2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFontInfo: fn(
            self: *const IElementBehaviorSiteLayout2,
            plf: *LOGFONTW,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IElementBehaviorSiteLayout2_GetFontInfo(self: *const T, plf: *LOGFONTW) callconv(.Inline) HRESULT {
            return @ptrCast(*const IElementBehaviorSiteLayout2.VTable, self.vtable).GetFontInfo(@ptrCast(*const IElementBehaviorSiteLayout2, self), plf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IHostBehaviorInit_Value = @import("../zig.zig").Guid.initString("3050F842-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IHostBehaviorInit = &IID_IHostBehaviorInit_Value;
pub const IHostBehaviorInit = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PopulateNamespaceTable: fn(
            self: *const IHostBehaviorInit,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostBehaviorInit_PopulateNamespaceTable(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHostBehaviorInit.VTable, self.vtable).PopulateNamespaceTable(@ptrCast(*const IHostBehaviorInit, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISurfacePresenter_Value = @import("../zig.zig").Guid.initString("305106E2-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ISurfacePresenter = &IID_ISurfacePresenter_Value;
pub const ISurfacePresenter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Present: fn(
            self: *const ISurfacePresenter,
            uBuffer: u32,
            pDirty: *RECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBuffer: fn(
            self: *const ISurfacePresenter,
            backBufferIndex: u32,
            riid: *const Guid,
            ppBuffer: **c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsCurrent: fn(
            self: *const ISurfacePresenter,
            pIsCurrent: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenter_Present(self: *const T, uBuffer: u32, pDirty: *RECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfacePresenter.VTable, self.vtable).Present(@ptrCast(*const ISurfacePresenter, self), uBuffer, pDirty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenter_GetBuffer(self: *const T, backBufferIndex: u32, riid: *const Guid, ppBuffer: **c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfacePresenter.VTable, self.vtable).GetBuffer(@ptrCast(*const ISurfacePresenter, self), backBufferIndex, riid, ppBuffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISurfacePresenter_IsCurrent(self: *const T, pIsCurrent: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISurfacePresenter.VTable, self.vtable).IsCurrent(@ptrCast(*const ISurfacePresenter, self), pIsCurrent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentSite_Value = @import("../zig.zig").Guid.initString("305106E1-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IViewObjectPresentSite = &IID_IViewObjectPresentSite_Value;
pub const IViewObjectPresentSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateSurfacePresenter: fn(
            self: *const IViewObjectPresentSite,
            pDevice: *IUnknown,
            width: u32,
            height: u32,
            backBufferCount: u32,
            format: DXGI_FORMAT,
            mode: VIEW_OBJECT_ALPHA_MODE,
            ppQueue: **ISurfacePresenter,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsHardwareComposition: fn(
            self: *const IViewObjectPresentSite,
            pIsHardwareComposition: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCompositionMode: fn(
            self: *const IViewObjectPresentSite,
            mode: VIEW_OBJECT_COMPOSITION_MODE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentSite_CreateSurfacePresenter(self: *const T, pDevice: *IUnknown, width: u32, height: u32, backBufferCount: u32, format: DXGI_FORMAT, mode: VIEW_OBJECT_ALPHA_MODE, ppQueue: **ISurfacePresenter) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentSite.VTable, self.vtable).CreateSurfacePresenter(@ptrCast(*const IViewObjectPresentSite, self), pDevice, width, height, backBufferCount, format, mode, ppQueue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentSite_IsHardwareComposition(self: *const T, pIsHardwareComposition: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentSite.VTable, self.vtable).IsHardwareComposition(@ptrCast(*const IViewObjectPresentSite, self), pIsHardwareComposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentSite_SetCompositionMode(self: *const T, mode: VIEW_OBJECT_COMPOSITION_MODE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentSite.VTable, self.vtable).SetCompositionMode(@ptrCast(*const IViewObjectPresentSite, self), mode);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ICanvasPixelArrayData_Value = @import("../zig.zig").Guid.initString("305107F9-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ICanvasPixelArrayData = &IID_ICanvasPixelArrayData_Value;
pub const ICanvasPixelArrayData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetBufferPointer: fn(
            self: *const ICanvasPixelArrayData,
            ppBuffer: **u8,
            pBufferLength: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICanvasPixelArrayData_GetBufferPointer(self: *const T, ppBuffer: **u8, pBufferLength: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICanvasPixelArrayData.VTable, self.vtable).GetBufferPointer(@ptrCast(*const ICanvasPixelArrayData, self), ppBuffer, pBufferLength);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPrint_Value = @import("../zig.zig").Guid.initString("305106E3-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IViewObjectPrint = &IID_IViewObjectPrint_Value;
pub const IViewObjectPrint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPrintBitmap: fn(
            self: *const IViewObjectPrint,
            ppPrintBitmap: **IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPrint_GetPrintBitmap(self: *const T, ppPrintBitmap: **IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPrint.VTable, self.vtable).GetPrintBitmap(@ptrCast(*const IViewObjectPrint, self), ppPrintBitmap);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentNotifySite_Value = @import("../zig.zig").Guid.initString("305107FA-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IViewObjectPresentNotifySite = &IID_IViewObjectPresentNotifySite_Value;
pub const IViewObjectPresentNotifySite = extern struct {
    pub const VTable = extern struct {
        base: IViewObjectPresentSite.VTable,
        RequestFrame: fn(
            self: *const IViewObjectPresentNotifySite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IViewObjectPresentSite.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentNotifySite_RequestFrame(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentNotifySite.VTable, self.vtable).RequestFrame(@ptrCast(*const IViewObjectPresentNotifySite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IViewObjectPresentNotify_Value = @import("../zig.zig").Guid.initString("305107F8-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IViewObjectPresentNotify = &IID_IViewObjectPresentNotify_Value;
pub const IViewObjectPresentNotify = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPreRender: fn(
            self: *const IViewObjectPresentNotify,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IViewObjectPresentNotify_OnPreRender(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IViewObjectPresentNotify.VTable, self.vtable).OnPreRender(@ptrCast(*const IViewObjectPresentNotify, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITrackingProtection_Value = @import("../zig.zig").Guid.initString("30510803-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_ITrackingProtection = &IID_ITrackingProtection_Value;
pub const ITrackingProtection = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EvaluateUrl: fn(
            self: *const ITrackingProtection,
            bstrUrl: BSTR,
            pfAllowed: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEnabled: fn(
            self: *const ITrackingProtection,
            pfEnabled: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackingProtection_EvaluateUrl(self: *const T, bstrUrl: BSTR, pfAllowed: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrackingProtection.VTable, self.vtable).EvaluateUrl(@ptrCast(*const ITrackingProtection, self), bstrUrl, pfAllowed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITrackingProtection_GetEnabled(self: *const T, pfEnabled: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITrackingProtection.VTable, self.vtable).GetEnabled(@ptrCast(*const ITrackingProtection, self), pfEnabled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBFCacheable_Value = @import("../zig.zig").Guid.initString("30510861-98B5-11CF-BB82-00AA00BDCE0B");
pub const IID_IBFCacheable = &IID_IBFCacheable_Value;
pub const IBFCacheable = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnterBFCache: fn(
            self: *const IBFCacheable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitBFCache: fn(
            self: *const IBFCacheable,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBFCacheable_EnterBFCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBFCacheable.VTable, self.vtable).EnterBFCache(@ptrCast(*const IBFCacheable, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBFCacheable_ExitBFCache(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBFCacheable.VTable, self.vtable).ExitBFCache(@ptrCast(*const IBFCacheable, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebApplicationScriptEvents_Value = @import("../zig.zig").Guid.initString("7C3F6998-1567-4BBA-B52B-48D32141D613");
pub const IID_IWebApplicationScriptEvents = &IID_IWebApplicationScriptEvents_Value;
pub const IWebApplicationScriptEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeforeScriptExecute: fn(
            self: *const IWebApplicationScriptEvents,
            htmlWindow: *IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScriptError: fn(
            self: *const IWebApplicationScriptEvents,
            htmlWindow: ?*IHTMLWindow2,
            scriptError: *IActiveScriptError,
            url: [*:0]const u16,
            errorHandled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationScriptEvents_BeforeScriptExecute(self: *const T, htmlWindow: *IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationScriptEvents.VTable, self.vtable).BeforeScriptExecute(@ptrCast(*const IWebApplicationScriptEvents, self), htmlWindow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationScriptEvents_ScriptError(self: *const T, htmlWindow: ?*IHTMLWindow2, scriptError: *IActiveScriptError, url: [*:0]const u16, errorHandled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationScriptEvents.VTable, self.vtable).ScriptError(@ptrCast(*const IWebApplicationScriptEvents, self), htmlWindow, scriptError, url, errorHandled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebApplicationNavigationEvents_Value = @import("../zig.zig").Guid.initString("C22615D2-D318-4DA2-8422-1FCAF77B10E4");
pub const IID_IWebApplicationNavigationEvents = &IID_IWebApplicationNavigationEvents_Value;
pub const IWebApplicationNavigationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeforeNavigate: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: *IHTMLWindow2,
            url: [*:0]const u16,
            navigationFlags: u32,
            targetFrameName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateComplete: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: *IHTMLWindow2,
            url: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateError: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: *IHTMLWindow2,
            url: [*:0]const u16,
            targetFrameName: ?[*:0]const u16,
            statusCode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DocumentComplete: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: *IHTMLWindow2,
            url: [*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DownloadBegin: fn(
            self: *const IWebApplicationNavigationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DownloadComplete: fn(
            self: *const IWebApplicationNavigationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_BeforeNavigate(self: *const T, htmlWindow: *IHTMLWindow2, url: [*:0]const u16, navigationFlags: u32, targetFrameName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).BeforeNavigate(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url, navigationFlags, targetFrameName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_NavigateComplete(self: *const T, htmlWindow: *IHTMLWindow2, url: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).NavigateComplete(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_NavigateError(self: *const T, htmlWindow: *IHTMLWindow2, url: [*:0]const u16, targetFrameName: ?[*:0]const u16, statusCode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).NavigateError(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url, targetFrameName, statusCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_DocumentComplete(self: *const T, htmlWindow: *IHTMLWindow2, url: [*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).DocumentComplete(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_DownloadBegin(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).DownloadBegin(@ptrCast(*const IWebApplicationNavigationEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_DownloadComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).DownloadComplete(@ptrCast(*const IWebApplicationNavigationEvents, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebApplicationUIEvents_Value = @import("../zig.zig").Guid.initString("5B2B3F99-328C-41D5-A6F7-7483ED8E71DD");
pub const IID_IWebApplicationUIEvents = &IID_IWebApplicationUIEvents_Value;
pub const IWebApplicationUIEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SecurityProblem: fn(
            self: *const IWebApplicationUIEvents,
            securityProblem: u32,
            result: *HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationUIEvents_SecurityProblem(self: *const T, securityProblem: u32, result: *HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationUIEvents.VTable, self.vtable).SecurityProblem(@ptrCast(*const IWebApplicationUIEvents, self), securityProblem, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebApplicationUpdateEvents_Value = @import("../zig.zig").Guid.initString("3E59E6B7-C652-4DAF-AD5E-16FEB350CDE3");
pub const IID_IWebApplicationUpdateEvents = &IID_IWebApplicationUpdateEvents_Value;
pub const IWebApplicationUpdateEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPaint: fn(
            self: *const IWebApplicationUpdateEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCssChanged: fn(
            self: *const IWebApplicationUpdateEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationUpdateEvents_OnPaint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationUpdateEvents.VTable, self.vtable).OnPaint(@ptrCast(*const IWebApplicationUpdateEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationUpdateEvents_OnCssChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationUpdateEvents.VTable, self.vtable).OnCssChanged(@ptrCast(*const IWebApplicationUpdateEvents, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebApplicationHost_Value = @import("../zig.zig").Guid.initString("CECBD2C3-A3A5-4749-9681-20E9161C6794");
pub const IID_IWebApplicationHost = &IID_IWebApplicationHost_Value;
pub const IWebApplicationHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        get_HWND: fn(
            self: *const IWebApplicationHost,
            hwnd: *HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Document: fn(
            self: *const IWebApplicationHost,
            htmlDocument: **IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IWebApplicationHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IWebApplicationHost,
            interfaceId: *const Guid,
            callback: *IUnknown,
            cookie: *u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IWebApplicationHost,
            cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_get_HWND(self: *const T, hwnd: *HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).get_HWND(@ptrCast(*const IWebApplicationHost, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_get_Document(self: *const T, htmlDocument: **IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).get_Document(@ptrCast(*const IWebApplicationHost, self), htmlDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).Refresh(@ptrCast(*const IWebApplicationHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_Advise(self: *const T, interfaceId: *const Guid, callback: *IUnknown, cookie: *u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).Advise(@ptrCast(*const IWebApplicationHost, self), interfaceId, callback, cookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_Unadvise(self: *const T, cookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).Unadvise(@ptrCast(*const IWebApplicationHost, self), cookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebApplicationActivation_Value = @import("../zig.zig").Guid.initString("BCDCD0DE-330E-481B-B843-4898A6A8EBAC");
pub const IID_IWebApplicationActivation = &IID_IWebApplicationActivation_Value;
pub const IWebApplicationActivation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CancelPendingActivation: fn(
            self: *const IWebApplicationActivation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationActivation_CancelPendingActivation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationActivation.VTable, self.vtable).CancelPendingActivation(@ptrCast(*const IWebApplicationActivation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWebApplicationAuthoringMode_Value = @import("../zig.zig").Guid.initString("720AEA93-1964-4DB0-B005-29EB9E2B18A9");
pub const IID_IWebApplicationAuthoringMode = &IID_IWebApplicationAuthoringMode_Value;
pub const IWebApplicationAuthoringMode = extern struct {
    pub const VTable = extern struct {
        base: IServiceProvider.VTable,
        get_AuthoringClientBinary: fn(
            self: *const IWebApplicationAuthoringMode,
            designModeDllPath: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IServiceProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationAuthoringMode_get_AuthoringClientBinary(self: *const T, designModeDllPath: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationAuthoringMode.VTable, self.vtable).get_AuthoringClientBinary(@ptrCast(*const IWebApplicationAuthoringMode, self), designModeDllPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RegisterAuthoringClientFunctionType = fn(
    authoringModeObject: *IWebApplicationAuthoringMode,
    host: *IWebApplicationHost,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const UnregisterAuthoringClientFunctionType = fn(
    host: *IWebApplicationHost,
) callconv(@import("std").os.windows.WINAPI) HRESULT;


//--------------------------------------------------------------------------------
// Section: Functions (68)
//--------------------------------------------------------------------------------
pub extern "USER32" fn FlashWindow(
    hWnd: HWND,
    bInvert: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn FlashWindowEx(
    pfwi: *FLASHWINFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn MessageBeep(
    uType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "USER32" fn SetLastErrorEx(
    dwErrCode: u32,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn RtlCaptureContext(
    ContextRecord: *CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn RtlUnwind(
    TargetFrame: ?*c_void,
    TargetIp: ?*c_void,
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ReturnValue: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn RtlPcToFileHeader(
    PcValue: *c_void,
    BaseOfImage: **c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn Wow64GetThreadContext(
    hThread: HANDLE,
    lpContext: *WOW64_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn Wow64SetThreadContext(
    hThread: HANDLE,
    lpContext: *const WOW64_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn ReadProcessMemory(
    hProcess: HANDLE,
    lpBaseAddress: *const c_void,
    lpBuffer: [*]u8,
    nSize: ?*c_void,
    lpNumberOfBytesRead: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WriteProcessMemory(
    hProcess: HANDLE,
    lpBaseAddress: *c_void,
    lpBuffer: [*]const u8,
    nSize: ?*c_void,
    lpNumberOfBytesWritten: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn IsDebuggerPresent(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DebugBreak(
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn OutputDebugStringA(
    lpOutputString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn OutputDebugStringW(
    lpOutputString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn ContinueDebugEvent(
    dwProcessId: u32,
    dwThreadId: u32,
    dwContinueStatus: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WaitForDebugEvent(
    lpDebugEvent: *DEBUG_EVENT,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DebugActiveProcess(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DebugActiveProcessStop(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn CheckRemoteDebuggerPresent(
    hProcess: HANDLE,
    pbDebuggerPresent: *BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn WaitForDebugEventEx(
    lpDebugEvent: *DEBUG_EVENT,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn EncodePointer(
    Ptr: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn DecodePointer(
    Ptr: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn EncodeSystemPointer(
    Ptr: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn DecodeSystemPointer(
    Ptr: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "api-ms-win-core-util-l1-1-1" fn EncodeRemotePointer(
    ProcessHandle: HANDLE,
    Ptr: ?*c_void,
    EncodedPtr: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-util-l1-1-1" fn DecodeRemotePointer(
    ProcessHandle: HANDLE,
    Ptr: ?*c_void,
    DecodedPtr: **c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "KERNEL32" fn Beep(
    dwFreq: u32,
    dwDuration: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn RaiseException(
    dwExceptionCode: u32,
    dwExceptionFlags: u32,
    nNumberOfArguments: u32,
    lpArguments: ?[*]const ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn UnhandledExceptionFilter(
    ExceptionInfo: *EXCEPTION_POINTERS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub extern "KERNEL32" fn SetUnhandledExceptionFilter(
    lpTopLevelExceptionFilter: ?LPTOP_LEVEL_EXCEPTION_FILTER,
) callconv(@import("std").os.windows.WINAPI) LPTOP_LEVEL_EXCEPTION_FILTER;

pub extern "KERNEL32" fn GetLastError(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetLastError(
    dwErrCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetErrorMode(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetErrorMode(
    uMode: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn AddVectoredExceptionHandler(
    First: u32,
    Handler: PVECTORED_EXCEPTION_HANDLER,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn RemoveVectoredExceptionHandler(
    Handle: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn AddVectoredContinueHandler(
    First: u32,
    Handler: PVECTORED_EXCEPTION_HANDLER,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn RemoveVectoredContinueHandler(
    Handle: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn RaiseFailFastException(
    pExceptionRecord: ?*EXCEPTION_RECORD,
    pContextRecord: ?*CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn FatalAppExitA(
    uAction: u32,
    lpMessageText: [*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn FatalAppExitW(
    uAction: u32,
    lpMessageText: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetThreadErrorMode(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn SetThreadErrorMode(
    dwNewMode: u32,
    lpOldMode: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-errorhandling-l1-1-3" fn TerminateProcessOnMemoryExhaustion(
    FailedAllocationSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ADVAPI32" fn OpenThreadWaitChainSession(
    Flags: u32,
    callback: ?PWAITCHAINCALLBACK,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "ADVAPI32" fn CloseThreadWaitChainSession(
    WctHandle: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ADVAPI32" fn GetThreadWaitChain(
    WctHandle: *c_void,
    Context: ?*c_void,
    Flags: u32,
    ThreadId: u32,
    NodeCount: *u32,
    NodeInfoArray: [*]WAITCHAIN_NODE_INFO,
    IsCycle: *i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn RegisterWaitChainCOMCallback(
    CallStateCallback: PCOGETCALLSTATE,
    ActivationStateCallback: PCOGETACTIVATIONSTATE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn MiniDumpWriteDump(
    hProcess: HANDLE,
    ProcessId: u32,
    hFile: HANDLE,
    DumpType: MINIDUMP_TYPE,
    ExceptionParam: ?*MINIDUMP_EXCEPTION_INFORMATION,
    UserStreamParam: ?*MINIDUMP_USER_STREAM_INFORMATION,
    CallbackParam: ?*MINIDUMP_CALLBACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn MiniDumpReadDumpStream(
    BaseOfDump: *c_void,
    StreamNumber: u32,
    Dir: ?*?*MINIDUMP_DIRECTORY,
    StreamPointer: ?*?*c_void,
    StreamSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetThreadContext(
    hThread: HANDLE,
    lpContext: *CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetThreadContext(
    hThread: HANDLE,
    lpContext: *const CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FlushInstructionCache(
    hProcess: HANDLE,
    lpBaseAddress: ?[*]const u8,
    dwSize: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FatalExit(
    ExitCode: i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "KERNEL32" fn GetThreadSelectorEntry(
    hThread: HANDLE,
    dwSelector: u32,
    lpSelectorEntry: *LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn Wow64GetThreadSelectorEntry(
    hThread: HANDLE,
    dwSelector: u32,
    lpSelectorEntry: *WOW64_LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DebugSetProcessKillOnExit(
    KillOnExit: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn DebugBreakProcess(
    Process: HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn FormatMessageA(
    dwFlags: FORMAT_MESSAGE_OPTIONS,
    lpSource: ?*const c_void,
    dwMessageId: u32,
    dwLanguageId: u32,
    lpBuffer: PSTR,
    nSize: u32,
    Arguments: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn FormatMessageW(
    dwFlags: FORMAT_MESSAGE_OPTIONS,
    lpSource: ?*const c_void,
    dwMessageId: u32,
    dwLanguageId: u32,
    lpBuffer: PWSTR,
    nSize: u32,
    Arguments: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "KERNEL32" fn CopyContext(
    Destination: *CONTEXT,
    ContextFlags: u32,
    Source: *CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn InitializeContext(
    Buffer: ?[*]u8,
    ContextFlags: u32,
    Context: **CONTEXT,
    ContextLength: *u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetEnabledXStateFeatures(
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "KERNEL32" fn GetXStateFeaturesMask(
    Context: *CONTEXT,
    FeatureMask: *u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn LocateXStateFeature(
    Context: *CONTEXT,
    FeatureId: u32,
    Length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) *c_void;

pub extern "KERNEL32" fn SetXStateFeaturesMask(
    Context: *CONTEXT,
    FeatureMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ntdll" fn RtlNtStatusToDosError(
    Status: NTSTATUS,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (3)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const OutputDebugString = OutputDebugStringA;
        pub const FatalAppExit = FatalAppExitA;
        pub const FormatMessage = FormatMessageA;
    },
    .wide => struct {
        pub const OutputDebugString = OutputDebugStringW;
        pub const FatalAppExit = FatalAppExitW;
        pub const FormatMessage = FormatMessageW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const OutputDebugString = *opaque{};
        pub const FatalAppExit = *opaque{};
        pub const FormatMessage = *opaque{};
    } else struct {
        pub const OutputDebugString = @compileError("'OutputDebugString' requires that UNICODE be set to true or false in the root module");
        pub const FatalAppExit = @compileError("'FatalAppExit' requires that UNICODE be set to true or false in the root module");
        pub const FormatMessage = @compileError("'FormatMessage' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (38)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const VS_FIXEDFILEINFO = @import("menus_and_resources.zig").VS_FIXEDFILEINFO;
const TIME_ZONE_INFORMATION = @import("windows_programming.zig").TIME_ZONE_INFORMATION;
const IDispatch = @import("automation.zig").IDispatch;
const HRGN = @import("gdi.zig").HRGN;
const HDC = @import("gdi.zig").HDC;
const IServiceProvider = @import("system_services.zig").IServiceProvider;
const FORMAT_MESSAGE_OPTIONS = @import("windows_programming.zig").FORMAT_MESSAGE_OPTIONS;
const HRESULT = @import("com.zig").HRESULT;
const NTSTATUS = @import("system_services.zig").NTSTATUS;
const IEnumUnknown = @import("com.zig").IEnumUnknown;
const LOGFONTW = @import("shell.zig").LOGFONTW;
const BOOL = @import("system_services.zig").BOOL;
const DISPPARAMS = @import("automation.zig").DISPPARAMS;
const TYPEDESC = @import("automation.zig").TYPEDESC;
const ILockBytes = @import("structured_storage.zig").ILockBytes;
const CADWORD = @import("com.zig").CADWORD;
const ITypeInfo = @import("automation.zig").ITypeInfo;
const IActiveIMMApp = @import("shell.zig").IActiveIMMApp;
const SAFEARRAY = @import("automation.zig").SAFEARRAY;
const PWSTR = @import("system_services.zig").PWSTR;
const EXCEPINFO = @import("automation.zig").EXCEPINFO;
const IDispatchEx = @import("automation.zig").IDispatchEx;
const IUnknown = @import("com.zig").IUnknown;
const LPTHREAD_START_ROUTINE = @import("system_services.zig").LPTHREAD_START_ROUTINE;
const BSTR = @import("automation.zig").BSTR;
const PSTR = @import("system_services.zig").PSTR;
const CALPOLESTR = @import("com.zig").CALPOLESTR;
const RECT = @import("display_devices.zig").RECT;
const HWND = @import("windows_and_messaging.zig").HWND;
const IMAGE_LOAD_CONFIG_CODE_INTEGRITY = @import("system_services.zig").IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
const DXGI_FORMAT = @import("dxgi.zig").DXGI_FORMAT;
const XSTATE_FEATURE = @import("system_services.zig").XSTATE_FEATURE;
const VARIANT = @import("automation.zig").VARIANT;
const HANDLE = @import("system_services.zig").HANDLE;
const POINT = @import("display_devices.zig").POINT;
const SIZE = @import("display_devices.zig").SIZE;
const FLOATING_SAVE_AREA = @import("system_services.zig").FLOATING_SAVE_AREA;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = PVECTORED_EXCEPTION_HANDLER;
    _ = PTOP_LEVEL_EXCEPTION_FILTER;
    _ = LPTOP_LEVEL_EXCEPTION_FILTER;
    _ = PWAITCHAINCALLBACK;
    _ = PCOGETCALLSTATE;
    _ = PCOGETACTIVATIONSTATE;
    _ = MINIDUMP_CALLBACK_ROUTINE;
    _ = RegisterAuthoringClientFunctionType;
    _ = UnregisterAuthoringClientFunctionType;

    const constant_export_count = 4;
    const type_export_count = 1407;
    const enum_value_export_count = 2275;
    const com_iface_id_export_count = 988;
    const com_class_id_export_count = 295;
    const func_export_count = 68;
    const unicode_alias_count = 3;
    const import_count = 38;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
