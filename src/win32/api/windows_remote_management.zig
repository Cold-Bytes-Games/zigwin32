//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (0)
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// Section: Types (76)
//--------------------------------------------------------------------------------
pub const WSMAN_DATA_TEXT = extern struct {
    bufferLength: u32,
    buffer: [*:0]const u16,
};

pub const WSMAN_DATA_BINARY = extern struct {
    dataLength: u32,
    data: *u8,
};

pub const WSManDataType = extern enum(i32) {
    WSMAN_DATA_NONE = 0,
    WSMAN_DATA_TYPE_TEXT = 1,
    WSMAN_DATA_TYPE_BINARY = 2,
    WSMAN_DATA_TYPE_DWORD = 4,
};
pub const WSMAN_DATA_NONE = WSManDataType.WSMAN_DATA_NONE;
pub const WSMAN_DATA_TYPE_TEXT = WSManDataType.WSMAN_DATA_TYPE_TEXT;
pub const WSMAN_DATA_TYPE_BINARY = WSManDataType.WSMAN_DATA_TYPE_BINARY;
pub const WSMAN_DATA_TYPE_DWORD = WSManDataType.WSMAN_DATA_TYPE_DWORD;

pub const WSMAN_DATA = extern struct {
    type: WSManDataType,
    Anonymous: WSMAN_DATA._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const WSMAN_ERROR = extern struct {
    code: u32,
    errorDetail: [*:0]const u16,
    language: [*:0]const u16,
    machineName: [*:0]const u16,
    pluginName: [*:0]const u16,
};

pub const WSMAN_USERNAME_PASSWORD_CREDS = extern struct {
    username: [*:0]const u16,
    password: [*:0]const u16,
};

pub const WSManAuthenticationFlags = extern enum(i32) {
    WSMAN_FLAG_DEFAULT_AUTHENTICATION = 0,
    WSMAN_FLAG_NO_AUTHENTICATION = 1,
    WSMAN_FLAG_AUTH_DIGEST = 2,
    WSMAN_FLAG_AUTH_NEGOTIATE = 4,
    WSMAN_FLAG_AUTH_BASIC = 8,
    WSMAN_FLAG_AUTH_KERBEROS = 16,
    WSMAN_FLAG_AUTH_CREDSSP = 128,
    WSMAN_FLAG_AUTH_CLIENT_CERTIFICATE = 32,
};
pub const WSMAN_FLAG_DEFAULT_AUTHENTICATION = WSManAuthenticationFlags.WSMAN_FLAG_DEFAULT_AUTHENTICATION;
pub const WSMAN_FLAG_NO_AUTHENTICATION = WSManAuthenticationFlags.WSMAN_FLAG_NO_AUTHENTICATION;
pub const WSMAN_FLAG_AUTH_DIGEST = WSManAuthenticationFlags.WSMAN_FLAG_AUTH_DIGEST;
pub const WSMAN_FLAG_AUTH_NEGOTIATE = WSManAuthenticationFlags.WSMAN_FLAG_AUTH_NEGOTIATE;
pub const WSMAN_FLAG_AUTH_BASIC = WSManAuthenticationFlags.WSMAN_FLAG_AUTH_BASIC;
pub const WSMAN_FLAG_AUTH_KERBEROS = WSManAuthenticationFlags.WSMAN_FLAG_AUTH_KERBEROS;
pub const WSMAN_FLAG_AUTH_CREDSSP = WSManAuthenticationFlags.WSMAN_FLAG_AUTH_CREDSSP;
pub const WSMAN_FLAG_AUTH_CLIENT_CERTIFICATE = WSManAuthenticationFlags.WSMAN_FLAG_AUTH_CLIENT_CERTIFICATE;

pub const WSMAN_AUTHENTICATION_CREDENTIALS = extern struct {
    authenticationMechanism: u32,
    Anonymous: WSMAN_AUTHENTICATION_CREDENTIALS._Anonymous_e__Union,
    const _Anonymous_e__Union = u32; // TODO: generate this nested type!
};

pub const WSMAN_OPTION = extern struct {
    name: [*:0]const u16,
    value: [*:0]const u16,
    mustComply: BOOL,
};

pub const WSMAN_OPTION_SET = extern struct {
    optionsCount: u32,
    options: *WSMAN_OPTION,
    optionsMustUnderstand: BOOL,
};

pub const WSMAN_OPTION_SETEX = extern struct {
    optionsCount: u32,
    options: *WSMAN_OPTION,
    optionsMustUnderstand: BOOL,
    optionTypes: *PWSTR,
};

pub const WSMAN_KEY = extern struct {
    key: [*:0]const u16,
    value: [*:0]const u16,
};

pub const WSMAN_SELECTOR_SET = extern struct {
    numberKeys: u32,
    keys: *WSMAN_KEY,
};

pub const WSMAN_FRAGMENT = extern struct {
    path: [*:0]const u16,
    dialect: [*:0]const u16,
};

pub const WSMAN_FILTER = extern struct {
    filter: [*:0]const u16,
    dialect: [*:0]const u16,
};

pub const WSMAN_OPERATION_INFO = extern struct {
    fragment: WSMAN_FRAGMENT,
    filter: WSMAN_FILTER,
    selectorSet: WSMAN_SELECTOR_SET,
    optionSet: WSMAN_OPTION_SET,
    reserved: *c_void,
    version: u32,
};

pub const WSMAN_OPERATION_INFOEX = extern struct {
    fragment: WSMAN_FRAGMENT,
    filter: WSMAN_FILTER,
    selectorSet: WSMAN_SELECTOR_SET,
    optionSet: WSMAN_OPTION_SETEX,
    version: u32,
    uiLocale: [*:0]const u16,
    dataLocale: [*:0]const u16,
};

pub const WSMAN_API = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const WSManProxyAccessType = extern enum(i32) {
    WSMAN_OPTION_PROXY_IE_PROXY_CONFIG = 1,
    WSMAN_OPTION_PROXY_WINHTTP_PROXY_CONFIG = 2,
    WSMAN_OPTION_PROXY_AUTO_DETECT = 4,
    WSMAN_OPTION_PROXY_NO_PROXY_SERVER = 8,
};
pub const WSMAN_OPTION_PROXY_IE_PROXY_CONFIG = WSManProxyAccessType.WSMAN_OPTION_PROXY_IE_PROXY_CONFIG;
pub const WSMAN_OPTION_PROXY_WINHTTP_PROXY_CONFIG = WSManProxyAccessType.WSMAN_OPTION_PROXY_WINHTTP_PROXY_CONFIG;
pub const WSMAN_OPTION_PROXY_AUTO_DETECT = WSManProxyAccessType.WSMAN_OPTION_PROXY_AUTO_DETECT;
pub const WSMAN_OPTION_PROXY_NO_PROXY_SERVER = WSManProxyAccessType.WSMAN_OPTION_PROXY_NO_PROXY_SERVER;

pub const WSMAN_PROXY_INFO = extern struct {
    accessType: u32,
    authenticationCredentials: WSMAN_AUTHENTICATION_CREDENTIALS,
};

pub const WSMAN_SESSION = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const WSManSessionOption = extern enum(i32) {
    WSMAN_OPTION_DEFAULT_OPERATION_TIMEOUTMS = 1,
    WSMAN_OPTION_MAX_RETRY_TIME = 11,
    WSMAN_OPTION_TIMEOUTMS_CREATE_SHELL = 12,
    WSMAN_OPTION_TIMEOUTMS_RUN_SHELL_COMMAND = 13,
    WSMAN_OPTION_TIMEOUTMS_RECEIVE_SHELL_OUTPUT = 14,
    WSMAN_OPTION_TIMEOUTMS_SEND_SHELL_INPUT = 15,
    WSMAN_OPTION_TIMEOUTMS_SIGNAL_SHELL = 16,
    WSMAN_OPTION_TIMEOUTMS_CLOSE_SHELL = 17,
    WSMAN_OPTION_SKIP_CA_CHECK = 18,
    WSMAN_OPTION_SKIP_CN_CHECK = 19,
    WSMAN_OPTION_UNENCRYPTED_MESSAGES = 20,
    WSMAN_OPTION_UTF16 = 21,
    WSMAN_OPTION_ENABLE_SPN_SERVER_PORT = 22,
    WSMAN_OPTION_MACHINE_ID = 23,
    WSMAN_OPTION_LOCALE = 25,
    WSMAN_OPTION_UI_LANGUAGE = 26,
    WSMAN_OPTION_MAX_ENVELOPE_SIZE_KB = 28,
    WSMAN_OPTION_SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB = 29,
    WSMAN_OPTION_REDIRECT_LOCATION = 30,
    WSMAN_OPTION_SKIP_REVOCATION_CHECK = 31,
    WSMAN_OPTION_ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS = 32,
    WSMAN_OPTION_USE_SSL = 33,
    WSMAN_OPTION_USE_INTEARACTIVE_TOKEN = 34,
};
pub const WSMAN_OPTION_DEFAULT_OPERATION_TIMEOUTMS = WSManSessionOption.WSMAN_OPTION_DEFAULT_OPERATION_TIMEOUTMS;
pub const WSMAN_OPTION_MAX_RETRY_TIME = WSManSessionOption.WSMAN_OPTION_MAX_RETRY_TIME;
pub const WSMAN_OPTION_TIMEOUTMS_CREATE_SHELL = WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_CREATE_SHELL;
pub const WSMAN_OPTION_TIMEOUTMS_RUN_SHELL_COMMAND = WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_RUN_SHELL_COMMAND;
pub const WSMAN_OPTION_TIMEOUTMS_RECEIVE_SHELL_OUTPUT = WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_RECEIVE_SHELL_OUTPUT;
pub const WSMAN_OPTION_TIMEOUTMS_SEND_SHELL_INPUT = WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_SEND_SHELL_INPUT;
pub const WSMAN_OPTION_TIMEOUTMS_SIGNAL_SHELL = WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_SIGNAL_SHELL;
pub const WSMAN_OPTION_TIMEOUTMS_CLOSE_SHELL = WSManSessionOption.WSMAN_OPTION_TIMEOUTMS_CLOSE_SHELL;
pub const WSMAN_OPTION_SKIP_CA_CHECK = WSManSessionOption.WSMAN_OPTION_SKIP_CA_CHECK;
pub const WSMAN_OPTION_SKIP_CN_CHECK = WSManSessionOption.WSMAN_OPTION_SKIP_CN_CHECK;
pub const WSMAN_OPTION_UNENCRYPTED_MESSAGES = WSManSessionOption.WSMAN_OPTION_UNENCRYPTED_MESSAGES;
pub const WSMAN_OPTION_UTF16 = WSManSessionOption.WSMAN_OPTION_UTF16;
pub const WSMAN_OPTION_ENABLE_SPN_SERVER_PORT = WSManSessionOption.WSMAN_OPTION_ENABLE_SPN_SERVER_PORT;
pub const WSMAN_OPTION_MACHINE_ID = WSManSessionOption.WSMAN_OPTION_MACHINE_ID;
pub const WSMAN_OPTION_LOCALE = WSManSessionOption.WSMAN_OPTION_LOCALE;
pub const WSMAN_OPTION_UI_LANGUAGE = WSManSessionOption.WSMAN_OPTION_UI_LANGUAGE;
pub const WSMAN_OPTION_MAX_ENVELOPE_SIZE_KB = WSManSessionOption.WSMAN_OPTION_MAX_ENVELOPE_SIZE_KB;
pub const WSMAN_OPTION_SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB = WSManSessionOption.WSMAN_OPTION_SHELL_MAX_DATA_SIZE_PER_MESSAGE_KB;
pub const WSMAN_OPTION_REDIRECT_LOCATION = WSManSessionOption.WSMAN_OPTION_REDIRECT_LOCATION;
pub const WSMAN_OPTION_SKIP_REVOCATION_CHECK = WSManSessionOption.WSMAN_OPTION_SKIP_REVOCATION_CHECK;
pub const WSMAN_OPTION_ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS = WSManSessionOption.WSMAN_OPTION_ALLOW_NEGOTIATE_IMPLICIT_CREDENTIALS;
pub const WSMAN_OPTION_USE_SSL = WSManSessionOption.WSMAN_OPTION_USE_SSL;
pub const WSMAN_OPTION_USE_INTEARACTIVE_TOKEN = WSManSessionOption.WSMAN_OPTION_USE_INTEARACTIVE_TOKEN;

pub const WSMAN_OPERATION = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const WSManCallbackFlags = extern enum(i32) {
    WSMAN_FLAG_CALLBACK_END_OF_OPERATION = 1,
    WSMAN_FLAG_CALLBACK_END_OF_STREAM = 8,
    WSMAN_FLAG_CALLBACK_SHELL_SUPPORTS_DISCONNECT = 32,
    WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTED = 64,
    WSMAN_FLAG_CALLBACK_NETWORK_FAILURE_DETECTED = 256,
    WSMAN_FLAG_CALLBACK_RETRYING_AFTER_NETWORK_FAILURE = 512,
    WSMAN_FLAG_CALLBACK_RECONNECTED_AFTER_NETWORK_FAILURE = 1024,
    WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTING = 2048,
    WSMAN_FLAG_CALLBACK_RETRY_ABORTED_DUE_TO_INTERNAL_ERROR = 4096,
    WSMAN_FLAG_CALLBACK_RECEIVE_DELAY_STREAM_REQUEST_PROCESSED = 8192,
};
pub const WSMAN_FLAG_CALLBACK_END_OF_OPERATION = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_END_OF_OPERATION;
pub const WSMAN_FLAG_CALLBACK_END_OF_STREAM = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_END_OF_STREAM;
pub const WSMAN_FLAG_CALLBACK_SHELL_SUPPORTS_DISCONNECT = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_SHELL_SUPPORTS_DISCONNECT;
pub const WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTED = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTED;
pub const WSMAN_FLAG_CALLBACK_NETWORK_FAILURE_DETECTED = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_NETWORK_FAILURE_DETECTED;
pub const WSMAN_FLAG_CALLBACK_RETRYING_AFTER_NETWORK_FAILURE = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_RETRYING_AFTER_NETWORK_FAILURE;
pub const WSMAN_FLAG_CALLBACK_RECONNECTED_AFTER_NETWORK_FAILURE = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_RECONNECTED_AFTER_NETWORK_FAILURE;
pub const WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTING = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_SHELL_AUTODISCONNECTING;
pub const WSMAN_FLAG_CALLBACK_RETRY_ABORTED_DUE_TO_INTERNAL_ERROR = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_RETRY_ABORTED_DUE_TO_INTERNAL_ERROR;
pub const WSMAN_FLAG_CALLBACK_RECEIVE_DELAY_STREAM_REQUEST_PROCESSED = WSManCallbackFlags.WSMAN_FLAG_CALLBACK_RECEIVE_DELAY_STREAM_REQUEST_PROCESSED;

pub const WSMAN_SHELL = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const WSMAN_COMMAND = extern struct { comment: [*]const u8 = "TODO: why is this struct empty?" };

pub const WSMAN_STREAM_ID_SET = extern struct {
    streamIDsCount: u32,
    streamIDs: *PWSTR,
};

pub const WSMAN_ENVIRONMENT_VARIABLE = extern struct {
    name: [*:0]const u16,
    value: [*:0]const u16,
};

pub const WSMAN_ENVIRONMENT_VARIABLE_SET = extern struct {
    varsCount: u32,
    vars: *WSMAN_ENVIRONMENT_VARIABLE,
};

pub const WSMAN_SHELL_STARTUP_INFO_V10 = extern struct {
    inputStreamSet: *WSMAN_STREAM_ID_SET,
    outputStreamSet: *WSMAN_STREAM_ID_SET,
    idleTimeoutMs: u32,
    workingDirectory: [*:0]const u16,
    variableSet: *WSMAN_ENVIRONMENT_VARIABLE_SET,
};

pub const WSMAN_SHELL_STARTUP_INFO_V11 = extern struct {
    __AnonymousBase_wsman_L665_C48: WSMAN_SHELL_STARTUP_INFO_V10,
    name: [*:0]const u16,
};

pub const WSMAN_SHELL_DISCONNECT_INFO = extern struct {
    idleTimeoutMs: u32,
};

pub const WSManShellFlag = extern enum(i32) {
    WSMAN_FLAG_NO_COMPRESSION = 1,
    WSMAN_FLAG_DELETE_SERVER_SESSION = 2,
    WSMAN_FLAG_SERVER_BUFFERING_MODE_DROP = 4,
    WSMAN_FLAG_SERVER_BUFFERING_MODE_BLOCK = 8,
    WSMAN_FLAG_RECEIVE_DELAY_OUTPUT_STREAM = 16,
};
pub const WSMAN_FLAG_NO_COMPRESSION = WSManShellFlag.WSMAN_FLAG_NO_COMPRESSION;
pub const WSMAN_FLAG_DELETE_SERVER_SESSION = WSManShellFlag.WSMAN_FLAG_DELETE_SERVER_SESSION;
pub const WSMAN_FLAG_SERVER_BUFFERING_MODE_DROP = WSManShellFlag.WSMAN_FLAG_SERVER_BUFFERING_MODE_DROP;
pub const WSMAN_FLAG_SERVER_BUFFERING_MODE_BLOCK = WSManShellFlag.WSMAN_FLAG_SERVER_BUFFERING_MODE_BLOCK;
pub const WSMAN_FLAG_RECEIVE_DELAY_OUTPUT_STREAM = WSManShellFlag.WSMAN_FLAG_RECEIVE_DELAY_OUTPUT_STREAM;

pub const WSMAN_RECEIVE_DATA_RESULT = extern struct {
    streamId: [*:0]const u16,
    streamData: WSMAN_DATA,
    commandState: [*:0]const u16,
    exitCode: u32,
};

pub const WSMAN_CONNECT_DATA = extern struct {
    data: WSMAN_DATA,
};

pub const WSMAN_CREATE_SHELL_DATA = extern struct {
    data: WSMAN_DATA,
};

pub const WSMAN_RESPONSE_DATA = u32; // TODO: implement StructOrUnion types?

pub const WSMAN_SHELL_COMPLETION_FUNCTION = fn(
    operationContext: ?*c_void,
    flags: u32,
    @"error": *WSMAN_ERROR,
    shell: *WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    operationHandle: ?*WSMAN_OPERATION,
    data: ?*WSMAN_RESPONSE_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_SHELL_ASYNC = extern struct {
    operationContext: *c_void,
    completionFunction: WSMAN_SHELL_COMPLETION_FUNCTION,
};

pub const WSMAN_COMMAND_ARG_SET = extern struct {
    argsCount: u32,
    args: *PWSTR,
};

pub const WSMAN_CERTIFICATE_DETAILS = extern struct {
    subject: [*:0]const u16,
    issuerName: [*:0]const u16,
    issuerThumbprint: [*:0]const u16,
    subjectName: [*:0]const u16,
};

pub const WSMAN_SENDER_DETAILS = extern struct {
    senderName: [*:0]const u16,
    authenticationMechanism: [*:0]const u16,
    certificateDetails: *WSMAN_CERTIFICATE_DETAILS,
    clientToken: HANDLE,
    httpURL: [*:0]const u16,
};

pub const WSMAN_PLUGIN_REQUEST = extern struct {
    senderDetails: *WSMAN_SENDER_DETAILS,
    locale: [*:0]const u16,
    resourceUri: [*:0]const u16,
    operationInfo: *WSMAN_OPERATION_INFO,
    shutdownNotification: i32,
    shutdownNotificationHandle: HANDLE,
    dataLocale: [*:0]const u16,
};

pub const WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT = fn(
    shellContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT = fn(
    shellContext: *c_void,
    commandContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_STARTUP = fn(
    flags: u32,
    applicationIdentification: [*:0]const u16,
    extraInfo: ?[*:0]const u16,
    pluginContext: **c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WSMAN_PLUGIN_SHUTDOWN = fn(
    pluginContext: ?*c_void,
    flags: u32,
    reason: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WSMAN_PLUGIN_SHELL = fn(
    pluginContext: *c_void,
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    startupInfo: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    inboundShellInformation: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_COMMAND = fn(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: *c_void,
    commandLine: [*:0]const u16,
    arguments: ?*WSMAN_COMMAND_ARG_SET,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_SEND = fn(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: *c_void,
    commandContext: ?*c_void,
    stream: [*:0]const u16,
    inboundData: *WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_RECEIVE = fn(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: *c_void,
    commandContext: ?*c_void,
    streamSet: ?*WSMAN_STREAM_ID_SET,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_SIGNAL = fn(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: *c_void,
    commandContext: ?*c_void,
    code: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_CONNECT = fn(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    shellContext: *c_void,
    commandContext: ?*c_void,
    inboundConnectInformation: ?*WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_AUTHZ_QUOTA = extern struct {
    maxAllowedConcurrentShells: u32,
    maxAllowedConcurrentOperations: u32,
    timeslotSize: u32,
    maxAllowedOperationsPerTimeslot: u32,
};

pub const WSMAN_PLUGIN_AUTHORIZE_USER = fn(
    pluginContext: *c_void,
    senderDetails: *WSMAN_SENDER_DETAILS,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_OPERATION = fn(
    pluginContext: *c_void,
    senderDetails: *WSMAN_SENDER_DETAILS,
    flags: u32,
    operation: u32,
    action: [*:0]const u16,
    resourceUri: [*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA = fn(
    pluginContext: *c_void,
    senderDetails: *WSMAN_SENDER_DETAILS,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT = fn(
    userAuthorizationContext: *c_void,
) callconv(@import("std").os.windows.WINAPI) void;

const CLSID_WSMan_Value = @import("../zig.zig").Guid.initString("BCED617B-EC03-420B-8508-977DC7A686BD");
pub const CLSID_WSMan = &CLSID_WSMan_Value;

const CLSID_WSManInternal_Value = @import("../zig.zig").Guid.initString("7DE087A5-5DCB-4DF7-BB12-0924AD8FBD9A");
pub const CLSID_WSManInternal = &CLSID_WSManInternal_Value;

pub const WSManSessionFlags = extern enum(i32) {
    WSManFlagUTF8 = 1,
    WSManFlagCredUsernamePassword = 4096,
    WSManFlagSkipCACheck = 8192,
    WSManFlagSkipCNCheck = 16384,
    WSManFlagUseNoAuthentication = 32768,
    WSManFlagUseDigest = 65536,
    WSManFlagUseNegotiate = 131072,
    WSManFlagUseBasic = 262144,
    WSManFlagUseKerberos = 524288,
    WSManFlagNoEncryption = 1048576,
    WSManFlagUseClientCertificate = 2097152,
    WSManFlagEnableSPNServerPort = 4194304,
    WSManFlagUTF16 = 8388608,
    WSManFlagUseCredSsp = 16777216,
    WSManFlagSkipRevocationCheck = 33554432,
    WSManFlagAllowNegotiateImplicitCredentials = 67108864,
    WSManFlagUseSsl = 134217728,
};
pub const WSManFlagUTF8 = WSManSessionFlags.WSManFlagUTF8;
pub const WSManFlagCredUsernamePassword = WSManSessionFlags.WSManFlagCredUsernamePassword;
pub const WSManFlagSkipCACheck = WSManSessionFlags.WSManFlagSkipCACheck;
pub const WSManFlagSkipCNCheck = WSManSessionFlags.WSManFlagSkipCNCheck;
pub const WSManFlagUseNoAuthentication = WSManSessionFlags.WSManFlagUseNoAuthentication;
pub const WSManFlagUseDigest = WSManSessionFlags.WSManFlagUseDigest;
pub const WSManFlagUseNegotiate = WSManSessionFlags.WSManFlagUseNegotiate;
pub const WSManFlagUseBasic = WSManSessionFlags.WSManFlagUseBasic;
pub const WSManFlagUseKerberos = WSManSessionFlags.WSManFlagUseKerberos;
pub const WSManFlagNoEncryption = WSManSessionFlags.WSManFlagNoEncryption;
pub const WSManFlagUseClientCertificate = WSManSessionFlags.WSManFlagUseClientCertificate;
pub const WSManFlagEnableSPNServerPort = WSManSessionFlags.WSManFlagEnableSPNServerPort;
pub const WSManFlagUTF16 = WSManSessionFlags.WSManFlagUTF16;
pub const WSManFlagUseCredSsp = WSManSessionFlags.WSManFlagUseCredSsp;
pub const WSManFlagSkipRevocationCheck = WSManSessionFlags.WSManFlagSkipRevocationCheck;
pub const WSManFlagAllowNegotiateImplicitCredentials = WSManSessionFlags.WSManFlagAllowNegotiateImplicitCredentials;
pub const WSManFlagUseSsl = WSManSessionFlags.WSManFlagUseSsl;

pub const WSManEnumFlags = extern enum(i32) {
    WSManFlagNonXmlText = 1,
    WSManFlagReturnObject = 0,
    WSManFlagReturnEPR = 2,
    WSManFlagReturnObjectAndEPR = 4,
    WSManFlagHierarchyDeep = 0,
    WSManFlagHierarchyShallow = 32,
    WSManFlagHierarchyDeepBasePropsOnly = 64,
    WSManFlagAssociatedInstance = 0,
    WSManFlagAssociationInstance = 128,
};
pub const WSManFlagNonXmlText = WSManEnumFlags.WSManFlagNonXmlText;
pub const WSManFlagReturnObject = WSManEnumFlags.WSManFlagReturnObject;
pub const WSManFlagReturnEPR = WSManEnumFlags.WSManFlagReturnEPR;
pub const WSManFlagReturnObjectAndEPR = WSManEnumFlags.WSManFlagReturnObjectAndEPR;
pub const WSManFlagHierarchyDeep = WSManEnumFlags.WSManFlagHierarchyDeep;
pub const WSManFlagHierarchyShallow = WSManEnumFlags.WSManFlagHierarchyShallow;
pub const WSManFlagHierarchyDeepBasePropsOnly = WSManEnumFlags.WSManFlagHierarchyDeepBasePropsOnly;
pub const WSManFlagAssociatedInstance = WSManEnumFlags.WSManFlagAssociatedInstance;
pub const WSManFlagAssociationInstance = WSManEnumFlags.WSManFlagAssociationInstance;

pub const WSManProxyAccessTypeFlags = extern enum(i32) {
    WSManProxyIEConfig = 1,
    WSManProxyWinHttpConfig = 2,
    WSManProxyAutoDetect = 4,
    WSManProxyNoProxyServer = 8,
};
pub const WSManProxyIEConfig = WSManProxyAccessTypeFlags.WSManProxyIEConfig;
pub const WSManProxyWinHttpConfig = WSManProxyAccessTypeFlags.WSManProxyWinHttpConfig;
pub const WSManProxyAutoDetect = WSManProxyAccessTypeFlags.WSManProxyAutoDetect;
pub const WSManProxyNoProxyServer = WSManProxyAccessTypeFlags.WSManProxyNoProxyServer;

pub const WSManProxyAuthenticationFlags = extern enum(i32) {
    WSManFlagProxyAuthenticationUseNegotiate = 1,
    WSManFlagProxyAuthenticationUseBasic = 2,
    WSManFlagProxyAuthenticationUseDigest = 4,
};
pub const WSManFlagProxyAuthenticationUseNegotiate = WSManProxyAuthenticationFlags.WSManFlagProxyAuthenticationUseNegotiate;
pub const WSManFlagProxyAuthenticationUseBasic = WSManProxyAuthenticationFlags.WSManFlagProxyAuthenticationUseBasic;
pub const WSManFlagProxyAuthenticationUseDigest = WSManProxyAuthenticationFlags.WSManFlagProxyAuthenticationUseDigest;

const IID_IWSMan_Value = @import("../zig.zig").Guid.initString("190D8637-5CD3-496D-AD24-69636BB5A3B5");
pub const IID_IWSMan = &IID_IWSMan_Value;
pub const IWSMan = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        CreateSession: fn(
            self: *const IWSMan,
            connection: BSTR,
            flags: i32,
            connectionOptions: *IDispatch,
            session: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateConnectionOptions: fn(
            self: *const IWSMan,
            connectionOptions: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_CommandLine: fn(
            self: *const IWSMan,
            value: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Error: fn(
            self: *const IWSMan,
            value: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSMan_CreateSession(self: *const T, connection: BSTR, flags: i32, connectionOptions: *IDispatch, session: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSMan.VTable, self.vtable).CreateSession(@ptrCast(*const IWSMan, self), connection, flags, connectionOptions, session);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSMan_CreateConnectionOptions(self: *const T, connectionOptions: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSMan.VTable, self.vtable).CreateConnectionOptions(@ptrCast(*const IWSMan, self), connectionOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSMan_get_CommandLine(self: *const T, value: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSMan.VTable, self.vtable).get_CommandLine(@ptrCast(*const IWSMan, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSMan_get_Error(self: *const T, value: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSMan.VTable, self.vtable).get_Error(@ptrCast(*const IWSMan, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManEx_Value = @import("../zig.zig").Guid.initString("2D53BDAA-798E-49E6-A1AA-74D01256F411");
pub const IID_IWSManEx = &IID_IWSManEx_Value;
pub const IWSManEx = extern struct {
    pub const VTable = extern struct {
        base: IWSMan.VTable,
        CreateResourceLocator: fn(
            self: *const IWSManEx,
            strResourceLocator: BSTR,
            newResourceLocator: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUTF8: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagCredUsernamePassword: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipCACheck: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipCNCheck: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseDigest: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseNegotiate: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseBasic: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseKerberos: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagNoEncryption: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagEnableSPNServerPort: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseNoAuthentication: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagNonXmlText: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnEPR: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnObjectAndEPR: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetErrorMessage: fn(
            self: *const IWSManEx,
            errorNumber: u32,
            errorMessage: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyDeep: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyShallow: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagHierarchyDeepBasePropsOnly: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagReturnObject: fn(
            self: *const IWSManEx,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSMan.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_CreateResourceLocator(self: *const T, strResourceLocator: BSTR, newResourceLocator: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).CreateResourceLocator(@ptrCast(*const IWSManEx, self), strResourceLocator, newResourceLocator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUTF8(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUTF8(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagCredUsernamePassword(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagCredUsernamePassword(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagSkipCACheck(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagSkipCACheck(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagSkipCNCheck(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagSkipCNCheck(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseDigest(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseDigest(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseNegotiate(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseNegotiate(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseBasic(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseBasic(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseKerberos(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseKerberos(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagNoEncryption(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagNoEncryption(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagEnableSPNServerPort(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagEnableSPNServerPort(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_SessionFlagUseNoAuthentication(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).SessionFlagUseNoAuthentication(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagNonXmlText(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagNonXmlText(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagReturnEPR(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagReturnEPR(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagReturnObjectAndEPR(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagReturnObjectAndEPR(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_GetErrorMessage(self: *const T, errorNumber: u32, errorMessage: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).GetErrorMessage(@ptrCast(*const IWSManEx, self), errorNumber, errorMessage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagHierarchyDeep(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagHierarchyDeep(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagHierarchyShallow(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagHierarchyShallow(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagHierarchyDeepBasePropsOnly(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagHierarchyDeepBasePropsOnly(@ptrCast(*const IWSManEx, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx_EnumerationFlagReturnObject(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx.VTable, self.vtable).EnumerationFlagReturnObject(@ptrCast(*const IWSManEx, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManEx2_Value = @import("../zig.zig").Guid.initString("1D1B5AE0-42D9-4021-8261-3987619512E9");
pub const IID_IWSManEx2 = &IID_IWSManEx2_Value;
pub const IWSManEx2 = extern struct {
    pub const VTable = extern struct {
        base: IWSManEx.VTable,
        SessionFlagUseClientCertificate: fn(
            self: *const IWSManEx2,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSManEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx2_SessionFlagUseClientCertificate(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx2.VTable, self.vtable).SessionFlagUseClientCertificate(@ptrCast(*const IWSManEx2, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManEx3_Value = @import("../zig.zig").Guid.initString("6400E966-011D-4EAC-8474-049E0848AFAD");
pub const IID_IWSManEx3 = &IID_IWSManEx3_Value;
pub const IWSManEx3 = extern struct {
    pub const VTable = extern struct {
        base: IWSManEx2.VTable,
        SessionFlagUTF16: fn(
            self: *const IWSManEx3,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseCredSsp: fn(
            self: *const IWSManEx3,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagAssociationInstance: fn(
            self: *const IWSManEx3,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerationFlagAssociatedInstance: fn(
            self: *const IWSManEx3,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagSkipRevocationCheck: fn(
            self: *const IWSManEx3,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagAllowNegotiateImplicitCredentials: fn(
            self: *const IWSManEx3,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionFlagUseSsl: fn(
            self: *const IWSManEx3,
            flags: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSManEx2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagUTF16(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagUTF16(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagUseCredSsp(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagUseCredSsp(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_EnumerationFlagAssociationInstance(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).EnumerationFlagAssociationInstance(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_EnumerationFlagAssociatedInstance(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).EnumerationFlagAssociatedInstance(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagSkipRevocationCheck(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagSkipRevocationCheck(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagAllowNegotiateImplicitCredentials(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagAllowNegotiateImplicitCredentials(@ptrCast(*const IWSManEx3, self), flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEx3_SessionFlagUseSsl(self: *const T, flags: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEx3.VTable, self.vtable).SessionFlagUseSsl(@ptrCast(*const IWSManEx3, self), flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManConnectionOptions_Value = @import("../zig.zig").Guid.initString("F704E861-9E52-464F-B786-DA5EB2320FDD");
pub const IID_IWSManConnectionOptions = &IID_IWSManConnectionOptions_Value;
pub const IWSManConnectionOptions = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        get_UserName: fn(
            self: *const IWSManConnectionOptions,
            name: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_UserName: fn(
            self: *const IWSManConnectionOptions,
            name: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Password: fn(
            self: *const IWSManConnectionOptions,
            password: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptions_get_UserName(self: *const T, name: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptions.VTable, self.vtable).get_UserName(@ptrCast(*const IWSManConnectionOptions, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptions_put_UserName(self: *const T, name: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptions.VTable, self.vtable).put_UserName(@ptrCast(*const IWSManConnectionOptions, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptions_put_Password(self: *const T, password: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptions.VTable, self.vtable).put_Password(@ptrCast(*const IWSManConnectionOptions, self), password);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManConnectionOptionsEx_Value = @import("../zig.zig").Guid.initString("EF43EDF7-2A48-4D93-9526-8BD6AB6D4A6B");
pub const IID_IWSManConnectionOptionsEx = &IID_IWSManConnectionOptionsEx_Value;
pub const IWSManConnectionOptionsEx = extern struct {
    pub const VTable = extern struct {
        base: IWSManConnectionOptions.VTable,
        get_CertificateThumbprint: fn(
            self: *const IWSManConnectionOptionsEx,
            thumbprint: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_CertificateThumbprint: fn(
            self: *const IWSManConnectionOptionsEx,
            thumbprint: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSManConnectionOptions.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx_get_CertificateThumbprint(self: *const T, thumbprint: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx.VTable, self.vtable).get_CertificateThumbprint(@ptrCast(*const IWSManConnectionOptionsEx, self), thumbprint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx_put_CertificateThumbprint(self: *const T, thumbprint: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx.VTable, self.vtable).put_CertificateThumbprint(@ptrCast(*const IWSManConnectionOptionsEx, self), thumbprint);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManConnectionOptionsEx2_Value = @import("../zig.zig").Guid.initString("F500C9EC-24EE-48AB-B38D-FC9A164C658E");
pub const IID_IWSManConnectionOptionsEx2 = &IID_IWSManConnectionOptionsEx2_Value;
pub const IWSManConnectionOptionsEx2 = extern struct {
    pub const VTable = extern struct {
        base: IWSManConnectionOptionsEx.VTable,
        SetProxy: fn(
            self: *const IWSManConnectionOptionsEx2,
            accessType: i32,
            authenticationMechanism: i32,
            userName: BSTR,
            password: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyIEConfig: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyWinHttpConfig: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAutoDetect: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyNoProxyServer: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseNegotiate: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseBasic: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ProxyAuthenticationUseDigest: fn(
            self: *const IWSManConnectionOptionsEx2,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IWSManConnectionOptionsEx.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_SetProxy(self: *const T, accessType: i32, authenticationMechanism: i32, userName: BSTR, password: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).SetProxy(@ptrCast(*const IWSManConnectionOptionsEx2, self), accessType, authenticationMechanism, userName, password);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyIEConfig(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyIEConfig(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyWinHttpConfig(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyWinHttpConfig(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyAutoDetect(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyAutoDetect(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyNoProxyServer(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyNoProxyServer(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyAuthenticationUseNegotiate(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyAuthenticationUseNegotiate(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyAuthenticationUseBasic(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyAuthenticationUseBasic(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManConnectionOptionsEx2_ProxyAuthenticationUseDigest(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManConnectionOptionsEx2.VTable, self.vtable).ProxyAuthenticationUseDigest(@ptrCast(*const IWSManConnectionOptionsEx2, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManSession_Value = @import("../zig.zig").Guid.initString("FC84FC58-1286-40C4-9DA0-C8EF6EC241E0");
pub const IID_IWSManSession = &IID_IWSManSession_Value;
pub const IWSManSession = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        Get: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            flags: i32,
            resource: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Put: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            resource: BSTR,
            flags: i32,
            resultResource: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Create: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            resource: BSTR,
            flags: i32,
            newUri: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Delete: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            flags: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Invoke: fn(
            self: *const IWSManSession,
            actionUri: BSTR,
            resourceUri: VARIANT,
            parameters: BSTR,
            flags: i32,
            result: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Enumerate: fn(
            self: *const IWSManSession,
            resourceUri: VARIANT,
            filter: BSTR,
            dialect: BSTR,
            flags: i32,
            resultSet: **IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Identify: fn(
            self: *const IWSManSession,
            flags: i32,
            result: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Error: fn(
            self: *const IWSManSession,
            value: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_BatchItems: fn(
            self: *const IWSManSession,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_BatchItems: fn(
            self: *const IWSManSession,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Timeout: fn(
            self: *const IWSManSession,
            value: *i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_Timeout: fn(
            self: *const IWSManSession,
            value: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Get(self: *const T, resourceUri: VARIANT, flags: i32, resource: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Get(@ptrCast(*const IWSManSession, self), resourceUri, flags, resource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Put(self: *const T, resourceUri: VARIANT, resource: BSTR, flags: i32, resultResource: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Put(@ptrCast(*const IWSManSession, self), resourceUri, resource, flags, resultResource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Create(self: *const T, resourceUri: VARIANT, resource: BSTR, flags: i32, newUri: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Create(@ptrCast(*const IWSManSession, self), resourceUri, resource, flags, newUri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Delete(self: *const T, resourceUri: VARIANT, flags: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Delete(@ptrCast(*const IWSManSession, self), resourceUri, flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Invoke(self: *const T, actionUri: BSTR, resourceUri: VARIANT, parameters: BSTR, flags: i32, result: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Invoke(@ptrCast(*const IWSManSession, self), actionUri, resourceUri, parameters, flags, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Enumerate(self: *const T, resourceUri: VARIANT, filter: BSTR, dialect: BSTR, flags: i32, resultSet: **IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Enumerate(@ptrCast(*const IWSManSession, self), resourceUri, filter, dialect, flags, resultSet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_Identify(self: *const T, flags: i32, result: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).Identify(@ptrCast(*const IWSManSession, self), flags, result);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_get_Error(self: *const T, value: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).get_Error(@ptrCast(*const IWSManSession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_get_BatchItems(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).get_BatchItems(@ptrCast(*const IWSManSession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_put_BatchItems(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).put_BatchItems(@ptrCast(*const IWSManSession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_get_Timeout(self: *const T, value: *i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).get_Timeout(@ptrCast(*const IWSManSession, self), value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManSession_put_Timeout(self: *const T, value: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManSession.VTable, self.vtable).put_Timeout(@ptrCast(*const IWSManSession, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManEnumerator_Value = @import("../zig.zig").Guid.initString("F3457CA9-ABB9-4FA5-B850-90E8CA300E7F");
pub const IID_IWSManEnumerator = &IID_IWSManEnumerator_Value;
pub const IWSManEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ReadItem: fn(
            self: *const IWSManEnumerator,
            resource: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_AtEndOfStream: fn(
            self: *const IWSManEnumerator,
            eos: *i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Error: fn(
            self: *const IWSManEnumerator,
            value: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEnumerator_ReadItem(self: *const T, resource: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEnumerator.VTable, self.vtable).ReadItem(@ptrCast(*const IWSManEnumerator, self), resource);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEnumerator_get_AtEndOfStream(self: *const T, eos: *i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEnumerator.VTable, self.vtable).get_AtEndOfStream(@ptrCast(*const IWSManEnumerator, self), eos);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManEnumerator_get_Error(self: *const T, value: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManEnumerator.VTable, self.vtable).get_Error(@ptrCast(*const IWSManEnumerator, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManResourceLocator_Value = @import("../zig.zig").Guid.initString("A7A1BA28-DE41-466A-AD0A-C4059EAD7428");
pub const IID_IWSManResourceLocator = &IID_IWSManResourceLocator_Value;
pub const IWSManResourceLocator = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        put_ResourceURI: fn(
            self: *const IWSManResourceLocator,
            uri: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_ResourceURI: fn(
            self: *const IWSManResourceLocator,
            uri: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSelector: fn(
            self: *const IWSManResourceLocator,
            resourceSelName: BSTR,
            selValue: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearSelectors: fn(
            self: *const IWSManResourceLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FragmentPath: fn(
            self: *const IWSManResourceLocator,
            text: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_FragmentPath: fn(
            self: *const IWSManResourceLocator,
            text: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_FragmentDialect: fn(
            self: *const IWSManResourceLocator,
            text: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_FragmentDialect: fn(
            self: *const IWSManResourceLocator,
            text: BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddOption: fn(
            self: *const IWSManResourceLocator,
            OptionName: BSTR,
            OptionValue: VARIANT,
            mustComply: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        put_MustUnderstandOptions: fn(
            self: *const IWSManResourceLocator,
            mustUnderstand: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_MustUnderstandOptions: fn(
            self: *const IWSManResourceLocator,
            mustUnderstand: *BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearOptions: fn(
            self: *const IWSManResourceLocator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        get_Error: fn(
            self: *const IWSManResourceLocator,
            value: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_put_ResourceURI(self: *const T, uri: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).put_ResourceURI(@ptrCast(*const IWSManResourceLocator, self), uri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_ResourceURI(self: *const T, uri: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_ResourceURI(@ptrCast(*const IWSManResourceLocator, self), uri);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_AddSelector(self: *const T, resourceSelName: BSTR, selValue: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).AddSelector(@ptrCast(*const IWSManResourceLocator, self), resourceSelName, selValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_ClearSelectors(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).ClearSelectors(@ptrCast(*const IWSManResourceLocator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_FragmentPath(self: *const T, text: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_FragmentPath(@ptrCast(*const IWSManResourceLocator, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_put_FragmentPath(self: *const T, text: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).put_FragmentPath(@ptrCast(*const IWSManResourceLocator, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_FragmentDialect(self: *const T, text: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_FragmentDialect(@ptrCast(*const IWSManResourceLocator, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_put_FragmentDialect(self: *const T, text: BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).put_FragmentDialect(@ptrCast(*const IWSManResourceLocator, self), text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_AddOption(self: *const T, OptionName: BSTR, OptionValue: VARIANT, mustComply: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).AddOption(@ptrCast(*const IWSManResourceLocator, self), OptionName, OptionValue, mustComply);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_put_MustUnderstandOptions(self: *const T, mustUnderstand: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).put_MustUnderstandOptions(@ptrCast(*const IWSManResourceLocator, self), mustUnderstand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_MustUnderstandOptions(self: *const T, mustUnderstand: *BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_MustUnderstandOptions(@ptrCast(*const IWSManResourceLocator, self), mustUnderstand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_ClearOptions(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).ClearOptions(@ptrCast(*const IWSManResourceLocator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManResourceLocator_get_Error(self: *const T, value: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManResourceLocator.VTable, self.vtable).get_Error(@ptrCast(*const IWSManResourceLocator, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManResourceLocatorInternal_Value = @import("../zig.zig").Guid.initString("EFFAEAD7-7EC8-4716-B9BE-F2E7E9FB4ADB");
pub const IID_IWSManResourceLocatorInternal = &IID_IWSManResourceLocatorInternal_Value;
pub const IWSManResourceLocatorInternal = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IWSManInternal_Value = @import("../zig.zig").Guid.initString("04AE2B1D-9954-4D99-94A9-A961E72C3A13");
pub const IID_IWSManInternal = &IID_IWSManInternal_Value;
pub const IWSManInternal = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        ConfigSDDL: fn(
            self: *const IWSManInternal,
            session: *IDispatch,
            resourceUri: VARIANT,
            flags: i32,
            resource: *BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWSManInternal_ConfigSDDL(self: *const T, session: *IDispatch, resourceUri: VARIANT, flags: i32, resource: *BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWSManInternal.VTable, self.vtable).ConfigSDDL(@ptrCast(*const IWSManInternal, self), session, resourceUri, flags, resource);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};


//--------------------------------------------------------------------------------
// Section: Functions (33)
//--------------------------------------------------------------------------------
pub extern "WsmSvc" fn WSManInitialize(
    flags: u32,
    apiHandle: **WSMAN_API,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManDeinitialize(
    apiHandle: ?*WSMAN_API,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManGetErrorMessage(
    apiHandle: *WSMAN_API,
    flags: u32,
    languageCode: ?[*:0]const u16,
    errorCode: u32,
    messageLength: u32,
    message: ?[*:0]u16,
    messageLengthUsed: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManCreateSession(
    apiHandle: *WSMAN_API,
    connection: ?[*:0]const u16,
    flags: u32,
    serverAuthenticationCredentials: ?*WSMAN_AUTHENTICATION_CREDENTIALS,
    proxyInfo: ?*WSMAN_PROXY_INFO,
    session: **WSMAN_SESSION,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManCloseSession(
    session: ?*WSMAN_SESSION,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManSetSessionOption(
    session: *WSMAN_SESSION,
    option: WSManSessionOption,
    data: *WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManGetSessionOptionAsDword(
    session: *WSMAN_SESSION,
    option: WSManSessionOption,
    value: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManGetSessionOptionAsString(
    session: *WSMAN_SESSION,
    option: WSManSessionOption,
    stringLength: u32,
    string: ?[*:0]u16,
    stringLengthUsed: *u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManCloseOperation(
    operationHandle: ?*WSMAN_OPERATION,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManCreateShell(
    session: *WSMAN_SESSION,
    flags: u32,
    resourceUri: [*:0]const u16,
    startupInfo: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    options: ?*WSMAN_OPTION_SET,
    createXml: ?*WSMAN_DATA,
    @"async": *WSMAN_SHELL_ASYNC,
    shell: **WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManRunShellCommand(
    shell: *WSMAN_SHELL,
    flags: u32,
    commandLine: [*:0]const u16,
    args: ?*WSMAN_COMMAND_ARG_SET,
    options: ?*WSMAN_OPTION_SET,
    @"async": *WSMAN_SHELL_ASYNC,
    command: **WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManSignalShell(
    shell: *WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    code: [*:0]const u16,
    @"async": *WSMAN_SHELL_ASYNC,
    signalOperation: **WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManReceiveShellOutput(
    shell: *WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    desiredStreamSet: ?*WSMAN_STREAM_ID_SET,
    @"async": *WSMAN_SHELL_ASYNC,
    receiveOperation: **WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManSendShellInput(
    shell: *WSMAN_SHELL,
    command: ?*WSMAN_COMMAND,
    flags: u32,
    streamId: [*:0]const u16,
    streamData: *WSMAN_DATA,
    endOfStream: BOOL,
    @"async": *WSMAN_SHELL_ASYNC,
    sendOperation: **WSMAN_OPERATION,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManCloseCommand(
    commandHandle: ?*WSMAN_COMMAND,
    flags: u32,
    @"async": *WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManCloseShell(
    shellHandle: ?*WSMAN_SHELL,
    flags: u32,
    @"async": *WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManCreateShellEx(
    session: *WSMAN_SESSION,
    flags: u32,
    resourceUri: [*:0]const u16,
    shellId: [*:0]const u16,
    startupInfo: ?*WSMAN_SHELL_STARTUP_INFO_V11,
    options: ?*WSMAN_OPTION_SET,
    createXml: ?*WSMAN_DATA,
    @"async": *WSMAN_SHELL_ASYNC,
    shell: **WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManRunShellCommandEx(
    shell: *WSMAN_SHELL,
    flags: u32,
    commandId: [*:0]const u16,
    commandLine: [*:0]const u16,
    args: ?*WSMAN_COMMAND_ARG_SET,
    options: ?*WSMAN_OPTION_SET,
    @"async": *WSMAN_SHELL_ASYNC,
    command: **WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManDisconnectShell(
    shell: *WSMAN_SHELL,
    flags: u32,
    disconnectInfo: *WSMAN_SHELL_DISCONNECT_INFO,
    @"async": *WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManReconnectShell(
    shell: *WSMAN_SHELL,
    flags: u32,
    @"async": *WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManReconnectShellCommand(
    commandHandle: *WSMAN_COMMAND,
    flags: u32,
    @"async": *WSMAN_SHELL_ASYNC,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManConnectShell(
    session: *WSMAN_SESSION,
    flags: u32,
    resourceUri: [*:0]const u16,
    shellID: [*:0]const u16,
    options: ?*WSMAN_OPTION_SET,
    connectXml: ?*WSMAN_DATA,
    @"async": *WSMAN_SHELL_ASYNC,
    shell: **WSMAN_SHELL,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManConnectShellCommand(
    shell: *WSMAN_SHELL,
    flags: u32,
    commandID: [*:0]const u16,
    options: ?*WSMAN_OPTION_SET,
    connectXml: ?*WSMAN_DATA,
    @"async": *WSMAN_SHELL_ASYNC,
    command: **WSMAN_COMMAND,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "WsmSvc" fn WSManPluginReportContext(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    context: *c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginReceiveResult(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    stream: ?[*:0]const u16,
    streamResult: ?*WSMAN_DATA,
    commandState: ?[*:0]const u16,
    exitCode: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginOperationComplete(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    errorCode: u32,
    extendedInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginGetOperationParameters(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
    flags: u32,
    data: *WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginGetConfiguration(
    pluginContext: *c_void,
    flags: u32,
    data: *WSMAN_DATA,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginReportCompletion(
    pluginContext: *c_void,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginFreeRequestDetails(
    requestDetails: *WSMAN_PLUGIN_REQUEST,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginAuthzUserComplete(
    senderDetails: *WSMAN_SENDER_DETAILS,
    flags: u32,
    userAuthorizationContext: ?*c_void,
    impersonationToken: HANDLE,
    userIsAdministrator: BOOL,
    errorCode: u32,
    extendedErrorInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginAuthzOperationComplete(
    senderDetails: *WSMAN_SENDER_DETAILS,
    flags: u32,
    userAuthorizationContext: ?*c_void,
    errorCode: u32,
    extendedErrorInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "WsmSvc" fn WSManPluginAuthzQueryQuotaComplete(
    senderDetails: *WSMAN_SENDER_DETAILS,
    flags: u32,
    quota: ?*WSMAN_AUTHZ_QUOTA,
    errorCode: u32,
    extendedErrorInformation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (0)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
    },
    .wide => struct {
    },
    .unspecified => if (@import("builtin").is_test) struct {
    } else struct {
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (8)
//--------------------------------------------------------------------------------
const IDispatch = @import("automation.zig").IDispatch;
const PWSTR = @import("system_services.zig").PWSTR;
const VARIANT = @import("automation.zig").VARIANT;
const IUnknown = @import("com.zig").IUnknown;
const HRESULT = @import("com.zig").HRESULT;
const HANDLE = @import("system_services.zig").HANDLE;
const BSTR = @import("automation.zig").BSTR;
const BOOL = @import("system_services.zig").BOOL;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    _ = WSMAN_SHELL_COMPLETION_FUNCTION;
    _ = WSMAN_PLUGIN_RELEASE_SHELL_CONTEXT;
    _ = WSMAN_PLUGIN_RELEASE_COMMAND_CONTEXT;
    _ = WSMAN_PLUGIN_STARTUP;
    _ = WSMAN_PLUGIN_SHUTDOWN;
    _ = WSMAN_PLUGIN_SHELL;
    _ = WSMAN_PLUGIN_COMMAND;
    _ = WSMAN_PLUGIN_SEND;
    _ = WSMAN_PLUGIN_RECEIVE;
    _ = WSMAN_PLUGIN_SIGNAL;
    _ = WSMAN_PLUGIN_CONNECT;
    _ = WSMAN_PLUGIN_AUTHORIZE_USER;
    _ = WSMAN_PLUGIN_AUTHORIZE_OPERATION;
    _ = WSMAN_PLUGIN_AUTHORIZE_QUERY_QUOTA;
    _ = WSMAN_PLUGIN_AUTHORIZE_RELEASE_CONTEXT;

    const constant_export_count = 0;
    const type_export_count = 74;
    const enum_value_export_count = 87;
    const com_iface_id_export_count = 12;
    const com_class_id_export_count = 2;
    const func_export_count = 33;
    const unicode_alias_count = 0;
    const import_count = 8;
    @setEvalBranchQuota(
        constant_export_count +
        type_export_count +
        enum_value_export_count +
        com_iface_id_export_count * 2 + // * 2 for value and ptr
        com_class_id_export_count * 2 + // * 2 for value and ptr
        func_export_count +
        unicode_alias_count +
        import_count +
        2 // TODO: why do I need these extra 2?
    );
    @import("std").testing.refAllDecls(@This());
}
